#!/usr/bin/env python

# Copyright (c) 2014 SpinPunch. All rights reserved.
# Use of this source code is governed by an MIT-style license that can be
# found in the LICENSE file.

# automatically generate tech_mods.json from tech.json

import SpinConfig
import SpinJSON
import AtomicFileWrite
import sys, re, traceback, os, getopt

if __name__ == '__main__':
    opts, args = getopt.gnu_getopt(sys.argv[1:], 'g:', ['game-id=',])
    ident = str(os.getpid())

    game_id = None
    for key, val in opts:
        if key == '--game-id' or key == '-g':
            game_id = val
    assert game_id

    if game_id != 'mf': # no mods except in old MF
        sys.exit(0)

    tech = SpinConfig.load(args[0], stripped = True)
    out_fd = AtomicFileWrite.AtomicFileWrite(args[1], 'w', ident=ident)

    print >>out_fd.fd, "// AUTO-GENERATED BY make_tech_mods.py"

    out = {}

    MOD_TYPES = [{'name': '_health', 'ui_name': ' Health', 'stat': 'max_hp', 'method':'*=(1+strength)', 'strength': [0.01, 0.02, 0.03, 0.04, 0.05],
                  'ui_description': 'Optimize defensive systems to withstand more damage',
                  'ui_congrats': 'Defensive systems upgraded for more toughness' },
                 {'name': '_damage', 'ui_name': ' Damage', 'stat': 'weapon_damage','method':'*=(1+strength)', 'strength': [0.01, 0.02, 0.03, 0.04, 0.05],
                  'ui_description': 'Optimize weapon systems to deal more damage',
                  'ui_congrats': 'Weapon systems upgraded for more damage and accuracy' },
                 {'name': '_armor', 'ui_name': ' Armor', 'stat': 'armor', 'method': '+=strength', 'strength': [1, 2, 3, 4, 5],
                  'ui_description': 'Strengthen armor plating to reduce damage taken when hit',
                  'ui_congrats': 'Armor plating added for stronger defense against enemy fire'}]

    # cost/time of level 1 mod corresponds to this level of the original unit tech
    LEVEL_SHIFT = 3

    # minimum unit tech level required to unlock level 1 mod
    LEVEL_REQ = 8

    for name, data in tech.iteritems():
        if 'associated_unit' not in data: continue
        assert '_production' in name

        for TYPE in MOD_TYPES:
            mod_levels = len(TYPE['strength'])

            mod_name = name.replace('_production', TYPE['name'])
            mod = { 'name': mod_name,
                    'ui_name': data['ui_name'] + TYPE['ui_name'],
                    'ui_description': TYPE['ui_description'],
                    'ui_congrats': TYPE['ui_congrats'],
                    'icon': 'inventory_unknown',
                    'research_category': data['research_category'],

                    'affects_unit': data['associated_unit'],
                    'effects': [{'code':'modstat', 'stat': TYPE['stat'], 'method': TYPE['method'], 'strength': TYPE['strength']}],

                    'cost_water': data['cost_water'][LEVEL_SHIFT:LEVEL_SHIFT+mod_levels],
                    'cost_iron': data['cost_iron'][LEVEL_SHIFT:LEVEL_SHIFT+mod_levels],
                    'research_credit_cost': data['research_credit_cost'][LEVEL_SHIFT:LEVEL_SHIFT+mod_levels],
                    'research_time': data['research_time'][LEVEL_SHIFT:LEVEL_SHIFT+mod_levels],
                    'activation': { "predicate": "ALWAYS_FALSE" }, # obsolete
                    'requires': { "predicate": "ALWAYS_FALSE" }, # obsolete
#                    'activation': { "predicate": "ANY_ABTEST", "key": "enable_mod_techs", "value": 1, "default": 0 },
#                    'requires': [{"predicate": "TECH_LEVEL", "tech": name, "min_level": min(max(level+LEVEL_REQ,1),8)} \
#                                 for level in xrange(mod_levels)],
                    }
            out[mod_name] = mod

    count = 0
    for name, data in out.iteritems():
        print >>out_fd.fd, '"%s":' % name, SpinJSON.dumps(data, pretty=True),
        if count != len(out)-1:
            print >>out_fd.fd, ','
        else:
            print >>out_fd.fd
        count += 1
    out_fd.complete()
