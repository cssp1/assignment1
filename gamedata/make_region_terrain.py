#!/usr/bin/env python

# Copyright (c) 2015 SpinPunch Studios. All rights reserved.
# Use of this source code is governed by an MIT-style license that can be
# found in the LICENSE file.

# convert ASCII C array containing image data to JSON regional map terrain

import sys

# input image is 8-bit gray (MF) or 24-bit RGB (TR)
# "classify" each pixel into one of the possible map tiles (territory_tiles.json array indices) by
# looking for least-squares difference across color components

TILES = { 'mf': {'tile0': {'col': [0.0/8.0], 'val': 0 },
                 'tile1': {'col': [1.0/8.0], 'val': 1 },
                 'tile2': {'col': [2.0/8.0], 'val': 2 },
                 'tile3': {'col': [3.0/8.0], 'val': 3 },
                 'tile4': {'col': [4.0/8.0], 'val': 4 },
                 'tile5': {'col': [5.0/8.0], 'val': 5 },
                 'tile6': {'col': [6.0/8.0], 'val': 6 },
                 'tile7': {'col': [7.0/8.0], 'val': 7 },
                 },
          'mf2': {'waterA': {'col': [0,0,0], 'val': 0 },
                  'cityA': {'col': [0,0,0.4], 'val': 1 },
                  'cityB': {'col': [0,0,0.6], 'val': 2 },
                  'cityC': {'col': [0,0,0.9], 'val': 3 },
                  'mountainA': {'col': [0.33,0,0], 'val': 4 },
                  'mountainB': {'col': [0.66,0,0], 'val': 5 },
                  'jungleA': {'col': [0,0.4,0], 'val': 6 },
                  'jungleB': {'col': [0,0.6,0], 'val': 7 },
                  'jungleC': {'col': [0,0.9,0], 'val': 8 },
                  'marsA': {'col': [0.4,0.4,0], 'val': 9 },
                  'marsB': {'col': [0.6,0.6,0], 'val': 10 },
                  'marsC': {'col': [0.8,0.8,0], 'val': 11 },
                 },
          'tr': {'waterA': {'col': [0,0,0], 'val': 0 },
                 'desertA': {'col': [0.2,0.2,0], 'val': 1 },
                 'desertB': {'col': [0.4,0.4,0], 'val': 2 },
                 'desertC': {'col': [0.5,0.5,0], 'val': 3 },
                 'desertD': {'col': [0.6,0.6,0], 'val': 4 },
                 'desertE': {'col': [0.8,0.8,0], 'val': 5 },
                 'mountainA': {'col': [0.33,0,0], 'val': 6 },
                 'mountainB': {'col': [0.5,0,0], 'val': 7 },
                 'mountainC': {'col': [0.66,0,0], 'val': 8 },
                 'grassA': {'col': [0,0.4,0], 'val': 9 },
                 'grassB': {'col': [0,0.6,0], 'val': 10 },
                 'grassC': {'col': [0,1.0,0], 'val': 11 },
                 },
          'dv': {'waterA': {'col': [0,0,0], 'val': 0 },
                 'desertA': {'col': [0.2,0.2,0], 'val': 1 },
                 'desertB': {'col': [0.4,0.4,0], 'val': 2 },
                 'desertC': {'col': [0.5,0.5,0], 'val': 3 },
                 'desertD': {'col': [0.6,0.6,0], 'val': 4 },
                 'desertE': {'col': [0.8,0.8,0], 'val': 5 },
                 'mountainA': {'col': [0.33,0,0], 'val': 6 },
                 'mountainB': {'col': [0.5,0,0], 'val': 7 },
                 'mountainC': {'col': [0.66,0,0], 'val': 8 },
                 'grassA': {'col': [0,0.4,0], 'val': 9 },
                 'grassB': {'col': [0,0.6,0], 'val': 10 },
                 'grassC': {'col': [0,1.0,0], 'val': 11 },
                 },
          'sg': {'waterA': {'col': [0,0,0], 'val': 0 },
                 'desertA': {'col': [0.2,0.2,0], 'val': 1 },
                 'desertB': {'col': [0.4,0.4,0], 'val': 2 },
                 'desertC': {'col': [0.5,0.5,0], 'val': 3 },
                 'desertD': {'col': [0.6,0.6,0], 'val': 4 },
                 'desertE': {'col': [0.8,0.8,0], 'val': 5 },
                 'mountainA': {'col': [0.33,0,0], 'val': 6 },
                 'mountainB': {'col': [0.5,0,0], 'val': 7 },
                 'mountainC': {'col': [0.66,0,0], 'val': 8 },
                 'grassA': {'col': [0,0.4,0], 'val': 9 },
                 'grassB': {'col': [0,0.6,0], 'val': 10 },
                 'grassC': {'col': [0,1.0,0], 'val': 11 },
                 },
          }

def classify(val, tiles, verbose = False):
    match = None
    match_diff = 999
    for name, data in tiles.iteritems():
        diff = 0.0
        for c in xrange(len(data['col'])):
            linear = float(val[c])/255.0
            diff += (linear-data['col'][c])*(linear-data['col'][c])
        if diff < match_diff:
            match_diff = diff
            match = data
        if verbose:
            print >>sys.stderr, val, diff, data
    if verbose:
        print >>sys.stderr, 'FINAL', match['val']
    return match['val']
#    block = 256/levels
#    return min(max(int(round((1.0*(val[0]))/block)), 0), levels-1)

if __name__ == '__main__':
    if len(sys.argv) < 5:
        sys.stderr.write("usage: %s INPUT.C XRES YRES GAME_ID\n" % sys.argv[0])
        sys.exit(1)

    print "// AUTO-GENERATED BY", ' '.join(sys.argv)
    fd = open(sys.argv[1])
    out = sys.stdout

    wh = [int(sys.argv[2]),int(sys.argv[3])]
    game_id = sys.argv[4]
    channels = len(TILES[game_id][TILES[game_id].keys()[0]]['col'])

    buf = []

    # skip 3-line header
    for i in xrange(3): fd.readline()

    for line in fd.xreadlines():
        line = line.strip()
        if line == '};': break
        line = line.split(',')[:-1]
        vals = map(int, line)
        assert len(vals) == wh[0]*channels
        buf += vals

    assert len(buf) == wh[0]*wh[1]*channels
    tiles = [0]*(wh[0]*wh[1])
    for y in xrange(wh[1]):
        for x in xrange(wh[0]):
            if channels == 1:
                i = y*wh[0]+x
                pixel = (buf[i],)
            elif channels == 3:
                # bottom-up BGR
                i = ((wh[1]-y-1)*wh[0]+x)*channels
                pixel = (buf[i+2],buf[i+1],buf[i+0])
            tiles[y*wh[0]+x] = classify(pixel, TILES[game_id]) # , verbose = (y==44))

    out.write('"')
    # in the future, we should use better compression here
    # with 8 levels, we can encode one tile in 3 bits, or pack two tiles per 7-bit char
    for i in xrange(0,len(tiles),1):
#        assert tiles[i] >= 0 and tiles[i] < levels
        val = tiles[i] + ord('A') # |(buf[i+1]<<3)
        out.write('%c' % val)
#        if i != 0: out.write(',')
#        out.write('%s' % val)
    out.write('"\n')
