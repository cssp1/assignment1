goog.provide('SPINPUNCHGAME');

// Copyright (c) 2015 Battlehouse Inc. All rights reserved.
// Use of this source code is governed by an MIT-style license that can be
// found in the LICENSE file.

/** @fileoverview
    @suppress {reportUnknownTypes} XXX we are not typesafe yet
*/

goog.require('goog.object');
goog.require('goog.array');
goog.require('goog.string');
goog.require('goog.net.XhrIo');
goog.require('goog.net.ErrorCode');
goog.require('goog.crypt.base64');
goog.require('goog.Uri');
goog.require('Iuppiter');
goog.require('lz4');
goog.require('SPGzip');

goog.require('AStar');
goog.require('ModChain');
goog.require('Predicates');
goog.require('Consequents');
goog.require('PlayerCache');
goog.require('AllianceCache');
goog.require('Backdrop');
goog.require('BattleLog');
goog.require('RaidBattleLog');
goog.require('BattleReplay');
goog.require('BattleReplayGUI');
goog.require('ChatFilter');
goog.require('Congrats');
goog.require('GameArt');
goog.require('GameTypes');
goog.require('GameObjectCollection');
goog.require('Session');
goog.require('SPUI');
goog.require('SPText');
goog.require('SPHTTP');
goog.require('SPFX');
goog.require('SPFB');
goog.require('SPKongregate');
goog.require('SPArmorGames');
goog.require('Screenshot');
goog.require('FBShare');
goog.require('FBUploadPhoto');
goog.require('FBInviteFriends');
goog.require('FBSendRequests');
goog.require('AGSendRequests');
goog.require('BHInvites');
goog.require('SPClockRace');
goog.require('SPay');
goog.require('SProbe');
goog.require('SPWebsocket');
goog.require('SPVideoWidget');
goog.require('ItemDisplay');
goog.require('Leaderboard');
goog.require('UpgradeHelp');
goog.require('Dripper');
goog.require('Bounce');
goog.require('CombatEngine');
goog.require('Showcase');
goog.require('PlayerInfoDialog');
goog.require('SquadControlDialog');
goog.require('SquadManageDialog');
goog.require('MountedWeaponDialog');
goog.require('ObstacleDialog');
goog.require('QuestBar');
goog.require('UpgradeBar');
goog.require('Base');
goog.require('Region');
goog.require('RegionMapReplay');
goog.require('RegionMap');
goog.require('RegionMapIndex');
goog.require('TeamMapAccelerator');
goog.require('VoxelMapAccelerator');
goog.require('buzz');
goog.require('Traceback');
goog.require('Citizens');

/** @param {?} x
    @return {?} */
function deepcopy(x) {
    if(x === undefined) {
        throw Error('attempt to deepcopy() undefined');
    } else if(x === null) {
        return null;
    } else if(x instanceof Array) {
        return deepcopy_array(x);
    } else if(typeof(x) === 'object') {
        return deepcopy_obj(x);
    } else {
        return x;
    };
}
/** @param {!Object} obj
    @return {!Object} */
function deepcopy_obj(obj) {
    var ret = {};
    for(var k in obj) {
        ret[k] = deepcopy(obj[k]);
    }
    return ret;
};
/** @param {!Array} x
    @return {!Array} */
function deepcopy_array(x) {
    var ret = Array(x.length);
    for(var i = 0; i < x.length; i++) {
        ret[i] = deepcopy(x[i]);
    }
    return ret;
};

/** @param {!Object} x
    @param {!Object} y
    @return {boolean} */
function deepequal_obj(x, y) {
    for(var kx in x) {
        if(!(kx in y) || !deepequal(x[kx], y[kx])) {
            return false;
        }
    }
    for(var ky in y) {
        if(!(ky in x)) { return false;}
    }
    return true;
};
/** @param {!Array} x
    @param {!Array} y
    @return {boolean} */
function deepequal_array(x, y) {
    if(x.length !== y.length) { return false; }
    for(var i = 0; i < x.length; i++) {
        if(!deepequal(x[i], y[i])) { return false; }
    }
    return true;
};
/** @param {?} x
    @param {?} y
    @return {boolean} */
function deepequal(x,y) {
    if((x && !y) || (!x && y)) { return false; }
    if(x === undefined || y === undefined) {
        throw Error('attempt to deepequal() undefined');
    } else if(x === null) {
        return y === null;
    } else if(x instanceof Array) {
        if(!(y instanceof Array)) { throw Error('deepequal() of Array and non-Array'); }
        return deepequal_array(x, y);
    } else if(typeof(x) === 'object') {
        if(typeof(y) !== 'object') { throw Error('deepequal() of Object and non-Object'); }
        return deepequal_obj(x, y);
    } else {
        return x === y;
    };
}

/** truncate floating-point value for leaner JSON.stringify() serialization
    @param {number} val
    @param {number} prec
    @return {number} */
function serialize_number(val, prec) {
    return +val.toFixed(prec);
}
/** @param {!Array<number>} v
    @return {!Array<number>} */
function vec_serialize(v) {
    return [serialize_number(v[0], 1), serialize_number(v[1], 1)];
}

// detect whether browser has touch-screen events
var touch_modes = {
    NONE : 0,
    TOUCHEVENT : 1,
    MSPOINTER: 2
}
var touch_mode = touch_modes.NONE;

if(typeof Touch === 'object' || typeof Touch === 'function') {
    touch_mode = touch_modes.TOUCHEVENT;
} else if(window.navigator['msPointerEnabled'] && window.navigator['msMaxTouchPoints'] > 1) {
    // be conservative here and only enable MSPointer on multi-touch hardware
    // in the future MSPointer could replace mouse input on IE10+
    touch_mode = touch_modes.MSPOINTER;
}

// for iOS: <meta name="viewport" content="width=device-width, initial-scale=0.5, user-scalable=no"/>
// but need canvas scaling

//
// function library
//

// for debug message printing use console.log()
if(!window.console) { window.console = /** @type {!Console} */ ({}); };
if(!window.console.log) { window.console.log = function(){}; };

function get_query_string(name) {
    var query = window.location.search;
    var start = query.indexOf(name+'=');
    if(start == -1) { return null; }
    start += name.length+1;
    var end = query.indexOf('&', start);
    if(end == -1) { end = query.length; }
    return unescape(query.substring(start, end));
};

function chrome_version_atleast(min_big, min_major, min_minor, min_release) {
    var ua = navigator.userAgent;
    var m = ua.match(new RegExp('Chrome/([0-9]+).([0-9]+).([0-9]+).([0-9]+)'));
    if(m) {
        var big = parseInt(m[1],10), major = parseInt(m[2],10), minor = parseInt(m[3],10), release = parseInt(m[4],10);
        if(big < min_big) {
            return false;
        } else if(big > min_big) {
            return true;
        } else {
            if(major < min_major) {
                return false;
            } else if(major > min_major) {
                return true;
            } else {
                if(minor < min_minor) {
                    return false;
                } else if(minor > min_minor) {
                    return true;
                } else {
                    return (release >= min_release);
                }
            }
        }
    }
    return false;
};

function clamp(x,a,b) {
    if(x < a)
        return a;
    if(x > b)
        return b;
    return x;
}

function log10(x) { return Math.log(x)/Math.log(10.0); }

/** @param {!Array.<number>} v
    @return {!Array.<number>} */
function vec_copy(v) { return [v[0], v[1]]; }

/** @param {!Array.<number>} v
    @param {!Array.<number>} w
    @return {!Array.<number>} */
function vec_add(v, w) {
    return [v[0]+w[0],v[1]+w[1]];
}
/** @param {!Array.<number>} v
    @param {!Array.<number>} w
    @return {!Array.<number>} */
function vec_mul(v, w) {
    return [v[0]*w[0], v[1]*w[1]];
}
function vec_div(v, w) {
    return [v[0]/w[0], v[1]/w[1]];
}
function vec_max(v, w) { return [Math.max(v[0],w[0]), Math.max(v[1],w[1])]; }

/** @param {!Array.<number>} v
    @return {!Array.<number>} */
function vec_floor(v) { return [Math.floor(v[0]), Math.floor(v[1])]; }

function vec_mod(v, n) { return [v[0]%n, v[1]%n]; }

/** @param {!Array.<number>} v
    @param {!Array.<number>} w
    @return {!Array.<number>} */
function v3_add(v, w) { return [v[0]+w[0], v[1]+w[1], v[2]+w[2]]; }

/** @param {!Array.<number>} v
    @param {!Array.<number>} w
    @return {!Array.<number>} */
function v3_sub(v, w) { return [v[0]-w[0], v[1]-w[1], v[2]-w[2]]; }

/** @param {!Array.<number>} v
    @param {!Array.<number>} w
    @return {!Array.<number>} */
function vec_sub(v, w) {
    return [v[0]-w[0],v[1]-w[1]];
}

/** @param {number} s
    @param {!Array.<number>} v
    @return {!Array.<number>} */
function vec_scale(s, v) {
    return [s*v[0],s*v[1]];
}
/** a + x*(b-a)
    @param {!Array.<number>} a
    @param {!Array.<number>} b
    @param {number} x
    @return {!Array.<number>} */
function vec_lerp(a, b, x) {
    return vec_add(a, vec_scale(x, vec_sub(b, a)));
}
/** @param {number} a
    @param {number} b
    @param {number} x
    @return {number} */
function lerp(a, b, x) {
    return a + x*(b-a);
}

/** @param {number} s
    @param {!Array.<number>} v
    @return {!Array.<number>} */
function v3_scale(s, v) { return [s*v[0], s*v[1], s*v[2]]; }

/** @param {!Array.<number>} v
    @return {number} */
function v3_length(v) { return Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); }

/** @param {!Array.<number>} a
    @param {!Array.<number>} b
    @return {number} */
function v3_distance(a, b) {
    var dx = b[0] - a[0], dy = b[1] - a[1], dz = b[2] - a[2];
    return Math.sqrt(dx*dx + dy*dy + dz*dz);
}
/** V + s * W
    @param {!Array.<number>} v
    @param {number} s
    @param {!Array.<number>} w
    @return {!Array.<number>} */
function v3_mad(v, s, w) { return [v[0]+s*w[0], v[1]+s*w[1], v[2]+s*w[2]]; }

/** @param {!Array.<number>} v
    @param {!Array.<number>} w
    @return {!Array.<number>} */
function v3_mul(v, w) { return [v[0]*w[0], v[1]*w[1], v[2]*w[2]]; }

function v3_normalized(v) {
    var len = v3_length(v);
    if(len > 0) {
        return [v[0]/len, v[1]/len, v[2]/len];
    } else {
        return [0,1,0];
    }
}

function v3_rotate_by_facing(facing, v) {
    // facing=0 means looking east, convert that so that angle=0 when facing north
    var angle = facing + 0.5*Math.PI;
    var c = Math.cos(angle), s = Math.sin(angle);
    var x =  c*v[0]-s*v[2];
    var z =  s*v[0]+c*v[2];
    return [x,v[1],z];
}

/** V + s * W
    @param {!Array.<number>} v
    @param {number} s
    @param {!Array.<number>} w
    @return {!Array.<number>} */
function vec_mad(v, s, w) { return [v[0]+s*w[0], v[1]+s*w[1]]; }

/** @param {!Array.<number>} a
    @param {!Array.<number>} b
    @return {number} */
function vec_dot(a,b) { return a[0]*b[0]+a[1]*b[1]; }

/** @param {!Array.<number>} v
    @return {number} */
function vec_length2(v) { return v[0]*v[0]+v[1]*v[1]; }

/** @param {!Array.<number>} v
    @return {number} */
function vec_length(v) { return Math.sqrt(v[0]*v[0]+v[1]*v[1]); }

/** @param {!Array.<number>} a
    @param {!Array.<number>} b
    @return {number} */
function vec_distance(a, b) {
    var dx = b[0] - a[0], dy = b[1] - a[1];
    return Math.sqrt(dx*dx + dy*dy);
}

function vec_normalized(v) {
    var len = vec_length(v);
    return [v[0]/len, v[1]/len];
}

/** @const */
var POSITION_EPSILON = 0.01;
/** @const */
var ANGLE_EPSILON = 0.001;

/** @param {!Array.<number>} v
    @param {!Array.<number>} w
    @return {boolean} */
function vec_equals(v, w) {
    var delta = vec_sub(v,w);
    if((delta[0]*delta[0]+delta[1]*delta[1]) < POSITION_EPSILON*POSITION_EPSILON) {
        return true;
    } else {
        return false;
    }
}

/** @param {!Array.<number>} v
    @param {!Array.<number>} w
    @return {boolean} */
function vec_equals_integer(v, w) {
    if(Math.floor(v[0]) == Math.floor(w[0]) &&
       Math.floor(v[1]) == Math.floor(w[1])) {
        return true;
    }
    return false;
}

/** @param {!Array.<!Array.<number>>} ls
    @return {!Array.<!Array.<number>>} */
function vec_list_reversed(ls) {
    return ls.reverse();
}

/** @param {!Array.<number>} v
    @return {string} */
function vec_print(v) { return v[0].toString()+','+v[1].toString(); };

/** Constrain radian angle to be in the range [0, 2*PI]
    @param {number} a
    @return {number} */
function normalize_angle(a) {
    if(isNaN(a)) { throw Error('normalize_angle(NaN)'); }
    if(a < 0) {
        return (a % (2*Math.PI)) + 2*Math.PI;
    } else if(a >= 2*Math.PI) {
        return a % (2*Math.PI);
    } else {
        return a;
    }
};

function hex_slanted(a) {
    // transform to "slanted" coordinate system for easier distance computation
    var new_x = a[0] - Math.floor(a[1]/2);
    return [new_x, a[1]];
}
function hex_distance(a,b) {
    var a2 = hex_slanted(a), b2 = hex_slanted(b);
    var dx = b2[0]-a2[0], dy = b2[1]-a2[1];
    var dd = dx + dy;
    //console.log('dx '+dx+' dy '+dy+' dd '+dd);
    return Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dd));
}

// convert a floating-point number of seconds into a string like '10d 4h 5m 10s'
// 'limit' limits how many "words" are in the result
var time_unit_table = {
    'd': 'Day', 'h': 'Hour', 'm': 'Min', 's': 'Sec'
};

function do_pretty_print_time_unit(qty, abbrev, spell_it) {
    if(spell_it) {
        var u = time_unit_table[abbrev];
        // note: don't pluralize "Mins" or "Secs", it looks awkward
        if(qty != 1 && (abbrev != 'm') && (abbrev != 's')) {
            u = (u + 's');
        }
        return qty.toString() + ' ' + u;
    } else {
        return qty.toString() + abbrev;
    }
};

function do_pretty_print_time(sec, limit, spell_units) {
    if(sec < 1) { // includes negative
        return '0';
    }

    var ret = [];
    var show_seconds = true;

    if(sec >= (24*60*60)) {
        var days = Math.floor(sec/(24*60*60));
        ret.push(do_pretty_print_time_unit(days, 'd', spell_units));
        sec -= days * (24*60*60);
        show_seconds = (limit >= 4);
    }
    if(sec >= (60*60)) {
        var hours = Math.floor(sec/(60*60));
        ret.push(do_pretty_print_time_unit(hours, 'h', spell_units));
        sec -= hours * (60*60);
    }
    if(sec >= 60) {
        var mins = Math.floor(sec/60);
        ret.push(do_pretty_print_time_unit(mins, 'm', spell_units));
        sec -= mins * 60;
    }
    if(sec >= 1 && show_seconds) {
        var secs = Math.floor(sec);
        ret.push(do_pretty_print_time_unit(secs, 's', spell_units));
    }
    ret = ret.slice(0, limit);
    return ret.join(spell_units ? ', ' : ' ');
}

function pretty_print_time(sec) {
    return do_pretty_print_time(sec, 10, false);
}
function pretty_print_time_brief(sec) {
    return do_pretty_print_time(sec, 2, false);
}
function pretty_print_time_very_brief(sec) {
    return do_pretty_print_time(sec, 1, false);
}

// turns a UNIX timestamp into a string like "2013 Dec 9"
function pretty_print_date_utc(ts) {
    var d = new Date(ts*1000);
    return d.getUTCFullYear().toString()+' '+gamedata['strings']['months_short'][d.getUTCMonth()]+' '+d.getUTCDate().toString();
}
function pretty_print_date_local(ts) {
    var d = new Date(ts*1000);
    return d.getFullYear().toString()+' '+gamedata['strings']['months_short'][d.getMonth()]+' '+d.getDate().toString();
}

// "2013 Dec 9 01:23" *UTC*
function pretty_print_date_and_time_utc(ts) {
    var dt = ts % 86400;
    var hours = Math.floor(dt/3600);
    var minutes = Math.floor(dt/60) % 60;
    return pretty_print_date_utc(ts) + ' ' + pad_with_zeros(hours.toFixed(0), 2)+':'+pad_with_zeros(minutes.toFixed(0), 2);
}

// pad a string with zeros until it is length 'n'
function pad_with_zeros(s, n) {
    var ret = s;
    while(ret.length < n) {
        ret = '0' + ret;
    }
    return ret;
}

/** uses decimal points and rounds down (useful for displaying resources that the player has or will be rewarded)
    @param {number} n
    @return {string}
*/
function pretty_print_qty_brief(n) {
    if(n >= 10000000) { // 10m+: 1 digit after the decimal, e.g. "18.5m"
        var d = n/1000000, rem = n % 1000000;
        return d.toFixed(rem == 0 ? 0 : 1)+'m';
    } else if(n >= 1000000) { // 1-10m: 2 digits after the decimal, e.g. "1.85m"
        var d = n/1000000, rem = n % 1000000;
        return d.toFixed(rem == 0 ? 0 : 2)+'m';
    } else if(n >= 1000) {
        var d = n/1000, rem = n % 1000;
        return d.toFixed(rem == 0 ? 0 : 1)+'k';
    } else {
        return n.toFixed(0);
    }
}

/** print a number in the form xxx,xxx,xxx
    @param {number} n
    @return {string} */
function pretty_print_number(n) {
    var sign;
    if(n < 0) {
        sign = '-';
        n = -n;
    } else {
        sign = '';
    }
    var ret = [];

    while(n >= 1) {
        var term = Math.floor(n % 1000);
        n = Math.floor(n/1000);
        var s = term.toFixed(0);
        if(n >= 1) {
            s = pad_with_zeros(s,3);
        }
        ret.push(s);
    }

    // special case for 0
    if(ret.length === 0) { ret.push('0'); }

    return sign + ret.reverse().join(',');
}

function reverse_digits(n) {
    if(n <= 0) { return '0'; }
    n = Math.ceil(n);
    var ret = '';
    while(n > 0) {
        ret += (n%10).toString();
        n = Math.floor(n/10);
    }
    return ret;
}

/** Return human-readable "diff" between two versions of a JSON structure
    @param {?} a
    @param {?} b
    @param {string=} prefix
    @return {string|null} */
function json_diff(a, b, prefix) {
    if(!prefix) { prefix = ''; }
    var retlist = [];
    if(a instanceof Array) {
        if(!(b instanceof Array)) { throw Error('type mismatch'); }
        if(a.length != b.length) {
            retlist.push(prefix+' array length change');
        } else {
            for(var i = 0; i < a.length; i++) {
                var subdiff = json_diff(a[i], b[i], prefix+'/'+i.toString());
                if(subdiff) {
                    retlist.push(subdiff);
                }
            }
        }
    } else if(typeof(a) === 'object' && a !== null) {
        if(typeof(b) !== 'object') { throw Error('type mismatch'); }
        for(var ka in a) {
            if(!(ka in b)) {
                retlist.push(prefix+'/'+ka+' property disappeared');
            } else {
                var subdiff = json_diff(a[ka], b[ka], prefix+'/'+ka);
                if(subdiff) {
                    retlist.push(subdiff);
                }
            }
        }
        for(var kb in b) {
            if(!(kb in a)) {
                retlist.push(prefix+'/'+kb+' new property');
            }
        }
    } else if(a === null || typeof(a) === 'number' || typeof(a) === 'string' || typeof(a) === 'boolean') {
        if(b !== null && a !== null && typeof(b) !== typeof(a)) { throw Error('type mismatch'); }
        if(a != b) {
            retlist.push(prefix+' '+(a === null ? 'null' : a.toString())+' -> '+(b === null ? 'null' : b.toString()));
        }
    } else {
        throw Error('unhandled value '+JSON.stringify(a));
    }
    return (retlist.length >= 1 ? retlist.join('\n') : null);
};

function current_pvp_week() {
    return Math.floor((player.get_absolute_time() - gamedata['matchmaking']['week_origin'])/(7*24*60*60));
}

function current_pvp_season() {
    var t = player.get_absolute_time();
    var seasons = gamedata['matchmaking']['season_starts'];
    for(var i = 0; i < seasons.length; i++) {
        if(seasons[i] > t) {
            return i;
        }
    }
    return seasons.length;
}


/** @return {boolean}
    Check if we are running in "mobile standalone" mode, which is
    where we're in a mobile browser, but permanently (sort of)
    full-screened by the OS.
*/
function is_browser_standalone_mode() {
    // for iOS
    if('standalone' in window.navigator && window.navigator['standalone']) { return true; }
    // for Chrome
    if('matchMedia' in window && window['matchMedia']('(display-mode: standalone)')['matches']) { return true; }
    if(get_query_string('standalone') === '1') { return true; }
    return false;
}

// only works after init()
function has_true_fullscreen() {
    if(!(canvas_div['SPINrequestFullScreen'] && document['SPINcancelFullScreen'])) { return false; }
    if(get_query_string('truefullscreen') === '1') { return true; }
    if(is_browser_standalone_mode()) { return false; } // bh.com frame is already "fullscreen", so disable in-app fullscreen
    return read_predicate(gamedata['client']['truefullscreen']).is_satisfied(player,null);
}

function toggle_true_fullscreen() {
    if(canvas_is_fullscreen) {
        document['SPINcancelFullScreen']();
        window.top.postMessage({'method': 'bh_electron_command', 'type':'APP_COMMAND', 'command':'CANCEL_FULLSCREEN'}, '*');
    } else {
        if(player.record_feature_use('truefullscreen')) {
            metric_event('6501_fullscreen_engaged', add_demographics({}));
        }

        if(player.tutorial_state != "COMPLETE") {
            player.record_feature_use('truefullscreen_during_tutorial');
        }
        canvas_div['SPINrequestFullScreen']();
        window.top.postMessage({'method': 'bh_electron_command', 'type':'APP_COMMAND', 'command':'ACTIVATE_FULLSCREEN'}, '*');
    }
}

/** @return {boolean}
    Check for situations where we want to encourage the player to enable fullscreen mode at EVERY login */
function auto_fullscreen_prompt_enabled() {
    if('ignore_fullscreen_prompt' in player.preferences && player.preferences['ignore_fullscreen_prompt']) {
        return false; // disabled by player preference
    }

    if(spin_frame_platform !== 'bh') { return false; } // only on bh.com for now
    if(!has_true_fullscreen()) { return false; }

    // check for Android devices. Note, this should not apply to ChromeOS Chromebooks,
    // and should not apply in browser standalone mode (where has_true_fullscreen() will return false above)
    if(spin_demographics['browser_OS'] === "Android") {
        return true;
    }

    return false;
}

function friend_invites_enabled() {
    return read_predicate(gamedata['client']['friend_invites_enabled']).is_satisfied(player, null);
}

// globals

// if true, obscure real names of player and friends
var anon_mode = false;
var ANON_NAME = 'John Smithson', ANON_NAME2 = 'Smith Johnson';

var LOTS_OF_METRICS = false;

// global state of game client
var client_states = {
    LOADING : 0,
    RUNNING : 1,
    UNABLE_TO_LOGIN: 2,
    TIMED_OUT: 3
};
var client_state = client_states.LOADING;

// state of GameArt downloads
var client_art_states = {
    DOWNLOADING_ESSENTIAL : 0,
    DOWNLOADING_ALL : 1,
    DONE : 2
};
var client_art_state = client_art_states.DOWNLOADING_ESSENTIAL;

// handles to the HTML5 div, canvas, and drawing context

/** @type {HTMLDivElement|null} */
var canvas_div = null;
/** @type {HTMLCanvasElement|null} */
var canvas = null;
/** @type {CanvasRenderingContext2D|null} */
var ctx = null;

// cache canvas dimensions to avoid reflows
// see comment at http://eli.thegreenplace.net/2010/02/13/finding-out-the-mouse-click-position-on-a-canvas-with-javascript/
var canvas_width = 0, canvas_height = 0, canvas_width_half = 0, canvas_height_half = 0;
var canvas_div_offsetLeft = 0, canvas_div_offsetTop = 0;
var canvas_div_offset_snoop_time = -1;
var canvas_is_fullscreen = false;

// scaling factor from actual screen pixels to "logical" canvas pixels, >1 when browser is in HiDPI "retina" mode
// see http://www.html5rocks.com/en/tutorials/canvas/hidpi/ (but note backingStorePixelRatio should be just window.devicePixelRatio)
var canvas_oversample = window['devicePixelRatio'] || 1;


// server_time is our estimate of the server's clock, in (floating-point) seconds
// NOTE: server_time may not be monotonically increasing, because we re-adjust it when we receive each AJAX message!
var server_time = 0, server_time_offset = 0;

// client_time is the client-side clock. It will usually be monotonically increasing (assuming the browser/OS works that way).
/** @type {number} */
var client_time = 0;

var last_clock_update_time = 0;
var last_clock_slew_time = 0; // ensure clock is slewed only once per frame

// try to adjust our server_time to match the server, but smoothly, without jumps
function update_client_and_server_time() {
    client_time = (new Date()).getTime()/1000;
    var prev_server_time = server_time + (client_time - last_clock_update_time);
    last_clock_update_time = client_time;

    var target_server_time = client_time + server_time_offset;
    if(Math.abs(prev_server_time - target_server_time) >= gamedata['client']['clock_slew_limit']) {
        // big discrepancy - instantly realign clock
        if(server_time != 0) {
            console.log('large server clock offset ('+(target_server_time-prev_server_time).toString()+'), snapping to server time');
        }
        server_time = target_server_time;
    } else {
        var delta_t = client_time - last_clock_slew_time;
        if(delta_t >= gamedata['client']['clock_slew_min_interval']) {
            // slew towards the "correct" offset
            var incr = gamedata['client']['clock_slew_rate'] * delta_t;
            server_time = Math.min(Math.max(target_server_time, prev_server_time - incr), prev_server_time + incr);
            last_clock_slew_time = client_time;
        } else {
            // preserve current offset
            server_time = prev_server_time;
        }
    }
}

// for tracking mouse movement
var mouse_state = { last_x: 0, last_y: 0, // last x,y location of movement that the game field handled
                    last_raw_x: 0, last_raw_y: 0, // last x,y location of movement, regardless of who handled the event
                    button: new SPUI.MouseButtonState(),  // bitmask of button states, manipulate with SPUI.MouseButtonState methods
                    spacebar: false, // whether or not spacebar is being held down
                    // state of view-scroll operation
                    has_scrolled: false, scroll_start_x: 0, scroll_start_y: 0,
                    // state of drag-select operation
                    has_dragged: false, drag_start_x: 0, drag_start_y: 0,

                    /** @type {GameObject|null} over which the mouse is currently hovering */
                    hovering_over: null,

                    dripper: new Dripper.Dripper(null, -1, -1), // state of current "drip" operation (used for SG-style unit deployment)
                    // webkit PointerLock API in use and pointer is locked
                    pointer_locked: false, pointer_lock_origin: [-1,-1],

                    /** @type {GameObject|null} last unit that received a single click (cleared upon double-click) */
                    last_unit_clicked: null,
                    last_click_time: -1 // client_time when the click was made
                  };

// number of seconds after a click within which a second click will be considered a double-click
var DOUBLE_CLICK_TIME = 0.6;

// tooltip for buildings on the landscape - re-used for each one
var mouse_tooltip = null;

var pointer_lock_supported = false;

// currently-selected unit and spell
// 'selection' is a very important global variable that maintains the state of whatever
// unit or building the player has selected with the mouse, and it also maintains the
// state of any modal actions the user might be applying to it. The main mouse-click
// handler sets selection.unit, then selection.spellname and selection.spellkind are
// set later, when the user has specified what kind of action they want to perform.
// e.g. if the player is in the middle of moving a building, selection.spellname will be 'MOVE_BUILDING'.

// selection.ui is a reference to a SPUI object associated with
// the current modal action (e.g., a dialog box or building
// placement cursor). You must add or remove this object from SPUI.root when changing selection.ui!

var selection = { /** @type {GameObject|null} */
                  unit: null,
                  /** @type {!Array<!GameObject>} for drag-selection of multiple mobile units */
                  multi: [],
                  spellname: null,
                  spellkind: null,
                  item: null, // inventory item
                  /** @type {SPUI.Dialog|null} */
                  ui: null,
                  ui_change_time: -1
                };

var control_groups = [];
for(var i = 0; i < 10; i++) {
    control_groups.push({});
}

function control_group_define(group) {
    control_groups[group] = {};
    control_group_add(group);
};

function control_group_add(group) {
    var grp = control_groups[group];
    if(selection.unit) {
        grp[selection.unit.id] = selection.unit;
        for(var i = 0; i < selection.multi.length; i++) {
            var u = selection.multi[i];
            grp[u.id] = u;
        }
    }
};

function control_group_toggle(group) {
    var grp = control_groups[group];
    if(selection.unit) {
        if(selection.unit.id in grp) {
            delete grp[selection.unit.id];
        } else {
            grp[selection.unit.id] = selection.unit;
        }
        for(var i = 0; i < selection.multi.length; i++) {
            var u = selection.multi[i];
            if(u === selection.unit) { continue; }
            if(u.id in grp) {
                delete grp[u.id];
            } else {
                grp[u.id] = u;
            }
        }
    }
};

// have to be careful because member units may have been destroyed
function control_group_activate(group) {
    var grp = control_groups[group];

    // preserve selection.unit if it's in the group
    var old_selection_unit = selection.unit;
    change_selection_unit(null);

    if(old_selection_unit && old_selection_unit.id in grp) {
        selection.unit = old_selection_unit;
    }

    for(var id in grp) {
        var u = grp[id];
        if(u.is_destroyed()) {
            delete grp[id];
            continue;
        }
        if(!selection.unit) {
            selection.unit = u;
        }
        selection.multi.push(u);
    }
};


// handles to SPUI dialogs for desktop UI
var desktop_dialogs = {};

// handle to SPFX instance for displaying the "enemy units offscreen" direction arrow
var offscreen_unit_arrow = null;

// user-visible error log
var user_log;

var backdrop_music = null;

var LION_STONE_ID = 1002; // hard-coded Lion Stone base ID for rails tutorial

// game map

// the width and height of one map cell in pixels, as projected into the isometric view
// note: must be divisible by 2!
/** @const */
var cellsize = [20,10]; // 64 32

// scroll offset of game view relative to center of play area, in units of pixels *at view_zoom=1.0*
// when equal to [0,0], the game view is centered on the play area
var view_pos = [0,0];
var view_limits = [ [0,0], [0,0] ]; // min/max value constraints on view_pos
var view_zoom_linear = 0; // controller for view_zoom, indexes into gamedata.client.view_zoom_steps
var view_zoom = 1; // zoom factor applied between playfield and screen coordinates

/** @type {!Array.<!Array.<number>>} corners of visible region, in "draw" coordinate space */
var view_roi = [[0,0],[0,0]];

/** we apply certain optimizations when view_zoom is 1 for faster drawing
    @return {boolean} true if zoom factor is != 1 */
function view_is_zoomed() { return Math.abs(view_zoom-1) >= 0.01; }

var hitloc = [0,0]; // last mouse-down location (*for debugging only*)

// forced scrolling (for tutorials, etc)

var force_scroll_state = {
    target: [0,0],
    key: null,
    speed: 0
};

/** initiate forced scrolling
 * @param {string|null} obj_type
 * @param {Array.<number>|null} pos
 * @param {string} key
 * @param {number=} speed
 */
function force_scroll(obj_type, pos, key, speed) {
    if(force_scroll_state.key == key) { return; }
    if(!speed) { speed = gamedata['client']['force_scroll_speed']; }

    if(obj_type) {
        var obj = find_object_by_type(obj_type);
        if(!obj) { return; }
        pos = obj.raw_pos();
    }

    var ncells = (session.viewing_base ? session.viewing_base.ncells() : [0,0]);

    // new target = 2D pixel offset from center of map to 'pos'
    force_scroll_state.key = key;
    force_scroll_state.target = ortho_to_playfield_vector(vec_sub(pos, vec_scale(0.5,ncells)));
    force_scroll_state.speed = speed;
}

function force_scroll_eval() {
    if(player.is_cheater || force_scroll_state.key === null) { return; }
    var delta = vec_sub(force_scroll_state.target, view_pos);
    var dist = vec_length(delta);

    if(dist >= 2/view_zoom) {
        var dir = vec_scale(1.0/dist, delta);
        var dpos = vec_scale(force_scroll_state.speed*dist, dir);
        if(vec_length(dpos) >= 0.5/view_zoom) {
            view_pos = vec_add(view_pos, dpos);
            return;
        }
    }
    // done
    force_scroll_state.key = null;
}

// Auras

/** @constructor @struct
    @implements {GameTypes.ISerializable}
    @param {GameObjectId|null} source_id object ID
    @param {string|null} source_team
    @param {Object} spec
    @param {?} strength
    @param {number} range
    @param {!GameTypes.TickCount} start_tick
    @param {!GameTypes.TickCount} expire_tick
    @param {Object|null=} vs_table
*/
function Aura(source_id, source_team, spec, strength, range, start_tick, expire_tick, vs_table) {
    this.source_id = source_id;
    this.source_team = source_team;
    this.spec = spec;
    this.strength = strength;
    this.range = range;
    /** @type {!GameTypes.TickCount} */
    this.start_tick = start_tick;
    /** @type {!GameTypes.TickCount} */
    this.expire_tick = expire_tick;
    this.stacks = 1;
    this.vs_table = vs_table || null;
    this.visual_effect = null;
};

/** @override */
Aura.prototype.serialize = function() {
    return {'source_id': this.source_id,
            'source_team': this.source_team,
            'spec': this.spec['name'],
            'strength': this.strength,
            'range': this.range,
            'start_tick': this.start_tick.get(),
            'expire_tick': this.expire_tick.get(),
            'stacks': this.stacks,
            'vs_table': this.vs_table};
};
/** @override */
Aura.prototype.apply_snapshot = function(snap) {
    this.source_id = snap['source_id'];
    this.source_team = snap['source_team'];
    this.spec = gamedata['auras'][snap['spec']];
    this.strength = snap['strength'];
    this.range = snap['range'];
    this.start_tick = new GameTypes.TickCount(snap['start_tick']);
    this.expire_tick = new GameTypes.TickCount(snap['expire_tick']);
    this.stacks = snap['stacks'];
    this.vs_table = snap['vs_table'];
};

/** @param {!Object<string,?>} snap
    @return {!Aura} */
Aura.unserialize = function(snap) {
    var ret = new Aura(snap['source_id'], snap['source_team'],
                       gamedata['auras'][snap['spec']],
                       snap['strength'], snap['range'],
                       new GameTypes.TickCount(snap['start_tick']),
                       new GameTypes.TickCount(snap['expire_tick']),
                       snap['vs_table']);
    ret.stacks = snap['stacks'];
    return ret;
};

/** @param {!World.World} world
    @param {!GameObject} obj */
Aura.prototype.apply = function(world, obj) {
    if('client' in this.spec && !this.spec['client']) { return; }
    goog.array.forEach(this.spec['effects'], function(effect) {
        var code = effect['code'];
        if(code === 'speed_boosted') {
            obj.combat_stats.maxvel *= (1 + this.strength);
        } else if(code === 'speed_weakened') {
            if(obj.is_mobile()) {
                obj.combat_stats.maxvel *= Math.max(1 - this.strength, 0);
            }
        } else if(code === 'defense_boosted') {
            obj.combat_stats.damage_taken *= (1-this.strength);
        } else if(code === 'defense_weakened') {
            obj.combat_stats.damage_taken *= (1+this.strength);
        } else if(code === 'radiation_hardened') {
            var val = obj.combat_stats.damage_taken_from['radiation'] || 1.0;
            obj.combat_stats.damage_taken_from['radiation'] = val * this.strength;
        } else if(code === 'frozen') {
            if(obj.is_mobile()) {
                obj.combat_stats.maxvel *= (1 - this.strength);
                obj.combat_stats.turn_rate *= (1 - this.strength);
                obj.combat_stats.erratic_flight = Math.max(obj.combat_stats.erratic_flight, this.strength);
            }
        } else if(code === 'ice_shielded') {
            obj.combat_stats.ice_effects *= this.strength;
        } else if(code === 'ice_encrusted') {
            // note: like "frozen", but reduce by ice_shielded/ice_effects
            if(obj.is_mobile()) {
                obj.combat_stats.maxvel *= (1 - obj.combat_stats.ice_effects*this.strength);
                obj.combat_stats.turn_rate *= (1 - obj.combat_stats.ice_effects*this.strength);
                obj.combat_stats.erratic_flight = Math.max(obj.combat_stats.erratic_flight, obj.combat_stats.ice_effects*this.strength);
            }
        } else if(code === 'on_island') {
            obj.combat_stats.damage_taken_from['drowning'] = 0;
        } else if(code === 'swamp_shielded') {
            obj.combat_stats.swamp_effects *= this.strength;
        } else if(code === 'moving_in_swamp') {
            if(obj.is_mobile()) {
                obj.combat_stats.maxvel *= (1 - obj.combat_stats.swamp_effects*this.strength);
                obj.combat_stats.turn_rate *= (1 - obj.combat_stats.swamp_effects*this.strength);
            }
        } else if(code === 'rate_of_fire_boosted') {
            obj.combat_stats.rate_of_fire *= (1 + this.strength);
        } else if(code === 'damage_boosted') {
            obj.combat_stats.weapon_damage *= (1 + this.strength);
        } else if(code === 'damage_weakened') {
            obj.combat_stats.weapon_damage *= (1 - this.strength);
        } else if(code === 'armor_boosted') {
            obj.combat_stats.extra_armor = Math.max(obj.combat_stats.extra_armor, this.strength);
        } else if(code.indexOf('damage_type_shielder') === 0) { // this handles both damage_type_shielder and damage_type_shielder_invisible
            // apply the damage_type_shielded or damage_type_shielded_invisible aura to this and nearby units

            if(obj.is_destroyed()) {
                // but don't apply if the shielder is dead
                return;
            }

            var targets_air = this.strength['targets_air'];
            var targets_ground = this.strength['targets_ground'];

            var obj_list = world.query_objects_within_distance(obj.raw_pos(),
                                                               gamedata['map']['range_conversion'] * this.range,
                                                               { only_team: obj.team, mobile_only: true,
                                                                 exclude_flying: !targets_air,
                                                                 flying_only: !targets_ground });
            for(var i = 0; i < obj_list.length; i++) {
                var o = obj_list[i].obj;
                o.create_aura(world, obj.id, obj.team, code.replace('shielder', 'shielded'), this.strength, new GameTypes.TickCount(1), 0);
            }
        } else if(code.indexOf('defense_booster') === 0) { // this handles both defense_booster and defense_booster_invisible
            // apply the defense_boosted or defense_boosted_invisible aura to this and nearby units

            if(obj.is_destroyed()) {
                // but don't apply if the booster is dead
                return;
            }

            var obj_list = world.query_objects_within_distance(obj.raw_pos(),
                                                               gamedata['map']['range_conversion'] * this.range,
                                                               { only_team: obj.team, mobile_only: true });
            for(var i = 0; i < obj_list.length; i++) {
                var o = obj_list[i].obj;
                o.create_aura(world, obj.id, obj.team, code.replace('booster', 'boosted'), this.strength, new GameTypes.TickCount(1), 0);
            }
        } else if(code.indexOf('damage_booster') === 0) { // this handles both damage_booster and damage_booster_invisible
            // apply the damage_boosted or damage_boosted_invisible aura to this and nearby units

            if(obj.is_destroyed()) {
                // but don't apply if the booster is dead
                return;
            }

            var obj_list = world.query_objects_within_distance(obj.raw_pos(),
                                                               gamedata['map']['range_conversion'] * this.range,
                                                               { only_team: obj.team, mobile_only: true });
            for(var i = 0; i < obj_list.length; i++) {
                var o2 = obj_list[i].obj;
                o2.create_aura(world, obj.id, obj.team, code.replace('booster', 'boosted'), this.strength, new GameTypes.TickCount(1), 0);
            }
        } else if(code.indexOf('range_booster') === 0) { // this handles both range_booster and range_booster_invisible
            // apply the range_boosted or range_boosted_invisible aura to this and nearby units

            if(obj.is_destroyed()) {
                // but don't apply if the booster is dead
                return;
            }

            var obj_list = world.query_objects_within_distance(obj.raw_pos(),
                                                               gamedata['map']['range_conversion'] * this.range,
                                                               { only_team: obj.team, mobile_only: true });
            for(var i = 0; i < obj_list.length; i++) {
                var o2 = obj_list[i].obj;
                o2.create_aura(world, obj.id, obj.team, code.replace('booster', 'boosted'), this.strength, new GameTypes.TickCount(1), 0);
            }
        } else if(code.indexOf('detector') === 0) {
            // apply the detected aura to nearby units

            if(obj.is_destroyed()) {
                // but don't apply if the booster is dead
                return;
            }

            var enemy = '';
            if(obj.team === 'enemy') {
                enemy = 'player';
            } else {
                enemy = 'enemy';
            }
            var aura_strength = this.strength || 1; // in this case, aura strength means chance of detection

            var obj_list = world.query_objects_within_distance(obj.raw_pos(),
                                                               gamedata['map']['range_conversion'] * this.range,
                                                               { only_team: enemy });
            for(var i = 0; i < obj_list.length; i++) {
                var o2 = obj_list[i].obj;
                if(o2.is_invisible_default()) {
                    // apply_aura represents the "roll" against the chance of failing detection, only calculates if aura_strength isn't 1 (100%)
                    var apply_aura = (aura_strength < 1) ? Math.random() : 1;
                    var avoided_detection = false;
                    if(o2.combat_stats.avoided_detection) {
                        avoided_detection = true; // invisible objects that avoided detection stay undetected
                    } else if(o2.combat_stats.detected) {
                        apply_aura = aura_strength;  // invisible objects that were detected stay detected
                    }
                    if((apply_aura <= aura_strength) && !avoided_detection) { // apply the aura if the random roll succeeded and the object didn't already avoid detection
                        o2.create_aura(world, obj.id, obj.team, code.replace('detector', 'detected'), this.strength, new GameTypes.TickCount(1), 0);
                    } else if ((apply_aura > aura_strength) || avoided_detection) { // apply the avoided detection aura if the object already avoided detection or the object already avoided detection
                        o2.create_aura(world, obj.id, obj.team, 'avoided_detection', this.strength, new GameTypes.TickCount(1), 0);
                    }
                }
            }
        } else if(code === 'detected') {
            obj.combat_stats.detected = 1;
        } else if(code === 'avoided_detection') {
            obj.combat_stats.detected = 0;
            obj.combat_stats.avoided_detection = 1;
        } else if(code === 'stunned') {
            obj.combat_stats.stunned += this.strength;
        } else if(code === 'grounded') {
            obj.combat_stats.flying = false;
            obj.combat_stats.maxvel = 0;
            obj.combat_stats.altitude = 0;
        } else if(code === 'disarmed') {
            obj.combat_stats.disarmed += this.strength;
        } else if(code === 'range_reduction') {
            obj.combat_stats.weapon_range *= Math.max(0, (1-this.strength));
            obj.combat_stats.effective_weapon_range *= Math.max(0, (1-this.strength));
        } else if(code === 'range_boosted') {
            obj.combat_stats.weapon_range *= Math.max(0, (1+this.strength));
            obj.combat_stats.effective_weapon_range *= Math.max(0, (1+this.strength));
        } else if(code === 'damage_type_shielded') {
            var damage_type = this.strength['type'];
            if(!damage_type) { return; };
            var val = obj.combat_stats.damage_taken_from[damage_type] || 1.0;
            var shield_strength = this.strength['shield_strength'];
            if(!shield_strength) { return; };
            obj.combat_stats.damage_taken_from[damage_type] = val * (1 - shield_strength);
        } else if(code === 'weak_zombie') {
            obj.combat_stats.maxvel *= this.spec['zombie_speed'];
            obj.combat_stats.weapon_damage *= this.spec['zombie_damage'];
        } else if(code === 'on_fire') {
            var apply_interval = effect['apply_interval'] || TICK_INTERVAL;
            // apply effect every N ticks
            var n_ticks = Math.floor(apply_interval/TICK_INTERVAL + 0.5);
            if(n_ticks <= 1 || (((world.combat_engine.cur_tick.get() - this.start_tick.get()) % n_ticks) == 0)) {
                var dmg = Math.max(1, Math.floor(this.strength*apply_interval));
                world.combat_engine.queue_damage_effect(new CombatEngine.TargetedDamageEffect(world.combat_engine.cur_tick, client_time, this.source_id, this.source_team, obj.id, dmg, effect['damage_vs'] || this.vs_table));
            }
        } else if(code === 'sprite_swapped') {
            obj.combat_stats.art_asset = this.strength['sprite'];
        } else if(code === 'projectile_speed_reduced') {
            obj.combat_stats.projectile_speed *= (1 - this.strength);
        } else if(code === 'cast_spell_continuously') {
            if(!obj.is_destroyed()) {
                var spellname = effect['spell'];
                obj.cast_client_spell(world, spellname, gamedata['spells'][spellname], null, null);
            }
        } else {
            console.log('unhandled aura code '+code);
        }
    }, this);
};

/** @param {!World.World} world
    @param {!GameObject} obj */
Aura.prototype.update_effect = function(world, obj) {
    if(('visual_effect' in this.spec) && !obj.spec['worth_less_xp'] && (!obj.is_invisible() || (obj.team === 'player' && !session.is_replay()))) {
        // do not show FX on barriers or invisible objects
        var vfx_props = {'radius': 0.8*obj.hit_radius() };
        this.visual_effect = world.fxworld.add_visual_effect_at_time(obj.interpolate_pos(world), (obj.is_mobile() ? obj.combat_stats.altitude : 0), [0,1,0], client_time, this.spec['visual_effect'], true, vfx_props);
    }
};

Aura.prototype.end = function(obj) {
    if('end_spell' in this.spec) {
        var spell_name = this.spec['end_spell'];
        obj.cast_client_spell(spell_name, gamedata['spells'][spell_name], obj, null);
    }
};

// to reduce the amount of AJAX traffic, group together all client->server messages
// that are sent within each iteration of the main game loop

/** @constructor @struct */
function AJAXMessageQueue() {
    this.queue = [];
    this.serial = -1;
    this.recv_progress = -1; // UNRELIABLE indication of progress receiving the response to this message bundle (-1 if unknown)
};
AJAXMessageQueue.prototype.push = function(msg) {
    this.queue.push(msg);
};
AJAXMessageQueue.prototype.length = function() { return this.queue.length; };
AJAXMessageQueue.prototype.prepend = function(msgs) {
    this.queue = msgs.concat(this.queue);
};

var message_queue = new AJAXMessageQueue();

// serial number for each AJAX message
var message_serial = 0;

// for obfuscation purposes
/** @constructor @struct */
function ServerSender() {
    this.foo = 123;
};
ServerSender.prototype.func = function(msg) {
    message_queue.push(msg);
};
var send_to_server = new ServerSender();

/** @constructor */
function RetransBuffer() {
    this.buf = [];
};
RetransBuffer.prototype.append = function(serial, msg) {
    this.buf.push([serial, msg]);
};
RetransBuffer.prototype.trim = function(ack) {
    while(this.buf.length > 0 && this.buf[0][0] <= ack) {
        this.buf.shift();
    }
};
RetransBuffer.prototype.length = function() { return this.buf.length; };

var retrans_buffer = new RetransBuffer();

// general-purpose mechanism for waiting for the server to acknowledge all actions submitted up to now
/** @constructor @struct */
function Synchronizer() {
    this.last_sent = 0;
    this.last_received = -1;
};
Synchronizer.INIT = -1; // this should be the starting value for variables used as sync markers
Synchronizer.prototype.request_sync = function() {
    var marker = this.last_sent;
    send_to_server.func(["CLIENT_SYNC", marker]);
    if(this.last_sent > 0xFFFFFFFF) {
        this.last_sent = 0;
        console.log('this.last_sent overflow!');
    } else {
        this.last_sent += 1;
    }
    return marker;
};
Synchronizer.prototype.receive_sync = function(marker) {
    this.last_received = marker;
};
Synchronizer.prototype.is_in_sync = function(marker) { return this.last_received >= marker; };

// returns false if ANY marker has not been replied yet
Synchronizer.prototype.is_globally_in_sync = function() {
    return (this.last_received >= this.last_sent-1);
};

var synchronizer = new Synchronizer();

// game objects

// Object actions are determined by two "layers" of code:
//
// 1) The lower "control" layer governs the unit's current movement/firing state
// and applies game rules (e.g. movement speed, spell range limit, and cooldown timer)
//
// 2) The higher "ai" layer tells the "control" layer what to do in order to accomplish
// goals like "move here" "attack this thing" etc.

var AI_DEBUG = 0; // 1 = display unit AI states, 2 = also print lots of AI info to console
var PLAYFIELD_DEBUG = false; // extra checking/recording on playfield movement
var PLAYFIELD_DEBUG_DRAW = false; // display unit and building info debug text
var COMBAT_DEBUG = (get_query_string('wombat') == '1');
var CLICK_DETECTION_DEBUG = (get_query_string('click_detection_debug') == '1');

/** object movement/spell control states
    @enum {number} */
var control_states = {
    CONTROL_STOP : 0, // not doing anything
    CONTROL_MOVING : 1, // moving towards 'this.dest'
    CONTROL_SHOOT : 2 // casting control_spellname at control_target
};
var control_state_names = {};
control_state_names[control_states.CONTROL_STOP] = 'CONTROL_STOP';
control_state_names[control_states.CONTROL_MOVING] = 'CONTROL_MOVING';
control_state_names[control_states.CONTROL_SHOOT] = 'CONTROL_SHOOT';

/** object AI states
    @enum {number} */
var ai_states = {
    AI_STOP : 0, // do nothing
    AI_ATTACK_SPECIFIC : 1, // attack ai_target (and only ai_target, moving into range if necessary)
    AI_ATTACK_ANY : 2, // attack ai_target, but switch to any other target that becomes closer/more threatening.
                       // and be willing to move to pursue enemies within aggro radius, BUT leash back to commanded position (ai_dest) otherwise (if ai_dest is not null, otherwise stand still)
    AI_MOVE : 3, // move to 'this.ai_dest' (do not stop to shoot)
    AI_ATTACK_STATIONARY : 4, // do not move, but shoot anything that comes within range
    AI_ATTACK_MOVE : 5, // StarCraft-style A-move: move towards ai_dest but stop and shoot if target comes in range
    AI_ATTACK_MOVE_AGGRO : 6, // like A-move, but pursue enemies within aggro radius (which is longer than weapon range)
    AI_DEFEND_MOVE : 7, // like regular move, but flip info A-move if attacked
    AI_NULL : 8 // disable AI - unlike AI_STOP, this won't touch any control values
};
var ai_state_names = {};
ai_state_names[ai_states.AI_STOP] = 'AI_STOP';
ai_state_names[ai_states.AI_ATTACK_SPECIFIC] = 'AI_ATTACK_SPECIFIC';
ai_state_names[ai_states.AI_ATTACK_ANY] = 'AI_ATTACK_ANY';
ai_state_names[ai_states.AI_MOVE] = 'AI_MOVE';
ai_state_names[ai_states.AI_ATTACK_STATIONARY] = 'AI_ATTACK_STATIONARY';
ai_state_names[ai_states.AI_ATTACK_MOVE] = 'AI_ATTACK_MOVE';
ai_state_names[ai_states.AI_ATTACK_MOVE_AGGRO] = 'AI_ATTACK_MOVE_AGGRO';
ai_state_names[ai_states.AI_DEFEND_MOVE] = 'AI_DEFEND_MOVE';
ai_state_names[ai_states.AI_NULL] = 'AI_NULL';

var ai_state_values = {
    'AI_STOP': ai_states.AI_STOP,
    'AI_ATTACK_SPECIFIC': ai_states.AI_ATTACK_SPECIFIC,
    'AI_ATTACK_ANY': ai_states.AI_ATTACK_ANY,
    'AI_MOVE': ai_states.AI_MOVE,
    'AI_ATTACK_STATIONARY': ai_states.AI_ATTACK_STATIONARY,
    'AI_ATTACK_MOVE': ai_states.AI_ATTACK_MOVE,
    'AI_ATTACK_MOVE_AGGRO': ai_states.AI_ATTACK_MOVE_AGGRO,
    'AI_DEFEND_MOVE': ai_states.AI_DEFEND_MOVE,
    'AI_NULL': ai_states.AI_NULL
};
function ai_state_can_be_queued(state) {
    return (state == ai_states.AI_ATTACK_SPECIFIC || state == ai_states.AI_MOVE || state == ai_states.AI_ATTACK_MOVE || state == ai_states.AI_ATTACK_MOVE_AGGRO || state == ai_states.AI_DEFEND_MOVE);
}

// flags for tracking which parts of the GameObject state are dirty and need to be sent to the server
var obj_state_flags = {
    XY: 1, // position
    HP: 2, // health/damage (also includes last_attacker, and killer_info if destroyed)
    ORDERS: 4, // movement orders
    PATROL: 8, // patrol flag
    URGENT: 16, // mark that this object should be flushed immediately at the end of the tick, instead of waiting for the next time-interval-based save
    HIGH_PRIORITY: 32, // high priority, 1/10 of the usual refresh time or 1 second, whichever is higher
    ALL: 255
};

/** @typedef {string} */
var GameObjectId = {};

/** @typedef {string} */
var TeamId = {};

/** @constructor - XXX not ready for struct yet
    @implements {GameTypes.IIncrementallySerializable}
 */
function GameObject() {
    /** @type {GameObjectId} */
    this.id = 'DEAD'; // = DEAD_ID if the object is "dead" or otherwise not part of the game world

    /** @type {!Object} */
    this.spec = {}; // set upon instantiation
    this.x = -1;
    this.y = -1;
    this.hp = 0;
    this.last_ping_hp = 0;
    this.max_hp = 0;
    /** @type {TeamId} */
    this.team = 'invalid';
    this.level = 1;
    this.equipment = null;
    /** @type {null|Array<string>} */
    this.behaviors = null;

    /** @type {null|string}
        "attacker" means that this unit, when spawned in an AI base, should belong to the attacking human player.
        no client-side effect during normal gameplay - this is used for AI base design only */
    this.force_team = null;

    /** for behaviors to keep state between ticks */
    this.behavior_state = {};

    /** @type {boolean} flag that the on_approach consequent has fired this session.
        Note: not synchronized with the server. Assumed to be set false each new session. */
    this.on_approach_fired = false;

    // true if there are unsaved changes that should be sent back to
    // the server before the session is closed
    // (only applies to hitpoints, and xy position and orders for mobile units)
    this.state_dirty = 0;

    this.control_state = control_states.CONTROL_STOP;
    /** @type {GameObjectId|null} */
    this.control_target_id = null;
    /** @type {string|null} */
    this.control_spellname = null;

    /** @type {number} this is a cooldown timer just for the default auto "shoot" spell */
    this.control_cooldown = 0;

    this.ai_state = ai_states.AI_STOP;
    this.ai_target = null;
    this.last_ai_target = null;

    // eventually the "threatlist" might be a full WoW-style threat list, but for now
    // it is just used as a way to cache the results of ai_pick_target() across ticks when there are no "map topology" changes
    this.ai_threatlist = null;
    this.ai_threatlist_dirty = true;
    // list of object IDs of other objects that set self.ai_target equal to this object, during the previous tick's AI calculations
    this.ai_attackers_list = [];
    // double-buffering for ai_attackers_list - this accumulates new attackers during the curren tick's AI calculations
    // (it is not used until the next tick)
    this.next_ai_attackers_list = [];

    // reference to last object that shot at us.
    // NOTE! we do not make effort to track whether the referred-to object is actually still alive
    // so check the id field before using
    this.last_attacker = null;

    // ID of the most damaging (against us) potential target, among
    // the group of objects that are both attacking us, and vulnerable
    // to our attacks.
    // Note :Once this is set to something non-null, it is "sticky" (NOT changed)
    // until that object dies.
    this.strongest_attacker_id = null;


    this.last_speak_sound = null; // client-side state to prevent sound FX spam
    this.last_speak_time = -1;

    // combat stats - pulled from gamedata but modified by auras
    /** @type {!CombatStats} */
    this.combat_stats = new CombatStats();

    /** @type {Array.<Aura>} */
    this.auras = [];

    this.cooldowns = {}; // XXX create a type for this

    // random number for offsetting looped animations
    this.anim_offset = Math.random();


    // direction object is looking (for graphics only, sim does not use!)
    this.cur_facing = this.anim_offset*2*Math.PI; // current (may be changing as it turns)
    this.next_facing = this.cur_facing;
    this.target_facing = this.cur_facing; // direction we want to look eventually


    // cache for this.calc_draw_pos()
    this.draw_pos_cache = [[0,0],0];

    // for graphics only, sprite scaling
    this.cur_scale = [1,1];

    // for graphics only (fading-in/out effects), last object opacity
    /** @type {number} */
    this.cur_opacity = 1;
    /** @type {number} */
    this.last_opacity = /** @type {number} */ (gamedata['client']['unit_spawn_opacity']);
    this.last_opacity_time = client_time; // note: resets as unit is spawned

    // for graphics only, last stabilized hp value
    this.last_ui_hp_stable = -1;
    this.last_ui_hp_time = -1;
    this.last_ui_hp = -1;

    // SPFX effect that exists all the time the object is alive
    /** @type {Object|null} - pointer into gamedata for this effect (the level-dependent post-get_leveled_quantity value) */
    this.permanent_effect_source = null;
    /** @type {SPFX.FXObject|null} */
    this.permanent_effect = null;

    this.default_altitude = 0;

    // for incremental serialization only
    this.serialization_dirty = false;
    /** @type {Object<string,?>|null} */
    this.prev_snapshot = null;
}

/** @override */
GameObject.prototype.serialize = function() {
    var ret = {'obj_id': this.id,
               'spec': this.spec['name'],
               'x': this.x,
               'y': this.y,
               'owner': (this.team === 'player' ? session.user_id : -1)
              };

    if(this.max_hp !== 0) {
        ret['hp'] = this.hp;
        ret['max_hp'] = this.max_hp;
    }
    if(this.level != 1) {
        ret['level'] = this.level;
    }
    if(!(this.is_inert() || (this.spec['worth_less_xp'] && !this.is_minefield() && !this.is_ambush()))) {
        // fields that shouldn't be needed for barriers and scenery
        ret['equipment'] = this.equipment ? deepcopy_obj(this.equipment) : null;
        ret['control_state'] = this.control_state;
        ret['control_target_id'] = this.control_target_id;
        ret['control_spellname'] = this.control_spellname;
        ret['control_cooldown'] = this.control_cooldown;
        ret['auras'] = goog.array.map(this.auras, function(aura) { return aura.serialize(); }, this);
        ret['combat_stats'] = this.combat_stats.serialize();
        ret['cooldowns'] = goog.object.map(this.cooldowns, function(v) {
            return {'start_tick': v.start_tick.get(), // translate from tick counts
                    'expire_tick': v.expire_tick.get()};
        }, this);
        if('turn_rate' in this.spec) {
            ret['cur_facing'] = serialize_number(this.cur_facing, 2);
            ret['target_facing'] = serialize_number(this.target_facing, 2);
            // note: next_facing is assumed to be computed from cur_facing and target_facing
        }
    }
    return ret;
};
/** @override */
GameObject.prototype.serialize_incremental = function() {
    if(!this.prev_snapshot) {
        this.prev_snapshot = this.serialize();
        return this.prev_snapshot;
    }
    if(this.serialization_dirty) {
        var new_snapshot = this.serialize();
        /** @const fields that always should be updated (because run_control_shooting() and damage mutate them unpredictably) */
        var always_diff = {}; // {'hp':1};
        var diffs = {};
        goog.object.forEach(new_snapshot, function(v, k) {
            if((k in always_diff) || !deepequal(this.prev_snapshot[k], v)) {
                diffs[k] = v;
            }
        }, this);

        this.prev_snapshot = new_snapshot;
        this.serialization_dirty = false;
        if(goog.object.isEmpty(diffs)) {
            return null;
        }
        return diffs;
    }
    return null;
};

/** @override */
GameObject.prototype.apply_snapshot = function(snap) {
    if(('obj_id' in snap) && snap['obj_id'] !== this.id) { throw Error('obj_id mismatch'); }
    if(('spec' in snap) && snap['spec'] !== this.spec['name']) { throw Error('specname mismatch'); }
    if('x' in snap) { this.x = snap['x']; }
    if('y' in snap) { this.y = snap['y']; }
    if('hp' in snap) { this.hp = snap['hp']; }
    if('max_hp' in snap) { this.max_hp = snap['max_hp']; }

    // XXX serialize creates a fake owner that is -1 for enemy, otherwise player
    // this should be replaced by better team/ownership serialization
    if('owner' in snap) { this.team = (snap['owner'] !== -1 ? 'player' : 'enemy'); }

    if('level' in snap) { this.level = snap['level']; }
    if('equipment' in snap) { this.equipment = snap['equipment']; }
    if('control_state' in snap) { this.control_state = snap['control_state']; }
    if('control_target_id' in snap) { this.control_target_id = snap['control_target_id']; }
    if('control_spellname' in snap) { this.control_spellname = snap['control_spellname']; }
    if('control_cooldown' in snap) { this.control_cooldown = snap['control_cooldown']; }
    if('combat_stats' in snap) { this.combat_stats.apply_snapshot(snap['combat_stats']); }
    if('auras' in snap) { this.auras = goog.array.map(snap['auras'], function(s) { return Aura.unserialize(s); }, this); }
    if('cooldowns' in snap) {
        this.cooldowns = {};
        for(var k in snap['cooldowns']) {
            var v = snap['cooldowns'][k];
            if(!('start_tick' in v)) { continue; } // bad legacy data
            var val;
            if(typeof(v['start_tick']) === 'object' && 'count' in v['start_tick']) { // bad legacy data where we forgot to decode tickcounts
                val = {start_tick: new GameTypes.TickCount(v['start_tick']['count']),
                       expire_tick: new GameTypes.TickCount(v['expire_tick']['count'])};
            } else {
                val = {start_tick: new GameTypes.TickCount(v['start_tick']),
                       expire_tick: new GameTypes.TickCount(v['expire_tick'])};
            }
            this.cooldowns[k] = val;
        }
    }
    if('cur_facing' in snap) {
        this.cur_facing = snap['cur_facing'];
        // set next_facing only for the very first tick after application of the initial snapshot
        // for later ticks, it will be overwritten by run_control_facing().
        this.next_facing = this.cur_facing;
    }
    if('target_facing' in snap) { this.target_facing = snap['target_facing']; }
};

/** @param {!Object<string,?>} snap
    @return {!GameObject} */
GameObject.unserialize = function(snap) {
    var spec = get_spec(snap['spec']);
    if(!spec) {
        throw Error('cannot create object of unrecognized type '+snap['spec']);
    }
    var kind = spec['kind'];
    var obj;
    if(kind === 'building') {
        obj = new Building();
    } else if(kind === 'mobile') {
        obj = new Mobile();
    } else if(kind === 'inert') {
        obj = new Inert();
    } else {
        throw Error('bad spec kind '+kind);
    }
    obj.spec = spec;
    obj.id = snap['obj_id'];
    obj.apply_snapshot(snap);
    obj.ai_state = ai_states.AI_NULL; // turn off AI
    return obj;
};

/** @param {!World.World} world */
GameObject.prototype.on_added_to_world = function(world) {};
/** @param {!World.World} world */
GameObject.prototype.on_removed_from_world = function(world) {
    this.remove_permanent_effect(world);

    // remove from selection.multi
    for(var i = 0; i < selection.multi.length; i++) {
        if(selection.multi[i] === this) {
            selection.multi.splice(i,1);
        }
    }

    if(selection.unit === this) {
        // try to select something else in the multi group
        if(selection.multi.length > 0) {
            selection.unit = selection.multi[0];
        } else {
            change_selection(null);
        }
    }
    if(mouse_state.hovering_over === this) {
        mouse_state.hovering_over = null;
    }
};

/** @const
    @type {GameObjectId} */
GameObject.DEAD_ID = 'DEAD';
/** @const
    @type {GameObjectId} */
GameObject.VIRTUAL_ID = 'VIRTUAL';

// pull raw combat stats from gamedata and initialize non-gamedata values

var RESURRECT_NEVER = 1;
var RESURRECT_AND_REPAIR_WITH_TECH = 2;
var RESURRECT_AND_REPAIR_ALWAYS = 10;

/** CombatStats is the interface that carries stat modifications from ModChains and object auras
    into the combat engine core.
    @constructor @struct
    @implements {GameTypes.ISerializable} */
function CombatStats() {
    this.stunned = 0;
    this.disarmed = 0;
    this.damage_taken = 1;
    /** @type {!Object.<string,number>} */
    this.damage_taken_from = {}; // OVERRIDES the spec's native damage_taken_from table
    this.rate_of_fire = 1;
    this.accuracy = 1;
    this.weapon_damage = 1;
    /** @type {!Object.<string,number>} */
    this.weapon_damage_vs = {}; // multiplies with the weapon's native damage_vs_table
    this.effective_weapon_range = 1;
    this.weapon_range = 1;
    this.extra_armor = 0;
    this.anti_air = 0;
    this.anti_missile = 1; // note! this is the chance that a missile is NOT intercepted
    this.turn_rate = 1;
    this.ice_effects = 1;
    this.swamp_effects = 1;
    this.projectile_speed = 1;
    this.splash_range = 1;
    this.art_asset = null;
    this.invisible = 0;
    this.detected = 0;
    this.avoided_detection = 0;
    this.weapon_facing_fudge = 0;
    this.muzzle_offset = [0,0,0];
    this.muzzle_height = 0;
    this.flying = false;
    this.altitude = 0;

    // Mobile only

    /** @type {number} */
    this.maxvel = 1; // scales the spec maxvel
    this.erratic_flight = 0;
};

CombatStats.prototype.clear = function() {
    // on, Javascript...
    this.stunned = 0;
    this.disarmed = 0;
    this.damage_taken = 1;
    this.damage_taken_from = {}; // OVERRIDES the spec's native damage_taken_from table
    this.rate_of_fire = 1;
    this.accuracy = 1;
    this.weapon_damage = 1;
    this.weapon_damage_vs = {}; // multiplies with the weapon's native damage_vs_table
    this.effective_weapon_range = 1;
    this.weapon_range = 1;
    this.extra_armor = 0;
    this.anti_air = 0;
    this.anti_missile = 1; // note! this is the chance that a missile is NOT intercepted
    this.turn_rate = 1;
    this.ice_effects = 1;
    this.swamp_effects = 1;
    this.projectile_speed = 1;
    this.splash_range = 1;
    this.maxvel = 1;
    this.erratic_flight = 0;
    this.art_asset = null;
    this.invisible = 0;
    this.detected = 0;
    this.avoided_detection = 0;
    this.weapon_facing_fudge = 0;
    this.muzzle_offset = [0,0,0];
    this.muzzle_height = 0;
    this.flying = false;
    this.altitude = 0;
};

/** @override */
CombatStats.prototype.serialize = function() {
    var ret = {};
    // only include non-default values, since the apply will clear to default first
    if(this.stunned) { ret['stunned'] = this.stunned; }
    if(this.disarmed) { ret['disarmed'] = this.disarmed; }
    if(this.damage_taken != 1) { ret['damage_taken'] = this.damage_taken; }
    if(!goog.object.isEmpty(this.damage_taken_from)) {
        ret['damage_taken_from'] = this.damage_taken_from; // reference, not copy!
    }
    if(this.rate_of_fire != 1) { ret['rate_of_fire'] = this.rate_of_fire; }
    if(this.accuracy != 1) { ret['accuracy'] = this.accuracy; }
    if(this.weapon_damage != 1) { ret['weapon_damage'] = this.weapon_damage; }
    if(!goog.object.isEmpty(this.weapon_damage_vs)) {
        ret['weapon_damage_vs'] = this.weapon_damage_vs; // reference, not copy!
    }
    if(this.effective_weapon_range != 1) { ret['effective_weapon_range'] = this.effective_weapon_range; }
    if(this.weapon_range != 1) { ret['weapon_range'] = this.weapon_range; }
    if(this.extra_armor != 0) { ret['extra_armor'] = this.extra_armor; }
    if(this.anti_air) { ret['anti_air'] = this.anti_air; }
    if(this.anti_missile != 1) { ret['anti_missile'] = this.anti_missile; }
    if(this.turn_rate != 1) { ret['turn_rate'] = this.turn_rate; }
    if(this.ice_effects != 1) { ret['ice_effects'] = this.ice_effects; }
    if(this.swamp_effects != 1) { ret['swamp_effects'] = this.swamp_effects; }
    if(this.projectile_speed != 1) { ret['projectile_speed'] = this.projectile_speed; }
    if(this.splash_range != 1) { ret['splash_range'] = this.splash_range; }
    if(this.maxvel != 1) { ret['maxvel'] = this.maxvel; }
    if(this.erratic_flight) { ret['erratic_flight'] = this.erratic_flight; }
    if(this.art_asset) { ret['art_asset'] = this.art_asset; }
    if(this.invisible) { ret['invisible'] = this.invisible; }
    if(this.detected) { ret['detected'] = this.detected; }
    if(this.avoided_detection) { ret['avoided_detection'] = this.avoided_detection; }
    if(this.weapon_facing_fudge) { ret['weapon_facing_fudge'] = this.weapon_facing_fudge; }
    if(this.muzzle_offset) { ret['muzzle_offset'] = this.muzzle_offset; }
    if(this.muzzle_height) { ret['muzzle_height'] = this.muzzle_height; }
    if(this.altitude) { ret['altitude'] = this.altitude; }
    if(this.flying) { ret['flying'] = this.flying; }
    return ret;
};

/** @override */
CombatStats.prototype.apply_snapshot = function(snap) {
    // clear to defaults
    if(!snap['incremental']) { this.clear(); }
    if('stunned' in snap) { this.stunned = snap['stunned']; }
    if('disarmed' in snap) { this.disarmed = snap['disarmed']; }
    if('damage_taken' in snap) { this.damage_taken = snap['damage_taken']; }
    if('damage_taken_from' in snap) { this.damage_taken_from = snap['damage_taken_from']; }
    if('rate_of_fire' in snap) { this.rate_of_fire = snap['rate_of_fire']; }
    if('accuracy' in snap) { this.accuracy = snap['accuracy']; }
    if('weapon_damage' in snap) { this.weapon_damage = snap['weapon_damage']; }
    if('weapon_damage_vs' in snap) { this.weapon_damage_vs = snap['weapon_damage_vs']; }
    if('effective_weapon_range' in snap) { this.effective_weapon_range = snap['effective_weapon_range']; }
    if('weapon_range' in snap) { this.weapon_range = snap['weapon_range']; }
    if('extra_armor' in snap) { this.extra_armor = snap['extra_armor']; }
    if('anti_air' in snap) { this.anti_air = snap['anti_air']; }
    if('anti_missile' in snap) { this.anti_missile = snap['anti_missile']; }
    if('turn_rate' in snap) { this.turn_rate = snap['turn_rate']; }
    if('ice_effects' in snap) { this.ice_effects = snap['ice_effects']; }
    if('swamp_effects' in snap) { this.swamp_effects = snap['swamp_effects']; }
    if('projectile_speed' in snap) { this.projectile_speed = snap['projectile_speed']; }
    if('splash_range' in snap) { this.splash_range = snap['splash_range']; }
    if('maxvel' in snap) { this.maxvel = snap['maxvel']; }
    if('erratic_flight' in snap) { this.erratic_flight = snap['erratic_flight']; }
    if('art_asset' in snap) { this.art_asset = snap['art_asset']; }
    if('invisible' in snap) { this.invisible = snap['invisible']; }
    if('detected' in snap) { this.detected = snap['detected']; }
    if('avoided_detection' in snap) { this.avoided_detection = snap['avoided_detection']; }
    if('weapon_facing_fudge' in snap) { this.weapon_facing_fudge = snap['weapon_facing_fudge']; }
    if('muzzle_offset' in snap) { this.muzzle_offset = snap['muzzle_offset']; }
    if('muzzle_height' in snap) { this.muzzle_height = snap['muzzle_height']; }
    if('altitude' in snap) { this.altitude = snap['altitude']; }
    if('flying' in snap) { this.flying = snap['flying']; }
};

// "merge" together two damage_vs tables, returning a table that has
// the multiplicative product of all entries from tables "a" and "b".
function merge_damage_vs(a, b) {
    var ret = {};
    for(var key in a) {
        if(!(key in ret)) {
            ret[key] = a[key];
        } else {
            ret[key] *= a[key];
        }
    }
    for(var key in b) {
        if(!(key in ret)) {
            ret[key] = b[key];
        } else {
            ret[key] *= b[key];
        }
    }
    return ret;
}

/** @return {number} */
GameObject.prototype.current_maxvel = function() {
    if('maxvel' in this.spec) {
        return player.get_any_abtest_value('global_maxvel_scale', gamedata['map']['global_maxvel_scale']) * this.get_leveled_quantity(this.spec['maxvel']) * this.combat_stats.maxvel;
    } else {
        return 0;
    }
};

GameObject.prototype.modify_stats_by_modstats = function() {};
GameObject.prototype.modify_stats_by_modstats_table = function(table) {
    if('maxvel' in table) { this.combat_stats.maxvel *= table['maxvel']['val']; }

    if('weapon_damage' in table) { this.combat_stats.weapon_damage *= table['weapon_damage']['val']; }
    if('weapon_range' in table) {
        this.combat_stats.weapon_range *= table['weapon_range']['val'];
        this.combat_stats.effective_weapon_range *= table['weapon_range']['val']; // also change effective_range
    }
    if('effective_weapon_range' in table) { this.combat_stats.effective_weapon_range *= table['effective_weapon_range']['val']; }

    // special case test
    if(('weapon_range_pvp' in table) && !session.home_base && !session.viewing_ai) {
        this.combat_stats.weapon_range *= table['weapon_range_pvp']['val'];
        this.combat_stats.effective_weapon_range *= table['weapon_range_pvp']['val']; // also change effective_range
    }

    if('accuracy' in table) { this.combat_stats.accuracy *= table['accuracy']['val']; }
    if('rate_of_fire' in table) { this.combat_stats.rate_of_fire *= table['rate_of_fire']['val']; }
    if('ice_effects' in table) { this.combat_stats.ice_effects *= table['ice_effects']['val']; }
    if('swamp_effects' in table) { this.combat_stats.swamp_effects *= table['swamp_effects']['val']; }
    if('damage_taken' in table) { this.combat_stats.damage_taken *= table['damage_taken']['val']; }
    if('armor' in table) {
        // XXX this should just be "armor" not "extra_armor" (?)
        this.combat_stats.extra_armor = Math.max(this.combat_stats.extra_armor, table['armor']['val'] - this.get_leveled_quantity(this.spec['armor']||0));
    }
    if('anti_air' in table) { this.combat_stats.anti_air = Math.max(this.combat_stats.anti_air, table['anti_air']['val']); }
    if('anti_missile' in table) { this.combat_stats.anti_missile *= table['anti_missile']['val']; }
    if('splash_range' in table) { this.combat_stats.splash_range *= table['splash_range']['val']; }

    if('weapon_facing_fudge' in table) { this.combat_stats.weapon_facing_fudge = table['weapon_facing_fudge']['val']; }
    if('muzzle_offset' in table) { this.combat_stats.muzzle_offset = table['muzzle_offset']['val']; }
    if('muzzle_height' in table) { this.combat_stats.muzzle_height = table['muzzle_height']['val']; }

    // apply weapon_damage_vs:something and damage_taken_from:something effects
    for(var key in table) {
        if(key.indexOf('weapon_damage_vs:') === 0) {
            var kind = key.split(':')[1];
            var cur_val = (kind in this.combat_stats.weapon_damage_vs ? this.combat_stats.weapon_damage_vs[kind] : 1.0);
            this.combat_stats.weapon_damage_vs[kind] = cur_val * table[key]['val'];
        } else if(key.indexOf('damage_taken_from:') === 0) {
            var kind = key.split(':')[1];
            var cur_val = (kind in this.combat_stats.damage_taken_from ? this.combat_stats.damage_taken_from[kind] : 1.0);
            this.combat_stats.damage_taken_from[kind] = cur_val * table[key]['val'];
        }
    }
};

/** @param {!World.World} world
    check for aura expiration, and apply aura modifiers to combat stats */
GameObject.prototype.update_and_apply_auras = function(world) {
    for(var i = 0; i < this.auras.length; i++) {
        var a = this.auras[i];
        if(!a.expire_tick.is_infinite() && GameTypes.TickCount.gt(session.get_real_world().combat_engine.cur_tick, a.expire_tick)) {
            this.auras.splice(i,1);
            i -= 1; // correction for loop iteration
            a.end(this);
            continue;
        }
        a.apply(world, this);
    }
};

/** @param {string} aura_name
    remove an aura with a specific name */
GameObject.prototype.remove_aura = function(aura_name) {
    for(var i = 0; i < this.auras.length; i++) {
        var a = this.auras[i];
        if(a.spec['name'] === aura_name) {
            this.auras.splice(i,1);
            a.end(this);
            return;
        }
    }
};

/** @param {!World.World} world */
GameObject.prototype.update_aura_effects = function(world) {
    goog.array.forEach(this.auras, function(aura) { aura.update_effect(world, this); }, this);
};

/** called once per tick
    @param {World.World|null} world - null for phantom/scenery objects */
GameObject.prototype.update_stats = function(world) {
    this.combat_stats.clear();
    this.combat_stats.invisible = this.is_invisible_default();
    this.combat_stats.weapon_facing_fudge = this.spec['weapon_facing_fudge'] || 0;
    this.combat_stats.muzzle_offset = this.spec['muzzle_offset'] || [0,0,0];
    this.combat_stats.muzzle_height = this.spec['muzzle_height'] || 0;
    this.combat_stats.flying = this.is_flying_default();
    this.combat_stats.altitude = this.default_altitude;
    this.modify_stats_by_modstats();
    if(world) {
        this.update_and_apply_auras(world);
    }
};

/** @param {!Base.Base} base */
GameObject.prototype.combat_power_factor = function(base) { return 1; };

// Return true if the ability identified by 'key' (usually spell name) is able to be used
/** @param {string} key
    @return {boolean} */
GameObject.prototype.get_cooldown = function(key) {
    if(key in this.cooldowns && GameTypes.TickCount.lte(session.get_real_world().combat_engine.cur_tick, this.cooldowns[key].expire_tick)) {
        // old timer is still active
        return false;
    } else {
        return true;
    }
};
/** @param {string} key
    @param {!GameTypes.TickCount} start
    @param {!GameTypes.TickCount} expire */
GameObject.prototype.set_cooldown = function(key, start, expire) {
    this.cooldowns[key] = { start_tick: start, expire_tick: expire };
};

/** @param {!World.World} world
    @param {!Array<!Object>} alist */
GameObject.prototype.receive_auras_update = function(world, alist) {
    // remove all permanent and expired auras
    for(var i = 0; i < this.auras.length; i++) {
        var a = this.auras[i];
        if(a.expire_tick.is_infinite() || GameTypes.TickCount.gt(world.combat_engine.cur_tick, a.expire_tick)) {
            this.auras.splice(i,1);
            i -= 1; // correction for loop iteration
            a.end(this);
            continue;
        }
    }

    if(!alist) { return; }
    for(var i = 0; i < alist.length; i++) {
        var data = alist[i];
        this.create_aura(world, null, null, data['name'], data['strength'],
                         ('duration' in data? relative_time_to_tick(data['duration']) : GameTypes.TickCount.infinity),
                         ('range' in data? data['range'] : -1));
    }
};

GameObject.prototype.is_weak_zombie = function() {
    if(this.auras) {
        for(var i = 0; i < this.auras.length; i++) {
            var spec = this.auras[i].spec;
            if('effects' in spec && spec['effects'].length > 0) {
                for(var j = 0; j < spec['effects'].length; j++) {
                    var eff = spec['effects'][j];
                    if(eff['code'] === 'weak_zombie') {
                        return true;
                    }
                }
            }
        }
    }
    return false;
};

function get_spec(specname) {
    var spec = gamedata['buildings'][specname] || gamedata['units'][specname] || gamedata['inert'][specname];
    if(!spec) {
        console.log('unknown spec name '+specname);
    }
    return spec;
}

// relink specs of all current objects into gamedata (called when gamedata is reloaded)
function reset_specs() {
    session.for_each_real_object(function(obj) {
        obj.spec = get_spec(obj.spec['name']);
    });
}

/** @param {!Object} data
    @param {boolean} init
    @param {boolean} is_deploying */
GameObject.prototype.receive_state = function(data, init, is_deploying) {
    this.id = /** @type {string} */ (data.shift());
    var specname = data.shift();
    this.spec = get_spec(specname);

    var newx = data.shift(), newy = data.shift();
    if((newx >= 0 && newy >= 0) || init) {
        // only apply position update if values are not -1,-1
        this.x = newx;
        this.y = newy;

        var ncells = session.viewing_base.ncells();
        this.x = clamp(this.x, 0, ncells[0]-1);
        this.y = clamp(this.y, 0, ncells[1]-1);
    }

    var updated_hp = data.shift();
    if(updated_hp >= 0) {
        this.hp = updated_hp;
    }
    this.max_hp = data.shift();
    this.team = data.shift();
    this.level = data.shift();
    this.equipment = data.shift();
    this.behaviors = data.shift();
    this.force_team = data.shift();

    this.update_stats(null);
    if(updated_hp >= 0) {
        this.state_dirty = 0;
    } else {
        this.state_dirty &= obj_state_flags.HP;
    }

    if(this.hp > this.max_hp) { console.log('hp disagreement '+this.hp+' '+this.max_hp); }
    //this.hp = Math.min(this.hp, this.get_leveled_quantity(this.spec['max_hp']));

    // initialize AI
    if(init && this.is_shooter()) {
        if(player.tutorial_state === "START" && this.team === 'player') {
            // special case for start of tutorial - don't have the player's units attack until moved manually
            this.ai_state = ai_states.AI_STOP;
        } else {
            // when in manual unit control, and deploying units into battle on hostile territory, start them in hold position
            if((session.viewing_base.base_landlord_id !== session.user_id) &&
               (this.team == 'player') &&
               (!get_preference_setting(player.preferences, 'auto_unit_control'))) {
                if('deploy_ai_order' in this.spec) {
                    this.ai_state = ai_state_values[this.spec['deploy_ai_order']['state']];
                } else {
                    this.ai_state = ai_state_values[gamedata['client']['default_deploy_ai_order']['manual']['state']];
                }
            } else {
                this.ai_state = ai_state_values[gamedata['client']['default_deploy_ai_order']['auto']['state']];
            }
        }
    }
};

function get_leveled_quantity(qty, level) {
    if((typeof qty) == 'undefined') {
        throw Error('get_leveled_quantity of undefined');
    }

    if(qty === null ||
       (typeof qty) === 'number' ||
       (typeof qty) === 'string' ||
       (typeof qty) === 'boolean') {
        return qty;
    } else if(0 in qty) {
        // hope it's an array
        return qty[level-1];
    } else {
        // anything else
        return qty;
    }
};

// some pieces of gamedata can be either scalars or arrays, this forces the result to an array
function get_as_array(qty) {
    if(0 in qty) { return qty; }
    return [qty];
};

// get a spec quantity that is possibly level-dependent (list indexed by level-1)
GameObject.prototype.get_leveled_quantity = function(qty) { return get_leveled_quantity(qty, this.level); }

/** Set new next_facing based on cur_facing and target_facing
    @param {!World.World} world */
GameObject.prototype.run_control_facing = function(world) {
    if('turn_rate' in this.spec) {

        if(this.is_building() && this.control_state === control_states.CONTROL_STOP &&
           !this.combat_stats.stunned && !(this.is_upgrading() || this.is_enhancing() || this.is_removing() || this.is_repairing() || this.disarmed)) {
            // idle turrets - rotate them around slowly
            var incr = gamedata['client']['turret_scan_speed']*Math.PI/180;
            incr *= this.combat_power_factor(world.base); // turn more slowly if depowered
            if(this.anim_offset > 0.5) { incr *= -1; }
            this.target_facing = normalize_angle(this.cur_facing + incr*TICK_INTERVAL);
        }

        // turn from cur_facing towards target_facing
        if(this.cur_facing != this.target_facing && !this.is_destroyed() && !this.combat_stats.stunned) {
            // how much the unit can turn in one tick
            // degrees/sec
            var max_degrees = this.combat_stats.turn_rate * this.get_leveled_quantity(this.spec['turn_rate'] || 230.0);
            // convert to radians/tick
            var turn_amount = Math.min(max_degrees*(Math.PI/180.0)*TICK_INTERVAL, Math.PI);

            // to avoid complex modulo math, do the computations with 2D vectors
            var cur = [Math.cos(this.cur_facing), Math.sin(this.cur_facing)];
            var tgt = [Math.cos(this.target_facing), Math.sin(this.target_facing)];

            var dot = cur[0]*tgt[0] + cur[1]*tgt[1];

            dot = Math.min(dot, 1); // avoid acos NaNs with rounding errors

            if(dot > Math.cos(turn_amount)) {
                // angle between vectors is less than turn_amount, snap to target
                this.next_facing = this.target_facing;
            } else {
                // angle between vectors is greater than turn_amount
                // choose direction to turn depending on Z component of cross product
                var cross = cur[0]*tgt[1] - cur[1]*tgt[0];
                if(cross > 0) {
                    this.next_facing = this.cur_facing + turn_amount;
                } else {
                    this.next_facing = this.cur_facing - turn_amount;
                }
            }
            this.next_facing = normalize_angle(this.next_facing);
        }
    }
};
/** @return {boolean} */
GameObject.prototype.is_building = function() { return (this.spec['kind'] === 'building'); };
/** @return {boolean} */
GameObject.prototype.is_mobile = function() { return (this.spec['kind'] === 'mobile'); };
/** @return {boolean} */
GameObject.prototype.is_flying = function() { return false; };
/** @return {boolean} */
GameObject.prototype.is_flying_default = function() { return false; };
/** @return {boolean} */
GameObject.prototype.is_inert = function() { return (this.spec['kind'] === 'inert'); };
/** @return {boolean} */
GameObject.prototype.is_blocker = function() { return false; };
/** @return {!Array.<number>} */
GameObject.prototype.raw_pos = function() { return [this.x, this.y]; };
/** @param {!World.World} world
    @return {!Array.<number>} */
GameObject.prototype.interpolate_pos = function(world) { return [this.x, this.y]; };
/** @param {!World.World} world
    @return {!Array.<number>} */
GameObject.prototype.interpolate_pos_for_draw = function(world) { return this.interpolate_pos(world); };
/** @param {!World.World} world
    @return {number} */
GameObject.prototype.interpolate_facing = function(world) {
    var progress = (visit_base_pending ? 1 : (client_time - world.last_tick_time)/(TICK_INTERVAL/combat_time_scale()));
    var ret;
    if(progress <= 0) {
        ret = this.cur_facing;
    } else if(progress >= 1) {
        ret = this.next_facing;
    } else {
        // Spherical linear interpolation - see https://en.wikipedia.org/wiki/Slerp
        var cur = [Math.cos(this.cur_facing), Math.sin(this.cur_facing)];
        var next = [Math.cos(this.next_facing), Math.sin(this.next_facing)];
        var cur_dot_next = vec_dot(cur, next);

        // avoid precision problems
        if(cur_dot_next >= 1 - ANGLE_EPSILON) { // angle almost zero - just snap to next
            ret = this.next_facing;
        } else if(cur_dot_next <= -1 + ANGLE_EPSILON) { // almost a perfect 180 degree turn
            ret = this.next_facing; // omega = Math.sqrt(2)/2; ?
        } else {
            var omega = Math.acos(cur_dot_next);
            var slerp_p0 = Math.sin((1-progress)*omega)/Math.sin(omega);
            var slerp_p1 = Math.sin(progress*omega)/Math.sin(omega);
            var slerp = vec_add(vec_scale(slerp_p0, cur), vec_scale(slerp_p1, next));
            ret = Math.atan2(slerp[1], slerp[0]);
            if(isNaN(ret)) {
                throw Error('slerp atan2 NaN: progress '+progress.toString()+' cur '+this.cur_facing.toString()+' next '+this.next_facing.toString()+' omega '+omega.toString());
            }
            ret = normalize_angle(ret);
        }
    }
    if(isNaN(ret)) {
        throw Error('NaN from interpolate_facing: progress '+progress.toString()+' cur '+this.cur_facing.toString()+' next '+this.next_facing.toString());
    }
    return ret;
};

/** @return {boolean} */
GameObject.prototype.is_invisible = function() { return false; };

/** @return {boolean} */
GameObject.prototype.is_invisible_default = function() { return false; };

/** @param {World.World|null} world
    return [[x,y], depth] for sprite drawing on game field */
GameObject.prototype.calc_draw_pos = function(world) {
    var p = (world ? this.interpolate_pos(world) : this.raw_pos());
    var depth = ortho_to_depth(p);
    return [p, depth];
};
/** @param {World.World|null} world */
GameObject.prototype.update_draw_pos = function(world) { this.draw_pos_cache = this.calc_draw_pos(world); };

/** @param {!World.World} world
    @param {!Array<number>} xy
    @param {!Array<number>} ji
    @param {number} zoom
    @param {number} fuzz
    @return {boolean} */
GameObject.prototype.detect_click = goog.abstractMethod;

/** @return {boolean} */
GameObject.prototype.is_indestructible = function() {
    return (this.max_hp === 0);
};
/** @return {boolean} */
GameObject.prototype.is_damaged = function() {
    if(this.max_hp === 0) { return false; } // indestructible object
    return (this.hp < this.max_hp);
};
/** @return {boolean} */
GameObject.prototype.is_destroyed = function() {
    if(this.max_hp === 0) { return false; } // indestructible object
    return (this.hp === 0) || (this.id === GameObject.DEAD_ID);
};
/** @return {boolean} */
GameObject.prototype.is_under_construction = function() {
    return false;
};

/** @return {boolean} */
GameObject.prototype.has_permanent_auras = function() {
    return(this.spec['permanent_auras'] || this.modstats['permanent_auras']);
};

/** @return {Array<Object<string,?>>|null} */
GameObject.prototype.get_permanent_auras_range = function() {
    var range = -1;
    var val = [];
    if(this.modstats['permanent_auras'] && this.modstats['permanent_auras']['val'] && this.modstats['permanent_auras']['val'].length >= 1) {
        val = this.modstats['permanent_auras']['val'];
    } else if(this.spec['permanent_auras'] && this.spec['permanent_auras'].length >= 1) {
        val = this.spec['permanent_auras'];
    }
    var check_val = null;
    if(Array.isArray(val) && val.length >= 1 && (Array.isArray(val[0]) || val[0] === null)) {
        check_val = get_leveled_quantity(val, this.level);
    } else {
        check_val = val;
    }
    goog.array.forEach(check_val, function(aura) {
        if('aura_range' in aura) {
            if(aura['aura_range'] * gamedata['map']['range_conversion'] > range) {
                range = aura['aura_range'] * gamedata['map']['range_conversion'];
            }
        };
    });

    return [check_val, range, false, -1, -1]; // returns in the same format as get_weapon_range()
};

function get_max_level(spec) {
    if('kind' in spec && spec['kind'] === 'mobile') {
        return spec['max_hp'].length;
    } else if('kind' in spec && spec['kind'] === 'building') {
        return spec['build_time'].length;
    } else if('kind' in spec && spec['kind'] === 'inert') {
        return spec['max_level'] || 1;
    } else if('research_time' in spec) {
        return spec['research_time'].length;
    } else if('enhance_time' in spec) {
        return spec['enhance_time'].length;
    } else if('craft_time' in spec) {
        return spec['craft_time'].length;
    } else {
        return 1;
    }
}

// return maximum level that should be displayed to players
// (may be lower than true max level)
function get_max_ui_level(spec) {
    var max_level = get_max_level(spec);
    if(!player.is_cheater && ('max_ui_level' in spec)) {
        max_level = Math.min(max_level, eval_cond_or_literal(spec['max_ui_level'], player, null));
    }
    return max_level;
}

GameObject.prototype.get_max_level = function() { return get_max_level(this.spec); };
GameObject.prototype.get_max_ui_level = function() { return get_max_ui_level(this.spec); };

// for an object at 'cur_level', find the next level at which stat 'statname' gets bigger
// if the object or stat is already maxed out, return -1
function get_next_level_with_stat_increase(spec, statname, cur_level) {
    var max_level = get_max_ui_level(spec);
    if(cur_level >= max_level) { return -1; }

    var cur_stat = get_leveled_quantity(spec[statname], cur_level);
    var max_stat = get_leveled_quantity(spec[statname], max_level);
    if(cur_stat >= max_stat) { return -1; }

    var next_level_that_gains_stat = cur_level + 1;
    while(get_leveled_quantity(spec[statname], next_level_that_gains_stat) <= cur_stat) {
        next_level_that_gains_stat += 1;
        if(next_level_that_gains_stat >= max_level) { break; }
    }
    return next_level_that_gains_stat;
}

/** @return {number} radius of "hitbox" - nonzero only for objects that cause collisions */
GameObject.prototype.hit_radius = function() { return 0; };

/** @return {Object<string,?>|null} */
GameObject.prototype.get_auto_spell = function() { return null; }; // for inerts etc
/** @return {number} */
GameObject.prototype.get_auto_spell_level = function() { return this.level; }; // index for stats of the auto spell

function is_melee_spell(spell) {
    if(spell['projectile_color'] === null && spell['projectile_speed'] < 0 &&
       ('priority_vs' in spell) && ('inaccessible' in spell['priority_vs'])) {
        return true;
    }
    return false;
}

function get_weapon_range(stats, level, spell) {
    var range = -1, trigger_range = -1, min_range = -1;

    if(spell && (spell['code'] == 'pbaoe') && ('splash_range' in spell)) {
        // max range at which damage is done
        range = gamedata['map']['splash_range_conversion'] * get_leveled_quantity(spell['splash_range'], level);
        // max range at which an attacker triggers the effect
        trigger_range = gamedata['map']['range_conversion'] * get_leveled_quantity(spell['range'] || -1, level);
        if(stats) {
            range *= stats.splash_range;
            trigger_range *= stats.weapon_range;
        }
    } else if(spell) {
        range = gamedata['map']['range_conversion'] * get_leveled_quantity(spell['range'] || -1, level);
        if(stats) {
            range *= stats.weapon_range;
        }
        if('min_range' in spell) {
            min_range = gamedata['map']['range_conversion'] * get_leveled_quantity(spell['min_range'] || -1, level);
        }
    }

    return [spell, range, (spell && ('splash_range' in spell)), trigger_range, min_range];
};

GameObject.prototype.is_shooter = function() { return (this.get_auto_spell() != null); };
GameObject.prototype.weapon_range = function() {
    var spell = this.get_auto_spell();

    // check for a continuously-casted PBAOE spell
    if(!spell) {
        var continuous_spell = this.spec['continuous_cast'] || null;
        if(this.is_building()) {
            continuous_spell = this.get_stat('continuous_cast', continuous_spell);
        } // XXX no case for units that have continuous_cast modded!

        if(continuous_spell) {
            var s = gamedata['spells'][continuous_spell];
            if(s['code'] == 'pbaoe' && 'splash_range' in s) { spell = s; }
        }
    }

    return get_weapon_range(this.combat_stats, this.get_auto_spell_level(), spell);
};
GameObject.prototype.is_invul = function() {
    return (this.spec['max_hp'] === 0) ||
        (this.spec['quarry_invul'] && session.is_quarry());
};

// return true if we have a weapon that can shoot at target (regardless of whether target is in range or not)
GameObject.prototype.can_shoot_at = function(target) {
    var auto_spell = this.get_auto_spell();
    if(!auto_spell) { return false; }
    if(target.is_invul()) { return false; }
    if('targets_nonmobile' in auto_spell && !auto_spell['targets_nonmobile'] && !target.is_mobile()) { return false; }
    if('help' in auto_spell && auto_spell['help'] && !target.is_damaged()) { return false; }
    if(target.is_flying()) {
        return (auto_spell['targets_air'] || this.combat_stats.anti_air);
    } else {
        return auto_spell['targets_ground'];
    }
};

GameObject.prototype.get_special_ability_spell = function() {
    var spell_name = null, spell = null;
    for(var i = 0; i < this.spec['spells'].length; i++) {
        spell_name = this.spec['spells'][i];
        var sp = gamedata['spells'][spell_name];
        if((sp['activation'] === 'instant' || sp['activation'] === 'targeted_area') &&
           spell_name !== 'MOVE_UNIT' &&
           (!sp['developer_only'] || (!spin_secure_mode && player.is_developer()))) {
            spell = sp; break;
        }
    }
    if(!spell) { return null; }
    return [spell_name, spell];
};

/** @param {!World.World} world */
GameObject.prototype.use_special_ability = function(world) {
    var name_sp = this.get_special_ability_spell();
    if(!name_sp) { return false; }
    var spell_name = name_sp[0], spell = name_sp[1];
    if(spell['activation'] === 'instant') {
        return this.cast_client_spell(world, spell_name, spell, this, null);
    } else if(spell['activation'] === 'targeted_area') {
        if(!this.get_cooldown(spell_name)) { return; }
        selection.spellname = spell_name;
        var range = gamedata['map']['range_conversion'] * this.get_leveled_quantity(spell['range'] || 0);
        var splash = gamedata['map']['splash_range_conversion'] * this.get_leveled_quantity(spell['splash_range'] || 0) * this.combat_stats.splash_range;
        change_selection_ui(new AOEUICursor(this, range, splash));
        return false;
    } else {
        console.log('unhandled ability activation type '+spell['activation']);
    }
    return false;
}

/** @param {!World.World} world
    @param {string} spell_name
    @param {Object} spell
    @param {GameObject|null} target
    @param {Array.<number>|null} location
    Same as cast_client_spell, but has no effect if the spell is not castable by this unit */
GameObject.prototype.cast_client_spell_checked = function(world, spell_name, spell, target, location) {
    var found = false;
    for(var i = 0; i < this.spec['spells'].length; i++) {
        if(this.spec['spells'][i] === spell_name) {
            found = true;
            break;
        }
    }
    if(found) {
        return this.cast_client_spell(world, spell_name, spell, target, location);
    } else {
        return false;
    }
};

/** @param {!World.World} world
    @param {string} spell_name
    @param {Object} spell
    @param {GameObject|null} target
    @param {Array.<number>|null} location */
GameObject.prototype.cast_client_spell = function(world, spell_name, spell, target, location) {
    // check for cooldowns
    if(!this.get_cooldown(spell_name)) {
        // can't fire yet - on cooldown
        return false;
    }

    if(spell['deployment_arming_delay'] && this.combat_stats.disarmed) {
        // can't fire yet - still arming
        return false;
    }

    if('applies_aura' in spell) {
        if(Array.isArray(spell['applies_aura'])) {
            goog.array.forEach(spell['applies_aura'], function(aura) {
                var aura_name = aura['aura_name'];
                var strength = this.get_leveled_quantity(aura['aura_strength'] || 1);
                var duration = this.get_leveled_quantity(aura['aura_duration'] || -1);
                var range = this.get_leveled_quantity(aura['aura_range'] || 0);
                this.create_aura(world, null, null, aura_name, strength, (duration < 0 ? GameTypes.TickCount.infinity : relative_time_to_tick(duration)), range);
            }, this);
        } else {
            var aura_name = spell['applies_aura'];
            var strength = this.get_leveled_quantity(spell['aura_strength'] || 1);
            var duration = this.get_leveled_quantity(spell['aura_duration'] || -1);
            var range = this.get_leveled_quantity(spell['aura_range'] || 0);
            this.create_aura(world, null, null, aura_name, strength, (duration < 0 ? GameTypes.TickCount.infinity : relative_time_to_tick(duration)), range);
        }
    }

    if('code' in spell) {
        var code = spell['code'];
        if(code === 'pbaoe') {
            var radius, radius_rect;
            if(spell['splash_radius_from_gridsize']) {
                radius = -1;
                radius_rect = this.spec['gridsize'];
            } else {
                radius = gamedata['map']['splash_range_conversion'] * this.get_leveled_quantity(spell['splash_range'] || 0) * this.combat_stats.splash_range;
                radius_rect = null;
            }

            var cooldown = this.get_leveled_quantity(spell['cooldown'] || 1.0);
            // note: damage in spells.json is PER SECOND
            var damage = this.get_leveled_quantity(spell['damage']) * cooldown;

            var impact_pos = this.raw_pos();

            if(spell['kills_self']) {
                // Detonator droid/landmine
                // queue BEFORE other damage so it's listed in this order in the battle log
                var death_client_time = client_time + (spell['kills_self_delay']||0);
                var death_tick = GameTypes.TickCount.add(world.combat_engine.cur_tick,
                                                         relative_time_to_tick(/** @type {number} */ (spell['kills_self_delay']||0)));
                var death_method = ('kills_self_method' in spell ? spell['kills_self_method'] : 'hostile');
                world.combat_engine.queue_damage_effect(new CombatEngine.KillDamageEffect(death_tick, death_client_time, this.id, null, this.id, death_method));
            }

            if(spell['impact_auras']) {
                for (var i = 0; i < spell['impact_auras'].length; i++) {
                    var imp_aura = spell['impact_auras'][i];
                    var strength = this.get_leveled_quantity(imp_aura['strength'] || 1);
                    if(imp_aura['strength_mod_by_weapon_damage']) {
                        strength *= this.combat_stats.weapon_damage;
                    }
                    var effect = new CombatEngine.AreaAuraEffect(world.combat_engine.cur_tick, client_time, this.id, this.team, impact_pos,
                                                    ('targets_ground' in spell ? spell['targets_ground'] : 1),
                                                    ('targets_air' in spell ? spell['targets_air'] : 1),
                                                    radius, radius_rect,
                                                    this.get_leveled_quantity(spell['splash_falloff'] || 'linear'),
                                                    strength,
                                                    this.get_leveled_quantity(imp_aura['spec']),
                                                    relative_time_to_tick(this.get_leveled_quantity(imp_aura['duration'] || 1)),
                                                    this.get_leveled_quantity(imp_aura['range'] || 0),
                                                    spell['damage_vs'] || {}, imp_aura['duration_vs'] || {},
                                                    spell['always_friendly_fire'] || false);
                    world.combat_engine.queue_damage_effect(effect);
                }
            }

            var effect = new CombatEngine.AreaDamageEffect(world.combat_engine.cur_tick, client_time, this.id, this.team, impact_pos,
                                              ('targets_ground' in spell ? spell['targets_ground'] : 1),
                                              ('targets_air' in spell ? spell['targets_air'] : 1) || this.combat_stats.anti_air,
                                              radius,
                                              this.get_leveled_quantity(spell['splash_falloff'] || 'linear'),
                                              damage, spell['damage_vs'] || {},
                                              spell['always_friendly_fire'] || false);
            world.combat_engine.queue_damage_effect(effect);

            // note: use both muzzle_flash and impact, because impact location is the object's own location
            var vfx = spell['visual_effect'] || spell['muzzle_flash_effect'] || spell['impact_visual_effect'] || null;
            if(vfx) {
                var vfx_props = {'dest': null}; // special case: inhibit PhantomUnits from spawning (since this is a self-destruct, not an offensive shot)
                world.fxworld.add_visual_effect_at_time(impact_pos, 0, [0,1,0], client_time, this.get_leveled_quantity(vfx), true, vfx_props);
            }
        } else if(code === 'projectile_attack') {
            // make sure casting unit isn't a weak zombie
            for(var i = 0; i < this.auras.length; i++) {
                var a = this.auras[i];
                if(a.spec['name'] === 'weak_zombie') {
                    var weak_zombie_message = gamedata['errors']['CANNOT_FIRE_PROJECTILE_WHILE_WEAK_ZOMBIE']['ui_name'];
                    if('weak_zombie_messages' in gamedata['strings'] && this.spec['name'] in gamedata['strings']['weak_zombie_messages'] && spell['name'] in gamedata['strings']['weak_zombie_messages'][this.spec['name']]) {
                        weak_zombie_message = gamedata['strings']['weak_zombie_messages'][this.spec['name']][spell['name']];
                    }
                    user_log.msg(weak_zombie_message.replace('%pct', (100 * gamedata['zombie_debuff_threshold']).toFixed()), new SPUI.Color(1,0,0,1));
                    return false;
                }
            }
            // make sure we are in range
            if(location) {
                var range = gamedata['map']['range_conversion'] * this.get_leveled_quantity(spell['range'] || 0);
                var dist = vec_distance(this.raw_pos(), location);
                //console.log('range: dist '+dist+' range '+range+' loc '+location);
                if(dist > range) {
                    return false;
                }
                this.fire_projectile(world, world.combat_engine.cur_tick, client_time, null, -1, spell, this.level, target, location, 0); // use object level for the spell
            } else {
                throw Error('projectile_attack with no location from '+this.spec['name']);
            }
        } else if(code === 'retreat_unit') {
            // remove the unit peacefully from the world.
            // no debris is spawned. But the unit does go down to 0 HP and counts as "destroyed" in the battle.

            flush_dirty_objects({}); // ensure latest damage HP values are sent to the server, for determining post-retreat secteam health

            world.send_and_destroy_object(this, this, 'retreat');

            if('muzzle_flash_effect' in spell) {
                // instance properties passed to vfx system
                var vfx_props = {'heading': this.cur_facing,
                                 'tick_offset': 0,
                                 'my_next_pos': this.next_pos};
                var muzzle_vfx = spell['muzzle_flash_effect'];
                world.fxworld.add_visual_effect_at_tick(this.interpolate_pos(world), (this.is_flying() ? this.combat_stats.altitude : 0),
                                                        [Math.cos(this.cur_facing), 0, Math.sin(this.cur_facing)],
                                                        world.combat_engine.cur_tick, 0,
                                                        muzzle_vfx, true, vfx_props);
            }
        }
    }

    var visual_cooldown = 0;
    if('cooldown' in spell) {
        var cd_seconds = this.get_leveled_quantity(spell['cooldown']);
        if(this.is_building()) {
            cd_seconds /= this.combat_power_factor(world.base); // increase cooldown if power_factor < 1
        }
        var cd_ticks = Math.floor(cd_seconds/TICK_INTERVAL);
        visual_cooldown = client_time + (cd_ticks+1)*TICK_INTERVAL;
        this.set_cooldown(spell_name, world.combat_engine.cur_tick, GameTypes.TickCount.add(world.combat_engine.cur_tick, new GameTypes.TickCount(cd_ticks)));
    }

    if(global_spell_icon && global_spell_icon.unit === this) {
        global_spell_icon.activated = client_time;
        global_spell_icon.cooldown = visual_cooldown;
    }

    return true;
};

/** @param {!World.World} world
    @param {GameObjectId|null} creator_id
    @param {string|null} creator_team
    @param {string} aura_name
    @param {?} strength
    @param {!GameTypes.TickCount} duration
    @param {number} range
    @param {Object=} vs_table */
GameObject.prototype.create_aura = function(world, creator_id, creator_team, aura_name, strength, duration, range, vs_table) {
    var aura_spec = gamedata['auras'][aura_name];
    if(!aura_spec) {
        throw Error('Bad aura name ' + aura_name);
    }
    var end_tick;
    if(duration.is_infinite()) {
        end_tick = GameTypes.TickCount.infinity; // infinite
    } else {
        end_tick = GameTypes.TickCount.add(session.get_real_world().combat_engine.cur_tick, duration);
    }

    var i;

    if(aura_spec['stacking'] !== 'independent') {
        // check for existing applications of the aura, and update them if found
        for(i = 0; i < this.auras.length; i++) {
            if(this.auras[i].spec === aura_spec) {
                if(typeof this.auras[i].strength === 'number' && typeof strength === 'number') {
                    // both old and new strength are numbers, so use the max
                    this.auras[i].strength = Math.max(this.auras[i].strength, strength);
                } else {
                    // not a number - overwrite the existing strength
                    this.auras[i].strength = strength;
                }
                this.auras[i].range = Math.max(this.auras[i].range, range);
                this.auras[i].start_tick = session.get_real_world().combat_engine.cur_tick;
                if(creator_id) {
                    this.auras[i].source_id = creator_id;
                    this.auras[i].source_team = creator_team;
                }
                if(!this.auras[i].expire_tick.is_infinite()) {
                    this.auras[i].expire_tick = GameTypes.TickCount.max(this.auras[i].expire_tick, end_tick);
                }
                break;
            }
        }
    } else {
        i = this.auras.length;
    }

    if(i >= this.auras.length) {
        // no existing applications, create one
        this.auras.push(new Aura(creator_id, creator_team, aura_spec, strength, range, world.combat_engine.cur_tick, end_tick, vs_table));
    }

    this.serialization_dirty = true;
};

GameObject.prototype.speak = function(name) {
    var field = 'sound_'+name;
    if(!(field in this.spec)) { return; }
    if(this.last_speak_sound == name && (client_time - this.last_speak_time) < gamedata['client']['min_speak_interval']) { return; }
    this.last_speak_sound = name;
    this.last_speak_time = client_time;
    GameArt.play_canned_sound(this.spec[field]);
};

/** Modify damage by vs_table coefficients on the weapon vs. a specific target

    This multiplies matching damage_vs values on the weapon by defense_types that the target is marked with.

    It also supports compound keys, which are multiple defense_types separated by commas.
    The keys are ANDded together, and can be negated by prefixing a key with "!".

    e.g., "building,!turret" means (building AND (NOT turret))
          "building,'turret" means (building AND turret)

    Finally, we also apply the target's damage_taken_from modifiers to the weapon.

    @param {Object.<string,number>} vs_table
    @param {GameObject} target
    @return {CombatEngine.Coeff} */
function get_damage_modifier(vs_table, target) {
    var damage_mod = 1;
    if(vs_table) {
        if(!('defense_types' in target.spec)) {
            if('default' in vs_table) {
                damage_mod *= vs_table['default'];
            }
        } else {
            for(var i = 0; i < target.spec['defense_types'].length; i++) {
                var kind = target.spec['defense_types'][i];
                if(kind in vs_table) {
                    var coeff = vs_table[kind];
                    damage_mod *= coeff;
                }
            }

            // check for compound terms in the vs_table
            for(var kind in vs_table) {
                if(kind.indexOf(',') !== -1) {
                    var terms = kind.split(',');
                    var match = true;
                    for(var j = 0; j < terms.length; j++) {
                        var term = terms[j];
                        // check for negated terms
                        var negate = false
                        if(term[0] === '!') {
                            negate = true;
                            term = term.slice(1);
                        }
                        // is this term present in defense_types?
                        if(goog.array.contains(target.spec['defense_types'], term)) {
                            if(negate) {
                                match = false;
                                break;
                            }
                        } else if(!negate) {
                            match = false;
                            break;
                        }
                    }
                    if(match) {
                        damage_mod *= vs_table[kind];
                        // console.log('match '+target.spec.name +' by '+kind+' -> '+vs_table[kind].toString());
                    }
                }
            }
        }

        // check the target's damage_taken_from stat
        for(var kind in vs_table) {
            if(kind in target.combat_stats.damage_taken_from) {
                damage_mod *= vs_table[kind] * target.combat_stats.damage_taken_from[kind];
            // note: completely override the native table, if present in combat_stats
            } else if('damage_taken_from' in target.spec && kind in target.spec['damage_taken_from']) {
                damage_mod *= vs_table[kind] * target.get_leveled_quantity(target.spec['damage_taken_from'][kind]);
            }
        }
    }
    return damage_mod;
};

function check_battle_outcome() {
    if(!session.battle_outcome_dirty) { return; }
    if(!synchronizer.is_in_sync(session.battle_outcome_sync_marker)) { return ; } // waiting for server to sync up
    session.battle_outcome_dirty = false;

    var outcome = calculate_battle_outcome();
    if(outcome != 'undecided') {
        if(session.home_base && (player.tutorial_state === 'wait_for_battle_finish')) {
            window.setTimeout(advance_tutorial, 1000);
        }
        var DELAY = gamedata['client']['battle_end_delay'];
        if(session.attack_finish_time <= 0 || (session.attack_finish_time - server_time > DELAY)) {
            session.set_attack_finish_time(server_time + DELAY);

            // set attacking units to hold position (celebration time, they won!)
            if(!session.home_base) {
                var order = {'state': ai_states.AI_ATTACK_STATIONARY, 'aggressive': false};
                session.for_each_real_object(function(obj) {
                    if(!obj.is_destroyed() && obj.is_mobile() && obj.team == 'player') {
                        obj.new_order(session.get_real_world(), order, true);
                    }
                });
            }
        }
    }
}

function calculate_battle_outcome() {
    var victory = true, defeat = true;

    if(session.home_base) {
        // home-turf battles are won if all enemy attackers are dead
        // and lost if all player units and buildings are dead

        if(session.incoming_attack_units.length > 0) {
            // more waves are yet to come
            return 'undecided';
        }

        session.for_each_real_object(function(obj) {
            if(obj.team === 'enemy' && !obj.is_destroyed()) {
                victory = false;
            }
            if(obj.team === 'player' && !obj.is_destroyed()) {
                defeat = false;
            }
        });
    } else {
        // foreign-turf battles are won if all enemy units and buildings are dead
        // and UNDECIDED if all player units are dead (let player End Attack manually)

        var ai_data = session.viewing_base.get_ai_base_data();

        session.for_each_real_object(function(obj) {

            // do not count barriers
            if(obj.spec['name'] === 'barrier') { return; }

            // do not count invulnerable objects (e.g. quarry harvesters)
            if(obj.is_invul()) { return; }

            if(player.tutorial_state != "COMPLETE") {
                // special case for tutorial: end battle once the three main buildings are destroyed
                var tut_targets = gamedata['tutorial']['wait_battle_finish2']['targets'];
                if(obj.team === 'enemy' && !obj.is_destroyed() && obj.spec['name'] in tut_targets) {
                    victory = false;
                }
            } else {
                if(ai_data && ai_data['timed_challenge']) {
                    // timed challenge - count only the enemy TOC
                    if(obj.team === 'enemy' && !obj.is_destroyed() && obj.spec.name === gamedata['townhall']) {
                        victory = false;
                    }
                } else {
                    // count any enemy object, except for landmines
                    if(obj.team === 'enemy' && !obj.is_destroyed() &&
                       !(obj.is_building() && (obj.is_minefield() || obj.is_ambush()))) {
                        victory = false;
                    }
                }
            }

            if(obj.team === 'player' && !obj.is_destroyed()) {
                defeat = false;
            }
        });

        if(player.tutorial_state == "COMPLETE" && !gamedata['client']['end_battle_on_defeat']) {
            defeat = false; // allow battle to go on even if player has no units left
        }

        // don't end the battle if the player has any more deployable units
        if(defeat && session.viewing_base.deployment_allowed &&
           (session.count_deployable_units() > 0 || session.count_pre_deploy_donated_units() > 0)) {
            defeat = false;
        }

        // don't end the battle if the player has usable combat items
        if(defeat && session.viewing_base.deployment_allowed) {
            goog.array.forEach(session.home_equip_items, function(entry) {
                if(inventory_item_is_usable_in_combat(ItemDisplay.get_inventory_item_spec(entry['item']['spec']), session) >= UsableInCombat.USABLE_MISSILE) {
                    defeat = false;
                }
            });
        }
        if(defeat && session.viewing_base.deployment_allowed) {
            for(var i = 0; i < player.inventory.length; i++) {
                var item = player.inventory[i];
                if(inventory_item_is_usable_in_combat(ItemDisplay.get_inventory_item_spec(item['spec']), session) >= UsableInCombat.USABLE_MISSILE) {
                    defeat = false;
                    break;
                }
            }
        }

        // check for inbound missiles and damage over time effects
        if(defeat && session.get_real_world().combat_engine.has_queued_effects()) {
            defeat = false;
            session.no_more_units = true;
        }
    }

    if(victory) {
        return 'victory';
    } else if(defeat) {
        return 'defeat';
    } else {
        return 'undecided';
    }
}

/** Advance time-interpolated variables */
GameObject.prototype.run_control_prep = function() {
    this.cur_facing = this.next_facing;
    if(this.control_cooldown > 0) {
        this.control_cooldown -= 1;
    }
};

/** @param {!World.World} world */
GameObject.prototype.run_control_pathing = function(world) {};

/** @param {!World.World} world */
GameObject.prototype.run_control_shooting = function(world) {

    if(this.is_destroyed() || this.combat_stats.stunned) { return; }

    if(this.control_state === control_states.CONTROL_SHOOT) {
        this.serialization_dirty = true;

        var target = world.objects._get_object(this.control_target_id);

        // turn to face target
        if(target && 'turn_rate' in this.spec) {
            var dir = vec_sub(target.raw_pos(), this.raw_pos());
            if((dir[1]*dir[1]+dir[0]*dir[0]) > 0.0001) {
                this.target_facing = normalize_angle(Math.atan2(dir[1], dir[0]));
            }
        }


        if((this.control_cooldown <= 0) &&
           (!this.combat_stats.disarmed) &&
           !(this.is_building() && (this.is_upgrading() || this.is_enhancing() || this.is_removing() || this.is_repairing() || this.disarmed)) &&
           (!this.is_under_construction()) &&
           (!this.is_destroyed())) {

            if(player.tutorial_state != "COMPLETE") {
                if('disable_combat' in gamedata['tutorial'][player.tutorial_state] &&
                   gamedata['tutorial'][player.tutorial_state]['disable_combat']) {
                    // no shooting until after the first part of the tutorial
                    return;
                }
            }

            if(!target || target.is_destroyed()) {
                // target is already dead
                this.control_state = control_states.CONTROL_STOP;
                return;
            }

            var spell = gamedata['spells'][this.control_spellname];
            if (!spell) {
                throw Error(this.control_spellname + ' missing from gamedata, needed by ' + this.spec['name']);
            }
            var spell_level = this.get_auto_spell_level(); // assumes auto_spell here

            if(('firing_arc' in spell) && ('turn_rate' in this.spec)) {
                // convert max angle difference to radians
                var max_arc = Math.min(get_leveled_quantity(spell['firing_arc'], spell_level)*(Math.PI/180.0), Math.PI);

                // to avoid complex modulo math, do the computations with 2D vectors
                var cur = [Math.cos(this.cur_facing), Math.sin(this.cur_facing)];
                var tgt = [Math.cos(this.target_facing), Math.sin(this.target_facing)];

                // dot product between current and target headings
                var dot = cur[0]*tgt[0] + cur[1]*tgt[1];
                dot = Math.min(dot, 1); // avoid acos NaNs with rounding errors

                if(Math.acos(dot) > max_arc) {
                    // not facing close enough to the right direction yet, wait before shooting
                    return;
                }
            }

            var cooldown = get_leveled_quantity(spell['cooldown'], spell_level);

            var cd = cooldown/this.combat_stats.rate_of_fire;
            cd /= this.combat_power_factor(world.base); // increase cooldown if power_factor < 1
            this.control_cooldown = Math.floor(cd/TICK_INTERVAL);

            if('cooldown_name' in spell) {
                // trigger non-auto-attack cooldown
                if(!this.get_cooldown(spell['cooldown_name'])) { return; }
                var cd_ticks = Math.floor(get_leveled_quantity(spell['cooldown'], spell_level)/TICK_INTERVAL);
                this.set_cooldown(spell['cooldown_name'], world.combat_engine.cur_tick,
                                  GameTypes.TickCount.add(world.combat_engine.cur_tick, new GameTypes.TickCount(cd_ticks)));
            }

            var target_pos, target_height;

            if(spell['targets_self']) {
                target_pos = this.raw_pos();
                target_height = this.is_flying() ? this.combat_stats.altitude : 0;
            } else {
                target_pos = target.raw_pos();
                target_height = target.is_flying() ? target.combat_stats.altitude : 0;
            }

            this.fire_projectile(world, world.combat_engine.cur_tick, client_time, null, -1, spell, spell_level, target, target_pos, target_height);
        }
    }

    var continuous_spell = this.spec['continuous_cast'] || null;
    if(this.is_building()) {
        continuous_spell = this.get_stat('continuous_cast', continuous_spell);
    } // XXX no case for units that have continuous_cast modded!

    if(continuous_spell &&
       (this.is_inert() ||
        (!this.is_destroyed() &&
         this.control_state === control_states.CONTROL_STOP &&
         !(this.is_building() && (this.is_under_construction() || this.is_upgrading() || this.is_enhancing() || this.is_removing() || this.is_repairing() || this.disarmed))))) {
        this.serialization_dirty = true;
        this.cast_client_spell(world, continuous_spell, gamedata['spells'][continuous_spell], null, null);
    }
};

/** adjust a shot vector to aim ahead of a target (from a stationary shooter), extrapolating its path linearly to impact
 * @param {!Array.<number>} P shot vector from shooter to target at proposed impact time
 * @param {!Array.<number>} target_vel velocity vector of target
 * @param {number} speed of bullet
 * @returns {number} time-of-flight of bullet, when fired in a way that will hit target at its linearly-extrapolated location
 * note: may fail to compute a time-of-flight if the target is moving away faster than the bullet can fly, in which case, returns -1.
 */
function apply_target_lead(P, target_vel, speed) {
    // attempt an accurate quadratic solution that takes into account target range changing with velocity
    // see http://playtechs.blogspot.com/2007/04/aiming-at-moving-target.html
    var a = speed*speed - vec_length2(target_vel);
    var b = vec_dot(P, target_vel);
    var c = vec_dot(P, P);
    var d = b*b + a*c;
    var t = -999;
    if(d > 0) {
        var root0 = (b - Math.sqrt(d)) / a;
        var root1 = (b + Math.sqrt(d)) / a;
        t = root0;
        if(t < 0 || (root1 >= 0 && root1 < t)) {
            t = root1;
        }
    }

    if(t > 0) {
        // only use the quadratic solution if a valid root is found
        // one might NOT be found if the target is moving away faster than the bullet can fly
        return t;
    }
    return -1; // no solution found
}

var no_miss_hack_reported = false;


/** @param {!World.World} world
    @param {GameObject|null} my_source
    @param {GameObjectId} my_id
    @param {string} my_spec_name
    @param {number} my_level
    @param {TeamId} my_team
    @param {Object} my_stats
    @param {!Array.<number>} my_pos
    @param {number} my_height
    @param {Array.<number>} my_muzzle_pos
    @param {number} fire_time
    @param {number} force_hit_time
    @param {Object} spell
    @param {GameObject|null} target
    @param {!Array.<number>} target_pos
    @param {number} target_height
    @param {boolean} fizzle
    @return {number}
*/
function do_fire_projectile_time(world, my_source, my_id, my_spec_name, my_level, my_team, my_stats, my_pos, my_height, my_muzzle_pos, fire_time, force_hit_time, spell, target, target_pos, target_height, fizzle) {
    var max_range = gamedata['map']['range_conversion'] * get_leveled_quantity(spell['range'], my_level) * (my_stats ? my_stats.weapon_range : 1);
    var eff_range = ('effective_range' in spell ? (gamedata['map']['range_conversion'] * get_leveled_quantity(spell['effective_range'], my_level) * (my_stats ? my_stats.effective_weapon_range : 1)) : max_range);
    var shot_v = vec_sub(target_pos, my_pos);

    var shot_length;
    if(spell['distance_calc'] == '3d') {
        shot_length = v3_distance([my_pos[0], my_height, my_pos[1]], [target_pos[0], target_height, target_pos[1]]);
        // don't throw off the accuracy calculation below! hack - eventually we should use full 3D math for all target range calcs.
        max_range += Math.abs(target_height - my_height);
        eff_range += Math.abs(target_height - my_height);
    } else if(vec_equals(shot_v, [0,0])) {
        // hack - pure vertical shots
        shot_length = target_height - my_height;
    } else {
        shot_length = vec_length(shot_v);
    }

    // adjust target_pos and shot_length to account for non-zero hitbox radius
    if(target) {
        var rad = target.hit_radius();
        if(rad > 0) {
            if(shot_length > rad+0.001) {
                var new_shot_length = (shot_length - rad);
                target_pos = vec_mad(my_pos, (new_shot_length/shot_length), shot_v);
                shot_v = vec_sub(target_pos, my_pos);
                shot_length = new_shot_length;
            }
        }
    }

    var damage;
    var damage_vs = spell['damage_vs'] || {};
    if(fizzle) {
        damage = 0;
    } else {
        damage = get_leveled_quantity(spell['damage'], my_level);

        if(damage != 0) {
            // damage in spec file is PER SECOND, must convert it to PER SHOT
            damage *= get_leveled_quantity(spell['cooldown'] || 1, my_level);
            if(my_stats) {
                // apply combat stat modifiers
                damage *= my_stats.weapon_damage;
                damage_vs = merge_damage_vs(damage_vs, my_stats.weapon_damage_vs);
            }

            // quantize damage to integers, and set lower bound to 1
            if(damage >= 0) {
                damage = Math.max(Math.ceil(damage), 1);
            } else {
                damage = Math.min(Math.ceil(damage), -1);
            }
        }
    }

    var speed = player.get_any_abtest_value('global_projectile_speed_scale', gamedata['map']['global_projectile_speed_scale']) * get_leveled_quantity(spell['projectile_speed'] || 0, my_level) * (my_stats ? my_stats.projectile_speed : 1) * combat_time_scale();
    // use_lead actually changes combat target position for splash weapons
    // for non-splash weapons, it affects graphics only (since hits are computed independently)
    var use_lead = get_leveled_quantity(spell['lead_target'] || 0, my_level);
    var lead_applied = false;
    var arc = world.fxworld.global_gravity * get_leveled_quantity(spell['projectile_arc'] || 0, my_level);
    var copies = get_leveled_quantity(spell['projectile_burst_size'] || 1, my_level);
    if(SPFX.detail < 1) {
        copies = Math.min(Math.max(Math.floor(SPFX.detail * copies), 1), 2);
    }
    var interval = get_leveled_quantity(spell['projectile_burst_interval'] || 0, my_level);
    var prefire_delay = get_leveled_quantity(spell['prefire_delay'] || 0, my_level) / combat_time_scale();
    var postfire_delay = get_leveled_quantity(spell['postfire_delay'] || 0, my_level) / combat_time_scale();

    var shot_time, shot_height;
    if(speed > 0) {
        // account for projectile travel time
        var P = shot_v;
        shot_time = shot_length/speed;
        shot_height = shot_length * arc;

        // fire splash weapons at extrapolated target position
        if(use_lead > 0 && ('splash_range' in spell) && target && target.is_mobile() && (target.vel[0] != 0 || target.vel[1] != 0)) {
            lead_applied = true;

            if(prefire_delay+postfire_delay > 0) {
                P = vec_mad(P, prefire_delay+postfire_delay, target.vel);
            }
            var lead_shot_time = apply_target_lead(P, target.vel, speed);
            if(lead_shot_time >= 0) {
                shot_time = lead_shot_time;
            }

            // propose extrapolated target position
            var test_pos = vec_mad(target_pos, (shot_time + prefire_delay + postfire_delay) * use_lead, target.vel);

            // constrain impact distance by maximum weapon range
            var test_len = vec_distance(test_pos, my_pos);
            if(test_len > max_range) {
                //console.log('CONSTRAIN test_len '+test_len.toFixed(3)+ ' max '+max_range.toFixed(3));

                // constrain to max range
                target_pos = vec_mad(my_pos, max_range, vec_normalized(vec_sub(test_pos, my_pos)));
                // recompute shot_time
                shot_time = max_range / speed;
            } else {
                // use proposed position
                target_pos = test_pos;
            }

            // recompute shot_v and shot_length
            shot_v = vec_sub(target_pos, my_pos);
            shot_length = vec_length(shot_v);

            //console.log('shot_time '+shot_time.toFixed(3)+' t '+t.toFixed(3)+' max '+max_shot_time.toFixed(3));
        }

    } else {
        // instant hit
        shot_time = 0;
        shot_height = 0;
    }

    // hit_time is the time at which the bullet will reach its final destination
    // hit_time+postfire_delay is when it will explode and do damage

    var hit_time, impact_spread;
    if(force_hit_time > 0) {
        hit_time = force_hit_time;
        impact_spread = 0; // shoot directly at target location
    } else {
        hit_time = fire_time + prefire_delay + shot_time;
        impact_spread = get_leveled_quantity(spell['projectile_impact_spread'] || 1.5, my_level);
    }

    var miss = 0; // nonzero if the shot is a miss
    var accuracy = get_leveled_quantity(spell['accuracy'] || 1, my_level) * (my_stats ? my_stats.accuracy : 1);
    if(shot_length > eff_range) { // degrade accuracy linearly between eff_range and max_range
        //console.log("MISS! "+shot_length.toString()+" eff "+eff_range.toString());
        accuracy *= 1 - (shot_length-eff_range)/(max_range-eff_range);
    }
    if(accuracy < 1) {
        if(Math.random() >= accuracy) {
            // miss
            miss = 1;
            impact_spread *= 3;
        }
        //console.log('range '+shot_length.toFixed(1)+' ('+eff_range.toFixed(1)+'-'+max_range.toFixed(1)+') accuracy '+accuracy.toFixed(2));
    }

    if(miss && spell['no_miss_hack']) { // XXX temporary band-aid fix for unexpected missed strikes
        if(!no_miss_hack_reported) {
            no_miss_hack_reported = true;
            metric_event('3350_no_miss_hack', {'spellname':spell['name'], 'shot_length':shot_length, 'eff_range': eff_range, 'max_range': max_range,
                                               'my_pos': my_pos, 'target_pos': target_pos,
                                               'target_hit_radius': (target ? target.hit_radius() : -1),
                                               'target_specname': (target ? target.spec['name'] : 'null')});
        }
        miss = 0;
    }

    // create graphical projectiles and impact effects
    var color = null;
    if(('projectile_color' in spell) && spell['projectile_color'] === null) {
        // no projectile
    }  else {
        color = spell['projectile_color'] || [1,1,0.5];
        if (my_stats && (my_stats.projectile_speed < 1)) {
            color = [0,0,0]; // special-case for really slow "bomb" shots
        } else if(my_team !== 'player') {
            if('projectile_hostile_color' in spell) {
                color = spell['projectile_hostile_color'];
            } else if(my_source && my_source.is_mobile()) {
                // hack - swap red and blue components for hostile attacks
                color = [color[2], 0.5*color[1], color[0]];
            }
        }
    }

    var exhaust = get_leveled_quantity(spell['projectile_particles'] || 0, my_level);
    if(SPFX.detail < 1) { exhaust = 0; }

    for(var i = 0; i < copies; i++) {
        // offset to de-synchronize visual effects
        var tick_offset = ('projectile_vfx_time_offset' in spell ? spell['projectile_vfx_time_offset'] : 1 ) * Math.random();
        var time_offset = tick_offset*TICK_INTERVAL/combat_time_scale();

        var impact_pos = vec_add(target_pos, [impact_spread*(-1+2*Math.random()),
                                              impact_spread*(-1+2*Math.random())]);
        var impact_height = target_height;
        var muzzle_time = fire_time+i*interval+time_offset; // time at which muzzle flash effect begins (bullet emerges prefire_delay later)
        var impact_time = hit_time+i*interval+time_offset; // time at which bullet reaches destination

        // when using unit_draw_scatter, adjust the visual effect target point towards the drawn location
        if(target && target.is_mobile() && gamedata['client']['unit_draw_scatter']) {
            impact_pos = vec_mad(impact_pos, gamedata['client']['unit_draw_scatter'], target.draw_offset);
        }
        var my_shot_v = vec_sub(impact_pos, my_pos);

        // if lead is enabled for a non-splash weapon, apply it to the graphical effect
        if(use_lead > 0 && !lead_applied && target && target.is_mobile() && (target.vel[0] != 0 || target.vel[1] != 0)) {
            var lead_shot_time = apply_target_lead(vec_mad(my_shot_v, prefire_delay+postfire_delay, target.vel), target.vel, speed);
            if(lead_shot_time >= 0) {
                impact_time = (muzzle_time + prefire_delay + lead_shot_time);
                impact_pos = vec_mad(impact_pos, (lead_shot_time + prefire_delay + postfire_delay) * use_lead, target.vel);
            }
        }

        // visual projectile effect
        if(color !== null && my_muzzle_pos) {
            var fxworld = world.fxworld;
            fxworld.add(new SPFX.TimeProjectile(fxworld, my_muzzle_pos, my_height,
                                                impact_pos, impact_height,
                                                muzzle_time+prefire_delay, impact_time,
                                                shot_height, color, (exhaust ? exhaust : null),
                                                get_leveled_quantity(spell['projectile_size'] || 2, my_level),
                                                get_leveled_quantity(spell['projectile_min_length'] || 0, my_level),
                                                get_leveled_quantity(spell['projectile_fade_time'] || 0, my_level),
                                                (spell['projectile_composite_mode'] || null),
                                                (spell['projectile_glow'] || 0),
                                                (spell['projectile_asset'] || null)
                                               ));
        }

        // visual weapon impact effect
        var impact_vfx = null;
        if(fizzle && ('fizzle_visual_effect' in spell)) {
            impact_vfx = spell['fizzle_visual_effect'];
        } else if('impact_visual_effect' in spell) {
            impact_vfx = spell['impact_visual_effect'];
        } else if('splash_range' in spell) {
            impact_vfx = gamedata['client']['vfx']['weapon_hit_splash'];
        } else {
            impact_vfx = gamedata['client']['vfx']['weapon_hit_nonsplash'];
        }

        // instance properties passed to vfx system
        var vfx_props = {};
        if(my_shot_v[0] != 0 || my_shot_v[1] != 0) {
            vfx_props['heading'] = Math.atan2(my_shot_v[1], my_shot_v[0]);
        }

        if(my_source && my_source.is_mobile()) {
            vfx_props['tick_offset'] = tick_offset;
            vfx_props['my_next_pos'] = my_source.next_pos; // position we will have at start of next combat tick
        }

        if(impact_vfx) {
            world.fxworld.add_visual_effect_at_time(impact_pos, impact_height, [0,1,0],
                                                    impact_time,
                                                    impact_vfx, (i == 0), vfx_props); // only play audio for first impact
        }

        // visual muzzle flash effect
        var muzzle_vfx = null;
        if('muzzle_flash_effect' in spell) {
            muzzle_vfx = spell['muzzle_flash_effect'];
        } else if(copies > 1) {
            muzzle_vfx = gamedata['client']['vfx']['muzzle_flash_burst'];
        } else {
            muzzle_vfx = gamedata['client']['vfx']['muzzle_flash_single'];
        }

        // only apply muzzle flash on first copy
        if(muzzle_vfx && my_muzzle_pos && (i == 0)) {
            world.fxworld.add_visual_effect_at_time(my_muzzle_pos, my_height,
                                                    v3_normalized([my_shot_v[0], 0, my_shot_v[1]]),
                                                    muzzle_time,
                                                    muzzle_vfx, true, vfx_props);
        }
    }

    // queue the actual damage effects
    if(!fizzle) {

    var effects = [];

    if('splash_range' in spell) {
        var radius = gamedata['map']['splash_range_conversion'] * get_leveled_quantity(spell['splash_range'], my_level) * (my_stats ? my_stats.splash_range : 1);
        // splash impact aura
        if(spell['impact_auras']) {
            for (var i = 0; i < spell['impact_auras'].length; i++) {
                var imp_aura = spell['impact_auras'][i];
                var strength = get_leveled_quantity(imp_aura['strength'] || 1, my_level);
                if(my_stats && imp_aura['strength_mod_by_weapon_damage']) {
                    strength *= my_stats.weapon_damage;
                }
                effects.push(new CombatEngine.AreaAuraEffect(absolute_time_to_tick(hit_time+postfire_delay), hit_time+postfire_delay, my_id, my_team, target_pos,
                                                ('splash_to_ground' in spell ? spell['splash_to_ground'] : false) || !(target_height > 0),
                                                ('splash_to_air' in spell ? spell['splash_to_air'] : false) || (target_height > 0),
                                                radius, false,
                                                get_leveled_quantity(spell['splash_falloff'] || 'linear', my_level),
                                                strength,
                                                get_leveled_quantity(imp_aura['spec'], my_level),
                                                relative_time_to_tick(get_leveled_quantity(imp_aura['duration'] || 1, my_level)),
                                                get_leveled_quantity(imp_aura['range'] || 0, my_level),
                                                damage_vs, imp_aura['duration_vs'] || {},
                                                // enable friendly fire ONLY if targeted at same-team object
                                                spell['always_friendly_fire'] || (target && target.team === my_team)));
            }
        }

        // splash damage
        if(damage != 0) {
            effects.push(new CombatEngine.AreaDamageEffect(absolute_time_to_tick(hit_time+postfire_delay), hit_time+postfire_delay, my_id, my_team, target_pos,
                                              ('splash_to_ground' in spell ? spell['splash_to_ground'] : false) || !(target_height > 0),
                                              ('splash_to_air' in spell ? spell['splash_to_air'] : false) || (target_height > 0),
                                              radius,
                                              get_leveled_quantity(spell['splash_falloff'] || 'linear', my_level),
                                              damage, damage_vs,
                                              // enable friendly fire ONLY if targeted at same-team object
                                              spell['always_friendly_fire'] || (target && target.team === my_team)));
        }

    } else {
        if(target && !miss) {
            if(spell['impact_auras']) {
                for (var i = 0; i < spell['impact_auras'].length; i++) {
                    var imp_aura = spell['impact_auras'][i];
                    var strength = get_leveled_quantity(imp_aura['strength'] || 1, my_level);
                    if(my_stats && imp_aura['strength_mod_by_weapon_damage']) {
                        strength *= my_stats.weapon_damage;
                    }
                    effects.push(new CombatEngine.TargetedAuraEffect(absolute_time_to_tick(hit_time+postfire_delay), hit_time+postfire_delay, my_id, my_team, target.id,
                                                        strength,
                                                        get_leveled_quantity(imp_aura['spec'], my_level),
                                                        relative_time_to_tick(get_leveled_quantity(imp_aura['duration'] || 1, my_level)),
                                                        get_leveled_quantity(imp_aura['range'] || 0, my_level),
                                                        damage_vs, imp_aura['duration_vs'] || {}
                                                       ));
                }
            }

            if(damage != 0) {
                effects.push(new CombatEngine.TargetedDamageEffect(absolute_time_to_tick(hit_time+postfire_delay), hit_time+postfire_delay, my_id, my_team, target.id, damage, damage_vs));
            }
        }
    }

    for(var i = 0; i < effects.length; i++) {
        world.combat_engine.queue_damage_effect(effects[i]);
    }

    if(miss && COMBAT_DEBUG) {
        // "Miss" alert text
        world.fxworld.add(new SPFX.CombatText(target_pos, 0, "MISS", [1,1,0.1,1], world.fxworld.now_time(), 1.0, {drop_shadow:true}));
    }

    }

    if(player.is_suspicious) {
        metric_event('3940_shot_fired', {'attack_event': true,
                                         'shooter_id': my_id,
                                         'shooter_team': my_team,
                                         'shooter_type': my_spec_name,
                                         'shooter_pos': my_pos,
                                         'target_id': target ? target.id : -1,
                                         'target_type': target ? target.spec['name'] : 'aoe',
                                         'target_team': target ? target.team : null,
                                         'target_pos': target_pos,
                                         'range': vec_length(vec_sub(target_pos, my_pos)),
                                         'damage': damage,
                                         'speed': speed,
                                         'client_time': client_time,
                                         'fire_time': fire_time,
                                         'hit_time': hit_time,
                                         'miss': miss
                                        });
    }

    return hit_time;
};

/** @param {!World.World} world
    @param {GameObject|null} my_source
    @param {GameObjectId} my_id
    @param {string} my_spec_name
    @param {number} my_level
    @param {TeamId} my_team
    @param {Object} my_stats
    @param {!Array.<number>} my_pos
    @param {number} my_height
    @param {Array.<number>} my_muzzle_pos
    @param {!GameTypes.TickCount} fire_tick
    @param {GameTypes.TickCount|null} force_hit_tick
    @param {Object} spell
    @param {GameObject|null} target
    @param {!Array.<number>} target_pos
    @param {number} target_height
    @param {boolean} fizzle
    @return {!GameTypes.TickCount}
*/
function do_fire_projectile_ticks(world, my_source, my_id, my_spec_name, my_level, my_team, my_stats, my_pos, my_height, my_muzzle_pos, fire_tick, force_hit_tick, spell, target, target_pos, target_height, fizzle) {
    var max_range = gamedata['map']['range_conversion'] * get_leveled_quantity(spell['range'], my_level) * (my_stats ? my_stats.weapon_range : 1);
    var eff_range = ('effective_range' in spell ? (gamedata['map']['range_conversion'] * get_leveled_quantity(spell['effective_range'], my_level) * (my_stats ? my_stats.effective_weapon_range : 1)) : max_range);
    var shot_v = vec_sub(target_pos, my_pos);

    var shot_length;
    if(spell['distance_calc'] == '3d') {
        shot_length = v3_distance([my_pos[0], my_height, my_pos[1]], [target_pos[0], target_height, target_pos[1]]);
        // don't throw off the accuracy calculation below! hack - eventually we should use full 3D math for all target range calcs.
        max_range += Math.abs(target_height - my_height);
        eff_range += Math.abs(target_height - my_height);
    } else if(vec_equals(shot_v, [0,0])) {
        // hack - pure vertical shots
        shot_length = target_height - my_height;
    } else {
        shot_length = vec_length(shot_v);
    }

    // adjust target_pos and shot_length to account for non-zero hitbox radius
    if(target) {
        var rad = target.hit_radius();
        if(rad > 0) {
            if(shot_length > rad+0.001) {
                var new_shot_length = (shot_length - rad);
                target_pos = vec_mad(my_pos, (new_shot_length/shot_length), shot_v);
                shot_v = vec_sub(target_pos, my_pos);
                shot_length = new_shot_length;
            }
        }
    }

    var damage;
    var damage_vs = spell['damage_vs'] || {};
    if(fizzle) {
        damage = 0;
    } else {
        damage = get_leveled_quantity(spell['damage'], my_level);

        if(damage != 0) {
            // damage in spec file is PER SECOND, must convert it to PER SHOT
            damage *= get_leveled_quantity(spell['cooldown'] || 1, my_level);
            if(my_stats) {
                // apply combat stat modifiers
                damage *= my_stats.weapon_damage;
                damage_vs = merge_damage_vs(damage_vs, my_stats.weapon_damage_vs);
            }

            // quantize damage to integers, and set lower bound to 1
            if(damage >= 0) {
                damage = Math.max(Math.ceil(damage), 1);
            } else {
                damage = Math.min(Math.ceil(damage), -1);
            }
        }
    }

    var speed = player.get_any_abtest_value('global_projectile_speed_scale', gamedata['map']['global_projectile_speed_scale']) * get_leveled_quantity(spell['projectile_speed'] || 0, my_level) * (my_stats ? my_stats.projectile_speed : 1) * TICK_INTERVAL;

    // use_lead actually changes combat target position for splash weapons
    // for non-splash weapons, it affects graphics only (since hits are computed independently)
    var use_lead = get_leveled_quantity(spell['lead_target'] || 0, my_level);
    var lead_applied = false;
    var arc = world.fxworld.global_gravity * get_leveled_quantity(spell['projectile_arc'] || 0, my_level);
    var copies = get_leveled_quantity(spell['projectile_burst_size'] || 1, my_level);
    if(SPFX.detail < 1) {
        copies = Math.min(Math.max(Math.floor(SPFX.detail * copies), 1), 2);
    }
    var interval = get_leveled_quantity(spell['projectile_burst_interval'] || 0, my_level);
    var prefire_delay_ticks = relative_time_to_tick(get_leveled_quantity(spell['prefire_delay'] || 0, my_level));
    var postfire_delay_ticks = relative_time_to_tick(get_leveled_quantity(spell['postfire_delay'] || 0, my_level));

    /** @type {!GameTypes.TickCount} */
    var shot_ticks;
    /** @type {number} */
    var shot_height;

    if(speed > 0) {
        // account for projectile travel time
        var P = shot_v;
        shot_ticks = new GameTypes.TickCount(Math.floor(shot_length/speed + 0.5));
        shot_height = shot_length * arc;

        // fire splash weapons at extrapolated target position
        if(use_lead > 0 && ('splash_range' in spell) && target && target.is_mobile() && (target.vel[0] != 0 || target.vel[1] != 0)) {
            lead_applied = true;

            var target_vel_per_tick = vec_scale(1/TICK_INTERVAL, target.vel);
            if(prefire_delay_ticks.get()+postfire_delay_ticks.get() > 0) {
                P = vec_mad(P, prefire_delay_ticks.get()+postfire_delay_ticks.get(), target_vel_per_tick); // XXXXXX check math
            }
            var lead_shot_ticks = apply_target_lead(P, target_vel_per_tick, speed);
            if(lead_shot_ticks >= 1) {
                shot_ticks = new GameTypes.TickCount(Math.floor(lead_shot_ticks + 0.5));
            }

            // propose extrapolated target position
            var test_pos = vec_mad(target_pos,
                                   GameTypes.TickCount.scale(use_lead,
                                                             GameTypes.TickCount.add(shot_ticks,
                                                                                     GameTypes.TickCount.add(prefire_delay_ticks, postfire_delay_ticks))).get(),
                                   target_vel_per_tick);

            // constrain impact distance by maximum weapon range
            var test_len = vec_distance(test_pos, my_pos);
            if(test_len > max_range) {
                //console.log('CONSTRAIN test_len '+test_len.toFixed(3)+ ' max '+max_range.toFixed(3));

                // constrain to max range
                target_pos = vec_mad(my_pos, max_range, vec_normalized(vec_sub(test_pos, my_pos)));
                // recompute shot_time
                shot_ticks = new GameTypes.TickCount(Math.floor(max_range / speed + 0.5));
            } else {
                // use proposed position
                target_pos = test_pos;
            }

            // recompute shot_v and shot_length
            shot_v = vec_sub(target_pos, my_pos);
            shot_length = vec_length(shot_v);

            //console.log('shot_time '+shot_time.toFixed(3)+' t '+t.toFixed(3)+' max '+max_shot_time.toFixed(3));
        }

    } else {
        // instant hit
        shot_ticks = new GameTypes.TickCount(0);
        shot_height = 0;
    }

    // hit_tick is the time at which the bullet will reach its final destination
    // hit_tick+postfire_delay is when it will explode and do damage

    /** @type {!GameTypes.TickCount} */
    var hit_tick;

    /** @type {number} */
    var impact_spread;

    if(force_hit_tick) {
        hit_tick = force_hit_tick;
        impact_spread = 0; // shoot directly at target location
    } else {
        hit_tick = GameTypes.TickCount.add(fire_tick,
                                           GameTypes.TickCount.add(prefire_delay_ticks,
                                                                   shot_ticks));
        impact_spread = get_leveled_quantity(spell['projectile_impact_spread'] || 1.5, my_level);
    }

    var miss = 0; // nonzero if the shot is a miss
    var accuracy = get_leveled_quantity(spell['accuracy'] || 1, my_level) * (my_stats ? my_stats.accuracy : 1);
    if(shot_length > eff_range) { // degrade accuracy linearly between eff_range and max_range
        //console.log("MISS! "+shot_length.toString()+" eff "+eff_range.toString());
        accuracy *= 1 - (shot_length-eff_range)/(max_range-eff_range);
    }
    if(accuracy < 1) {
        if(Math.random() >= accuracy) {
            // miss
            miss = 1;
            impact_spread *= 3;
        }
        //console.log('range '+shot_length.toFixed(1)+' ('+eff_range.toFixed(1)+'-'+max_range.toFixed(1)+') accuracy '+accuracy.toFixed(2));
    }

    if(miss && spell['no_miss_hack']) { // XXX temporary band-aid fix for unexpected missed strikes
        if(!no_miss_hack_reported) {
            no_miss_hack_reported = true;
            metric_event('3350_no_miss_hack', {'spellname':spell['name'], 'shot_length':shot_length, 'eff_range': eff_range, 'max_range': max_range,
                                               'my_pos': my_pos, 'target_pos': target_pos,
                                               'target_hit_radius': (target ? target.hit_radius() : -1),
                                               'target_specname': (target ? target.spec['name'] : 'null')});
        }
        miss = 0;
    }

    // create graphical projectiles and impact effects
    var color = null;
    if(('projectile_color' in spell) && spell['projectile_color'] === null) {
        // no projectile
    }  else {
        color = spell['projectile_color'] || [1,1,0.5];
        if (my_stats && (my_stats.projectile_speed < 1)) {
            color = [0,0,0]; // special-case for really slow "bomb" shots
        } else if(my_team !== 'player') {
            if('projectile_hostile_color' in spell) {
                color = spell['projectile_hostile_color'];
            } else if(my_source && my_source.is_mobile()) {
                // hack - swap red and blue components for hostile attacks
                color = [color[2], 0.5*color[1], color[0]];
            }
        }
    }

    var exhaust = get_leveled_quantity(spell['projectile_particles'] || 0, my_level);
    if(SPFX.detail < 1) { exhaust = 0; }

    for(var i = 0; i < copies; i++) {
        // offset to de-synchronize visual effects
        var tick_offset = ('projectile_vfx_time_offset' in spell ? spell['projectile_vfx_time_offset'] : 1 ) * Math.random();
        var time_offset = tick_offset*TICK_INTERVAL/combat_time_scale();

        var impact_pos = vec_add(target_pos, [impact_spread*(-1+2*Math.random()),
                                              impact_spread*(-1+2*Math.random())]);
        var impact_height = target_height;
        var impact_tick = hit_tick; // tick at which bullet reaches destination

        // when using unit_draw_scatter, adjust the visual effect target point towards the drawn location
        if(target && target.is_mobile() && gamedata['client']['unit_draw_scatter']) {
            impact_pos = vec_mad(impact_pos, gamedata['client']['unit_draw_scatter'], target.draw_offset);
        }
        var my_shot_v = vec_sub(impact_pos, my_pos);

        // if lead is enabled for a non-splash weapon, apply it to the graphical effect
        if(use_lead > 0 && !lead_applied && target && target.is_mobile() && (target.vel[0] != 0 || target.vel[1] != 0)) {
            var target_vel_per_tick = vec_scale(1/TICK_INTERVAL, target.vel);

            var lead_shot_tick_count = apply_target_lead(vec_mad(my_shot_v, prefire_delay_ticks.get()+postfire_delay_ticks.get(), target_vel_per_tick), target_vel_per_tick, speed);
            if(lead_shot_tick_count >= 0) {
                var lead_shot_ticks = new GameTypes.TickCount(Math.floor(lead_shot_tick_count + 0.5));
                impact_tick = GameTypes.TickCount.add(fire_tick,
                                                      GameTypes.TickCount.add(prefire_delay_ticks,
                                                                              lead_shot_ticks));
                impact_pos = vec_mad(impact_pos, (lead_shot_ticks.get() + prefire_delay_ticks.get() + postfire_delay_ticks.get()) * use_lead, target_vel_per_tick);
            }
        }

        // visual projectile effect
        if(color !== null && my_muzzle_pos) {

            // when interval is greater than a tick, actually delay the firing/impact graphics
            var my_fire_tick = GameTypes.TickCount.add(fire_tick, prefire_delay_ticks);
            var my_impact_tick = impact_tick;
            var tick_delay = i*interval + time_offset;
            if(tick_delay >= TICK_INTERVAL) {
                var whole_ticks = Math.floor(tick_delay / TICK_INTERVAL);
                tick_delay -= whole_ticks * TICK_INTERVAL;
                my_fire_tick = new GameTypes.TickCount(my_fire_tick.get() + whole_ticks);
                my_impact_tick = new GameTypes.TickCount(my_impact_tick.get() + whole_ticks);
            }

            var fxworld = world.fxworld;
            fxworld.add(new SPFX.TicksProjectile(fxworld, my_muzzle_pos, my_height,
                                                 impact_pos, impact_height,
                                                 my_fire_tick,
                                                 my_impact_tick,
                                                 tick_delay,
                                                 shot_height, color, (exhaust ? exhaust : null),
                                                 get_leveled_quantity(spell['projectile_size'] || 2, my_level),
                                                 get_leveled_quantity(spell['projectile_min_length'] || 0, my_level),
                                                 get_leveled_quantity(spell['projectile_fade_time'] || 0, my_level),
                                                 (spell['projectile_composite_mode'] || null),
                                                 (spell['projectile_glow'] || 0),
                                                 (spell['projectile_asset'] || null)
                                                ));
        }

        // visual weapon impact effect
        var impact_vfx = null;
        if(fizzle && ('fizzle_visual_effect' in spell)) {
            impact_vfx = spell['fizzle_visual_effect'];
        } else if('impact_visual_effect' in spell) {
            impact_vfx = spell['impact_visual_effect'];
        } else if('splash_range' in spell) {
            impact_vfx = gamedata['client']['vfx']['weapon_hit_splash'];
        } else {
            impact_vfx = gamedata['client']['vfx']['weapon_hit_nonsplash'];
        }

        // instance properties passed to vfx system
        var vfx_props = {};
        if(my_shot_v[0] != 0 || my_shot_v[1] != 0) {
            vfx_props['heading'] = Math.atan2(my_shot_v[1], my_shot_v[0]);
        }

        if(my_source && my_source.is_mobile()) {
            vfx_props['tick_offset'] = tick_offset;
            vfx_props['my_next_pos'] = my_source.next_pos; // position we will have at start of next combat tick
        }

        if(impact_vfx) {
            world.fxworld.add_visual_effect_at_tick(impact_pos, impact_height, [0,1,0],
                                                    impact_tick, i*interval + time_offset,
                                                    impact_vfx, (i == 0), vfx_props); // only play audio for first impact
        }

        // visual muzzle flash effect
        var muzzle_vfx = null;
        if('muzzle_flash_effect' in spell) {
            muzzle_vfx = spell['muzzle_flash_effect'];
        } else if(copies > 1) {
            muzzle_vfx = gamedata['client']['vfx']['muzzle_flash_burst'];
        } else {
            muzzle_vfx = gamedata['client']['vfx']['muzzle_flash_single'];
        }

        // only apply muzzle flash on first copy
        if(muzzle_vfx && my_muzzle_pos && (i == 0)) {
            world.fxworld.add_visual_effect_at_tick(my_muzzle_pos, my_height,
                                                    v3_normalized([my_shot_v[0], 0, my_shot_v[1]]),
                                                    fire_tick, i*interval + time_offset,
                                                    muzzle_vfx, true, vfx_props);
        }
    }

    // queue the actual damage effects
    if(!fizzle) {

    var effects = [];

    if('splash_range' in spell) {
        var radius = gamedata['map']['splash_range_conversion'] * get_leveled_quantity(spell['splash_range'], my_level) * (my_stats ? my_stats.splash_range : 1);
        // splash impact aura
        if(spell['impact_auras']) {
            for (var i = 0; i < spell['impact_auras'].length; i++) {
                var imp_aura = spell['impact_auras'][i];
                var strength = get_leveled_quantity(imp_aura['strength'] || 1, my_level);
                if(my_stats && imp_aura['strength_mod_by_weapon_damage']) {
                    strength *= my_stats.weapon_damage;
                }
                effects.push(new CombatEngine.AreaAuraEffect(GameTypes.TickCount.add(hit_tick, postfire_delay_ticks), -1, my_id, my_team, target_pos,
                                                ('splash_to_ground' in spell ? spell['splash_to_ground'] : false) || !(target_height > 0),
                                                ('splash_to_air' in spell ? spell['splash_to_air'] : false) || (target_height > 0),
                                                radius, false,
                                                get_leveled_quantity(spell['splash_falloff'] || 'linear', my_level),
                                                strength,
                                                get_leveled_quantity(imp_aura['spec'], my_level),
                                                relative_time_to_tick(get_leveled_quantity(imp_aura['duration'] || 1, my_level)),
                                                get_leveled_quantity(imp_aura['range'] || 0, my_level),
                                                damage_vs, imp_aura['duration_vs'] || {},
                                                // enable friendly fire ONLY if targeted at same-team object
                                                spell['always_friendly_fire'] || (target && target.team === my_team)));
            }
        }

        // splash damage
        if(damage != 0) {
            effects.push(new CombatEngine.AreaDamageEffect(GameTypes.TickCount.add(hit_tick, postfire_delay_ticks), -1, my_id, my_team, target_pos,
                                              ('splash_to_ground' in spell ? spell['splash_to_ground'] : false) || !(target_height > 0),
                                              ('splash_to_air' in spell ? spell['splash_to_air'] : false) || (target_height > 0),
                                              radius,
                                              get_leveled_quantity(spell['splash_falloff'] || 'linear', my_level),
                                              damage, damage_vs,
                                              // enable friendly fire ONLY if targeted at same-team object
                                              spell['always_friendly_fire'] || (target && target.team === my_team)));
        }

    } else {
        if(target && !miss) {
            if(spell['impact_auras']) {
                for (var i = 0; i < spell['impact_auras'].length; i++) {
                    var imp_aura = spell['impact_auras'][i];
                    var strength = get_leveled_quantity(imp_aura['strength'] || 1, my_level);
                    if(my_stats && imp_aura['strength_mod_by_weapon_damage']) {
                        strength *= my_stats.weapon_damage;
                    }
                    effects.push(new CombatEngine.TargetedAuraEffect(GameTypes.TickCount.add(hit_tick, postfire_delay_ticks), -1, my_id, my_team, target.id,
                                                        strength,
                                                        get_leveled_quantity(imp_aura['spec'], my_level),
                                                        relative_time_to_tick(get_leveled_quantity(imp_aura['duration'] || 1, my_level)),
                                                        get_leveled_quantity(imp_aura['range'] || 0, my_level),
                                                        damage_vs, imp_aura['duration_vs'] || {}
                                                       ));
                }
            }

            if(damage != 0) {
                effects.push(new CombatEngine.TargetedDamageEffect(GameTypes.TickCount.add(hit_tick, postfire_delay_ticks), -1, my_id, my_team, target.id, damage, damage_vs));
            }
        }
    }

    for(var i = 0; i < effects.length; i++) {
        world.combat_engine.queue_damage_effect(effects[i]);
    }

    if(miss && COMBAT_DEBUG) {
        // "Miss" alert text
        world.fxworld.add(new SPFX.CombatText(target_pos, 0, "MISS", [1,1,0.1,1], world.fxworld.now_time(), 1.0, {drop_shadow:true}));
    }

    }

    if(player.is_suspicious) {
        metric_event('3940_shot_fired', {'attack_event': true,
                                         'shooter_id': my_id,
                                         'shooter_team': my_team,
                                         'shooter_type': my_spec_name,
                                         'shooter_pos': my_pos,
                                         'target_id': target ? target.id : -1,
                                         'target_type': target ? target.spec['name'] : 'aoe',
                                         'target_team': target ? target.team : null,
                                         'target_pos': target_pos,
                                         'range': vec_length(vec_sub(target_pos, my_pos)),
                                         'damage': damage,
                                         'speed': speed,
                                         'client_time': client_time,
                                         'fire_tick': fire_tick.get(),
                                         'hit_tick': hit_tick.get(),
                                         'miss': miss
                                        });
    }

    return hit_tick;
};

/** For now, require callers to supply both combat-tick and clock-time parameters.
    @param {!World.World} world
    @param {!GameTypes.TickCount} fire_tick
    @param {number} fire_time
    @param {GameTypes.TickCount|null} force_hit_tick
    @param {number} force_hit_time
    @param {Object} spell
    @param {number} spell_level
    @param {GameObject|null} target
    @param {!Array.<number>} target_pos
    @param {number} target_height */
GameObject.prototype.fire_projectile = function(world, fire_tick, fire_time, force_hit_tick, force_hit_time, spell, spell_level, target, target_pos, target_height) {
    var my_pos = this.interpolate_pos(world);
    var my_height = (this.is_flying() ? this.combat_stats.altitude : 0);
    var my_muzzle_pos = my_pos;

    // compute bullet origin in map coordinates
    // note: this is only for visual effect, the combat-engine firing position is always unit origin,
    // to avoid pathfinding issues with facing

    var facing = this.interpolate_facing(world);
    // note: convert muzzle_offset from model coordinates (+z north) to map coordinates (-z north)
    var offset = v3_rotate_by_facing(facing, v3_mul([1,1,-1], this.combat_stats.muzzle_offset));
    my_muzzle_pos = vec_add(my_muzzle_pos, [offset[0], offset[2]]);
    my_height += this.combat_stats.muzzle_offset[1];
    my_height += this.combat_stats.muzzle_height;

    if(spell['kills_self']) {
        // special for Detonator Droids - kill self
        var death_client_time = client_time;
        var death_tick = fire_tick;
        if('kills_self_delay' in spell) {
            death_tick = GameTypes.TickCount.add(death_tick, relative_time_to_tick(/** @type {number} */ (spell['kills_self_delay'])));
            death_client_time += spell['kills_self_delay'];
        }
        var death_method = ('kills_self_method' in spell ? spell['kills_self_method'] : 'hostile');

        world.combat_engine.queue_damage_effect(new CombatEngine.KillDamageEffect(death_tick, death_client_time, this.id, null, this.id, death_method));
    }

    if(COMBAT_ENGINE_USE_TICKS) {
        do_fire_projectile_ticks(world, this, this.id, this.spec['name'],
                                 spell_level,
                                 this.team, this.combat_stats, my_pos, my_height, my_muzzle_pos, fire_tick, force_hit_tick, spell, target, target_pos, target_height, false);
    } else {
        do_fire_projectile_time(world, this, this.id, this.spec['name'],
                                spell_level,
                                this.team, this.combat_stats, my_pos, my_height, my_muzzle_pos, fire_time, force_hit_time, spell, target, target_pos, target_height, false);
    }
};

GameObject.prototype.is_being_attacked = function() {
    return (this.ai_attackers_list.length > 0);
}

/** @param {!World.World} world

    Roll over next_attackers_list into ai_attackers_list, filtering
    out objects that have died, or we cannot hit. Clear out
    next_ai_attackers_list for use during the upcoming tick.

    Note: for objects that won't make use of this.ai_attackers_list
    for targeting, we will just leave it empty here.
 */
GameObject.prototype.ai_attackers_list_update = function(world) {
    var ai_attackers_list = this.next_ai_attackers_list;
    this.ai_attackers_list = [];
    this.next_ai_attackers_list = [];
    var my_id = this.id;
    var auto_spell = this.get_auto_spell();
    if(!auto_spell) { // ignore units that can't shoot
        return; // leave this.ai_attackers_list empty
    }
    var auto_spell_level = this.get_auto_spell_level();
    var auto_spell_range = gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['range'], auto_spell_level) * this.combat_stats.weapon_range;
    if(auto_spell_range <= 0 || !this.is_mobile()) { // ignore units that have no range and turrets
        return; // leave this.ai_attackers_list empty
    }
    // only counts units that the object can shoot back at, so filter
    if(ai_attackers_list.length > 0) {
        this.ai_attackers_list = goog.array.filter(ai_attackers_list, function(a) {
            if(!world.objects.has_object(a) || world.objects.get_object(a).is_destroyed()) { return false; }
            var obj = world.objects._get_object(a);
            if(!obj) { return false; }
            if(obj.is_flying() && !(auto_spell['targets_air'] || (this.combat_stats && this.combat_stats.anti_air))) { return false; }
            if(!obj.is_flying() && !auto_spell['targets_ground']) { return false; }
            return true;
        }, this);
    }
}

/** @param {!World.World} world
    First check if it's time to update this.strongest_attacker_id.
    If it is, look through this.ai_attackers_list and pick the
    most threatening object.
 */
GameObject.prototype.update_strongest_attacker_id = function(world) {
    var auto_spell = this.get_auto_spell();
    if(!auto_spell || !this.is_mobile() || this.ai_attackers_list.length === 0) { // ignore unarmed and turrets, abort if no attackable attackers
        this.strongest_attacker_id = null;
        return;
    }
    if(this.strongest_attacker_id && world.objects.has_object(this.strongest_attacker_id) && !world.objects.get_object(this.strongest_attacker_id).is_destroyed()) {
        return; // leave current strongest_attacker_id value if it's alive
    }
    var i = 0;
    var most_dangerous_index = 0;
    var most_dangerous_damage = 0;
    var my_defense_types = this.spec['defense_types'];
    goog.array.forEach(this.ai_attackers_list, function(a) {
        if(!world.objects.has_object(this.strongest_attacker_id) || world.objects.get_object(this.strongest_attacker_id).is_destroyed()) {
            i += 1;
            return;
        }
        var attacker = world.objects._get_object(a);
        var attacker_spell = attacker.get_auto_spell();
        if(!attacker_spell) {
            i += 1;
            return;
        }
        var attacker_spell_level = attacker.get_auto_spell_level();
        var attacker_damage = get_leveled_quantity(attacker_spell['damage'], attacker_spell_level);
        var attacker_highest_damage = 0;
        if('impact_auras' in attacker_spell) {
            goog.array.forEach(attacker_spell['impact_auras'], function(aura_data) {
                var aura = gamedata['auras'][aura_data['spec']];
                var is_dot = false;
                if('effects' in aura) {
                    goog.array.forEach(aura['effects'], function(effect) {
                        if(effect['code'] == 'on_fire') {
                            is_dot = true;
                        }
                    });
                }
                if(is_dot) {
                    attacker_damage += Math.floor(get_leveled_quantity(1, attacker_spell_level) * get_leveled_quantity(aura_data['strength'] || 1, attacker_spell_level));
                }
            });
        }
        var attacker_damage_vs = get_leveled_quantity(attacker_spell['damage_vs'], attacker_spell_level);
        goog.array.forEach(my_defense_types, function(d) {
            if(d in attacker_damage_vs) {
                var this_damage_vs = attacker_damage_vs[d] * attacker_damage;
                if(this_damage_vs > attacker_highest_damage) {
                    attacker_highest_damage = this_damage_vs;
                }
            }
        });
        if(attacker_highest_damage > most_dangerous_damage) {
            most_dangerous_index = i;
        }
        i += 1;
    }, this);
    this.strongest_attacker_id = this.ai_attackers_list[most_dangerous_index];
}

// ideally, get rid of this, because one object's targeting cannot
// vary based on the ai_target of another object during this tick
// (this would create an ordering dependency).
// worst case, double-buffer it like ai_attacker_list.
GameObject.prototype.is_attacking_attacker = function() {
    // return true if our ai_target is an object that currently is targeting us
    if(!this.ai_target || !this.ai_target.id || !this.ai_target.last_ai_target || !this.ai_target.last_ai_target.id) { return false; }
    return this.id.localeCompare(this.ai_target.last_ai_target.id) === 0;
}

/** @param {!World.World} world */
GameObject.prototype.ai_threatlist_update = function(world) {
    if(!this.spec['enable_ai_threatlist']) { return; }
    if(this.ai_threatlist !== null && !this.ai_threatlist_dirty) { return; }

    // throttle how many of these updates can take place per frame, since they can involve expensive queries
    if(this.is_mobile() && world.tick_astar_queries_left === 0) {
        return;
    }

    // remember previous target, to try to re-target it if possible
    var prev_target_id = null;
    if(this.ai_threatlist !== null && this.ai_threatlist.length >= 1) {
        prev_target_id = this.ai_threatlist[0]['obj_id'];
    }

    this.ai_threatlist_dirty = false;
    this.ai_threatlist = [];

    if(this.is_destroyed()) {
        return;
    }

    var auto_spell = this.get_auto_spell();
    if(!auto_spell) { return; }
    var auto_spell_level = this.get_auto_spell_level();

    world.tick_astar_queries_left -= 1;

    var aggro_radius;
    if(this.is_mobile()) {
        // search entire map for targets. Target found will be
        // position-dependent, but we assume that any changes to game
        // state that would change our choice of target will also
        // dirty the threatlist.

        var ncells = world.base.ncells();
        aggro_radius = Math.sqrt(2)*Math.max(ncells[0], ncells[1]);
    } else {
        // turrets only look within weapon range
        aggro_radius = gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['range'], auto_spell_level) * this.combat_stats.weapon_range;
    }

    var targeting_result = this.ai_pick_target_classic_cached(world, auto_spell, auto_spell_level, aggro_radius, false, prev_target_id, 'ai_threatlist_update');
    if(targeting_result && targeting_result.target) {
        this.ai_threatlist.push({'obj_id': targeting_result.target.id,
                                 'spec': targeting_result.target.spec.name,
                                 'path_end': targeting_result.path_end || null});
    }
};

// find "best" thing to target within shoot_range (which may be <= 0, or longer than weapon range)
/** @param {!World.World} world
    @param {Object} auto_spell
    @param {number} auto_spell_level
    @param {number} shoot_range
    @param {boolean} nearest_only
    @param {string} tag */
GameObject.prototype.ai_pick_target = function(world, auto_spell, auto_spell_level, shoot_range, nearest_only, tag) {
    if(this.spec['enable_ai_threatlist']) {
        if(this.ai_threatlist !== null) {
            return this.ai_pick_target_by_threatlist(world, auto_spell, auto_spell_level, shoot_range);
        } else {
            // this can happen if A* is starved
            if(AI_DEBUG >= 2) { console.log(this.spec['name']+' no active threatlist!'); }
            return {target:null};
        }
    } else {
        return this.ai_pick_target_classic(world, auto_spell, auto_spell_level, shoot_range, nearest_only, null, tag);
    }
};

/** @param {!World.World} world
    @param {Object} auto_spell
    @param {number} auto_spell_level
    @param {number} shoot_range */
GameObject.prototype.ai_pick_target_by_threatlist = function(world, auto_spell, auto_spell_level, shoot_range) {
    // weed out dead objects
    this.ai_threatlist = goog.array.filter(this.ai_threatlist, function(a) {
        var obj = world.objects._get_object(a['obj_id']);
        if(!obj || obj.is_destroyed()) { return false; }
        return true;
    });
    if(this.ai_threatlist.length > 0) {
        var entry = this.ai_threatlist[0];
        var obj = world.objects.get_object(entry['obj_id']);
        var his_pos = obj.raw_pos();
        return {target: obj,
                pos: his_pos,
                dist: Math.max(0, vec_distance(this.raw_pos(), his_pos) - obj.hit_radius()),
                path_end: (entry['path_end'] || null)};
    }
    return {target:null};
};

// stateless version of target-picking

/** @param {!World.World} world
    @param {Object} auto_spell
    @param {number} auto_spell_level
    @param {number} shoot_range
    @param {boolean} nearest_only
    @param {string|null} prev_target_id
    @param {string} tag */
GameObject.prototype.ai_pick_target_classic_cached = function(world, auto_spell, auto_spell_level, shoot_range, nearest_only, prev_target_id, tag) {
    // this cache operates by sharing the targeting results for nearby identical units
    // "nearby" means not necessarily in the same grid cell, but in the same connectivity region, so that pathing remains valid!
    var CHUNK = this.spec['ai_pick_target_cache_chunk'] || (get_preference_setting(player.preferences, 'sg_ai_20150416') ? 12 : 0) || player.get_any_abtest_value('ai_pick_target_cache_chunk', gamedata['client']['ai_pick_target_cache_chunk']) || -1;

    /** @type {string|null} cache key */
    var key = null;

    if(!nearest_only && CHUNK >= 1) {
        world.astar_context.ensure_connectivity();
        if(world.astar_context.connectivity) {
            // cache is operational
            if(world.ai_pick_target_classic_cache_gen != world.astar_map.generation) {
                world.ai_pick_target_classic_cache_gen = world.astar_map.generation;
                world.ai_pick_target_classic_cache = {};
            }

            var cur_cell = this.raw_pos();
            key = this.spec['name']+','+this.team+','+Math.floor(cur_cell[0]/CHUNK).toFixed(0)+','+Math.floor(cur_cell[1]/CHUNK).toFixed(0)+','+world.astar_context.connectivity.region_num(vec_floor(cur_cell)).toFixed(0)+','+auto_spell['name']+','+(auto_spell_level||1).toFixed(0)+','+shoot_range.toFixed(3)+','+(prev_target_id || 'null');
        }
    }

    if(key !== null && (key in world.ai_pick_target_classic_cache)) {
        world.ai_pick_target_classic_cache_hits += 1;
        return world.ai_pick_target_classic_cache[key];
    }
    var ret = this.ai_pick_target_classic(world, auto_spell, auto_spell_level, shoot_range, nearest_only, prev_target_id, tag);
    if(key !== null) {
        world.ai_pick_target_classic_cache_misses += 1;
        world.ai_pick_target_classic_cache[key] = ret;
    }
    return ret;
};

/** @param {!World.World} world
    @param {Object} auto_spell
    @param {number} auto_spell_level
    @param {number} shoot_range
    @param {boolean} nearest_only
    @param {string|null} prev_target_id
    @param {string} tag */
GameObject.prototype.ai_pick_target_classic = function(world, auto_spell, auto_spell_level, shoot_range, nearest_only, prev_target_id, tag) {
    var verbose = (AI_DEBUG >= 2 && this.is_mobile());

    var auto_spell_range = gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['range'], auto_spell_level) * this.combat_stats.weapon_range;
    var auto_spell_min_range = ('min_range' in auto_spell) ? gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['min_range'], auto_spell_level) : -1; // * Math.max(1,this.combat_stats.weapon_range); ?
    var priority_far_range = ('priority_far_range' in auto_spell) ? (gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['priority_far_range'], auto_spell_level) * Math.max(1,this.combat_stats.weapon_range)) : -1;

    var target_team = null;

    var target_full_health_objects;
    if(auto_spell['help']) {
        target_team = this.team;
        target_full_health_objects = false;
    } else {
        if(this.team === 'player') {
            target_team = 'enemy';
        } else {
            target_team = 'player';
        }
        target_full_health_objects = true;
    }

    var target_mobile_only;
    if(('targets_nonmobile' in auto_spell && !auto_spell['targets_nonmobile']) || (this.ai_state === ai_states.AI_DEFEND_MOVE)) {
        target_mobile_only = true;
    } else {
        target_mobile_only = false;
    }

    // create targeting priority table
    var priority_table = gamedata['base_priority_vs']; // start with game defaults

    if(auto_spell['priority_vs'] || auto_spell['damage_vs']) { // merge in spell's priority_vs or damage_vs, if present
        priority_table = merge_damage_vs(priority_table, auto_spell['priority_vs'] || auto_spell['damage_vs']);
    }

    // in the future, this table could be used to cut down on the object query (by skipping objects whose priority would be <= 0)

    var my_pos = this.raw_pos();

    // do we want to bother querying for barriers?
    var exclude_barriers;
    if(auto_spell['priority_vs'] && ('barrier' in auto_spell['priority_vs']) && (auto_spell['priority_vs']['barrier'] > 0)) {
        // if the weapon spell has a positive priority_vs for "barrier", assume we always care about them
        exclude_barriers = false;
    } else {
        // player units ignore barriers when on auto control, or when target_barriers preference is off.
        exclude_barriers = (this.team === 'player' && (get_preference_setting(player.preferences, 'auto_unit_control') || !get_preference_setting(player.preferences, 'target_barriers')));
    }

    var obj_list = world.query_objects_within_distance(my_pos, shoot_range,
                                                 { ignore_object: this,
                                                   exclude_invul: true,
                                                   only_team: target_team,
                                                   exclude_full_health: !target_full_health_objects,
                                                   exclude_barriers: exclude_barriers,
                                                   exclude_minefields: true,
                                                   mobile_only: target_mobile_only,
                                                   exclude_flying: !(auto_spell['targets_air'] || this.combat_stats.anti_air),
                                                   flying_only: !auto_spell['targets_ground'],
                                                   exclude_invisible_to: this.team,
                                                   nearest_only: nearest_only,
                                                   tag: tag
                                                 });

    // within this list, find the object that is 1) highest priority and 2) nearest
    var ret_obj = null;
    var max_priority = -1;
    var min_dist = 9999;
    var min_pos = null;
    var min_path_end = null; // best target requires movement towards this point to reach firing range

    for(var i = 0; i < obj_list.length; i++) {
        var obj = obj_list[i].obj, dist = obj_list[i].dist, pos = obj_list[i].pos;
        var override_priority = obj_list[i].override_priority || null; // this is set for "blocker" objects
        var override_path_end = obj_list[i].override_path_end || null; // this is set for "blocker" objects
        var debug_orig_target = obj_list[i].debug_orig_target || null; // this is set for "blocker" objects

        var path_end = (override_path_end || null);

        if(auto_spell_min_range > 0 && (dist+2*obj.hit_radius()) < auto_spell_min_range) { continue; } // too close

        var priority;
        if(override_priority !== null) {
            priority = override_priority;
        } else {
            priority = get_damage_modifier(priority_table, obj);

            if(prev_target_id && obj.id === prev_target_id && ('prev_target' in priority_table)) {
                // unit prefers to re-use the previous target, even if a new, higher-priority one becomes available
                priority *= priority_table['prev_target'];
            }

            var is_far = false;
            if(priority > 0 && priority_far_range > 0 && dist > priority_far_range && ('far' in priority_table)) {
                // if target is very far away (beyond priority_far_range), then reduce its priority
                priority *= priority_table['far'];
                is_far = true;
            }

            //if(verbose) { console.log(this.spec['name']+' -> '+obj.spec['name']+': dist '+dist.toString()+' auto_spell_range '+auto_spell_range.toString()+' prio '+priority.toString() + (is_far ? 'FAR' : '')); }

        }

        if(verbose) {
            var s = 'considering target: '+obj.spec['name']+' at '+vec_print(obj.raw_pos());
            if(debug_orig_target) { s += ' blocking '+debug_orig_target.spec['name']; }
            console.log(s);
        }

        if(override_priority === null) {

            if(priority > 0 && (dist > auto_spell_range) && ('inaccessible' in priority_table)) {
                // if the spell cares about accessibility, we have to
                // figure out whether we can get in range of the target
                // without destroying something in the way

                // See diagram at https://docs.google.com/a/spinpunch.com/spreadsheets/d/1q9XGfbzhnzK_5V8FP7BoBgkdcK93cQbuMAsf5BIP-Q0/edit?usp=sharing

                // "dest" is the point furthest from the target (along the vector from us to it) where we can just barely be in range to shoot it
                var dest = pos;
                var delta = vec_sub(pos, my_pos);
                var full_len = vec_length(delta);
                if(dist < full_len) {
                    dest = vec_add(my_pos, vec_scale(dist/full_len, delta));
                }
                var ncells = session.viewing_base.ncells();
                var cur_cell = [clamp(Math.floor(my_pos[0]),0,ncells[0]-1),
                                clamp(Math.floor(my_pos[1]),0,ncells[1]-1)];
                var dest_cell = [clamp(Math.floor(dest[0]),0,ncells[0]-1),
                                 clamp(Math.floor(dest[1]),0,ncells[1]-1)];
                var accessible = world.astar_map.linear_path_is_clear(cur_cell, dest_cell) ? 1 : 0;
                if(verbose) { console.log('    direct path clear? '+accessible.toString()); }

                if(!accessible) { // straight-line path is not clear - try an A* path to any cell within shooting range of the target
                    var test_path = null;

                    var test_point = vec_floor(pos);
                    var ring_size;
                    if(!world.astar_map.is_blocked(test_point)) {
                        // destination itself is unblocked, try getting directly to it
                        ring_size = -1;
                        test_path = world.astar_context.search(cur_cell, test_point);
                    } else {
                        // need to search in an expanding ring for unblocked cells
                        ring_size = auto_spell_range + obj.hit_radius();
                        test_path = world.astar_context.ring_search(cur_cell, test_point, ring_size);
                    }

                    if(verbose) {
                        console.log('    PATH to '+obj.spec['name']+' (ring '+ring_size.toString()+'):'); console.log(test_path);
                        if(test_path && test_path.length >= 1) {
                            console.log('    remainder '+(vec_distance(test_path[test_path.length-1], pos) - obj.hit_radius()).toString());
                        }
                    }

                    if(test_path && test_path.length >= 1) {
                        if(verbose) { console.log('    obstacles '+(vec_distance(test_path[test_path.length-1], pos)).toString()+' hit_radius '+obj.hit_radius().toString()+' spell_range '+auto_spell_range.toString()); }
                    }

                    if(test_path && test_path.length >= 1 && vec_distance(test_path[test_path.length-1], pos) - obj.hit_radius() <= auto_spell_range) {
                        // target IS accessible by moving around obstacles

                        // but if the path takes us farther away than our priority_far_range BEYOND the direct path, consider the path not usable
                        // note: using test_path.length here directly is the Manhattan distance approximation, not true distance
                        // XXX the middle test in this if() statement might need further refinement, tweaking exactly
                        // how far out of the way a unit should be willing to go before deciding to break through obstacles instead.
                        if(priority_far_range > 0 && test_path.length >= priority_far_range && ('far' in priority_table)) {
                            if(verbose) { console.log('    deviation too big ('+test_path.length.toString()+' vs '+priority_far_range.toString()+'), treating it as inaccessible'); }
                            accessible = 0;
                            path_end = test_path[test_path.length-1];
                        } else {
                            // target CAN be reached with small path deviation
                            if(verbose) { console.log('    deviation small, going around obstacles'); }
                            accessible = 2;
                            path_end = test_path[test_path.length-1];
                        }
                    }

                    if(!accessible && ('blocker' in priority_table)) { // no cell within shooting range of the target is accessible by a fully clear path
                        // try to identify a barrier along the way, and promote it up near the target's priority
                        if(verbose) {
                            console.log("    LOOKING FOR BLOCKERS cur "+vec_print(cur_cell)+' dest '+vec_print(dest_cell)+' team '+target_team+' obj '+obj.id+' spell '+auto_spell['name']+' range '+auto_spell_range.toString());
                        }
                        var temp = this.ai_pick_target_find_blocker(world, cur_cell, dest_cell, target_team, obj, auto_spell, auto_spell_range,
                                                                    // note: pass damage_vs, not priority_vs, to avoid including things like "barrier":0
                                                                    auto_spell['damage_vs'] || {});
                        if(temp) {
                            var blocker = temp.blocker, blocker_path_end = temp.blocker_path_end;
                            // found something in the way that we can smash!
                            // append it to the list of objects to examine, with priority set to *our main target's* priority, scaled by 'blocker'
                            if(verbose) { console.log("    BLOCKER "+blocker.spec['name']+ ' at '+vec_print(blocker.raw_pos())+' prio '+(priority * priority_table['blocker']).toString()); }
                            obj_list.push(new GameTypes.GameObjectQueryResult(blocker, vec_distance(my_pos, blocker.raw_pos()) - blocker.hit_radius(), blocker.raw_pos(),
                                                                    priority * priority_table['blocker'],
                                                                    blocker_path_end,
                                                                    obj));
                        } else {
                            if(verbose) { console.log("    NO BLOCKER FOUND"); }
                        }
                    }
                }

                if(!accessible) {
                    priority *= priority_table['inaccessible'];
                }
            }
        }

        // switch to this target if it is higher priority than any other target we've checked,
        // OR (it is equal to the highest priority AND closer than any other target of that priority)
        if((priority > max_priority) ||
           ((priority == max_priority) && (dist < min_dist))) {

            if(auto_spell['kills_self'] && priority <= 0) {
                // do not waste suicide explosions against targets that will take no damage from them.
                continue;
            }

            if(verbose) {
                var s = 'new best target! '+obj.spec['name']+' prio '+priority.toString()+' at '+vec_print(obj.raw_pos());
                if(debug_orig_target) { s += ' blocking '+debug_orig_target.spec['name']; }
                console.log(s);
            }

            max_priority = priority;
            min_dist = dist;
            min_pos = pos;
            min_path_end = path_end;
            ret_obj = obj;
        }
    }

    var ret = {target:ret_obj, pos:min_pos, dist:min_dist, /*priority:max_priority,*/ path_end:min_path_end};
    if(verbose) {
        console.log(this.spec['name']+' '+this.id+' now targeting -> '+ret_obj.spec['name']+' at '+vec_print(ret_obj.raw_pos()));
        //console.log(ret);
    }
    return ret;
};

/** This function is called from the target-picking code when a target object is not accessibly by any clear path.
    It tries to find the best blocking object to break to clear the way. (note: regular buildings can also count
    as "blockers", it doesn't have to be a barrier).
    @param {!World.World} world
    @param {!Array.<number>} cur_cell - where we are now
    @param {!Array.<number>} dest_cell - where we want to go (might be blocked)
    @param {string} target_team - limit candidate objects to those on this team
    @param {GameObject} obj - the actual target we're trying to reach
    @param {!Object} auto_spell - our weapon
    @param {number} auto_spell_range - our weapon range
    @param {!Object.<string,number>} priority_table - scales our expected damage against various targets
    @return {{blocker:!GameObject, blocker_path_end: !Array.<number>}|null} - the blocking object, and the nearby cell coordinates from which we can hit it */
// XXX should be a member of Mobile, not GameObject
GameObject.prototype.ai_pick_target_find_blocker = function(world, cur_cell, dest_cell, target_team, obj, auto_spell, auto_spell_range, priority_table) {
    var blocker = null;
    var blocker_path_end = null;

    if(get_preference_setting(player.preferences, 'sg_ai_20150416') || player.get_any_abtest_value('astar_accessibility', gamedata['client']['astar_accessibility'])) {
        // use A* to plot a course through destructible blockers toward the target
        //console.log('astar_accessibility '+vec_print(cur_cell)+' to '+vec_print(dest_cell)+' with range '+auto_spell_range.toString());
        var ring_size = auto_spell_range + obj.hit_radius();
        var ncells = session.viewing_base.ncells();

        // A* cost function
        // cost equals "how fast we can kill it" expressed in units of "time it would take to move one map cell"
        var secs_per_move = 1.0 / this.current_maxvel();
        var my_dps = this.get_leveled_quantity(auto_spell['damage'])/this.get_leveled_quantity(auto_spell['cooldown']);

        var checker = function(cell, ignored_path) {
            var blocker_list = cell.blockers;
            if(!blocker_list) { return AStar.PASS; } // nothing here
            var max_cost = AStar.PASS;
            for(var k = 0; k < blocker_list.length; k++) {
                var b = blocker_list[k];
                if(!b.is_destroyed()) {
                    if(b !== obj && b.is_building() && b.team === target_team) {
                        var damage_mod = get_damage_modifier(priority_table, b);
                        if(damage_mod > 0) {
                            var secs_to_destroy = b.hp / (damage_mod * my_dps);
                            var cost = secs_to_destroy / secs_per_move;
                            //var cost = 0.1; // b.hp / my_damage;
                            max_cost = Math.max(max_cost, cost); // cell cost is max of blocker costs
                        } else {
                            return AStar.NOPASS; // can't damage it
                        }
                    } else {
                        return AStar.NOPASS; // blocked by something we can't destroy
                    }
                }
            }
            return max_cost;
        };
        var checker_key = this.team+':'+this.spec['name']; // checker should be unique to our team and spec

        // perform the query

        // enlarge iter_limit because we want to work very hard to find a path.
        // if no path is found to a valid target, the unit will get stuck "marching in place!"
        var old_limit = world.astar_context.iter_limit;
        var path = world.astar_context.search(cur_cell, dest_cell, checker, checker_key);
        world.astar_context.iter_limit = old_limit;

        if(path && path.length > 0) {
            for(var i = 0; i < path.length; i++) {
                var cell_pos = path[i];
                if(world.astar_map.is_blocked(cell_pos) === AStar.PASS) { continue; } // ignore clear steps along path
                var blocker_list = world.astar_map.cell(cell_pos).blockers;
                if(!blocker_list) { continue; }
                for(var k = 0; k < blocker_list.length; k++) {
                    var b = blocker_list[k];
                    if(b !== obj && !b.is_destroyed() && b.is_building() && b.team === target_team) {
                        // found optimal blocker!
                        blocker = b;
                        // where to stand to smash it?
                        // XXX could optimize by going further back along path to edge of weapon range
                        blocker_path_end = (i > 0 ? path[i-1] : vec_copy(cur_cell));
                        //console.log('astar_accessibility FOUND '+blocker.spec['name']+' at '+vec_print(blocker_path_end));
                        world.playfield_check_pos(blocker_path_end, 'blocker_path_end');
                        break;
                    }
                }
                if(blocker) { break; }
            }
        }
    } else {
    // not indented to minimize diff

    /** @type {Object.<string,boolean>} - set of object IDs we've seen */
    var seen_objects = {}; // for making sure we only evaluate each candidate blocker once

    // Naive/greedy blocker detection: march along the straight line from cur to dest, picking the closest reachable obstacle along it.
    // This could be improved by using A* with a cost function.
    var straight_path = world.astar_map.get_linear_path(cur_cell, dest_cell);

    // Alternatively, this iteration could be done using astar_map, now that it can remember which objects are responsible for blocking a cell.
    // It would probably be faster that way.
    for(var j = 0; j < straight_path.length; j++) {
        // XXX note: this will return slightly different results depending on map_accel_chunk!
        var blocker_list = world.voxel_map_accel.objects_near_xy(straight_path[j], target_team);
        if(!blocker_list) { continue; }
        var min_blocker_dist = Infinity; // use minimum distance from us to blocker to break ties
        for(var k = 0; k < blocker_list.length; k++) {
            var b = blocker_list[k];
            if(b !== obj && !b.is_destroyed() && b.is_building() && b.is_blocker() && !(b.id in seen_objects)) {
                seen_objects[b.id] = true;

                // Check if b actually lies on any cell in the straight path.
                // Since voxel_map_accel is conservative, we have to check each object it returns to see if it's actually on the path.
                // The original SG release didn't have this check, so units would flail around destroying ALL
                // nearby objects returned by voxel_map_accel, instead of only the ones that block their path!
                if(!b.covers_any_of(straight_path)) { continue; }

                var b_pos = b.raw_pos();
                var d = vec_distance(b_pos, cur_cell);
                if(d < min_blocker_dist) {
                    // construct linear path towards blocker
                    var b_path = world.astar_map.get_linear_path(cur_cell, b_pos);

                    // march along the linear path, trying to get in range before hitting a blocker
                    for(var p = 0; p < b_path.length; p++) {
                        var pt = b_path[p];
                        if(p > 0 && world.astar_map.is_blocked(vec_floor(pt))) {
                            break; // can't get directly to this blocker
                        }
                        // in range yet?
                        if(vec_distance(pt, b_pos) - b.hit_radius() <= auto_spell_range) {
                            // found a viable blocker!
                            blocker_path_end = pt;
                            world.playfield_check_pos(blocker_path_end, 'blocker_path_end');
                            blocker = b;
                            min_blocker_dist = d;
                            break;
                        }
                    }
                }
            }
            // don't stop here - just picking the first one found causes grouped units to pick different targets - not good
        }
        if(blocker) { break; } // stop - any other objects would be further along the path and thus further away
    }
    }

    return (blocker && blocker_path_end) ? {blocker:blocker, blocker_path_end:blocker_path_end} : null;
};

// AI-level function - set control state to stop
GameObject.prototype.ai_stop = function() {
    this.control_state = control_states.CONTROL_STOP;
    this.control_spellname = null;
    this.control_target_id = null;
};

// AI-level function - set control state to shoot. Trusts that target is in range!
GameObject.prototype.ai_shoot = function(auto_spell, target) {
    this.control_state = control_states.CONTROL_SHOOT;
    this.control_spellname = auto_spell['name'];
    this.control_target_id = target.id;
    this.serialization_dirty = true;
};

/** AI-level function - set control state to move to a location. "target" is an optional target object to set as control_target
    XXX should be a member of Mobile, not GameObject
    @param {Array<number>|null} new_dest
    @param {GameObject|null} target
    @param {string} reason */
GameObject.prototype.ai_move_towards = function(new_dest, target, reason) {
    if(!new_dest) { this.ai_stop(); return; } // nowhere to go

    this.control_spellname = null;
    this.control_target_id = (target ? target.id : null);

    if(vec_equals(this.raw_pos(), new_dest)) {
        this.control_state = control_states.CONTROL_STOP; // already here
        this.dest = new_dest;
    } else {
        this.control_state = control_states.CONTROL_MOVING;
        if(!vec_equals(this.dest, new_dest)) {
            if(!vec_equals_integer(this.dest, new_dest)) {
                this.path_valid = false;
            }
            this.dest = new_dest;
        }
    }
};

/** AI-level function - set control state to attack or pursue a target, as retured by ai_pick_target()
    @param {!World.World} world
    @param {Object} auto_spell
    @param {number} auto_spell_level
    @param {Object} targeting_result */
GameObject.prototype.ai_pursue_target = function(world, auto_spell, auto_spell_level, targeting_result) {
    var auto_spell_range = gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['range'], auto_spell_level) * this.combat_stats.weapon_range;
    var auto_spell_eff_range = ('effective_range' in auto_spell) ? gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['effective_range'], auto_spell_level) * this.combat_stats.effective_weapon_range : auto_spell_range;
    var auto_spell_min_range = ('min_range' in auto_spell) ? gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['min_range'], auto_spell_level) : -1; // * Math.max(1,this.combat_stats.weapon_range); ?

    this.ai_target = targeting_result.target;
    if(this.ai_target) {
        this.ai_target.next_ai_attackers_list.push(this.id);
    }

    // if the target is in effective range, shoot it.
    // if the target is in range but not in effective range, shoot it if our weapon is not on cooldown
    // if our weapon is on cooldown, move closer (but if in hold-position, do not move)
    // otherwise, move closer
    if((targeting_result.dist <= auto_spell_range) &&
       (auto_spell_min_range < 0 || (targeting_result.dist+2*targeting_result.target.hit_radius()) >= auto_spell_min_range) &&
       ((targeting_result.dist <= auto_spell_eff_range) || (this.ai_state === ai_states.AI_ATTACK_STATIONARY) || (this.control_cooldown <= 0))) {
        this.ai_shoot(auto_spell, this.ai_target);
    } else if(this.is_mobile() && this.ai_state !== ai_states.AI_ATTACK_STATIONARY) {
        if(auto_spell_min_range >= 0) { throw Error('need to implement ai_move_away'); }
        var dest;
        if(targeting_result.path_end) {
            dest = targeting_result.path_end;
            world.playfield_check_pos(dest, 'ai_pursue_target (targeting_result.path_end)');
        } else {
            dest = targeting_result.pos;
            var reason = 'targeting_result.pos';

            if(gamedata['enable_accurate_target_selection_distance'] &&
               (targeting_result.dist > 0 || world.astar_map.is_blocked(vec_floor(dest)))) {
                // move to nearest edge of target, not center of target
                // (not sure about the is_blocked check - when dist is zero so that unit will stay in place (dest = my_pos) (?))
                var my_pos = this.raw_pos();
                var delta = vec_sub(targeting_result.pos, my_pos);
                var full_len = vec_length(delta);
                if(targeting_result.dist < full_len) {
                    dest = vec_add(my_pos, vec_scale(targeting_result.dist/full_len, delta));
                    reason = 'targeting_result.pos -> accurate';
                }
            }
            world.playfield_check_pos(dest, 'ai_pursue_target ('+reason+')');
        }
        this.ai_move_towards(dest, this.ai_target, 'ai_pursue_target');
    } else {
        this.ai_stop(); // can't move

        // if a turret's current target moves out of range, try to switch to a closer target
        if(!this.is_mobile() && this.ai_threatlist !== null) {
            this.ai_threatlist_dirty = true;
        }
    }
};

/** move on to next queued order, defaulting to AI_ATTACK_ANY (and returning true) if none apply
    @param {!World.World} world */
GameObject.prototype.next_ai_order = function(world) {
    this.state_dirty |= obj_state_flags.ORDERS;

    if(this.orders.length > 0) {
        var old_order = this.orders.shift();

        if(this.is_mobile() && this.patrol) {
            // recycle old order
            this.orders.push(old_order);
        }
    }

    if(this.orders.length == 0) {
        var dest;
        if(this.ai_dest) {
            dest = this.ai_dest;
        } else if(session.viewing_base.base_landlord_id != session.user_id && this.team === 'player') {
            // on offense, units should not adopt any position as "home" to leash back to
            // not sure if we want to also apply this to enemy units invading player's home base
            dest = null;
        } else {
            dest = this.raw_pos();
        }

        // quantize dest
        if(dest) { dest = [Math.floor(dest[0]), Math.floor(dest[1])]; }

        var order = {'state': ai_states.AI_ATTACK_ANY, 'dest': dest};
        this.new_order(world, order, true);
        return true;
    } else {
        this.apply_orders(world);
    }
    return false;
};
/** @param {!World.World} world */
GameObject.prototype.run_behaviors = function(world) {
    if(this.behaviors === null) { return; }
    if(this.is_destroyed()) { return; }
    if(this.team === 'player') { return; } // no behaviors for player-controlled objects
    goog.array.forEach(this.behaviors, function(behavior_name) {
        // maybe convert these into predicates/consequents later?
        if(behavior_name === 'damage_alarm') {
            if(!('damage_alarm' in this.behavior_state)) {
                this.behavior_state['damage_alarm'] = {'start_hp': this.hp, 'triggered': 0};
            }
            var state = this.behavior_state['damage_alarm'];
            if(!state['triggered'] && this.hp < state['start_hp']) {
                state['triggered'] = 1;
                session.for_each_real_object(function(obj) {
                    if(obj.is_mobile() && obj.team === this.team) {
                        // note: we don't want to persist this aggro to the server for subsequent attacks!
                        // so just set the AI mode without going through the "orders" path
                        //do_unit_command_make_aggressive(world, obj);
                        obj.ai_aggressive = true;
                        // and suppress leashing for the rest of the battle
                        obj.ai_leash_after = GameTypes.TickCount.infinity;
                    }
                }, this);
            }
        } else if(behavior_name === 'pack_aggro') {
            if(!('pack_aggro' in this.behavior_state)) {
                this.behavior_state['pack_aggro'] = {'next_trigger': new GameTypes.TickCount(0)};
            }
            var state = this.behavior_state['pack_aggro'];
            var holdoff_ticks = relative_time_to_tick('leash_holdoff_time' in gamedata['map'] ?
                                                      gamedata['map']['leash_holdoff_time'] : 5);
            if(GameTypes.TickCount.gt(world.combat_engine.cur_tick, state['next_trigger']) && this.ai_target) {
                // don't fire again until TWO holdoff periods
                state['next_trigger'] = GameTypes.TickCount.add(world.combat_engine.cur_tick,
                                                                GameTypes.TickCount.scale(2, holdoff_ticks));
                session.for_each_real_object(function(obj) {
                    if(obj.is_mobile() && obj.pack_id === this.pack_id && obj.team === this.team) {
                        // note: include self in this iteration!
                        if(obj !== this) {
                            // synchronize trigger time for him too
                            if(!('pack_aggro' in obj.behavior_state)) {
                                obj.behavior_state['pack_aggro'] = {'next_trigger': state['next_trigger']};
                            } else {
                                obj.behavior_state['pack_aggro']['next_trigger'] =
                                    GameTypes.TickCount.max(state['next_trigger'],
                                                            obj.behavior_state['pack_aggro']['next_trigger']);
                            }
                        }
                        //do_unit_command_attack(world, obj, this.ai_target, false, true);
                        // note: we don't want to persist this aggro to the server for subsequent attacks!
                        // so just set the AI mode without going through the "orders" path
                        //do_unit_command_make_aggressive(world, obj);
                        obj.ai_aggressive = true;

                        // and suppress leashing temporarily
                        obj.ai_leash_after = GameTypes.TickCount.max(obj.ai_leash_after,
                                                                     GameTypes.TickCount.add(world.combat_engine.cur_tick,
                                                                                             holdoff_ticks));
                    }
                }, this);
            }
        } else if(behavior_name === 'aggro_pulse') {
            if(!('aggro_pulse' in this.behavior_state)) {
                this.behavior_state['aggro_pulse'] = {'triggered': 0};
            }
            var state = this.behavior_state['aggro_pulse'];
            if(!state['triggered'] && this.ai_target) {
                state['triggered'] = 1;
                var radius = ('aggro_radius' in this.spec ? this.get_leveled_quantity(this.spec['aggro_radius']) :
                              gamedata['map']['aggro_radius'][this.team]['defense']); // assume this is a defending unit
                var objlist = session.get_real_world().query_objects_within_distance(this.raw_pos(), radius,
                                                                                     { only_team: this.team,
                                                                                       ignore_object: this,
                                                                                       mobile_only: true });
                goog.array.forEach(objlist, function(entry) {
                    // note: we don't want to persist this aggro to the server for subsequent attacks!
                    // so just set the AI mode without going through the "orders" path
                    entry.obj.ai_aggressive = true;
                }, this);
            }
        } else if(behavior_name === 'team_flip') {
            if(!('team_flip' in this.behavior_state)) {
                this.behavior_state['team_flip'] = {'triggered': 0};
            }
            var state = this.behavior_state['team_flip'];
            if(!state['triggered']) {
                state['triggered'] = 1;
                if(this.team === 'player') {
                    this.team = 'enemy';
                } else if(this.team === 'enemy') {
                    this.team = 'player';
                }
            }
        } else if(behavior_name === 'self_destruct') {
            if(!('self_destruct' in this.behavior_state)) {
                this.behavior_state['self_destruct'] = {'triggered': 0};
            }
            var state = this.behavior_state['self_destruct'];
            if(this.hp < 0.9*this.max_hp && !state['triggered']) {
                state['triggered'] = 1;
                world.combat_engine.queue_damage_effect(new CombatEngine.KillDamageEffect(world.combat_engine.cur_tick, client_time, this.id, null, this.id, 'hostile'));
            }
        }
    }, this);
};

/** @param {!World.World} world */
GameObject.prototype.run_ai = function(world) {
    this.is_leashing = false;

    if(this.is_destroyed()) {
        this.ai_stop();
        return;
    }

    if(!this.can_accept_commands()) {
        // deactivate AI for friendly units on the battlefield before battle start
        return;
    }

    var auto_spell = this.get_auto_spell();
    var auto_spell_level = this.get_auto_spell_level();
    var auto_spell_range, auto_spell_eff_range, auto_spell_min_range;
    if(auto_spell) {
        auto_spell_range = gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['range'], auto_spell_level) * this.combat_stats.weapon_range;
        auto_spell_eff_range = ('effective_range' in auto_spell) ? gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['effective_range'], auto_spell_level) * this.combat_stats.effective_weapon_range : auto_spell_range;
        auto_spell_min_range = ('min_range' in auto_spell) ? gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['min_range'], auto_spell_level) : -1; // * Math.max(1,this.combat_stats.weapon_range); ?

    } else {
        auto_spell_range = auto_spell_eff_range = auto_spell_min_range = -1;
    }

    if(this.ai_state === ai_states.AI_ATTACK_SPECIFIC) {
        if(!auto_spell) {
            throw Error('AI_ATTACK state but unit has no auto-cast spell');
        }
        if(auto_spell_min_range > 0) { throw Error('AI_ATTACK_SPECIFIC not supported when spell has min_range'); } // needs code to back away if too close

        // override target if player has selected "Unit Defends Self" option
        if(this.team == 'player' && !!player.preferences['unit_defends_self'] && !!player.preferences['self_defense_aggression'] && this.is_being_attacked() && !this.is_attacking_attacker() && this.strongest_attacker_id && world.objects.has_object(this.strongest_attacker_id) && !world.objects.get_object(this.strongest_attacker_id).is_destroyed()) {
            var retaliate_obj = world.objects.get_object(this.strongest_attacker_id);
            var retaliate_pos = retaliate_obj.raw_pos();
            this.ai_pursue_target(world, auto_spell, auto_spell_level, {target: retaliate_obj, pos: retaliate_pos, dist: Math.max(0, vec_distance(this.raw_pos(), retaliate_pos) - retaliate_obj.hit_radius()), path_end: null});
        } else if(this.ai_target === null || this.ai_target.is_destroyed()) { // if the target is dead, switch to AI_ATTACK_ANY
            this.ai_target = null;
            this.next_ai_order(world);
        } else if(!(auto_spell['targets_air'] || this.combat_stats.anti_air) && this.ai_target.is_flying()) {
            // prevent non-anti-air weapons from shooting at air target
            this.ai_target = null;
            this.next_ai_order(world);
        } else if(!auto_spell['targets_ground'] && !this.ai_target.is_flying()) {
            // prevent anti-air-only weapons from shooting at ground target
            this.ai_target = null;
            this.next_ai_order(world);
        } else {
            var target_pos = this.ai_target.raw_pos();
            var dist = vec_distance(this.raw_pos(), target_pos) - this.ai_target.hit_radius();
            this.ai_pursue_target(world, auto_spell, auto_spell_level, {target:this.ai_target, pos:target_pos, dist:dist});
        }
    }

    if(this.ai_state === ai_states.AI_ATTACK_ANY || this.ai_state === ai_states.AI_ATTACK_STATIONARY ||
       this.ai_state === ai_states.AI_ATTACK_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO || this.ai_state === ai_states.AI_DEFEND_MOVE) {
        if(!auto_spell) {
            throw Error('AI_ATTACK state but unit has no auto-cast spell');
        }

        var shoot_range = auto_spell_range;

        var offense_or_defense;
        var /** string */ other_team;
        if(this.team == 'player') {
            offense_or_defense = (session.viewing_base.base_landlord_id == session.user_id ? 'defense' : 'offense');
            other_team = 'enemy';
        } else {
            offense_or_defense = (session.viewing_base.base_landlord_id == session.user_id ? 'offense' : 'defense');
            other_team = 'player';
        }

        var leash_radius = -1;

        // for leashing, we care whether the aggressive setting is only temporary (e.g. from pack aggro)
        // or ordered by the player
        //var is_permanently_aggressive = this.ai_aggressive;
        var is_permanently_aggressive = this.ai_aggressive && (this.orders.length > 0 && this.orders[0]['aggressive']);

        // check whether unit should leash
        if(this.is_mobile() && player.get_any_abtest_value('enable_leash_radius', gamedata['enable_leash_radius']) &&
           GameTypes.TickCount.gt(world.combat_engine.cur_tick, this.ai_leash_after) &&
           (player.tutorial_state == "COMPLETE") // no leashing during tutorial
          ) {
            // leash if (not aggressive) OR (aggressive, but no enemies are in the world)
            if(!is_permanently_aggressive || !world.team_map_accel.has_any_of_team(other_team)) {
                if('leash_radius' in this.spec) {
                    leash_radius = this.get_leveled_quantity(this.spec['leash_radius']);
                } else {
                    leash_radius = gamedata['map']['leash_radius'][this.team][offense_or_defense];
                }
            }
        }

        var leash_distance = -1;
        if(leash_radius > 0 &&
           (this.ai_state === ai_states.AI_ATTACK_ANY || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO) &&
           this.ai_dest) {
            leash_distance = vec_distance(this.raw_pos(), this.ai_dest);

            // check leash before shooting
            if(player.get_any_abtest_value('enable_leash_radius_while_shooting', gamedata['enable_leash_radius_while_shooting'])) {
                if(leash_distance >= leash_radius) {
                    // ignore all targets, leash!
                    shoot_range = 0;
                    this.is_leashing = true;
                }
            }
        }

        // reset targeting
        this.ai_target = null;

        // find best targetable objects within shooting range
        var targeting_result = null;
        if(this.is_mobile() && this.ai_state !== ai_states.AI_ATTACK_STATIONARY && (gamedata['enable_global_targeting'] || auto_spell['global_targeting'])) {
            targeting_result = null; // skip directly to the aggro-range query
        } else if(shoot_range > 0) {
            targeting_result = this.ai_pick_target(world, auto_spell, auto_spell_level, shoot_range, false, 'enemies_near');
        }

        if(targeting_result && targeting_result.target) {
            // a target has been found within max weapon range
            this.ai_pursue_target(world, auto_spell, auto_spell_level, targeting_result);

            // BUT, as a special case, if we are mobile and shooting at a
            // nonmobile, non-dangerous target, and we are being
            // attacked by something that we are able to shoot, then
            // retarget and either shoot or move towards the attacker
            // ignores this last_attacker logic if unit_defends_self is on and it belongs to the player
            if(this.is_mobile() && shoot_range > 0 && !this.ai_target.is_mobile() && !this.ai_target.is_shooter() &&
               (!this.ai_target.is_building() || !this.ai_target.is_turret()) &&
               ((this.ai_state !== ai_states.AI_ATTACK_STATIONARY) || (this.team !== 'player')) &&
               this.last_attacker && !this.last_attacker.is_destroyed() && (this.last_attacker.is_mobile() || this.last_attacker.is_building()) &&
               ((auto_spell['targets_ground'] && !this.last_attacker.is_flying()) ||
                ((auto_spell['targets_air'] || this.combat_stats.anti_air) && this.last_attacker.is_flying())) &&
               vec_distance(this.raw_pos(), this.last_attacker.raw_pos()) <= this.last_attacker.weapon_range()[1] &&
               !(auto_spell['help'] || 0) && !(this.team == 'player' && !!player.preferences['unit_defends_self'])) {
                //console.log('SPECIAL CASE: SWITCHING TARGET TO '+this.last_attacker.spec['name']);

                var last_attacker_pos = this.last_attacker.raw_pos();
                this.ai_pursue_target(world, auto_spell, auto_spell_level, {target:this.last_attacker, pos:last_attacker_pos, dist:vec_distance(this.raw_pos(), last_attacker_pos) - this.last_attacker.hit_radius()});
            } else if (this.team == 'player' && !!player.preferences['unit_defends_self'] && this.is_being_attacked() && !this.is_attacking_attacker() && this.strongest_attacker_id) {
                var retaliate_obj = world.objects.get_object(this.strongest_attacker_id);
                var retaliate_pos = retaliate_obj.raw_pos();
                this.ai_pursue_target(world, auto_spell, auto_spell_level, {target: retaliate_obj, pos: retaliate_pos, dist: Math.max(0, vec_distance(this.raw_pos(), retaliate_pos) - retaliate_obj.hit_radius())});
            }

        } else {
            // no target within shooting range - look beyond range now

            if(!this.is_mobile()) {
                this.ai_stop(); // can't move

                // but, turrets should stay on the lookout for new targets that come into range
                if(this.ai_threatlist !== null) {
                    this.ai_threatlist_dirty = true;
                }

            } else {

                if(this.ai_state === ai_states.AI_ATTACK_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO) {
                    // proceed to a-move destination
                    this.ai_move_towards(this.ai_dest, null, 'amove');
                }

                // if no target has been found yet, and we're mobile, then move towards the nearest enemy object
                // within aggro radius
                if(this.ai_aggressive || this.ai_state === ai_states.AI_ATTACK_ANY || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO) {
                    var ncells = session.viewing_base.ncells();
                    var entire_map = Math.max(ncells[0], ncells[1]);

                    // only pursue targets within aggro radius
                    var aggro_radius;
                    if('aggro_radius' in this.spec) {
                        aggro_radius = this.get_leveled_quantity(this.spec['aggro_radius']);
                    } else {
                        aggro_radius = gamedata['map']['aggro_radius'][this.team][offense_or_defense];
                    }

                    // if aggressive (or a healer), use the entire map
                    if(this.is_permanently_aggressive /* || auto_spell['help'] */) {
                        aggro_radius = entire_map;
                    } else if(this.ai_aggressive) {
                        if(leash_distance < 0) {
                            aggro_radius = entire_map;
                        } else if(leash_distance >= leash_radius) {
                            // leash back
                            aggro_radius = 0;
                            this.is_leashing = true;
                        } else {
                            // constrain aggro to not take the unit beyond leash radius again
                            // limit aggro to "gap" (distance remaining before leash ends) plus weapon range, to avoid oscillation when aggro expands after beginning to leash
                            aggro_radius = Math.max(0, Math.min(aggro_radius, (leash_radius - leash_distance) + shoot_range));
                        }
                    }

                    if(aggro_radius > 0) {
                        // make sure aggro radius is at least as big as weapon range
                        aggro_radius = Math.max(aggro_radius, shoot_range);
                    }

                    // find nearest targetable object within aggro range
                    this.ai_target = null;

                    // note: using the nearest_only flag here, which turns
                    // off prioritization for distant targets, is probably
                    // wrong behavior-wise, but the old (pre-SG) code
                    // behaved that way, and we do not want to
                    // unexpectedly change combat AI behavior in old
                    // games, so optionally use the old behavior.
                    var bad_long_range_targeting = !gamedata['enable_prioritized_long_range_targeting'];
                    var long_range_targeting_result = this.ai_pick_target(world, auto_spell, auto_spell_level, aggro_radius, bad_long_range_targeting, 'enemies_far');

                    if(long_range_targeting_result && long_range_targeting_result.target) {
                        this.ai_pursue_target(world, auto_spell, auto_spell_level, long_range_targeting_result);
                    } else if(this.ai_dest) {
                        // leash back to "home" location
                        this.ai_move_towards(this.ai_dest, null, 'leash');
                    }
                }
            }
        }
    }

    if(this.ai_state === ai_states.AI_STOP) {
        this.ai_stop();
    }

    if('special_ai' in this.spec) {
        read_consequent(this.spec['special_ai']).execute({'source_obj':this}); // , 'xy': this.raw_pos()});
    }

    // on_approach handling - XXX convert this to a special_ai ?

    // @type {Array<Object<string,?>>|null} List of consequents
    var on_approach = this.get_on_approach_consequents();

    if(!session.is_replay() && on_approach && !this.on_approach_fired) {
        var pred = read_predicate({'predicate': 'HOSTILE_UNIT_NEAR'});
        // note: rely on the predicate check below mutating qdata with 'hostile_obj' to record the triggerer
        var qdata = {'source_obj': this,
                     'distance': gamedata['map']['aggro_radius'][this.team]['defense']
                    };
        if(pred.is_satisfied(player, qdata)) {
            this.fire_on_approach_secteams(on_approach, qdata['hostile_obj'].id);
        }
    }
};

/** Get a list of (JSON) consequents that this object should run when enemies approach
    @return {Array<Object<string,?>>|null} List of consequents */
GameObject.prototype.get_on_approach_consequents = function() {
    return (this.is_mobile() ? get_unit_stat(this.team === 'player' ? player.stattab : enemy.stattab,
                                             this.spec['name'], 'on_approach', null) :
            this.is_building() ? this.get_stat('on_approach', null) : null);
};

/** Tell the server we are firing our ON_APPROACH consequent
    @param {Array<Object<string,?>>|null} on_approach consequent list from above
    @param {GameObjectId|null} source_obj_id that triggered this */
GameObject.prototype.fire_on_approach_secteams = function(on_approach, source_obj_id) {
    goog.array.forEach(on_approach, function(cons) {
        if(this.on_approach_fired) { return; }
        if(cons['consequent'] === 'SPAWN_SECURITY_TEAM') {
            send_to_server.func(["ON_APPROACH", this.id, this.raw_pos(), source_obj_id, client_time]);
            this.on_approach_fired = true;
        }
    }, this);
};

/**
 * Get the map cells occupied by a building or inert at position "xy" with size "gridsize"
 * returns [[x_lo,x_hi], [y_lo,y_hi]]  (where lo to hi-1 are blocked, hi itself is not blocked)
 * Must match get_grid_bounds() in server Python!
 * @param {Array.<number>} xy
 * @param {Array.<number>} gridsize
 */
function get_grid_bounds(xy, gridsize) {
    // by convention, xy is at the "center" of the object
    // for objects with odd gridsizes, the bound is extended one unit east/south
    var half = [gridsize[0]>>1, gridsize[1]>>1]; // vec_floor(vec_add(vec_scale(0.5, gridsize), [0.5,0.5]));
    var extra = [(gridsize[0]&1) ? 1 : 0,
                 (gridsize[1]&1) ? 1 : 0];
    return [[xy[0]-half[0], xy[0]+half[0]+extra[0]],
            [xy[1]-half[1], xy[1]+half[1]+extra[1]]];
}

/** @param {!World.World} world
 * Instantiate any permanent SPFX effect specified by this object's spec and stores a reference to it
 * in this.permanent_effect. Does nothing if that effect has already been created.
 */
GameObject.prototype.update_permanent_effect = function(world) {
    if(this.is_destroyed() || this.is_under_construction()) {
        this.remove_permanent_effect(world);
        return;
    }

    var fx = this.get_leveled_quantity(this.spec['permanent_effect'] || null);
    if(!fx) {
        this.remove_permanent_effect(world);
        return;
    }

    var pos = this.interpolate_pos(world);

    // if we already have an effect, but it's the wrong one, then remove it
    if(this.permanent_effect && (this.permanent_effect_source !== fx)) {
        this.remove_permanent_effect(world);
    }

    if(this.permanent_effect) {
        // move existing effect
        this.permanent_effect.reposition([pos[0], this.combat_stats.altitude || 0, pos[1]]);
    } else {
        // create new effect
        this.permanent_effect = world.fxworld.add_visual_effect_at_time(pos, this.combat_stats.altitude || 0, [0, 1, 0], client_time, fx, true, null);
        this.permanent_effect_source = fx;
    }
};

/** @param {!World.World} world
 * Removes any permanent SPFX effects attached to this object.
 */
GameObject.prototype.remove_permanent_effect = function(world) {
    if(this.permanent_effect) {
        world.fxworld.remove(this.permanent_effect);
        this.permanent_effect = null;
        this.permanent_effect_source = null;
    }
};

/**
 * @constructor @struct
 * @extends GameObject
 */
function MapBlockingGameObject() {
    goog.base(this);

    /** @type {Object|null} */
    this.removing = null;

    /** @type {World.World|null} world we've been added to */
    this.world = null;

    this.sync_marker = Synchronizer.INIT; // for holding the UI until server catches up to a specific request

    // NESW neighbor presence - this is how much to ADD to bound size in each direction because of the presence or absence of a neighbor.
    // Only updated by WallManager.
    this.neighbors = [0,0,0,0];

    // for debugging only, record a history of the times we were blocked/unblocked
    this.debug_block_history = [];
}
goog.inherits(MapBlockingGameObject, GameObject);

MapBlockingGameObject.prototype.is_blocker = function() { return true; };

MapBlockingGameObject.prototype.request_sync = function() { this.sync_marker = synchronizer.request_sync(); return this.sync_marker; };
MapBlockingGameObject.prototype.is_in_sync = function() { return synchronizer.is_in_sync(this.sync_marker); };

MapBlockingGameObject.prototype.is_removing = function() {
    return !!this.removing;
}
MapBlockingGameObject.prototype.time_until_finish = function() {
    if(this.is_removing()) {
        var bus = this.removing;
        if(bus['start_time'] <= 0) { throw Error('invalid state: removing halted'); }
        return bus['start_time'] + bus['total_time'] - bus['done_time'] - server_time;
    } else {
        return -1;
    }
};

MapBlockingGameObject.prototype.remove_time_left = function() {
    var bus = this.removing;
    var ret = bus['total_time'] - bus['done_time'];
    if(bus['start_time'] > 0) {
        ret -= (server_time - bus['start_time']);
    }
    return ret;
};
MapBlockingGameObject.prototype.remove_progress = function() {
    var bus = this.removing;
    return (bus['done_time'] + (bus['start_time'] > 0 ? (server_time - bus['start_time']) : 0))/bus['total_time'];
};
MapBlockingGameObject.prototype.activity_speedup_kind = function() {
    if(this.is_removing()) {
        return 'remove';
    } else {
        return null;
    }
};

/** @override */
MapBlockingGameObject.prototype.on_added_to_world = function(world) {
    goog.base(this, 'on_added_to_world', world);
    if(this.world !== null) { throw Error('already added to world'); }
    this.world = world;
    this.update_map(null, [this.x,this.y], this.is_destroyed(), 'on_added_to_world');
};
/** @override */
MapBlockingGameObject.prototype.on_removed_from_world = function(world) {
    goog.base(this, 'on_removed_from_world', world);
    if(this.world !== world) { throw Error('not added to world world'); }
    this.world = null;
    this.update_map(world, [this.x,this.y], this.is_destroyed(), 'on_removed_from_world');
};

/** @override */
MapBlockingGameObject.prototype.apply_snapshot = function(snap) {
    var old_x = this.x, old_y = this.y;
    var was_destroyed = this.is_destroyed();
    goog.base(this, 'apply_snapshot', snap);
    this.update_map(this.world, [old_x, old_y], was_destroyed, 'apply_snapshot(destr '+(was_destroyed?'1':'0')+'->'+(this.is_destroyed()?'1':'0'));
};

/** @override */
MapBlockingGameObject.prototype.receive_state = function(data, init, is_deploying) {
    var old_x = this.x, old_y = this.y;
    var was_destroyed = (this.spec ? this.is_destroyed() : false);

    goog.base(this, 'receive_state', data, init, is_deploying);
    this.removing = data.shift();

    this.update_map(this.world, [old_x, old_y], was_destroyed, 'receive_state(destr '+(was_destroyed?'1':'0')+'->'+(this.is_destroyed()?'1':'0'));
};

/** Update collision data structure after a possible change in position and destruction state
    @param {World.World|null} old_world
    @param {!Array.<number>} old_xy
    @param {boolean} was_destroyed before this update
    @param {string} reason, for debugging */
MapBlockingGameObject.prototype.update_map = function(old_world, old_xy, was_destroyed, reason) {
    // update collision data structure
    if(this.world !== old_world || this.x != old_xy[0] || this.y != old_xy[1] || was_destroyed != this.is_destroyed()) {
        if(old_world && old_xy[0] != -1 && old_xy[1] != -1 && !was_destroyed) {
            // unblock old location
            this.block_map_at(old_world, old_xy, -1, reason);
        }
        // block new location
        if(this.world && !this.is_destroyed()) {
            this.block_map(1, reason);
        }

        if(this.world) {
            var wall_mgr = this.world.wall_mgr;
            if(wall_mgr && wall_mgr.spec === this.spec) { wall_mgr.dirty = true; }
        }
    }
};

/** @return {!Array.<!Array.<number>>} map bounds CURRENTLY blocked
    (may differ from original bounds if using collide_as_wall setting) */
MapBlockingGameObject.prototype.current_collision_bounds = function(xy) {
    var b = get_grid_bounds(xy, this.spec['unit_collision_gridsize']);
    b[0][0] -= this.neighbors[3]; // west neighbor
    b[0][1] += this.neighbors[1]; // east
    b[1][0] -= this.neighbors[0]; // north
    b[1][1] += this.neighbors[2]; // south
    return b;
};

MapBlockingGameObject.prototype.set_neighbors = function(new_neighbors) {
    if(!goog.array.some(this.neighbors, function(n, i) { return n != new_neighbors[i]; })) {
        return; // no delta
    }
    this.block_map(-1, 'set_neighbors(-1)');
    this.neighbors = new_neighbors;
    this.block_map(1, 'set_neighbors(1)');
};

/** Return true if this object overlays any grid cell along a list of cells
    @param {Array.<Array.<number>>} path
    @return {boolean} */
MapBlockingGameObject.prototype.covers_any_of = function(path) {
    var bounds = this.current_collision_bounds([this.x,this.y]);
    return goog.array.some(path, function(xy) {
        return (xy[0] >= bounds[0][0] && xy[0] < bounds[0][1] &&
                xy[1] >= bounds[1][0] && xy[1] < bounds[1][1]);
    });
};

/** @private
    @param {!World.World} world
    @param {!Array.<number>} xy of the building itself
    @param {number} incr to add/subtract from blockage
    @param {string} reason, for debugging */
MapBlockingGameObject.prototype.block_map_at = function(world, xy, incr, reason) {
    if(this.spec['unit_collision_gridsize'][0] <= 0) {
        return;
    }
    var bounds = this.current_collision_bounds(xy);
    if(!reason || typeof(reason) !== 'string') { throw Error('bad reason'); }
    this.debug_block_history.push({'xy':xy, 'incr':incr, 'reason':reason});
    world.astar_map.block_map([bounds[0][0], bounds[1][0]], [bounds[0][1]-bounds[0][0], bounds[1][1]-bounds[1][0]], incr, this, reason);
    invalidate_unit_paths();
    invalidate_all_threatlists();
};

/** Block/unblock map at current location
    @param {number} incr
    @param {string} reason, for debugging */
MapBlockingGameObject.prototype.block_map = function(incr, reason) {
    if(this.world) {
        this.block_map_at(this.world, [this.x, this.y], incr, reason);
    }
};
/** @override */
MapBlockingGameObject.prototype.hit_radius = function() {
    // approximation - multiply by sqrt(2) for the diagonal
    var rad = 1.414 * 0.5 * Math.max(this.spec['unit_collision_gridsize'][0],
                                     this.spec['unit_collision_gridsize'][1]);
    rad *= gamedata['map']['building_hitbox_scale'];
    return rad;
};

/** @override as a special case, destroyed map objects are pushed backwards in Z order */
MapBlockingGameObject.prototype.calc_draw_pos = function(world) {
    // in space, drop buildings downward
    var flat = (this.is_building() && world && world.base.base_climate_data['fly_at_ground_level']);

    if(!this.is_destroyed() && !flat) {
        return goog.base(this, 'calc_draw_pos', world);
    }

    var p = [this.x - this.spec['unit_collision_gridsize'][0]/2,
             this.y - this.spec['unit_collision_gridsize'][1]/2];
    var depth = ortho_to_depth(p);
    return [[this.x, this.y], depth];
};

/** @override */
MapBlockingGameObject.prototype.detect_click = function(world, xy, ji, zoom, fuzz) {
    var pos = this.interpolate_pos(world);
    // check orthogonal grid position against object's base area
    var bounds = get_grid_bounds(pos, this.spec['gridsize']);
    if(ji[0] >= bounds[0][0] && ji[0] < bounds[0][1] && ji[1] >= bounds[1][0] && ji[1] < bounds[1][1]) {
        return true;
    }
    if(this.spec['click_bounds']) {
        var c = ortho_to_playfield(pos);
        var b = this.spec['click_bounds'];
        var s = screen_to_playfield(xy);
        if(s[0] >= c[0]+b[0][0] && s[0] < c[0]+b[0][1] && s[1] >= c[1]+b[1][0] && s[1] < c[1]+b[1][1]) {
            return true;
        }
    } else if(this.spec['click_detection'] == 'sprite') {
        var asset = GameArt.assets[this.get_leveled_quantity(this.spec['art_asset'])];
        if(asset.detect_click(ortho_to_screen(pos), this.interpolate_facing(world), client_time, 'normal', xy, view_zoom, fuzz)) {
            return true;
        }
    }
    return false;
};

/**
 * @constructor @struct
 * @extends MapBlockingGameObject
 */
function Inert() {
    goog.base(this);
    this.metadata = null;
    // true if we sent a collect action and are waiting to hear back from server
    this.collect_sent = false;
}
goog.inherits(Inert, MapBlockingGameObject);
/** @override */
Inert.prototype.receive_state = function(data, init, is_deploying) {
    goog.base(this, 'receive_state', data, init, is_deploying);
    this.metadata = data.shift();
};
/** @override */
Inert.prototype.serialize = function() {
    var ret = goog.base(this, 'serialize');
    if(this.metadata) {
        ret['metadata'] = deepcopy(this.metadata);
    }
    return ret;
};
/** @override */
Inert.prototype.apply_snapshot = function(snap) {
    goog.base(this, 'apply_snapshot', snap);
    if('metadata' in snap) { this.metadata = snap['metadata']; }
};
/** @override as a special case, "flat" inert objects are pushed backwards in Z order */
Inert.prototype.calc_draw_pos = function(world) {
    if(this.spec['draw_flat']) {
        // use depth of the far northwest corner rather than the center
        var p = [this.x - this.spec['gridsize'][0]/2,
                 this.y - this.spec['gridsize'][1]/2];
        var depth = ortho_to_depth(p);
        // add bias to Z depth calc for layering
        var depth_bias = ('depth_bias' in this.spec ? this.spec['depth_bias'] : (this.spec['auto_spawn'] ? -1 : 0));
        depth += 1000*depth_bias;
        return [[this.x, this.y], depth];
    } else {
        return goog.base(this, 'calc_draw_pos', world);
    }
};

/**
 * @constructor @struct
 * @extends MapBlockingGameObject
 */
function Building() {
    goog.base(this);
    this.repair_finish_time = -1;
    this.disarmed = false;

    /** @type {Object|null} */
    this.crafting = null;

    /** @type {Object|null} */
    this.enhancing = null;

    /** @type {Object|string|null} */
    this.config = null;

    this.build_total_time = -1;
    this.build_start_time = -1;
    this.build_done_time = -1;

    this.upgrade_total_time = -1;
    this.upgrade_start_time = -1;
    this.upgrade_done_time = -1;
    /** @type {UpgradeHelp.UpgradeHelp|null} */
    this.upgrade_help = null;

    this.research_item = '';
    this.research_total_time = -1;
    this.research_start_time = -1;
    this.research_done_time = -1;

    this.produce_start_time = -1;
    this.produce_rate = -1;
    this.contents = 0;
    this.manuf_queue = [];
    this.manuf_start_time = -1;
    this.manuf_done_time = -1;

    this.modstats = {};
    /** @type {!Object<string, number>} current enhancement levels */
    this.enhancements = {};

    // true if we sent a state ping and are waiting to hear back from server
    this.ping_sent = false;
    this.equip_pending = false; // true if we are waiting to hear back from the server on an equip request XXX use sync_marker
    this.client_predictions = null; // client-side predicted manuf_queue, only non-null if out of sync

    // dictionary of data about the object who killed us - used to track between the actual kill and the transmission of the combat update
    // note that this is data is queried from the attacker and "frozen" at the moment of the kill to avoid race conditions
    this.killer_info = null;

    this.harvest_glow_time = -1; // graphical effect only

    this.idle_state_cache = null; // for GUI display only - cache result of get_idle_state()
    this.idle_state_cache_valid_until = -1;
}
goog.inherits(Building, MapBlockingGameObject);

/** @override */
Building.prototype.serialize = function() {
    var ret = goog.base(this, 'serialize');
    ret['disarmed'] = this.disarmed;
    ret['modstats'] = deepcopy_obj(this.modstats);
    return ret;
};
/** @override */
Building.prototype.apply_snapshot = function(snap) {
    goog.base(this, 'apply_snapshot', snap);
    if('disarmed' in snap) { this.disarmed = snap['disarmed']; }
    if('modstats' in snap) { this.modstats = snap['modstats']; }
};

Building.prototype.start_client_prediction = function(field, original) {
    this.request_sync();
    if(!this.client_predictions) { this.client_predictions = {}; }
    if(!(field in this.client_predictions)) {
        this.client_predictions[field] = original.slice(0); // XXX needs help for non-arrays
    }
    return this.client_predictions[field];
};
Building.prototype.get_client_prediction = function(field, original) {
    if(this.is_in_sync()) {
        this.client_predictions = null;
    } else if(this.client_predictions && (field in this.client_predictions)) {
        return this.client_predictions[field];
    }
    return original;
};

Building.update_modstats = function(team, update) {
    session.for_each_real_object(function(obj) {
        if(obj.is_building() && obj.team == team) {
            obj.modstats = (obj.id in update ? update[obj.id] : {});

            if(obj.has_weapon_mount()) {
                // initialize AI state
                obj.ai_state = (obj.is_shooter() ? ai_states.AI_ATTACK_ANY : ai_states.AI_STOP);
            }
        }
    });
};

Building.prototype.get_stat = function(stat, default_value) {
    return ModChain.get_stat(this.modstats[stat]||null, default_value);
};

/** @override */
Building.prototype.get_auto_spell = function() {
    if(('spells' in this.spec) && (this.spec['spells'].length > 0)) {
        var spellname = this.get_stat('weapon', this.spec['spells'][0]);
        if(spellname) {
            var auto_spell = gamedata['spells'][spellname];
            if(auto_spell['activation'] === 'auto') {
                return auto_spell;
            }
        }
    }
    return null;
};

/** @override */
Building.prototype.get_auto_spell_level = function() {
    return this.get_stat('weapon_level', this.level);
};

/** @override */
Building.prototype.receive_state = function(data, init, is_deploying) {
    var old_level = this.level;
    var old_manuf_queue = this.manuf_queue;
    var old_build_start = this.build_start_time;
    var was_under_construction = this.is_under_construction();

    goog.base(this, 'receive_state', data, init, is_deploying);

    var old_repair_time = this.repair_finish_time;
    this.repair_finish_time = data.shift();
    this.build_total_time = data.shift();
    this.build_start_time = data.shift();
    this.build_done_time = data.shift();
    this.upgrade_total_time = data.shift();
    this.upgrade_start_time = data.shift();
    this.upgrade_done_time = data.shift();
    var upgrade_help_state = data.shift();
    if(this.upgrade_total_time > 0) {
        this.upgrade_help = new UpgradeHelp.UpgradeHelp();
        this.upgrade_help.receive_state(upgrade_help_state);
    } else {
        this.upgrade_help = null;
    }
    this.research_item = data.shift();
    this.research_total_time = data.shift();
    this.research_start_time = data.shift();
    this.research_done_time = data.shift();
    this.produce_start_time = data.shift();
    this.produce_rate = data.shift();
    this.contents = data.shift();
    this.manuf_queue = data.shift();
    this.manuf_start_time = data.shift();
    this.manuf_done_time = data.shift();
    this.disarmed = data.shift();
    this.crafting = data.shift();
    this.config = data.shift();
    this.enhancing = data.shift();
    var enh = data.shift();
    this.enhancements = (enh !== null ? enh : {}); // convert null to empty object

    session.clear_building_idle_state_caches(); // for ALL buildings

    if(player.tutorial_state === 'wait_for_repairs') {
        if(old_repair_time > 0 && this.repair_finish_time < 0) {
            advance_tutorial();
        }
    }

    if((player.tutorial_state === 'defensive_cannon_complete' ||
        player.tutorial_state === 'speedup_open_context_menu' ||
        player.tutorial_state === 'speedup_open_speedup_menu' ||
        player.tutorial_state === 'speedup_click_finish') && old_build_start > 0 && this.build_start_time < 0) {
        // skip the speedup tutorial steps
        if(player.tutorial_state != 'defensive_cannon_complete') {
            metric_event(gamedata['tutorial']['defensive_cannon_complete']['metric'], {});
        }
        player.tutorial_state = 'defensive_cannon_complete';
        advance_tutorial();
    }

    // invoke building upgrade congrats
    if(((!init && this.level > old_level) ||
        was_under_construction && !this.is_under_construction()) &&
        this.team == 'player') {

        var congrats_func = (function (_spec_name, _level) { return function() {
            invoke_building_upgrade_congrats(_spec_name, _level);
            player.claim_achievements();
        }; })(this.spec['name'], this.level);

        if(!player.is_cheater) {
            // trigger visual effect
            var fx_data = ('upgrade_finish_effect' in this.spec ?
                           this.spec['upgrade_finish_effect'] :
                           gamedata['client']['vfx']['building_upgrade_finish']);
            if(fx_data) {
                session.get_real_world().fxworld.add_visual_effect_at_time([this.x,this.y], 0, [0,1,0], client_time, fx_data,
                                               !this.spec['worth_less_xp'], // no sound for barrier upgrades
                                               { '%OBJECT_SPRITE': this.get_leveled_quantity(this.spec['art_asset'])});
            }
            // hold notification until animation finishes
            notification_queue.hold_until(client_time + 2.9);
        }

        if(player.tutorial_state == "COMPLETE") {
            notification_queue.push(congrats_func);
        }
    }
};
Building.prototype.provides_power = function() { return !!this.spec['provides_power']; };
Building.prototype.provides_power_shutdown = function() { return !!this.spec['power_shutdown_threshold']; };
Building.prototype.provides_half_power_threshold = function() { return !!this.spec['half_power_threshold']; };
Building.prototype.needs_power_ping = function() { return (this.provides_power() && (this.provides_power_shutdown() || this.provides_half_power_threshold())) }
Building.prototype.is_townhall = function() { return this.spec['name'] === gamedata['townhall']; };
Building.prototype.is_turret = function() { return this.spec['history_category'] === 'turrets'; };
Building.prototype.is_emplacement = function() { return this.spec['equip_slots'] && ('turret_head' in this.spec['equip_slots']); };
Building.prototype.is_security_node = function() { return 'show_security_node_ui' in gamedata && read_predicate(gamedata['show_security_node_ui']).is_satisfied(player, null) && this.spec['equip_slots'] && ('security_node' in this.spec['equip_slots']); };
Building.prototype.is_security_node_only = function() {
    if(!(this.spec['equip_slots'] && ('security_node' in this.spec['equip_slots']))) { return false; }
    var ret = true;
    goog.object.forEach(this.spec['crafting_categories'], function(cat) {
        if(cat && typeof(cat) === 'string' && cat.indexOf("security_nodes_") == -1) {
            ret = false;
        };
    });
    return ret;
};
Building.prototype.is_security_node_crafting = function() {
    if(!this.is_security_node()) { return false; }
    var craft_queue = this.get_crafting_queue();
    var ret = false;
    if(craft_queue && craft_queue.length > 0) {
        goog.object.forEach(craft_queue, function(craft) {
            var recipe = craft['craft']['recipe'];
            var category = gamedata['crafting']['recipes'][recipe]['crafting_category'];
            if(category.indexOf("security_nodes_") == 0) {
                ret = true;
            };
        });
    }
    return ret;
};
Building.prototype.is_barrier = function() { return this.spec['name'] === 'barrier'; };
Building.prototype.is_trapped_barrier = function() { return this.spec['equip_slots'] && ('barrier_trap' in this.spec['equip_slots']); };
Building.prototype.is_armed_building = function() { return this.spec['equip_slots'] && ('building_weapon' in this.spec['equip_slots']); };
Building.prototype.is_armed_townhall = function() {
    return this.is_townhall() && this.spec['equip_slots'] && ('townhall_weapon' in this.spec['equip_slots']) && (get_leveled_quantity(this.spec['equip_slots']['townhall_weapon'], this.level) > 0);
};

/** @return {Object|null} the turret head item currently being crafted (assumes is_crafting() is true) */
Building.prototype.first_crafting_inprogress_item = function() {
    var craft_queue = this.get_crafting_queue();
    if(craft_queue.length > 0) {
        return get_crafting_recipe_product_list(gamedata['crafting']['recipes'][craft_queue[0]['craft']['recipe']],
                                                craft_queue[0]['craft']['level'] || 1)[0];
    }
    return null;
};

/** @return {Object|null} the instance of the turret head item equipped here, if any, otherwise null */
Building.prototype.turret_head_item = function() {
    if(this.equipment && this.equipment['turret_head'] && this.equipment['turret_head'].length > 0) {
        return this.equipment['turret_head'][0] ? player.decode_equipped_item(this.equipment['turret_head'][0]) : null;
    }
    return null;
};
/** @return {Object|null} the turret head item currently being crafted (assumes is_crafting() is true) */
Building.prototype.turret_head_inprogress_item = Building.prototype.first_crafting_inprogress_item;

/** @return {Object|null} the instance of the turret head item equipped here, if any, otherwise null */
Building.prototype.security_node_item = function() {
    if(this.equipment && this.equipment['security_node'] && this.equipment['security_node'].length > 0) {
        return this.equipment['security_node'][0] ? player.decode_equipped_item(this.equipment['security_node'][0]) : null;
    }
    return null;
};
/** @return {Object|null} the turret head item currently being crafted (assumes is_crafting() is true) */
Building.prototype.security_node_inprogress_item = Building.prototype.first_crafting_inprogress_item;

/** @return {Object|null} the instance of the barrier trap item equipped here, if any, otherwise null */
Building.prototype.barrier_trap_item = function() {
    if(this.equipment && this.equipment['barrier_trap'] && this.equipment['barrier_trap'].length > 0) {
        return this.equipment['barrier_trap'][0] ? player.decode_equipped_item(this.equipment['barrier_trap'][0]) : null;
    }
    return null;
};
/** @return {Object|null} the barrier trap item currently being crafted (assumes is_crafting() is true) */
Building.prototype.barrier_trap_inprogress_item = Building.prototype.first_crafting_inprogress_item;

/** @return {Object|null} the instance of the building weapon item equipped here, if any, otherwise null */
Building.prototype.building_weapon_item = function() {
    if(this.equipment && this.equipment['building_weapon'] && this.equipment['building_weapon'].length > 0) {
        return this.equipment['building_weapon'][0] ? player.decode_equipped_item(this.equipment['building_weapon'][0]) : null;
    }
    return null;
};
/** @return {Object|null} the building weapon item currently being crafted (assumes is_crafting() is true) */
Building.prototype.building_weapon_inprogress_item = Building.prototype.first_crafting_inprogress_item;

/** @return {Object|null} the instance of the townhall weapon item equipped here, if any, otherwise null */
Building.prototype.townhall_weapon_item = function() {
    if(this.equipment && this.equipment['townhall_weapon'] && this.equipment['townhall_weapon'].length > 0) {
        return this.equipment['townhall_weapon'][0] ? player.decode_equipped_item(this.equipment['townhall_weapon'][0]) : null;
    }
    return null;
};
/** @return {Object|null} the building weapon item currently being crafted (assumes is_crafting() is true) */
Building.prototype.townhall_weapon_inprogress_item = Building.prototype.first_crafting_inprogress_item;

Building.prototype.is_minefield = function() { return this.spec['equip_slots'] && ('mine' in this.spec['equip_slots']); };
Building.prototype.is_ambush = function() { return this.spec['equip_slots'] && ('ambush' in this.spec['equip_slots']); };
Building.prototype.is_minefield_armed = function() { return (this.equipment && this.equipment['mine'] && this.equipment['mine'].length > 0); };
Building.prototype.is_ambush_armed = function() { return (this.equipment && this.equipment['ambush'] && this.equipment['ambush'].length > 0); };
Building.prototype.has_weapon_mount = function() { return (this.spec['equip_slots'] && ('ambush' in this.spec['equip_slots'] || 'mine' in this.spec['equip_slots'] || 'turret_head' in this.spec['equip_slots'] || 'barrier_trap' in this.spec['equip_slots'] || 'building_weapon' in this.spec['equip_slots'] || 'townhall_weapon' in this.spec['equip_slots'])) };

/** @param {string} slot_name
    @return {string|null}
    returns the spec name of any item found in the named slot type on this building, null if none found */
Building.prototype.equipped_item_name_by_slot = function(slot_name) {
    if(this.equipment && this.equipment[slot_name] && this.equipment[slot_name].length > 0) {
        return (this.equipment[slot_name][0] ? player.decode_equipped_item(this.equipment[slot_name][0])['spec'] : null);
    } else if(this.config && this.config[slot_name] && this.config[slot_name].length > 0) {
        return (typeof(this.config[slot_name]) === 'string' ? this.config[slot_name] : player.decode_equipped_item(this.config[slot_name][0])['spec']);
    }
    return null;
};

// returns the name of mine item associated with this minefield, if any, otherwise null
Building.prototype.minefield_item = function() { return this.equipped_item_name_by_slot('mine'); };
// same, but for ambush-point items
Building.prototype.ambush_item = function() { return this.equipped_item_name_by_slot('ambush'); };

// search session for any player-owned minefield building
var find_any_player_minefield = function() {
    return session.for_each_real_object(function(obj) {
        if(obj.is_building() && obj.is_minefield() && obj.team === 'player') {
            return obj;
        }
    });
};

// search session for any player-owned ambush point building
var find_any_player_ambush_point = function() {
    return session.for_each_real_object(function(obj) {
        if(obj.is_building() && obj.is_ambush() && obj.team === 'player') {
            return obj;
        }
    });
};

Building.prototype.is_producer = function() {
    return ('production_capacity' in this.spec);
};

/** Return the name of the resource this building produces
    @return {string|null} */
Building.prototype.produces_res = function() {
    if('production_capacity' in this.spec) {
        for(var res in gamedata['resources']) {
            if(('produces_'+res) in this.spec) {
                return res;
            }
        }
    }
    return null;
};

Building.prototype.get_production_capacity = function() {
    var cap = this.get_leveled_quantity(this.spec['production_capacity']);
    //cap = Math.floor(cap * player.get_abtest_value('T001_harvester_cap', 'modifier', 1));
    return cap;
};
Building.prototype.is_storage = function() {
    for(var res in gamedata['resources']) {
        if(('storage_'+res) in this.spec) {
            return true;
        }
    }
    return false;
};
Building.prototype.is_factory = function() {
    return (this.spec['spells'].indexOf("MAKE_DROIDS") != -1);
};
Building.prototype.is_researcher = function() {
    return (this.spec['spells'].indexOf("RESEARCH_FOR_FREE") != -1);
};
Building.prototype.is_crafter = function() {
    var crafting_cat = this.spec['crafting_categories'];
    if(crafting_cat) {
        // detect if crafting_categories is actually a level-based array,
        // by checking for any entry that is itself an array. If so,
        // we want to return true only if the building has some crafting category
        // at its current level.
        goog.array.forEach(this.spec['crafting_categories'], function(cat) {
            if(cat && Array.isArray(cat)){
                crafting_cat = this.get_leveled_quantity(this.spec['crafting_categories']);
            }
        }, this);
    }
    return (this.spec['spells'].indexOf("CRAFT_FOR_FREE") != -1 && crafting_cat);
};
Building.prototype.is_manufacturer = function() {
    return (this.spec['spells'].indexOf("MAKE_DROIDS") != -1);
};
Building.prototype.is_lottery_building = function() {
    if(this.spec['spells'].indexOf("LOTTERY_SCAN") != -1) {
        var spell = gamedata['spells']['LOTTERY_SCAN'];
        if(!('show_if' in spell) || read_predicate(spell['show_if']).is_satisfied(player, null)) {
            return true;
        }
    }
    return false;
};
Building.prototype.is_warehouse = function() {
    return ('provides_inventory' in this.spec);
};
Building.prototype.is_repairing = function() {
    return (this.repair_finish_time > 0);
};
Building.prototype.is_under_construction = function() {
    return (this.build_total_time > 0);
};
Building.prototype.is_upgrading = function() {
    return (this.upgrade_total_time > 0);
};
Building.prototype.is_enhancing = function() {
    return !!this.enhancing;
}
Building.prototype.is_researching = function() {
    return !!(this.research_item);
};
Building.prototype.get_crafting_queue = function() {
    return this.get_client_prediction('crafting.queue', this.crafting ? this.crafting['queue'] : []);
};
Building.prototype.is_crafting = function() { // return current recipe name or null if not crafting
    var craft_queue = this.get_crafting_queue();
    if(craft_queue && craft_queue.length > 0) {
        return craft_queue[0]['craft']['recipe'];
    }
    return false;
};
Building.prototype.is_crafting_grid_weapon = function() { // return current recipe name or null if not crafting
    if(!(this.is_crafting())) { return false; }
    var craft_queue = this.get_crafting_queue();
    if(craft_queue && craft_queue.length > 0) {
        return craft_queue[0]['craft']['recipe']['crafting_category'] === 'mines' || craft_queue[0]['craft']['recipe']['crafting_category'] === 'ambushes';
    }
    return false;
};
Building.prototype.is_manufacturing = function() {
    return (this.manuf_queue.length > 0);
};
Building.prototype.manuf_total_time = function() {
    var tot = 0;
    for(var i = 0; i < this.manuf_queue.length; i++) {
        tot += this.manuf_queue[i]['total_time'];
    }
    return tot;
};

Building.prototype.is_using_foreman = function() {
    if(this.is_under_construction() || this.is_upgrading() || this.is_enhancing()) { return true; } // removing does not require foreman
    if(this.is_crafting()) {
        var craft_queue = this.get_crafting_queue();
        for(var i = 0; i < craft_queue.length; i++) {
            var recipe_name = craft_queue[i]['craft']['recipe'];
            if(recipe_name in gamedata['crafting']['recipes']) {
                var category_name = gamedata['crafting']['recipes'][recipe_name]['crafting_category'];
                if(category_name in gamedata['crafting']['categories']) {
                    if(gamedata['crafting']['categories'][category_name]['foreman']) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
};

Building.prototype.time_until_finish = function() {
    if(this.is_repairing()) {
        return this.repair_finish_time - server_time;
    } else if(this.is_upgrading()) {
        if(this.upgrade_start_time <= 0) { throw Error('invalid state: upgrade halted'); }
        return this.upgrade_total_time - (server_time - this.upgrade_start_time) - this.upgrade_done_time;
    } else if(this.is_enhancing()) {
        var bus = this.enhancing;
        if(bus['start_time'] <= 0) { throw Error('invalid state: enhancing halted'); }
        return bus['start_time'] + bus['total_time'] - bus['done_time'] - server_time;
    } else if(this.is_removing()) {
        var bus = this.removing;
        if(bus['start_time'] <= 0) { throw Error('invalid state: removing halted'); }
        return bus['start_time'] + bus['total_time'] - bus['done_time'] - server_time;
    } else if(this.is_under_construction()) {
        if(this.build_start_time <= 0) { throw Error('invalid state: construct halted'); }
        return this.build_total_time - (server_time - this.build_start_time) - this.build_done_time;
    } else if(this.is_researching()) {
        if(this.research_start_time <= 0) { throw Error('invalid state: research halted'); }
        return this.research_total_time - (server_time - this.research_start_time) - this.research_done_time;
    } else if(this.is_crafting()) {
        var craft_queue = this.get_crafting_queue();
        if(craft_queue[0]['start_time'] <= 0) { throw Error('invalid state: crafting halted'); }
        var last = craft_queue[craft_queue.length-1];
        return last['start_time'] + last['total_time'] - last['done_time'] - server_time;
    } else if(this.is_manufacturing()) {
        if(this.manuf_start_time <= 0) { throw Error('invalid state: manufacturing halted'); }
        return this.manuf_total_time() - (server_time - this.manuf_start_time) - this.manuf_done_time;
    } else {
        return -1;
    }
};

Building.prototype.activity_speedup_kind = function() {
    var ret = goog.base(this, 'activity_speedup_kind');
    if(ret) { return ret; }
    if(this.is_repairing()) {
        return 'building_repair';
    } else if(this.is_upgrading() || this.is_under_construction()) {
        return 'building_upgrade';
    } else if(this.is_enhancing()) {
        return 'building_enhance';
    } else if(this.is_researching()) {
        return 'tech_research';
    } else if(this.is_manufacturing()) {
        return 'unit_manufacture';
    } else if(this.is_crafting()) {
        return 'crafting';
    } else {
        return null;
    }
};


Building.prototype.is_busy = function() {
    return this.is_repairing() || this.is_upgrading() || this.is_enhancing() || this.is_removing() || this.is_under_construction() || this.is_researching() || this.is_manufacturing() || (this.is_crafting() && this.crafting_time_left_all() > 0);
};

Building.prototype.research_time_left = function() {
    var ret = this.research_total_time - this.research_done_time;
    if(this.research_start_time > 0) {
        ret -= (server_time - this.research_start_time);
    }
    return ret;
};
Building.prototype.research_progress = function() {
    return (this.research_done_time + (this.research_start_time > 0 ? (server_time - this.research_start_time) : 0))/this.research_total_time;
};

Building.prototype.crafting_time_left_all = function() {
    var ret = 0;
    goog.array.forEach(this.get_crafting_queue(), function(bus) {
        ret += bus['total_time'] - bus['done_time'];
        if(bus['start_time'] > 0) {
            ret -= Math.max(0, server_time - bus['start_time']);
        }
    });
    return Math.max(0, ret);
};

// return time left on currently in-progress recipe
// if there are finished recipes to collect, but none in progress, return -1
Building.prototype.crafting_time_left_one = function() {
    var craft_queue = this.get_crafting_queue();
    for(var i = 0; i < craft_queue.length; i++) {
        var bus = craft_queue[i];
        var ret = bus['total_time'] - bus['done_time'];
        var cat = gamedata['crafting']['categories'][gamedata['crafting']['recipes'][bus['craft']['recipe']]['crafting_category']];
        if(bus['start_time'] > 0) {
            ret -= Math.max(0, server_time - bus['start_time']);
        }
        if(ret <= 0 && ('auto_collect' in cat) && !cat['auto_collect']) {
            continue; // done; skip
        }
        return ret;
    }
    return -1; // nothing going on
};
Building.prototype.crafting_progress_all = function() {
    var total = this.crafting_time_left_all();
    if(total > 0) {
        var done = 0;
        goog.array.forEach(this.get_crafting_queue(), function(bus) {
            done += bus['done_time'] + (bus['start_time'] > 0 && bus['start_time'] < server_time ? (server_time - bus['start_time']) : 0);
        });
        return done / total;
    } else {
        return 1;
    }
};

// progress on earliest entry in queue
// NOT counting any entries that are already finished pending collection
// if everything in the queue is finished pending collection, return -1
Building.prototype.crafting_progress_one = function() {
    var queue = this.get_crafting_queue();
    for(var i = 0; i < queue.length; i++) {
        var bus = queue[i];
        var recipe_name = bus['craft']['recipe'];
        var auto_collect = true;
        if(recipe_name in gamedata['crafting']['recipes']) {
            var category_name = gamedata['crafting']['recipes'][recipe_name]['crafting_category'];
            if(category_name in gamedata['crafting']['categories']) {
                var cat = gamedata['crafting']['categories'][category_name];
                if(('auto_collect' in cat) && !cat['auto_collect']) {
                    auto_collect = false;
                }
            }
        }
        var prog = (bus['done_time'] + (bus['start_time'] > 0 ? (server_time - bus['start_time']) : 0))/bus['total_time'];
        if(prog >= 1 && !auto_collect) {
            continue; // SKIP non-auto-collect entries
        }
        return prog;
    }
    // non-auto-collect entry is pending, but there is no further work
    return -1;
};

Building.prototype.build_time_left = function() {
    var ret = this.build_total_time - this.build_done_time;
    if(this.build_start_time > 0) {
        ret -= (server_time - this.build_start_time);
    }
    return ret;
};
Building.prototype.build_progress = function() {
    return (this.build_done_time + (this.build_start_time > 0 ? (server_time - this.build_start_time) : 0))/this.build_total_time;
};

Building.prototype.upgrade_time_left = function() {
    var ret = this.upgrade_total_time - this.upgrade_done_time;
    if(this.upgrade_start_time > 0) {
        ret -= (server_time - this.upgrade_start_time);
    }
    return ret;
};
Building.prototype.upgrade_progress = function() {
    return (this.upgrade_done_time + (this.upgrade_start_time > 0 ? (server_time - this.upgrade_start_time) : 0))/this.upgrade_total_time;
};

Building.prototype.enhance_time_left = function() {
    var bus = this.enhancing;
    var ret = bus['total_time'] - bus['done_time'];
    if(bus['start_time'] > 0) {
        ret -= (server_time - bus['start_time']);
    }
    return ret;
};
Building.prototype.enhance_progress = function() {
    var bus = this.enhancing;
    return (bus['done_time'] + (bus['start_time'] > 0 ? (server_time - bus['start_time']) : 0))/bus['total_time'];
};

Building.prototype.manuf_time_left = function() {
    var ret = this.manuf_total_time() - this.manuf_done_time;
    if(this.manuf_start_time > 0) {
        ret -= (server_time - this.manuf_start_time);
    }
    return ret;
};

Building.prototype.manuf_time_left_one = function() {
    var ret = this.manuf_queue[0]['total_time'] - this.manuf_done_time;
    if(this.manuf_start_time > 0) {
        ret -= (server_time - this.manuf_start_time);
    }
    return ret;
};
// % completion of FIRST unit in queue
Building.prototype.manuf_progress_one = function() {
    if(this.manuf_queue[0]['total_time'] <= 0) { return 1; }
    return (this.manuf_done_time + (this.manuf_start_time > 0 ? (server_time - this.manuf_start_time) : 0))/this.manuf_queue[0]['total_time'];
};

// estimate the current contents of a producer building based on last server-provided data
// this is only used for GUI purposes. Note: returns continuous float, not quantized!
Building.prototype.interpolate_contents = function() {
    if(this.produce_start_time < 0) {
        // building is idle
        return this.contents;
    }

    var estimate = this.contents + this.produce_rate * (server_time - this.produce_start_time)/(60*60);
    estimate = Math.max(0, Math.min(estimate, this.get_production_capacity()));
    return estimate;
};

/** @override */
Building.prototype.combat_power_factor = function(base) {
    if(gamedata['enable_power']) {
        var powerfac = base.power_factor();
        if(powerfac < 1) {
            var min_fac = gamedata['minimum_combat_power_factor'];
            return min_fac + (1-min_fac)*powerfac;
        }
    }
    return 1;
};

// these functions are for client-side prediction only - server will override true state with next OBJECT_STATE_UPDATE
Building.prototype.update_research = function(undamaged_time) {
    if(!this.research_item) { return; }
    if(this.repair_finish_time > 0 || this.is_damaged()) { return; }
    if(this.research_start_time > 0) { return; }
    if(undamaged_time >= 0) {
        this.research_done_time += server_time - undamaged_time;
    }
    this.research_start_time = server_time;
};

function _update_crafting(queue, undamaged_time) {
    var delay = 0;
    goog.array.forEach(queue, function(bus) {
        var old_done_time = bus['done_time'];
        if(bus['start_time'] < 0) {
            if(undamaged_time >= 0) {
                if('creation_time' in bus && bus['creation_time'] >= 0) { undamaged_time = Math.max(undamaged_time, bus['creation_time']); }
                bus['done_time'] += Math.max(0, Math.min(server_time - undamaged_time - delay, bus['total_time'] - bus['done_time']));
            }
            bus['start_time'] = server_time + delay;
        }
        delay = bus['total_time'] - bus['done_time']; // delay start of next action in queue by remaining time on preceding action
        if(undamaged_time >= 0) {
            undamaged_time += bus['done_time'] = old_done_time; // un-credit next action for progress accured to preceding action
        }
    });
}

Building.prototype.update_crafting = function(undamaged_time) {
    if(!this.is_crafting()) { return; }
    var craft_queue = this.get_crafting_queue();
    if(this.repair_finish_time > 0 || this.is_damaged()) {
        var cat = gamedata['crafting']['categories'][gamedata['crafting']['recipes'][craft_queue[0]['craft']['recipe']]['crafting_category']];
        if(('haltable' in cat) && !cat['haltable']) {
            // not haltable
        } else {
            return; // halted
        }
    }
    return _update_crafting(craft_queue, undamaged_time);
};

Building.prototype.update_build = function(undamaged_time) {
    if(this.build_total_time < 0) { return; }
    if(this.repair_finish_time > 0 || this.is_damaged()) { return; }
    if(this.build_start_time > 0) { return; }
    if(undamaged_time >= 0) {
        this.build_done_time += server_time - undamaged_time;
    }
    this.build_start_time = server_time;
};

Building.prototype.update_manuf = function(undamaged_time) {
    if(this.manuf_queue.length < 1) { return; }
    if(this.repair_finish_time > 0 || this.is_damaged()) { return; }
    if(this.manuf_start_time > 0) { return; }
    if(undamaged_time >= 0) {
        this.manuf_done_time += server_time - undamaged_time;
    }
    this.manuf_start_time = server_time;
};

Building.prototype.update_upgrade = function(undamaged_time) {
    if(this.upgrade_total_time < 0) { return; }
    if(this.repair_finish_time > 0 || this.is_damaged()) { return; }
    if(this.upgrade_start_time > 0) { return; }
    if(undamaged_time >= 0) {
        this.upgrade_done_time += server_time - undamaged_time;
    }
    this.upgrade_start_time = server_time;
};

Building.prototype.update_all_actions = function(undamaged_time) {
    this.update_research(undamaged_time);
    this.update_upgrade(undamaged_time);
    this.update_build(undamaged_time);
    this.update_manuf(undamaged_time);
    this.update_crafting(undamaged_time);
};

Building.prototype.modify_stats_by_modstats = function() {
    this.modify_stats_by_modstats_table(this.modstats);
};

// return true if the object should be invisible to opponents
Building.prototype.is_invisible_default = function() { return !!this.spec['invisible']; };

// return true if the object should be invisible to opponents
Building.prototype.is_invisible = function() { return (!!this.combat_stats.invisible && !this.combat_stats.detected); };

/** return position/text/icon/etc for the idle state, if it should be drawn in the GUI
    @return {({idle: Object,
              asset: (string|undefined),
              icon_pos: (!Array.<number>|undefined),
              click_bounds: ((!Array.<!Array.<number>>)|null|undefined),
              text_str: (string|null|undefined),
              text_pos: (Array.<number>|null|undefined),
              bounce: (boolean|undefined),
              pulse_period: (number|undefined),
              pulse_amplitude: (number|undefined)})|null}
 */
Building.prototype.get_idle_state_appearance = function() {
    if(session.home_base && !session.has_attacked && gamedata['client']['enable_idle_icons'] && !player.is_cheater &&
       this.team === 'player' && !this.spec['worth_less_xp'] &&
       player.tutorial_state == "COMPLETE" && get_preference_setting(player.preferences, 'show_idle_buildings') &&
       read_predicate({'predicate':'LIBRARY', 'name': ('show_idle_buildings' in gamedata['predicate_library'] ? 'show_idle_buildings' : 'extended_tutorial_complete')}).is_satisfied(player,null)) {
        var idle = this.get_idle_state();
        if(!idle) { return null; }
        if(!idle['state']) { return {idle: idle}; }

        if(!(idle['state'] in gamedata['strings']['idle_buildings'])) { throw Error('unknown building idle state '+idle['state']); }
        var state_data = gamedata['strings']['idle_buildings'][idle['state']];

        var icon_name = state_data['icon'];
        if(!icon_name) { return {idle: idle}; } // no icon

        if(!(icon_name in GameArt.assets)) { throw Error('invalid draw_idle_icon ' + icon_name); }

        // all coordinates here are in playfield coordinate system

        var icon_sprite = GameArt.assets[icon_name].states['normal'];
        if(!icon_sprite) { throw Error('No normal state defined for icon asset ' + icon_name); }
        var xy = this.playfield_xy();
        var default_text_height = this.get_health_bar_dims()[2];
        var icon_pos = vec_add(xy, [0, -Math.floor(0.75*default_text_height + icon_sprite.wh[1]/2)]);

        var click_bounds = [[icon_pos[0] - icon_sprite.wh[0]/2, icon_pos[0] + icon_sprite.wh[0]/2],
                            [icon_pos[1] - icon_sprite.wh[1]/2, icon_pos[1] + icon_sprite.wh[1]/2]];
        var is_bouncy = !!state_data['bounce'];
        if(is_bouncy) {
            click_bounds[1][0] -= icon_sprite.wh[1]/2; // enlarge click area vertically
        }

        var text_str = state_data['ui_name'] || null;
        var text_pos = null;
        if(text_str) {
            text_pos = icon_pos;
            if(idle['s_replace']) { text_str = text_str.replace('%s', idle['s_replace']); }
            var text_edge = measure_centered_text(ctx, text_str, text_pos);
            click_bounds[0][1] = Math.max(click_bounds[0][1], text_pos[0] + (text_pos[0]-text_edge[0]));
            icon_pos = vec_add(text_edge, [-25,-3]);
            click_bounds[0][0] = Math.min(click_bounds[0][0], icon_pos[0] - icon_sprite.wh[0]/2);
        }

        if(is_bouncy) {
            icon_pos[1] = Math.floor(icon_pos[1] - 18 * Bounce.get(client_time));
        }

        return {idle: idle,
                asset: icon_name,
                icon_pos: icon_pos,
                click_bounds: click_bounds,
                text_str: text_str,
                text_pos: text_pos,
                bounce: is_bouncy,
                pulse_period: ('pulse_period' in state_data ? state_data['pulse_period'] : (gamedata['client']['idle_icon_pulse_period'] || 0)),
                pulse_amplitude: ('pulse_amplitude' in state_data ? state_data['pulse_amplitude'] : (gamedata['client']['idle_icon_pulse_amplitude'] || 0))
               };
    }
    return null;
};

/** @override */
Building.prototype.detect_click = function(world, xy, ji, zoom, fuzz) {
    if(goog.base(this, 'detect_click', world, xy, ji, zoom, fuzz)) {
        return true;
    }
    if(!this.spec['worth_less_xp'] && player.get_any_abtest_value('idle_icon_type', gamedata['client']['idle_icon_type'] || 'old') == 'advanced') {
        var appearance = this.get_idle_state_appearance();
        if(appearance && appearance.click_bounds) {
            // work in playfield coordinate system
            var p = screen_to_playfield(xy);
            var b = appearance.click_bounds;
            if(p[0] >= b[0][0] && p[0] < b[0][1] && p[1] >= b[1][0] && p[1] < b[1][1]) {
                return true;
            }
        }
    }
    return false;
};

// for odd gridsizes, add one-half unit to center the sprite on the grid bounds
MapBlockingGameObject.prototype.get_odd_shift = function() {
    var gridsize = this.spec['gridsize'];
    return [gridsize[0] > 1 && (gridsize[0]&1) ? 0.5 : 0,
            gridsize[1] > 1 && (gridsize[1]&1) ? 0.5 : 0];
};
MapBlockingGameObject.prototype.playfield_xy = function() {
    var odd_shift = this.get_odd_shift();
    return vec_floor(ortho_to_playfield(vec_add([this.x, this.y], odd_shift)));
};

/** Functions for working with climates
    @constructor @struct */
var Climate = function(data) {
    /** @const */
    this.data = data;
};

/** @return {boolean} if there are unit deployment restrictions */
Climate.prototype.has_climate_unit_restrictions = function() {
    if(this.data['include_manufacture_categories'] ||
       this.data['exclude_manufacture_categories'] ||
       this.data['exclude_air_units'] ||
       this.data['exclude_ground_units'] ||
       this.data['include_units'] ||
       this.data['exclude_units']) {
        return true;
    }
    return false;
};

/** @return {boolean} if there are unit deployment OR other (missile) restrictions */
Climate.prototype.has_climate_restrictions = function() {
    return (this.has_climate_unit_restrictions() ||
            this.data['applies_aura'] ||
            this.data['exclude_missiles']);
};

/** @param {!Object} spec
    @return {boolean} */
Climate.prototype.can_deploy_unit_of_spec = function(spec) {
    if(('include_manufacture_categories' in this.data)) {
        if(!goog.array.contains(this.data['include_manufacture_categories'], spec['manufacture_category'])) { return false; }
    }
    if(('exclude_manufacture_categories' in this.data)) {
        if(goog.array.contains(this.data['exclude_manufacture_categories'], spec['manufacture_category'])) { return false; }
    }
    if(this.data['exclude_air_units'] && spec['flying']) { return false; }
    if(this.data['exclude_ground_units'] && !spec['flying']) { return false; }
    if('include_units' in this.data) {
        if(!goog.array.contains(this.data['include_units'], spec['name'])) { return false; }
    }
    if('exclude_units' in this.data) {
        if(goog.array.contains(this.data['exclude_units'], spec['name'])) { return false; }
    }
    return true;
};

/** Return list of ui_descriptions of unit deployment restrictions
    @return {!Array.<string>} */
Climate.prototype.get_climate_unit_restrictions = function() {
    var strings = gamedata['strings']['climate_restrictions'];
    var ls = [];
    goog.array.forEach(['include_manufacture_categories','exclude_manufacture_categories'], function(kind) {
        if(kind in this.data) {
            var catlist = [];
            goog.array.forEach(this.data[kind], function(cat) {
                catlist.push(gamedata['strings']['manufacture_categories'][cat]['plural']);
            });
            ls.push(strings[kind].replace('%s', catlist.join(', ')));
        }
    }, this);
    goog.array.forEach(['include_units','exclude_units'], function(kind) {
        if(kind in this.data) {
            var catlist = [];
            goog.array.forEach(this.data[kind], function(specname) {
                catlist.push(gamedata['units'][specname]['ui_name']);
            });
            ls.push(strings[kind].replace('%s', catlist.join(', ')));
        }
    }, this);
    goog.array.forEach(['exclude_air_units','exclude_ground_units'], function(kind) {
        if(this.data[kind]) { ls.push(strings[kind]); }
    }, this);
    return ls;
};

/** Return a single ui_string describing all climate restrictions and auras
    @return {string} */
Climate.prototype.describe_climate_restrictions = function() {
    var strings = gamedata['strings']['climate_restrictions'];
    var ls = this.get_climate_unit_restrictions();
    goog.array.forEach(['exclude_missiles'], function(kind) {
        if(this.data[kind]) { ls.push(strings[kind]); }
    }, this);
    if('applies_aura' in this.data) {
        ls.push(gamedata['auras'][this.data['applies_aura']]['ui_description']);
    }
    // ensure something is listed
    if(ls.length < 1) { ls.push(gamedata['strings']['climate_restrictions']['none']); }
    return ls.join('. ');
};

/** Return a single ui_string describing only climate unit restrictions
    @return {string} */
Climate.prototype.describe_climate_unit_restrictions = function() {
    var ls = this.get_climate_unit_restrictions();
    // ensure something is listed
    if(ls.length < 1) { ls.push(gamedata['strings']['climate_restrictions']['none']); }
    return ls.join('. ');
};

// session state
var session = new Session.Session();

// player state
var player = {};

/** @dict */
player.resource_state = {
    "space": [0,0], // [provided,occupied]
    "gamebucks": -1,
    "facebook_credits": -1,
    "player_level": 1,
    "xp": 0,
    "protection_end_time": 0
};
player.my_army = {};
player.squads = null;
player.squad_client_data = {}; // squad control state only used in the client

player.travel_state = {'dest_loc': null, 'start_time': -1, 'end_time': -1, 'attacks_made': 0};

// for graphical display purposes ONLY, track the last update
// to resource_state, so we can display a running-ticker effect
player.last_resource_state = { "xp": 0, "facebook_credits": -1, "gamebucks": -1 };
player.last_resource_time = -1; player.last_xp_time = -1; player.last_credits_time = -1;

// set this to >= client_time to trigger flash effect
player.flash_res_time = {};
player.flash_credits_time = -1;

// if >0, client_time at which daily attack should be triggered
player.daily_attack_time = -1;
player.new_battle_histories = 0; // count of unseen battle history entries

// same format as server's player.inventory
player.max_inventory = 0;
player.reserved_inventory = 0;
player.inventory = [];
player.loot_buffer = [];
player.donated_units = {};
player.session_lottery_loot = []; // list of items won via lottery this session

player.init = function() {
    for(var res in gamedata['resources']) {
        player.resource_state[res] = [0,0]; // [max,current]
        player.last_resource_state[res] = 0;
        player.flash_res_time[res] = -1;
    }
};

player.max_usable_inventory = function() {
    return player.max_inventory - player.reserved_inventory;
};

/** @param {number|!Array.<number>} level_gap_table
    @param {number} attacker_level
    @return {number} */
var _min_attackable_level = function(level_gap_table, attacker_level) {
    var max_gap;
    if((typeof level_gap_table) === 'number') {
        max_gap = level_gap_table;
    } else {
        var ind = Math.min(Math.max(attacker_level-1,0), level_gap_table.length-1);
        max_gap = level_gap_table[ind];
    }
    return Math.max(attacker_level - max_gap, 0);
};

/** @return {!Array.<number>} [low,high] inclusive level range */
player.attackable_level_range = function() {
    var attacker_level = player.level();

    var mode = player.is_ladder_player() ? 'ladder' : 'default';

    // game-global level gap table
    var level_gap_table = gamedata['max_pvp_level_gap'];

    // optional per-region override
    if(session.region && session.region.data && session.region.data['max_pvp_level_gap']) {
        level_gap_table = session.region.data['max_pvp_level_gap'];
    }

    var lower_bound = _min_attackable_level(level_gap_table[mode], attacker_level);
    var upper_bound;
    if(gamedata['apply_pvp_level_gap_upward']) {
        upper_bound = lower_bound;
        while(_min_attackable_level(level_gap_table[mode], upper_bound) <= attacker_level) {
            upper_bound += 1;
        }
        if(upper_bound > lower_bound) { upper_bound -= 1; }
    } else {
        upper_bound = -1;
    }
    return [lower_bound, upper_bound];
};

/** @param {number} x
    @param {!Array.<number>} r
    @return {boolean} */
var in_level_range = function(x, r) {
    if(r[0] >= 0 && x < r[0]) { return false; }
    if(r[1] >= 0 && x > r[1]) { return false; }
    return true;
};

/** @param {number} defender_level
    @return {boolean} */
player.in_attackable_level_range = function(defender_level) {
    return in_level_range(defender_level, player.attackable_level_range());
};

/** @return {number} */
player.level = function() { return player.resource_state['player_level']; };

player.unit_donation_enabled = function() {
    return player.get_any_abtest_value('enable_unit_donation', gamedata['enable_unit_donation']);
};

player.alliance_help_enabled = function() { return eval_cond_or_literal(player.get_territory_setting('enable_alliance_help'), player, null); };

player.donated_units_icon = function() {
    // try to use alliance icon, otherwise use default icon
    var icon = gamedata['auras']['donated_units']['icon'];
    if(session.is_in_alliance()) {
        var info = AllianceCache.query_info_sync(session.alliance_id);
        if(info['logo']) {
            icon = 'alicon_'+info['logo'];
        }
    }
    return icon;
};

function units_description(unit_list, separator) {
    // create text description of the donated units
    var by_type = {};
    for(var i = 0; i < unit_list.length; i++) {
        var incr = unit_list[i]['stack'] || 1;
        var specname = unit_list[i]['spec'];
        if(!(specname in by_type)) { by_type[specname] = 0; }
        by_type[specname] += incr;
    }
    var descr_list = [];
    // list donated units in reverse "coolness" order from gamedata['units']
    for(var name in gamedata['units']) {
        if(name in by_type) {
            var qty = by_type[name];
            descr_list.push(qty.toFixed(0)+'x '+gamedata['units'][name]['ui_name']);
        }
    }
    descr_list.reverse();
    var descr = descr_list.join(separator);
    return descr;
}

player.donated_units_description = function(separator) {
    var by_specname = {};
    goog.object.forEach(player.donated_units, function(entry) {
        if(!(entry['spec'] in by_specname)) { by_specname[entry['spec']] = 0; }
        by_specname[entry['spec']] += ('stack' in entry ? entry['stack'] : 1);
    });
    var ret = [];
    goog.object.forEach(by_specname, function(count, specname) {
        ret.push({'spec': specname, 'stack':count});
    });
    return units_description(ret, separator);
};

player.donated_units_space = function() {
    var consumes_space = 0;
    goog.object.forEach(player.donated_units, function(entry) {
        var stack = ('stack' in entry ? entry['stack'] : 1);
        consumes_space += stack * get_leveled_quantity(gamedata['units'][entry['spec']]['consumes_space'], entry['level'] || 1);
    });
    return consumes_space;
};

player.count_donated_units = function() {
    var count = 0;
    goog.object.forEach(player.donated_units, function(entry) {
        count += ('stack' in entry ? entry['stack'] : 1);
    });
    return count;
};

player.has_donated_units = function() { return goog.object.getCount(player.donated_units) > 0; };

player.donated_units_max_space = function() {
    var alliance_building = find_object_by_type(gamedata['alliance_building']);
    if(!alliance_building) { return -1; }
    return alliance_building.get_leveled_quantity(alliance_building.spec['provides_donated_space'] || 0);
};

player.alliance_help_daily_limit = function() {
    var alliance_building = find_object_by_type(gamedata['alliance_building']);
    if(!alliance_building) { return 1; }
    return alliance_building.get_leveled_quantity(alliance_building.spec['alliance_help_daily_limit'] || 1);
};

// same as player.mailbox on the server
player.mailbox = [];
player.mailbox_sync_marker = Synchronizer.INIT; // for client-side prediction of the mailbox contents

// same as player.map_bookmarks on server
player.map_bookmarks = {};

// table of completed quests from server (same format as server's player.completed_quests)
player.completed_quests = {};

player.achievements = null; // same as player.achievements on server side

// for UI purposes only, compute the last "ui_step" value per "ui_category" of quests
player.quest_chain_lengths = [];

// quest_cache memoizes the activation/claimability status of all quests
var QUEST_CACHE_DEBUG = false;
player.quest_cache = {}; // map from quest name -> quest_status flags
player.quest_cache_dirty = true;
player.quest_status = {
    // ACTIVE and CLAIMABLE are bits that can be OR'ed together
    ACTIVE : 1,
    CLAIMABLE: 2
};

player.active_quests = []; // list of quests that are active (including satisfied but unclaimed quests), sorted in priority order
player.claimable_quests = -1; // number of quests that are completed but rewards not claimed yet. -1 for "not computed yet".


// "quest_tracked" is the "currently accepted" quest, and means that GUI tips from that quest will be shown
player.quest_tracked = null;
player.quest_tracked_dirty = false; // flag used for knowing when the quest tip UI must be re-evaluated
player.quest_tracked_complete_time = -1; // time until the mission complete dialog will be invoked automatically
player.quest_root = new SPUI.Container();
player.quest_root.transparent_to_mouse = true;
player.quest_landscape_arrow = null; // reference to tutorial arrow SPUI Dialog, if one is up

player.tutorial_state = 'START';
player.tutorial_hold = false; // stop tutorial temporarily, e.g. for replay on first visit

player.unit_repair_queue = [];
player.tech = {};
player.unit_equipment = {};
player.player_auras = [];
player.stattab = {'player':{'combat_time_scale':ModChain.make_chain(1)},'units':{},'buildings':{},'INIT':'player'};
player.history = {};
player.abtests = {};
player.cooldowns = {};
// NOTE! global_cooldown is relative to client_time, NOT server_time like all other cooldowns!
player.global_cooldown = {'start':-1, 'end':-1}; // the GCD is client-side only for now
player.developer = false; // developer access ON LIVE SERVER (e.g. shows chat gagging options)
player.is_suspicious = false; // extra logging to track suspected hackers
player.is_chat_mod = false; // whether player has chat moderation authority
player.isolate_pvp = 0; // same as server's isolate_pvp flag
player.vpn_status = null; // if not null, player is probably on a VPN, and this is a string that describes it in more detail
player.acquisition_campaign = null; // acquisition_campaign field, from server
player.home_base_id = null; // base_id of player's home
player.home_base_loc = null; // base_map_loc of player's home
player.enable_muffins = false; // show extra-secret hidden developer features
/** @type {boolean} */
player.is_cheater = false; // allow breaking of unit space/building limits (NOT ON LIVE SERVER)
player.ui_name = '(Unknown)';
/** @type {string|null} same as on server */
player.alias = null;
/** @type {string|null} same as on server */
player.title = null;
/** @type {number} same as on server */
player.trust_level = -1;
/** @type {string|null} same as on server */
player.privacy_consent = null;
player.facebook_name = '(Unknown)';
player.facebook_currency = null;
player.facebook_permissions = spin_facebook_login_permissions.split(',');
player.facebook_third_party_id = null;
player.friends = [];
player.preferences = {};
player.country = 'unknown';
player.price_region = 'unknown';
player.country_tier = 'unknown';
player.logged_in_times = -1;
player.creation_time = -1;
player.chat_seen = {}; // same as server

function enable_muffins() {
    if(!player.is_developer()) { return; }
    player.enable_muffins = !player.enable_muffins;
};

/** @return {boolean} */
player.is_developer = function() { return player.developer; };

/** Is the new realtime chat moderation system enabled?
    @return {boolean} */
player.has_advanced_chat_reporting = function() {
    return player.get_any_abtest_value('advanced_chat_reporting', gamedata['client']['advanced_chat_reporting'] || false);
}

player.has_facebook_permissions = function(scope) {
    var want_perms = scope.split(',');
    var has_all = true;
    for(var i = 0; i < want_perms.length; i++) {
        if(!goog.array.contains(player.facebook_permissions, want_perms[i])) {
            has_all = false;
            break;
        }
    }
    return has_all;
};

player.is_syfy_user = function() {
    if(get_query_string('syfy_test') === '1') { return true; }
    if(!player.acquisition_campaign || player.acquisition_campaign.length < 4) { return false; }
    return (player.acquisition_campaign.substr(0,2) === "63");
};

player.get_ui_name = function() {
    if(anon_mode) {
        return ANON_NAME;
    }
    return player.ui_name;
};

/** Create a fake player cache entry based on the live player
    @return {!Object} */
player.get_player_cache_props = function() {
    return {'ui_name': player.get_ui_name(),
            'player_level': player.level(),
            'alliance_id': session.alliance_id};
};

// same as server-side function, used for gathering summary dimensions for metric events
player.get_denormalized_summary_props = function(format) {
    if(format != 'brief') { throw Error('unhandled format '+format); }
    var ret = {'plat': spin_frame_platform,
               'cc': player.get_townhall_level(),
               'rcpt': player.history['money_spent'] || 0,
               'ct': player.country,
               'tier': player.country_tier};
    if(player.is_developer()) { ret['developer'] = 1; }
    return ret;
};


/** generic function that operates on player.preferences['blocked_users'] or player.preferences['force_blocked_users']
    @param {Array.<number>|null} blist
    @param {number} uid
    @return {boolean} */
var _has_blocked_user = function(blist, uid) {
    if(!blist) { return false; }
    return goog.array.some(blist, function(entry) { return entry === uid; });
};

/** True if we have manually blocked the other player
    @param {number} uid
    @return {boolean} */
player.has_blocked_user = function(uid) { return _has_blocked_user(player.preferences['blocked_users'] || null, uid); };

/** True if we should never see the other player's chat messages
    @param {number} uid
    @return {boolean} */
player.has_blocked_or_force_blocked_user = function(uid) {
    return _has_blocked_user(player.preferences['blocked_users'] || null, uid) ||
        _has_blocked_user(player.preferences['force_blocked_users'] || null, uid);
};

player.block_user = function(uid) {
    if(player.has_blocked_user(uid)) { return; }
    if(!('blocked_users' in player.preferences)) {
        player.preferences['blocked_users'] = [];
    }
    player.preferences['blocked_users'].push(uid);
    send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
};
player.unblock_user = function(uid) {
    if(!player.has_blocked_user(uid)) { return; }
    var blist = player.preferences['blocked_users'];
    for(var i = 0; i < blist.length; i++) {
        if(blist[i] === uid) {
            blist.splice(i,1);
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
            return;
        }
    }
};

/** @param {string} cd_name
    @param {Object=} match_data
    @return {Object|null} */
player.cooldown_find = function(cd_name, match_data) {
    var cd, to_go;
    if(cd_name === 'GCD') {
        cd = player.global_cooldown;
        to_go = cd['end'] - client_time;
    } else if(cd_name in player.cooldowns) {
        cd = player.cooldowns[cd_name];
        to_go = cd['end'] - server_time;
    } else {
        cd = null;
    }

    if(cd && to_go > 0) {
        if(match_data) {
            var data = ('data' in cd ? cd['data'] : {});
            for(var k in match_data) {
                if(!(k in data) || data[k] != match_data[k]) {
                    return null; // mismatchh
                }
            }
        }
        return cd;
        // don't clear expired cooldowns, let server do it
    }

    return null;
};

/** @param {string} cd_name
    @param {Object=} match_data
    @return {number} */
player.cooldown_togo = function(cd_name, match_data) {
    if(cd_name === 'GCD') {
        // special treatment for GCD - compare against client time
        return player.global_cooldown['end'] - client_time;
    }
    var cd = player.cooldown_find(cd_name, match_data);
    if(cd) {
        return (cd['end'] - server_time);
    }
    return -1;
};

/** @param {string} cd_name
    @param {Object=} match_data
    @return {number} of active stacks */
player.cooldown_active = function(cd_name, match_data) {
    var cd = player.cooldown_find(cd_name, match_data);
    if(cd) {
        return ('stack' in cd ? cd['stack'] : 1);
    }
    return 0;
};

// NOTE: this is for client-side cooldowns only, and is cleared on every COOLDOWN_UDPATE! (except for GCD)
player.cooldown_client_trigger = function(cd_name, duration) {
    if(cd_name === 'GCD') {
        player.global_cooldown = {'start': client_time, 'end': client_time + duration};
    } else {
        player.cooldowns[cd_name] = {'start': server_time, 'end': server_time + duration};
    }
};

player.travel_satisfied = function(base_loc) {
    if(!base_loc || (player.home_base_loc && vec_equals(base_loc, player.home_base_loc))) { return true; }
    return (player.travel_state['dest_loc'] &&
            vec_equals(player.travel_state['dest_loc'], base_loc) &&
            server_time >= player.travel_state['end_time'] &&
            player.travel_state['attacks_made'] < gamedata['territory']['deployments_per_travel']);
};

player.travel_time_to = function(dest_loc) {
    if(!dest_loc || !player.home_base_loc || vec_equals(dest_loc, player.home_base_loc)) { return 0; }
    var delta = hex_distance(player.home_base_loc, dest_loc);
    if(player.is_developer() && get_query_string('fast_travel')) {
        // developer-only option for debugging
        delta = Math.min(delta, 1);
    }
    var t = delta * gamedata['territory']['travel_time_per_hex'];
    if(t > 0) {
        t = Math.max(1, Math.floor(t / get_player_stat(player.stattab, 'travel_speed')));
    }
    return t;
};

function tutorial_opt_out() {
    if(!player.preferences['skip_tutorial']) {
        player.record_feature_use('skip_tutorial');
        player.preferences['skip_tutorial'] = 1;
        send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
    }
    player.quest_tracked = null;
    player.quest_tracked_dirty = true;
}

/** @param {Object=} quest */
function tutorial_opt_in(quest) {
    if('skip_tutorial' in player.preferences) {
        player.record_feature_use('resume_tutorial');
        delete player.preferences['skip_tutorial'];
        send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
    }

    if(quest) {
        player.quest_tracked = quest;
        player.quest_tracked_dirty = true;
    } else {
        // automatically accept next eligible quest
        player.update_quest_cache(true);
    }

    // return what we managed to pick as a quest
    return player.quest_tracked;
}

player.claim_achievements = function () {
    if(player.achievements === null) { return; } // not initialized yet
    if(!session.home_base) { return; } // only try to claim achievements at home base
    for(var name in gamedata['achievements']) {
        if(name in player.achievements) { continue; }
        var spec = gamedata['achievements'][name];
        if(('activation' in spec) && !read_predicate(spec['activation']).is_satisfied(player, null)) { continue; }
        if(('show_if' in spec) && !read_predicate(spec['show_if']).is_satisfied(player, null)) { continue; }
        if(read_predicate(spec['goal']).is_satisfied(player, null)) {
            player.achievements[name] = {'pending': 1};
            send_to_server.func(["CLAIM_ACHIEVEMENT", name]);
        }
    }
};

player.get_quest_status = function(quest) {
    var status = 0;
    if('show' in quest && !quest['show']) { return status; }
    if(quest['developer_only'] && (spin_secure_mode || !player.is_developer())) { return status; }

    var qdata = (quest['name'] in player.completed_quests ? player.completed_quests[quest['name']] : null);

    if('repeat_interval' in quest) {
        // repeatable quest
        if(qdata !== null) {
            if(server_time - qdata['time'] < quest['repeat_interval']) {
                return status; // not enough time has passed since last completion
            }
        }
    } else {
        // not a repeatable quest
        if(qdata !== null) {
            return status; // already completed
        }
    }

    if(('show_if' in quest) && !read_predicate(quest['show_if']).is_satisfied(player, qdata)) {
        return status; // show_if predicate not true
    }

    if(('activation' in quest) && !read_predicate(quest['activation']).is_satisfied(player, qdata)) {
        return status; // activation predicate not true
    }

    status |= player.quest_status.ACTIVE; // quest is active!

    if(read_predicate(quest['goal']).is_satisfied(player, qdata)) {
        status |= player.quest_status.CLAIMABLE; // quest is claimable!
    }

    return status;
};

player.has_any_units = function() {
    return !goog.object.isEmpty(player.my_army);
};

player.can_activate_quest = function(quest) {
    if(!(quest['name'] in player.quest_cache)) {
        player.quest_cache[quest['name']] = player.get_quest_status(quest);
    }
    return (player.quest_cache[quest['name']] & player.quest_status.ACTIVE);
};

player.can_complete_quest = function(quest) {
    if(!(quest['name'] in player.quest_cache)) {
        player.quest_cache[quest['name']] = player.get_quest_status(quest);
    }
    return (player.quest_cache[quest['name']] & player.quest_status.CLAIMABLE);
};

player.invalidate_quest_cache = function() { player.quest_cache_dirty = true; };
player.refresh_quest_cache_entry = function(quest) {
    if(quest['name'] in player.quest_cache) {
        delete player.quest_cache[quest['name']];
    }
    player.can_complete_quest(quest); // force re-evaluation
};

/** @param {boolean=} force */
player.update_quest_cache = function(force) {
    if(!force && !player.quest_cache_dirty) { return; }
    if(QUEST_CACHE_DEBUG) { console.log("UPDATE QUEST CACHE"); }
    player.quest_cache_dirty = false;

    player.quest_cache = {};
    player.active_quests = [];

    // Predicates that check for QUEST_COMPLETE can recurse and cause this to be O(N^2).
    // Since game state cannot change during this loop, cache predicate results.
    predicate_cache_on();
    for(var name in gamedata['quests']) {
        var quest = gamedata['quests'][name];
        if(player.can_activate_quest(quest)) {
            player.active_quests.push(quest);
        }
    }
    predicate_cache_off();

    // sort active quest list so that it appears in the UI in good order,
    // and, if auto-accepting, make sure we accept the highest-priority eligible quest
    var compare_by_priority = function(a,b) {
        var pa = a['ui_priority'] || 0, pb = b['ui_priority'] || 0;

        // group all claimable quests together at the front of the list
        var ca = player.can_complete_quest(a), cb = player.can_complete_quest(b);

        // sort by claimability first, and then ui_priority
        if(ca && !cb) {
            return -1;
        } else if(cb && !ca) {
            return 1;
        } else if(pa < pb) {
            return 1;
        } else if(pa > pb) {
            return -1;
        } else {
            return 0;
        }
    };

    player.active_quests.sort(compare_by_priority);

    player.claimable_quests = 0;
    var found_tracked = false;
    var first_completable_quest = null, first_incomplete_quest = null;

    for(var i = 0; i < player.active_quests.length; i++) {
        var quest = player.active_quests[i];

        if(player.can_complete_quest(quest)) {
            player.claimable_quests += 1;
            if(!first_completable_quest) { first_completable_quest = quest; }
        } else {
            if(!first_incomplete_quest) { first_incomplete_quest = quest; }
        }

        // candidate quests for tracking: either FORCE_CLAIM (regardless of claimability) or NOT CLAIMABLE
        if(quest['force_claim'] || !player.can_complete_quest(quest)) {
            // if no quest is currently tracked, and not skipping tutorial,
            // auto-track the highest-priority candidate quest
            if(!player.quest_tracked && !player.preferences['skip_tutorial']) {
                player.quest_tracked = quest; player.quest_tracked_dirty = true;
                found_tracked = true;
                if(QUEST_CACHE_DEBUG) { console.log("HERE A "+player.quest_tracked['name']); }
            } else if(quest === player.quest_tracked) {
                found_tracked = true;
                if(QUEST_CACHE_DEBUG) { console.log("HERE FOUND "+player.quest_tracked['name']); }
            }
        }
    }

    if(!found_tracked) {
        if(QUEST_CACHE_DEBUG) { console.log("NO QUEST FOUND IN FIRST PASS"); }
        player.quest_tracked = null;
        player.quest_tracked_dirty = true;
    }

    // retrack an appropriate quest
    if(!player.preferences['skip_tutorial']) {
        // skip_claim behavior - grab next incomplete quest if nothing is tracked, or if the tracked quest is complete and not foce_claim
        if(first_incomplete_quest &&
           (!player.quest_tracked || (player.can_complete_quest(player.quest_tracked) && !player.quest_tracked['force_claim']))) {
            player.quest_tracked = first_incomplete_quest;
            player.quest_tracked_dirty = true;
            if(QUEST_CACHE_DEBUG) { console.log("HERE B "+player.quest_tracked['name']); }
        }
    }
}

player.prune_expired_mail = function() {
    for(var i = 0; i < player.mailbox.length; i++) {
        var mail = player.mailbox[i];
        if(('expire_time' in mail) && (mail['expire_time'] > 0) && (server_time >= mail['expire_time'])) {
            player.mailbox.splice(i,1);
            i -= 1;
        }
    }
};
player.mailbox_remove = function(mail) {
    for(var i = 0; i < player.mailbox.length; i++) {
        if(player.mailbox[i] === mail) { player.mailbox.splice(i,1); break; }
    }
};
player.mailbox_iter = function(func) {
    var nth = 0;
    for(var i = 0; i < player.mailbox.length; i++) {
        if('show_if' in player.mailbox[i] && player.mailbox[i]['show_if'] in gamedata['predicate_library']) {
            if(!read_predicate({'predicate':'LIBRARY', 'name': player.mailbox[i]['show_if']}).is_satisfied(player, null)) {
                continue;
            }
        }
        if(func(player.mailbox[i], nth)) { break; }
        nth += 1;
    }
};
player.mailbox_count = function() {
    var count = 0;
    player.mailbox_iter(function(mail) { count += 1; });
    return count;
};

/** Get the "Nth" visible mail in the player's mailbox
    @param {number} n
    @return {!Object} - note, return cannot be null */
player.mailbox_nth = function(n) {
    var ret = null;
    player.mailbox_iter(function(mail, i) { if(i == n) { ret = mail; return true } });
    if(!ret) {
        throw Error('mail message not found! '+n.toString()+' from '+JSON.stringify(player.mailbox));
    }
    return ret;
};

/** Get a mail from the mailbox by its msg_id
    @param {string} msg_id
    @return {Object|null} - note, null if mail not found */
player.get_mail_by_msg_id = function(msg_id) {
    var ret = null;
    player.mailbox_iter(function(mail, i) { if(mail['msg_id'] === msg_id) { ret = mail; return true } });
    return ret;
};

player.has_unread_mail = function() {
    if(!player.get_any_abtest_value('enable_inventory', gamedata['enable_inventory'])) { return 0; }
    var count = 0;
    player.mailbox_iter(function(mail) { if(!mail['read']) { count += 1; } });
    return count;
};

player.mail_message_has_money = function(msg) {
    if('gift_order' in msg && 'attachments' in msg && msg['attachments'].length>0) {
        return true;
    }
    // also check for any mail with attached gamebucks
    if('attachments' in msg) {
        for(var i = 0; i < msg['attachments'].length; i++) {
            if(goog.array.contains(['gamebucks','alloy'], msg['attachments'][i]['spec'])) {
                return true;
            }
        }
    }
    return false;
};

player.mail_message_is_discardable = function(msg) {
    if('attachments' in msg) {
        for(var i = 0; i < msg['attachments'].length; i++) {
            if(msg['attachments'][i]['undiscardable']) {
                return false;
            }
        }
    }
    return true;
};

player.has_uncollected_gift_mail = function() {
    var gifts_waiting = 0;
    player.mailbox_iter(function(msg) {
        if(player.mail_message_has_money(msg)) {
            gifts_waiting += 1;
        }
    });
    return gifts_waiting;
};

// returns next level player is qualified for, or 0 if no levelup is possible
player.can_level_up = function() {
    var data = gamedata['player_xp']['level_xp'];

    var level = player.resource_state['player_level'];

    while(level < data.length-1) {
        if(player.resource_state['xp'] >= data[level+1]) {
            level += 1;
            continue;
        } else {
            break;
        }
    }
    return (level > player.resource_state['player_level'] ? level : 0);
};

player.unit_micro_enabled = function() { return (!('enable_unit_micro' in gamedata) || gamedata['enable_unit_micro'] || player.is_cheater); };
player.squads_enabled = function() { return read_predicate({'predicate':'LIBRARY', 'name': 'squads_enabled'}).is_satisfied(player, null); };

/** Get an over-rideable setting from territory.json
    @param {string} name
    @param {?=} default_value
    @return {?} */
player.get_territory_setting = function(name, default_value) {
    if(typeof default_value === 'undefined') {
        default_value = false;
    }
    var ret = default_value;
    if(name in gamedata['territory']) {
        ret = gamedata['territory'][name];
    }
    if(session.region && session.region.data && (name in session.region.data)) {
        ret = session.region.data[name];
    }
    ret = player.get_any_abtest_value(name, ret);
    return ret;
};

/** @return {boolean} */
player.auto_resolve_enabled = function() { return player.get_territory_setting('enable_auto_resolve'); };
/** @return {boolean} */
player.squad_combat_enabled = function() { return player.get_territory_setting('enable_squad_combat'); };
/** @return {boolean} */
player.squad_speedups_enabled = function() { return player.get_territory_setting('enable_squad_speedups'); };
/** @return {boolean} */
player.squad_speedup_items_enabled = function() { return player.get_territory_setting('enable_squad_speedup_items'); };
/** @return {boolean} */
player.map_home_combat_enabled = function() { return player.get_territory_setting('enable_map_home_combat'); };
/** @return {boolean} */
player.quarry_guards_enabled = function() { return player.get_territory_setting('enable_quarry_guards'); };
/** @return {boolean} */
player.raids_enabled = function() { return eval_cond_or_literal(player.get_territory_setting('enable_raids'), player, null); };

/** @return {boolean} */
player.squads_affect_revenge = function() { return eval_cond_or_literal(player.get_territory_setting('squads_affect_revenge'), player, null); };
/** @return {boolean} */
player.quarries_affect_revenge = function() { return eval_cond_or_literal(player.get_territory_setting('quarries_affect_revenge'), player, null); };

/** alliance raids flag - includes both defensive and offensive raids.
    valid only when raids_enabled() is true.
    @return {boolean}
 */
player.alliance_raids_enabled = function() { return eval_cond_or_literal(player.get_territory_setting('enable_alliance_raids'), player, null); };

/** @return {number} */
player.raid_pvp_attempts_left = function() {
    var cd = player.cooldown_find('raid_pvp_attempt');
    var cd_time = player.get_territory_setting('raid_pvp_attempt_cooldown');
    var attempts_max = player.get_territory_setting('raid_pvp_attempts_max');
    var consumed = (cd ? ('stack' in cd ? cd['stack'] : 1) : 0);
    if(cd) {
        // passage of time
        consumed -= Math.max(0, Math.floor((server_time - cd['start']) / cd_time));
    }
    return Math.max(0, attempts_max - consumed);
};
/** @return {number} seconds until next attempt is added, -1 if full */
player.raid_pvp_attempt_next_in = function() {
    var cd = player.cooldown_find('raid_pvp_attempt');
    if(!cd) { return -1; }
    var cd_time = player.get_territory_setting('raid_pvp_attempt_cooldown');
    return cd_time - ((server_time - cd['start']) % cd_time);
};

/** @return {string} */
player.squad_block_mode = function() {
    var mode = player.get_territory_setting('squad_block_mode');
    if(!goog.array.contains(['always', 'after_move', 'never'], mode)) { throw Error('bad squad_block_mode '+mode); }
    return mode;
};
/** @return {boolean} */
player.squad_bumping_enabled = function() { return player.get_territory_setting('enable_squad_bumping'); };

player.unit_speedups_enabled = function() { return player.is_cheater || !('enable_unit_speedups' in gamedata) || gamedata['enable_unit_speedups']; };
player.crafting_speedups_enabled = function() { return player.is_cheater || !('enable_crafting_speedups' in gamedata) || gamedata['enable_crafting_speedups']; };
player.resource_gifts_enabled = function() {
    var pred_or_literal = player.get_any_abtest_value('enable_resource_gifts', gamedata['enable_resource_gifts']);
    var pred_ok;
    if(typeof(pred_or_literal) === 'object') {
        pred_ok = read_predicate(pred_or_literal).is_satisfied(player, null);
    } else {
        pred_ok = !!pred_or_literal;
    }
    return (pred_ok &&
            (spin_frame_platform == 'fb' ||
             spin_frame_platform == 'ag' ||
             (spin_frame_platform == 'bh' && friend_invites_enabled())));
};
player.upgrade_bar_enabled = function() { return player.get_any_abtest_value('enable_upgrade_bar', gamedata['client']['enable_upgrade_bar']) &&
                                          read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null); };

player.num_mobile_squads = function() { return goog.object.getCount(player.squads)-1; };
player.num_deployed_squads = function() {
    var count = 0;
    goog.object.forEach(player.squads, function(d) { if('map_loc' in d) { count += 1; } });
    return count;
};
player.num_deployed_raids = function() {
    var count = 0;
    goog.object.forEach(player.squads, function(d) { if('map_loc' in d && d['raid']) { count += 1; } });
    return count;
};
/** returns whether or not all foremen are in use
 * @returns {boolean} */
player.foreman_is_busy = function() {
    return player.foremen_in_use() >= player.stattab['total_foremen'];
};
/** returns whether or not all removers are in use
 * @returns {boolean} */
player.remover_is_busy = function() { return player.removers_in_use() >= 1; };

/** returns a list of buildings that are currently being worked on by a foreman
 * @returns {Array.<GameObject>} */
player.foreman_get_tasks = function() {
    var tasks = [];

    session.for_each_real_object(function(obj) {
        if(obj.is_building() && obj.is_using_foreman()) {
            tasks.push(obj);
        }
    });

    return tasks;
};
/** returns a list of inerts/buildings that are currently being removed
 * @returns {Array.<GameObject>} */
player.remover_get_tasks = function() {
    var tasks = [];
    session.for_each_real_object(function(obj) {
        if((obj.is_inert() || obj.is_building()) && obj.is_removing()) {
            tasks.push(obj);
        }
    });
    return tasks;
};
/** returns the number of foreman that are occupied by a task
 * @returns {number} */
player.foremen_in_use = function() { return player.foreman_get_tasks().length; };
/** returns the number of removers that are occupied by a task
 * @returns {number} */
player.removers_in_use = function() { return player.remover_get_tasks().length; };

player.all_minefields_armed = function() {
    return !session.for_each_real_object(function(obj) {
        if(obj.is_building() && obj.team == 'player' && obj.is_minefield() && !obj.is_minefield_armed()) {
            return true;
        }
    });
};

player.alliance_building_is_busy = function() {
    var alliance_building = find_object_by_type(gamedata['alliance_building']);
    if(!alliance_building || alliance_building.is_under_construction() || alliance_building.is_upgrading() || alliance_building.is_enhancing() || alliance_building.is_removing() || alliance_building.is_damaged()) {
        return true;
    }
    return false;
};
player.region_map_building_is_busy = function() {
    var region_map_building = find_object_by_type(gamedata['region_map_building']);
    if(!region_map_building ||
       ((region_map_building.is_under_construction() || region_map_building.is_upgrading() || region_map_building.is_enhancing() || region_map_building.is_removing()) && !player.get_any_abtest_value('region_map_available_during_transmitter_upgrade', gamedata['territory']['region_map_available_during_transmitter_upgrade'])) ||
       (region_map_building.is_damaged() && !player.get_any_abtest_value('region_map_available_during_transmitter_repair', gamedata['territory']['region_map_available_during_transmitter_repair']))) {
        return true;
    }
    return false;
};
player.warehouse_is_busy = function() {
    if(player.get_any_abtest_value('enable_inventory', gamedata['enable_inventory'])) {
        if(!session.home_base) { return session.home_warehouse_busy; }
        var warehouse = find_object_by_type(gamedata['inventory_building']);
        if(!warehouse ||
           ((warehouse.is_under_construction() || warehouse.is_upgrading() || warehouse.is_enhancing() || warehouse.is_removing()) && !player.get_any_abtest_value('inventory_available_during_warehouse_upgrade', gamedata['inventory_available_during_warehouse_upgrade'])) ||
           (warehouse.is_damaged() && !player.get_any_abtest_value('inventory_available_during_warehouse_repair', gamedata['inventory_available_during_warehouse_repair']))) {
            return true;
        }
    }
    return false;
};
player.squad_bay_is_busy = function() {
    if(player.squads_enabled()) {
        var bay = find_object_by_type(gamedata['squad_building']);
        if(!bay ||
           ((bay.is_under_construction() || bay.is_upgrading() || bay.is_enhancing() || bay.is_removing()) && !player.get_any_abtest_value('squads_available_during_squad_bay_upgrade', gamedata['squads_available_during_squad_bay_upgrade'])) ||
           (bay.is_damaged() && !player.get_any_abtest_value('squads_available_during_squad_bay_repair', gamedata['squads_available_during_squad_bay_repair']))) {
            return true;
        }
    }
    return false;
};

/** @param {!Building} scanner
    @return {boolean} */
player.lottery_is_busy = function(scanner) {
    if(player.get_any_abtest_value('enable_lottery', gamedata['enable_lottery'])) {
        if(!scanner ||
           ((scanner.is_under_construction() || scanner.is_upgrading() || scanner.is_enhancing() || scanner.is_removing()) && !player.get_any_abtest_value('lottery_available_during_scanner_upgrade', gamedata['lottery_available_during_scanner_upgrade'])) ||
           (scanner.is_damaged() && !player.get_any_abtest_value('lottery_available_during_scanner_repair', gamedata['lottery_available_during_scanner_repair']))) {
            return true;
        }
    }
    return false;
};

/** @param {!Building} scanner
    @return {{num_scans: number,
              next_scan_method: (string|null),
              can_scan: boolean,
              on_cooldown: boolean,
              fail_ui_reason: (string|null),
              fail_helper: (function()|null)
              }} */
player.get_lottery_state = function(scanner) {
    var ret = { num_scans: 0,
                next_scan_method: null,
                next_scan_free: false,
                can_scan: false,
                on_cooldown: false,
                fail_ui_reason: null,
                fail_helper: null };

    var spell = gamedata['spells']['LOTTERY_SCAN'];

    if(scanner.contents > 0) {
        ret.num_scans += scanner.contents;
        ret.next_scan_method = 'contents';
        ret.can_scan = true;
    }

    var togo = player.cooldown_togo('lottery_free');
    if(togo <= 0) {
        ret.num_scans += 1;
        ret.next_scan_method = 'cooldown'; // use cooldown first
        ret.can_scan = true;
    } else if(!ret.can_scan) {
        // ret.fail_ui_reason = spell['ui_tooltip_on_cooldown'].replace('%s', pretty_print_time(togo));
        // actually show the button as enabled
        ret.can_scan = true;
        ret.on_cooldown = true;
        ret.next_scan_method = 'paid';

        // check for aura scans
        var aura = goog.array.find(player.player_auras, function(a) {
            return (a['spec'] == 'lottery_scans') && (!('end_time' in a) || (server_time < a['end_time'])) &&
                (!('start_time' in a) || (server_time >= a['start_time']));
        });
        if(aura) {
            ret.num_scans += ('stack' in aura ? aura['stack'] : 1);
            ret.next_scan_method = 'aura';
            if(aura['data'] && aura['data']['free']) {
                ret.next_scan_free = true;
            }
        }
    }

    if(player.lottery_is_busy(scanner)) {
        ret.can_scan = false;
        ret.fail_ui_reason = spell['ui_tooltip_busy'];
        ret.fail_helper = (function (_scanner) { return function() {
            change_selection_unit(_scanner);
            if(_scanner.is_damaged() && !_scanner.is_repairing()) {
                invoke_repair_dialog();
            } else {
                invoke_speedup_dialog('speedup');
            }
        }; })(scanner);
    }

    if(player.inventory.length >= player.max_usable_inventory()) {
        ret.can_scan = false;
        ret.fail_ui_reason = spell['ui_tooltip_inventory_full'];
        ret.fail_helper = function() {
            // send click event
            metric_event('1632_lottery_no_space_help', {'sum': player.get_denormalized_summary_props('brief')});
            var helper = get_requirements_help('inventory_space_need',null);
            if(helper) { helper(); }
        };
    }

    if('requires' in spell) {
        var pred = read_predicate(spell['requires']);
        if(!pred.is_satisfied(player, null)) {
            ret.can_scan = false;
            ret.fail_ui_reason = pred.ui_describe(player);
            ret.fail_helper = get_requirements_help(pred);
        }
    }

    return ret;
};

player.quantize_building_location = function(ji, spec) {
    if(spec['quantize_location']) {
        var q = spec['quantize_location'];
        if(q > 2) {
            // new SG-style quantization
            // because of the convention that a building's x,y coordinates are its center, and not its corner,
            // we can't quantize just by snapping the x,y coordinates. We have to do more math to pick the right center.
            var gridsize = spec['gridsize'];
            if(gridsize[0]&1 || gridsize[1]&1) { throw Error('cannot quantize odd gridsize with q = '+q.toString()); }
            var half = [gridsize[0]>>1, gridsize[1]>>1];
            // this is where the corner was BEFORE quantization
            var old_corner = [ji[0]-half[0], ji[1]-half[1]];
            // this is where we want the corner to be AFTER quantization
            var corner = [q*Math.floor(old_corner[0]/q),
                          q*Math.floor(old_corner[1]/q)];
            return [corner[0]+half[0], corner[1]+half[1]];
        } else {
            // 2-unit TR-style quantization
            return [q*Math.floor(ji[0]/q),
                    q*Math.floor(ji[1]/q)];
        }
    }
    return ji;
};

player.is_building_location_valid = function(ji, spec, myself, options) {
    return player.is_building_location_valid_detailed(ji, spec, myself, options)[0];
};
player.is_building_location_valid_detailed = function(ji, spec, myself, options) {
    var world = session.get_real_world();
    var gridsize = spec['gridsize'];

    if(spec['quantize_location']) { // enforce quantization
        var test_ji = player.quantize_building_location(ji, spec);
        if(ji[0] != test_ji[0] || ji[1] != test_ji[1]) {
            return [false,'overlap'];
        }
    }

    // find bounding box of building
    var bound = get_grid_bounds(ji, gridsize);

    // check against base size
    var ncells = world.base.ncells();
    var mid = world.base.midcell();
    var rad = world.base.get_base_radius();

    // allow outside perimeter in developer mode
    if(player.is_cheater || (options && options.ignore_perimeter)) {
        // just clamp against entire play area
        if(bound[0][0] < 0 || bound[0][1] > ncells[0] ||
           bound[1][0] < 0 || bound[1][1] > ncells[1]) {
            return [false,'perimeter'];
        }
    } else {
        // clamp against base perimeter
        if(bound[0][0] < mid[0]-rad || bound[0][1] > mid[0]+rad ||
           bound[1][0] < mid[1]-rad || bound[1][1] > mid[1]+rad) {
            return [false,'perimeter'];
        }
    }

    // allow overlap in developer mode
    if(player.is_cheater) { return [true,null]; }

    // get curret bounds, for an object that's already built
    var mybound = (myself ? get_grid_bounds([myself.x,myself.y], gridsize) : null);

    // check against map-object blockage
    for(var v = bound[1][0]; v <= bound[1][1]-1; v++) {
        for(var u = bound[0][0]; u <= bound[0][1]-1; u++) {
            // ignore collisions from the building itself
            if(mybound) {
                if(v >= mybound[1][0] && v < mybound[1][1] &&
                   u >= mybound[0][0] && u < mybound[0][1]) {
                    continue;
                }
            }
            if(world.astar_map.is_blocked([u,v])) {
                return [false,'overlap'];
            }
        }
    }

    // also check against all buildings
    // since we want to restrict on gridsize, NOT unit_collision_gridsize (which controls map blocking)
    // and block placement on top of destroyed buildings, which do not block the astar map!

    // expand boundary to include exclusion zone
    var zone = spec['exclusion_zone'] || [0,0];
    var excl_bound = [[bound[0][0]-zone[0], bound[0][1]+zone[0]],
                      [bound[1][0]-zone[1], bound[1][1]+zone[1]]];

    for(var id in world.objects.objects) {
        var obj = world.objects.objects[id];
        if(obj !== myself && (obj.is_building() || (obj.is_inert() && obj.spec['blocks_buildings']))) {
            var hisbound = get_grid_bounds([obj.x,obj.y], obj.spec['gridsize']);
            // if OTHER object has an exclusion zone, then apply OUR exclusion zone
            var b = (obj.spec['exclusion_zone'] ? excl_bound : bound);

            if((b[0][0] < hisbound[0][0] && b[0][1] > hisbound[0][0]) ||
               (b[0][0] >= hisbound[0][0] && b[0][0] < hisbound[0][1])) {

                if((b[1][0] < hisbound[1][0] && b[1][1] > hisbound[1][0]) ||
                   (b[1][0] >= hisbound[1][0] && b[1][0] < hisbound[1][1])) {
                    return [false,'overlap'];
                }
            }
        }
    }

    return [true,null];
}

// returns PlayerCache entries for each giftable friend (and possible alliancemate)
// may go asynchronous, so uses a callback (guarantees GUI blockage though)
player.get_giftable_friend_info_list_async = function(cb) {
    var giftable_friends = [];
    for(var i = 0; i < player.friends.length; i++) {
        var friend = player.friends[i];
        if(!friend.is_giftable()) {
            continue;
        }
        // note: cannot rely on actual PlayerCache info entries being present in the cache,
        // since a clear() can get rid of them. Reconstruct a fake entry instead.
        var props = {'user_id': friend.user_id,
                     'ui_name': friend.get_ui_name()};
        var fbid = friend.get_facebook_id();
        if(fbid) {
            props['facebook_id'] = fbid;
        }
        giftable_friends.push(props);
    }

    if(gamedata['gift_alliancemates'] && session.is_in_alliance()) {
        // query alliance mates
        var ui_locker_arr = [null]; // need to pass the UI locker dialog to the callback AFTER query is launched, so stuff it inside an array
        AllianceCache.query_members(session.alliance_id, false, null, (function (_ui_locker_arr, _cb, _giftable_friends) { return function(info) {
            close_dialog(_ui_locker_arr[0]);
            if(info && info['members']) {
                goog.array.forEach(info['members'], function(member_info) {
                    var member_id = member_info['user_id'];
                    // ignore yourself
                    if(member_id == session.user_id) { return; }
                    // ignore already-listed players
                    if(goog.array.findIndex(_giftable_friends, function(info) { return info['user_id'] == member_id; }) >= 0) { return; }
                    // ignore players on cooldown
                    if(player.cooldown_active('send_gift:'+member_id.toString())) { return; }
                    // ensure cached player info
                    var player_info = PlayerCache.query_sync(member_id);
                    if(player_info) {
                        // Facebook doesn't allow sending requests to non-friends who aren't playing anymore,
                        // so skip them. The limit seems to be around 7-9 days. But anyone who uninstalls the app may cause an error immediately.
                        if(player_info['uninstalled'] ||
                           !('last_login_time' in player_info) ||
                           player_info['last_login_time'] < server_time - 5*86400) {
                            return;
                        }
                        // also skip blacklisted players
                        if(member_id.toString() in FBSendRequests.user_id_blacklist) { return; }

                        _giftable_friends.push(player_info);
                    }
                });
            }
            _cb(_giftable_friends);
        }; })(ui_locker_arr, cb, giftable_friends));
        ui_locker_arr[0] = invoke_ui_locker_until_closed(); // prevent GUI action while the query is in progress
    } else {
        cb(giftable_friends);
    }
};

player.map_bookmark_create = function(region_id, ui_name, coords) {
    coords = vec_floor(coords);
    if(!(region_id in player.map_bookmarks)) { player.map_bookmarks[region_id] = []; }
    var found = false;
    for(var i = 0; i < player.map_bookmarks[region_id].length; i++) {
        if(vec_equals(coords, player.map_bookmarks[region_id][i]['coords'])) {
            player.map_bookmarks[region_id][i]['ui_name'] = ui_name;
            player.map_bookmarks[region_id][i]['time'] = server_time;
            found = true; break;
        }
    }
    if(!found) {
        if(goog.object.getCount(player.map_bookmarks[region_id]) >= gamedata['client']['map_bookmarks_max']) {
            var err = gamedata['errors']['TOO_MANY_BOOKMARKS'];
            invoke_child_message_dialog(err['ui_title'], err['ui_name'].replace('%d', pretty_print_number(gamedata['client']['map_bookmarks_max'])),
                                        {'dialog':'message_dialog_big'});
            return;
        }
        player.map_bookmarks[region_id].push({'region':region_id, 'coords':coords, 'ui_name':ui_name, 'time': server_time});
    }
    send_to_server.func(["MAP_BOOKMARK_UPDATE", region_id, SPHTTP.wrap_string(ui_name), coords, server_time]);
};
player.map_bookmark_rename = player.map_bookmark_create;
player.map_bookmark_find = function(region_id, coords) {
    coords = vec_floor(coords);
    if(!(region_id in player.map_bookmarks)) { return null; }
    for(var i = 0; i < player.map_bookmarks[region_id].length; i++) {
        if(vec_equals(coords, player.map_bookmarks[region_id][i]['coords'])) {
            return player.map_bookmarks[region_id][i];
        }
    }
    return null;
};
player.map_bookmark_delete = function(region_id, coords) {
    coords = vec_floor(coords);
    if(!(region_id in player.map_bookmarks)) { return; }
    for(var i = 0; i < player.map_bookmarks[region_id].length; i++) {
        if(vec_equals(coords, player.map_bookmarks[region_id][i]['coords'])) {
            player.map_bookmarks[region_id].splice(i,1);
            send_to_server.func(["MAP_BOOKMARK_UPDATE", region_id, SPHTTP.wrap_string('DELETED'), coords]);
            break;
        }
    }
    if(player.map_bookmarks[region_id].length < 1) {
        delete player.map_bookmarks[region_id];
    }
};

player.get_max_storage = function() {
    var ret = goog.object.map(gamedata['resources'], function() { return 0; });
    session.for_each_real_object(function(obj) {
        if(obj.is_building() && !obj.spec['worth_less_xp'] && !obj.is_under_construction()) {
            for(var res in gamedata['resources']) {
                ret[res] += obj.get_leveled_quantity(obj.spec['storage_'+res] || 0);
            }
        }
    });
    return ret;
};

/** @param {string} resname
    @return {number} 0-1 fullness of storage */
function get_storage_fullness(resname) {
    // XXX probably should make this clearer by separating base vs. player data
    if(session.viewing_ai || session.is_replay() || session.viewing_base.base_id != session.viewing_player_home_base_id) {
        return 0.5;
    } else {
        var max_res = player.get_max_storage();
        if(max_res[resname] <= 0) { return 0; }
        var p = (session.home_base ? player.resource_state : enemy.resource_state);
        return p[resname][1]/max_res[resname];
    }
}

player.init_abtests = function(test_data) {
    player.abtests = test_data;
    // modify gamedata

    if(spin_art_path) {
        // NOTE! this is for testing only, and only affects downloads that begin AFTER server connection!
        spin_art_path = player.get_any_abtest_value('art_cdn_path', spin_art_path);
    }

    for(var test_name in player.abtests) {
        var group = player.abtests[test_name];
        if(test_name in gamedata['abtests'] && gamedata['abtests'][test_name]['active'] && (group in gamedata['abtests'][test_name]['groups'])) {
            var data = gamedata['abtests'][test_name]['groups'][group];
            if(data['patches_client_gamedata']) {
                var kinds = ['resources', 'spells', 'units', 'buildings', 'tech', 'enhancements', 'art', 'dialogs', 'strings', 'map', 'quests', 'predicate_library', 'consequent_library', 'tutorial','virals'];
                for(var i = 0; i < kinds.length; i++) {
                    var kind = kinds[i];
                    if(kind in data) {
                        var patches = data[kind];
                        var target = gamedata[kind];
                        for(var klass in patches) {
                            var patch = patches[klass];
                            if(typeof patch === 'object') {
                                var ktarg = target[klass];
                                for(var key in patch) {

                                    // special case for dialogs.json:
                                    // add widget properties rather than replace
                                    if(kind === 'dialogs' && key === 'widgets') {
                                        for(var widget_name in patch[key]) {
                                            for(var prop_name in patch[key][widget_name]) {
                                                ktarg[key][widget_name][prop_name] = patch[key][widget_name][prop_name];
                                            }
                                        }
                                    } else {
                                        ktarg[key] = patch[key];
                                    }
                                }
                            } else {
                                target[klass] = patch;
                            }
                        }
                    }
                }
            }
        }
    }

    // now that quests are all patched, compute last step of each ui_category
    player.quest_chain_lengths = {};
    for(var name in gamedata['quests']) {
        var quest = gamedata['quests'][name];
        if('ui_category' in quest) {
            var last = (quest['ui_category'] in player.quest_chain_lengths ? player.quest_chain_lengths[quest['ui_category']] : 0);
            var cur = quest['ui_step'] || 1;
            player.quest_chain_lengths[quest['ui_category']] = Math.max(last, cur);
        }
    }

    // select FB payments API
    var api_name = eval_cond_or_literal(player.get_any_abtest_value('payments_api', gamedata['store']['payments_api']), player, null);
    if(!api_name) { throw Error('cannot get payments_api name'); }
    SPay.set_api(api_name);
};

player.get_abtest_value = function(test_name, key, default_value) {
    if(test_name in gamedata['abtests']) {
        var group;
        if(gamedata['abtests'][test_name]['active'] && (test_name in player.abtests)) {
            group = player.abtests[test_name];
        } else {
            group = gamedata['abtests'][test_name]['default_group'];
        }
        if(group in gamedata['abtests'][test_name]['groups']) {
            return gamedata['abtests'][test_name]['groups'][group][key];
        }
    }
    return default_value;
};

player.get_any_abtest_value = function(key, default_value) {
    for(var test_name in player.abtests) {
        var group = player.abtests[test_name];
        if(test_name in gamedata['abtests']) {
            var data = gamedata['abtests'][test_name];
            if(data['active'] && group in data['groups']) {
                var group_data = data['groups'][group];
                if(key in group_data) {
                    return group_data[key];
                }
            }
        }
    }
    return default_value;
};

player.flashy_loot = function() {
    if(player.get_abtest_value('T010_flashy_loot', 'enable', 1) &&
       player.get_abtest_value('T012_flashy2', 'enable', 1)) {
        return true;
    } else {
        return false;
    }
};

player.record_feature_use = function(name) {
    var key = 'feature_used:'+name;
    if(!(key in player.history) || player.history[key] < 1) {
        player.history[key] = 1; // client-side predict
        send_to_server.func(["RECORD_FEATURE_USE", name]);

        // update quest status, because some quests are completed by a feature_used: value going nonzero
        player.invalidate_quest_cache();
        player.quest_tracked_dirty = true;
        return true; // first time
    }
    return false; // already seen
};
player.check_feature_use = function(name) {
    var key = 'feature_used:'+name;
    return !!(player.history[key]);
};

player.record_client_history = function(name, incr) {
    send_to_server.func(["RECORD_CLIENT_HISTORY", name, incr]);
};

// find the type of building that can perform research on "category"
function get_lab_for(category) {
    for(var name in gamedata['buildings']) {
        var cats = gamedata['buildings'][name]['research_categories'] || null;
        if(cats && goog.array.contains(cats, category)) {
            return name;
        }
    }
    return null;
}
// find the type of building that can produce units of a specific category
function get_factory_for(category) {
    for(var name in gamedata['buildings']) {
        if((gamedata['buildings'][name]['manufacture_category'] || null) == category) {
            return name;
        }
    }
    return null;
}
// find the type of building that can craft items of a specific category
function get_workshop_for(category) {
    for(var name in gamedata['buildings']) {
        var cats = gamedata['buildings'][name]['crafting_categories'] || null;
        if(cats) {
            if (goog.array.contains(cats, category)) {
                return name;
            } else {
                goog.array.forEach(cats, function(subcats) {
                    if(subcats && Array.isArray(subcats)){
                        if (goog.array.contains(subcats, category)) {
                            return name;
                        }
                    }
                });
            }
        }
    }
    throw Error('no workshop for category '+category);
}

// find the type of building that increases your TOTAL army space
function total_space_building() {
    for(var specname in gamedata['buildings']) {
        var spec = gamedata['buildings'][specname];
        if((player.squads_enabled() && 'provides_total_space' in spec) ||
           (!player.squads_enabled() && ('provides_space' in spec))) {
            return specname;
        }
    }
    return gamedata['townhall']; // fallback
}
// find the type of building that increases your DEPLOYABLE army space
function attack_space_building() {
    for(var specname in gamedata['buildings']) {
        var spec = gamedata['buildings'][specname];
        if('provides_space' in spec) {
            return specname;
        }
    }
    return gamedata['townhall']; // fallback
}

// enemy player state
var enemy = {
    facebook_portrait: null,
    resource_state: {
        "protection_end_time": 0,
        "player_level": 0
    },
    instance_expiration_time:-1,
    tech: {},
    unit_equipment: {},
    stattab: {},
    player_auras: [],
    is_pvp_player_cache: true
};

enemy.init = function() {
    for(var res in gamedata['resources']) {
        enemy.resource_state[res] = [0,0];
    }
};

/** @return {number} */
enemy.level = function() { return enemy.resource_state['player_level']; };

enemy.is_pvp_player = function() { return enemy.is_pvp_player_cache; };

enemy.is_ladder_player = function() {
    if(!enemy.is_pvp_player()) { return false; }
    return gamedata['ladder_pvp'] || (session.viewing_player_home_region && (session.viewing_player_home_region in gamedata['regions']) && gamedata['regions'][session.viewing_player_home_region]['ladder_pvp']);
};
enemy.is_legacy_pvp_player = function() {
    if(!enemy.is_pvp_player()) { return false; }
    if(('legacy_pvp' in gamedata) && !gamedata['legacy_pvp']) { return false; }
    if(session.viewing_player_home_region && session.viewing_player_home_region in gamedata['regions']) {
        var data = gamedata['regions'][session.viewing_player_home_region];
        if('legacy_pvp' in data && !data['legacy_pvp']) { return false;}
    }
    return true;
};
enemy.get_any_abtest_value = function(key, default_value) { return default_value; };

player.get_townhall = function() {
    return session.for_each_real_object(function(obj) {
        if(obj.team === 'player' && obj.spec['name'] === gamedata['townhall']) {
            return obj;
        }
    });
};
player.get_townhall_level = function() {
    var cc = player.get_townhall();
    if(cc) {
        return cc.level;
    } else if(session.is_remote_base()) {
        if(gamedata['townhall']+'_level' in player.history) {
            return player.history[gamedata['townhall']+'_level'];
        } else {
            // XXX nasty hack
            return 5;
        }
    }
    return 0;
};

player.is_pvp_player = function() { return read_predicate({'predicate':'LIBRARY','name':'pvp_requirement'}).is_satisfied(player,null); };

player.is_ladder_player = function() {
    if(!player.is_pvp_player()) { return false; }
    return gamedata['ladder_pvp'] || (session.region && session.region.data && session.region.data['ladder_pvp']);
};
player.is_legacy_pvp_player = function() {
    if(!player.is_pvp_player()) { return false; }
    if(('legacy_pvp' in gamedata) && !gamedata['legacy_pvp']) { return false; }
    if(session.region && session.region.data && ('legacy_pvp' in session.region.data) && !session.region.data['legacy_pvp']) { return false; }
    return true;
};

player.home_continent = function() {
    if(session.region && session.region.data) { return session.region.data['continent_id']; }
    return eval_cond_or_literal(gamedata['continent_assignment'], player, null);
};

/** @param {string} specname
    @param {number} level
    @return {boolean} whether this type of unit, if owned by player, currently carries a secteam */
player.unit_carries_secteam = function(specname, level) {
    var spec = gamedata['units'][specname];
    var on_destroy = get_unit_stat(player.stattab, specname, 'on_destroy', get_leveled_quantity(spec['on_destroy'] || null, level));
    if(!on_destroy) { return false; }
    for(var i = 0; i < on_destroy.length; i++) {
        var cons = on_destroy[i];
        if(cons['consequent'] === 'SPAWN_SECURITY_TEAM') {
            return true;
        }
    }
    return false;
};

player.can_resurrect_unit = function(obj) {
    if(obj.spec['resurrectable']) { return true; }
    return get_unit_stat(player.stattab, obj.spec['name'], 'resurrection', RESURRECT_NEVER) >= RESURRECT_AND_REPAIR_WITH_TECH;
};

/** @param {Object} spec - note: the spec itself, not the specname
    @param {number} hp
    @return {boolean} */
player.can_repair_unit_of_spec = function(spec, hp) {
    if(hp > 0) { return true; }
    var ability = (spec['resurrectable'] ? ((gamedata['resurrect_requires_tech'] && !spec['resurrectable_without_tech']) ? RESURRECT_AND_REPAIR_WITH_TECH : RESURRECT_AND_REPAIR_ALWAYS) : RESURRECT_NEVER);
    ability = Math.max(ability, get_unit_stat(player.stattab, spec['name'], 'resurrection', RESURRECT_NEVER));
    if(ability >= RESURRECT_AND_REPAIR_ALWAYS) {
        return true;
    } else if(ability >= RESURRECT_AND_REPAIR_WITH_TECH) {
        if((player.tech[spec['level_determined_by_tech']] || 0) >= 1) { return true; }
    }
    return false;
};

player.can_repair_unit = function(obj) { return player.can_repair_unit_of_spec(obj.spec, obj.hp); };

/** @param {string} specname
    @param {?number=} level
    @return {!Array.<number>} */
player.inventory_item_quantity_and_expiration = function(specname, level) {
    var total = 0, expire_time = -1;
    for(var i = 0; i < player.inventory.length; i++) {
        var item = player.inventory[i];
        if(item['spec'] == specname && (!level || (item['level']||1) == level)) {
            if((!('expire_time' in item)) || (item['expire_time'] >= server_time)) {
                var stack = (('stack' in item) ? item['stack'] : 1);
                total += stack;
                if('expire_time' in item) {
                    if(expire_time > 0) {
                        expire_time = Math.min(expire_time, item['expire_time']);
                    } else {
                        expire_time = item['expire_time'];
                    }
                }
            }
        }
    }
    return [total, expire_time];
};

/** @param {string} specname
    @param {?number=} level
    @return {number} */
player.inventory_item_quantity = function(specname, level) {
    var quant_expr = player.inventory_item_quantity_and_expiration(specname, level);
    return quant_expr[0];
};

player.stored_item_iter = function(func) {
    var stop = false;
    goog.array.forEach(player.inventory, function(entry) { stop |= func(entry); }); if(stop) { return; }
    goog.array.forEach(player.loot_buffer, function(entry) { stop |= func(entry); }); if(stop) { return; }
};

/** If an item of "espec" can theoretically go into a slot on a "thing" (works with both building and unit specs),
    then return the applicable criteria object from within espec, otherwise null.
    (ignores unique_equipped/limited_equipped constraints)
    @param {Object} host_spec
    @param {number} host_level
    @param {string} slot_type
    @param {Object} espec of the equipment item
    @param {Object} einstance of the equipment item
    @param {boolean=} ignore_min_level ignore the min_level requirement
    @return {Object|null} */
function equip_is_compatible_with_slot(host_spec, host_level, slot_type, espec, einstance, ignore_min_level) {
    if(!('equip' in espec)) { return null; }
    var crit_list;
    if('compatible' in espec['equip']) {
        crit_list = espec['equip']['compatible'];
    } else {
        crit_list = [espec['equip']]; // legacy items use raw outer JSON
    }
    for(var i = 0; i < crit_list.length; i++) {
        var crit = crit_list[i];
        if(('kind' in crit) && (crit['kind'] != host_spec['kind'])) { continue; }
        if(('name' in crit) && (crit['name'] != host_spec['name'])) { continue; }
        if(('manufacture_category' in crit) && (crit['manufacture_category'] != host_spec['manufacture_category'])) { continue; }
        if(('history_category' in crit) && (crit['history_category'] != host_spec['history_category'])) { continue; }
        if(('slot_type' in crit) && crit['slot_type'] != slot_type) { continue; }
        if(!ignore_min_level && ('min_level' in crit) && (host_level < get_leveled_quantity(crit['min_level'], einstance['level'] || 1))) { continue; }
        return crit;
    }
    return null;
}

/** Return true if an item of "espec" can theoretically go into a slot on a building
    (ignores unique_equipped/limited_equipped constraints)
    @param {Building} unit
    @param {string} slot_type
    @param {Object} espec of the equipment item
    @param {Object} einstance of the equipment item
    @param {boolean=} ignore_min_level
    @return {Object|null}
*/
function equip_is_compatible_with_building(unit, slot_type, espec, einstance, ignore_min_level) {
    return equip_is_compatible_with_slot(unit.spec, unit.level, slot_type, espec, einstance, ignore_min_level);
}

/** Return true if an item of "espec" can theoretically go into a slot on a unit spec
    (ignores unique_equipped/limited_equipped constraints)
    @param {string} techname of the unit-associated tech
    @param {string} specname of the unit
    @param {string} slot_type
    @param {Object} espec of the equipment item
    @param {Object} einstance of the equipment item
    @param {boolean=} ignore_min_level
    @return {Object|null}
*/
function equip_is_compatible_with_unit(techname, specname, slot_type, espec, einstance, ignore_min_level) {
    return equip_is_compatible_with_slot(gamedata['units'][specname], player.tech[techname]||0, slot_type, espec, einstance, ignore_min_level);
}

/** Find any player-owned building in the session that is compatible with a given equip item
    @param {Object} item_spec
    @return {Building|null} */
function find_any_compatible_building(item_spec) {
    var equip = item_spec['equip'];
    var crit_list = ('compatible' in equip ? equip['compatible'] : [equip]);
    for(var i = 0; i < crit_list.length; i++) {
        var crit = crit_list[i];
        if(crit['kind'] === 'building') {
            var ok_obj = session.for_each_real_object(function(obj) {
                if(obj.spec['equip_slots'] && crit['slot_type'] in obj.spec['equip_slots'] &&
                   equip_is_compatible_with_building(obj, crit['slot_type'], item_spec, null, true) &&
                   obj.team === 'player') {
                    return obj;
                }
            });
            if(ok_obj) { return ok_obj; }
        }
    }
    return null;
};

/** Reference to a specific slot in an equipment data structure
    @constructor @struct
    @param {string} slot_type
    @param {number} slot_index */
var EquipSlotAddress = function(slot_type, slot_index) {
    this.slot_type = slot_type;
    this.slot_index = slot_index;
};
EquipSlotAddress.prototype.equals = function(other) {
    return (this.slot_type == other.slot_type && this.slot_index == other.slot_index);
};

/** Reference to a specific slot on a specific building, e.g. used as delivery address for crafting products
    @constructor @struct
    @extends EquipSlotAddress
    @param {GameObjectId} obj_id
    @param {string} slot_type
    @param {number} slot_index */
var BuildingEquipSlotAddress = function(obj_id, slot_type, slot_index) {
    goog.base(this, slot_type, slot_index);
    this.obj_id = obj_id;
};
goog.inherits(BuildingEquipSlotAddress, EquipSlotAddress);
BuildingEquipSlotAddress.prototype.equals = function(other) {
    return (goog.base(this, 'equals', other) && this.obj_id == other.obj_id);
};

/** Reference to a specific slot on a specific unit type
    @constructor @struct
    @extends EquipSlotAddress
    @param {string} specname
    @param {string} slot_type
    @param {number} slot_index */
var UnitEquipSlotAddress = function(specname, slot_type, slot_index) {
    goog.base(this, slot_type, slot_index);
    this.specname = specname;
};
goog.inherits(UnitEquipSlotAddress, EquipSlotAddress);
UnitEquipSlotAddress.prototype.equals = function(other) {
    return (goog.base(this, 'equals', other) && this.specname == other.specname);
};

/** Legacy equipment entry format is just a specname string. New equipment format is a full {'spec':..., 'level':...} dictionary
    @param {?} data
    @return {Object} */
player.decode_equipped_item = function(data) {
    if(typeof(data) === 'string') {
        return {'spec':data};
    }
    return data;
};

/** Iterate through all equipped items
    @param {function(Object, EquipSlotAddress):(boolean|undefined)} func (return true to stop iteration) */
player.equipped_item_iter = function(func) {
    var stop = false;
    goog.object.forEach(player.unit_equipment, function(equipment, specname) {
        goog.object.forEach(equipment, function(name_list, slot_type) {
            if(slot_type === 'equip_pending') { return; } // special value
            goog.array.forEach(name_list, function(name, slot_index) { if(name) { stop |= func(player.decode_equipped_item(name), new UnitEquipSlotAddress(specname, slot_type, slot_index)); } });
        });
    });
    if(stop) { return; }
    session.for_each_real_object(function(obj) {
        if(obj.is_building() && obj.team === 'player') {
            if(obj.equipment) {
                goog.object.forEach(obj.equipment, function(name_list, slot_type) {
                    goog.array.forEach(name_list, function(name, slot_index) { if(name) { stop |= func(player.decode_equipped_item(name), new BuildingEquipSlotAddress(obj.id, slot_type, slot_index)); } });
                });
            }
        }
    });
};

player.mail_attachments_iter = function(func) {
    goog.array.forEach(player.mailbox, function(mail) {
        if('attachments' in mail) {
            goog.array.forEach(mail['attachments'], func);
        }
    });
};

/** Iterate through all crafting queues for ingredients and products
    @param {function(Object, (EquipSlotAddress|null)):(boolean|undefined)} func (return true to stop iteration) */
player.crafting_queue_ingredients_and_products_iter = function(func) {
    session.for_each_real_object(function(obj) {
        if(obj.is_building() && obj.team === 'player' && obj.is_crafter() && obj.is_crafting()) {
            goog.array.forEach(obj.get_crafting_queue(), function(bus) {
                var recipe_name = bus['craft']['recipe'];
                var recipe = gamedata['crafting']['recipes'][recipe_name] || null;
                if(recipe) {
                    var product_list = get_crafting_recipe_product_list(recipe, bus['craft']['level'] || 1);
                    goog.array.forEach(product_list, function(prod) {
                        if('spec' in prod) { // only works on deterministic products!
                            var address = null;
                            var delivery = bus['craft']['delivery'];
                            if(delivery && delivery['obj_id']) {
                                address = new BuildingEquipSlotAddress(delivery['obj_id'], delivery['slot_type'], delivery['slot_index']);
                            }
                            func(prod, address);
                        }
                    });
                    var ingr_list = get_crafting_recipe_ingredients_list(recipe, bus['craft']['level'] || 1);
                    if(ingr_list && gamedata['crafting']['categories'][recipe['crafting_category']]['refund_ingredients']) {
                        // only check ingredients if they are refundable and thus available to the player if cancelled
                        goog.array.forEach(ingr_list, (function(ingr_item) { func(ingr_item, null); }));
                    }
                }
            });
        }
    });
};

/** Return true if crafting a new item of spec "product_spec" into "delivery_address" would violate a limited_equipped constraint
 @param {Object} product_spec
 @param {BuildingEquipSlotAddress|null} delivery_address
 @return {boolean} */
player.would_violate_limited_equipped = function(product_spec, delivery_address) {
    if(!product_spec['limited_equipped']) { return false; }
    var limit = player.stattab['limited_equipped'][product_spec['limited_equipped']] || 0;
    if(limit < 1) { return true; }
    var count = 0;
    var check_func = function(other_item, other_address) {
        var other_spec = ItemDisplay.get_inventory_item_spec(other_item['spec']);

        // skip our own destination slot if it matches (assumes we're replacing this item)
        if(delivery_address && other_address && other_address instanceof BuildingEquipSlotAddress && other_address.equals(delivery_address) &&
           other_spec['limited_equipped'] == product_spec['limited_equipped']) { return false; }

        if(other_spec && other_spec['limited_equipped']==product_spec['limited_equipped']) {
            count += 1;
            if(count+1 > limit) { return true; }
        }
        return false;
    };

    // check existing items
    player.equipped_item_iter(check_func);
    if(count+1 > limit) { return true; }

    // check crafting queues
    player.crafting_queue_ingredients_and_products_iter(check_func);
    if(count+1 > limit) { return true; }

    return false;
};

/** Return true if crafting a new item of spec "product_spec" into "delivery_address" would violate a unique_equipped constraint
 @param {Object} product_spec
 @param {BuildingEquipSlotAddress|null} delivery_address
 @return {boolean} */
player.would_violate_unique_equipped = function(product_spec, delivery_address) {
    if(!product_spec['unique_equipped']) { return false; }
    var count = 0;
    var check_func = function(other_item, other_address) {
        var other_spec = ItemDisplay.get_inventory_item_spec(other_item['spec']);

        // skip our own destination slot if it matches (assumes we're replacing this item)
        if(delivery_address && other_address && other_address instanceof BuildingEquipSlotAddress && other_address.equals(delivery_address) &&
           other_spec['unique_equipped'] == product_spec['unique_equipped']) { return false; }

        if(other_spec && other_spec['unique_equipped']==product_spec['unique_equipped']) {
            count += 1;
            if(count > 0) { return true; }
        }
        return false;
    };

    // check existing items
    player.equipped_item_iter(check_func);
    if(count > 0) { return true; }

    // check crafting queues
    player.crafting_queue_ingredients_and_products_iter(check_func);
    if(count > 0) { return true; }

    return false;
};

/** Return current count of a limited_equipped item pool, ignoring anything that matches in delivery_address
    @param {Object} product_spec
    @param {BuildingEquipSlotAddress|null} delivery_address
    @return {number} */
player.count_limited_equipped = function(product_spec, delivery_address) {
    var count = 0;
    var count_func = function(other_item, other_address) {
        var other_spec = ItemDisplay.get_inventory_item_spec(other_item['spec']);

        // skip our own destination slot if it matches (assumes we're replacing this item)
        if(delivery_address && other_address && other_address instanceof BuildingEquipSlotAddress && other_address.equals(delivery_address) &&
           other_spec['limited_equipped'] == product_spec['limited_equipped']) { return; }

        if(other_spec && other_spec['limited_equipped']==product_spec['limited_equipped']) {
            count += 1;
        }
    };
    player.equipped_item_iter(count_func);
    player.crafting_queue_ingredients_and_products_iter(count_func);
    return count;
};

/** search player for an item with the given name
 * @param {string} name
 * @param {number=} min_count
 * @param {boolean=} check_mail
 * @param {boolean=} check_crafting
 * @param {?number=} level
 * @param {?number=} min_level
 */
player.has_item = function(name, min_count, check_mail, check_crafting, level, min_level) {
    if(!min_count) { min_count = 1; }
    var count = 0;
    var func = function(x) {
        if(x['spec'] == name && (!level || ((x['level']||1) == level)) && (!min_level || ((x['level']||1) >= min_level))) {
            count += ('stack' in x ? x['stack'] : 1);
            if(count >= min_count) {
                return true;
            }
        }
        return false;
    };
    player.stored_item_iter(func); if(count >= min_count) { return true; }
    player.equipped_item_iter(func); if(count >= min_count) { return true; }
    if(check_mail) { player.mail_attachments_iter(func); }; if(count >= min_count) { return true; }
    if(check_crafting) { player.crafting_queue_ingredients_and_products_iter(func); }; if(count >= min_count) { return true; }
    return false;
}
/** search player for an item with the given name and return how many we have
 * @param {string} name
 * @param {boolean=} check_mail
 * @param {boolean=} check_crafting
 * @param {?number=} level
 */
player.count_item = function(name, check_mail, check_crafting, level) {
    var count = 0;
    var func = function(x) {
        if(x['spec'] == name && (!level || ((x['level']||1) == level))) {
            count += ('stack' in x ? x['stack'] : 1);
        }
        return false;
    };
    player.stored_item_iter(func);
    player.equipped_item_iter(func);
    if(check_mail) { player.mail_attachments_iter(func); }
    if(check_crafting) { player.crafting_queue_ingredients_and_products_iter(func); }
    return count;
}

player.has_item_equipped = function(item_name) {
    var found = false;
    var func = function(x) {
        if(x['spec'] == item_name) {
            found = true;
            return true;
        }
        return false;
    };
    player.equipped_item_iter(func); if(found) { return found; }
    return false;
}

/** Check if this ID is in the range exclusively used by AI players
    @param {number} id
    @return {boolean} */
function is_ai_user_id_range(id) {
    var max_ai_user_id = ('max_ai_user_id' in gamedata ? gamedata['max_ai_user_id'] : 1100);
    return (id > 0 && id <= max_ai_user_id);
}

function home_base_id(user_id) { return 'h' + user_id.toString(); }

// NOTE: "Friend" represents AIs, True Facebook Friends, and "Rivals" (strangers the server gives you to attack)
// to differentiate, use is_ai() and is_real_friend

/** @constructor @struct
    @param {number} user_id
    @param {boolean} is_real_friend
    @param {!Object<string,?>} info
    @param {string|null} relationship (null, 'mentor', or 'trainee')
 */
function Friend(user_id, is_real_friend, info, relationship) {
    this.user_id = user_id;
    this.is_real_friend = !!is_real_friend;
    this.relationship = relationship;

    // store some PlayerCache properties to preserve them even across a clear()
    if(!info) { throw Error('no pcache_data for '+this.user_id.toString()); }
    this.facebook_id_memo = (info['facebook_id'] && info['facebook_id'] !== -1 && info['facebook_id'] !== '-1') ? info['facebook_id'].toString() : null;
    this.social_id_memo = info['social_id'] || null;
    this.is_ai_memo = (info['social_id'] == 'ai' || (info['facebook_id'] && (info['facebook_id'] === -1 || info['facebook_id'] === '-1')));
    this.ui_name_memo = PlayerCache._get_ui_name(info) || 'Unknown(Friend)';
    this.player_level_memo = info['player_level'] || 1;
    this.townhall_level_memo = info[gamedata['townhall']+'_level'] || 1;
}

Friend.prototype.get_facebook_id = function() { return this.facebook_id_memo; };
Friend.prototype.get_social_id = function() { return this.social_id_memo; };
Friend.prototype.is_ai = function() { return this.is_ai_memo; };
Friend.prototype.get_ui_name = function() { return this.ui_name_memo; };
Friend.prototype.is_giftable = function() {
    return !this.is_ai() && player.resource_gifts_enabled() && !player.cooldown_active('send_gift:'+this.user_id.toString());
};
Friend.prototype.is_mentor = function() { return this.relationship === 'mentor'; };
Friend.prototype.is_trainee = function() { return this.relationship === 'trainee'; };
Friend.prototype.is_bh_invite_complete = function() {
    var complete_pred = gamedata['predicate_library']['bh_invite_complete'];
    if(!complete_pred || complete_pred['predicate'] !== 'PLAYER_HISTORY' ||
       complete_pred['key'] != gamedata['townhall']+'_level' ||
       !complete_pred['ui_name']) {
        throw Error('unhandled bh_invite_complete predicate');
    }
    return this.get_townhall_level() >= complete_pred['value'];
};

Friend.prototype.get_player_level = function() {
    if(this.is_ai_memo) { return this.player_level_memo; } // assume AI levels do not change
    var info = PlayerCache.query_sync_fetch(this.user_id);
    if(info) {
        return info['player_level'] || 1;
    }
    return this.player_level_memo; // fallback
};
Friend.prototype.get_townhall_level = function() {
    if(this.is_ai_memo) { return this.townhall_level_memo; } // assume AI levels do not change
    var info = PlayerCache.query_sync_fetch(this.user_id);
    if(info) {
        return info[gamedata['townhall']+'_level'] || 1;
    }
    return this.townhall_level_memo; // fallback
};
Friend.prototype.classify_ai_difficulty = function() {
    var mode = player.get_any_abtest_value('map_dialog_ai_difficulty', gamedata['client']['map_dialog_ai_difficulty']);
    if(mode == 'tier') {
        var player_tier = player.resource_state['player_level'];
        var my_tier = this.player_level_memo;
        if(my_tier >= player_tier + 3) {
            return 'extreme';
        } else if(my_tier >= player_tier + 2) {
            return 'monstrous';
        } else if(my_tier >= player_tier + 1) {
            return 'hard';
        } else if(my_tier >= player_tier) {
            return 'medium';
        } else if(my_tier >= player_tier - 1) {
            return 'easy';
        } else {
            return 'obsolete';
        }
    } else {
        var p_level = player.resource_state['player_level'];
        var gap = (p_level >= 5 ? 5 : 3);
        if(this.player_level_memo < 3) {
            return 'easy';
        } else if(this.player_level_memo < 9) {
            return 'medium';
        } else if(this.player_level_memo < 15) {
            return 'hard';
        } else if(this.player_level_memo < 25) {
            return 'monstrous';
        } else {
            return 'extreme';
        }
    }
};

/** @param {!Friend} a
    @param {!Friend} b
    @return {number} */
Friend.compare_by_player_level = function(a,b) {
    if(a.get_player_level() > b.get_player_level()) {
        return -1;
    } else if(a.get_player_level() < b.get_player_level()) {
        return 1;
    } else {
        return 0;
    }
};

function get_alliance_logo_asset(logo) {
    if(logo) {
        var name = 'alicon_'+logo.toString();
        if(name in GameArt.assets) {
            return name;
        }
    }
    return 'inventory_unknown';
}

/** Return S,M,L,XL designation for the given quarry richness level
    @param {number} richness
    @return {string} */
function quarry_richness_ui_str(richness) {
    var table = gamedata['strings']['regional_map']['richness'];
    var rich_str = '?';
    for(var r = 0; r < table.length; r++) {
        if(richness >= table[r][0]) {
                rich_str = table[r][1];
        } else {
            break;
       }
    }
    return rich_str;
}

/** fungible items go immediately into resource storage. Check if there is enough room.
    @param {!Object} spec
    @param {number} stack
    @param {!Object} resource_state
    @return {boolean} */
function fungible_inventory_item_can_fit(spec, stack, resource_state) {
    if(spec['resource'] == 'gamebucks' || spec['resource'] == 'lottery_scans') {
        return true;
    } else if(spec['resource'] in resource_state) {
        if(stack + resource_state[spec['resource']][1] <= resource_state[spec['resource']][0]) {
            return true;
        }
    }
    return false;
}

function inventory_item_can_fit(item, inventory, max_usable_inventory) {
    var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
    var togo = ('stack' in item ? item['stack'] : 1);

    if(spec['fungible']) {
        return fungible_inventory_item_can_fit(spec, 1, player.resource_state); // check for at least 1 unit to fit
    }

    // open slot
    if(inventory.length < max_usable_inventory) { return true; }

    // can stack with existing (returns true as long as 1 can fit)

    var max_stack = (spec['max_stack'] || 1);
    var orig_stack = togo;
    for(var i = 0; i < inventory.length; i++) {
        var inv = inventory[i];
        if(inv['spec'] === item['spec']) {
            var inv_stack = ('stack' in inv? inv['stack'] : 1);
            if(inv_stack < max_stack) {
                togo -= (max_stack - inv_stack);
                if(togo <= 0) { break; }
            }
        }
    }
    return (togo < orig_stack); // return true if ANY one can be taken from the stack
}

function inventory_items_can_all_fit(items, inventory, max_usable_inventory) {
    // operate on a copy of the inventory and resources

    // note: this is a SHALLOW copy of inventory. Only 'stack' count will be mutated.
    var scratch = [];
    for(var i = 0; i < inventory.length; i++) {
        scratch.push(goog.object.clone(inventory[i]));
    }

    // this is a DEEP clone of resource_state, necessary because the resource
    // entries are themselves arrays.
    var scratch_resource_state = /** @type {!Object<string,*>} */
        (goog.object.unsafeClone(player.resource_state));

    for(var i = 0; i < items.length; i++) {
        var item = items[i];
        var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
        var max_stack = (spec['max_stack'] || 1);
        var togo = ('stack' in item ? item['stack'] : 1);

        if(spec['fungible']) {
            // check for entire fungible amount to fit
            if(fungible_inventory_item_can_fit(spec, togo, scratch_resource_state)) {
                if(spec['resource'] in scratch_resource_state) {
                    scratch_resource_state[spec['resource']][1] += togo;
                }
                continue;
            } else {
                return false;
            }
        } else {
            // check for stackable item
            for(var j = 0; j < scratch.length; j++) {
                var inv = scratch[j];
                if(inv['spec'] === item['spec']) {
                    var inv_stack = ('stack' in inv? inv['stack'] : 1);
                    if(inv_stack < max_stack) {
                        var added = Math.min(togo, (max_stack - inv_stack))
                        togo -= added;
                        inv['stack'] = inv_stack + added;
                    }
                }
            }
            if(togo <= 0) { continue; } // able to accommodate everything just by stacking
            if(scratch.length >= max_usable_inventory) { return false; } // now we need a free slot
            scratch.push(goog.object.clone(item));
        }
    }
    return true;
}

/* Some functions to manually check for array-of-array item lists,
   since get_leveled_quantity() won't do it right */

/** @param {!Object} spec
    @param {number=} level
    @return {!Array.<!Object>} */
function get_crafting_recipe_product_list(spec, level) { // XXXXXX move to ItemDisplay.js
    // need to manually check for array-of-arrays, since get_leveled_quantity() won't do it right
    if(Array.isArray(spec['product']) && spec['product'].length >= 1 && Array.isArray(spec['product'][0])) {
        return get_leveled_quantity(spec['product'], level || 1);
    }
    return spec['product'];
}

/** @param {!Object} spec
    @param {number} level
    @param {string} key_name
    @return {!Array.<!Object>} */
function get_ingredients_list(spec, level, key_name) {
    if(Array.isArray(spec[key_name]) && spec[key_name].length >= 1 && Array.isArray(spec[key_name][0])) {
        return get_leveled_quantity(spec[key_name], level);
    }
    return spec[key_name] || [];
}
/** @param {!Object} spec
    @param {number=} level
    @return {!Array.<!Object>} */
function get_crafting_recipe_ingredients_list(spec, level) { return get_ingredients_list(spec, level || 1, 'ingredients'); };
/** @param {!Object} spec
    @param {number=} level
    @return {!Array.<!Object>} */
function get_enhancement_ingredients_list(spec, level) { return get_ingredients_list(spec, level || 1, 'ingredients'); }
/** @param {!Object} spec
    @param {number=} level
    @return {!Array.<!Object>} */
function get_building_ingredients_list(spec, level) { return get_ingredients_list(spec, level || 1, 'upgrade_ingredients'); }
/** @param {!Object} spec
    @param {number=} level
    @return {!Array.<!Object>} */
function get_tech_ingredients_list(spec, level) { return get_ingredients_list(spec, level || 1, 'research_ingredients'); }

/** Check if this list of ingredient items is OK for instant speedups
    @param {!Array<!Object>} ingr_list
    @return {boolean} */
function ingredients_list_allows_instant(ingr_list) {
    for(var i = 0; i < ingr_list.length; i++) {
        var ingr_spec = ItemDisplay.get_inventory_item_spec(ingr_list[i]['spec']);
        if('allow_instant' in ingr_spec && !ingr_spec['allow_instant']) {
            return false;
        }
    }
    return true;
};

/** Check if this resource is OK for instant speedups
    @param {!Object} resdata
    @param {!Object} player
    @return {boolean} */
function resource_allow_instant_upgrade(resdata,player) {
    if (!('allow_instant' in resdata)) { return true; }
    return eval_pred_or_literal(resdata['allow_instant'], player, null);
}

/** @param {!Object} spec
    @param {number=} level */
function get_crafting_recipe_ui_name(spec, level) { // XXXXXX move to ItemDisplay.js
    level = level || 1;
    if('ui_name' in spec) {
        return get_leveled_quantity(spec['ui_name'], level);
    }
    var product_list = get_crafting_recipe_product_list(spec, level);
    if(product_list[0] && product_list[0]['spec']) {
        return ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(product_list[0]['spec']));
    }
    throw Error('cannot determine ui_name for crafting recipe '+spec['name']+' at level '+level.toString());
}

/** @param {!Object} spec
    @param {number=} level */
function get_crafting_recipe_icon(spec, level) { // XXXXXX move to ItemDisplay.js
    level = level || 1;
    if('icon' in spec) {
        return get_leveled_quantity(spec['icon'], level);
    }
    var product_list = get_crafting_recipe_product_list(spec, level);
    if(product_list[0] && product_list[0]['spec']) {
        return get_leveled_quantity(ItemDisplay.get_inventory_item_spec(product_list[0]['spec'])['icon'], level);
    }
    throw Error('cannot determine icon for crafting recipe '+spec['name']+' at level '+level.toString());
}

// get a spec quantity that is possibly level-dependent (list indexed by level-1)
player.get_leveled_quantity = function(qty) {
    if((typeof qty) === 'number') {
        return qty;
    } else {
        // assume it's an array
        return qty[player.resource_state['player_level']-1];
    }
};

/** @param {!World.World} world
    @param {!Array<number>} xy0
    @param {!Array<number>} xy1
    @param {Object|null} look_for_spec
    @return {!Array<!GameObject>} */
// note: only looks at friendly units, used for drag selection
function find_objects_in_screen_rect(world, xy0, xy1, look_for_spec) {
    var found_units = [];
    var mouserect = [ [xy0[0], xy1[0]],
                      [xy0[1], xy1[1]] ];

    // drag-selection seems to feel better with a smaller amount of fuzz than click-selection
    var position_fuzz = 2;

    world.objects.for_each(function(temp) {
        if(look_for_spec && (temp.spec !== look_for_spec)) { return; }
        if(!temp.is_mobile()) { return; }
        if(temp.is_destroyed()) { return; }
        if(temp.team != 'player' || (session.is_quarry() && !session.has_deployed && session.region.data['storage'] != 'nosql')) { return; }
        var objji = temp.interpolate_pos(world);
        var asset = GameArt.assets[temp.get_leveled_quantity(temp.spec['art_asset'])];
        if(asset.detect_rect(ortho_to_screen(objji), temp.interpolate_facing(world), client_time, 'normal', mouserect, view_zoom, position_fuzz)) {
            found_units.push(temp);
        }
    });
    return found_units;
};

/** @param {!World.World} world
    @param {!Array<number>} xy
    @param {!Array<number>} ji
    @param {boolean} include_unselectable
    @return {GameObject|null} */
function find_object_at_screen_pixel(world, xy, ji, include_unselectable) {
    // note: prioritize units over buildings if there is any overlap
    // also sort units by Z order
    var found_units = [];
    var found_buildings = [];

    // fudge factor for clicking on units - you can be off by this many pixels (at zoom=1) and still hit
    var position_fuzz = 2;
    if(player.tutorial_state === 'click_on_rover_action') {
        position_fuzz = 10;
    }

    // could speed up with some form of 2D data structure
    world.objects.for_each(function(temp) {
        var objji = temp.interpolate_pos(world);

        if(temp.is_inert() && !player.is_cheater) {
            if(temp.spec['is_scenery'] && !temp.spec['has_tooltip']) {
                return;
            }
            if(!include_unselectable && !temp.spec['selectable']) {
                return;
            }
        }

        if(temp.is_invisible() && (temp.team !== 'player' || session.is_replay())) { return; }

        if(!temp.is_mobile()) {
            // in combat, skip destroyed buildings (but in peacetime keep them, because you want the context menu to repair)
            if(temp.is_destroyed() && session.has_attacked && (session.viewing_base.base_type != 'quarry' || session.viewing_base.base_landlord_id != session.user_id)) { return; }

            if(temp.detect_click(world, xy, ji, view_zoom, position_fuzz)) {
                found_buildings.push(temp);
                // do not break out of loop
            }
        } else {
            if(!temp.is_destroyed() && temp.detect_click(world, xy, ji, view_zoom, position_fuzz)) {
                found_units.push(temp);
            }
        }
    });

    var found_list = (found_units.length > 0 ? found_units : found_buildings);
    var ret = null;

    if(found_list.length > 0) {
        if(found_list.length < 2) {
            ret = found_list[0];
        } else {
            // return unit with highest Z coordinate
            var high_unit = found_list[0], high_z = -1;
            for(var i = 0; i < found_list.length; i++) {
                var unit_xy = found_list[i].interpolate_pos(world);
                var unit_z = ortho_to_depth(unit_xy);
                if(unit_z > high_z) {
                    high_z = unit_z;
                    high_unit = found_list[i];
                }
            }
            ret = high_unit;
        }
    }

    if(player.tutorial_state === 'click_on_rover_action') {
        if(ret && ret.spec['name'] != gamedata['tutorial'][player.tutorial_state]['unit_type']) {
            return null;
        }
    } else if(player.tutorial_state === 'move_rover_action') {
        return null;
    }
    return ret;
}

// update resource_state from server protocol message
var update_resources_is_first_call = true;
function update_resources(data, init) {
    var res_changed = false, res_reduced = false;
    for(var res in gamedata['resources']) {
        if(data[res][1] != player.resource_state[res][1]) {
            res_changed = true;
            if(data[res][1] < player.resource_state[res][1]) {
                res_reduced = true;
            }
        }
    }
    if(res_changed) {
        if(init && update_resources_is_first_call) {
            // do not cause ticker effects on very first call
        } else {
            if(player.last_resource_time <= 0) {
                var delay;
                if(res_reduced) {
                    // do not delay ticker effect on reduction
                    delay = 0;
                } else {
                    delay = gamedata['client']['resource_ticker_delay'];
                }
                player.last_resource_time = client_time + delay;
            }

            // trigger flashes
            // NOTE: this will overlap with the flashes from receiving the HARVESTED_RESOURCES message,
            // but checking for flash_X_time <= 0 means that the flash should be triggered correctly
            // because the server sends HARVESTED_RESOURCES *before* the actual resource level update
            for(var res in gamedata['resources']) {
                if(data[res][1] > player.resource_state[res][1] && player.flash_res_time[res] <= 0) {
                    player.flash_res_time[res] = client_time;
                }
            }
        }
        for(var res in gamedata['resources']) {
            player.last_resource_state[res] = player.resource_state[res][1];
        }

        session.clear_building_idle_state_caches(); // for ALL buildings
    }

    var currency = (player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks' ? 'gamebucks' : 'facebook_credits');
    if(data[currency] != player.resource_state[currency]) {
        if(init && update_resources_is_first_call) {
        } else {
            if(player.last_credits_time <= 0) {
                player.last_credits_time = client_time;
            }
            if(data[currency] > player.resource_state[currency] && player.flash_credits_time <= 0) {
                player.flash_credits_time = client_time;
            }
        }
        player.last_resource_state[currency] = player.resource_state[currency];
    }

    update_resources_xp(data['xp']);

    player.resource_state["space"] = data["space"];
    for(var res in gamedata['resources']) {
        player.resource_state[res] = data[res];
    }
    player.resource_state["gamebucks"] = data["gamebucks"];
    player.resource_state["facebook_credits"] = data["facebook_credits"];
    player.resource_state["protection_end_time"] = data["protection_end_time"];

    if(data["player_level"] !== player.resource_state["player_level"]) {
        player.resource_state["player_level"] = data["player_level"];
        player.claim_achievements(); // check for level-up achievements
    }

    if(init && update_resources_is_first_call) {
        update_resources_is_first_call = false;
    }
}

function update_resources_xp(data_xp) {
    if(data_xp != player.resource_state['xp']) {
        player.last_resource_state['xp'] = player.resource_state['xp'];
        player.last_xp_time = client_time;
    }
    player.resource_state["xp"] = data_xp;
}

function update_enemy_resources(data) {
    for(var res in gamedata['resources']) {
        enemy.resource_state[res] = data[res];
    }
    enemy.resource_state["player_level"] = data["player_level"];
    enemy.resource_state["protection_end_time"] = data["protection_end_time"];
}

// game units

player.virtual_units = {};

var MAX_UNIT_SPRITE_SIZE = 64; // max pixel dimensions of all unit sprites (for culling)
var FRAME_RATE_CAP = 60; // maximum screen update rate, in Hz
if(1) {
    var x = get_query_string('frame_rate_cap');
    if(x) { FRAME_RATE_CAP = parseInt(x,10); }
}
var USING_REQUESTANIMATIONFRAME = false;
var LAST_ANIM_FRAME_TIMEOUT = 0;

var COMBAT_ENGINE_USE_TICKS = false;

/** @const */
var TICK_INTERVAL = 0.25; // # of seconds between unit simulation ticks

// temporary bridge until entire combat engine is converted to ticks
/** @param {number} t
    @return {!GameTypes.TickCount} */
function absolute_time_to_tick(t) {
    var delta = t - client_time;
    return new GameTypes.TickCount(session.get_real_world().combat_engine.cur_tick.get() + Math.floor(delta/TICK_INTERVAL + 0.5));
};
/** @param {number} t
    @return {!GameTypes.TickCount} */
function relative_time_to_tick(t) {
    return new GameTypes.TickCount(Math.floor(t/TICK_INTERVAL + 0.5));
};

var player_combat_time_scale = 1.0; // additional time scaling applied by playfield speed bar controls
var player_playfield_speed = 0; // incremental version, used to drive player_combat_time_scale
function update_player_combat_time_scale(new_speed) { // note: caller's responsibility to check against limits.
    player_playfield_speed = new_speed | 0; // integer-ize
    if(!(player_playfield_speed.toFixed(0) in gamedata['client']['playfield_speeds'])) {
        // fix playfield invalid speed
        player_playfield_speed = 0;
    }
    player_combat_time_scale = gamedata['client']['playfield_speeds'][player_playfield_speed.toFixed(0)] || 1;
    //session.set_attack_finish_time(session.true_attack_finish_time);
};

/** @return {number} */
function combat_time_scale() {
    var sc = get_player_stat(player.stattab, 'combat_time_scale');
    return player_combat_time_scale * sc;
};

var last_combat_save = 0;
var last_high_priority_save = 0;
var last_power_repair_ping = 0;
var last_server_ping = 0;
var last_proxy_keepalive = 0;

// chat ping interval is obtained from gamedata
var last_chat_ping = 0;

// for spacing out rapid-fire loot CombatText notifications
var last_loot_text_time = 0;
var last_loot_text_count = 0;
var last_loot_text_pos = null;

// cause all defending units/turrets to recalculate their threatlists
// called when new attacking units are spawned
function invalidate_defender_threatlists() {
    session.for_each_real_object(function(obj) {
        if(!obj.is_destroyed() &&
           ((session.home_base && obj.team == 'player') || (!session.home_base && obj.team != 'player')) &&
           (obj.is_building() || obj.is_mobile())) {
            if(obj.ai_threatlist !== null) {
                obj.ai_threatlist_dirty = true;
            }
        }
    });
}

// cause all units to recalculate their threatlists
// called when map blockage changes, because
// the current system for setting threatlist depends on A*
// queries to determine accessibility
function invalidate_all_threatlists() {
    session.for_each_real_object(function(obj) {
        if(!obj.is_destroyed() &&
           (obj.is_building() || obj.is_mobile())) {
            if(obj.ai_threatlist !== null) {
                obj.ai_threatlist_dirty = true;
            }
        }
    });
}

// cause all mobile units to recalculate their movement paths
// called when map blockage changes
function invalidate_unit_paths() {
    session.for_each_real_object(function(obj) {
        if(obj.is_mobile()) {
            obj.path_valid = false;
        }
    });
}

/**
 * @constructor @struct
 * @extends GameObject
 */
function Mobile() {
    goog.base(this);
    this.squad_id = null;
    this.orders = [];
    this.patrol = null;
    /** @type {null|string} */
    this.pack_id = null;
    this.temporary = null;

    // client side reference only, the authoritive source is player.unit_repair_queue
    this.under_repair_finish = -1;

    /** @type {?Array.<number>} */
    this.ai_dest = null;
    this.ai_aggressive = false;
    /** @type {!GameTypes.TickCount} at which unit should resume leashing */
    this.ai_leash_after = new GameTypes.TickCount(0);
    this.is_leashing = false; // for debugging only

    // Movement of mobile units is handled by the client using a
    // StarCraft-style deterministic simulation. The server only
    // tracks movement to the coarseness of the map grid (like
    // buildings), which is recorded in this.x and this.y. Every few
    // seconds we send updates using OBJECT_COMBAT_UPDATES telling the
    // server roughly where the object is.

    /** @type {!Array.<number>} */
    this.pos = [-1,-1]; // position at end of last computed tick
    /** @type {!Array.<number>} */
    this.vel = [0,0];     // velocity at end of last computed tick, in pos units per second. Only used for lead-aiming computations.
    /** @type {!Array.<number>} */
    this.next_pos = [-1,-1]; // position at beginning of next tick

    /** @type {number} altitude above ground, if flying */
    this.default_altitude = 0;

    /** @type {?Array.<number>} */
    this.dest = [-1,-1]; // final movement destination

    /** @type {!Array.<!Array.<number>>} */
    this.path = []; // list of xy coords along A* path
    this.path_valid = false; // whether the A* path can be re-used
    this.path_new = false; // whether the A* path was just re-computed (for debugging only)
    this.stuck_loc = null; // state for tracking A* frustration

    // random vector for offsetting draw location
    if(gamedata['client']['unit_draw_scatter']) {
        // uniformly distributed point in unit circle
        var theta = 2*Math.PI*Math.random();
        var sqrt_r = Math.sqrt(Math.random());
        this.draw_offset = [sqrt_r*Math.cos(theta), sqrt_r*Math.sin(theta)];
    } else {
        this.draw_offset = null;
    }

    /** @type {boolean} for replays only - recorded result of is_invisible() during battle */
    this.replay_invisible = false;
}

goog.inherits(Mobile, GameObject);

/** @override */
Mobile.prototype.serialize = function() {
    var ret = goog.base(this, 'serialize');
    //ret['orders'] = deepcopy_array(this.orders);
    //ret['patrol'] = this.patrol; // might be needed for facing
    if(this.temporary) { ret['temporary'] = this.temporary; } // should be constant during a replay
    if(this.squad_id) { ret['squad_id'] = this.squad_id;} // should be constant during a replay
    //ret['ai_dest'] = (this.ai_dest ? deepcopy_array(this.ai_dest) : null);
    //ret['ai_aggressive'] = this.ai_aggressive;
    ret['pos'] = vec_serialize(this.pos);
    //ret['vel'] = this.vel; // computed by control prep
    ret['next_pos'] = vec_serialize(this.next_pos);
    //ret['dest'] = (this.dest ? deepcopy_array(this.dest) : null); // only needed for pathing
    //ret['path_valid'] = this.path_valid; // only needed for pathing
    //ret['path'] = deepcopy_array(this.path); // only needed for pathing
    //ret['stuck_loc'] = (this.stuck_loc ? deepcopy_array(this.stuck_loc) : null); // only needed for pathing
    ret['is_invisible'] = (this.is_invisible() ? 1 : 0);
    return ret;
};
/** @override */
Mobile.prototype.apply_snapshot = function(snap) {
    goog.base(this, 'apply_snapshot', snap);
    //if('orders' in snap) { this.orders = snap['orders']; }
    //if('patrol' in snap) { this.patrol = snap['patrol']; }
    if('temporary' in snap) { this.temporary = snap['temporary']; }
    if('squad_id' in snap) { this.squad_id = snap['squad_id']; }
    //if('ai_dest' in snap) { this.ai_dest = snap['ai_dest']; }
    //if('ai_aggressive' in snap) { this.ai_aggressive = snap['ai_aggressive']; }
    if('pos' in snap) { this.pos = snap['pos']; }
    //if('vel' in snap) { this.vel = snap['vel']; }
    if('next_pos' in snap) { this.next_pos = snap['next_pos']; }
    //if('dest' in snap) { this.dest = snap['dest']; } // XXX only needed for facing I think
    //if('path_valid' in snap) { this.path_valid = snap['path_valid']; } // XXX only needed for facing I think
    //if('path' in snap) { this.path = snap['path']; } // XXX only needed for facing I think
    //if('stuck_loc' in snap) { this.stuck_loc = snap['stuck_loc']; }
    if('is_invisible' in snap) { this.replay_invisible = !!snap['is_invisible']; }
};

/** @override */
Mobile.prototype.on_added_to_world = function(world) {
    goog.base(this, 'on_added_to_world', world);
    this.default_altitude = (this.get_leveled_quantity(this.spec['altitude'] || 0));
    if(this.default_altitude != 0 && world.base.base_climate_data['fly_at_ground_level']) {
        // set altitudes low, but not to zero, so it doesn't screw up anti-air/anti-ground weapon behavior
        this.default_altitude = 1.0;
    }
};

/** @override */
Mobile.prototype.on_removed_from_world = function(world) {
    goog.base(this, 'on_removed_from_world', world);

    if(world === session.get_real_world() && session.home_base /*&& session.attack_finish_time > server_time*/ && this.team == 'enemy' && this.id !== GameObject.DEAD_ID) { // XXX move into Session
        session.incoming_attack_units_destroyed += 1;
    }
};

Mobile.prototype.is_temporary = function() { return !!this.temporary; };
Mobile.prototype.is_flying = function() { return this.combat_stats.flying || false; };
Mobile.prototype.is_flying_default = function() { return this.spec['flying'] || false; };
Mobile.prototype.passes_through_walls = function() { return this.spec['flying'] || this.spec['noclip']; };
Mobile.prototype.is_under_repair = function() { return this.under_repair_finish > 0; };

// return true if the object should be invisible to opponents
Mobile.prototype.is_invisible_default = function() {
    // mobile units only go invisible when:
    // 1) invis_on_hold: 1 in unit spec
    // 2) unit is in hold position mode
    // 3) unit is within a base owned by the unit's owner (i.e. it's playing defense, not offense)
    // 4) unit is NOT in a quarry or naked squad
    if(this.spec['invis_on_hold'] && this.orders && this.orders.length == 1 &&
       !this.orders[0]['aggressive'] &&
       this.orders[0]['state'] == ai_states.AI_ATTACK_STATIONARY) {
        // check if in friendly base
        if((this.team === 'player' && session.viewing_user_id === session.user_id) ||
           (this.team === 'enemy' && session.viewing_user_id !== session.user_id)) {
            if(!session.is_quarry() && !session.is_squad()) {
                return true;
            }
        }
    }
    return false;
};

// return true if the object should be invisible to opponents
Mobile.prototype.is_invisible = function() {

    // override dynamic value with recorded value, since orders and AI state are not recorded
    if(session.is_replay()) { return this.replay_invisible; }

    return (!!this.combat_stats.invisible && !this.combat_stats.detected);
};

function get_player_stat(stattab, stat) { return ModChain.get_stat(stattab['player'][stat], null); }

function get_unit_stat(stattab, specname, stat, default_value) {
    if(specname in stattab['units']) {
        return ModChain.get_stat(stattab['units'][specname][stat]||null, default_value);
    }
    return default_value;
}

// this version of get_auto_spell disregards modstats - this is only
// to be used when getting stats for a new building you have not built
// yet, or a unit you have not unlocked.
function get_auto_spell_raw(spec) {
    var ret = null;
    if(('spells' in spec) && (spec['spells'].length > 0)) {
        var spellname = spec['spells'][0];
        if(spellname) {
            var auto_spell = gamedata['spells'][spellname];
            if(auto_spell['activation'] === 'auto') {
                ret = auto_spell;
            }
        }
    } else if ('equip' in spec && 'effects' in spec['equip']) {
        var effects = spec['equip']['effects'];
        var mod_spellname = '';
        goog.array.forEach(effects, function(effect) {
            if('code' in effect && effect['code'] === 'modstat' && 'stat' in effect && effect['stat'] === 'weapon' && 'strength' in effect) {
                mod_spellname = effect['strength'];
            };
        });
        var mod_auto_spell = gamedata['spells'][mod_spellname];
        if(mod_auto_spell['activation'] === 'auto') {
            ret = mod_auto_spell;
        }
    }
    return ret;
}

// includes player or enemy modstats
function get_auto_spell_for_unit(player_or_enemy, unit_spec) {
    if(('spells' in unit_spec) && (unit_spec['spells'].length > 0)) {
        var spellname = get_unit_stat(player_or_enemy.stattab, unit_spec['name'], 'weapon', unit_spec['spells'][0]);
        if(spellname) {
            var auto_spell = gamedata['spells'][spellname];
            if(auto_spell['activation'] === 'auto') {
                return auto_spell;
            }
        }
    }
    return null;
}
function get_auto_spell_level_for_unit(player_or_enemy, unit_spec, unit_level) {
    return get_unit_stat(player_or_enemy.stattab, unit_spec['name'], 'weapon_level', unit_level);
}

/** @override */
Mobile.prototype.get_auto_spell = function() {
    var owner = (this.team === 'player' ? player : enemy);
    return get_auto_spell_for_unit(owner, this.spec);
};
/** @override */
Mobile.prototype.get_auto_spell_level = function() {
    var owner = (this.team === 'player' ? player : enemy);
    return get_auto_spell_level_for_unit(owner, this.spec, this.level);
};

function get_auto_spell_for_item(item_spec) {
    var spellname = ItemDisplay.get_inventory_item_weapon_spellname(item_spec);
    if(spellname) {
        return gamedata['spells'][spellname];
    }
    return null;
}

/** @enum {number} Matches GameObjectSpec.COST_MODE_* on server */
var COST_MODE = {
    REPAIR : 0,
    RECYCLE : 1,
    MANUFACTURE_CANCEL : 2,
    MANUFACTURE : 3
};

/** @param {!Object<string,?>} spec
    @param {number} level
    @param {number} cur_hp
    @param {number} max_hp
    @param {!Object} player
    @param {number=} cost_mode
    @param {GameObject|null=} builder
    @param {boolean=} allow_fractions */
function mobile_cost_to_repair(spec, level, cur_hp, max_hp, player, cost_mode, builder, allow_fractions) {
    if(!cost_mode) { cost_mode = COST_MODE.REPAIR; }
    var cost_ratio, time_ratio, spd;
    if(cost_mode === COST_MODE.MANUFACTURE_CANCEL) { // note: legacy only - now queue entries store their own cost
        cost_ratio = gamedata['manufacture_cancel_refund'];
        time_ratio = spd = 1;
    } else if(cost_mode === COST_MODE.RECYCLE) {
        cost_ratio = player.get_any_abtest_value('unit_recycle_resources', gamedata['unit_recycle_resources'])
        // note: do not bonus this, to avoid exploits where you increase the unit's cost after it's built, then recycle it
        time_ratio = spd = 1;
    } else if(cost_mode === COST_MODE.REPAIR && (get_leveled_quantity(spec['resurrectable'] || false, level) || cur_hp > 0)) {
        cost_ratio = ('unit_repair_resources' in spec ? spec['unit_repair_resources'] : player.get_any_abtest_value('unit_repair_resources', gamedata['unit_repair_resources']));
        time_ratio = ('unit_repair_time' in spec ? spec['unit_repair_time'] : player.get_any_abtest_value('unit_repair_time', gamedata['unit_repair_time']));
        // XXX grab it from the building instead?
        cost_ratio *= get_unit_stat(player.stattab, spec['name'], 'repair_cost', 1);
        spd = get_unit_stat(player.stattab, spec['name'], 'repair_speed', 1);
    } else {
        // treat destroyed, non-resurrectable units the same as manufacturing from scratch
        cost_ratio = 1;
        time_ratio = 1;
        // XXX grab it from the building instead?
        cost_ratio *= get_unit_stat(player.stattab, spec['name'], 'manufacture_cost', 1);
        spd = get_unit_stat(player.stattab, spec['name'], 'manufacture_speed', 1);
    }

    var health_ratio = 1.0 - 1.0*cur_hp/max_hp;
    var cost_time = get_leveled_quantity(spec['build_time'], level);
    var raw_rep_time = time_ratio * health_ratio * cost_time / spd;
    var rep_time = (allow_fractions ? Math.max(0, raw_rep_time) : Math.max(1, Math.floor(raw_rep_time)));
    var ret = {'time':rep_time};

    for(var res in gamedata['resources']) {
        var raw_amount = cost_ratio * health_ratio * get_leveled_quantity(spec['build_cost_'+res] || 0, level);
        ret[res] = Math.max(0, (allow_fractions ? raw_amount : Math.floor(raw_amount)));
    }

    return ret;
}

Mobile.prototype.cost_to_repair = function(player) { return mobile_cost_to_repair(this.spec, this.level, this.hp, this.max_hp, player); };

Mobile.prototype.modify_stats_by_modstats = function() {
    var tbl = null;
    if(this.team === 'player') {
        tbl = (player.stattab['units']||{})[this.spec['name']];
    } else {
        tbl = (enemy.stattab['units']||{})[this.spec['name']];
    }
    if(tbl) { this.modify_stats_by_modstats_table(tbl); }
};

/** Check if the given "orders" are valid
    @param {?} orders
    @return {boolean} */
Mobile.orders_are_valid = function(orders) {
    if(!(orders instanceof Array)) { return false; }
    for(var i = 0; i < orders.length; i++) {
        var ord = orders[i];
        if(typeof ord !== 'object') { return false; }
    }
    return true;
};

/** @override */
Mobile.prototype.receive_state = function(data, init, is_deploying) {
    var old_x = this.x, old_y = this.y;
    goog.base(this, 'receive_state', data, init, is_deploying);
    this.squad_id = data.shift();
    var orders = data.shift();
    var patrol = data.shift();
    this.pack_id = data.shift();
    this.temporary = data.shift();

    if(patrol !== null) { this.patrol = !!patrol; }

    if(init || old_x != this.x || old_y != this.y) {
        // apply position update

        this.pos = [this.x, this.y];
        var ncells = session.viewing_base.ncells();
        if(this.pos[0] < 0 || this.pos[0] >= ncells[0] || this.pos[1] < 0 || this.pos[1] >= ncells[1]) {
            console.log('received state for out-of-bounds unit! '+this.pos[0]+' '+this.pos[1]);
            this.pos[0] = clamp(this.pos[0], 0, ncells[0]-1);
            this.pos[1] = clamp(this.pos[1], 0, ncells[1]-1);
        }

        this.next_pos = [this.pos[0], this.pos[1]];
        this.dest = [this.pos[0], this.pos[1]];
    }

    if(init) {
        // on object creation, apply (valid) persistent orders to AI state
        // however, do not accept AI_STOP as it is almost certainly not what the player wants
        // also, do not apply orders to player's units when being deployed in an attack
        if(orders && Mobile.orders_are_valid(orders) && orders[0]['state'] != ai_states.AI_STOP &&
           (this.team != 'player' || !is_deploying || session.home_base)) {
            this.orders = orders;
        } else {
            // no effect, use default AI state
            var order = {'state': this.ai_state};
            if(this.ai_state === ai_states.AI_ATTACK_ANY && is_deploying) {
                order['dest'] = null; // do not set "home" location
            } else {
                order['dest'] = [Math.floor(this.pos[0]),Math.floor(this.pos[1])];
            }

            this.orders = [order];

            // enable aggressive mode for invading units (except for player-owned units in manual mode)
            if(
                ((session.viewing_base.base_landlord_id !== session.user_id) && (this.team == 'player') &&
                 (get_preference_setting(player.preferences, 'auto_unit_control') ||
                  (('deploy_ai_order' in this.spec) && this.spec['deploy_ai_order']['aggressive']) ||
                  gamedata['client']['default_deploy_ai_order']['manual']['aggressive']
                 )) ||

                ((session.viewing_base.base_landlord_id === session.user_id) && (this.team != 'player'))) {
                this.ai_aggressive = true;
                // attacking units should never leash
                this.ai_leash_after = GameTypes.TickCount.infinity;
            }

            // propagate orders to server
            this.state_dirty |= obj_state_flags.ORDERS;
        }
        this.apply_orders(null);
    }

    // snoop update into my_army
    if(this.id in player.my_army) {
        var obj = player.my_army[this.id];
        obj['hp_ratio'] = this.hp/this.max_hp;
        obj['level'] = this.level;
    }
};

/** @param {World.World|null} world - only null on initial creation */
Mobile.prototype.apply_orders = function(world) {
    if(typeof this.pos === 'undefined') {
        throw Error('apply_orders on '+this.spec['name']+' with this.pos undefined');
    }

    if(this.orders.length > 0) {
        var ord = this.orders[0];
        this.ai_state = ord['state'];
        this.ai_target = null;
        if('target' in ord && world) {
            var target_object = world.objects._get_object(ord['target']);
            this.ai_target = target_object;
            if(target_object) {
                target_object.next_ai_attackers_list.push(this.id);
            }
        }
        if('dest' in ord) {
            if(ord['dest'] === null) {
                this.ai_dest = null;
            } else {
                this.ai_dest = [Math.floor(ord['dest'][0]), Math.floor(ord['dest'][1])];
            }
        } else {
            this.ai_dest = [Math.floor(this.pos[0]), Math.floor(this.pos[1])];
        }
        if('aggressive' in ord) {
            this.ai_aggressive = ord['aggressive'];
        }
        // note: if 'aggressive' not in ord, then do NOT change current state
        this.path_valid = false;
        this.serialization_dirty = true;
    }
};

/** @param {!World.World} world
    @param {!Object} neword
    @param {boolean} replace */
Mobile.prototype.new_order = function(world, neword, replace) {
    if(replace || this.orders.length == 0 ||
       !ai_state_can_be_queued(this.orders[0]['state'])) {
        this.orders = [neword];

        // turn off patrolling
        this.patrol = null;
        this.state_dirty |= obj_state_flags.PATROL;

        this.apply_orders(world);
    } else {
        // limit max # of orders
        if(this.orders.length >= gamedata['client']['max_unit_orders']) { return; }

        // when patrolling, insert the new waypoint BEFORE the patrol_origin order
        if(this.patrol && this.orders.length >= 2) {
            var origin = -1;
            for(var i = 0; i < this.orders.length; i++) { if(this.orders[i]['patrol_origin']) { origin = i; break; } }
            if(origin < 0) { origin = this.orders.length-1; }
            this.orders.splice(origin, 0, neword);
        } else {
            this.orders.push(neword);
        }
    }
    this.state_dirty |= obj_state_flags.ORDERS;
};

/** @return {boolean} whether the object can currently accept player input */
GameObject.prototype.can_accept_commands = function() {
    // do not allow control of "force_team": "attacker" units prior to battle start
    if(session.viewing_base.base_landlord_id != session.user_id &&
       !session.has_attacked &&
       this.team === 'player') {
        return false;
    }
    return true;
};

/** quantized location as of last combat tick
    @override */
Mobile.prototype.raw_pos = function() { return this.pos; };

/** @override */
Mobile.prototype.interpolate_pos = function(world) {
    var progress = clamp((visit_base_pending ? 1 : (client_time - world.last_tick_time)/(TICK_INTERVAL/combat_time_scale())), 0, 1);
    return vec_add(this.pos, vec_scale(progress, vec_sub(this.next_pos, this.pos)));
};

/** @override interpolated location, with added offset for un-dogpiling units */
Mobile.prototype.interpolate_pos_for_draw = function(world) {
    var pos = this.interpolate_pos(world);
    if(gamedata['client']['unit_draw_scatter'] && this.draw_offset) {
        return vec_mad(pos, gamedata['client']['unit_draw_scatter'], this.draw_offset);
    }
    return pos;
};

/** @override */
Mobile.prototype.detect_click = function(world, xy, ji, zoom, fuzz) {
    // mobile units use the sprite hit detection code
    var asset = GameArt.assets[this.get_leveled_quantity(this.spec['art_asset'])];
    var pos = this.interpolate_pos(world);
    if(asset.detect_click(ortho_to_screen_3d([pos[0], this.combat_stats.altitude, pos[1]]), this.interpolate_facing(world), client_time, 'normal', xy, zoom, fuzz)) {
        return true;
    }
    return false;
}

/** @override */
Mobile.prototype.run_ai = function(world) {
    if(this.is_destroyed()) {
        this.ai_stop();
        return;
    }

    if(this.ai_state === ai_states.AI_ATTACK_STATIONARY) {
        this.ai_stop();
    }

    // run this before the base class run_ai() because we may switch to AI_ATTACK_ANY
    if(this.ai_state === ai_states.AI_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO || this.ai_state === ai_states.AI_DEFEND_MOVE ||
       (this.ai_state === ai_states.AI_ATTACK_ANY && !this.ai_target)) {
        if(this.ai_dest && vec_equals(this.raw_pos(), this.ai_dest)) {
            // arrived at destination
            this.ai_stop();

            if(this.ai_state === ai_states.AI_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO || this.ai_state === ai_states.AI_DEFEND_MOVE) {
                this.next_ai_order(world);
            }
        } else {
            this.ai_move_towards(this.ai_dest, null, 'run_ai/ai_dest');
        }
    }

    goog.base(this, 'run_ai', world);

    // Anti-clumping

    // If the unit doesn't have anything important to do, then try to have it spread away from other close units.
    // We use a "gas diffusion" approach: treat the density of units as a scalar "pressure" and try to move the
    // unit along the gradient towards lower pressure.
    var declump_radius = player.get_any_abtest_value('unit_declump_radius', gamedata['client']['unit_declump_radius']);
    //console.log('declump? '+this.spec['name'] +' '+declump_radius.toString()+' pos '+this.raw_pos()[0].toString()+','+this.raw_pos()[1].toString()+' dest '+this.ai_dest[0].toString()+','+this.ai_dest[1].toString()+' ai_state '+ai_state_names[this.ai_state]+' ai_target '+(this.ai_target? this.ai_target.spec['name'] : 'none')+' control_state '+control_state_names[this.control_state]);

    if((declump_radius > 0) &&
       (world.tick_astar_queries_left !== 0 || !gamedata['client']['unit_declump_avoid_astar']) &&
       (this.ai_state === ai_states.AI_ATTACK_ANY || this.ai_state === ai_states.AI_ATTACK_STATIONARY || this.ai_state === ai_states.AI_ATTACK_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO || this.ai_state === ai_states.AI_DEFEND_MOVE) &&
       (this.control_state === control_states.CONTROL_STOP || player.get_any_abtest_value('unit_declump_urgently',gamedata['client']['unit_declump_urgently']))) {
        // consider units this far away in pressure gradient calculation
        var gradient = [0,0]; // pressure gradient
        var pos = this.raw_pos(); // get our position

        // Compute contribution to pressure gradient of each nearby unit

        // This is an O(N^2) algorithm, but it works OK as long as the average number of units per grid
        // cell is low (in this game it's typically < 1). If there are lots of units per grid cell, then
        // it would be better to use a particle-cell model and accumulate unit density in a grid
        // data structure.

        var objlist = session.get_real_world().query_objects_within_distance(pos, declump_radius,
                                                    { ignore_object: this,
                                                      // should this also look at inerts? not sure...
                                                      // but, collidable inerts generally have a big extent, so I'm not sure
                                                      // what the point would be of including them. Also, performance is likely to suffer.
                                                      //include_collidable_inerts: true,
                                                      exclude_flying: !this.is_flying(),
                                                      flying_only: this.is_flying()
                                                    });

        for(var n = 0; n < objlist.length; n++) {
            if(objlist[n].obj === this) { continue; }
            var dist = objlist[n].dist;
            var loc = objlist[n].pos;
            var direction;
            if(dist < POSITION_EPSILON) {
                direction = vec_normalized([-1+2*Math.random(), -1+2*Math.random()]);
            } else {
                direction = vec_normalized(vec_sub(loc, pos));
            }
            var weight = Math.exp(-dist);
            gradient[0] += weight * direction[0];
            gradient[1] += weight * direction[1];
        }

        // If a nonzero gradient is detected, then get the unit moving
        if(gradient[0] != 0 || gradient[1] != 0) {
            gradient = vec_normalized(gradient);
            this.control_state = control_states.CONTROL_MOVING;
            this.control_target_id = null;
            var target_pos = [pos[0], pos[1]];

            // arbitrarily move 1 unit along the gradient towards lower pressure
            var mdist = 1;
            target_pos[0] += mdist * -gradient[0];
            target_pos[1] += mdist * -gradient[1];

            // clamp against map boundaries
            var ncells = session.viewing_base.ncells();
            target_pos[0] = clamp(target_pos[0], 0, ncells[0]-1);
            target_pos[1] = clamp(target_pos[1], 0, ncells[1]-1);

            // avoid sending the unit into blocked areas
            if(!this.passes_through_walls()) {
                while((target_pos[0] > 0) && (target_pos[1] > 0) &&
                      (target_pos[0] < ncells[0]-1) && (target_pos[1] < ncells[1]-1) &&
                      (world.astar_map.is_blocked(vec_floor(target_pos)))) {
                    target_pos[0] += mdist * -gradient[0];
                    target_pos[1] += mdist * -gradient[1];
                }
                target_pos[0] = clamp(target_pos[0], 0, ncells[0]-1);
                target_pos[1] = clamp(target_pos[1], 0, ncells[1]-1);
            }

            if(!this.dest || !vec_equals(this.dest, target_pos)) {
                if(!this.dest || !vec_equals_integer(this.dest, target_pos)) {
                    this.path_valid = false;
                }
                this.dest = target_pos;
                // XXX hack - reset ai_dest to avoid looping during leash behavior
                if(this.ai_state === ai_states.AI_ATTACK_ANY && this.ai_dest) {
                    this.ai_dest = this.dest;
                }
            }
        }
    }
};

/** @override */
Mobile.prototype.run_control_prep = function() {
    goog.base(this, 'run_control_prep');

    // update pos
    if(!vec_equals(this.pos, this.next_pos)) {
        this.vel = vec_scale(1/TICK_INTERVAL, vec_sub(this.next_pos, this.pos));

        this.pos = this.next_pos;
        // eventually persist the new location to the server
        this.state_dirty |= obj_state_flags.XY;
    } else {
        this.vel = [0,0];
    }
};

/** Based on pos and dest, set next_pos and vel
    @override */
Mobile.prototype.run_control_pathing = function(world) {
    goog.base(this, 'run_control_pathing', world);

    if(this.is_destroyed()) {
        // we're dead, Jim.
        return;
    }

    if(this.combat_stats.stunned) { this.control_state = control_states.CONTROL_STOP; }

    if(this.control_state === control_states.CONTROL_STOP ||
       this.control_state === control_states.CONTROL_SHOOT) {
        // stop at end of this tick's motion
        if(!vec_equals(this.next_pos, this.pos)) {
            this.serialization_dirty = true;
            this.next_pos = this.pos;
        }

    } else if(this.control_state === control_states.CONTROL_MOVING) {
        this.serialization_dirty = true;
        var maxvel = this.current_maxvel();
        if(this.dest === null) { throw Error('dest must be non-null here '+this.spec['name']+' '+this.id); }

        if(PLAYFIELD_DEBUG >= 2 && this === last_created_object) {
            console.log(this.spec['name']+' CONTROL_MOVING pos '+this.pos[0].toString()+','+this.pos[1].toString()+' dest '+this.dest[0].toString()+','+this.dest[1].toString()+' path_valid '+this.path_valid.toString());
        }

        // vector to destination
        var to_dest = vec_sub(this.dest, this.pos);

        // distance to destination
        var dist = vec_length(to_dest);

        if(dist < POSITION_EPSILON) {
            // arrived at destination
            this.pos = this.dest;
            this.next_pos = this.dest;
            this.path = [];
            this.path_valid = false;
            // leave rover.facing alone
            this.control_state = control_states.CONTROL_STOP;

        } else {
            // follow A* path
            var path_next; // coordinates of next cell in movement path

            /* placate Closure compiler */ path_next = this.pos;

            // compute A* path
            var ncells = session.viewing_base.ncells();
            var cur_cell = [clamp(Math.floor(this.pos[0]),0,ncells[0]-1),
                            clamp(Math.floor(this.pos[1]),0,ncells[1]-1)];
            var dest_cell = [clamp(Math.floor(this.dest[0]),0,ncells[0]-1),
                             clamp(Math.floor(this.dest[1]),0,ncells[1]-1)];
            world.playfield_check_pos(dest_cell, 'dest_cell');
            if((cur_cell[0] == dest_cell[0]) && (cur_cell[1] == dest_cell[1])) {
                // rover is same cell as final destination, no need to compute path
                if(!this.dest) { throw Error('this.dest is null'); }
                path_next = this.dest;
                world.playfield_check_path([this.pos,path_next], 'copy_from_this.dest');
            } else {
                // update the A* path
                if(!this.path_valid) {
                    // first see if a direct route is open
                    if(this.passes_through_walls() || world.astar_map.linear_path_is_clear(cur_cell, dest_cell)) {
                        // if so, construct a direct route, and skip the call to A*
                        if(PLAYFIELD_DEBUG >= 2 && this === last_created_object) {
                            console.log(this.spec['name']+' taking direct route');
                        }
                        this.path = [cur_cell, dest_cell];
                        this.path_valid = true; this.path_new = true;
                        if(!this.passes_through_walls()) {
                            world.playfield_check_path(this.path, 'direct_skip_A*');
                        }
                    } else {
                        if(world.tick_astar_queries_left === 0) {
                            // do nothing until the client has CPU to run A*
                            if(PLAYFIELD_DEBUG >= 2 && this === last_created_object) {
                                console.log(this.spec['name']+' starved for A* time');
                            }
                            path_next = this.pos;
                            world.playfield_check_path([this.pos,path_next], 'A*_starved');
                        } else {
                            // run the slow A* search
                            world.tick_astar_queries_left -= 1;
                            this.path = world.astar_context.search(cur_cell, dest_cell);
                            world.playfield_check_path(this.path, 'A*');
                            world.astar_map.smooth_path(this.path);
                            world.playfield_check_path(this.path, 'A*_smoothed');
                            this.path_valid = true;
                            this.path_new = true;
                            if(PLAYFIELD_DEBUG >= 2 && this === last_created_object) {
                                var p = '';
                                goog.array.forEach(this.path, function(loc) { p += ' '+loc[0].toString()+','+loc[1].toString(); });
                                console.log(this.spec['name']+' A* result:'+p);
                            }
                        }
                    }
                }
                if(this.path.length == 0) {
                    // path is blocked
                    path_next = this.pos;
                    world.playfield_check_path([this.pos,path_next], 'path is blocked');

                    // check against blockage ON TOP OF unit
                    if(world.astar_map.is_blocked(cur_cell)) {
                        // unit is trapped inside of a blocked area
                        // construct a fake path that allows it to pass out
                        var temp = [cur_cell[0]+2, cur_cell[1]+2];
                        while(temp[0] < ncells[0]-1 && temp[1] < ncells[1]-1) {
                            if(!world.astar_map.is_blocked(temp)) {
                                this.path = [temp];
                                path_next = [this.path[0][0]+0.5, this.path[0][1]+0.5];
                                this.path_valid = true; this.path_new = true;
                                break;
                            }
                            temp[0] += 1;
                            temp[1] += 1;
                        }
                        if(PLAYFIELD_DEBUG) {
                            console.log(this.spec['name']+' trapped, moving out of '+cur_cell[0].toString()+','+cur_cell[1].toString());
                        }
                    }

                } else {

                    // follow movement path
                    if(PLAYFIELD_DEBUG >= 2 && this === last_created_object) {
                        var p = '';
                        goog.array.forEach(this.path, function(loc) { p += ' '+loc[0].toString()+','+loc[1].toString(); });
                        console.log(this.spec['name']+' following path'+p);
                    }
                    while(this.path.length >= 1) {
                        path_next = vec_add(this.path[0], [0.5, 0.5]);
                        var next_cell = vec_floor(path_next);
                        if(cur_cell[0] != next_cell[0] || cur_cell[1] != next_cell[1]) {
                            // we have to cross at least one more cell
                            break;
                        } else {
                            // we have reached the cell containing the next waypoint
                            if(vec_distance(this.pos, path_next) < 0.001) {
                                // we're right at the waypoint, move on to the next one
                                this.path.shift();
                            } else {
                                // we have not quite reached the next waypoint yet, but see if we can "cut the corner"
                                if(this.path.length > 1) {
                                    // not the final waypoint - cut the corner, but only if we can make it
                                    // to the next waypoint without entering a blocked area
                                    if(this.passes_through_walls() || world.astar_map.linear_path_is_clear(this.pos, this.path[1])) {
                                        this.path.shift(); // cut off the corner
                                    } else {
                                        break; // cannot cut the corner
                                    }
                                } else {
                                    // final waypoint - just stop after this tick
                                    this.path.shift();
                                    break;
                                }
                            }
                        }
                    }

                    /* OLD code - broken because it can "cut corners" into blocked cells
                    // delete head of path until next path point is at least (maxvel*TICK_INTERVAL) units away
                    // also delete nodes closer than ~1.5 units to avoid stair-stepping (since smooth_path does not
                    // know about continuous coordinates, it will still leave stair-steps at the beginning of the path)

                    while(this.path.length > 0) {
                        path_next = [this.path[0][0]+0.5, this.path[0][1]+0.5];
                        var path_next_dist = vec_length(vec_sub(path_next,this.pos));
                        if(path_next_dist >= Math.max(1.5,(maxvel*TICK_INTERVAL))) {
                            break;
                        }
                        if(this.path.length <= 1) { break; }
                        this.path.shift(); // remove head
                    }
                    */
                }
            }

            // recompute dist and to_dest based on A* path
            to_dest = vec_sub(path_next, this.pos);
            dist = vec_length(to_dest);

            // how far the rover will go in this tick
            var move_dist;
            if(dist < maxvel*TICK_INTERVAL) {
                move_dist = dist;
            } else {
                move_dist = maxvel*TICK_INTERVAL;
            }

            if(dist > 0.001) {
                // unit-vector direction to destination
                var dir = vec_scale(1/dist, to_dest);
                this.target_facing = normalize_angle(Math.atan2(dir[1], dir[0]));

                var can_move = true;

                if(this.spec['turn_before_move'] > 0) {
                    // convert max angle difference to radians
                    var max_arc = Math.min(this.get_leveled_quantity(this.spec['turn_before_move'])*(Math.PI/180.0), Math.PI);

                    // to avoid complex modulo math, do the computations with 2D vectors
                    var cur = [Math.cos(this.cur_facing), Math.sin(this.cur_facing)];
                    var tgt = [Math.cos(this.target_facing), Math.sin(this.target_facing)];

                    // dot product between current and target headings
                    var dot = cur[0]*tgt[0] + cur[1]*tgt[1];
                    dot = Math.min(dot, 1); // avoid acos NaNs with rounding errors

                    if(Math.acos(dot) > max_arc) {
                        // not facing close enough to the right direction yet, wait before moving
                        can_move = false;
                    }
                }

                if(can_move) {
                    this.next_pos = vec_add(this.pos, vec_scale(move_dist, dir));
                    world.playfield_check_path([this.pos, path_next], 'CONTROL_MOVING (normal, path_next)');
                    world.playfield_check_path([this.pos, this.next_pos], 'CONTROL_MOVING (normal, next_pos)');
                    this.next_pos[0] = clamp(this.next_pos[0], 0, ncells[0]-1);
                    this.next_pos[1] = clamp(this.next_pos[1], 0, ncells[1]-1);
                } else {
                    this.next_pos = this.pos;
                }

//                this.stuck_loc = null;
            } else {
                //  rover wants to move, but path is blocked
                this.next_pos = this.pos;
                // leave rover.facing alone

                // give it one chance to un-stick, in case there is a valid path beyond the iter limit
                if(gamedata['client']['astar_unstick_radius'] >= 0 &&
                   (!this.stuck_loc || vec_distance(this.pos, this.stuck_loc) >= gamedata['client']['astar_unstick_radius'])) {
                    if(PLAYFIELD_DEBUG && this === last_created_object) {
                        console.log("UNSTICKING "+this.spec['name']+' at '+this.pos[0].toString()+','+this.pos[1].toString());
                    }
                    this.stuck_loc = vec_copy(this.pos);
                    this.path_valid = false; // recalc path on next tick
                }
            }

            if(PLAYFIELD_DEBUG >= 2 && this === last_created_object) { console.log(this.spec['name']+' pos '+this.pos[0].toString()+','+this.pos[1].toString()+' path_next '+path_next[0].toString()+','+path_next[1].toString()+' dist '+dist.toString()+' move_dist '+move_dist.toString()+' next_pos '+this.next_pos[0].toString()+','+this.next_pos[1].toString()); }

        }

    } // END control_moving

    if(typeof(this.pos) == 'undefined') {
        throw Error(this.spec['name']+' exited run_control_pathing (' + control_state_names[this.control_state] + ') with undefined this.pos');
    }
};

/** @param {!SPFX.FXWorld} fxworld */
Mobile.prototype.add_movement_effect = function(fxworld) {
    if(!this.is_destroyed() && this.control_state === control_states.CONTROL_MOVING &&
       ('movement_effect' in this.spec)) {
        fxworld.add_visual_effect_at_time(this.pos, this.combat_stats.altitude, [0,1,0], client_time, this.spec['movement_effect'], true, null);
    }
};

var last_created_object = null; // for debugging messages

/** instantiate game object from server message
    @param {!Object} data
    @param {boolean} is_deploying */
function create_object(data, is_deploying) {
    // peek inside state message to determine object type
    var specname = data[1];
    var spec = get_spec(specname);
    if(!spec) {
        throw Error('cannot create object of unrecognized type '+specname);
    }

    var kind = spec['kind'];
    var obj;
    if(kind === 'building') {
        obj = new Building();
    } else if(kind === 'mobile') {
        obj = new Mobile();
    } else if(kind === 'inert') {
        obj = new Inert();
    } else {
        throw Error('bad spec kind '+kind);
    }

    obj.receive_state(data, true, is_deploying);

    // spread units on attack deployment
    // the server only stores positions with the granularity of one map cell.
    // for mobile units, scatter them randomly within the cell so they aren't
    // all on top of each other
    if(!session.home_base && obj.team === 'player' && obj.is_mobile()) {
        var radius = player.get_any_abtest_value('unit_deploy_spread', gamedata['unit_deploy_spread']);
        var ncells = session.viewing_base.ncells();
        obj.pos = [clamp(obj.pos[0]+radius*(Math.random()-0.5), 0, ncells[0]-1),
                   clamp(obj.pos[1]+radius*(Math.random()-0.5), 0, ncells[1]-1)];
        obj.next_pos = vec_copy(obj.pos);
        obj.dest = vec_copy(obj.pos);
        if(obj.ai_dest) { obj.ai_dest = vec_copy(obj.pos); }
        if(obj.orders.length == 1 && obj.orders[0]['dest']) { // only if not null or missing
            obj.orders[0]['dest'] = vec_copy(obj.pos);
        }
        if(!obj.is_destroyed() && player.unit_micro_enabled()) {
            add_unit_to_selection(obj);
        }
    }

    last_created_object = obj;
    return obj;
};

/** pack up what we know about the object that got a killing blow on another object
    @param {GameObject|null} killer */
function get_killer_info(killer) {
    if(killer && killer.id !== GameObject.VIRTUAL_ID) {
        // note: killer.id = 'VIRTUAL' for the virtual "player" unit, i.e. tactical missiles and such
        var ret = {'team': killer.team,
                   'spec': killer.spec['name'],
                   'level': killer.level,
                   'id': killer.id};
        if(killer.is_building()) {
            if(killer.is_minefield() && killer.is_minefield_armed()) {
                ret['mine'] = killer.minefield_item();
            } else if(killer.is_ambush() && killer.is_ambush_armed()) {
                ret['ambush'] = killer.ambush_item();
            } else if(killer.is_emplacement() && killer.turret_head_item()) {
                ret['turret_head'] = killer.turret_head_item()['spec'];
            } else if(killer.is_trapped_barrier() && killer.barrier_trap_item()) {
                ret['barrier_trap'] = killer.barrier_trap_item()['spec'];
            } else if(killer.is_armed_building() && killer.building_weapon_item()) {
                ret['building_weapon'] = killer.building_weapon_item()['spec'];
            } else if(killer.is_armed_townhall() && killer.townhall_weapon_item()) {
                ret['townhall_weapon'] = killer.townhall_weapon_item()['spec'];
            }
        }
        return ret;
    }
    return null;
}

//
// engine code
//

// URL to game server GAMEAPI, preferring direct connection if possible
function gameapi_url() {
    if(spin_game_use_websocket && (parseInt(spin_game_server_wss_port,10) > 0 ||
                                   parseInt(spin_game_server_ws_port,10) > 0)) {
        var backend_proto, frontend_proto, backend_port;
        if(parseInt(spin_game_server_wss_port,10) > 0) {
            // note: this connection goes to the frontend, so use the same protocol as spin_server_protocol
            backend_proto = 'wss://';
            frontend_proto = (spin_server_protocol === 'https://' ? 'wss://' : 'ws://');
            // but the port number here is for the backend, so always use the WSS port number
            backend_port = spin_game_server_wss_port;
        } else {
            backend_proto = frontend_proto = 'ws://';
            backend_port = spin_game_server_ws_port;
        }
        if(spin_game_direct_multiplex) {
            // help the proxyserver/haproxy setup to direct this to the gameserver directly
            var ret = frontend_proto + spin_server_host + ':' + spin_server_port + '/WS_GAMEAPI?spin_game_server_port=' + backend_port;
            if(spin_game_server_snam) {
                ret += "&spin_game_server_snam=" + spin_game_server_snam;
            }
            return ret;
        } else {
            return backend_proto + spin_game_server_host + ':' + backend_port + '/WS_GAMEAPI';
        }

    } else if(spin_game_direct_connect && !spin_game_direct_multiplex) {
        // most modern browsers now disallow pages hosted via HTTPS from making non-HTTPS AJAX requests :(
        // so prefer HTTPS if available
        if(spin_server_protocol === 'https://') {
            return 'https://'+spin_game_server_host+":"+spin_game_server_ssl_port+"/GAMEAPI";
        } else {
            return 'http://'+spin_game_server_host+":"+spin_game_server_http_port+"/GAMEAPI";
        }
    } else {
        // go via proxyserver
        return proxy_gameapi_url(true);
    }
}

function gameapi_connection_method() {
    if(spin_game_direct_connect) {
        var url = gameapi_url();
        if(url.indexOf('https') == 0) {
            return 'direct_ssl';
        } else if(url.indexOf('wss') == 0) {
            return 'direct_wss';
        } else if(url.indexOf('ws') == 0) {
            return 'direct_ws';
        } else {
            return 'direct_http';
        }
    } else {
        return 'proxy_ssl';
    }
}

// URL to proxyserver GAMEAPI, used as fallback and for sending keepalives when in direct connect mode
function proxy_gameapi_url(try_multiplex) {
    var ret = spin_server_protocol+spin_server_host+":"+spin_server_port+"/GAMEAPI";
    if(try_multiplex) { // "help" the proxyserver/haproxy setup to direct this to the gameserver directly
        // always use the SSL backend port, if available, even if the frontend is HTTP
        var backend_port = (parseInt(spin_game_server_ssl_port,10) > 0 ? spin_game_server_ssl_port : spin_game_server_http_port);
        ret += "?spin_game_server_port=" + backend_port;
        if(spin_game_server_snam) {
            ret += "&spin_game_server_snam=" + spin_game_server_snam;
        }
    }
    return ret;
}

/** Construct a URL to the server's OGPAPI (Open Graph endpoint)
    @param {Object.<string,string>} props - properties to attach. Only "type" is required.
    @return {string} */
function ogpapi_url(props) {
    var proxyserver = spin_server_host+(parseInt(spin_server_http_port,10)!=80 ? ':'+spin_server_http_port : '');
    var url = 'http://'+proxyserver+'/OGPAPI';
    var i = 0;
    for(var k in props) {
        url += (i == 0 ? '?' : '&') + k + '=' + encodeURIComponent(props[k]);
        i += 1;
    }
    // force flush of bad cached entries at Facebook
    url += (i == 0 ? '?' : '&') + 'sp_ogpapi_ver=2';
    return url;
}

function send_proxy_keepalive() {
    console.log('send_proxy_keepalive()');
    var resp = function(event) {
        //console.log('proxy keepalive resp '+event.target.getStatusText()+' text '+event.target.getResponseText());
    };
    goog.net.XhrIo.send(proxy_gameapi_url(false), resp, 'POST',
                        'proxy_keepalive_only=1&session='+session.session_id.toString(), {},
                        1000*ajax_config['message_timeout_gameplay']);
}

var metric_0107_sent = false;

function gameart_onload() {
    var all = GameArt.get_dl_progress_all();
    var essential = GameArt.get_dl_progress_essential();

    var time_to_load = (new Date()).getTime()/1000 - spin_pageload_begin;

    if(essential >= 1) {
        if(client_art_state === client_art_states.DOWNLOADING_ESSENTIAL) {
            client_art_state = client_art_states.DOWNLOADING_ALL;
            if(!metric_0107_sent) {
                metric_0107_sent = true;
                SPLWMetrics.send_event(spin_metrics_anon_id, '0107_client_loaded_essential_art', add_demographics({'user_id': session.user_id,
                                                                                                                   'since_pageload': (new Date()).getTime()/1000 - spin_pageload_begin}));
            }
        }
    }

    if(all >= 1) {
        client_art_state = client_art_states.DONE;
    }
}

// COORDINATE TRANSFORMS

// "ortho" cell indices are j (= horizontal, + to right/east) i (= vertical, + down/south) with 0,0 at northwest corner of the base
// (the isometric view has +j towards lower-right and +i towards lower-left)
// pixel coordinates are always x (= horizontal, + to right) y (= vertical, + down)
// "playfield" coordinates are pixel coordinates with 0,0 at northwest corner of ortho cell 0,0
// "screen" coordinates are "playfield" coordinates shifted by view_pos then zoomed by view_zoom
// "draw" coordinates at the coordinates within the canvas transform set by do_draw() when drawing the playfield
// (when zoom = 1, it is the same as "screen", and when zoom != 1, it is the same as "playfield")


// convert orthographic cell index to pixel coordinate of top (northwest) corner of cell
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function ortho_to_playfield(ji) {
    // rotate to diamond pixel grid
    var x = (cellsize[0]*ji[0] - cellsize[0]*ji[1])/2;
    var y = (cellsize[1]*ji[0] + cellsize[1]*ji[1])/2;
    return [x,y];
}
/** @param {!Array.<number>} p
    @return {!Array.<number>} */
function playfield_to_screen(p) {
    // shift view so that view_pos puts center grid cell at middle of canvas
    var ncells = (session.has_world() ? session.get_draw_world().base.ncells() : [0,0]);
    return vec_add(vec_scale(view_zoom, vec_sub(p, view_pos)),
                   [canvas_width_half, canvas_height_half - view_zoom*cellsize[1]*ncells[1]/2]);
}
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function ortho_to_screen(ji) {
    return playfield_to_screen(ortho_to_playfield(ji));
}
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function ortho_to_draw(ji) {
    if(view_is_zoomed()) {
        return ortho_to_playfield(ji);
    } else {
        return ortho_to_screen(ji);
    }
}
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function ortho_to_draw_vector(ji) {
    if(view_is_zoomed()) {
        return ortho_to_playfield_vector(ji);
    } else {
        return ortho_to_screen_vector(ji);
    }
}
/** @param {!Array.<number>} j_height_i
    @return {!Array.<number>} */
function ortho_to_screen_3d(j_height_i) {
    var xy = ortho_to_screen([j_height_i[0], j_height_i[2]]);
    xy[1] += j_height_i[1] * -15 * view_zoom;
    return xy;
}
/** @param {!Array.<number>} j_height_i
    @return {!Array.<number>} */
function ortho_to_draw_3d(j_height_i) {
    var xy = ortho_to_draw([j_height_i[0], j_height_i[2]]);
    xy[1] += j_height_i[1] * -15;
    return xy;
}

// transform a vector (not a point) from orthographic cell coordinates to playfield coordinates
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function ortho_to_playfield_vector(ji) {
    var x = (cellsize[0]*ji[0] - cellsize[0]*ji[1])/2;
    var y = (cellsize[1]*ji[0] + cellsize[1]*ji[1])/2;
    return [x,y];
};
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function ortho_to_screen_vector(ji) {
    var p = ortho_to_playfield_vector(ji);
    if(view_is_zoomed()) {
        p = vec_scale(view_zoom, p);
    }
    return p;
};

// return depth corresponding to an orthographic cell position
// higher values are closer to the "camera"
/** @param {!Array.<number>} ji
    @return {number} */
function ortho_to_depth(ji) {
    return ji[0] + ji[1];
}

/** @param {!Array.<number>} xy
    @return {!Array.<number>} */
function screen_to_playfield(xy) {
    // undo view window shift
    var ncells = session.get_draw_world().base.ncells();
    return vec_add(view_pos, vec_scale(1/view_zoom, vec_sub(xy, [canvas_width_half, canvas_height_half - view_zoom*cellsize[1]*ncells[1]/2])));
}
/** @param {!Array.<number>} xy
    @return {!Array.<number>} */
function playfield_to_ortho(xy) {
    // rotate to orthogonal grid
    var j = xy[0]/(cellsize[0]) + xy[1]/(cellsize[1]);
    var i = -xy[0]/(cellsize[0]) + xy[1]/(cellsize[1]);
    // quantize
    return vec_floor([j,i]);
}
/** @param {!Array.<number>} xy
    @return {!Array.<number>} */
function screen_to_ortho(xy) {
    return playfield_to_ortho(screen_to_playfield(xy));
}
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function playfield_to_draw(ji) {
    if(view_is_zoomed()) {
        return ji;
    } else {
        return playfield_to_screen(ji);
    }
}

/** Most browser Canvas implementations seem to have a fast path that activates when
    things are drawn at integer coordinate positions. This function quantizes 2D
    coordinates appropriately for the current Canvas settings.
    @param {!Array.<number>} xy
    @return {!Array.<number>} */
function draw_quantize(xy) {
    if(view_is_zoomed()) {
        // all bets are off, don't even bother
        return xy;
    } else if(canvas_oversample === 1) {
        return [Math.floor(xy[0]), Math.floor(xy[1])];
    } else {
        return [Math.floor(xy[0]*canvas_oversample)/canvas_oversample,
                Math.floor(xy[1]*canvas_oversample)/canvas_oversample];
    }
}

// cache of last known pixel dimensions of Facebook iframe area
var fb_iframe_dims = null;
var fb_iframe_scroll = null;
var fb_iframe_offset = null;

/** @return {boolean}
 Check if the Facebook client SDK, specifically FB.Canvas, seems to be available.
 If not, calls to FB.Canvas.*() methods will fail with the error "Cannot read property 'postMessage' of null". */
function fb_canvas_methods_available() {
    return (typeof FB != 'undefined') && (typeof FB.Canvas != 'undefined');
}

// query Facebook for the iframe viewport dimensions
function fb_iframe_update(cb) {
    if(!fb_canvas_methods_available()) {
        // if the Facebook XDM mechanism is broken, there is nothing we can do.
        return;
    }

    // somehow, getPageInfo() still throws "Cannot read property 'postMessage' of null" unpredictably.
    // just ignore it when this happens
    try {
        FB.Canvas.getPageInfo((function (_cb) { return function(info) {
            // only write console message on active ping and not passive snoop
            if(_cb) {
                console.log('FB.Canvas.getPageInfo: dims '+info['clientWidth'].toString()+'x'+info['clientHeight'].toString()+
                            ' scroll '+info['scrollLeft'].toString()+'x'+info['scrollTop'].toString()+
                            ' offset '+info['offsetLeft'].toString()+'x'+info['offsetTop'].toString());
            }
            fb_iframe_dims = [info['clientWidth'], info['clientHeight']];
            fb_iframe_scroll = [info['scrollLeft'], info['scrollTop']];
            fb_iframe_offset = [info['offsetLeft'], info['offsetTop']];
            if(_cb) { _cb(); }
        }; })(cb));
        return;

    } catch(e) {
        log_exception(e, 'FB.Canvas.getPageInfo');
    }

    // call the callback in the exception case
    if(cb) { cb(); }
}

/** Set fixed canvas size based on browser dimensions
    @param {!Array.<number>} max_dims */
function update_armorgames_iframe_size(max_dims) {
    if(spin_frame_platform === 'ag' &&
       spin_armorgames_enabled &&
       gamedata['client']['armorgames_iframe_size_mode'] === 'screen') {
        var header = document.getElementById('spin_header');
        var width_buffer = gamedata['client']['armorgames_iframe_margins'][0];
        var height_buffer = (header ? header.clientHeight : 0) + gamedata['client']['armorgames_iframe_footer_peek'] +
            gamedata['client']['armorgames_iframe_margins'][1];
        var width = Math.max(736, max_dims[0] - width_buffer);
        var height = Math.max(425, max_dims[1] - height_buffer);
        var arg = {'width': width, 'height': height};
        console.log("MAX_DIMS "+JSON.stringify(max_dims)+" RESIZING TO "+JSON.stringify(arg));
        SPArmorGames.setIframeDimensions(arg);
    }
}

// called when browser window changes size - query for max iframe size
function on_resize_browser(e) {
    console.log('BROWSER '+window.innerWidth+' x '+window.innerHeight+' screen '+screen.width+' x '+screen.height);
    fb_iframe_dims = null;

    var force_width_s = get_query_string('force_width'), force_height_s = get_query_string('force_height');
    var force_width = (force_width_s ? parseInt(force_width_s,10) : -1), force_height = (force_height_s ? parseInt(force_height_s,10) : -1);

    if(force_width > 0 && force_height > 0) {
        fb_iframe_dims = [force_width, force_height];
        on_resize_iframe(null);
    } else if(spin_frame_platform == 'fb' && spin_facebook_enabled && gamedata['client']['facebook_iframe_resize_hack'] && fb_canvas_methods_available()) {
        fb_iframe_update(function() { on_resize_iframe(null); });
    } else {
        // no Facebook API, just use natural iframe size as determined by browser CSS layout
        on_resize_iframe(null);
    }
};

// called when game iframe SHOULD change size to be appropriate for the browser window size
function on_resize_iframe(e) {
    if(spin_frame_platform == 'fb' && spin_facebook_enabled && gamedata['client']['facebook_iframe_resize_hack']) {
        // On Facebook App settings page, Canvas Height should be in "Fixed" (not "Fluid") mode for this to work

        var newheight;

        // Facebook used to auto-scroll canvas games downward to put the top of the game canvas at the
        // top of the browser window. So we used to use the exact pixel viewport size in that case,
        // to get a sort-of-fullscreen appearance (within the blue Facebook frame).

        // As of 2014 Nov 22, Facebook no longer auto-scrolls canvas games down. So this ends up chopping
        // off the bottom of the canvas. Code disabled but left in for reference only.

        // 2014 Nov 25 update - this path IS required for Firefox in truefullscreen mode, otherwise mouse click tracking gets the wrong height offset.
        var needs_firefox_hack = (spin_demographics['browser_name'] === 'Firefox' && canvas_is_fullscreen);

        if(needs_firefox_hack /* || window.innerWidth >= (screen.width-320) */) {
            // I THINK WE MIGHT BE IN FAKE FULLSCREEN MODE
            if(fb_iframe_dims) {
                // if Facebook has given us the exact pixel viewport size, use that
                newheight = fb_iframe_dims[1];
            } else {
                // otherwise, try to almost take up the entire screen height
                // need to provide some padding for browser toolbars etc.
                // 30px works OK on Chrome/Firefox/IE
                newheight = screen.availHeight-30;
            }

        } else {
            // WINDOWED MODE
            if(fb_iframe_dims) {
                // occupy almost full vertical canvas, but leave room for Facebook chrome
                newheight = Math.max(425, fb_iframe_dims[1] - (fb_iframe_offset !== null ? fb_iframe_offset[1] : 43));

                // maybe conditionalize on if(!canvas_is_fullscreen)?
                var header = document.getElementById('spin_header');
                if(header) { newheight -= header.clientHeight; }

                // SHOW TOP PORTION OF SPIN_FOOTER with forum links etc.
                newheight -= gamedata['client']['facebook_iframe_footer_peek'];

            } else {
                // no clue about browser height. Just use fixed height (like Kixeye)
                newheight = 625;
            }
        }

        canvas_div.style.height = newheight.toString()+'px';
        if(get_query_string('force_width')) {
            canvas_div.style.width = fb_iframe_dims[0].toString()+'px';
            //canvas.style.width = canvas_div.style.width;
            //canvas.style.height = canvas_div.style.height;
        }

        // resize startup_div to match, if it is still visible
        var startup_div = document.getElementById('startup_div');
        if(startup_div.offsetWidth > 0 && startup_div.offsetHeight > 0) {
            startup_div.style.height = canvas_div.style.height;
            startup_div.style.width = canvas_div.style.width;
        }

        if(fb_canvas_methods_available()) {
            var iframe_width = canvas_width;
            var iframe_height = newheight + parseInt(document.getElementById('spin_footer').style.height,10);
            console.log('FB.Canvas.setSize: '+iframe_width+'x'+iframe_height);
            FB.Canvas.setSize({'width':iframe_width, 'height': iframe_height});
        }
    }

    on_resize_game();
}



// read current canvas_div width/height and set game canvas accordingly
function on_resize_game() {
    // these are in oversampled / backing-store units, and should NOT be used for layout computations
    canvas.width = canvas_oversample * canvas_div.offsetWidth;
    canvas.height = canvas_oversample * canvas_div.offsetHeight;

    canvas.style.width = canvas_div.offsetWidth.toString()+'px';
    canvas.style.height = canvas_div.offsetHeight.toString()+'px';

    // turning off imageSmoothing helps avoid seams on transparent GUI sprites,
    // although it does create a somewhat blocky appearance.
    ctx['imageSmoothingEnabled'] = (canvas_oversample === 1);

    // update cached dimensions
    canvas_width = Math.floor(canvas.width / canvas_oversample);
    canvas_height = Math.floor(canvas.height / canvas_oversample);
    canvas_width_half = Math.floor(canvas_width/2);
    canvas_height_half = Math.floor(canvas_height/2);
    canvas_div_offsetLeft = canvas_div.offsetLeft;
    canvas_div_offsetTop = canvas_div.offsetTop;

    set_view_limits();
    //console.log('GAME '+canvas_width+'x'+canvas_height);

    SPUI.on_resize(canvas_width, canvas_height);
    tutorial_root.wh = [canvas_width, canvas_height];
    tutorial_root.on_resize();
    player.quest_root.wh = [canvas_width, canvas_height];
    player.quest_root.on_resize();

    force_draw();
}

/** Set the "base" transform for canvas drawing */
function set_default_canvas_transform(ctx) {
    ctx.setTransform(canvas_oversample, 0, 0, canvas_oversample, 0, 0);
}

function set_view_zoom(new_linear) {
    if(new_linear != get_preference_setting(player.preferences, 'playfield_zoom')) {
        player.preferences['playfield_zoom'] = new_linear;
        send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
    }

    view_zoom_linear = clamp(new_linear, gamedata['client']['view_zoom_limits'][0], gamedata['client']['view_zoom_limits'][1]);
    if(Math.abs(view_zoom_linear) < 0.01) {
        // ensure that we use fast paths when not zooming
        view_zoom_linear = 0;
        view_zoom = 1;
    } else {
        view_zoom = Math.exp(view_zoom_linear);
    }
    set_view_limits();
}

function set_view_limits() {
    var BORDER = gamedata['client']['playfield_scroll_margin'];
    var ncells = (session.viewing_base ? session.viewing_base.ncells() : [0,0]);
    view_limits[0] = [-cellsize[0]*ncells[0]/2+canvas_width_half/view_zoom-BORDER[0],
                      cellsize[0]*ncells[0]/2-canvas_width_half/view_zoom+BORDER[0] ];
    if(view_limits[0][1] < view_limits[0][0]) { view_limits[0] = [0,0]; };
    view_limits[1] = [-cellsize[1]*ncells[1]/2+canvas_height_half/view_zoom-BORDER[1],
                      cellsize[1]*ncells[1]/2-canvas_height_half/view_zoom+BORDER[1] ];
    if(view_limits[1][1] < view_limits[1][0]) { view_limits[1] = [0,0]; };
}

// note: sound/music, fullscreen, and settings buttons
function invoke_playfield_controls_bar() {
    var orient = (gamedata['client']['playfield_controls_bar_layout'] || 'vertical');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['playfield_controls_bar_'+orient]);
    dialog.user_data['dialog'] = 'playfield_controls_bar_'+orient;
    dialog.user_data['adjusting_music'] = false;
    dialog.user_data['adjusting_sound'] = false;
    dialog.transparent_to_mouse = true;

    // true FS support
    if(has_true_fullscreen()) {
        dialog.widgets['fullscreen_button'].show = true;
    } else if(is_browser_standalone_mode()) {
        // no need for this button (?)
        dialog.widgets['fullscreen_button'].show = false;
    } else {
        // fake FS dialog - breaks tutorial and has no useful info for non-Windows/Mac browsers
        dialog.widgets['fullscreen_button'].show = ((player.tutorial_state == "COMPLETE") &&
                                                    (spin_demographics['browser_OS'] === "Mac" ||
                                                     spin_demographics['browser_OS'] === "Windows"));
    }
    dialog.widgets['fullscreen_button'].onclick = function() {
        if(has_true_fullscreen()) {
            toggle_true_fullscreen();
        } else {
            invoke_fullscreen_instructions();
        }
    };

    dialog.widgets['settings_button'].onclick = invoke_settings_dialog;

    dialog.widgets['screenshot_button'].onclick = function(w) {
        var dialog = w.parent;
        invoke_post_screenshot(null, /* reason = */ dialog.user_data['dialog'] + (session.home_base ? '_home': '_away'),
                               make_post_screenshot_caption(dialog.data['widgets']['screenshot_button']['ui_caption'],
                                                            (session.viewing_user_id === session.user_id ? player.get_player_cache_props() : PlayerCache.query_sync(session.viewing_user_id))
                                                           ));
    };

    dialog.widgets['music_button'].show = GameArt.enable_audio;
    dialog.widgets['sound_button'].show = GameArt.enable_audio;

    if(GameArt.enable_audio) {
        dialog.widgets['music_button'].onclick = function(w) {
            var dialog = w.parent;
            dialog.user_data['adjusting_sound'] = false;
            dialog.user_data['volume_type'] = 'music';
            if(!!player.preferences['volume_control_enabled']) {
                dialog.user_data['adjusting_music'] = !dialog.user_data['adjusting_music'];
            } else {
                update_player_volume(dialog, 2); // update_player_volume will use legacy mute/unmute if receiving a delta value of 2
            }
        }
        dialog.widgets['sound_button'].onclick = function(w) {
            var dialog = w.parent;
            dialog.user_data['volume_type'] = 'sound';
            dialog.user_data['adjusting_music'] = false;
            if(!!player.preferences['volume_control_enabled']) {
                dialog.user_data['adjusting_sound'] = !dialog.user_data['adjusting_sound'];
            } else {
                update_player_volume(dialog, 2); // update_player_volume will use legacy mute/unmute if receiving a delta value of 2
            }
        }
        dialog.widgets['volume_down_button'].onclick = function(w) {
            var dialog = w.parent;
            update_player_volume(dialog, -1);
        }
        dialog.widgets['volume_up_button'].onclick = function(w) {
            var dialog = w.parent;
            update_player_volume(dialog, 1);
        }
        dialog.widgets['volume_bar_sound_button'].onclick = function(w) {
            var dialog = w.parent;
            update_player_volume(dialog, 2);
        }
        dialog.widgets['volume_bar_music_button'].onclick = function(w) {
            var dialog = w.parent;
            update_player_volume(dialog, 2);
        }
    }
    dialog.ondraw = update_playfield_controls_bar;
    return dialog;
}

function invoke_electron_control_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['electron_control_dialog']);
    dialog.user_data['dialog'] = 'electron_control_dialog';
    dialog.transparent_to_mouse = true;
    dialog.widgets['exit_button'].onclick = function() {
        window.top.postMessage({'method': 'bh_electron_command', 'type':'APP_COMMAND', 'command':'EXIT'}, '*');
    };
    dialog.ondraw = update_electron_control_dialog;
    return dialog;
}

/**
    @param {SPUI.Dialog} dialog
*/
function update_electron_control_dialog(dialog) {
    dialog.xy = [canvas_width-dialog.wh[0],0]; //ensures exit button is at top far-right if canvas is resized
    dialog.widgets['exit_button'].show = canvas_is_fullscreen;
}

/**
    @param {SPUI.Dialog} dialog
    @param {number} delta
*/
function update_player_volume(dialog, delta) {
    var sound_or_music = dialog.user_data['volume_type'];
    var last_music_volume, change, method;
    last_music_volume = GameArt.music_volume;
    if (delta === 2) { // passed by sound/music mute/unmute buttons and if player preferences are set for legacy sound controls
        method = 'mute-unmute';
    } else if (delta > 0) {
        change = 0.01;
    } else if (delta < 0) {
        change = -0.01;
    }
    if(sound_or_music === 'sound') {
        if (method && method === 'mute-unmute') {
            if(GameArt.sound_volume == 0 && player.preferences['last_sound_volume'] > 0) {
                GameArt.sound_volume = player.preferences['last_sound_volume'];
            } else {
                GameArt.sound_volume = (GameArt.sound_volume > 0 ? 0 : 1);
            }
        } else {
            GameArt.sound_volume += change;
        }
        if(GameArt.sound_volume < 0) {
            GameArt.sound_volume = 0;
        } else if (GameArt.sound_volume > 1) {
            GameArt.sound_volume = 1;
        }
    } else {
        if (method && method === 'mute-unmute') {
            if(GameArt.music_volume == 0 && player.preferences['last_music_volume'] > 0) {
                GameArt.music_volume = player.preferences['last_music_volume'];
            } else {
                GameArt.music_volume = (GameArt.music_volume > 0 ? 0 : 1);
            }
        } else {
            GameArt.music_volume += change;
        }
        if(GameArt.music_volume < 0) {
            GameArt.music_volume = 0;
        } else if (GameArt.music_volume > 1) {
            GameArt.music_volume = 1;
        }
    }
    if(backdrop_music) {
        if(GameArt.music_volume > 0 && last_music_volume === 0) {
            backdrop_music.loop();
            backdrop_music.play(client_time);
            backdrop_music.fadeIn(0.001);
        } else if (GameArt.music_volume === 0) {
            backdrop_music.unloop();
            backdrop_music.stop(client_time);
        }
    }
    player.preferences['sound_volume'] = GameArt.sound_volume;
    if(GameArt.sound_volume > 0) {
        player.preferences['last_sound_volume'] = GameArt.sound_volume;
    }
    player.preferences['music_volume'] = GameArt.music_volume;
    if(GameArt.music_volume > 0) {
        player.preferences['last_music_volume'] = GameArt.music_volume;
    }
    send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
}

/** @param {SPUI.Dialog} dialog */
function update_playfield_controls_bar(dialog) {
    // on the old horizontal controls bar, there isn't enough space to show away from home or in battle.
    dialog.widgets['screenshot_button'].show = (session.enable_combat_resource_bars &&
                                                ((player.tutorial_state == "COMPLETE") &&
                                                 (dialog.user_data['dialog'] == 'playfield_controls_bar_vertical' || (session.home_base && !session.has_attacked)) &&
                                                 post_screenshot_enabled()));

    dialog.widgets['volume_down_button'].show = dialog.widgets['volume_up_button'].show = (dialog.user_data['adjusting_music'] || dialog.user_data['adjusting_sound']);
    if (dialog.user_data['adjusting_music'] || dialog.user_data['adjusting_sound']) {
        dialog.wh = dialog.data['volume_dimensions'];
        dialog.xy = dialog.data['volume_xy'];
        dialog.on_mousewheel_function = update_player_volume;
    } else {
        dialog.wh = dialog.data['dimensions'];
        dialog.xy = dialog.data['xy'];
        dialog.on_mousewheel_function = null;
    }
    goog.array.forEach(['', '_prog', '_amount','_button'], function(w) {
        if('volume_bar_sound'+w in dialog.widgets) {
            dialog.widgets['volume_bar_sound'+w].show = dialog.user_data['adjusting_sound'];
        }
        if('volume_bar_music'+w in dialog.widgets) {
            dialog.widgets['volume_bar_music'+w].show = dialog.user_data['adjusting_music'];
        }
    });
    dialog.widgets['volume_bar_sound_prog'].progress = Math.min(1, GameArt.sound_volume);
    dialog.widgets['volume_bar_music_prog'].progress = Math.min(1, GameArt.music_volume);
    dialog.widgets['volume_bar_sound_amount'].str = dialog.data['widgets']['volume_bar_sound_amount']['ui_name'].replace('%pct', (GameArt.sound_volume*100.0).toFixed(0));
    dialog.widgets['volume_bar_music_amount'].str = dialog.data['widgets']['volume_bar_music_amount']['ui_name'].replace('%pct', (GameArt.music_volume*100.0).toFixed(0));
    if(GameArt.sound_volume > 0) {
        dialog.widgets['volume_bar_sound'].tooltip.str = dialog.data['widgets']['volume_bar_sound']['ui_tooltip'].replace('%M', 'Mute');
    } else {
        dialog.widgets['volume_bar_sound'].tooltip.str = dialog.data['widgets']['volume_bar_sound']['ui_tooltip'].replace('%M', 'Unmute');
    }
    if(GameArt.music_volume > 0) {
        dialog.widgets['volume_bar_music'].tooltip.str = dialog.data['widgets']['volume_bar_music']['ui_tooltip'].replace('%M', 'Mute');
    } else {
        dialog.widgets['volume_bar_music'].tooltip.str = dialog.data['widgets']['volume_bar_music']['ui_tooltip'].replace('%M', 'Unmute');
    }

    if(dialog.user_data['dialog'] == 'playfield_controls_bar_horizontal') {
        var top = desktop_dialogs['desktop_top'];
        if(!top) {
            if(session.is_replay()) {
                dialog.show = true;
                dialog.xy = [Math.floor(canvas_width_half - dialog.wh[0]/2), 0];
            } else {
                dialog.show = false; return;
            }
        } else {
            dialog.show = true;
            if('alliances_button' in top.widgets) {
                dialog.xy = vec_add(dialog.data['spacing_under'], vec_add([0,top.widgets['alliances_button'].wh[1]], top.widgets['alliances_button'].get_absolute_xy()));
            } else {
                dialog.xy = vec_add(dialog.data['spacing_right'], top.get_absolute_xy());
            }
        }
        if(!dialog.widgets['fullscreen_button'].show) {
            dialog.widgets['settings_button'].xy = dialog.data['widgets']['fullscreen_button']['xy'];
        } else {
            dialog.widgets['settings_button'].xy = dialog.data['widgets']['settings_button']['xy'];
        }
    } else {
        // attach to right side of desktop
        dialog.xy = vec_add(dialog.data['spacing'], [canvas_width-dialog.wh[0], Math.floor(canvas_height/2 - dialog.wh[1])]);
        // hack for A/B test
        if(!dialog.widgets['screenshot_button'].show) {
            var delta = dialog.data['widgets']['sound_button']['xy'][1] - dialog.data['widgets']['screenshot_button']['xy'][1];
            dialog.widgets['controls_bg'].xy = vec_add(dialog.data['widgets']['controls_bg']['xy'], [0,delta]);
            dialog.widgets['controls_bg'].wh = vec_add(dialog.data['widgets']['controls_bg']['dimensions'], [0,-delta]);
        } else {
            dialog.widgets['controls_bg'].xy = dialog.data['widgets']['controls_bg']['xy'];
            dialog.widgets['controls_bg'].wh =dialog.data['widgets']['controls_bg']['dimensions'];
        }
        if(!dialog.widgets['fullscreen_button'].show) {
            dialog.widgets['settings_button'].xy = dialog.data['widgets']['fullscreen_button']['xy'];
            var delta = dialog.data['widgets']['settings_button']['xy'][1] - dialog.data['widgets']['fullscreen_button']['xy'][1];
            dialog.widgets['controls_bg'].wh[1] = dialog.widgets['controls_bg'].wh[1] - delta;
        } else {
            dialog.widgets['settings_button'].xy = dialog.data['widgets']['settings_button']['xy'];
            var delta = 0;
            if(!dialog.widgets['screenshot_button'].show) {
                delta = dialog.data['widgets']['sound_button']['xy'][1] - dialog.data['widgets']['screenshot_button']['xy'][1];
            }
            dialog.widgets['controls_bg'].xy = vec_add(dialog.data['widgets']['controls_bg']['xy'], [0,delta]);
            dialog.widgets['controls_bg'].wh = vec_add(dialog.data['widgets']['controls_bg']['dimensions'], [0,-delta]);
        }
    }
    dialog.widgets['settings_button'].show = session.enable_combat_resource_bars && ((player.tutorial_state == "COMPLETE") ||
                                                                                     gamedata['tutorial'][player.tutorial_state]['enable_desktop_control_buttons']);
    dialog.widgets['fullscreen_button'].state = canvas_is_fullscreen ? 'reverse' : 'normal';
    if(GameArt.enable_audio) {
        dialog.widgets['music_button'].state = GameArt.music_volume > 0 ? 'on' : 'off';
        dialog.widgets['sound_button'].state = GameArt.sound_volume > 0 ? 'on' : 'off';
    }
}

function invoke_playfield_zoom_bar() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['playfield_zoom_bar']);
    dialog.user_data['dialog'] = 'playfield_zoom_bar';
    var zoom_cb = function(incr) { return function(w) {
        player.record_feature_use('playfield_zoom');
        // quantize to avoid misalignment when used together with mousewheel zoom
        var new_zoom = view_zoom_linear + incr * gamedata['client']['view_zoom_click_increment'];
        var quant = gamedata['client']['view_zoom_click_increment'];
        new_zoom = quant * Math.round(new_zoom / quant);
        set_view_zoom(new_zoom);
    }; };
    dialog.widgets['zoom_in_button'].onclick = zoom_cb(1);
    dialog.widgets['zoom_out_button'].onclick = zoom_cb(-1);
    dialog.ondraw = update_playfield_zoom_bar;
    return dialog;
}
function update_playfield_zoom_bar(dialog) {
    // attach to right side of desktop
    //if('playfield_controls_bar' in desktop_dialogs && (desktop_dialogs['playfield_controls_bar'].user_data['dialog'] == 'playfield_controls_bar_vertical')) { ... }
    dialog.xy = vec_add(dialog.data['spacing'], [canvas_width-dialog.wh[0], Math.floor((canvas_height /* -dialog.wh[1]*/ )/2)]);
    dialog.widgets['zoom_readout'].str = dialog.data['widgets']['zoom_readout']['ui_name'].replace('%d', (view_zoom_linear >= 0 ? '+' : '') + view_zoom_linear.toFixed(1));
    dialog.widgets['zoom_readout'].text_color = SPUI.make_colorv(dialog.data['widgets']['zoom_readout']['text_color_'+(view_zoom_linear === 0 ? 'zero' : 'nonzero')]);
    dialog.widgets['zoom_in_button'].state = (view_zoom_linear >= gamedata['client']['view_zoom_limits'] ? 'disabled' : 'normal');
    dialog.widgets['zoom_out_button'].state = (view_zoom_linear < gamedata['client']['view_zoom_limits'] ? 'disabled' : 'normal');

    // hide if combat resource bars are off, but still compute position for dialogs anchored to this
    dialog.show = !!session.enable_combat_resource_bars;
}

/** @param {BattleReplay.Player|null=} replay_player */
function init_playfield_speed_bar(replay_player) {
    if((replay_player || player.get_any_abtest_value('enable_playfield_speed_bar', gamedata['client']['enable_playfield_speed_bar'])) &&
       !('playfield_speed_bar' in desktop_dialogs)) {
        var dialog = invoke_playfield_speed_bar(replay_player);
        if(dialog) {
            desktop_dialogs['playfield_speed_bar'] = dialog;
            SPUI.root.add_under(dialog);
        }
    }
}

/** @return {!Array<number>} */
function get_playfield_speed_limits() {
    // when deployment_allowed is false, assume this is a timed skill challenge, so disable time manipulation
    if(!session.is_replay() && !session.viewing_base.deployment_allowed) { return [0, 0]; }

    return gamedata['client']['playfield_speed_limits'][session.is_replay() ? 'replay': 'normal'];
};
/** @param {BattleReplay.Player|null=} replay_player */
function invoke_playfield_speed_bar(replay_player) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['playfield_speed_bar']);
    dialog.user_data['dialog'] = 'playfield_speed_bar';
    dialog.user_data['replay_player'] = replay_player || null;
    dialog.wh = dialog.data[replay_player ? 'dimensions_replay' : 'dimensions'];
    dialog.widgets['speed_bg'].wh = dialog.data['widgets']['speed_bg'][replay_player ? 'dimensions_replay' : 'dimensions'];
    var speed_cb = function(incr) { return function(w) {
        player.record_feature_use('playfield_speed');
        var new_speed = player_playfield_speed + incr;
        var limits = get_playfield_speed_limits();
        new_speed = clamp(new_speed, limits[0], limits[1]);
        if(new_speed != player_playfield_speed) {
            session.get_draw_world().control_paused = false;
            update_player_combat_time_scale(new_speed);
        }

        // persist preference
        if(!session.is_replay() && player.preferences['playfield_speed'] != player_playfield_speed) {
            player.preferences['playfield_speed'] = player_playfield_speed;
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
        }
    }; };
    dialog.widgets['speed_up_button'].onclick = speed_cb(1);
    dialog.widgets['speed_down_button'].onclick = speed_cb(-1);
    dialog.widgets['pause_button'].onclick = function() {
        var world = session.get_draw_world();
        world.control_paused = !world.control_paused;
    };
    dialog.widgets['restart_button'].onclick = function(w) {
        var dialog = w.parent;
        var replay_player = dialog.user_data['replay_player'];
        if(replay_player) {
            replay_player.world.control_paused = false;
            replay_player.restart();
        }
    };
    dialog.ondraw = update_playfield_speed_bar;
    return dialog;
}
function update_playfield_speed_bar(dialog) {
    var is_replay = session.is_replay() && dialog.user_data['replay_player'];

    // attach to right side of desktop, underneath zoom bar
    dialog.xy = vec_add(dialog.data['spacing'], [canvas_width-dialog.wh[0], Math.floor((canvas_height/2) + gamedata['dialogs']['playfield_zoom_bar']['dimensions'][1])]);
    goog.array.forEach(['speed_amount', 'speed_label'], function(wname) {
        dialog.widgets[wname].text_color = SPUI.make_colorv(dialog.data['widgets'][wname]['text_color_'+(player_playfield_speed === 0 ? 'zero' : 'nonzero')]);
    });
    var limits = get_playfield_speed_limits();
    dialog.widgets['speed_up_button'].state = (player_playfield_speed >= limits[1] ? 'disabled' : 'normal');
    dialog.widgets['speed_down_button'].state = (player_playfield_speed <= limits[0] ? 'disabled' : 'normal');
    dialog.widgets['speed_amount'].str = dialog.data['widgets']['speed_amount']['ui_name'].replace('%f', player_combat_time_scale.toFixed(1));
    dialog.widgets['pause_button'].state = (session.get_draw_world().control_paused ? 'active' : 'normal');

    dialog.widgets['pause_button'].show =
        dialog.widgets['restart_button'].show = is_replay;

    // hide if combat resource bars are off, but still compute position for dialogs anchored to this
    dialog.show = !!session.enable_combat_resource_bars;
}

var last_flush_time = 0;

// test server robustness against lag by adding delay to AJAX transmissions
var inject_lag = 0;

var ajax_config = null; // pointer into gamedata.client.ajax_config

// set to true if there has been any mouse/keyboard input since the last transmission to the server.
// if not, then set the nokeepalive flag so that automated messages do not hold the connection open
var input_since_last_xmit = true;
var input_since_last_proxy_xmit = true;

// go through some gymnastics to preserve a reference to the XMLHttpRequest hidden inside a goog.net.XhrIo so we can attach our own progress listener.
/** @constructor @struct
  * @extends goog.net.XmlHttpFactory */
function MyXmlHttpFactory(request) {
    this.request = request;
};
goog.inherits(MyXmlHttpFactory, goog.net.XmlHttpFactory);
MyXmlHttpFactory.prototype.getOptions = goog.net.XmlHttp.getOptions;
MyXmlHttpFactory.prototype.createInstance = function() { return this.request; };

var last_ajax_serial = -1;
var last_ajax_xmit_time = -1;
var last_ajax_xmit_len = -1;

var the_websocket = null;
var last_websocket_keepalive = -1;
var last_websocket_xmit_time = -1;
var last_websocket_xmit_len = -1;
var last_websocket_queue = null; // last AJAXMessageQueue queued for transmission on the websocket
var last_websocket_serial = -1; // serial number of last_websocket_queue

/** Low-level websocket transmission function.

    SpinPunch fragmentation protocol: this is another layer of fragmentation
    ON TOP OF WebSocket messages. Necessary because some browsers (IE)
    in some configurations seem to have trouble transmitting >32KB messages
    intact.

    The protocol is just this: one websocket message of the characters 'SP'
    plus the decimal length (0-padded to 20 digits), followed by individual
    messages to concatenate to re-assemble the original message.

    @param {SPWebsocket.SPWebsocket} socket
    @param {string} data */
function websocket_transmit(socket, data) {
    var max_msg = eval_cond(gamedata['client']['websocket_max_message'] || 0, player, null);
    if(max_msg > 0 && data.length > max_msg) {
        var ptr = 0;
        // send "start of fragmented message" message
        socket.send('SP'+pad_with_zeros(data.length.toString(), 20));
        while(ptr < data.length) {
            var to_send = Math.min(data.length - ptr, max_msg);
            socket.send(data.slice(ptr, ptr + to_send));
            ptr += to_send;
        }
    } else {
        socket.send(data);
    }
};

/** @param {boolean=} force
    @param {number=} my_timeout */
function flush_message_queue(force, my_timeout) {
    if(message_queue.length() < 1) {
        return;
    }

    // limit AJAX requests to ocurring no more frequently than one per this number of seconds
    if(!force && (client_time - last_flush_time) < gamedata['client']['ajax_min_flush_interval']) {
        //console.log('Throttling back AJAX');
        return;
    }
    last_flush_time = client_time;

    // test server robustness against different groupings of messages within an AJAX request
    var GROUPTEST = false;
    if(GROUPTEST && message_queue.length() < 2 && message_queue.queue[0][0] != "CLIENT_HELLO") {
        return;
    }

    if(player.is_developer()) {
        goog.array.forEach(message_queue.queue, function(msg) {
            console.log(['To Server ('+gameapi_connection_method()+')', message_serial.toString()].concat(msg));
        });
    }

    // tag messages that are sent without human input as 'nokeepalive'
    // so they won't hold the session open past its timeout
    var keepalive = input_since_last_xmit;
    input_since_last_xmit = false;

    var send_it;

    if(spin_game_use_websocket) {
        // Websockets
        var data_dict = {'myarg': message_queue.queue, // NOT stringified internally
                         'serial': message_serial,
                         'ack': ajax_next_serial - 1,
                         'session': session.session_id};
        if(!keepalive) {
            // message is automatic, do not keepalive
            data_dict['nokeepalive'] = 1;
        }
        ajax_last_ack = ajax_next_serial - 1;

        var data_str = JSON.stringify(data_dict);
        message_queue.serial = message_serial;

        // save this message bundle in case websocket fails and we need to re-transmit it via HTTP
        last_websocket_queue = message_queue;
        last_websocket_serial = message_serial;
        last_websocket_xmit_time = client_time;
        last_websocket_xmit_len = data_str.length;

        if(!the_websocket) {
            var enable_reconnect = (get_query_string('enable_websocket_reconnect') === '1' ||
                                    player.get_any_abtest_value('enable_websocket_reconnect',
                                                                gamedata['client']['enable_websocket_reconnect']));
            var min_delay = eval_cond(gamedata['client']['websocket_min_delay'], player, null);
            the_websocket = new SPWebsocket.SPWebsocket(gameapi_url(),
                                                        ajax_config['message_timeout_hello'],
                                                        ajax_config['message_timeout_gameplay'],
                                                        enable_reconnect,
                                                        min_delay);
            var on_websocket_error = function(event) {
                if(!the_websocket || SPINPUNCHGAME.shutdown_in_progress || client_state === client_states.TIMED_OUT) { return; } // irrelevant
                the_websocket.close();
                the_websocket = null;

                var error_props = {'user_id': spin_user_id,
                                   'method': (event.data||'unknown'),
                                   'serial': last_websocket_serial,
                                   'len': last_websocket_xmit_len,
                                   'elapsed': client_time - last_websocket_xmit_time,
                                   'since_connect': (session.connected() ? client_time - session.connect_time : session.connect_time),
                                   'since_pageload': client_time - spin_pageload_begin,
                                   'connection': gameapi_connection_method()
                                  };

                // can we recover?
                var can_recover = false;
                if(last_websocket_serial == message_serial-1) { // we only had one message on the wire
                    if(ajax_config['enable_proxy']) { // can fall back to proxied HTTP
                        can_recover = true;

                        // note: force metric to be sent via the GIF fetch method rather than with the normal client/server stream
                        SPLWMetrics.send_event(spin_metrics_anon_id, '0645_direct_ws_failure_falling_back_to_proxy', add_demographics(error_props));
                        spin_game_use_websocket = false;
                        spin_game_direct_connect = false;

                        // switch back to HTTP and retransmit failed bundle
                        message_serial -= 1;
                        message_queue.prepend(last_websocket_queue.queue);
                        last_websocket_queue = null;
                        last_websocket_serial = -1;
                        flush_message_queue(true);
                        if(session.connected()) {
                            longpoll_send();
                        }
                    }
                }

                if(can_recover) {
                    return;
                }

                // permadeath
                if(event.data == 'connect_timeout') {
                    invoke_timeout_message('0641_client_died_from_ws_connect_timeout', error_props, {});
                } else if(event.data == 'xmit_error') {
                    invoke_timeout_message('0642_client_died_from_ws_xmit_failure', error_props, {});
                } else {
                    invoke_timeout_message('0649_client_died_from_ws_unknown_failure', error_props, {});
                }

            };
            var on_websocket_shutdown = function(event) { // server-initiated shutdown
                if(!the_websocket || SPINPUNCHGAME.shutdown_in_progress) { return; } // irrelevant
                the_websocket = null;
                session.connect_time = -3; // disconnect session
                if(client_state !== client_states.TIMED_OUT) {
                    //invoke_timeout_message('0600_client_idle_timeout', {}, {});
                    var s = gamedata['errors']['UNKNOWN_SESSION'];
                    invoke_timeout_message('0643_client_died_from_ws_shutdown', {'method': event.data},
                                           {'ui_title': s['ui_title'], 'ui_description': s['ui_name'].replace('%d','643'), 'ui_button': s['ui_button'],
                                            'dialog': s['dialog'] || null});
                }
                SPINPUNCHGAME.shutdown();
            };
            var on_websocket_message = function(event) {

                // update client_time here immediately, for ping keepalives
                client_time = (new Date()).getTime()/1000;

                if(event.data == 'SPws_ping') {
                    // server set us a ping
                } else {
                    on_ajax(event.data, (the_websocket && the_websocket.url.indexOf('ws://') == 0 ? 'direct_ws' : 'direct_wss'));
                }

                // Chrome throttles JavaScript timers in background tabs,
                // but does allow WebSocket message processing - so use this as a chance to send keepalive ping.
                if(the_websocket && gamedata['client']['websocket_keepalive_interval'] > 0 &&
                   (client_time - last_websocket_keepalive > gamedata['client']['websocket_keepalive_interval'])) {
                    last_chat_ping = client_time;
                    last_websocket_keepalive = client_time;
                    send_to_server.func(["PING_CHAT", player.chat_seen, 'websocket_keepalive_message']);
                    flush_message_queue(true);
                }
            };
            var on_websocket_reconnect = function(event) {
                console.log('WebSocket reconnected. Retransmitting '+retrans_buffer.length().toString()+' messages.');
                goog.array.forEach(retrans_buffer.buf, function(serial_msg) {
                    websocket_transmit(the_websocket,
                                       JSON.stringify({'myarg': serial_msg[1],
                                                       'serial': serial_msg[0],
                                                       'ack': ajax_next_serial - 1,
                                                       'session': session.session_id}));
                    ajax_last_ack = ajax_next_serial - 1;
                });
                send_to_server.func(["RECONNECT"]);
                flush_message_queue(true);
            };
            goog.events.listen(the_websocket.target, 'error', on_websocket_error);
            goog.events.listen(the_websocket.target, 'shutdown', on_websocket_shutdown);
            goog.events.listen(the_websocket.target, 'message', on_websocket_message);
            goog.events.listen(the_websocket.target, 'reconnect', on_websocket_reconnect);

            the_websocket.connect();
        }

        send_it = (function (_data_str, _the_websocket) { return function() { websocket_transmit(_the_websocket, _data_str); }; })(data_str, the_websocket);

    } else {
        // Google Closure XhrIo method
        var msg = 'myarg='+encodeURIComponent(JSON.stringify(message_queue.queue));
        message_queue.serial = message_serial;
        msg += '&serial='+message_serial.toString();
        msg += '&ack='+(ajax_next_serial-1).toString();
        msg += '&session='+session.session_id.toString();
        if(!keepalive) {
            // message is automatic, do not keepalive
            msg += '&nokeepalive=1';
        }
        ajax_last_ack = ajax_next_serial - 1;

        last_ajax_serial = message_serial;
        last_ajax_xmit_time = client_time;
        last_ajax_xmit_len = msg.length;

        var timeout_ms = 1000*(my_timeout ? my_timeout : ajax_config['message_timeout_gameplay']);

        // needs to be true for Firefox 25 etc due to very strict CORS policies
        // note, this requires that the server respond with an Access-Control-Allow-Origin that exactly matches the Origin: on the request,
        // wildcard (*) is NOT ok!
        var use_cors_credentials = true;

        send_it = (function(_msg, _timeout_ms, _use_cors_credentials) { return function() {
            //goog.net.XhrIo.send(gameapi_url(), on_ajax_goog, 'POST', _msg, {}, _timeout_ms, _use_cors_credentials);

            // go through some gymnastics to preserve a reference to the XMLHttpRequest so we can attach a progress listener
            var request = goog.net.XmlHttp();
            var x = new goog.net.XhrIo(new MyXmlHttpFactory(request));
            goog.events.listen(x, goog.net.EventType.COMPLETE, on_ajax_goog);
            goog.events.listen(x, goog.net.EventType.READY, (function (_x) { return function() { _x.dispose(); }; })(x));

            // partial-progress event that updates the message bundle's response progress
            // note: this is not supported and will not fire on IE < 10
            request.addEventListener('progress', (function (_message_queue) { return function(e) {
                if(e.lengthComputable && e.total > 0) {
                    _message_queue.recv_progress = e.loaded/e.total;
                }
            }; })(message_queue), false);

            x.setTimeoutInterval(_timeout_ms);
            x.setWithCredentials(_use_cors_credentials);
            x.send(gameapi_url(), 'POST', _msg, {});
        }; })(msg, timeout_ms, use_cors_credentials);
    }

    if(inject_lag > 0) {
        window.setTimeout(send_it, Math.floor(1000*inject_lag));
    } else {
        send_it();
    }

    retrans_buffer.append(message_serial, message_queue.queue);
    if(retrans_buffer.length() >= gamedata['client']['ajax_message_buffer']) {
        invoke_timeout_message('0624_client_retrans_buffer_overflow', {'len': retrans_buffer.length()}, {});
    }

    message_queue = new AJAXMessageQueue();
    message_serial += 1;
}

var longpoll_error_count = 0;
var longpoll_in_progress = false;
function longpoll_send() {
    if(SPINPUNCHGAME.shutdown_in_progress || client_state === client_states.TIMED_OUT) { return; }
    if(longpoll_in_progress) { return; }
    if(!gamedata['client']['enable_ajax_longpoll']) { return; }
    if(spin_game_use_websocket) { return; }

    var msg = 'myarg='+JSON.stringify([["LONGPOLL"]])+'&serial=-1&longpoll=1&session='+session.session_id.toString()+'&nokeepalive=1';
    if(player.is_developer()) {
        console.log('To Server: LONGPOLL');
    }

    longpoll_in_progress = true;
    goog.net.XhrIo.send(gameapi_url(), function(event) {
        longpoll_in_progress = false;
        var repeat = true;
        if(!event.target.isSuccess()) {
            var code = event.target.getLastErrorCode();
            console.log('LONGPOLL error code '+code);
            if(code === goog.net.ErrorCode.HTTP_ERROR) {
                // we failed to send the request, or got a bad HTTP response code back
                longpoll_error_count += 1;
                if(longpoll_error_count >= 4) { repeat = false; } // don't spam if we can't get requests through
            } else if(code === goog.net.ErrorCode.TIMEOUT) {
                // ordinary timeout
            } else {
                // some unknown error
                repeat = false;
            }
        } else {
            if(on_ajax(event.target.getResponseText(), 'LONGPOLL') < 0) {
                // when we get a message back with -1 as the serial, treat that as a serious error
                repeat = false; // longpoll_error_count += 1;
            }
        }
        if(repeat) {
            longpoll_send(); // send again
        }
    }, 'POST', msg, {}, 1000*gamedata['client']['ajax_longpoll_timeout'], true);
}

// queue of user notifications that occur upon login or next session change
// (not active during initial on-rails tutorial - unless priority >= 200, or in combat)
/** @constructor @struct */
function NotificationQueue() {
    this.queue = [];
    this.hold_time = -1;
    this.achievements = []; // buffer up achievements in case we get more than one in a single transaction
}

// set minimum priority to 200 for notifications to fire during tutorial
NotificationQueue.TUTORIAL_MIN_PRIO = 200;

// fire the next notification message in the queue
// return true if one was successfully fired
NotificationQueue.prototype.fire_next = function(min_prio) {
    if(this.hold_time > 0 && client_time < this.hold_time) { return false; }

    var item = null, item_i = -1;

    for(var i = 0; i < this.queue.length; i++) {
        // only fire notifications when at home OR at a friendly quarry OR if the show_if_away option is set
        if(session.home_base ||
           (session.is_quarry() && (session.viewing_user_id == session.user_id)) ||
           this.queue[i]['show_if_away']) {
            if(this.queue[i]['priority'] > min_prio) {
                item_i = i;
                item = this.queue[i];
                min_prio = item['priority'];
            }
        }
    }

    if(item) {
        this.queue.splice(item_i,1);
        item['cb']();
        if(item['maintain_quest_tips']) {
            // ugly hack - if the callback is used to pop up some sort of tutorial GUI, like TUTORIAL_ARROW,
            // then we do not want to blow away player.quest_root
            player.quest_tracked_dirty = false;
            selection.ui_change_time = -1;
        } else {
            // normally, we want to re-evaluate quest tips here
            player.quest_tracked_dirty = true;
        }
    }
    return !!item;
};

NotificationQueue.prototype.push = function(cb, params) {
    if(!params) { params = {}; }
    this.queue.push({'cb':cb,
                     'priority': params['priority'] || 0,
                     'show_if_away': params['show_if_away'] || false,
                     'maintain_quest_tips': params['maintain_quest_tips'] || false
                    });
};
NotificationQueue.prototype.push_with_priority = function(cb, priority) { this.push(cb, {'priority':priority}); };

NotificationQueue.prototype.pending = function() { return this.queue.length > 0; };
NotificationQueue.prototype.clear = function() { this.queue = []; };
NotificationQueue.prototype.hold_until = function(t) { this.hold_time = Math.max(this.hold_time, t); };
NotificationQueue.prototype.remove = function(cb) {
    for(var i = 0; i < this.queue.length; i++) {
        if(this.queue[i]['cb'] === cb) {
            this.queue.splice(i,1);
            i -= 1;
        }
    }
};

var notification_queue = new NotificationQueue();


// main code

// spin_loading_screen_mode meanings:
// "canvas" = old method, hide startup_div immediately and paint loading_screen_image on white canvas
// "div" = new method, keep startup_div visible until canvas is ready to paint game
var loading_screen_image = null; // reference to HTML5 Image element for OLD loading screen
var startup_div_shown = true;

var kill_startup_div = function() {
    if(!startup_div_shown) { return; }
    startup_div_shown = false;
    var startup_div = document.getElementById('startup_div');
    var fade_time = (spin_loading_screen_mode == 'div' ? (gamedata['client']['startup_div_fade_time'] || 0.5) : -1);
    if(fade_time > 0) {
        var set_startup_div_fade = (function (_start_time, _end_time, _div) { return function() {
            if(client_time >= _end_time) {
                _div.style.display = 'none';
                if(spin_frame_platform === 'bh') { // inform the parent /play page that we are painting everything now
                    window.top.postMessage('bh_iframe_loaded', '*');
                }
                return;
            }
            _div.style.opacity = 1.0 - (client_time - _start_time)/(_end_time - _start_time);
            window.setTimeout(set_startup_div_fade, 1000*gamedata['client']['startup_div_fade_tick']);
        }; })(client_time, client_time + fade_time, startup_div);
        set_startup_div_fade();
    } else {
        startup_div.style.display = 'none';
    }
};
var kill_loading_screen = function() {
    kill_startup_div();
    if(loading_screen_image) {
        loading_screen_image = null; // don't need this any more, let GC have it

        if(spin_frame_platform === 'bh') { // inform the parent /play page that we are painting everything now
            window.top.postMessage('bh_iframe_loaded', '*');
        }
    }
};

var blacklist_audio = false;

SPINPUNCHGAME.watchdog_timer = null;
SPINPUNCHGAME.shutdown_in_progress = false;

SPINPUNCHGAME.shutdown = function() {
    SPINPUNCHGAME.shutdown_in_progress = true;

    if(SPINPUNCHGAME.watchdog_timer) {
        window.clearTimeout(SPINPUNCHGAME.watchdog_timer);
        SPINPUNCHGAME.watchdog_timer = null;
    }

    if(session.connected()) {
        // flush damage changes
        flush_dirty_objects({});
        send_to_server.func(["LOGOUT"]);
        flush_message_queue(true);

        // mark session as not connected anymore so we don't try to send messages again
        session.connect_time = -2;
    }

    if(the_websocket) {
        the_websocket.close();
        the_websocket = null;
    }
};

// sends metric to game server
function metric_event(event_name, props) {
    if(typeof props === 'undefined') { props = {}; }
    if(session.connected()) {
        // send through the server connection
        SPLWMetrics.prepare_props(event_name, props);
        send_to_server.func(["REPORT_METRIC", event_name, props]);
    } else {
        // send through the early metrics connection
        SPLWMetrics.send_event(spin_metrics_anon_id, event_name, props);
    }
}

// send exception info to server as a metric event
SPINPUNCHGAME.client_exception_sent = false;
function log_exception(e, where) {
    if(SPINPUNCHGAME.client_exception_sent) { return; }
    SPINPUNCHGAME.client_exception_sent = true;
    var msg;
    if(e) {
        msg = e.toString();
        if(e.stack) {
            // some browsers (Chrome) repeat the message at the beginning of the stack - trim that off
            var stack = e.stack.toString();
            if(stack.indexOf(msg) == 0) {
                stack = stack.slice(msg.length);
                while(stack.length >= 1 && stack[0] == '\n') { stack = stack.slice(1); } // strip off leading newlines
            }
            msg += '\nstack:\n'+stack;
        }
        if(e.message) {
            msg += '\nmessage: '+e.message.toString();
        }

        /* I don't think this works anymore...
        try {
            msg += '\ntraceback: ' +Traceback.printStackTrace({e:e, guess:false}).join('\n');
        } catch(ex) {}
        */
    } else {
        msg = 'none';
    }

    // show in JS console
    var ui_tick = (session.has_world() && session.get_real_world().combat_engine ? session.get_real_world().combat_engine.cur_tick.get() : -1);
    console.log('Exception thrown in '+where+' at tick '+ui_tick.toString()+':\n'+msg);

    if(player.is_developer()) {
        window.alert('SpinPunch CLIENT EXCEPTION in \"'+where+'\" (check JS Console for more detail):\n'+msg);
    }

    // phone home
    var MAX_LEN = gamedata['client']['max_exception_msg_length'];
    if(msg.length > MAX_LEN) { msg = msg.slice(0,MAX_LEN); }
    metric_event('0970_client_exception', add_demographics({'method':msg, 'location':where,
                                                            'since_connect': (session.connected() ? client_time - session.connect_time : session.connect_time),
                                                            'since_pageload': client_time - spin_pageload_begin,
                                                            'server_message_history': debug_server_message_history.join(','),
                                                            'gameclient_build_date':(typeof gameclient_build_date === 'undefined' ? 'unknown' : gameclient_build_date),
                                                            'gamedata_build_info':gamedata['gamedata_build_info'],
                                                            'server_name':spin_game_server_name}));
}

function do_unsupported_browser_redirect(url) {
    location.href = (url ? url : spin_unsupported_browser_landing);
}

function do_account_banned_redirect() {
    location.href = gamedata['strings']['account_banned_landing'];
}

// fill in "Your Player ID:" at right side of linkbar
function linkbar_put_id(user_id) {
    if(user_id <= 0) { return; }
    var bar = document.getElementById('spin_footer_linkbar_id');
    if(!bar) { return; }
    bar.innerHTML = 'Player ID: <b>'+user_id.toString()+'</b>&nbsp;&nbsp;&nbsp;';
}

// replace __USER_ID__/__ISSUE_ID__ in URL paths (or any string) with the player's actual user_id and camouflaged money_spent amount
function url_put_info(url, user_id, money_spent) {
    // replace __ISSUE_ID__ with camouflaged money_spent
    var camo = gamedata['game_id']+'_';
    for(var c = 0; c < 6; c++) { camo += Math.floor(10*Math.random()).toString(); }
    camo += '_';
    camo += reverse_digits(money_spent);

    // replace Zendesk "PP_code" with another camouflaged money_spent
    var PP_CODES = [[1000,'pp_code_3888'], [100,'pp_code_2888'], [0.01, 'pp_code_1866'], [-1, 'pp_code_0866']];
    var pp;
    for(pp = 0; pp < PP_CODES.length; pp++) {
        if(money_spent >= PP_CODES[pp][0]) {
            break;
        }
    }

    // ZenDesk ticket field game title ID is the lowercased, underscore_spaced full name, with non-alphabetic characters removed
    var title_id = gamedata['strings']['game_name'].toLowerCase();
    while(title_id.indexOf(' ') !== -1) {
        title_id = title_id.replace(' ', '_');
    }
    while(title_id.indexOf("'") !== -1) {
        title_id = title_id.replace("'", '');
    }

    var replacements = {
        '__USER_ID__': user_id.toString(),
        '__SOCIAL_ID__': spin_social_id ? spin_social_id.toString() : '',
        '__ARMORGAMES_ID__': spin_armorgames_user ? spin_armorgames_user.toString() : '',
        '__FACEBOOK_ID__': spin_facebook_user ? spin_facebook_user.toString() : '',
        '__KONGREGATE_ID__': spin_kongregate_user ? spin_kongregate_user.toString() : '',
        '__BATTLEHOUSE_ID__': spin_battlehouse_user ? spin_battlehouse_user.toString() : '',
        '__FRAME_PLATFORM__': spin_frame_platform.toString(),
        '__TITLE_ID__': title_id,
        '__ISSUE_ID__': camo,
        '__PP_CODE__': PP_CODES[pp][1]
    };

    goog.object.forEach(replacements, function(v,k) {
        while(url.indexOf(k) != -1) {
            url = url.replace(k, v);
        }
    });

    return url;
}

/** @param {string} url */
function url_open_in_new_tab(url) {
    var handle = window.open(url, '_blank');
    if(handle) { handle.focus(); }
}

SPINPUNCHGAME.init = function() {
    console.log('init');

    var p = get_query_string('inject_lag');
    if(p) { inject_lag = parseFloat(p); }

    ajax_config = gamedata['client']['ajax_config'][(spin_ajax_config in gamedata['client']['ajax_config']) ? spin_ajax_config : 'default'];

    // we've had trouble with some browsers (Chrome, Safari) not firing these events reliably when navigating away from the game page
    // call shutdown from BOTH unload and beforeunload to be as sure as possible that we send a logout (though it is still not guaranteed)
    window.addEventListener("beforeunload", SPINPUNCHGAME.shutdown, false);
    window.addEventListener("unload", SPINPUNCHGAME.shutdown, false);

    // register bh.com iframe postMessage handler
    if(spin_frame_platform === 'bh') {
        window.addEventListener("message", Battlehouse.on_postMessage, false);
    }

    if(document.URL.indexOf('anon_mode=1') != -1) { anon_mode = true; }
    if(document.URL.indexOf('dev_linkbar=1') != -1) { document.getElementById('canvas_div').style.height = '50%'; }

    linkbar_put_id(spin_user_id);

    // this timer is cleared after the first frame renders successfully.
    // if it ever actually fires, then chances are the browser encountered an error running the client code
    SPINPUNCHGAME.watchdog_timer = window.setTimeout(function() {
        metric_event('0950_watchdog_timer_fired', add_demographics({}));
        SPINPUNCHGAME.watchdog_timer = null;
    }, 10*1000);

    canvas_div = /** @type {HTMLDivElement} */ (document.getElementById('canvas_div'));
    canvas = /** @type {HTMLCanvasElement} */ (document.getElementById('canvas'));

    if(canvas.getContext) {
        ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
    }

    // check for bad browsers
    var unsupported_reason = null, unsupported_url = null;
    if(!ctx || !ctx.fillText) {
        console.log('Browser does not support HTML5 canvas!');
        unsupported_reason = 'HTML5 Canvas';
    } else if(spin_demographics['browser_name'] === 'Firefox' &&
              spin_demographics['browser_version'] < 6) {
        unsupported_reason = 'Firefox version < 6';
    } else if(spin_demographics['browser_name'] === 'Safari' &&
              spin_demographics['browser_version'] < 5) {
        unsupported_reason = 'Safari version < 5';
    } else if(spin_demographics['browser_name'] === 'Chrome' &&
              spin_demographics['browser_version'] < 31) {
        unsupported_reason = 'Chrome version < 31';
    } else if(spin_demographics['browser_name'] === 'Chrome' &&
              chrome_version_atleast(33,0,1700,0) &&
              !chrome_version_atleast(33,0,1721,0)) {
        unsupported_reason = 'Chrome v33 beta with JS parser bug';
        unsupported_url = gamedata['strings']['bad_chrome_version_landing'];
    } else if(spin_demographics['browser_name'] === 'Chrome' &&
              chrome_version_atleast(42,0,0,0) &&
              !chrome_version_atleast(43,0,0,0)) {
        unsupported_reason = 'Chrome v42 with audio bug';
    }

    if(unsupported_reason) {
        SPLWMetrics.send_event(spin_metrics_anon_id, '0940_unsupported_browser',
                               add_demographics({'method':unsupported_reason}));
        // wait to hopefully allow metrics to fire
        window.setTimeout((function (_url) { return function() { do_unsupported_browser_redirect(_url); }; })(unsupported_url), 1500);
        return;
    } else {
        ctx = /** @type {!CanvasRenderingContext2D} */ (ctx); // guaranteed by unsupported_reason test
    }

    // configure stack trace depth for reporting exceptions
    if(spin_demographics['browser_name'] === 'Chrome') {
        Error.stackTraceLimit = 32;
    }

    // initialize graphics modules

    // detect browser font rendering gamma
    var fonts_are_thick = false;
    if(spin_demographics['browser_name'] === 'Firefox') {
        fonts_are_thick = true;
    } else if(spin_demographics['browser_name'] === 'Chrome') {
        // Chrome switched from "thin" to "thick" gamma in Chrome/22.0.1229.79
        // and back again to "thin" in Chrome/22.0.1229.92
        // and back again to "thick" in Chrome/24.0.1312.52
        fonts_are_thick = (chrome_version_atleast(22,0,1229,79) && !chrome_version_atleast(22,0,1229,92)) || chrome_version_atleast(24,0,1312,52);
    }

    // hack that reduces the variety of unique font sizes/faces used in rendering the Canvas
    var low_fonts = false;
    if(get_query_string('low_fonts') == '1') {
        low_fonts = true;
    } else if(spin_demographics['browser_name'] === 'Chrome') {
        // These versions of Chrome have a glyph caching bug
        low_fonts |= (chrome_version_atleast(30,0,1599,69) && !chrome_version_atleast(30,0,1599,101));
    } else if(spin_demographics['browser_name'] === 'Explorer' && spin_demographics['browser_version'] >= 12) {
        // MS Edge has a performance problem with Canvas text rendering, reducing font variety helps
        low_fonts |= true;
    }

    SPUI.init(canvas, ctx, {fonts_are_thick: fonts_are_thick,
                            low_fonts: low_fonts,
                            html_text_input: false // updated after receiving A/B tests
                           });

    window.addEventListener("resize", on_resize_browser, false);

    // call once to set initial canvas size
    on_resize_browser(null);

    // better locate tutorial stuff on first run
    view_pos = [0,50];

    // disable browser's default right-click->context menu behavior on the canvas
    canvas.addEventListener("contextmenu", function(e) { e.preventDefault(); }, true);

    if(touch_mode === touch_modes.TOUCHEVENT) {
        canvas.addEventListener("touchstart", on_touchstart, false);
        canvas.addEventListener("touchend", on_touchend, false);
        canvas.addEventListener("touchcancel", on_touchend, false);
        canvas.addEventListener("touchmove", on_touchmove, false);
    } else if(touch_mode === touch_modes.MSPOINTER && 1) { // disable this if anything breaks on IE
        canvas.addEventListener("MSPointerDown", on_MSPointerDown, false);
        canvas.addEventListener("MSPointerUp", on_MSPointerUp, false);
        canvas.addEventListener("MSPointerOut", on_MSPointerOut, false);
        canvas.addEventListener("MSPointerMove", on_MSPointerMove, false);
    }

    canvas.addEventListener("mousedown", on_mousedown, false);
    canvas.addEventListener("mouseup", on_mouseup, false);
    canvas.addEventListener("mousemove", on_mousemove, false);
    canvas.addEventListener("wheel", on_mousewheel, false);

    // allow canvas to acquire focus (and force focus when mouse is over it) so that keydown events work
    // see http://www.dbp-consulting.com/tutorials/canvas/CanvasKeyEvents.html
    canvas.setAttribute('tabindex', '0');
    canvas.focus();
    canvas.addEventListener("mouseover", function(e) {
        // auto-refocus on all mouseover events, unless there is an active HTML text input
        if(SPUI.keyboard_focus && SPUI.keyboard_focus.want_html_focus()) { return; }
        canvas.focus();
    }, false);
    canvas.addEventListener("mouseout", on_mouseout, false);
    canvas.addEventListener("mouseout", function(e) { canvas.blur(); }, false);
    canvas.addEventListener("keydown", on_keydown, false);
    canvas.addEventListener("keypress", on_keypress, false);
    canvas.addEventListener("keyup", on_keyup, false);
    canvas.addEventListener("textInput", on_textInput, false);

    pointer_lock_supported = ('webkitPointerLockElement' in document);
    if(pointer_lock_supported) {
        document.addEventListener("webkitpointerlockchange", on_pointer_lock_change, false);
        document.addEventListener("mousemove", on_mousemove, false);
    }

    // requestAnimationFrame shim from http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    window['requestAnimFrame'] = (function(){
        var fun =
              window['requestAnimationFrame']       ||
              window['webkitRequestAnimationFrame'] ||
              window['mozRequestAnimationFrame']    ||
              window['oRequestAnimationFrame']      ||
              window['msRequestAnimationFrame']     ||
            null;

        if(get_query_string('requestAnimationFrame')) {
            if(get_query_string('requestAnimationFrame') !== '1') {
                fun = null;
            } else {
                // leave fun alone
            }
        } else {
            if(!eval_cond_or_literal(gamedata['client']['use_requestAnimationFrame'], player, null)) {
                fun = null; // disable it
            }
        }

        var ret;
        USING_REQUESTANIMATIONFRAME = (fun != null);
        if(fun != null) {
            console.log("using requestAnimationFrame for animation");
            ret = function(callback, element, delay_ms) { fun(callback, element); };
        } else {
            ret = function(/* function */ callback, /* DOMElement */ element, /* number */ delay_ms){
                LAST_ANIM_FRAME_TIMEOUT = delay_ms;
                window.setTimeout(callback, delay_ms);
            };
            console.log("requestAnimationFrame not available or disabled; using setTimeout for animation");
        }
        return ret;
    })();

    // note: Closure incorrectly obfuscates these canvas/document properties, so manually quote all lookups
    canvas_div['SPINrequestFullScreen'] = (function() {
        var event_name = null, fun = null;

        // standard version
        fun = canvas_div['requestFullScreenWithKeys'] ||
            canvas_div['requestFullScreen'];
        if(fun) {
            event_name = 'fullscreenchange';
        } else {
            // try webkit version
            fun = canvas_div['webkitRequestFullScreenWithKeys'] ||
                  canvas_div['webkitRequestFullScreen'];
            if(fun && (spin_demographics['browser_name'] !== 'Safari')) { // webkit fullscreen seems broken on Safari now!
                event_name = 'webkitfullscreenchange';
                // manually ensure keyboard input works
                if(fun === canvas_div['webkitRequestFullScreen']) {
                    fun = function() { canvas_div['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']); };
                }
            } else {
                // try mozilla version
                fun = canvas_div['mozRequestFullScreenWithKeys'] ||
                      canvas_div['mozRequestFullScreen'];
                if(fun) {
                    event_name = 'mozfullscreenchange';
                } else {
                    // try IE version
                    fun = canvas_div['msRequestFullScreenWithKeys'] ||
                          canvas_div['msRequestFullScreen'];
                    if(fun) {
                        event_name = 'msfullscreenchange';
                    }
                }
            }
        }
        if(fun && event_name) {
            console.log("fullscreen support is available (event "+event_name+")");
            document['SPINcancelFullScreen'] = document['cancelFullScreen'] ||
                                           document['webkitCancelFullScreen'] ||
                                           document['mozCancelFullScreen'] ||
                                           document['msCancelFullScreen'];
            // install event handler
            document.addEventListener(event_name, function(e) {
                if(!document['fullScreenElement'] && !document['mozFullScreen'] && !document['webkitIsFullScreen'] &&
                   // not sure what flag to use here
                   !document['msIsFullScreen'] && !document['msFullScreen']
                  ) {
                    console.log('exiting fullscreen mode');
                    canvas_is_fullscreen = false;

                    // unlock screen orientation, if the API is available
                    if('orientation' in screen && 'unlock' in screen['orientation']) { screen['orientation']['unlock'](); }
                } else {
                    console.log('entering fullscreen mode');
                    canvas_is_fullscreen = true;

                    // lock screen into landscape mode, if the API is available
                    if('orientation' in screen && 'lock' in screen['orientation']) {
                        screen['orientation']['lock']('landscape').then(
                            // success
                            function(_) { },
                            // failure - do nothing
                            function(_) {});
                    }
                }
            }, false);
        } else {
            console.log("fullscreen support is NOT available in this browser");
        }
        return fun;
    })();

    console.log("Client starting, using gamedata version "+gamedata["version"]);

    player.init();
    enemy.init();

    // add virtual units
    for(var name in gamedata["virtual_units"]) {
        player.virtual_units[name] = { spec: gamedata["virtual_units"][name], id: GameObject.VIRTUAL_ID, team: 'player', stats: {},
                                       is_mobile: function() { return 0; },
                                       is_building: function() { return 0; },
                                       is_destroyed: function() { return 0; }
                                     };
    }

    if(spin_loading_screen_mode == 'canvas') {
        // to test skipping this load, you can use this instead of the below lines:
        // loading_screen_image = {complete: false, width: -1};

        // start downloading the splash screen before GameArt init
        loading_screen_image = new Image();
        loading_screen_image.crossOrigin = 'Anonymous';
        loading_screen_image.src = GameArt.art_url(spin_loading_screen_data, false);
    }

    // old Chrome on Windows crashes with audio
    if(spin_demographics['browser_name'] === 'Chrome' &&
       spin_demographics['browser_OS'] === 'Windows' &&
       !chrome_version_atleast(17, 0, 963, 66)) {
        blacklist_audio = true;
        console.log('blacklisting audio on Windows Chrome version < 17.0.963.66');
    }

    if(spin_demographics['browser_name'] === 'Opera') {
        blacklist_audio = true;
        console.log('blacklisting audio on Opera');
    }

    SPUI.time = client_time = (new Date()).getTime()/1000;
    ctx.font = SPUI.desktop_font.str();

    // set up permanent UI elements

    // add error log
    user_log = new SPUI.ErrorLog(5);
    desktop_dialogs['user_log'] = user_log;
    //SPUI.root.add(user_log);
    user_log.xy = [200, 120];

    // display any messages passed from the web page scripts
    for(var i = 0; i < spin_init_messages.length; i++) {
        user_log.msg(spin_init_messages[i], new SPUI.Color(0.5,1,1,1));
    }

    // try websockets by default, if able and gamedata.client.enable_websockets is true
    if(spin_game_direct_connect && gamedata['client']['enable_websockets'] && SPWebsocket.is_supported() &&
       (parseInt(spin_game_server_ws_port,10) > 0 || parseInt(spin_game_server_wss_port,10) > 0)) {
        spin_game_use_websocket = true;
    }

    // send CLIENT_HELLO first to try to make sure it doesn't get pushed behind graphics download
    var user_demographics = [spin_demographics['browser_name'] || 'unknown',
                             spin_demographics['browser_version'] || 'unknown',
                             spin_demographics['browser_OS'] || 'unknown',
                             spin_demographics['locale'] || 'unknown',
                             spin_demographics['browser_hardware'] || 'unknown',
                             (screen.width.toString() + 'x' + screen.height.toString()),
                             (canvas_width.toString() + 'x' + canvas_height.toString()),
                             window['devicePixelRatio'] || 1,
                             spin_client_platform, spin_client_vendor, spin_client_version
                            ];

    // send browser caps metric
    var audio_context_works = false;
    try { if((typeof(AudioContext) != 'undefined') || (typeof(webkitAudioContext) != 'undefined')) { audio_context_works = true; } } catch(e) {};
    /*
    var webgl_works = false;
    try {
        var temp = document.createElement('canvas');
        var ctxNames = ['webgl', 'experimental-webgl'];
        var glCtx = temp.getContext('webgl') || temp.getContext('experimental-webgl');
        if(glCtx) { webgl_works = true; }
    } catch(e) {}
    */
    var browser_caps = {'canvas': 1,
                        //'webgl': webgl_works ? 1 : 0,
                        'websocket': SPWebsocket.is_supported() ? 1 : 0,
                        'audio_element': (buzz.isSupported() ? 1 : 0),
                        'audio_ogg': (buzz.isSupported() && buzz.isOGGSupported() ? 1 : 0),
                        'audio_wav': (buzz.isSupported() && buzz.isWAVSupported() ? 1 : 0),
                        'audio_mp3': (buzz.isSupported() && buzz.isMP3Supported() ? 1 : 0),
                        'audio_aac': (buzz.isSupported() && buzz.isAACSupported() ? 1 : 0),
                        'audio_context': (audio_context_works ? 1 : 0)};

    if(spin_demographics['browser_hardware'] == "iPad" || spin_demographics['browser_hardware'] == "iPhone") {
        browser_caps['retina_display'] = ((window['devicePixelRatio'] && (window['devicePixelRatio'] >= 2)) ? 1 : 0);
    }

    last_proxy_keepalive = client_time; // unnecessary to send a proxy keepalive immediately

    var client_build_date_str = (typeof gameclient_build_date === 'undefined' ? 'unknown' : gameclient_build_date);

    session.client_hello_packet = ["CLIENT_HELLO",
                                   SPHTTP.wrap_string(spin_game_query_string),
                                   spin_facebook_signed_request,
                                   spin_social_id,
                                   spin_metrics_anon_id,
                                   spin_session_id,
                                   user_demographics,
                                   browser_caps,
                                   gamedata['gamedata_build_info'],
                                   client_build_date_str,
                                   spin_session_time,
                                   spin_session_data,
                                   spin_facebook_oauth_token,
                                   spin_session_signature,
                                   spin_facebook_login_permissions,
                                   null,
                                   spin_login_country,
                                   spin_user_id];

    SPLWMetrics.send_event(spin_metrics_anon_id, '0105_client_start', add_demographics({'user_id': session.user_id,
                                                                                        'splash_image': spin_loading_screen_name,
                                                                                        'since_pageload': (new Date()).getTime()/1000 - spin_pageload_begin}));

    // uncomment these brackets to test proxyserver race conditions
    //window.setTimeout(function() {
    send_to_server.func(session.client_hello_packet);

    flush_message_queue(true, ajax_config['message_timeout_hello']);

    if(spin_loading_screen_mode == 'canvas') {
        kill_startup_div();
    }

    draw();
    //}, 3000);

    SPFB.AppEvents.activateApp();
};

// spawn desktop dialogs
// This should be called every time the session changes, because the dialogs are different
// depending on whether the player is looking at their own base or someone else's.

var global_chat_frame = null; // same chat frame is re-used for entire session
var global_spell_icon = null;

function init_desktop_dialogs() {
    // destroy the current desktop
    for(var name in desktop_dialogs) {
        var dialog = desktop_dialogs[name];
        if(dialog.parent) {
            if(name === 'chat_frame' || name === 'user_log') {
                // do not destroy these dialogs, just unparent
                dialog.parent.unparent(dialog);
            } else {
                dialog.parent.remove(dialog);
                delete desktop_dialogs[name];
            }
        }
    }

    // we want to add these dialogs to SPUI.root in order, but underneath anything already there
    var root_next = SPUI.root.children.length > 0 ? SPUI.root.children[0] : null;

    // top dialog
    var dialog_name;
    if(session.home_base) {
        dialog_name = 'desktop_top';
    } else {
        dialog_name = 'desktop_top_visitor';
    }
    dialog = new SPUI.Dialog(gamedata['dialogs'][dialog_name]);
    dialog.transparent_to_mouse = true;
    desktop_dialogs['desktop_top'] = dialog;

    if(session.home_base && session.has_deployed) {
        // defensive battle bars
        var defensive_battle_bars = invoke_defensive_battle_bars();
        desktop_dialogs['defensive_battle_bars'] = defensive_battle_bars;
        SPUI.root.add_before(root_next, defensive_battle_bars);
    }

    var enable_control_buttons = (!session.has_attacked &&
                                  ((player.tutorial_state == "COMPLETE") ||
                                   gamedata['tutorial'][player.tutorial_state]['enable_desktop_control_buttons']));

    if(session.home_base) {
        dialog.widgets['battle_history_button'].show =
            dialog.widgets['battle_history_jewel'].show =
            dialog.widgets['leaderboard_button'].show = enable_control_buttons;

        dialog.widgets['keyboard_shortcuts_button'].show = enable_control_buttons && (!('enable_keyboard_shortcuts_button' in gamedata['client']) || gamedata['client']['enable_keyboard_shortcuts_button']);

        dialog.widgets['leaderboard_button'].onclick = function(w) { invoke_leaderboard(); };
        dialog.widgets['keyboard_shortcuts_button'].onclick = invoke_keyboard_shortcuts;
        dialog.widgets['keyboard_shortcuts_jewel'].ondraw = update_notification_jewel;
        dialog.widgets['keyboard_shortcuts_jewel'].show = dialog.widgets['keyboard_shortcuts_button'].show && player.get_any_abtest_value('enable_keyboard_shortcuts_jewel', gamedata['client']['enable_keyboard_shortcuts_jewel']);

        dialog.widgets['battle_history_button'].onclick = function(w) { invoke_battle_history_dialog(session.user_id, -1, session.alliance_id, '', -1, w); };
        dialog.widgets['battle_history_jewel'].ondraw = update_notification_jewel;

        dialog.widgets['trialpay_button'].onclick = function(w) { Store.trialpay_invoke(); };
        dialog.widgets['trialpay_button'].show = enable_control_buttons && ((player.tutorial_state === "COMPLETE") && player.get_abtest_value('T015_offer_wall_t4', 'enable', 0));
        dialog.widgets['alliances_button'].show = enable_control_buttons && ((player.tutorial_state === "COMPLETE") && player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances']));
        dialog.widgets['alliances_button'].onclick = invoke_alliance_dialog;

        dialog.widgets['quest_tracker_title'].onclick =
            dialog.widgets['quest_tracker_descr'].onclick = function() {
                invoke_missions_dialog(true, player.quest_tracked);
            };

    } else { // NOT at home base

        // set up enemy portrait
        if(session.viewing_base.base_landlord_id != session.user_id) {
            var enemy_portrait_dialog = invoke_enemy_portrait_dialog();
            desktop_dialogs['enemy_portrait_dialog'] = enemy_portrait_dialog;
            SPUI.root.add_before(root_next, enemy_portrait_dialog);

            var enemy_resource_bars = new SPUI.Dialog(gamedata['dialogs']['enemy_resource_bars']);
            enemy_resource_bars.ondraw = update_enemy_resource_bars;
            desktop_dialogs['enemy_resource_bars'] = enemy_resource_bars;
            SPUI.root.add_before(root_next, enemy_resource_bars);

            init_playfield_speed_bar();
        }
    }

    if(session.home_base) {
        // developer button
        if(!spin_secure_mode && player.is_developer() && !anon_mode) {
            dialog.widgets['developer_button'].show = true;
            dialog.widgets['developer_button'].onclick = invoke_cheat_menu;
        } else {
            dialog.widgets['developer_button'].show = false;
        }

        dialog.widgets['skip_tutorial_button'].onclick = function() {
            var s = gamedata['strings']['skip_tutorial_confirm'];
            invoke_child_message_dialog(s['ui_title'], s['ui_description'],
                                        {'cancel_button': true,
                                         'ok_button_ui_name': s['ui_button'],
                                         'on_ok': tutorial_opt_out});
        };
    }

    // when defending home base against AI attack, hide resource bars and show "Surrender" button
    if(session.home_base) {
        if(session.has_attacked) {
            if(player.tutorial_state == "COMPLETE" &&
               session.enable_progress_timers /* hide surrender button during critical guided steps */) {
                dialog.widgets['surrender_button'].show = true;
            } else {
                dialog.widgets['surrender_button'].show = false;
            }

            dialog.widgets['surrender_button'].onclick = surrender_to_ai_attack;
        }
    }

    // parent user_log to desktop_top
    dialog.add(user_log);

    // the desktop_top ondraw function goes and updates ALL desktop dialogs
    dialog.ondraw = update_desktop_dialogs;
    SPUI.root.add_before(root_next, dialog);

    // player portrait
    var player_portrait_dialog = invoke_player_portrait_dialog();
    desktop_dialogs['player_portrait_dialog'] = player_portrait_dialog;
    SPUI.root.add_before(root_next, player_portrait_dialog);

    // aura bar
    // IMPORTANT - must be added AFTER player_portrait_dialog because its ondraw needs to read the portrait's position
    var aura_bar = new SPUI.Dialog(gamedata['dialogs']['aura_bar']);
    aura_bar.transparent_to_mouse = true;
    desktop_dialogs['aura_bar'] = aura_bar;
    aura_bar.ondraw = update_aura_bar;
    SPUI.root.add_before(root_next, aura_bar);

    // combat resource bars
    if(!session.home_base) {
        var damage_bar = invoke_combat_damage_bar();
        damage_bar.show = false; // turn off initially so it doesn't flash on session change
        desktop_dialogs['combat_damage_bar'] = damage_bar;
        SPUI.root.add_under(damage_bar);

        var bars = invoke_combat_resource_bars();
        bars.show = false; // turn off initially so it doesn't flash on session change
        desktop_dialogs['combat_resource_bars'] = bars;
        SPUI.root.add_under(bars);
    }

    // playfield zoom bar
    if(player.get_any_abtest_value('enable_playfield_zoom', gamedata['client']['enable_playfield_zoom'])) {
        var zoombar = invoke_playfield_zoom_bar();
        desktop_dialogs['playfield_zoom_bar'] = zoombar;
        SPUI.root.add_under(zoombar);
    }

    // playfield controls bar
    var controls_bar = invoke_playfield_controls_bar();
    desktop_dialogs['playfield_controls_bar'] = controls_bar;
    SPUI.root.add_after(dialog, controls_bar); // add controls_bar to SPUI.root right after desktop_top, because its update method depends on desktop_top's position

    // Electron-only exit button
    var show_electron_control_dialog = eval_cond_or_literal(gamedata['client']['show_electron_control_dialog'], player, null);
    if(show_electron_control_dialog) {
        var electron_control_dialog = invoke_electron_control_dialog();
        desktop_dialogs['electron_control_dialog'] = electron_control_dialog;
        SPUI.root.add_under(electron_control_dialog)
    }


    // desktop bottom

    if(session.home_base) {
        if(session.has_attacked) {
            dialog_name = 'desktop_bottom_defense';
        } else {
            dialog_name = 'desktop_bottom';
        }
    } else {
        dialog_name = 'desktop_bottom_visitor';
    }

    dialog = new SPUI.Dialog(gamedata['dialogs'][dialog_name]);
    dialog.transparent_to_mouse = true;
    desktop_dialogs['desktop_bottom'] = dialog;
    SPUI.root.add_before(root_next, dialog);

    if(session.home_base) {
        if(session.has_attacked) {
        } else {
            var missions_button_visible = !('missions_button_minimized' in player.preferences && player.preferences['missions_button_minimized']);
            dialog.widgets['missions_button'].onclick = function() {
                var action = 'missions'; // invoke "mail" or "missions" dialog

                if(player.tutorial_state == "COMPLETE") {
                    var force_action = null;
                    if('missions_button_action' in gamedata['client']) {
                        force_action = eval_cond(gamedata['client']['missions_button_action'], player, null);
                    }
                    if(force_action !== 'missions' && (player.has_unread_mail() || player.has_uncollected_gift_mail())) {
                        action = 'mail';
                    }
                }

                if(action === 'mail') {
                    invoke_mail_dialog(true);
                } else {
                    invoke_missions_dialog(true);
                }
            };
            dialog.widgets['missions_grow_up'].show = !(dialog.widgets['missions_grow_down'].show =
            dialog.widgets['missions_button'].show = missions_button_visible);
            dialog.widgets['map_button'].onclick = function() { invoke_map_dialog(null); };
            dialog.widgets['store_button'].onclick = function(w) { invoke_store(); };

            var do_add_friend = function() {
                change_selection(null);
                if(spin_frame_platform == 'bh') {
                    // on battlehouse, go directly to Membership Rewards
                    invoke_invite_friends_dialog('friend_bar');
                } else {
                    // on FB etc, show prompt first
                    invoke_invite_friends_prompt('friend_bar');
                }
            }

            for(var i = 0; i < dialog.widgets['friend_bar'].data['widgets']['friend_icon']['array'][0]; i++) {
                dialog.widgets['friend_bar'].widgets['add_friend_button'+i.toString()].onclick = do_add_friend;
            }

            // last slot always shows add-friend button
            if(friend_invites_enabled()) {
                dialog.widgets['friend_bar'].widgets['add_friend_button6'].show = true;
                dialog.widgets['friend_bar'].widgets['friend_icon6'].show = false;
            } else {
                dialog.widgets['friend_bar'].widgets['add_friend_button6'].show = false;
                dialog.widgets['friend_bar'].widgets['friend_icon6'].show = true;
            }

            dialog.widgets['friend_bar'].user_data['friend_bar_pos'] = 0;
            dialog.widgets['friend_bar'].user_data['popout'] = null; // reference to popout dialog

            scroll_friend_bar(dialog.widgets['friend_bar'], -1);
            var friend_bar_scroller = function(_incr) { return function(w) {
                scroll_friend_bar(w.parent, w.parent.user_data['friend_bar_pos']+_incr);
            }; };
            dialog.widgets['friend_bar'].widgets['scroll_left'].onclick = friend_bar_scroller(-1);
            dialog.widgets['friend_bar'].widgets['scroll_right'].onclick = friend_bar_scroller(1);

            dialog.widgets['friend_bar'].show = read_predicate(gamedata['client']['friend_bar_enabled']).is_satisfied(player, null);

            dialog.widgets['friend_bar'].user_data['transition_start_time'] = -1;
            dialog.widgets['friend_bar'].user_data['maximized'] = !('friend_bar_minimized' in player.preferences && player.preferences['friend_bar_minimized']);

            dialog.widgets['grow_toggle'].onclick = function(w) {
                var dialog = w.parent;
                dialog.widgets['friend_bar'].user_data['maximized'] = !dialog.widgets['friend_bar'].user_data['maximized'];

                player.preferences['friend_bar_minimized'] = !dialog.widgets['friend_bar'].user_data['maximized'];
                send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);

                dialog.widgets['friend_bar'].user_data['transition_start_time'] = client_time;
                if(dialog.widgets['friend_bar'].user_data['popout']) { close_dialog(dialog.widgets['friend_bar'].user_data['popout']); }
            };

            dialog.widgets['friend_bar'].ondraw = update_friend_bar;

            dialog.widgets['store_jewel'].user_data['count'] =
                dialog.widgets['you_have_mail_jewel'].user_data['count'] =
                dialog.widgets['buildings_jewel'].user_data['count'] = 0;
            dialog.widgets['store_jewel'].ondraw =
                dialog.widgets['you_have_mail_jewel'].ondraw =
                dialog.widgets['buildings_jewel'].ondraw = update_notification_jewel;
        }
    } else {
        dialog.widgets['home_button'].onclick = visit_base_home;
        dialog.widgets['home_button'].str = dialog.data['widgets']['home_button']['ui_name'+(session.using_squad_deployment() ? '_squads' : '')];

        // dynamically set up unit deployment bar
        var d = new SPUI.Dialog(gamedata['dialogs']['unit_deployment_bar_'+(gamedata['unit_deploy_style'] || 'batch')]);
        if(gamedata['unit_deploy_style'] == 'drip') {
            d.user_data['drip_unit'] = null; // which unit is currently selected
        } else if(gamedata['unit_deploy_style'] == 'squad') {
            d.user_data['selected_squad_id'] = null; // which squad_id is currently selected
        }
        dialog.add(d); dialog.widgets['unit_deployment_bar'] = d;
    }

    // attack button dialog
    if(!session.home_base) {
        var attack_button_dialog = new SPUI.Dialog(gamedata['dialogs']['attack_button_dialog']);
        desktop_dialogs['attack_button_dialog'] = attack_button_dialog;
        attack_button_dialog.ondraw = update_attack_button_dialog;
        SPUI.root.add_before(root_next, attack_button_dialog);
    }

    // chat frame
    if(!global_chat_frame) {
        global_chat_frame = init_chat_frame();
        desktop_dialogs['chat_frame'] = global_chat_frame;
    }

    if(session.home_base && !session.has_attacked) {
        SPUI.root.add_before(root_next, global_chat_frame);
        global_chat_frame.show = (player.tutorial_state === "COMPLETE");

        if(player.tutorial_state === "COMPLETE" && player.get_any_abtest_value('enable_desktop_quest_bar', gamedata['client']['enable_desktop_quest_bar'])) {
            QuestBar.init();
        }
    }

}

function update_notification_jewel(dialog) {
    // for jewel display: "text", a string, overrides "count", a number
    var text = dialog.user_data['text'] || null;
    var count = dialog.user_data['count'] || 0;
    dialog.widgets['num_bg'].show = dialog.widgets['num'].show = (count || text);
    if(dialog.widgets['num'].show) {
        dialog.widgets['num'].str = text || pretty_print_number(count);
        var suffix = (count >= 100 ? '_wide100' : (count >= 10 ? '_wide10' : ''));
        dialog.widgets['num_bg'].xy = dialog.widgets['num_bg'].data['xy' + suffix];
        dialog.widgets['num_bg'].wh = dialog.widgets['num_bg'].data['dimensions' + suffix];
    }
}

function scroll_friend_bar(dialog, page) {
    if(!dialog.parent) { return; } // orphaned

    if(page === -1) {
        page = dialog.user_data['friend_bar_pos'];
    } else {
        dialog.user_data['friend_bar_pos'] = page;
    }

    // remove popout
    if(dialog.user_data['popout']) {
        close_dialog(dialog.user_data['popout']);
    }

    // make list of real human friends
    var friend_list_hi = []; // >= level 3
    var friend_list_lo = []; // < level 3
    for(var i = 0; i < player.friends.length; i++) {
        var friend = player.friends[i];
        if(friend.is_ai() || !friend.is_real_friend) {
            continue;
        }
        if(friend.get_player_level() >= 3) {
            friend_list_hi.push(friend);
        } else {
            friend_list_lo.push(friend);
        }
    }

    // sort high-level list by player level (HIGH TO LOW)
    friend_list_hi.sort(Friend.compare_by_player_level);

    friend_list_lo.sort(Friend.compare_by_player_level);

    /*
    // sort low-level list by login time (recent to old) XXX needs PlayerCache info
    friend_list_lo.sort(function (a,b) {
        if(a.last_login_time > b.last_login_time) {
            return -1;
        } else if(a.last_login_time < b.last_login_time) {
            return 1;
        } else {
            return 0;
        }
    });
    */

    // only show first 10 people of low level
    var friend_list = friend_list_hi;
    for(var i = 0; i < Math.min(10, friend_list_lo.length); i++) {
        friend_list.push(friend_list_lo[i]);
    }

    // now fill in the dialog widgets
    var row = 0;
    var rows_per_page = dialog.data['widgets']['friend_icon']['array'][0]-1; // how many rows show up on each page

    var chapter_friends = friend_list.length; // total number of friends in this chapter

    // how many pages are in this chapter
    var chapter_pages = Math.floor((chapter_friends+rows_per_page-1)/rows_per_page);

    // reset the page index if it's out of bounds
    dialog.user_data['friend_bar_pos'] = page = (chapter_pages === 0 ? 0 : clamp(page, 0, chapter_pages-1));

    if(chapter_pages > 0) {
        // if any friends are to be shown

        // indices of the first and last friends able to be shown in the page
        var first_friend_on_page = page * rows_per_page;
        var last_friend_on_page = (page+1)*rows_per_page - 1;
        last_friend_on_page = Math.max(0, Math.min(last_friend_on_page, chapter_friends-1));

        // on click for friend button
        var click_cbmaker = function(uid, fbid, friend) { return function(w) {
            var friend_bar = w.parent;
            if(friend_bar.user_data['popout']) {
                    if(friend_bar.user_data['popout'].user_data['user_id'] == uid) {
                        // popout already up - visit base
                        visit_base(uid);
                        return;
                    } else {
                        close_dialog(friend_bar.user_data['popout']);
                    }
            }

            // spawn popout
            change_selection_ui(null);
            var dialog_data = gamedata['dialogs']['friend_bar_popout'];
            var dialog = new SPUI.Dialog(dialog_data);
            dialog.user_data['dialog'] = 'friend_bar_popout';
            dialog.user_data['user_id'] = uid;
            dialog.user_data['fbid'] = fbid;
            dialog.user_data['is_giftable'] = friend.is_giftable();
            selection.ui = dialog;
            SPUI.root.add(dialog);

            friend_bar.user_data['popout'] = dialog;
            dialog.on_destroy = (function (_friend_bar) { return function() { _friend_bar.user_data['popout'] = null; }; })(friend_bar);

            dialog.xy = vec_add(w.get_absolute_xy(), [-50, -161]);
            dialog.widgets['spy_button'].onclick = function(w) { visit_base(w.parent.user_data['user_id']); };

            dialog.widgets['gift_button'].show = player.resource_gifts_enabled();
            if(dialog.widgets['gift_button'].show) {
                if(dialog.user_data['is_giftable']) {
                    dialog.widgets['gift_button'].state = 'normal';
                    dialog.widgets['gift_button'].tooltip.str = null;
                    dialog.widgets['gift_button'].onclick = function(w) {
                        var uid = w.parent.user_data['user_id'];
                        change_selection_ui(null);
                        invoke_send_gifts(uid, 'friend_bar');
                    };
                } else if(player.get_any_abtest_value('ungiftable_fallback_to_invite', gamedata['client']['ungiftable_fallback_to_invite'])) {
                    dialog.widgets['gift_button'].state = 'normal';
                    dialog.widgets['gift_button'].tooltip.str = null;
                    dialog.widgets['gift_button'].onclick = function(w) {
                        change_selection_ui(null);
                        // ANY giftable friends?
                        player.get_giftable_friend_info_list_async(function (ret) {
                            if(ret.length > 0) {
                                invoke_send_gifts(null, 'friend_bar_fallback', ret);
                            } else {
                                var s = gamedata['errors']['NO_GIFTABLE_FRIENDS'];
                                var options = {'dialog': 'message_dialog_big'};
                                if(friend_invites_enabled()) {
                                    options['ok_button_ui_name'] = s['ui_button_invite'];
                                    options['cancel_button'] = false;
                                    options['on_ok'] = function() {
                                        invoke_invite_friends_dialog('ungiftable_fallback');
                                    };
                                }
                                invoke_child_message_dialog(s['ui_title'], s['ui_name'], options);
                            }
                        });
                    };
                } else {
                    dialog.widgets['gift_button'].state = 'disabled';
                    dialog.widgets['gift_button'].tooltip.str = dialog.data['widgets']['gift_button']['ui_tooltip_already_sent'];
                }
            }

            dialog.widgets['message_button'].show = (!!fbid && (spin_frame_platform == 'fb'));
            if(dialog.widgets['message_button'].show) {
                dialog.widgets['message_button'].onclick = function(w) {
                    var uid = w.parent.user_data['user_id'];
                    var fbid = w.parent.user_data['fbid'];
                    change_selection_ui(null);
                    invoke_facebook_message_dialog(fbid, uid);
                };
            }

            dialog.widgets['info_button'].onclick = function(w) {
                var uid = w.parent.user_data['user_id'];
                change_selection_ui(null);
                PlayerInfoDialog.invoke(uid);
            };

        }; };

        for(var i = first_friend_on_page; i <= last_friend_on_page; i++) {
            var friend = friend_list[i];
            var widget = dialog.widgets['friend_icon'+row.toString()];
            widget.show = true;
            widget.set_user(friend.user_id);
            widget.onclick = click_cbmaker(friend.user_id, friend.get_facebook_id(), friend);
            dialog.widgets['add_friend_button'+row.toString()].show = false;
            row += 1;
        }
    }

    // clear out empty rows
    while(row < rows_per_page) {
        dialog.widgets['add_friend_button'+row.toString()].show = friend_invites_enabled();
        dialog.widgets['friend_icon'+row.toString()].show = !dialog.widgets['add_friend_button'+row.toString()].show;
        dialog.widgets['friend_icon'+row.toString()].onclick = null;
        dialog.widgets['friend_icon'+row.toString()].set_user(null);
        row += 1;
    }

    // set clickability of scroll arrows
    if(page != 0) {
        dialog.widgets['scroll_left'].state = 'normal';
    } else {
        dialog.widgets['scroll_left'].state = 'disabled';
    }

    if(page < (chapter_pages-1)) {
        dialog.widgets['scroll_right'].state = 'normal';
    } else {
        dialog.widgets['scroll_right'].state = 'disabled';
    }

};

function update_friend_bar(dialog) {
    if(!dialog.parent) { return; } // dialog was closed

    var t = (dialog.user_data['transition_start_time'] > 0 ? clamp((client_time - dialog.user_data['transition_start_time']) / dialog.data['transition_time'], 0, 1) : 1);
    var base_xy_max = vec_add(dialog.parent.data['widgets']['friend_bar']['xy'], dialog.data['xy']);
    var base_xy_min = vec_add(dialog.parent.data['widgets']['friend_bar']['xy'], dialog.data['xy_minimized']);
    dialog.xy = vec_floor(vec_lerp(dialog.user_data['maximized'] ? base_xy_min : base_xy_max,
                                   dialog.user_data['maximized'] ? base_xy_max : base_xy_min, t));

    // flashing "+Add" button row
    if(player.get_townhall_level() < 5 && !invite_friends_dialog_shown_this_session) {
        for(var row = 0; row < dialog.data['widgets']['add_friend_button']['array'][0]; row++) {
            var w = dialog.widgets['add_friend_button'+row.toString()];
            if(w.show && w.state !== 'disabled' && 'text_color_emphasis' in w.data) {
                var period = 10.0, duration = 0.3, offset = row * 0.1;
                var anim_t = ((client_time-offset) % period);
                var col_v = (anim_t < duration ? w.data['text_color_emphasis'] : w.data['text_color']);
                w.text_color = SPUI.make_colorv(col_v);
            }
        }
    }
}

function invoke_player_portrait_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['player_portrait_dialog']);
    dialog.widgets['player_portrait'].set_user(session.user_id);
    dialog.widgets['player_name'].onclick =
        dialog.widgets['player_portrait'].onclick = function() {
            if(player.tutorial_state != "COMPLETE") { return; }
            change_selection(null);
            PlayerInfoDialog.invoke(session.user_id);
        };
    dialog.ondraw = update_player_portrait_dialog;
    return dialog;
}

function invoke_enemy_portrait_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['enemy_portrait_dialog']);
    if(!dialog.widgets['enemy_portrait'].user_id) {
        dialog.widgets['enemy_portrait'].set_user(session.viewing_user_id);
        if(session.viewing_ai) {
            dialog.widgets['enemy_portrait'].tooltip.str = ''; // get rid of Player Info tooltip for AIs
        }

        dialog.widgets['enemy_name'].onclick =
            dialog.widgets['enemy_portrait'].onclick = function() {
                if(player.tutorial_state != "COMPLETE" || session.viewing_ai || session.has_attacked) { return; }
                change_selection(null);
                PlayerInfoDialog.invoke(session.viewing_user_id);
            };
    }
    dialog.ondraw = update_enemy_portrait_dialog;
    return dialog;
}

// update the small trophy counter displayed on yourself (who="player") or enemy (who="enemy") portrait dialogs
function update_portrait_trophy_widgets(dialog, who) {
    var show_it = player.is_ladder_player() || (player.current_trophy_pve_challenge_togo() > 0) || player.current_trophy_pvp_challenge_name();
    if(who == 'enemy' && (session.viewing_user_id == session.user_id || (session.viewing_ai && !session.is_ladder_battle()))) {
        show_it = false;
    }

    dialog.widgets[who+'_trophy_icon'].show = dialog.widgets[who+'_trophy_count'].show = show_it;
    if(!show_it) { return; }

    var trophy_type = (player.is_ladder_player() || player.current_trophy_pvp_challenge_name() ? 'pvp' : 'pve');
    var ui_trophy_type = gamedata['events'][(trophy_type == 'pvp' ? 'challenge_pvp_ladder' : player.current_trophy_pve_challenge_name())]['ui_name'];
    dialog.widgets[who+'_trophy_icon'].state = trophy_type;

    var count = 0;
    if(who == 'player') {
        var player_data = PlayerCache.query_sync(session.user_id);
        if(player_data && (('trophies_'+trophy_type) in player_data)) {
            count = player_data['trophies_'+trophy_type];
        }
    } else {
        // XXX if(session.viewing_ai && session.is_ladder_battle()) { ... do some adjustment? }
        var enemy_data = PlayerCache.query_sync(session.viewing_user_id);
        if(enemy_data && (('trophies_'+trophy_type) in enemy_data)) {
            count = enemy_data['trophies_'+trophy_type];
        }
    }

    var togo;
    if(trophy_type === 'pvp') {
        if(gamedata['matchmaking']['ladder_point_frequency'] === 'season') {
            togo = -1;
        } else {
            togo = player.current_trophy_pvp_challenge_togo();
        }
    } else {
        togo = player.current_trophy_pve_challenge_togo();
    }
    var display_count = display_trophy_count(count, trophy_type);

    dialog.widgets[who+'_trophy_count'].str = pretty_print_number(display_count);
    dialog.widgets[who+'_trophy_count'].text_color = (display_count >= 0 ? SPUI.default_text_color : SPUI.error_text_color);
    dialog.widgets[who+'_trophy_count'].tooltip.str = dialog.data['widgets'][who+'_trophy_count']['ui_tooltip'].replace('%d',dialog.widgets[who+'_trophy_count'].str).replace('%type', ui_trophy_type);
    if(togo > 0) {
        dialog.widgets[who+'_trophy_count'].tooltip.str += dialog.data['widgets'][who+'_trophy_count']['ui_tooltip_expiry'].replace('%expiry', gamedata['strings']['trophies_expire_in']).replace('%s', pretty_print_time_brief(togo));
    }

    // clicking on the trophy count brings up (in order of availability):
    // 1) Top Alliances tab, if an alliance PvP tournament is going on
    // 2) Leaderboard, PvP page
    // 3) nothing
    var trophy_cb = null;
    if(player.use_trophies()) {
        trophy_cb = function(w) {
            change_selection_ui(null);
            var d = _invoke_alliance_dialog();
            if(d) { alliance_list_change_tab(d, 'top'); }
        }
    } else if(read_predicate(gamedata['strings']['leaderboard']['categories']['trophies_pvp']['leaderboard_show_if']).is_satisfied(player,null)) {
        trophy_cb = function(w) {
            change_selection_ui(null);
            invoke_leaderboard(gamedata['matchmaking']['ladder_point_frequency'], 'all', 'trophies_pvp');
        }
    }

    dialog.widgets[who+'_trophy_count'].onclick = dialog.widgets[who+'_trophy_icon'].onclick = trophy_cb;
}


function update_player_portrait_dialog(dialog) {
    var convention = gamedata['client']['visiting_portrait_convention'] || 'both_players';
    var placement = null;

    if(convention == 'both_players') {
        // always show in upper-left
        placement = 'top_left';
    } else if(convention == 'base_owner') {
        if(session.viewing_base.base_landlord_id == session.user_id) {
            // show in upper-left
            placement = 'top_left';
        }
        // otherwise, not our base
    } else {
        throw Error('unhandled visiting_portrait_convention ' + convention);
    }

    if(placement == 'top_left') {
        var anchor = gamedata['client']['player_portrait_anchor'] || 'desktop_top';
        if(anchor == 'desktop_top') {
            dialog.xy = vec_add(get_shifted_console_position(), dialog.data['xy_desktop_top']);
        } else if(anchor == 'canvas_edge') {
            dialog.xy = vec_add([0,0], dialog.data[(global_chat_frame.is_visible() ? 'xy_with_chat' : 'xy')]);
        } else {
            throw Error('unhandled player_portrait_anchor '+anchor);
        }
    } else {
        dialog.show = false; return;
    }

    dialog.widgets['player_name'].str = player.get_ui_name();
    dialog.widgets['player_level'].str = dialog.widgets['player_level'].data['ui_name'].replace('%d', player.resource_state['player_level'].toString());
    dialog.widgets['player_name'].state = dialog.widgets['player_portrait'].state = (session.has_attacked ? 'disabled' : 'normal');
    dialog.widgets['player_portrait'].tooltip.str = (session.has_attacked ? null : dialog.data['widgets']['player_portrait']['ui_tooltip']);

    // display trophy counts
    update_portrait_trophy_widgets(dialog, 'player');

    // XP amount
    var next_level = player.resource_state['player_level']+1;
    var data = gamedata['player_xp']['level_xp'];
    var next_xp, next_xp_text, progress;
    if(next_level < data.length) {
        next_xp = data[next_level];
        next_xp_text = pretty_print_number(next_xp);
        var last_xp = data[next_level-1];
        progress = (player.resource_state['xp']-last_xp)/(next_xp-last_xp);
    } else {
        // exceeded max level!
        next_xp = -1;
        next_xp_text = '-';
        progress = 1;
    }
    var xp_text = pretty_print_number(player.resource_state['xp']);
    dialog.widgets['player_level'].tooltip.str =
        dialog.data['widgets']['player_level']['ui_tooltip'].replace('%s1', xp_text).replace('%s2', next_xp_text);

    dialog.widgets['player_xp_bar'].progress = progress;

    // flash effect
    var flashy_loot = player.flashy_loot();
    var t = (client_time - player.last_xp_time)/gamedata['client']['xp_bar_flash_duration'];
    var wdata = dialog.data['widgets']['player_xp_bar'];
    var col = wdata['full_color'];
    if(!flashy_loot || t >= 1) {
        t = 1;
        player.last_resource_state['xp'] = player.resource_state['xp'];
    } else if(t > 0) {
        var amp = Math.exp(-5*(t-0.2)*(t-0.2));
        var col0 = wdata['full_color'], col1 = wdata['flash_color'];
        col = [col0[0] + amp*(col1[0]-col0[0]),
               col0[1] + amp*(col1[1]-col0[1]),
               col0[2] + amp*(col1[2]-col0[2]),
               col0[3] + amp*(col1[3]-col0[3])];
    }
    dialog.widgets['player_xp_bar'].full_color = new SPUI.Color(col[0], col[1], col[2], col[3]);
}

function update_enemy_portrait_dialog(dialog) {
    var convention = gamedata['client']['visiting_portrait_convention'] || 'both_players';

    if(convention == 'both_players') {
        // always show in upper-right
        var anchor = gamedata['client']['player_portrait_anchor'] || 'desktop_top';
        if(anchor == 'canvas_edge') {
            dialog.xy = vec_add([canvas_width,0], dialog.data['xy_top_right']);
        } else {
            dialog.xy = vec_add(get_shifted_console_position(), dialog.data['xy_desktop_top']);
        }
    } else if(convention == 'base_owner') {
        // always show in upper-left
        dialog.xy = vec_add([0,0], dialog.data['xy_top_left']);
    } else {
        throw Error('unhandled visiting_portrait_convention ' + convention);
    }

    var enemy_name = session.ui_name;
    var max_len = dialog.data['widgets']['enemy_name']['max_len'];
    if(enemy_name.length > max_len) {
        enemy_name = enemy_name.slice(0,max_len)+'...';
    }
    dialog.widgets['enemy_name'].str = (anon_mode ? ANON_NAME2 : enemy_name);
    dialog.widgets['enemy_level'].str = dialog.widgets['enemy_level'].data['ui_name'].replace('%d',enemy.resource_state['player_level'].toString());
    dialog.widgets['enemy_name'].state = (session.has_attacked ? 'disabled' : 'normal');
    dialog.widgets['enemy_portrait'].tooltip.str = (session.has_attacked || session.viewing_ai ? null : dialog.data['widgets']['enemy_portrait']['ui_tooltip']);

    update_portrait_trophy_widgets(dialog, 'enemy');
}

// update the resource loot bars on the enemy player
// note: fancy flashing and dynamic movement not implemented
function update_enemy_resource_bars(dialog) {
    dialog.show = session.enable_combat_resource_bars && !!session.res_looter && session.viewing_base.base_type != 'squad';
    if(!dialog.show) { return; }

    var convention = gamedata['client']['visiting_portrait_convention'] || 'both_players';

    if(convention == 'both_players') {
        // anchor below enemy portrait at top-right
        dialog.xy = vec_add([canvas_width,0], dialog.data['xy_top_right_under_portrait']);
    } else if(convention == 'base_owner') {
        // always show in top-right
        dialog.xy = vec_add([canvas_width,0], dialog.data['xy_top_right']);
    } else {
        throw Error('unhandled visiting_portrait_convention ' + convention);
    }

    var starting = session.res_looter['starting'];
    var cur = session.res_looter['cur'];

    // resource fullness progress bars
    for(var res in gamedata['resources']) {
        var resdata = gamedata['resources'][res];
        var disp = cur[res] || 0;
        var show_me = (disp > 0) && (!('show_if' in resdata) || read_predicate(resdata['show_if']).is_satisfied(player,null));
        goog.array.forEach(['', '_prog', '_icon', '_amount'], function(w) {
            if('resource_bar_'+res+w in dialog.widgets) {
                dialog.widgets['resource_bar_'+res+w].show = show_me;
            }
        });
        if('resource_bar_'+res+'_amount' in dialog.widgets) {
            dialog.widgets['resource_bar_'+res+'_amount'].str = pretty_print_number(disp);
            dialog.widgets['resource_bar_'+res+'_amount'].text_scale = 1;
        }
        if('resource_bar_'+res+'_prog' in dialog.widgets) {
            dialog.widgets['resource_bar_'+res+'_prog'].full_color = SPUI.make_colorv(gamedata['resources'][res]['bar_full_color']);
            dialog.widgets['resource_bar_'+res+'_prog'].progress = Math.min(1, disp/starting[res]);
        }
        if(('resource_bar_'+res in dialog.widgets) && dialog.widgets['resource_bar_'+res].tooltip) {
            dialog.widgets['resource_bar_'+res].tooltip.str = dialog.data['widgets']['resource_bar_'+res]['ui_tooltip'].replace('%RES', resdata['ui_name']);
        }
    }
}

// update resource displays for desktop dialogs and the Store, with fancy ticker effects
/** @param {SPUI.Dialog} dialog
    @param {boolean} primary - if true, then apply the magnetic attractors for loot burst particle effects (only main desktop should have this)
    @param {boolean} use_res_looter - if true, reference session.res_looter instead of player resource state
    @param {boolean} show_during_combat */
function update_resource_bars(dialog, primary, use_res_looter, show_during_combat) {
    var flashy_loot = player.flashy_loot();
    var currency = (player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks' ? 'gamebucks' : 'facebook_credits');

    // overall hide/show
    goog.array.forEach(goog.object.getKeys(gamedata['resources']).concat(['fbcredits']), function(res) {
        if('resource_bar_'+res in dialog.widgets) {
            var show_me, show_button, show_button_asset;
            if(res == 'fbcredits') {
                show_me = show_during_combat || !session.has_attacked;
                show_button = show_me;
                show_button_asset = show_button;
                if(currency == 'gamebucks') {
                    dialog.widgets['resource_bar_'+res+'_icon'].asset = player.get_any_abtest_value('gamebucks_resource_icon', gamedata['store']['gamebucks_resource_icon']);
                } else {
                    dialog.widgets['resource_bar_'+res+'_icon'].asset = 'resource_icon_fbcredits';
                }
            } else {
                var resdata = gamedata['resources'][res];
                show_me = (show_during_combat || !session.has_attacked) && (!('show_if' in resdata) || read_predicate(resdata['show_if']).is_satisfied(player,null));
                show_button = show_me && !session.has_attacked;
                show_button_asset = show_button && (!('allow_instant' in resdata) || resdata['allow_instant']);
                dialog.widgets['resource_bar_'+res+'_icon'].asset = resdata['icon_small'];
            }
            goog.array.forEach(['', '_prog', '_icon', '_button', '_amount'], function (w) {
                if('resource_bar_'+res+w in dialog.widgets) {
                    dialog.widgets['resource_bar_'+res+w].show = (w == '_button' ? show_button : show_me);
                    if(w == '_button' && !show_button_asset) {
                        dialog.widgets['resource_bar_'+res+w].bg_image = null; // blank out the button, but still show it
                    }
                }
            });
            if('resource_bar_'+res+'_button' in dialog.widgets && show_me) {
                var button_state = (player.tutorial_state === "COMPLETE") ? 'normal':'disabled';
                if(res == 'fbcredits') {
                    // if purchase UI is disabled, then show the button grayed-out
                    var pred = gamedata['store']['buy_gamebucks_dialog_enable_if'] || null;
                    if(pred && !read_predicate(pred).is_satisfied(player)) {
                        button_state = 'disabled_clickable';
                    }
                    // but always connect the callback - this will show predicate helper if purchase UI is disabled
                    dialog.widgets['resource_bar_'+res+'_button'].onclick =
                        dialog.widgets['resource_bar_'+res+'_icon'].onclick =
                        dialog.widgets['resource_bar_'+res].onclick =
                        Store.get_balance_plus_cb();
                } else {
                    dialog.widgets['resource_bar_'+res+'_button'].onclick =  (function (_res) { return function(w) {
                        if(w.parent) { w.parent.onleave(); } // get rid of tooltips
                        if(('allow_instant' in gamedata['resources'][_res]) && !gamedata['resources'][_res]['allow_instant']) {
                            var helper = get_requirements_help(_res, 1);
                            if(helper) { helper(); }
                        } else {
                            invoke_store(_res);
                        }
                    }; })(res);
                }
                dialog.widgets['resource_bar_'+res+'_button'].state = button_state;
            }
        }
    });

    // SPFX physics attractors for loot burst effects
    if(primary && player.get_any_abtest_value('enable_loot_burst_effects', gamedata['client']['enable_loot_burst_effects']) && session.viewing_base) {
        for(var res in gamedata['resources']) {
            if('resource_bar_'+res+'_prog' in dialog.widgets) {
                if(!dialog.user_data[res+'_magnet']) {
                    var props = goog.object.clone(gamedata['client']['vfx']['resource_burst_magnet']);
                    props['charge'] = res;
                    dialog.user_data[res+'_magnet'] = session.get_draw_world().fxworld.add_visual_effect_at_time([0,0],0,[0,1,0],client_time, props, false, null);
                    props = goog.object.clone(gamedata['client']['vfx']['resource_burst_drag']);
                    props['charge'] = res;
                    dialog.user_data[res+'_drag'] = session.get_draw_world().fxworld.add_visual_effect_at_time([0,0],0,[0,1,0],client_time, props, false, null);
                }
                var magnet_pos_canvas = vec_add(dialog.xy, vec_add(dialog.widgets['resource_bar_'+res+'_prog'].xy, vec_scale(0.5, dialog.widgets['resource_bar_'+res+'_prog'].wh)));
                var magnet_pos_ortho = screen_to_ortho(magnet_pos_canvas); // projection of point at altitude=0
                var fake_alt = 20; // fake the magnet being "at altitude" above the ground
                dialog.user_data[res+'_magnet'].pos = [magnet_pos_ortho[0] + (10/15)*fake_alt, fake_alt, magnet_pos_ortho[1] + (10/15)*fake_alt];
            }
        }
    }

    // "resource_t" interpolates displayed resource values from old to new,
    // and controls the text-grow and ticker effect (but not the flashes)
    // use shorter ticker effects when gradual looting is happening
    var ticker_duration = ((session.has_attacked && gamedata['gradual_loot'] > 0) ? 0.1 : 1) * gamedata['client']['resource_ticker_duration'];
    var resource_t = (client_time - player.last_resource_time)/ticker_duration;
    if(resource_t >= 1) {
        resource_t = 1;
        player.last_resource_time = -1;
        for(var res in gamedata['resources']) {
            player.last_resource_state[res] = player.resource_state[res][1];
            session.last_loot[res] = session.loot[res] || 0;
            if(session.res_looter) {
                session.last_looted_uncapped[res] = session.res_looter['looted_uncapped'][res] || 0;
            }
        }
    } else if(resource_t < 0) {
        resource_t = 0;
    }

    var credits_t = (client_time - player.last_credits_time)/gamedata['client']['resource_ticker_duration'];
    if(credits_t >= 1) {
        credits_t = 1;
        player.last_credits_time = -1;
    } else if(credits_t < 0) {
        credits_t = 0;
    }

    var resource_text_scale = 1, credits_text_scale = 1;
    var PEAK = gamedata['client']['resource_ticker_grow_peak'];
    var GROW_AMOUNT = gamedata['client']['resource_ticker_grow_amount'];
    var SPEED = gamedata['client']['resource_ticker_decay_speed'];
    if(flashy_loot && !SPUI.low_fonts && resource_t > 0 && resource_t < 1) {
        var amp = Math.exp(-SPEED*(resource_t-PEAK)*(resource_t-PEAK));
        resource_text_scale = 1 + amp*(GROW_AMOUNT-1.0);
    }
    if(flashy_loot && !SPUI.low_fonts && credits_t > 0 && credits_t < 1) {
        var amp = Math.exp(-SPEED*(credits_t-PEAK)*(credits_t-PEAK));
        credits_text_scale = 1 + amp*(GROW_AMOUNT-1.0);
    }

    // resource bar flashes (both main resources at home and looted resources in attacks)
    var glow_credits = 0;
    var glow_res = {}; for(var res in gamedata['resources']) { glow_res[res] = 0; }
    if(flashy_loot && ((session.home_base && !session.has_attacked) || (!session.home_base && session.has_attacked && !(gamedata['gradual_loot']>0)))) {
        var t_credits = (player.flash_credits_time > 0 ? (client_time - player.flash_credits_time)/gamedata['client']['harvest_flash_time'] : 0);
        if(t_credits > 0 && t_credits < 1) {
            glow_credits = Math.sin(1*Math.PI*gamedata['client']['harvest_flash_count']*t_credits);
        } else if(t_credits >= 1) {
            player.flash_credits_time = -1;
        }
        for(var res in gamedata['resources']) {
            var t_res = (player.flash_res_time[res] > 0 ? (client_time - player.flash_res_time[res])/gamedata['client']['harvest_flash_time'] : 0);
            if(t_res > 0 && t_res < 1) {
                glow_res[res] = Math.sin(1*Math.PI*gamedata['client']['harvest_flash_count']*t_res);
            } else if(t_res >= 1) {
                player.flash_res_time[res] = -1; // reset effect
            }
        }
    }

    for(var res in gamedata['resources']) {
        if('resource_bar_'+res+'_glow' in dialog.widgets) {
            dialog.widgets['resource_bar_'+res+'_glow'].show = true;
            dialog.widgets['resource_bar_'+res+'_glow'].alpha = glow_res[res]*glow_res[res];
        }
    }

    if('resource_bar_fbcredits_glow' in dialog.widgets) {
        dialog.widgets['resource_bar_fbcredits_glow'].alpha = glow_credits*glow_credits;
    }

    // resource amounts - this is a little complicated to do the running-ticker effect
    var old_res = {}, cur_res = {};
    var capacity = {};

    for(var res in gamedata['resources']) {
        if(session.home_base) { // normal resource display
            capacity[res] = player.resource_state[res][0];
            old_res[res] = player.last_resource_state[res]
            cur_res[res] = player.resource_state[res][1];
        } else {
            if(use_res_looter) { // display uncapped looted amount vs. starting looot amount available
                old_res[res] = session.last_looted_uncapped[res] || 0;
                cur_res[res] = session.res_looter['looted_uncapped'][res] || 0;
                capacity[res] = session.res_looter['starting'][res] || 0;
            } else { // display capped looted amount vs. home base storage
                old_res[res] = session.last_loot[res] || 0;
                cur_res[res] = session.loot[res] || 0;
                capacity[res] = player.resource_state[res][0];
            }
        }
    }

    if(session.home_base) {
        if('resource_bar_fbcredits_amount' in dialog.widgets) {
            var old_credits = player.last_resource_state[currency];
            var cur_credits = player.resource_state[currency];

            if(cur_credits >= 0 || currency == 'gamebucks') {
                var disp_credits = (old_credits >= 0 ? Math.floor(old_credits + credits_t * (cur_credits - old_credits)) : cur_credits);
                // special hack - do not show fractional gamebucks amounts while ticking
                if(currency == 'gamebucks' && credits_t > 0 && credits_t < 1) {
                    var divisor = player.get_any_abtest_value('gamebucks_display_divisor', gamedata['store']['gamebucks_display_divisor']);
                    if(divisor != 1) {
                        disp_credits = divisor * Math.floor(disp_credits/divisor);
                    }
                }

                dialog.widgets['resource_bar_fbcredits_amount'].str = Store.display_user_currency_amount(disp_credits, 'compact');
                dialog.widgets['resource_bar_fbcredits_amount'].text_scale = (cur_credits <= old_credits) ? 1 : credits_text_scale;
            } else {
                dialog.widgets['resource_bar_fbcredits_amount'].str = '?'; // no data available
                dialog.widgets['resource_bar_fbcredits_amount'].text_scale = 1;
            }
        }
    }

    // resource fullness progress bars
    for(var res in gamedata['resources']) {
        var disp = Math.floor(old_res[res] + resource_t * (cur_res[res] - old_res[res]));
        if('resource_bar_'+res+'_amount' in dialog.widgets) {
            dialog.widgets['resource_bar_'+res+'_amount'].str = pretty_print_number(disp);
            dialog.widgets['resource_bar_'+res+'_amount'].text_scale = (cur_res[res] <= old_res[res]) ? 1 : resource_text_scale;
        }
        if('resource_bar_'+res+'_prog' in dialog.widgets) {
            var glow = glow_res[res];
            dialog.widgets['resource_bar_'+res+'_prog'].progress = Math.min(1, disp/Math.max(capacity[res],0.01));
            var wdata = dialog.data['widgets']['resource_bar_'+res+'_prog'];
            var amp = 0.33*glow*glow;
            var col0 = gamedata['resources'][res]['bar_full_color'], col1 = wdata['flash_color'];
            var col = [col0[0] + amp*(col1[0]-col0[0]),
                       col0[1] + amp*(col1[1]-col0[1]),
                       col0[2] + amp*(col1[2]-col0[2]),
                       col0[3] + amp*(col1[3]-col0[3])];
            dialog.widgets['resource_bar_'+res+'_prog'].full_color = SPUI.make_colorv(col);
        }
    }


    // token count update
    var shift = [0,0]; // shift other widgets over to make room
    if('resource_bar_tokens' in dialog.data['widgets']) {
        /** @type {Array<string>} */
        var token_names;
        if(gamedata['store']['show_item_quantity']) {
            token_names = eval_cond(gamedata['store']['show_item_quantity'], player, null) || [];
        } else {
            token_names = [];
        }

        for(var y = 0; y < dialog.data['widgets']['resource_bar_tokens']['array'][1]; y++) {
            for(var x = 0; x < dialog.data['widgets']['resource_bar_tokens']['array'][0]; x++) {
                var index = y * dialog.data['widgets']['resource_bar_tokens']['array'][0] + x;
                goog.array.forEach(['resource_bar_tokens','resource_bar_tokens_icon',
                                    'resource_bar_tokens_expire_icon',
                                    'resource_bar_tokens_amount'],
                                   function(wname) {
                                       dialog.widgets[SPUI.get_array_widget_name(wname, dialog.data['widgets'][wname]['array'], [x,y])].show = (index < token_names.length);
                                   });

                if(index < token_names.length) {
                    var spec = ItemDisplay.get_inventory_item_spec(token_names[index]);
                    var qty_expr = player.inventory_item_quantity_and_expiration(token_names[index]);
                    var qty = qty_expr[0], expr = qty_expr[1];
                    dialog.widgets[SPUI.get_array_widget_name('resource_bar_tokens_expire_icon', dialog.data['widgets']['resource_bar_tokens_expire_icon']['array'], [x,y])].show = (expr > 0);
                    dialog.widgets[SPUI.get_array_widget_name('resource_bar_tokens_icon', dialog.data['widgets']['resource_bar_tokens_icon']['array'], [x,y])].asset = spec['store_icon'];
                    dialog.widgets[SPUI.get_array_widget_name('resource_bar_tokens_amount', dialog.data['widgets']['resource_bar_tokens_amount']['array'], [x,y])].str = pretty_print_number(qty);
                    dialog.widgets[SPUI.get_array_widget_name('resource_bar_tokens', dialog.data['widgets']['resource_bar_tokens']['array'], [x,y])].tooltip.str = dialog.data['widgets']['resource_bar_tokens']['ui_tooltip'].replace('%d0', pretty_print_number(qty)).replace('%s1', spec['ui_name_plural'] || spec['ui_name']).replace('%s2', spec['ui_name_plural'] || spec['ui_name']).replace('%expire', (expr > 0 ? dialog.data['widgets']['resource_bar_tokens']['ui_tooltip_expire'].replace('%s', pretty_print_time(expr-server_time)) : ''));
                }
            }
        }
    }

    // tooltips
    if(1) {
        for(var res in gamedata['resources']) {
            if(('resource_bar_'+res in dialog.widgets) && dialog.widgets['resource_bar_'+res].tooltip) {
                var resdata = gamedata['resources'][res];
                dialog.widgets['resource_bar_'+res].tooltip.str = dialog.data['widgets']['resource_bar_'+res]['ui_tooltip'].replace('%d0',
                                                                                                                                    pretty_print_number(player.resource_state[res][0])).replace('%RES', resdata['ui_name']).replace('%STORAGES1', gamedata['buildings'][resdata['storage_building']]['ui_name_plural']).replace('%STORAGES2', gamedata['buildings'][resdata['storage_building']]['ui_name_plural']);
            }
        }

        if('resource_bar_fbcredits' in dialog.widgets) {
            dialog.widgets['resource_bar_fbcredits'].tooltip.str = Store.get_balance_tooltip();
            if(('fixed_tooltip_offset_'+currency) in dialog.data['widgets']['resource_bar_fbcredits']) {
                var tipoff = dialog.data['widgets']['resource_bar_fbcredits']['fixed_tooltip_offset_'+currency];
                dialog.widgets['resource_bar_fbcredits'].tooltip.xy = vec_add(shift, [dialog.xy[0]+tipoff[0], dialog.xy[1]+tipoff[1]]);
            }
        }
    }
}

function invoke_defensive_battle_bars() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['defensive_battle_bars']);
    dialog.ondraw = update_defensive_battle_bars;
    return dialog;
}
function update_defensive_battle_bars(dialog) {
    dialog.xy = dialog.data['xy']; // anchor to top-left

    // AI attack wave indicators
    var show_wave_indicators = false, show_next_wave = false, show_combat_timer = true;

    if(session.attack_finish_time > server_time && player.tutorial_state == "COMPLETE") {
        show_wave_indicators = true;
        if(session.incoming_attack_wave_time > 0) {
            show_next_wave = true;
            dialog.widgets['next_wave_time'].str = dialog.data['widgets']['next_wave_time']['ui_name'].replace('%s', pretty_print_time(session.incoming_attack_wave_time - server_time));
        } else {
            dialog.widgets['next_wave_time'].str = dialog.data['widgets']['next_wave_time']['ui_name_final'];
        }
        // show number of attackers destroyed/left
        var prog = session.incoming_attack_units_destroyed/Math.max(1, session.incoming_attack_units_total);
        dialog.widgets['wave_damage_prog'].progress = prog;
        dialog.widgets['wave_damage_amount'].str = Math.floor(100*prog).toFixed(0)+'%';
    }

    goog.array.forEach(['wave_damage_bar','wave_damage_prog','wave_damage_icon','wave_damage_amount'],
                       function (name) { dialog.widgets[name].show = show_wave_indicators; });
    goog.array.forEach([/*'next_wave_bar','next_wave_icon',*/ 'next_wave_time'],
                       function (name) { dialog.widgets[name].show = show_wave_indicators && show_next_wave; });

    // protection/attack time bar
    if(session.attack_finish_time > server_time) {
        // player is defending against an attack
        dialog.widgets['protection_time_icon'].asset = 'resource_icon_combat_time';
        var str = pretty_print_time(session.ui_attack_time_togo());
        dialog.widgets['protection_time_amount'].str = str;
        dialog.widgets['protection_time_bar'].tooltip.str = dialog.data['widgets']['protection_time_bar']['ui_tooltip_attack_ends_in'].replace('%s', str);
    } else if(session.incoming_attack_pending()) {
        // an attack is incoming on the player's home base
        if(player.tutorial_state != "COMPLETE") {
            dialog.widgets['protection_time_icon'].asset = 'resource_icon_combat_time';
            var str = pretty_print_time(session.incoming_attack_time - server_time);
            dialog.widgets['protection_time_amount'].str = str;
            dialog.widgets['protection_time_bar'].tooltip.str = dialog.data['widgets']['protection_time_bar']['ui_tooltip_incoming_attack'].replace('%s', str);
        } else {
            // "Evil Valentina"
            show_combat_timer = false;
        }
    } else {
        show_combat_timer = false;
    }

    dialog.widgets['protection_time_bar'].show =
        dialog.widgets['protection_time_icon'].show =
        dialog.widgets['protection_time_amount'].show = show_combat_timer;
}

function invoke_combat_damage_bar() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['combat_damage_bar']);
    dialog.transparent_to_mouse = true;
    dialog.user_data['base_damage_server'] = 0;
    dialog.user_data['base_damage_server_flags'] = {};
    dialog.user_data['base_damage_client_flags'] = {};
    dialog.user_data['base_damage_ping_pending'] = 0; // amount of base_damage client saw when last ping was sent
    dialog.user_data['base_damage_ping_send_time'] = 0;
    dialog.user_data['base_damage_ping_recv_time'] = 0;
    dialog.ondraw = update_combat_damage_bar;
    return dialog;
}
function update_combat_damage_bar(dialog) {
    var placement = gamedata['client']['combat_damage_bar_placement'] || 'top_left';
    if(placement == 'top_left') {
        dialog.xy = dialog.data['xy_'+placement];
    } else if(placement == 'bottom_right') {
        dialog.xy = vec_add([canvas_width,canvas_height], dialog.data['xy_'+placement]);
    } else {
        throw Error('unhnadled combat_damage_bar_placement '+placement);
    }

    goog.array.forEach(['damage_bar','damage_prog','damage_icon','damage_amount'], function(wname) {
        if(gamedata['client']['combat_resource_bars_transparent'] && !('battle_stars' in gamedata) && goog.array.contains(['damage_bar', 'damage_prog'], wname)) {
            dialog.widgets[wname].show = false;
        } else {
            dialog.widgets[wname].show = (session.viewing_base.base_type != 'squad');
        }
    });
    goog.array.forEach(['damage_prog_tick0','damage_prog_tick1','damage_prog_win'], function(wname) {
        dialog.widgets[wname].show = false;
    });

    dialog.widgets['battle_stars_bg'].show = dialog.widgets['base_damage_label'].show =('battle_stars' in gamedata);

    for(var i = 0; i < dialog.data['widgets']['battle_stars_star']['array'][0]; i++) {
        dialog.widgets['battle_stars_hole'+i.toString()].show = ('battle_stars' in gamedata);
        dialog.widgets['battle_stars_star'+i.toString()].show = ('battle_stars' in gamedata &&
                                                                  'battle_stars' in session.loot &&
                                                                  i < goog.object.getCount(session.loot['battle_stars']));
    }

    // fix up the CombatText offsets according to dialog placement
    var transform_text_offset = function(off) {
        return vec_mul(placement == 'bottom_right' ? [-1,-1] : [1,1], off);
    };

    var do_sound = false;
    var base_damage;
    if(session.viewing_base.base_type == 'squad') {
        base_damage = 0;
    } else {
        base_damage = calc_base_damage();
        dialog.widgets['damage_prog'].progress = base_damage;
        dialog.widgets['damage_amount'].str = Math.floor(100*base_damage).toFixed(0)+'%'; // (100.0*base_damage).toFixed(2)+'%';
        dialog.widgets['damage_amount'].text_color = ((base_damage < gamedata['matchmaking']['ladder_win_damage'] && session.is_ladder_battle() && (gamedata['matchmaking']['ladder_win_condition']||'base_damage')=='base_damage') ? SPUI.error_text_color : SPUI.default_text_color);
        if(session.is_ladder_battle() && (gamedata['matchmaking']['ladder_win_condition']||'base_damage') == 'base_damage') {
            var ticks = [];
            ticks.push({'progress':gamedata['matchmaking']['ladder_win_damage']});
            dialog.widgets['damage_prog_win'].show = true;
            dialog.widgets['damage_prog_win'].xy = [dialog.widgets['damage_prog'].xy[0]+Math.floor(gamedata['matchmaking']['ladder_win_damage']*dialog.widgets['damage_prog'].wh[0]),
                                                    dialog.data['widgets']['damage_prog_win']['xy'][1]];
            if('ladder_bonus_damage' in gamedata['matchmaking']) {
                goog.array.forEach(gamedata['matchmaking']['ladder_bonus_damage'], function(entry, i) {
                    if(entry[0] > 0) {
                        var w = dialog.widgets['damage_prog_tick'+i.toString()];
                        w.show = true; w.str = (1+entry[1]).toFixed(1)+'x';
                        w.xy = [dialog.widgets['damage_prog'].xy[0]+Math.floor(entry[0]*dialog.widgets['damage_prog'].wh[0]),
                                dialog.data['widgets']['damage_prog_tick']['xy'][1]];
                        ticks.push({'progress':entry[0]});
                    }
                });
                dialog.widgets['damage_bar'].tooltip.str = dialog.data['widgets']['damage_bar']['ui_tooltip_bonus'].replace('%WIN', (100*gamedata['matchmaking']['ladder_win_damage']).toString()).replace('%BONUS', (100*ticks[ticks.length-1]['progress']).toString());
            }
            dialog.widgets['damage_prog'].ticks = ticks;
        }
    }

    // reconcile base damage (and ladder/protection/stars that result from it) with server
    if(session.has_deployed && !visit_base_pending &&
       (session.viewing_base.base_landlord_id != session.user_id) && (session.viewing_base.base_type == 'home')) {

        var need_base_damage_ping_for_battle_star = -1; // base_damage threshold for most recent battle star client thinks it deserves

        if('battle_stars' in gamedata) {
            var i = 0;
            for(var name in gamedata['battle_stars']) {
                // these are confirmed by the server via session.loot, not the damage ping response

                // if we haven't received confirmation, and we think we deserve the star, ask server for it
                if(!session.loot['battle_stars'] || !session.loot['battle_stars'][name]) {
                    if(!dialog.user_data['battle_star_'+name+'_pending'] && read_predicate(gamedata['battle_stars'][name]).is_satisfied(player, null)) {
                        dialog.user_data['battle_star_'+name+'_pending'] = 1;
                        flush_dirty_objects({buildings_only:true, skip_check:true});
                        send_to_server.func(["CLAIM_BATTLE_STAR", name]);
                        if(gamedata['matchmaking']['ladder_win_condition']=='battle_stars') {
                            need_base_damage_ping_for_battle_star = base_damage;
                        }
                    }
                } else {
                    // server says we have it now, announce it if we haven't announced it yet
                    if(!dialog.user_data['battle_star_'+name+'_announced']) {
                        dialog.user_data['battle_star_'+name+'_announced'] = client_time;
                        do_sound = true;

                        session.get_real_world().combat_engine.log_annotation(new CombatEngine.BattleStarAnnotation(name));
                    }
                    // apply animation to the battle star
                    if(i < dialog.data['widgets']['battle_stars_star']['array'][0]) {
                        if(dialog.user_data['battle_star_'+name+'_announced']) {
                            var t = client_time - dialog.user_data['battle_star_'+name+'_announced'];
                            var duration = dialog.data['widgets']['battle_stars_star']['anim_time'];
                            var s = clamp(t/duration, 0, 1);
                            s = 1-Math.pow(1-s, 2);
                            var w = dialog.widgets['battle_stars_star'+i.toString()];
                            // fade in
                            w.alpha = clamp(s, 0, 1);
                            // size down and move into place
                            var scale = s*1+(1-s)*dialog.data['widgets']['battle_stars_star']['start_scale'];
                            var origin = dialog.data['widgets']['battle_stars_star']['zoom_origin'];
                            if(scale != 1) {
                                w.transform = [scale,0,
                                               0,scale,
                                               origin[0]+scale*(-origin[0]),
                                               origin[1]+scale*(-origin[1])];
                            } else {
                                w.transform = null;
                            }
                        }
                    }
                }
                i += 1;
            }
        }

        // figure out if we want to do a base damage ping

        // highest damage amount for which we have an acknowledged or in-flight request
        var last_request_damage = dialog.user_data['base_damage_ping_pending'];

        // highest damage amount we need to know about (critical thresholds for win, battle star, and protection)
        var want_damage = 0;
        if(base_damage >= 1) { want_damage = Math.max(want_damage, base_damage); }
        if(session.is_ladder_battle() && (base_damage >= gamedata['matchmaking']['ladder_win_damage'])) { want_damage = Math.max(want_damage, gamedata['matchmaking']['ladder_win_damage']); }
        goog.array.forEach(['ladder_bonus_damage', 'ladder_protection'], function(kind) {
            if(kind in gamedata['matchmaking']) {
                goog.array.forEach(gamedata['matchmaking'][kind], function(entry, i) {
                    if(entry[0] > 0) {
                        if(base_damage >= entry[0]) { want_damage = Math.max(want_damage, entry[0]); }
                    }
                });
            }
        });
        want_damage = Math.max(want_damage, need_base_damage_ping_for_battle_star);
        var is_out_of_sync = (Math.abs(base_damage - dialog.user_data['base_damage_server']) > 0.0001);

        if(last_request_damage < want_damage ||
           (is_out_of_sync && (client_time - dialog.user_data['base_damage_ping_send_time'] > gamedata['client']['base_damage_ping_interval']))) {

            // send ping request
            dialog.user_data['base_damage_ping_pending'] = base_damage;
            dialog.user_data['base_damage_ping_send_time'] = client_time;
            flush_dirty_objects({buildings_only:true, skip_check:true});
            var damaged_objects = null;
            if(gamedata['client']['base_damage_ping_detail']) {
                damaged_objects = do_calc_base_damage({detail:true})[1];
            }
            send_to_server.func(["PING_BASE_DAMAGE", session.viewing_base.base_id, base_damage, damaged_objects, session.viewing_base.power_state]);
            //console.log('last_request_damage '+last_request_damage.toString()+' want_damage '+want_damage.toString()+' base_damage '+base_damage.toString()+' out_of_sync '+is_out_of_sync.toString());
        }

        // show new base-damage-related state
        if(dialog.user_data['base_damage_server_flags']['is_ladder_win'] && !dialog.user_data['base_damage_client_flags']['is_ladder_win']) {
            dialog.user_data['base_damage_client_flags']['is_ladder_win'] = dialog.user_data['base_damage_server_flags']['is_ladder_win'];
            var points = dialog.user_data['base_damage_client_flags']['ladder_win_points'] = dialog.user_data['base_damage_server_flags']['ladder_win_points'];
            // note: this is the MAX point count for a win - it might need to be scaled down by base damage

            var trophy_type = (player.is_ladder_player() || player.current_trophy_pvp_challenge_name() ? 'pvp' : 'pve');
            var max_win = 0, min_win = 0, win_scale_by = null;
            goog.array.forEach(player.player_auras, function(aura) {
                var spec = gamedata['auras'][aura['spec']];
                var cons = spec['on_battle_end_victory'] || spec['on_battle_end_defeat'] || null;
                if(cons && cons['consequent'] == 'GIVE_TROPHIES' && cons['trophy_kind'] == trophy_type) {
                    var method = cons['method'] || '+';
                    var stack = ('stack' in aura ? aura['stack'] : 1);
                    if(method == '+') {
                        max_win += stack;
                        win_scale_by = cons['scale_by'] || null;
                        min_win = Math.max(min_win, cons['min_amount'] || 0);
                    }
                }
            });
            // points = max_win; ?
            if(win_scale_by == 'base_damage') {
                points = Math.floor(points * base_damage + 0.5);
                points = Math.max(points, min_win);
            }

            session.get_real_world().fxworld.add_ui(new SPFX.CombatText(vec_add(vec_add(dialog.xy, dialog.widgets['damage_prog'].xy), transform_text_offset(dialog.data['widgets']['damage_prog']['victory_text_offset'])), 0,
                                            gamedata['strings']['combat_messages']['ladder_victory'+(points==1 ? '':'_plural')].replace('%d', points.toString()),
                                            [1,1,0], session.get_real_world().fxworld.now_time(), 3.0,
                                            {drop_shadow: true, font_size: 21, text_style: "thick", is_ui: true}));
            do_sound = true;
        } else if((dialog.user_data['base_damage_server_flags']['ladder_win_points']||0) >
                  (dialog.user_data['base_damage_client_flags']['ladder_win_points']||0)) {
            var points = dialog.user_data['base_damage_server_flags']['ladder_win_points'] - (dialog.user_data['base_damage_client_flags']['ladder_win_points']||0);
            dialog.user_data['base_damage_client_flags']['ladder_win_points'] = dialog.user_data['base_damage_server_flags']['ladder_win_points'];
            session.get_real_world().fxworld.add_ui(new SPFX.CombatText(vec_add(vec_add(dialog.xy, dialog.widgets['damage_prog'].xy), transform_text_offset(dialog.data['widgets']['damage_prog']['victory_text_offset'])), 0,
                                            gamedata['strings']['combat_messages']['ladder_victory_bonus'+(points==1 ? '':'_plural')].replace('%d', points.toString()),
                                            [1,1,0], session.get_real_world().fxworld.now_time(), 3.0,
                                            {drop_shadow: true, font_size: 21, text_style: "thick", is_ui: true}));
            do_sound = true;
        }

        if((dialog.user_data['base_damage_server_flags']['ladder_protection']||0) >
           (dialog.user_data['base_damage_client_flags']['ladder_protection']||0)) {
            dialog.user_data['base_damage_client_flags']['ladder_protection'] = dialog.user_data['base_damage_server_flags']['ladder_protection'];
            var hours = dialog.user_data['base_damage_server_flags']['ladder_protection']/3600;
            session.get_real_world().fxworld.add_ui(new SPFX.CombatText(vec_add(vec_add(dialog.xy, dialog.widgets['damage_prog'].xy), transform_text_offset(dialog.data['widgets']['damage_prog']['protection_text_offset'])), 0,
                                            gamedata['strings']['combat_messages']['ladder_protection_granted'].replace('%s', hours.toFixed(0)),
                                            [1,1,0], session.get_real_world().fxworld.now_time(), 3.0,
                                            {drop_shadow: true, font_size: 19, text_style: "thick", is_ui: true}));
            do_sound = true;
        }
    }
    dialog.user_data['base_damage'] = base_damage; // XXXXXX nasty hack - save for later use by combat_resource_bars
    if(do_sound) { GameArt.play_canned_sound('success_playful_22');; }
}

function invoke_combat_resource_bars() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['combat_resource_bars']);
    dialog.transparent_to_mouse = true;
    dialog.ondraw = update_combat_resource_bars;
    return dialog;
}

var FORCE_BASE_DAMAGE_PING = false; // for debugging/profiling

function update_combat_resource_bars(dialog) {
    dialog.xy = dialog.data[(gamedata['client']['combat_damage_bar_placement']||'top_left') != 'top_left' ? 'xy_no_damage' : 'xy'];
    update_resource_bars(dialog, true, !!session.res_looter, true);

    var is_nosql = session.region.data && (session.region.data['storage'] == 'nosql');

    for(var res in gamedata['resources']) {
        goog.array.forEach(['resource_bar_'+res+'_amount',
                            'resource_bar_'+res+'_icon',
                            'resource_bar_'+res+'_prog',
                            'resource_bar_'+res+'_glow',
                            'resource_bar_'+res], function(wname) {
                                if(wname in dialog.widgets) {
                                    if(gamedata['client']['combat_resource_bars_transparent'] && goog.array.contains(['resource_bar_'+res,'resource_bar_'+res+'_prog'], wname)) {
                                        dialog.widgets[wname].show = false;
                                    } else if(session.viewing_base.base_landlord_id == session.user_id ||
                                              session.viewing_base.base_type == 'squad') {
                                        // hide at friendly bases and any squad
                                        dialog.widgets[wname].show = false;
                                    }
                                }
                            });
    }

    // trophy widgets
    var trophy_mode = null, trophy_type = null;
    if(session.is_ladder_battle() && gamedata['client']['combat_resource_bars_show_trophies']) {
        trophy_mode = (session.has_attacked ? 'current' : 'possible');
        trophy_type = (player.is_ladder_player() || player.current_trophy_pvp_challenge_name() ? 'pvp' : 'pve');
        dialog.widgets['trophies_current_icon'].state =
            dialog.widgets['trophies_victory_icon'].state =
            dialog.widgets['trophies_defeat_icon'].state = trophy_type;
        // figure out the trophy amounts to display
        var max_win = 0, max_loss = 0, min_win = 0, min_loss = 0, win_scale_by = null, loss_scale_by = null;;
        goog.array.forEach(player.player_auras, function(aura) {
            var spec = gamedata['auras'][aura['spec']];
            var cons = spec['on_battle_end_victory'] || spec['on_battle_end_defeat'] || null;
            if(cons && cons['consequent'] == 'GIVE_TROPHIES' && cons['trophy_kind'] == trophy_type) {
                var method = cons['method'] || '+';
                var stack = ('stack' in aura ? aura['stack'] : 1);
                if(method == '+') {
                    max_win += stack;
                    win_scale_by = cons['scale_by'] || null;
                    min_win = Math.max(min_win, cons['min_amount'] || 0);
                } else {
                    max_loss += stack;
                    loss_scale_by = cons['scale_by'] || null;
                    min_loss = Math.max(min_loss, cons['min_amount'] || 0);
                }
            }
        });
        //console.log('here max_win '+max_win.toString()+' max_loss '+max_loss.toString());
        if(trophy_mode == 'possible') {
            dialog.widgets['trophies_victory_amount'].str = display_trophy_count(max_win, trophy_type).toFixed(0);
            dialog.widgets['trophies_defeat_amount'].str = display_trophy_count(-1*max_loss, trophy_type).toFixed(0);
        } else if(trophy_mode == 'current') {
            var outcome;
            if(gamedata['matchmaking']['ladder_win_condition']=='battle_stars') {
                // base_damage_server_flags cannot be used reliably here because we don't ping for base damage until >threshold
                outcome = (goog.object.getCount(session.loot['battle_stars']||{}) >= 1 ? 'victory' : 'defeat');
            } else {
                // XXXXXX nasty hack - reach over into the combat damage bar
                var flags = desktop_dialogs['combat_damage_bar'].user_data['base_damage_server_flags'];
                outcome = (flags['is_ladder_win'] ? 'victory' : 'defeat');
            }
            var current = 0;
            if(outcome == 'victory') {
                // scale_by base_damage, deployed_unit_space
                current = max_win;
                if(win_scale_by == 'base_damage') {
                    // XXXXXX nasty hack
                    var base_damage = desktop_dialogs['combat_damage_bar'].user_data['base_damage'];
                    current = Math.floor(current * base_damage + 0.5);
                }
                current = Math.max(current, min_win);
            } else {
                current = max_loss;
                if(loss_scale_by = 'deployed_unit_space') {
                    var deployment_limit = get_player_stat(player.stattab, 'deployable_unit_space');
                    current = Math.floor(current * session.deployed_unit_space / (1.0*deployment_limit) + 0.5);
                }
                current = Math.max(current, min_loss);
                current *= -1; // show loss as negative
            }
            dialog.widgets['trophies_current_amount'].str = display_trophy_count(current, trophy_type).toFixed(0);
            dialog.widgets['trophies_current_amount'].text_color = SPUI.make_colorv(dialog.data['widgets']['trophies_current_amount']['text_color_'+outcome]);
        }
    }

    dialog.widgets['trophies_current_icon'].show = dialog.widgets['trophies_current_amount'].show = (trophy_mode == 'current');
    dialog.widgets['trophies_victory_icon'].show = dialog.widgets['trophies_victory_amount'].show =
        dialog.widgets['trophies_defeat_label'].show =
        dialog.widgets['trophies_defeat_icon'].show = dialog.widgets['trophies_defeat_amount'].show = (trophy_mode == 'possible');

    // attack timer bar
    dialog.widgets['attack_time_icon'].show =
        dialog.widgets['attack_time_amount'].show = (session.has_attacked && gamedata['client']['combat_resource_bars_show_time']);
    dialog.widgets['attack_time_bar'].show = (dialog.widgets['attack_time_icon'].show && !gamedata['client']['combat_resource_bars_transparent']);

    if(dialog.widgets['attack_time_amount'].show) {
        dialog.widgets['attack_time_amount'].str = pretty_print_time(session.ui_attack_time_togo());
    }

    // unit space deployed/deployable
    dialog.widgets['unit_space_icon'].show =
        dialog.widgets['unit_space_amount'].show = (gamedata['client']['combat_resource_bars_show_space'] &&
                                                    session.has_attacked && session.viewing_base.deployment_allowed &&
                                                    (session.viewing_base.base_landlord_id != session.user_id ||
                                                     (!is_nosql && session.viewing_base.base_type == 'quarry')));
    dialog.widgets['unit_space_bar'].show =
        dialog.widgets['unit_space_prog'].show = (dialog.widgets['unit_space_amount'].show && !gamedata['client']['combat_resource_bars_transparent']);

    // decide whether to show "out of space" message
    var out_of_space = false;

    if(dialog.widgets['unit_space_prog'].show && session.has_attacked) {
        var deployable_space = get_player_stat(player.stattab,'deployable_unit_space');
        var str = pretty_print_number(session.deployed_unit_space);
        str += ' / ';
        str += pretty_print_number(deployable_space);
        dialog.widgets['unit_space_amount'].str = str;
        dialog.widgets['unit_space_prog'].progress = session.deployed_unit_space/deployable_space;
        dialog.widgets['unit_space_bar'].tooltip.str = dialog.data['widgets']['unit_space_bar']['ui_tooltip'].replace('%ATTACK_SPACE_BUILDING', gamedata['buildings'][attack_space_building()]['ui_name']);

        // if player is almost out of deployable unit space, display a message to that effect

        // are any deployment buttons grayed out?
        var btm = desktop_dialogs['desktop_bottom'];
        if(btm && btm.mouse_enter_time > 0) {
            if(gamedata['unit_deploy_style'] === 'squad') {
                var ulist = btm.widgets['unit_deployment_bar'].user_data['deploy_button_squad_ids'];
                if(ulist) {
                    for(var i = 0; i < ulist.length; i++) {
                        var d = btm.widgets['unit_deployment_bar'].widgets['squad'+i.toString()];
                        var bg = d.widgets['bg'];
                        var hovering = bg.mouse_enter_time && bg.mouse_enter_time > 0;
                        if(hovering && d.user_data['can_deploy'] === false) { // yes, button is grayed out
                            out_of_space = true;
                            break;
                        }
                    }
                }
            } else if(selection.ui && selection.ui.user_data && selection.ui.user_data['cursor'] == 'DeployUICursor') {
                // in individual-unit deploy styles, only show if deploy cursor active
                var ulist = btm.user_data['deploy_button_specs'];
                if(ulist) {
                    for(var i = 0; i < ulist.length; i++) {
                        var specname = ulist[i];
                        var d = btm.widgets['unit_deployment_bar'].widgets['unit'+i.toString()];
                        var btn = d.widgets[(gamedata['unit_deploy_style'] == 'drip' || gamedata['unit_deploy_style'] == 'squad' ?
                                             'frame' : 'plus_one')];
                        var hovering = false;
                        goog.object.forEach(d.widgets, function(w) { if(w.mouse_enter_time && w.mouse_enter_time > 0) { hovering = true; } });

                        if(btn.show && btn.state == 'disabled' && // yes, button is grayed out
                           // reason for gray-out is capacity limit (not lack of units at home)
                           (session.count_pre_deploy_units_of_spec(specname) < session.count_deployable_units_of_spec(specname)) &&
                           // mouse is hovering over the grayed-out unit
                           hovering) {
                            out_of_space = true;
                            break;
                        }
                    }
                }
            }
        }
    }

    dialog.widgets['unit_space_message_bg'].show =
        dialog.widgets['unit_space_message_line'].show =
        dialog.widgets['unit_space_message_rect'].show =
        dialog.widgets['unit_space_message'].show = out_of_space;
    if(dialog.widgets['unit_space_message'].show) {
        dialog.widgets['unit_space_message'].str = dialog.data['widgets']['unit_space_message']['ui_name'].replace('%ATTACK_SPACE_BUILDING', gamedata['buildings'][attack_space_building()]['ui_name']);
    }
}

function update_aura_bar(dialog) {
    dialog.show = (session.enable_combat_resource_bars &&
                   (player.tutorial_state == "COMPLETE") &&
                   desktop_dialogs['player_portrait_dialog'].show &&
                   !desktop_dialogs['playfield_controls_bar'].user_data['adjusting_sound'] &&
                   !desktop_dialogs['playfield_controls_bar'].user_data['adjusting_music']);

    // position relative to player
    dialog.xy = vec_add([desktop_dialogs['player_portrait_dialog'].xy[0], 0], [9,64]);

    // get list of auras to show - filter out expired/hidden auras
    var display_aura_list = goog.array.filter(player.player_auras, function(aura) {
        if('start_time' in aura && aura['start_time'] > server_time) { return false; }
        if(aura['end_time'] && aura['end_time'] > 0 && aura['end_time'] < server_time) { return false; }
        var spec =  gamedata['auras'][aura['spec']];
        if(('show' in spec) && (!spec['show'])) { return false; }
        if(('show_if' in spec) && !read_predicate(spec['show_if']).is_satisfied(player, null)) { return false; }
        return true;
    });

    // prepend some "dummy" auras that display information in the same
    // format as an aura, but aren't actually stored in player.player_auras

    // dummy aura for damage protection
    if(player.resource_state['protection_end_time'] > server_time) {
        display_aura_list.unshift({'spec':'damage_protection', 'end_time': player.resource_state['protection_end_time'],
                                   'ui_glow': !!dialog.user_data['protection_time_glow']});
    }

    // dummy aura for donated units
    if(player.unit_donation_enabled() && player.has_donated_units()) {
        display_aura_list.unshift({'spec':'donated_units',
                                   'icon': player.donated_units_icon(), // override with alliance-specific icon
                                   'ui_description_extra': player.donated_units_description(', ') + '\n' + gamedata['auras']['donated_units']['ui_space'].replace('%cur',player.donated_units_space().toFixed(0)).replace('%max',player.donated_units_max_space().toFixed(0))
                                  });
    }

    // dummy aura for incoming raids
    if(player.home_base_loc && session.region && !session.region.dirty &&
       session.region.feature_incoming_raid_togo({'base_map_loc': player.home_base_loc}) > 0) {
        var features = session.region.find_features_at_coords(player.home_base_loc, {eta_only: true});
        goog.array.forEach(features, function(feature) {
            if(feature['base_landlord_id'] !== session.user_id &&
               feature['base_type'] === 'squad' &&
               feature['raid']) {
                var stance = session.region.feature_stance(feature);
                var aura_name = null;

                if(feature['raid'] === 'guard' && player.alliance_raids_enabled() && (stance & (Region.Stance.ALLIANCEMATE))) {
                    // incoming guards
                    aura_name = 'incoming_raid_guards';
                } else if(feature['raid'] !== 'scout' && (stance & Region.Stance.HOSTILE)) {
                    aura_name = 'incoming_raid';
                }
                if(aura_name) {
                    var attacker_info = PlayerCache.query_sync(feature['base_landlord_id']);
                    var attacker_ui_name = PlayerCache._get_ui_name(attacker_info || {});
                    var attacker_home_feature = session.region.find_feature_by_id('h'+feature['base_landlord_id'].toString());
                    var attacker_home_base_loc = (attacker_home_feature ? attacker_home_feature['base_map_loc'] : null);
                    display_aura_list.unshift({'spec': aura_name,
                                               'end_time': ('base_map_path' in feature ? Math.max(feature['base_map_path'][feature['base_map_path'].length-1]['eta'], server_time) : server_time),
                                               'ui_description_extra': gamedata['auras'][aura_name]['ui_description_extra'].replace('%PERSON', attacker_ui_name),
                                               'onclick_consequent_state': (attacker_home_base_loc ?
                                                                            {'map_loc': attacker_home_base_loc} : null)
                                              });
                }
            }
        });
    }

    var dialog_width = 0;

    for(var i = 0; i < dialog.data['widgets']['aura_icon']['array'][0]; i++) {

        if(i < display_aura_list.length) {
            var aura = display_aura_list[i];
            var aura_spec = gamedata['auras'][aura['spec']];


            // in non-deployment_allowed bases, player aura and equipment effects are turned off
            // however, non-cancelable auras still take effect
            var effects_inhibited = (session.viewing_base && !session.viewing_base.deployment_allowed &&
                                     !('cancelable' in aura_spec && !aura_spec['cancelable'] && aura_spec['name'] != 'donated_units'));

            // show aura
            dialog.widgets['aura_slot'+i].show = false;
            dialog.widgets['aura_icon'+i].show = true;
            var icon = aura['icon'] || aura_spec['icon'] || 'inventory_unknown';
            if(icon == 'gamebucks_inventory_icon') {
                icon = player.get_any_abtest_value('gamebucks_inventory_icon', gamedata['store']['gamebucks_inventory_icon']);
            }
            dialog.widgets['aura_icon'+i].asset = icon;
            dialog.widgets['aura_icon'+i].alpha = (effects_inhibited ? 0.5 : 1);

            dialog.widgets['aura_stack'+i].str = ('stack' in aura ? (('stack_prefix' in aura_spec) ? aura_spec['stack_prefix'] : '') + pretty_print_number(aura['stack']) : null);
            dialog.widgets['aura_stack'+i].show = ('stack' in aura) && (aura['stack'] != 1) && (!('show_stack' in aura_spec) || aura_spec['show_stack']);
            if(dialog.widgets['aura_stack'+i].show) {
                dialog.widgets['aura_stack'+i].text_color = ('stack_font_color' in aura_spec ? SPUI.make_colorv(aura_spec['stack_font_color']) : SPUI.default_text_color);
                var font_size = dialog.data['widgets']['aura_stack']['text_size'];
                dialog.widgets['aura_stack'+i].font = ItemDisplay.get_font_for_stack(dialog.widgets['aura_stack'+i], false, ('stack' in aura ? aura['stack'] : 1));
            }
            dialog.widgets['aura_frame'+i].show = true;
            dialog.widgets['aura_frame'+i].state = (dialog.user_data['aura_context'] && dialog.user_data['aura_context'].user_data['slot'] == i ? 'active' : (aura_spec['harm'] ? 'debuff' : 'buff'));

            dialog.widgets['aura_frame'+i].onenter = (function (_i, _aura) { return function(w) {
                var dialog = w.parent;
                if(dialog.user_data['aura_context'] &&
                   dialog.user_data['aura_context'].user_data['slot'] == _i) { return; }
                invoke_aura_context(dialog, w.xy, _i, _aura, false);
            }; })(i, aura);

            if(aura_spec['on_click']) {
                dialog.widgets['aura_frame'+i].onclick = (function (_cons, _state) { return function(w) {
                    read_consequent(_cons).execute(_state);
                }; })(aura_spec['on_click'], aura['onclick_consequent_state'] || null);
            } else {
                dialog.widgets['aura_frame'+i].onclick = (function (_i, _aura) { return function(w) {
                    var dialog = w.parent;
                    if(dialog.user_data['aura_context'] &&
                       dialog.user_data['aura_context'].user_data['slot'] == _i) {
                        invoke_aura_context(dialog, w.xy, _i, _aura, true);
                    }
                }; })(i, aura);
            }
            dialog.widgets['aura_frame'+i].onleave_cb = (function (_i) { return function(w) {
                var dialog = w.parent;
                var c = dialog.user_data['aura_context'];
                var out_of_bounds = true;
                if(c) {
                    var abs_xy = c.get_absolute_xy();
                    if((mouse_state.last_raw_x >= abs_xy[0]) && (mouse_state.last_raw_x < (abs_xy[0]+c.wh[0])) &&
                       (mouse_state.last_raw_y >= abs_xy[1])) { // note: no check on Y max
                            out_of_bounds = false;
                    }
                }

                if(dialog.user_data['aura_context'] &&
                   dialog.user_data['aura_context'].user_data['slot'] == _i &&
                   (out_of_bounds || !dialog.user_data['aura_context'].user_data['show_dropdown'])) {
                    invoke_aura_context(dialog, w.xy, -1, null, false);
                }
            }; })(i);

            if(('end_time' in aura) && (aura['end_time'] > 0)) {
                dialog.widgets['aura_timer'+i].show = true;
                dialog.widgets['aura_timer'+i].str = pretty_print_time_brief(aura['end_time']-server_time);
                dialog.widgets['aura_timer'+i].alpha = (effects_inhibited ? 0.5 : 1);
            } else {
                dialog.widgets['aura_timer'+i].show = false;
            }

            if(aura['ui_glow'] || aura_spec['ui_glow']) {
                var flash = dialog.data['widgets']['aura_glow']['alpha'] * (0.5*Math.sin(dialog.data['widgets']['aura_glow']['pulse_frequency']*client_time/(2*Math.PI))+0.5);
                dialog.widgets['aura_glow'+i].show = true;
                dialog.widgets['aura_glow'+i].alpha = flash;
            } else {
                dialog.widgets['aura_glow'+i].show = false;
            }

            dialog_width = Math.max(dialog_width, dialog.widgets['aura_icon'+i].xy[0] + dialog.widgets['aura_icon'+i].wh[0]);
        } else {
            dialog.widgets['aura_glow'+i].show =
                dialog.widgets['aura_slot'+i].show =
                dialog.widgets['aura_icon'+i].show =
                dialog.widgets['aura_stack'+i].show =
                dialog.widgets['aura_frame'+i].show =
                dialog.widgets['aura_timer'+i].show = false;
        }
    }

    // elongate size to match max aura dimension
    dialog.wh = [Math.max(dialog.data['dimensions'][0], dialog_width), dialog.data['dimensions'][1]];
}

// call an AI attack. If there is an on_visit message associated with
// the attack, display that and allow player to cancel out before launching
// the attack.
function start_ai_attack(uid) {
    // catch-all for leaving home when there is something in the loot buffer
    if(session.home_base && !session.has_attacked && (player.loot_buffer.length > 0)) {
        invoke_loot_dialog();
        return;
    }

    // function to actually start the AI attack
    var attack_func = (function (_uid) { return function() {
        send_to_server.func(["START_AI_ATTACK", _uid.toString()]);
        invoke_ui_locker();
    }; })(uid);

    // fire on_visit predicate, if there is one
    if(uid.toString() in gamedata['ai_bases_client']['bases']) {
        var base = gamedata['ai_bases_client']['bases'][uid.toString()];

        // hack - only works with DISPLAY_MESSAGE consequents
        if('on_visit' in base && base['on_visit']['consequent'] == 'DISPLAY_MESSAGE' &&
           (!base['on_visit']['tag'] || !(base['on_visit']['tag'] in DisplayMessageConsequent_seen)) ) {
            var dialog = create_splash_message(base['on_visit']);
            install_child_dialog(dialog);
            dialog.modal = true;
            dialog.auto_center();
            dialog.widgets['ok_button'].onclick = attack_func;
            return;
        }
    }

    // fallback - just call the attack immediately
    attack_func();
}

function event_time_togo(event_data) {
    var ret;
    if('time_period' in event_data) {
        ret = event_data['time_period'] - ((player.get_absolute_time() - event_data['time_origin']) % event_data['time_period']);
    } else {
        ret = -player.get_event_time('current_event', event_data['name'], 'end');
    }
    if(typeof ret === 'undefined') {
        throw Error('cannot determine time_to_go for '+event_data['name']);
    }
    return ret;
}

function get_event_evil_valentina_props(event_data) {
    // did player already finish event?
    if(('goal' in event_data) && read_predicate(event_data['goal']).is_satisfied(player, null)) { return null; }
    // is player ineligible for event?
    if(('activation' in event_data) && !read_predicate(event_data['activation']).is_satisfied(player, null)) { return null; }

    var props = {};
    props['time_to_go'] = event_time_togo(event_data);
    props['portrait_asset'] = event_data['console_portrait'] || null;
    props['stat'] = event_data['stat'] || null;
    props['prizes_ui_name'] = event_data['prizes_ui_name'] || null;
    props['fight_button_ui_name'] = event_data['fight_button_ui_name'] || null;
    props['fight_button_ui_tooltip'] = event_data['fight_button_ui_tooltip'] || null;
    props['ui_description'] = event_data['ui_description'] || null;

    var gui_mode = 'legacy';
    // ui strings
    var ui_title = null, speech_str = null;
    // action that triggers the next fight
    var action = null, act_pred = null;
    var token_item = null;
    var info_action = null, prizes_action = null, portrait_action = null, portrait_tooltip = null;
    var cooldown = -1;
    var map_battle_action = null, map_battle_ui_name = null, map_battle_pred = null;

    if(event_data['info_url']) {
        var url = eval_cond_or_literal(event_data['info_url'], player, null);
        if(url) {
            info_action = (function (_url) { return function() {
                url_open_in_new_tab(_url);
            }; })(url);
        }
    }

    if(event_data['portrait_action']) {
        var cons = eval_cond_or_literal(event_data['portrait_action'], player, null);
        if(cons) {
            portrait_action = (function(_cons) { return function() { _cons.execute(); }; })(read_consequent(cons));
        }
    }
    portrait_tooltip = event_data['ui_portrait_tooltip'] || null;

    if('chain' in event_data) {
        // new-style "cond" based action determination

        if(event_data['gui_mode'] == 'map_and_base_event') {
            gui_mode = 'map_and_base_event';
            token_item = event_data['token_item'] || null;
            if('map_battle_button_action' in event_data) {
                map_battle_action = (function(_cons) { return function() { _cons.execute(); }; })(read_consequent(event_data['map_battle_button_action']));
                if('activation' in event_data['map_battle_button_action']) {
                    map_battle_pred = read_predicate(event_data['map_battle_button_action']['activation']);
                }
            }
            map_battle_ui_name = event_data['ui_map_battle_button'] || null;
        }

        var chain = null;
        for(var i = 0; i < event_data['chain'].length; i++) {
            if(read_predicate(event_data['chain'][i][0]).is_satisfied(player, null)) {
                chain = event_data['chain'][i];
                break;
            }
        }
        if(!chain) { return null; }
        ui_title = chain[1]['ui_title'];
        speech_str = chain[1]['ui_speech'];
        if('console_portrait' in chain[1]) { props['portrait_asset'] = chain[1]['console_portrait']; }
        action = chain[1]['fight_button_action'];
        if('activation' in chain[1]) {
            act_pred = read_predicate(chain[1]['activation']);
        }

        if(!act_pred) {
            var base;
            if(action['visit_base']) {
                base = gamedata['ai_bases_client']['bases'][action['visit_base'].toString()];
            } else if(action['call_attack']) {
                base = gamedata['ai_bases_client']['bases'][action['call_attack'].toString()];
            }
            if('activation' in base) {
                act_pred = read_predicate(base['activation']);
            }
        }

    } else if(event_data['gui_mode'] == 'map_event' || event_data['gui_mode'] == 'stat_tournament' || event_data['token_item']) {
        gui_mode = 'map_event';
        token_item = event_data['token_item'] || null;
        ui_title = event_data['ui_title'];
        speech_str = event_data['ui_subtitle'].replace('%togo', pretty_print_time_brief(props['time_to_go']));
        action = event_data['fight_button_action'];
        if('activation' in action) {
            act_pred = read_predicate(action['activation']);
        }
        if(event_data['prizes_action']) {
            prizes_action = (function(_cons) { return function() { _cons.execute(); }; })(read_consequent(event_data['prizes_action']));
        }
    } else if(event_data['gui_mode'] == 'event_preview') {
        gui_mode = 'event_preview';
        ui_title = event_data['ui_title'];
        speech_str = event_data['ui_subtitle'].replace('%togo', pretty_print_time_brief(props['time_to_go']));

    } else {
        // old-style events
        ui_title = event_data['ui_title'];
        speech_str = event_data['ui_speech'];

        if('fight_button_ai_progress_key' in event_data) {
            var key = event_data['fight_button_ai_progress_key'];
            var cur = player.history[key] || 0;
            if('fight_button_actions' in event_data) {
                action = event_data['fight_button_actions'][cur];
            } else {
                throw Error('cannot determine action');
            }
        }
    }

    var fight_action = null;
    if(action) {
    if(action['visit_base']) {
        fight_action = (function (_num) { return function() { visit_base(_num); }; })(action['visit_base']);
    } else if(action['call_attack']) {
        if(!act_pred) {
            var pred_src = { "predicate": "OBJECT_UNDAMAGED", "spec": gamedata['townhall'] };
            if(pred_src) { act_pred = read_predicate(pred_src); }
        }

        fight_action = (function (_type) { return function() { start_ai_attack(_type); }; })(action['call_attack']);
    } else if(action['visit_ladder_rival']) {
        fight_action = function() { do_visit_base(-1, {ladder_battle:1}); };
        cooldown = player.cooldown_togo('VISIT_LADDER_RIVAL');
        if('activation' in action) {
            act_pred = read_predicate(action['activation']);
        }
    } else if(action['region_map']) {
        fight_action = function() {
            invoke_region_map();
        };
        if('activation' in action) {
            act_pred = read_predicate(action['activation']);
        }
    } else if(action['consequent']) {
        fight_action = (function (_cons) { return function() { _cons.execute(); }; })(read_consequent(action));
        if('activation' in action) {
            act_pred = read_predicate(action['activation']);
        }
    } else {
        throw Error('cannot parse fight_button_action: '+action.toString());
    }
    }

    if('ui_speech_key' in event_data && 'ui_speech_key_goal' in event_data) {
        var goal = event_data['ui_speech_key_goal'];
        var cur = player.history[event_data['ui_speech_key']] || 0;
        var delta = goal-cur;
        speech_str = speech_str.replace('%goal_minus_key', delta.toString());
        speech_str = speech_str.replace('%bases', (delta == 1 ? 'base' : 'bases')); // user-visible, but obsolete
        speech_str = speech_str.replace('%attacks', (delta == 1 ? 'attack' : 'attacks')); // user-visible, but obsolete
    }

    props['ui_title'] = ui_title;
    props['speech_str'] = speech_str;
    props['act_pred'] = act_pred;
    props['fight_action'] = fight_action;
    props['cooldown'] = cooldown;
    props['info_action'] = info_action;
    props['prizes_action'] = prizes_action;
    props['portrait_action'] = portrait_action;
    props['portrait_tooltip'] = portrait_tooltip;
    props['token_item'] = token_item;
    props['map_battle_action'] = map_battle_action;
    props['map_battle_pred'] = map_battle_pred;
    props['map_battle_ui_name'] = map_battle_ui_name;
    props['gui_mode'] = gui_mode;
    return props;
}

function get_event_evil_valentina() {
    if(player.tutorial_state !== "COMPLETE" || player.is_cheater) { return null; }

    var props = null;

    // is any global event currently going on?
    if(read_predicate({'predicate':'LIBRARY', 'name': 'hide_event_info_until'}).is_satisfied(player, null)) {
        var event_data = player.get_event_data('current_event');
        if(event_data) {
            props = get_event_evil_valentina_props(event_data);
        }
    }
    // global events take priority over tutorial event
    if(props) { return props; }

    // tutorial event
    if(read_predicate({'predicate':'LIBRARY', 'name': 'enable_tutorial_event'}).is_satisfied(player, null)) {
        var tutorial_event_name = player.get_any_abtest_value('tutorial_event', gamedata['tutorial_event']);
        if(tutorial_event_name) {
            props = get_event_evil_valentina_props(gamedata['events'][tutorial_event_name]);
        }
    }

    return props;
}

function get_console_shift() { return ((global_chat_frame && global_chat_frame.is_visible()) ? global_chat_frame.user_data['console_shift'] : 0); };

// return the current x,y coordinates for the top-left corner of the desktop_top dialog (shifted when chat is maximized)
function get_shifted_console_position() {
    var console_shift = get_console_shift();

    // center in game window (region to right of console_shift)
    var xy = [0,0];
    var wh = gamedata['dialogs']['desktop_top']['dimensions'];
    xy[0] = Math.floor(console_shift + (canvas_width - console_shift)/2 - wh[0]/2);
    if(xy[0] < 0) {
        xy[0] = 0;
    } else if(xy[0]+wh[0] > canvas_width) {
        xy[0] = canvas_width - wh[0];
    }
    return xy;
}

// update data fields and centering of desktop dialogs
function update_desktop_dialogs() {
    var droid_factory = null, robotics_lab = null;

    var basic_manuf_category = goog.object.getKeys(gamedata['strings']['manufacture_categories'])[0]; // most basic manufacture category
    var basic_research_category = gamedata['strings']['research_categories']['army'][0]['name']; // most basic army research category

    if(session.home_base) {
        // scan player's buildings to find a few things

        session.for_each_real_object(function(obj) {
            if(obj.is_building() && obj.is_manufacturer() && obj.spec['manufacture_category'] === basic_manuf_category) { droid_factory = obj; }
            if(obj.is_building() && obj.is_researcher() && obj.spec['research_categories'][0] === basic_research_category) { robotics_lab = obj; }
        });
    }

    // during tutorial, restrict access to non-applicable dialogs
    var enable_missions = (player.tutorial_state === "COMPLETE" ||
                           player.tutorial_state === "open_missions_dialog");
    var enable_map = (player.tutorial_state === "COMPLETE" ||
                      player.tutorial_state === "open_map_dialog" ||
                      player.tutorial_state === "spy_on_ai");
    var enable_store = (player.tutorial_state === "COMPLETE");
    var enable_buildings =  (player.tutorial_state === "COMPLETE" ||
                             player.tutorial_state === "open_buildings_dialog" ||
                             player.tutorial_state === "go_to_defense_tab" ||
                             player.tutorial_state === "choose_defensive_cannon" //||
//                           player.tutorial_state === "place_defensive_cannon"
                            );
    var enable_produce = (player.tutorial_state === "COMPLETE");
    var enable_friends = (player.tutorial_state === "COMPLETE");

    var flashy_loot = player.flashy_loot();

    // disable changing the session before or during an attack
    if(session.incoming_attack_pending() || session.has_attacked) {
        enable_map = false;
        enable_friends = false;
    }

    // process top dialog
    var dialog = desktop_dialogs['desktop_top'];

    // shift console horizontally to make room for chat and
    // center in game window (region to right of console_shift)
    dialog.xy = get_shifted_console_position();

    // player protection/attack timer and "Evil Valentina" (non-tutorial version)
    var show_evil_valentina = false;
    var show_regional_event_info = false;

    dialog.widgets['network_trouble_message'].show = (the_websocket && the_websocket.is_reconnecting());

    if(session.home_base) {
        dialog.widgets['battle_history_jewel'].user_data['count'] = player.new_battle_histories;
        dialog.widgets['keyboard_shortcuts_jewel'].user_data['count'] = player.check_feature_use('keyboard_shortcuts_list') ? 0 : 1;

        update_resource_bars(dialog, true, false, false);

        dialog.widgets['low_power_bg'].show =
            dialog.widgets['low_power_message'].show = (gamedata['enable_power'] && player.quest_root.children.length < 1 && selection.ui_change_time === -1 && player.tutorial_state == "COMPLETE" && session.get_draw_world().base.power_factor() < 1);
        if(dialog.widgets['low_power_message'].show) {
            dialog.widgets['low_power_message'].str = dialog.data['widgets']['low_power_message']['ui_name'].replace('%d', Math.min(99, 100.0*session.get_draw_world().base.power_factor()).toFixed(0)).replace('%POWERPLANTS',gamedata['buildings'][gamedata['strings']['modstats']['stats']['limit:energy']['check_spec']]['ui_name_plural']);
        }

        dialog.widgets['user_abtest_message'].show = !dialog.widgets['network_trouble_message'].show &&
                                                      (player.tutorial_state == "COMPLETE" &&
                                                      !(player.quest_tracked && player.quest_tracked['ui_step']) &&
                                                      !session.has_attacked &&
                                                      !session.incoming_attack_pending() &&
                                                      !anon_mode);
        dialog.widgets['user_abtest_message'].str = eval_cond_or_literal(player.get_any_abtest_value('ui_user_abtest_message', gamedata['strings']['ui_user_abtest_message'] || null), player, null) || null;

        dialog.widgets['edit_mode_message'].show = !!player.is_cheater;

        // check for excessive scenery sprites
        var inert_count = 0;
        if(player.is_cheater) {
            session.for_each_real_object(function(obj) {
                if(obj.is_inert()) { inert_count += 1; }
            });
        }
        dialog.widgets['excessive_sprite_message'].show = player.is_cheater && (inert_count > gamedata['client']['inert_warn_count']);
        if(dialog.widgets['excessive_sprite_message'].show) {
            dialog.widgets['excessive_sprite_message'].str = dialog.data['widgets']['excessive_sprite_message']['ui_name'].replace('%cur', inert_count.toString()).replace('%max', gamedata['client']['inert_warn_count'].toString());
        }

    } else { // NOT home base

        dialog.widgets['edit_mode_micro_message'].show = !!player.is_cheater && ('enable_unit_micro' in gamedata) && !gamedata['enable_unit_micro'];

        dialog.widgets['protection_message'].show =
            dialog.widgets['protection_defended'].show = false;

        desktop_dialogs['combat_resource_bars'].show = session.enable_combat_resource_bars && (session.has_attacked || (session.is_ladder_battle() && gamedata['client']['combat_resource_bars_show_trophies'])) && (session.viewing_base.base_landlord_id !== session.user_id);
        desktop_dialogs['combat_damage_bar'].show =  desktop_dialogs['combat_resource_bars'].show && session.has_attacked;

        if(session.viewing_base.base_type == 'quarry' && session.viewing_base.base_landlord_id == session.user_id) {
            dialog.widgets['abandon_button'].show = true;

            var actual_cb = (function (_w) { return function() {
                var dialog = _w.parent;
                dialog.widgets['abandon_button'].str = dialog.data['widgets']['abandon_button']['ui_name_pending'];
                dialog.widgets['abandon_button'].state = 'disabled';
                send_to_server.func(["QUARRY_ABANDON", session.viewing_base.base_id]);
            }; })(dialog.widgets['abandon_button']);

            var state, tip, msg;

            if(session.region.data && session.region.data['storage'] == 'nosql') {
                if(session.defending_squads.length > 0) {
                    dialog.widgets['abandon_button'].state = 'disabled';
                    msg = null;
                    state = 'disabled';
                    tip = '_nosql_guarded';
                } else {
                    msg = gamedata['strings']['abandon_quarry_confirm_nosql'];
                    state = 'attack';
                    tip = '_nosql';
                }
            } else {
                msg = gamedata['strings']['abandon_quarry_confirm'];
                state = 'attack';
                tip = '';
            }

            if(dialog.widgets['abandon_button'].state == 'disabled') { state = 'disabled'; } // already pending

            dialog.widgets['abandon_button'].state = state;
            dialog.widgets['abandon_button'].tooltip.str = dialog.data['widgets']['abandon_button']['ui_tooltip'+tip];
            dialog.widgets['abandon_button'].onclick = (function (_msg, _actual_cb) { return function(w) {
                if(_msg) {
                    invoke_child_message_dialog(_msg['ui_title'], _msg['ui_description'],
                                                {'cancel_button':true,
                                                 'ok_button_ui_name': _msg['ui_button'],
                                                 'dialog': 'message_dialog_big',
                                                 'on_ok': _actual_cb});
                }
            }; })(msg, actual_cb);
        }

        // enemy protection timer

        // note: as a special case, do NOT show the protection
        // timer if the opponent seems to be currently logged
        // in. They are not attackable anyway, and this avoids
        // complaints by players who get attacked, visit their
        // attacker (who is still logged in), and see an
        // out-of-date protection timer that seems to be still active.
        //
        // UPDATE: no, never show protection time bar EVER.
        // This is just a source of endless confusion and complaints.

        if(1) {
            dialog.widgets['protection_time_bar'].show =
                dialog.widgets['protection_time_icon'].show =
                dialog.widgets['protection_time_amount'].show = false;
        }

        // instance reset timer
        if((!session.has_deployed) && enemy.instance_expiration_time > server_time &&
           player.get_abtest_value('T011_ai_bases', 'timer', 0)) {
            dialog.widgets['reset_time_bar'].show =
                dialog.widgets['reset_time_icon'].show =
                dialog.widgets['reset_time_amount'].show = true;
            var str = pretty_print_time(enemy.instance_expiration_time - server_time);
            dialog.widgets['reset_time_amount'].str = str;
            dialog.widgets['reset_time_bar'].tooltip.str = dialog.widgets['reset_time_bar'].tooltip.data['ui_name'].replace('%s', str)
        } else {
            dialog.widgets['reset_time_bar'].show =
                dialog.widgets['reset_time_icon'].show =
                dialog.widgets['reset_time_amount'].show = false;
        }

        dialog.widgets['attack_time_label'].show = dialog.widgets['attack_time_amount'].show = (session.has_attacked && gamedata['client']['desktop_top_show_attack_time']);
        if(dialog.widgets['attack_time_amount'].show) {
            var togo = session.ui_attack_time_togo();
            var s;
            if(togo <= 0) {
                s = '--:--';
            } else {
                var ui_mins = (togo < 60 ? '0' : Math.floor(togo/60.0).toFixed(0));
                var ui_sec = pad_with_zeros(Math.floor(togo%60.0).toFixed(0), 2);
                s = ui_mins + ':' + ui_sec;
            }
            dialog.widgets['attack_time_amount'].str = s;
        }

        // warn about important enemy auras
        var ui_enemy_aura_msgs = [];
        goog.array.forEach(enemy.player_auras, function(aura) {
            var spec = gamedata['auras'][aura['spec']];
            if(!spec) { return; }
            var msg = eval_cond_or_literal(spec['ui_enemy_warning'] || null, player, null);
            if(msg) {
                ui_enemy_aura_msgs.push(msg);
            }
        });
        if(ui_enemy_aura_msgs.length > 0) {
            dialog.widgets['enemy_aura_message'].show = true;
            dialog.widgets['enemy_aura_message'].str = ui_enemy_aura_msgs.join('\n');
        } else {
            dialog.widgets['enemy_aura_message'].show = false;
        }
    } // end NOT session.home_base

    if(session.home_base) {

        if(gamedata['client']['desktop_question_button_consequent']) {
            // new consequent-based ? button
            dialog.widgets['question_button'].show = (player.tutorial_state == "COMPLETE") && !session.has_attacked;
            // awkward positioning hack to move it over where the keyboard shortcuts button would go, if keyboard shortcuts are off
            dialog.widgets['question_button'].xy = dialog.data['widgets']['question_button'][('enable_keyboard_shortcuts_button' in gamedata['client'] && !gamedata['client']['enable_keyboard_shortcuts_button']) ? 'xy_no_shortcuts': 'xy'];
            dialog.widgets['question_button'].tooltip.str = dialog.data['widgets']['question_button']['ui_tooltip_consequent'];
            dialog.widgets['question_button'].onclick = (function (_raw) { return function(w) {
                read_consequent(_raw).execute();
            }; })(gamedata['client']['desktop_question_button_consequent']);

        } else { // old ? button

            dialog.widgets['question_button'].onclick = function() {
                player.quest_tracked = null; player.quest_tracked_dirty = true; // allow re-initialization of highest-priority quest
                var tracked = tutorial_opt_in();

                // if we can't automatically pick up a quest with GUI tips, punt by showing missions dialog
                if(!tracked || tracked['ui_instructions']) {
                    invoke_missions_dialog(true);
                }
            };

            dialog.widgets['question_button'].show = (player.tutorial_state == "COMPLETE" &&
                                                      !session.has_attacked && !session.incoming_attack_pending() &&
                                                      player.get_any_abtest_value('skip_tutorial_button', gamedata['client']['skip_tutorial_button']));
            // only disable "?" button if there are live "click here" tips going on
            dialog.widgets['question_button'].state = (player.quest_tracked && ('tips' in player.quest_tracked) && !player.quest_tracked['ui_instructions'] ? 'disabled' : 'normal');
        }

        if(player.tutorial_state == "COMPLETE" &&
           player.get_any_abtest_value('skip_tutorial_button', gamedata['client']['skip_tutorial_button']) &&
           player.quest_tracked && ('tips' in player.quest_tracked) && (player.quest_tracked['ui_step']) && (player.quest_tracked['ui_category']) &&
           !session.has_attacked && !session.incoming_attack_pending()) {
            // new-style mission progress indicator
            dialog.widgets['skip_tutorial_bg'].show =
                dialog.widgets['skip_tutorial_prog'].show =
                dialog.widgets['skip_tutorial_label'].show =
                dialog.widgets['skip_tutorial_button'].show = true;
            dialog.widgets['quest_tracker_bg'].show =
                dialog.widgets['quest_tracker_title'].show =
                dialog.widgets['quest_tracker_descr'].show = false;

            var cur_step = player.quest_tracked['ui_step'];
            var last_step = player.quest_chain_lengths[player.quest_tracked['ui_category']];

            var s = dialog.widgets['skip_tutorial_label'].data['ui_name'].replace('%s', player.quest_tracked['ui_category']).replace('%d1', cur_step.toString()).replace('%d2', last_step.toString());
            dialog.widgets['skip_tutorial_prog'].progress = (cur_step + (player.can_complete_quest(player.quest_tracked) ? 1.0 : 0.5))/(last_step+1);
            dialog.widgets['skip_tutorial_label'].str = s;

        } else {
            // new-style quest does NOT have ui_step/ui_category
            // OR it's an old-style quest
            dialog.widgets['skip_tutorial_bg'].show =
                dialog.widgets['skip_tutorial_prog'].show =
                dialog.widgets['skip_tutorial_label'].show =
                dialog.widgets['skip_tutorial_button'].show = false;

            if(player.tutorial_state == "COMPLETE" && player.quest_tracked && !session.has_attacked &&
               player.get_any_abtest_value('enable_quest_tracker', gamedata['client']['enable_quest_tracker']) &&
               (player.get_any_abtest_value('skip_tutorial_button', gamedata['client']['skip_tutorial_button']) ||
                !('tips' in player.quest_tracked))) {
                var quest = player.quest_tracked;
                dialog.widgets['quest_tracker_bg'].show =
                    dialog.widgets['quest_tracker_title'].show =
                    dialog.widgets['quest_tracker_descr'].show = true;

                dialog.widgets['skip_tutorial_button'].show = player.get_any_abtest_value('skip_tutorial_button', gamedata['client']['skip_tutorial_button']);

                var can_complete = player.can_complete_quest(player.quest_tracked);
                if(can_complete) {
                    dialog.widgets['quest_tracker_title'].str = dialog.data['widgets']['quest_tracker_title']['ui_name_complete'];
                    dialog.widgets['quest_tracker_descr'].set_text_with_linebreaking(quest['ui_name']);
                } else {
                    if(quest['ui_instructions']) {
                        dialog.widgets['quest_tracker_title'].str = dialog.data['widgets']['quest_tracker_title']['ui_name'];
                        dialog.widgets['quest_tracker_descr'].set_text_with_linebreaking(quest['ui_instructions']);
                    } else {
                        dialog.widgets['quest_tracker_title'].str = dialog.data['widgets']['quest_tracker_title']['ui_name'];
                        dialog.widgets['quest_tracker_descr'].set_text_with_linebreaking(dialog.data['widgets']['quest_tracker_descr']['ui_name']); // this only happens if skip_tutorial_button=0
                    }
                }
                // resize quest_tracker_bg to fit description text
                var n_lines = 1;
                if(dialog.widgets['quest_tracker_descr'].str) {
                    n_lines = dialog.widgets['quest_tracker_descr'].str.split('\n').length;
                }
                dialog.widgets['quest_tracker_bg'].xy = vec_copy(dialog.data['widgets']['quest_tracker_bg']['xy'+(can_complete ? '_complete' : '')]);
                dialog.widgets['quest_tracker_bg'].wh = vec_add(dialog.data['widgets']['quest_tracker_bg']['dimensions'+(can_complete ? '_complete' : '')],
                                                                [0, n_lines * dialog.widgets['quest_tracker_descr'].font.leading + dialog.widgets['quest_tracker_descr'].font.size]);
            } else {
            dialog.widgets['quest_tracker_bg'].show =
                    dialog.widgets['quest_tracker_title'].show =
                    dialog.widgets['quest_tracker_descr'].show = false;
            }
        }
    }

    // bottom dialog

    dialog = desktop_dialogs['desktop_bottom'];

    if(session.home_base) {

        if(session.has_attacked) {
            // nothing to update
        } else {

        dialog.widgets['missions_button'].state = enable_missions ? 'normal':'disabled';
        var missions_button_visible = !('missions_button_minimized' in player.preferences && player.preferences['missions_button_minimized']);
        dialog.widgets['missions_grow_toggle'].onclick = function() {
            missions_button_visible = !missions_button_visible;
            player.preferences['missions_button_minimized'] = !missions_button_visible;
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
        };
        dialog.widgets['missions_grow_up'].show = !missions_button_visible;
        dialog.widgets['missions_grow_down'].show =
            dialog.widgets['missions_button'].show = missions_button_visible;

        // "Reward Waiting" indicator on Missions button
        var num_waiting = player.has_unread_mail();

        // see if there is a gamebucks gift waiting
        var gifts_waiting = player.has_uncollected_gift_mail();
        if(gifts_waiting) {
            // always show "1" when an unopened gift is waiting
            num_waiting = Math.max(num_waiting, 1);
        }

        if(gifts_waiting && !selection.ui) {
            // show bigass "click-me" arrow
            if(!dialog.user_data['you_have_gift_arrow'] &&
               tutorial_root.children.length==0 &&
               player.quest_root.children.length==0) {
                dialog.user_data['you_have_gift_arrow'] = make_tutorial_arrow_for_button('desktop_bottom', 'missions_button', 'down');
            }
        } else {
            if(dialog.user_data['you_have_gift_arrow'] && dialog.user_data['you_have_gift_arrow'].parent) {
                tutorial_root.remove(dialog.user_data['you_have_gift_arrow']);
                dialog.user_data['you_have_gift_arrow'] = null;
            }
        }

        if(num_waiting > 0 && enable_missions) {
            if (!missions_button_visible) {
                dialog.widgets['missions_grow_glow'].show = true;
                dialog.widgets['missions_grow_glow'].alpha = gamedata['client']['notification_icon_glow_intensity']*(0.5 + 0.5 * Math.sin(2*Math.PI*(client_time*gamedata['client']['notification_icon_glow_freq'])));
            } else {
                dialog.widgets['missions_grow_glow'].show = false;
            }
            dialog.widgets['you_have_mail'].show = dialog.widgets['you_have_mail_glow'].show = missions_button_visible;
            dialog.widgets['you_have_mail_glow'].alpha = gamedata['client']['notification_icon_glow_intensity']*(0.5 + 0.5 * Math.sin(2*Math.PI*(client_time*gamedata['client']['notification_icon_glow_freq'])));
            if(player.get_any_abtest_value('show_notification_counter', gamedata['client']['show_notification_counter'])) {
                dialog.widgets['you_have_mail_jewel'].show = missions_button_visible;
                dialog.widgets['you_have_mail_jewel'].user_data['count'] = num_waiting;
            } else {
                dialog.widgets['you_have_mail_jewel'].show = false;
            }
        } else {
            dialog.widgets['you_have_mail'].show =
                dialog.widgets['missions_grow_glow'].show =
                dialog.widgets['you_have_mail_jewel'].show =
                dialog.widgets['you_have_mail_glow'].show = false;
        }

        var building_jewels = get_building_jewels();
        dialog.widgets['buildings_jewel'].user_data['count'] = building_jewels['ALL'];

        if(player.get_any_abtest_value('enable_store_jewel', gamedata['store']['enable_store_jewel']) &&
           read_predicate(gamedata['store']['activate_store_jewel']).is_satisfied(player, null)) {
            var count = 0;

            // count up jewel triggers from all store categories
            for(var icat = 0; icat < gamedata['store']['catalog'].length; icat++) {
                var catdata = gamedata['store']['catalog'][icat];
                if('jewel' in catdata && read_predicate(catdata['jewel']).is_satisfied(player, null)) { // jewel on category itself - this is not usual
                    count += 1;
                }
                for(var isku = 0; isku < gamedata['store']['catalog'][icat]['skus'].length; isku++) {
                    var skudata = gamedata['store']['catalog'][icat]['skus'][isku];
                    if(new_store_allow_sku(skudata)) {
                        if('jewel' in skudata) {
                            if(read_predicate(skudata['jewel']).is_satisfied(player, null)) {
                                count += 1;
                            }
                        }
                    }
                }
            }

            dialog.widgets['store_jewel'].user_data['count'] = count;
        }

        // map button
        dialog.widgets['map_button'].state = (enable_map? 'normal' : 'disabled');
        dialog.widgets['store_button'].state = (enable_store ? 'normal':'disabled');

        // friend bar
        // visibility keyed off friend_bar.show from the dialog initialization
        dialog.widgets['grow_toggle'].show = dialog.widgets['grow_bg'].show = dialog.widgets['friend_bar'].show;
        dialog.widgets['grow_up'].show = dialog.widgets['friend_bar'].show && !dialog.widgets['friend_bar'].user_data['maximized'];
        dialog.widgets['grow_down'].show = dialog.widgets['friend_bar'].show && !dialog.widgets['grow_up'].show;

        for(var i = 0; i < dialog.widgets['friend_bar'].data['widgets']['friend_icon']['array'][0]; i++) {
            dialog.widgets['friend_bar'].widgets['friend_icon'+i.toString()].state =
                dialog.widgets['friend_bar'].widgets['add_friend_button'+i.toString()].state = (enable_friends? 'normal' : 'disabled');
        }

        // robots button
        if(droid_factory != null || player.is_cheater) {
            dialog.widgets['robots_button'].state = enable_produce ? 'normal':'disabled';
            dialog.widgets['robots_button'].onclick = (function (fact) {
                return function() { change_selection(fact);
                                    invoke_manufacture_dialog('robots_button');
                                  };
            })(droid_factory);
        } else {
            dialog.widgets['robots_button'].state = 'disabled';
        }

        // buildings button
        dialog.widgets['buildings_button'].state = enable_buildings ? 'normal':'disabled';
        dialog.widgets['buildings_button'].onclick = function(w) { invoke_build_dialog(); };

        // research button
        if(enable_produce || robotics_lab != null) {
            dialog.widgets['research_button'].state = 'normal';
            dialog.widgets['research_button'].onclick = function(w) {
                invoke_research_dialog('army');
            };
        } else {
            dialog.widgets['research_button'].state = 'disabled';
        }

        // unit space / power displays
        {
            var space_usage = player.get_army_space_usage_by_squad();
            dialog.widgets['resource_space_amount'].str = pretty_print_number(space_usage['ALL']) + ' / ' + pretty_print_number(player.stattab['total_space']);

            dialog.widgets['resource_power_amount'].show = dialog.widgets['resource_power_icon'].show = gamedata['enable_power'];
            if(gamedata['enable_power']) {
                dialog.widgets['resource_power_amount'].str = pretty_print_number(session.viewing_base.power_state[1]) + ' / ' + pretty_print_number(session.viewing_base.power_state[0]);
                if(session.viewing_base.power_state[1] > session.viewing_base.power_state[0]) {
                    dialog.widgets['resource_power_amount'].text_color = SPUI.error_text_color;
                } else {
                    dialog.widgets['resource_power_amount'].text_color = SPUI.default_text_color;
                }
            }

            dialog.widgets['resource_foreman_amount'].show =
                dialog.widgets['resource_foreman_icon'].show =
                dialog.widgets['resource_foreman_button'].show = gamedata['enable_multiple_foremen'];

            if(gamedata['enable_multiple_foremen']) {
                var in_use = player.foremen_in_use();

                dialog.widgets['resource_foreman_amount'].str = pretty_print_number(in_use) + ' / ' + pretty_print_number(player.stattab['total_foremen']);

                if(in_use >= player.stattab['total_foremen']) {
                    dialog.widgets['resource_foreman_amount'].text_color = SPUI.error_text_color;
                } else {
                    dialog.widgets['resource_foreman_amount'].text_color = SPUI.default_text_color;
                }
                dialog.widgets['resource_foreman_button'].onclick = function() {
                    var helper = get_requirements_help('foreman', null, {short_circuit:true});
                    if(helper) { helper(); }
                };
            }
        }


        // "EVIL VALENTINA" AI character in lower-right corner

        // initialize the evil-valentina widgets that are part of desktop_bottom to hidden, then show selectively below
        dialog.widgets['event_preview_info'].show =
                dialog.widgets['map_event_info'].show =
                dialog.widgets['attacker_info_button'].show =
                dialog.widgets['map_battle_bg'].show =
                dialog.widgets['map_battle_button'].show = false;
        var show_event_info = !('event_button_minimized' in player.preferences && player.preferences['event_button_minimized']);
        dialog.widgets['event_grow_up'].show = !show_event_info;
        dialog.widgets['event_grow_down'].show = show_event_info;
        dialog.widgets['event_grow_toggle'].onclick = function() {
            show_event_info = !show_event_info;
            player.preferences['event_button_minimized'] = !show_event_info;
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
        };

        for(var y = 0; y < dialog.data['widgets']['resource_bar_tokens']['array'][1]; y++) {
            for(var x = 0; x < dialog.data['widgets']['resource_bar_tokens']['array'][0]; x++) {
                goog.array.forEach(['resource_bar_tokens','resource_bar_tokens_icon','resource_bar_tokens_amount'], function(wname) {
                    dialog.widgets[SPUI.get_array_widget_name(wname, dialog.data['widgets'][wname]['array'], [x,y])].show = false;
                });
            }
        }

        // info about incoming AI attack the player is about to suffer
        // WAS: session.incoming_attack_pending() && (!selection.ui || !selection.ui.user_data || selection.ui.user_data['dialog'] != 'daily_attack_dialog')
        if(show_evil_valentina) {
            dialog.widgets['attacker_timer'].str = pretty_print_time(session.incoming_attack_time - server_time);
            dialog.widgets['attacker_fight_button'].onclick = start_incoming_attack;
            dialog.widgets['attacker_portrait'].onclick =
                dialog.widgets['attacker_speech_bg'].onclick = null;

        } else {
            // check for ongoing event info
            var props = get_event_evil_valentina();
            if(props !== null) {
                var fight_button = null, d = null;

                if(props['gui_mode'] == 'event_preview') {
                    // preannouncement only
                    dialog.ondraw = function(w) {
                        dialog.widgets['event_preview_info'].show = show_event_info;
                    };
                    d = dialog.widgets['event_preview_info'];
                    d.widgets['title'].str = props['ui_title'];

                    d.widgets['time_amount'].str = props['speech_str'];
                    d.widgets['info_button'].onclick = props['info_action'] || null;
                    d.widgets['info_button'].show = !!props['info_action'];
                } else {
                    // live event
                    if(props['gui_mode'] == 'map_event') {
                        // new-style map event info
                        dialog.widgets['map_event_info'].show = show_event_info;
                        d = dialog.widgets['map_event_info'];
                        fight_button = d.widgets['fight_button'];
                        d.widgets['title'].str = props['ui_title'];
                        d.widgets['title'].tooltip.str = props['ui_description'];
                        d.widgets['subtitle'].str = props['speech_str'];
                        d.widgets['info_button'].onclick = props['info_action'] || null;
                        d.widgets['info_button'].show = !!props['info_action'];

                        if(props['token_item']) {
                            var item_list = (props['token_item'] instanceof Array ? props['token_item'] : [props['token_item']]);
                            for(var y = 0; y < d.data['widgets']['resource_bar_tokens']['array'][1]; y++) {
                                for(var x = 0; x < d.data['widgets']['resource_bar_tokens']['array'][0]; x++) {
                                    var index = y*d.data['widgets']['resource_bar_tokens']['array'][0] + x;
                                    if(index < item_list.length) {
                                        var ispec = ItemDisplay.get_inventory_item_spec(item_list[index]);
                                        d.widgets[SPUI.get_array_widget_name('resource_bar_tokens', d.data['widgets']['resource_bar_tokens']['array'],[x,y])].tooltip.str = d.data['widgets']['resource_bar_tokens']['ui_tooltip'].replace('%s', ispec['ui_name_plural']);
                                        d.widgets[SPUI.get_array_widget_name('resource_bar_tokens_icon', d.data['widgets']['resource_bar_tokens_icon']['array'],[x,y])].asset = ispec['store_icon'];
                                        d.widgets[SPUI.get_array_widget_name('resource_bar_tokens_icon', d.data['widgets']['resource_bar_tokens_icon']['array'],[x,y])].state = 'normal';
                                        d.widgets[SPUI.get_array_widget_name('resource_bar_tokens_amount', d.data['widgets']['resource_bar_tokens_amount']['array'],[x,y])].str = pretty_print_number(player.inventory_item_quantity_and_expiration(item_list[index])[0]);
                                    }
                                    d.widgets[SPUI.get_array_widget_name('resource_bar_tokens', d.data['widgets']['resource_bar_tokens']['array'],[x,y])].onclick = props['prizes_action'] || null;
                                }
                            }

                        } else { // show stat, or blank the display if there is no stat
                            var stat_list = [];
                            if(props['stat']) {
                                stat_list.push(props['stat']);
                            }
                            for(var y = 0; y < d.data['widgets']['resource_bar_tokens']['array'][1]; y++) {
                                for(var x = 0; x < d.data['widgets']['resource_bar_tokens']['array'][0]; x++) {
                                    var index = y*d.data['widgets']['resource_bar_tokens']['array'][0] + x;
                                    if(index < stat_list.length) {
                                        var stat_config = stat_list[index];
                                        var stat_data = gamedata['strings']['leaderboard']['categories'][stat_config['name']];
                                        d.widgets[SPUI.get_array_widget_name('resource_bar_tokens', d.data['widgets']['resource_bar_tokens']['array'],[x,y])].tooltip.str = stat_data['title'] + ':\n' + stat_data['description'];
                                        d.widgets[SPUI.get_array_widget_name('resource_bar_tokens_icon', d.data['widgets']['resource_bar_tokens_icon']['array'],[x,y])].asset = props['portrait_asset'];
                                        d.widgets[SPUI.get_array_widget_name('resource_bar_tokens_icon', d.data['widgets']['resource_bar_tokens_icon']['array'],[x,y])].state = 'resource_icon';

                                        d.widgets[SPUI.get_array_widget_name('resource_bar_tokens_amount', d.data['widgets']['resource_bar_tokens_amount']['array'],[x,y])].show = false;

                                        if(!('point_counts' in d.user_data)) {
                                            d.user_data['point_counts'] = {};
                                        }
                                        if(!(stat_config['name'] in d.user_data['point_counts'])) {
                                            d.user_data['point_counts'][stat_config['name']] = null; // mark pending
                                            d.widgets[SPUI.get_array_widget_name('resource_bar_tokens_spinner', d.data['widgets']['resource_bar_tokens_spinner']['array'],[x,y])].show = true;
                                            query_player_scores([session.user_id], [[stat_config['name'], stat_config['time_scope']]],
                                                                (function (_d, _x, _y, _stat_config) { return function(ids, results) {
                                                                    if(!_d.is_visible()) { return; }
                                                                    _d.widgets[SPUI.get_array_widget_name('resource_bar_tokens_spinner', _d.data['widgets']['resource_bar_tokens_spinner']['array'],[_x,_y])].show = false;
                                                                    _d.user_data['point_counts'][_stat_config['name']] = results[0][0] ? results[0][0]['absolute'] : 0;
                                                                }; })(d,x,y,stat_config));
                                        } else if(d.user_data['point_counts'][stat_config['name']] !== null) {
                                            d.widgets[SPUI.get_array_widget_name('resource_bar_tokens_amount', d.data['widgets']['resource_bar_tokens_amount']['array'],[x,y])].show = true;
                                            d.widgets[SPUI.get_array_widget_name('resource_bar_tokens_amount', d.data['widgets']['resource_bar_tokens_amount']['array'],[x,y])].str = pretty_print_number(d.user_data['point_counts'][stat_config['name']]);
                                        }
                                        d.widgets[SPUI.get_array_widget_name('resource_bar_tokens', d.data['widgets']['resource_bar_tokens']['array'],[x,y])].onclick = props['prizes_action'];
                                    } else {
                                        d.widgets[SPUI.get_array_widget_name('resource_bar_tokens', d.data['widgets']['resource_bar_tokens']['array'],[x,y])].show =
                                            d.widgets[SPUI.get_array_widget_name('resource_bar_tokens_amount', d.data['widgets']['resource_bar_tokens_amount']['array'],[x,y])].show =
                                            d.widgets[SPUI.get_array_widget_name('resource_bar_tokens_icon', d.data['widgets']['resource_bar_tokens_icon']['array'],[x,y])].show = false;
                                    }
                                }
                            }
                        }

                    } else {
                        // old-style predicate event info
                        dialog.widgets['map_event_info'].show = false;

                        // add "Map Battle" button and token counter to legacy guy-in-corner if the event is specified as a "map_and_base_event"
                        if(props['gui_mode'] == 'map_and_base_event' && !player.is_cheater) { // turn off if player is using dev edit mode
                            dialog.widgets['map_battle_bg'].show =
                                dialog.widgets['resource_bar_tokens'].show =
                                dialog.widgets['resource_bar_tokens_icon'].show =
                                dialog.widgets['resource_bar_tokens_amount'].show = show_event_info;

                            if(props['token_item']) {
                                var item_list = (props['token_item'] instanceof Array ? props['token_item'] : [props['token_item']]);
                                for(var y = 0; y < dialog.data['widgets']['resource_bar_tokens']['array'][1]; y++) {
                                    for(var x = 0; x < dialog.data['widgets']['resource_bar_tokens']['array'][0]; x++) {
                                        var index = y*dialog.data['widgets']['resource_bar_tokens']['array'][0] + x;
                                        if(index < item_list.length) {
                                            var ispec = ItemDisplay.get_inventory_item_spec(item_list[index]);
                                            dialog.widgets[SPUI.get_array_widget_name('resource_bar_tokens', dialog.data['widgets']['resource_bar_tokens']['array'],[x,y])].tooltip.str = dialog.data['widgets']['resource_bar_tokens']['ui_tooltip'].replace('%s', ispec['ui_name_plural']);
                                            dialog.widgets[SPUI.get_array_widget_name('resource_bar_tokens_icon', dialog.data['widgets']['resource_bar_tokens_icon']['array'],[x,y])].asset = ispec['store_icon'];
                                            dialog.widgets[SPUI.get_array_widget_name('resource_bar_tokens_icon', dialog.data['widgets']['resource_bar_tokens_icon']['array'],[x,y])].state = 'normal';
                                            dialog.widgets[SPUI.get_array_widget_name('resource_bar_tokens_amount', dialog.data['widgets']['resource_bar_tokens_amount']['array'],[x,y])].str = pretty_print_number(player.inventory_item_quantity_and_expiration(item_list[index])[0]);
                                        }
                                        dialog.widgets[SPUI.get_array_widget_name('resource_bar_tokens', dialog.data['widgets']['resource_bar_tokens']['array'],[x,y])].onclick = props['prizes_action'] || null;
                                    }
                                }
                            }

                            dialog.widgets['map_battle_button'].show = !!props['map_battle_action'];
                            if(dialog.widgets['map_battle_button'].show) {
                                dialog.widgets['map_battle_button'].show = show_event_info;
                            }
                            dialog.widgets['map_battle_button'].str = (props['map_battle_ui_name'] || dialog.data['widgets']['map_battle_button']['ui_name']);
                            if(props['map_battle_pred'] && !props['map_battle_pred'].is_satisfied(player, null)) {
                                dialog.widgets['map_battle_button'].tooltip.str = dialog.data['widgets']['map_battle_button']['ui_tooltip_locked'].replace('%s', props['map_battle_pred'].ui_describe(player));
                                var helper = get_requirements_help(props['map_battle_pred'], null);
                                if(helper) {
                                    dialog.widgets['map_battle_button'].onclick = helper;
                                    dialog.widgets['map_battle_button'].state = 'disabled_clickable';
                                } else {
                                    dialog.widgets['map_battle_button'].state = 'disabled';
                                }
                            } else {
                                dialog.widgets['map_battle_button'].tooltip.str = null;
                                dialog.widgets['map_battle_button'].onclick = props['map_battle_action'];
                                dialog.widgets['map_battle_button'].state = 'normal';
                            }
                        }
                        show_evil_valentina = show_event_info;
                        fight_button = dialog.widgets['attacker_fight_button'];
                        dialog.widgets['attacker_timer'].str = pretty_print_time_brief(props['time_to_go']);
                        dialog.widgets['attacker_portrait'].bg_image = props['portrait_asset'];
                        dialog.widgets['attacker_speech_title'].str = props['ui_title'];
                        dialog.widgets['attacker_prepare'].str = props['speech_str'];

                        dialog.widgets['attacker_info_button'].show = !!props['info_action'];
                        if (dialog.widgets['attacker_info_button'].show) {
                            dialog.widgets['attacker_info_button'].show = !('event_button_minimized' in player.preferences && player.preferences['event_button_minimized']);
                        }
                        dialog.widgets['attacker_prepare'].text_hjustify = (props['info_action'] ? 'left' : 'center');
                        dialog.widgets['attacker_info_button'].onclick = props['info_action'] || null;
                    }

                    // common event info
                    if(props['act_pred'] && !props['act_pred'].is_satisfied(player, null)) {
                        // player does NOT meet requirement to Fight stage
                        var helper = get_requirements_help(props['act_pred'], null);
                        fight_button.str = fight_button.data['ui_name_locked'];
                        fight_button.onclick = (helper ? helper : null);
                        fight_button.text_color = SPUI.disabled_text_color;
                        fight_button.fixed_tooltip_offset = fight_button.data['fixed_tooltip_offset'];
                        fight_button.tooltip.str = fight_button.data['ui_tooltip_locked'].replace('%s', props['act_pred'].ui_describe(player));
                        fight_button.tooltip.text_color = SPUI.error_text_color;
                    } else if(props['cooldown'] > 0) {
                        // player meets requirements, but it's on cooldown
                        fight_button.str = props['fight_button_ui_name'] || fight_button.data['ui_name'];
                        fight_button.onclick = null;
                        fight_button.text_color = SPUI.disabled_text_color;
                        fight_button.fixed_tooltip_offset = fight_button.data['fixed_tooltip_offset_cooldown'];
                        fight_button.tooltip.str = fight_button.data['ui_tooltip_cooldown'].replace('%s', pretty_print_time_brief(props['cooldown']));
                        fight_button.tooltip.text_color = SPUI.default_text_color;
                    } else {
                        // player DOES meet requirement to Fight next stage
                        fight_button.str = props['fight_button_ui_name'] || fight_button.data['ui_name'];
                        fight_button.onclick = props['fight_action'];
                        fight_button.text_color = SPUI.black_color;
                        fight_button.fixed_tooltip_offset = null; // fight_button.data['fixed_tooltip_offset'];
                        fight_button.tooltip.str = props['fight_button_ui_tooltip'] || null;
                        fight_button.tooltip.text_color = SPUI.default_text_color;
                    }
                }

                if(d && d.widgets['prizes_button']) {
                    d.widgets['prizes_button'].onclick = props['prizes_action'];
                    d.widgets['prizes_button'].str = props['prizes_ui_name'] || d.data['widgets']['prizes_button']['ui_name'];
                }

                if(d && d.widgets['enemy_portrait']) {
                    d.widgets['enemy_portrait'].bg_image = props['portrait_asset'];
                    d.widgets['enemy_portrait'].onclick = props['portrait_action']||null;
                    d.widgets['enemy_portrait'].tooltip.str = props['portrait_tooltip']||null;
                    d.widgets['enemy_portrait'].state = (props['portrait_action'] || !('disabled' in GameArt.assets[props['portrait_asset']].states) ? 'normal' : 'disabled');
                    if(d.widgets['enemy_portrait_bg_highlight']) {
                        d.widgets['enemy_portrait_bg_highlight'].show = !!props['portrait_action'];
                        var spring_up = (!!props['portrait_action']) && d.widgets['enemy_portrait'].detect_hit([mouse_state.last_raw_x,mouse_state.last_raw_y], d.widgets['enemy_portrait'].parent.get_absolute_xy());
                        goog.array.forEach(['enemy_portrait_bg', 'enemy_portrait_bg_highlight', 'enemy_portrait'], function(name) {
                            d.widgets[name].xy = vec_add(d.data['widgets'][name]['xy'], spring_up ? [0,-1] : [0,0]);
                        });
                    }
                }
            }
        }

        // regional event info display
        if(player.tutorial_state == "COMPLETE" &&
           read_predicate({'predicate':'LIBRARY', 'name': 'hide_event_info_until'}).is_satisfied(player, null) &&
           !(global_chat_frame && global_chat_frame.user_data['size'] === 'big')) {
            var quarry_event = player.get_event_data('current_event', 'event_quarry_contest');
            if(quarry_event) {
                show_regional_event_info = true;
                dialog.widgets['regional_title'].str = quarry_event['ui_title'];
                dialog.widgets['regional_descr'].str = quarry_event['ui_description'];
                dialog.widgets['regional_timer'].str = pretty_print_time_brief(-player.get_event_time('current_event', 'event_quarry_contest', 'end'));
                var rank_str = null;
                if(session.region.contest_rank) {
                    rank_str = pretty_print_number(session.region.contest_rank['rank']+1);
                }
                dialog.widgets['regional_rank'].str = (rank_str ? quarry_event['ui_rank'].replace('%d', rank_str) : dialog.widgets['regional_rank'].data['ui_name']);
                dialog.widgets['regional_leaderboard_button'].onclick = function() {
                    invoke_leaderboard('week', 'all', 'quarry_resources');
                };
            }
        }

        dialog.widgets['regional_bg'].show =
        dialog.widgets['regional_sunken'].show =
        dialog.widgets['regional_bg_point'].show =
        dialog.widgets['regional_rect'].show =
        dialog.widgets['regional_title'].show =
        dialog.widgets['regional_rank'].show =
        dialog.widgets['regional_descr'].show =
        dialog.widgets['regional_timer'].show =
        dialog.widgets['regional_leaderboard_button'].show = show_regional_event_info;

        dialog.widgets['attacker_portrait'].show =
            dialog.widgets['attacker_speech_bg'].show =
            dialog.widgets['attacker_speech_title'].show =
            dialog.widgets['attacker_prepare'].show =
            dialog.widgets['attacker_timer'].show =
            dialog.widgets['attacker_fight_button'].show = show_evil_valentina;

        } // END not defending an attack

    } else { // END home_base

        // update desktop_bottom_visitor

        dialog.widgets['climate_restrictions'].show = session.viewing_base.climate.has_climate_restrictions();
        if(dialog.widgets['climate_restrictions'].show) {
            dialog.widgets['climate_restrictions'].str = dialog.data['widgets']['climate_restrictions']['ui_name'].replace('%name', session.viewing_base.climate.data['ui_name']).replace('%s', session.viewing_base.climate.describe_climate_restrictions());
        }

        dialog.widgets['deployable_squads'].show = (player.squads_enabled() && session.deployable_squads.length > 0 && /* squads available */
                                                    session.viewing_base.base_landlord_id != session.user_id && /* at foreign base */
                                                    (session.region.data && session.region.data['storage'] == 'nosql') && /* on the map */
                                                    (gamedata['unit_deploy_style'] !== 'squad') /* not using squad deploy style */
                                                   );
        if(dialog.widgets['deployable_squads'].show) {
            var ui_list = [];
            goog.array.forEach(session.deployable_squads, function(squad_id) {
                if(squad_id.toString() in player.squads) {
                    ui_list.push('['+player.squads[squad_id.toString()]['ui_name']+']');
                }
            });
            dialog.widgets['deployable_squads'].str = dialog.data['widgets']['deployable_squads']['ui_name'].replace('%s', ui_list.join(', '));
        }

        if(!session.has_attacked || (session.viewing_base.base_landlord_id == session.user_id &&
                                     session.region.data && session.region.data['storage'] == 'nosql')) {
            // show "Return Home" button, hide combat unit deployment
            dialog.widgets['bg_blanker'].show = true;
            dialog.widgets['bg_blanker'].xy = dialog.data['widgets']['bg_blanker']['xy' + (session.is_ladder_battle() ? '_ladder' : '')];

            dialog.widgets['ladder_switch_price_icon'].show =
                dialog.widgets['ladder_switch_price'].show =
                dialog.widgets['ladder_switch_button'].show = session.is_ladder_battle() && player.is_ladder_player();
            var cost = eval_cond_or_literal(gamedata['matchmaking']['ladder_match_switch_cost'], player, null);
            for(var res in cost) {
                // note: can't display multiple resources
                dialog.widgets['ladder_switch_price_icon'].asset = gamedata['resources'][res]['icon_small'];
                dialog.widgets['ladder_switch_price'].str = pretty_print_number(cost[res]);
            }
            var res_ok = true;
            for(var res in cost) {
                if(player.resource_state[res][1] < cost[res]) {
                    res_ok = false; break;
                }
            }
            if(visit_base_pending || !res_ok || !player.is_ladder_player()) {
                dialog.widgets['ladder_switch_price'].onclick = dialog.widgets['ladder_switch_button'].onclick = null;
                dialog.widgets['ladder_switch_button'].state = 'disabled';
            } else {
                dialog.widgets['ladder_switch_price'].onclick =
                    dialog.widgets['ladder_switch_button'].onclick = function(w) {
                        var dialog = w.parent;
                        var cost = eval_cond_or_literal(gamedata['matchmaking']['ladder_match_switch_cost'], player, null);
                        var res_ok = true;
                        for(var res in cost) {
                            if(player.resource_state[res][1] < cost[res]) {
                                res_ok = false; break;
                            }
                        }

                        if(!visit_base_pending && res_ok) {
                            do_visit_base(-1, {ladder_battle:1, ladder_switch:1});
                        }
                    };
            }

            dialog.widgets['home_button'].show = true;
            dialog.widgets['home_button'].state = (player.tutorial_state === "COMPLETE") ? 'normal':'disabled';
            dialog.widgets['unit_deployment_bar'].show = false;

            // reset dialog to normal dimensions
            dialog.wh = [dialog.data['dimensions'][0],
                         dialog.data['dimensions'][1]];

            dialog.widgets['deployable_squads'].xy = dialog.data['widgets']['deployable_squads']['xy'];
            dialog.widgets['climate_restrictions'].xy = dialog.data['widgets']['climate_restrictions']['xy'];

        } else {
            // hide "Return Home" button, show combat unit deployment
            dialog.widgets['bg_blanker'].show = (gamedata['unit_deploy_style'] == 'drip');
            dialog.widgets['bg_blanker'].xy = dialog.data['widgets']['bg_blanker']['xy'];
            dialog.widgets['bg_blanker'].color = SPUI.make_colorv(dialog.data['widgets']['bg_blanker']['color_combat']);

            dialog.widgets['ladder_switch_price_icon'].show =
                dialog.widgets['ladder_switch_price'].show =
                dialog.widgets['ladder_switch_button'].show =
                dialog.widgets['home_button'].show = false;

            dialog.widgets['unit_deployment_bar'].show = true;
            var deploy_info = update_unit_deployment_bar(dialog);
            var show_cols = deploy_info.show_cols;
            if(dialog.widgets['deployable_squads'].show) {
                dialog.widgets['deployable_squads'].xy = vec_add(dialog.data['widgets']['deployable_squads']['xy'],
                                                                 vec_scale(show_cols-1, dialog.data['widgets']['deployable_squads']['xy_per_col']));
            }

            if(dialog.widgets['climate_restrictions'].show) {
                dialog.widgets['climate_restrictions'].xy = vec_add(dialog.data['widgets']['climate_restrictions']['xy'],
                                                                    vec_scale(show_cols-1, dialog.data['widgets']['climate_restrictions']['xy_per_col']));
            }

        } // END session HAS attacked

    } // END not home base

    // center at bottom of game window
    dialog.xy = [desktop_dialogs['desktop_top'].xy[0], // Math.max(0, Math.floor(canvas_width/2 - dialog.wh[0]/2)),
                 canvas_height - dialog.wh[1]];

    if(!session.home_base && session.has_attacked && gamedata['client']['end_attack_button_placement'] == 'bottom_left') {
        // make sure desktop_bottom and unit deployment bar don't slide underneath the End Attack button with narrow browser window

        // compute absolute X coordinate of right-hand edge of End Attack button, plus a little padding
        var edge = 2*gamedata['dialogs']['attack_button_dialog']['bottom_left_offset'][0] +
            gamedata['dialogs']['attack_button_dialog']['dimensions'][0];
        dialog.xy[0] = Math.max(dialog.xy[0], edge);
    }

    if(global_spell_icon) {
        var namsp = null;
        if(selection.unit && selection.unit.is_mobile()) {
            namsp = selection.unit.get_special_ability_spell();
        }
        global_spell_icon.set_spell(selection.unit, namsp ? namsp[0] : null, namsp ? namsp[1] : null);
        global_spell_icon.xy = [dialog.xy[0]+60, dialog.xy[1]-40];
    }
}

/** @param {!SPUI.Dialog} dialog is desktop_bottom_visitor, not the unit_deployment_bar itself
    (we need to tweak some other widget position depending on what is shown on the bar)
    @return {{show_cols: number}} */
function update_unit_deployment_bar(dialog) {
    if(gamedata['unit_deploy_style'] === 'squad') {
        return update_unit_deployment_bar_squad(dialog);
    } else {
        return update_unit_deployment_bar_batch_or_drip(dialog);
    }
}

/** @param {!SPUI.Dialog} dialog is desktop_bottom_visitor, not the unit_deployment_bar itself
    @return {{show_cols: number}} */
function update_unit_deployment_bar_squad(dialog) {
    var max_icons = dialog.widgets['unit_deployment_bar'].data['widgets']['squad']['array'][0];
    var i = 0;

    dialog.widgets['unit_deployment_bar'].user_data['deploy_button_squad_ids'] = [];

    // detect when pre_deploy_units got cleared out, e.g. by pressing Escape
    if(goog.object.isEmpty(session.pre_deploy_units)) {
        dialog.widgets['unit_deployment_bar'].user_data['selected_squad_id'] = null;
    }

    var selected_squad_id = dialog.widgets['unit_deployment_bar'].user_data['selected_squad_id'];

    // scan deployable units for info
    var squad_ids_passing_climate_restrictions = {}; // for check against climate restrictions
    var min_space_by_squad_id = {}; // minimum space to deploy one unit from this squad
    var total_space_by_squad_id = {}; // total space still deployable in this squad
    var max_build_time_by_squad_id = {}; // for deciding on which unit is the "coolest"
    var representative_specname_by_squad_id = {};

    // note: this skips already-deployed units
    session.foreach_deployable_unit(function (army_unit) {
        var squad_id = army_unit['squad_id'] || 0
        var spec = gamedata['units'][army_unit['spec']];
        var level = army_unit['level'] || 1;
        var space = get_leveled_quantity(spec['consumes_space'] || 0, level);
        var build_time = get_leveled_quantity(spec['build_time'] || 0, level);

        squad_ids_passing_climate_restrictions[squad_id] = 1;

        if(!(squad_id in min_space_by_squad_id) || space < min_space_by_squad_id[squad_id]) {
            min_space_by_squad_id[squad_id] = space;
        }
        total_space_by_squad_id[squad_id] = (total_space_by_squad_id[squad_id] || 0) + space;
        if(!(squad_id in max_build_time_by_squad_id) || build_time > max_build_time_by_squad_id[squad_id]) {
            max_build_time_by_squad_id[squad_id] = build_time;
            representative_specname_by_squad_id[squad_id] = army_unit['spec'];
        }
    });

    goog.array.forEach(session.deployable_squads, function(squad_id) {
        if(i >= max_icons) {
            //console.log('Ran out of space to display deployable units!');
            return;
        }

        if(!(squad_id in squad_ids_passing_climate_restrictions)) { return; }

        var squad = player.squads[squad_id.toString()];
        dialog.widgets['unit_deployment_bar'].user_data['deploy_button_squad_ids'].push(squad_id);

        var d = dialog.widgets['unit_deployment_bar'].widgets['squad'+i.toString()];
        d.show = true;
        d.user_data['squad_id'] = squad_id;

        var deploy_limit = session.deployed_unit_space - (selected_squad_id in total_space_by_squad_id ? total_space_by_squad_id[selected_squad_id] : 0);
        var can_deploy = (squad_id in squad_ids_passing_climate_restrictions) &&
            (deploy_limit+min_space_by_squad_id[squad_id] <= get_player_stat(player.stattab, 'deployable_unit_space'));
        d.user_data['can_deploy'] = can_deploy;

        d.widgets['cancel'].onclick = function(w) {
            var d = w.parent;
            var dialog = d.parent.parent;
            // switch away from current selection
            goog.object.forEach(session.pre_deploy_units, function(obj, obj_id) {
                var spec = gamedata['units'][obj['spec']];
                session.deployed_unit_space -= get_leveled_quantity(spec['consumes_space'] || 0, obj['level']||1);
            });
            goog.object.clear(session.pre_deploy_units);
            dialog.widgets['unit_deployment_bar'].user_data['selected_squad_id'] = null;
            change_selection_ui(null);
        };
        d.widgets['cancel'].show = (selected_squad_id == squad_id);

        // set up callbacks
        var onclick = (function (_d) { return function() {
            var squad_id = _d.user_data['squad_id'];
            var dialog = _d.parent.parent;
            if(dialog.widgets['unit_deployment_bar'].user_data['selected_squad_id'] === squad_id) { return; }
            if(dialog.widgets['unit_deployment_bar'].user_data['selected_squad_id'] !== null) {
                // switch away from current selection
                goog.object.forEach(session.pre_deploy_units, function(obj, obj_id) {
                    var spec = gamedata['units'][obj['spec']];
                    session.deployed_unit_space -= get_leveled_quantity(spec['consumes_space'] || 0, obj['level']||1);
                });
                goog.object.clear(session.pre_deploy_units);
                dialog.widgets['unit_deployment_bar'].user_data['selected_squad_id'] = null;
            }

            // at this point we are sure at least one unit can be deployed from this squad

            /** @type {string|null} specname of first unit affected by weak-unit debuffs */
            var is_zombie = null;
            /** @type {string|null} */
            var is_weak_secteam = null;

            session.foreach_deployable_unit(function (army_unit) {
                if((army_unit['squad_id'] || 0) !== squad_id) { return; }

                var spec = gamedata['units'][army_unit['spec']];
                var level = army_unit['level'] || 1;
                var space = get_leveled_quantity(spec['consumes_space'] || 0, level);

                // check deployment space limit
                if(session.deployed_unit_space + space > get_player_stat(player.stattab, 'deployable_unit_space')) {
                    return;
                }

                var curmax = army_unit_hp(army_unit);
                var ratio = curmax[0]/Math.max(curmax[1],1);

                if(!is_zombie && gamedata['zombie_debuff_threshold'] >= 0 && ratio < gamedata['zombie_debuff_threshold']) {
                    is_zombie = army_unit['spec'];
                }
                if(!is_weak_secteam && gamedata['weak_secteam_debuff_threshold'] >= 0 && ratio < gamedata['weak_secteam_debuff_threshold'] && player.unit_carries_secteam(army_unit['spec'], level)) {
                    is_weak_secteam = army_unit['spec'];
                }

                session.pre_deploy_units[army_unit['obj_id']] = army_unit;
                session.deployed_unit_space += space;
            });

            // set up deployment cursor.
            dialog.widgets['unit_deployment_bar'].user_data['selected_squad_id'] = squad_id;
            if(!(selection.ui && selection.ui.user_data && selection.ui.user_data['cursor'] == 'DeployUICursor')) {
                change_selection(player.virtual_units["DEPLOYER"]);
                selection.spellname = "DEPLOY_UNITS";
                var cursor = new DeployUICursor();
                change_selection_ui_under(cursor);
            }

            if(player.tutorial_state == "COMPLETE") {
                if(is_zombie) {
                    invoke_weak_unit_tip('weak_zombie_tip', /** @type {string} */ (is_zombie), gamedata['zombie_debuff_threshold']);
                } else if(is_weak_secteam) {
                    invoke_weak_unit_tip('weak_secteam_tip', /** @type {string} */ (is_weak_secteam), gamedata['weak_secteam_debuff_threshold']);
                }
            }

            player.quest_tracked_dirty = true;
            return true;
        }; })(d);
        var frame_state = (selected_squad_id == squad_id ?
                           'active': (can_deploy ? 'normal' : 'disabled'));
        var squad_ui_name = squad['ui_name'] || '';
        d.widgets['name'].str = squad_ui_name;
        unit_icon_set(d.widgets['icon'], representative_specname_by_squad_id[squad_id], -1, null, onclick, frame_state, null, false);
        d.widgets['bg'].onclick = (can_deploy ? onclick : null);
        d.widgets['bg_highlight'].show = (frame_state != 'disabled');
        d.widgets['bg_highlight'].fade_unless_hover = (frame_state === 'active' ? 0 : d.data['widgets']['bg_highlight']['fade_unless_hover']);
        d.widgets['bg_highlight'].outline_color = SPUI.make_colorv(d.data['widgets']['bg_highlight'][(frame_state === 'active' ? 'outline_color_active' : 'outline_color')]);
        d.widgets['name'].text_color = SPUI.make_colorv(d.data['widgets']['name'][(frame_state === 'active' ?
                                                                                   'text_color_active' :
                                                                                   (frame_state === 'disabled' ?
                                                                                    'text_color_disabled' :
                                                                                    'text_color'))]);

        // override unit_icon_set here
        d.widgets['icon'].widgets['frame'].show =
            d.widgets['icon'].widgets['slot'].show = false;
        i += 1;
    });

    // DONATED UNITS
    if(i < max_icons && player.unit_donation_enabled() && player.has_donated_units() &&
       !session.viewing_base.climate.has_climate_unit_restrictions() && session.viewing_base.deployment_allowed) {
        throw Error('donated units not supported');
    }

    var ONEROW = 11;
    var show_rows = Math.max(i, ONEROW); // always show at least one full row
    var show_cols = Math.floor((i+ONEROW-1)/ONEROW);
    var vpad = dialog.widgets['unit_deployment_bar'].data['dimensions'][1] - (dialog.widgets['unit_deployment_bar'].data['widgets']['squad']['xy'][1] + dialog.widgets['unit_deployment_bar'].data['widgets']['squad']['dimensions'][1]);
    var col_height = (vpad+dialog.widgets['unit_deployment_bar'].data['widgets']['squad']['dimensions'][1]);

    for(var k = 0; k < i; k++) {
        // position widgets into columns
        var col = Math.floor(k/ONEROW);
        var wdat = dialog.widgets['unit_deployment_bar'].data['widgets']['squad'];
        var d = dialog.widgets['unit_deployment_bar'].widgets['squad'+k.toString()];
        d.xy = [wdat['xy'][0]+(k%ONEROW)*wdat['array_offset'][0],
                wdat['xy'][1]+(show_cols-col-1)*col_height];
        if(d.widgets['bg'].fixed_tooltip_offset) {
            // reposition donated units tooltip so it does not obscure the button
            if(dialog.widgets['unit_deployment_bar'].user_data['deploy_button_squad_ids'][k] === 'DONATED_UNITS' &&
               d.widgets['bg'].tooltip.str) {
                d.widgets['bg'].fixed_tooltip_offset = vec_add(d.data['widgets']['bg']['fixed_tooltip_offset'],
                                                               [0, -Math.floor((d.widgets['bg'].tooltip.str.split('\n').length-1.5)*SPUI.desktop_font.leading)]);
            }
        }
    }

    // set .wh of dialog so that dialog is the right size, and mouse clicks will always be trapped
    dialog.wh = dialog.widgets['unit_deployment_bar'].wh = [ONEROW * dialog.widgets['unit_deployment_bar'].data['widgets']['squad']['array_offset'][0],
                                                            show_cols * col_height + dialog.widgets['unit_deployment_bar'].data['widgets']['squad']['xy'][1]];

    while(i < max_icons) {
        dialog.widgets['unit_deployment_bar'].widgets['squad'+i.toString()].show = (i < show_rows);
        goog.object.forEach(dialog.widgets['unit_deployment_bar'].widgets['squad'+i.toString()].widgets, function(w, wname) {
                w.show = false;
        });
        i += 1;
    }

    return {show_cols: show_cols};
}

/** @param {!SPUI.Dialog} dialog is desktop_bottom_visitor, not the unit_deployment_bar itself
    @return {{show_cols: number}} */
function update_unit_deployment_bar_batch_or_drip(dialog) {
    var max_icons = dialog.widgets['unit_deployment_bar'].data['widgets']['unit']['array'][0];
    var i = 0;

    // first see how many we need to skip, in order to show the most powerful units
    var unique_specs = {};
    session.foreach_deployable_unit(function(obj) {
        unique_specs[obj['spec']] = 1;
    });
    var uniques = goog.object.getCount(unique_specs);

    if(player.unit_donation_enabled() && player.has_donated_units() && session.viewing_base.deployment_allowed) { uniques += 1; }

    var skip = 0;
    if(uniques > max_icons) {
        skip = uniques - max_icons;
    }

    dialog.user_data['deploy_button_specs'] = [];
    var any_can_deploy = false;

    for(var specname in gamedata['units']) {
        var spec = gamedata['units'][specname];

        if(!(specname in unique_specs)) { continue; }
        if(!session.viewing_base.climate.can_deploy_unit_of_spec(spec)) { continue; }
        if(skip > 0) { skip--; continue; }
        var home_qty = session.count_deployable_units_of_spec(specname);
        var in_battle_qty = session.count_post_deploy_units_of_spec(specname);
        var deploy_qty = session.count_pre_deploy_units_of_spec(specname);

        dialog.user_data['deploy_button_specs'].push(specname);

        var d = dialog.widgets['unit_deployment_bar'].widgets['unit'+i.toString()];
        d.show = true;

        // set up callbacks
        var incr_callback = function (name, incr) { return function() {
            // check quantity limit
            incr = Math.min(incr, session.count_deployable_units_of_spec(name) - session.count_pre_deploy_units_of_spec(name));

            // check deployment space limit
            var space = gamedata['units'][name]['consumes_space'];
            if(space > 0) {
                var limit = get_player_stat(player.stattab, 'deployable_unit_space');
                incr = Math.min(incr, Math.floor((limit - session.deployed_unit_space)/space));
            }

            if(incr < 1) { return false; }

            // set up deployment cursor.
            // for tutorial, hold off until all units are readied for deployment
            if(player.tutorial_state != "COMPLETE" && gamedata['tutorial'][player.tutorial_state]['next'] != 'place_robots_message') {
            } else if(selection.spellname != "DEPLOY_UNITS") {
                change_selection(player.virtual_units["DEPLOYER"]);
                selection.spellname = "DEPLOY_UNITS";
                var cursor = new DeployUICursor();
                change_selection_ui_under(cursor);
            }

            /** @type {string|null} specname of first unit affected by weak-unit debuffs */
            var is_zombie = null;
            /** @type {string|null} */
            var is_weak_secteam = null;

            for(var i = 0; i < incr; i++) {
                var obj_zomb = session.get_next_deployable_unit(name);
                var obj = obj_zomb[0];
                if(!is_zombie && obj_zomb[1]) { is_zombie = obj['spec']; }
                if(!is_weak_secteam && obj_zomb[2]) { is_weak_secteam = obj['spec']; }
                session.pre_deploy_units[obj['obj_id']] = obj;
                if(gamedata['unit_deploy_style'] != 'drip') {
                    // batch-style unit deployment predicts deployed_unit_space as the cursor fills up, drip-style does not
                    session.deployed_unit_space += space;
                }
            }

            if(player.tutorial_state == "COMPLETE") {
                if(is_zombie) {
                    invoke_weak_unit_tip('weak_zombie_tip', /** @type {string} */ (is_zombie), gamedata['zombie_debuff_threshold']);
                } else if(is_weak_secteam) {
                    invoke_weak_unit_tip('weak_secteam_tip', /** @type {string} */ (is_weak_secteam), gamedata['weak_secteam_debuff_threshold']);
                }
            }

            player.quest_tracked_dirty = true;
            if(player.tutorial_state.indexOf('deploy_robots_action') != -1) { advance_tutorial(); }
            return true;
        }; };

        var tip = spec['ui_name']+'\n'+spec['ui_tip'];
        if('ui_tip2' in spec) { tip += '\n'+spec['ui_tip2']; }
        var can_deploy;

        if(gamedata['unit_deploy_style'] == 'drip') {
            can_deploy = (session.deployed_unit_space+spec['consumes_space'] <= get_player_stat(player.stattab, 'deployable_unit_space'));

            var init_deployer = (function(_incr_callback) { return function(_specname) {
                if(selection.ui && selection.ui.user_data && selection.ui.user_data['cursor'] == 'DeployUICursor') { return; }
                change_selection(player.virtual_units["DEPLOYER"]);
                selection.spellname = "DEPLOY_UNITS";
                var cursor = new DeployUICursor();
                change_selection_ui_under(cursor);

                _incr_callback(_specname, session.count_deployable_units_of_spec(_specname) - session.count_pre_deploy_units_of_spec(_specname))();

            };})(incr_callback);

            // initialize drip_unit
            if(d.parent.user_data['drip_unit'] === null && can_deploy) {
                d.parent.user_data['drip_unit'] = specname;
                d.parent.user_data['drip_unit_push_time'] = -1;
                init_deployer(specname);
            }
            d.user_data['specname'] = specname;
            if('icon' in spec) {
                d.widgets['item'].asset = get_leveled_quantity(spec['icon'],1);
            } else {
                d.widgets['item'].asset = get_leveled_quantity(spec['art_asset'],1);
            }
            d.widgets['item'].state = GameArt.assets[d.widgets['item'].asset].has_state('icon') ? 'icon' : 'normal';
            d.widgets['stack'].str = home_qty.toString();
            d.widgets['frame'].state = (d.parent.user_data['drip_unit'] == specname ? 'active': (can_deploy ? 'normal' : 'disabled'));
            d.widgets['frame'].tooltip.str = tip;
            d.widgets['frame'].tooltip.delay = 0.25;

            d.widgets['frame'].onclick = (function (_init_deployer) { return function(w) {
                var _d = w.parent;
                _d.parent.user_data['drip_unit'] = _d.user_data['specname'];
                change_selection_ui(null);
                _init_deployer(_d.user_data['specname']);
            }; })(init_deployer);

        } else {
            can_deploy = (deploy_qty < home_qty) &&
                (session.deployed_unit_space+spec['consumes_space'] <= get_player_stat(player.stattab, 'deployable_unit_space'));

            d.widgets['plus_all'].str = d.data['widgets']['plus_all']['ui_name'];
            d.widgets['plus_one'].show = true;

            d.widgets['cancel'].show = (deploy_qty > 0);
            d.widgets['plus_one'].state = d.widgets['plus_all'].state = (can_deploy ? 'normal' : 'disabled');

            d.widgets['bg'].tooltip.str = tip;
            d.widgets['unit'].bg_image = get_leveled_quantity(spec['art_asset'],1);
            d.widgets['unit'].state = 'icon';
            d.widgets['unit'].alpha = (spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1);
            d.widgets['counter'].str = deploy_qty.toString()+'/'+home_qty.toString();

            d.widgets['unit'].onclick = d.widgets['plus_one'].onclick = incr_callback(specname, 1);
            d.widgets['plus_all'].onclick = incr_callback(specname, 10);

            d.widgets['cancel'].onclick = (function (name) { return function() {
                // un-pre-deploy the weakest unit
                var weakest = session.get_weakest_pre_deploy_unit(name);

                if(weakest) {
                    delete session.pre_deploy_units[weakest['obj_id']];
                    session.deployed_unit_space -= get_leveled_quantity(gamedata['units'][weakest['spec']]['consumes_space'], weakest['level']||1);
                }

                // if in combat, and no more units are left in session.pre_deploy_units, kill the cursor
                if(session.has_deployed) {
                    var any_left = goog.object.getCount(session.pre_deploy_units) > 0;
                    if(!any_left) {
                        change_selection(null);
                    }
                }
            }; })(specname);

            // disable non-applicable buttons in tutorial
            if(player.tutorial_state != "COMPLETE") {
                d.widgets['unit'].onclick = null;
                d.widgets['plus_one'].state = 'disabled';
                d.widgets['cancel'].show = false;
                if('button' in gamedata['tutorial'][player.tutorial_state] &&
                   gamedata['tutorial'][player.tutorial_state]['button'].indexOf('DEPLOY_UNIT:') == 0 &&
                   gamedata['tutorial'][player.tutorial_state]['button'].split(':')[1] != specname) {
                    d.widgets['plus_all'].state = 'disabled';
                }
            }
        }

        any_can_deploy |= can_deploy;

        i += 1;
        if(i >= max_icons) {
            //console.log('Ran out of space to display deployable units!');
            break;
        }
    }

    // DONATED UNITS
    if(i < max_icons && player.unit_donation_enabled() && player.has_donated_units() &&
       !session.viewing_base.climate.has_climate_unit_restrictions() && session.viewing_base.deployment_allowed) {

        var specname = 'DONATED_UNITS';
        dialog.user_data['deploy_button_specs'].push(specname);
        var deploy_qty = session.count_pre_deploy_donated_units();
        var home_qty = player.count_donated_units();
        var consumes_space = (gamedata['donated_units_take_space'] ? player.donated_units_space() : 0);
        if(consumes_space) { throw Error('this case not handled'); }
        var can_deploy;

        // set up callbacks
        var add_donated_units = function() {
            // set up deployment cursor
            if(selection.spellname != "DEPLOY_UNITS") {
                change_selection(player.virtual_units["DEPLOYER"]);
                selection.spellname = "DEPLOY_UNITS";
                var cursor = new DeployUICursor();
                change_selection_ui_under(cursor);
            }
            // queue the units
            goog.object.forEach(player.donated_units, function(entry) {
                // note that we could just do one at a time now!
                // note: "spec" is not required for the server protocol, but we need it to simplify do_deploy() FX and DeployUICursor.destroy()
                var new_entry = {'obj_id': entry['obj_id'], 'spec': entry['spec'], 'source': 'donated'};
                session.pre_deploy_units[new_entry['obj_id']] = new_entry;
                // (note: would add deployed_unit_space requirement here, in non-drip mode, if we wanted to track it)
            });

            player.quest_tracked_dirty = true;
        };

        var d = dialog.widgets['unit_deployment_bar'].widgets['unit'+i.toString()];
        d.show = true;

        if(gamedata['unit_deploy_style'] == 'drip') {
            can_deploy = true;

            var init_deployer = (function(_add_donated_units) { return function() {
                if(selection.ui && selection.ui.user_data && selection.ui.user_data['cursor'] == 'DeployUICursor') { return; }
                change_selection(player.virtual_units["DEPLOYER"]);
                selection.spellname = "DEPLOY_UNITS";
                var cursor = new DeployUICursor();
                change_selection_ui_under(cursor);
                _add_donated_units();
            };})(add_donated_units);

            // initialize drip_unit
            if(d.parent.user_data['drip_unit'] === null && can_deploy) {
                d.parent.user_data['drip_unit'] = specname;
                d.parent.user_data['drip_unit_push_time'] = -1;
                init_deployer();
            }
            d.user_data['specname'] = specname;
            d.widgets['item'].asset = player.donated_units_icon();

            d.widgets['stack'].str = home_qty.toString();
            d.widgets['frame'].state = (d.parent.user_data['drip_unit'] == specname ? 'active': (can_deploy ? 'normal' : 'disabled'));
            d.widgets['frame'].tooltip.str = gamedata['auras']['donated_units']['ui_description'] + '\n' + player.donated_units_description('\n');
            d.widgets['frame'].tooltip.delay = 0.25;

            d.widgets['frame'].onclick = (function (_init_deployer) { return function(w) {
                var _d = w.parent;
                _d.parent.user_data['drip_unit'] = _d.user_data['specname'];
                change_selection_ui(null);
                _init_deployer();
            }; })(init_deployer);

        } else {
            can_deploy = (deploy_qty < home_qty);
            d.widgets['bg'].tooltip.str = gamedata['auras']['donated_units']['ui_description'] + '\n' + player.donated_units_description('\n');
            d.widgets['unit'].bg_image = player.donated_units_icon();
            d.widgets['unit'].state = 'normal';
            d.widgets['counter'].str = deploy_qty+'/'+home_qty;

            d.widgets['plus_one'].state = d.widgets['plus_all'].state = (can_deploy ? 'normal' : 'disabled');
            d.widgets['plus_all'].str = d.data['widgets']['plus_all']['ui_name_donated_units'];

            d.widgets['unit'].onclick = d.widgets['plus_one'].onclick = d.widgets['plus_all'].onclick = add_donated_units;
            d.widgets['plus_one'].show = false;

            d.widgets['cancel'].show = (deploy_qty > 0);
            d.widgets['cancel'].onclick = (function (name, _consumes_space) { return function() {
                // remove all donations from pre_deploy_units
                session.pre_deploy_units = goog.object.filter(session.pre_deploy_units, function(entry) { return entry['source'] !== 'donated'; });
                // note: deployed_unit_space tracking would go here

                // if in combat, and no more units are left in session.pre_deploy_units, kill the cursor
                if(session.has_deployed) {
                    var any_left = goog.object.getCount(session.pre_deploy_units) > 0;
                    if(!any_left) {
                        change_selection(null);
                    }
                }
            }; })(specname, consumes_space);
        }
        any_can_deploy |= can_deploy;
        i += 1;
    }

    if(gamedata['unit_deploy_style'] == 'drip' && !any_can_deploy &&
       selection.ui && selection.ui.user_data && selection.ui.user_data['cursor'] == 'DeployUICursor') {
        // cannot drip-deploy any more units
        change_selection_ui(null);
    }

    var ONEROW = 11;
    var show_rows = Math.max(i, ONEROW); // always show at least one full row
    var show_cols = Math.floor((i+ONEROW-1)/ONEROW);
    var vpad = dialog.widgets['unit_deployment_bar'].data['dimensions'][1] - (dialog.widgets['unit_deployment_bar'].data['widgets']['unit']['xy'][1] + dialog.widgets['unit_deployment_bar'].data['widgets']['unit']['dimensions'][1]);
    var col_height = (vpad+dialog.widgets['unit_deployment_bar'].data['widgets']['unit']['dimensions'][1]);

    for(var k = 0; k < i; k++) {
        // position widgets into columns
        var col = Math.floor(k/ONEROW);
        var wdat = dialog.widgets['unit_deployment_bar'].data['widgets']['unit'];
        var d = dialog.widgets['unit_deployment_bar'].widgets['unit'+k.toString()];
        d.xy = [wdat['xy'][0]+(k%ONEROW)*wdat['array_offset'][0],
                wdat['xy'][1]+(show_cols-col-1)*col_height];
        var tipwidget = (gamedata['unit_deploy_style'] == 'drip' || gamedata['unit_deploy_style'] == 'squad' ?
                         'frame' : 'bg');
        if(d.widgets[tipwidget].fixed_tooltip_offset) {
            // reposition donated units tooltip so it does not obscure the button
            if(dialog.user_data['deploy_button_specs'][k] == 'DONATED_UNITS' &&
               d.widgets[tipwidget].tooltip.str) {
                d.widgets[tipwidget].fixed_tooltip_offset = vec_add(d.data['widgets'][tipwidget]['fixed_tooltip_offset'],
                                                                    [0, -Math.floor((d.widgets[tipwidget].tooltip.str.split('\n').length-1.5)*SPUI.desktop_font.leading)]);
            }
        }
    }

    // set .wh of dialog so that dialog is the right size, and mouse clicks will always be trapped
    dialog.wh = dialog.widgets['unit_deployment_bar'].wh = [ONEROW * dialog.widgets['unit_deployment_bar'].data['widgets']['unit']['array_offset'][0],
                                                            show_cols * col_height + dialog.widgets['unit_deployment_bar'].data['widgets']['unit']['xy'][1]];

    while(i < max_icons) {
        dialog.widgets['unit_deployment_bar'].widgets['unit'+i.toString()].show = (i < show_rows);
        goog.object.forEach(dialog.widgets['unit_deployment_bar'].widgets['unit'+i.toString()].widgets, function(w, wname) {
            if(wname != 'bg') {
                w.show = false;
            }
        });
        i += 1;
    }

    return {show_cols: show_cols};
}

function init_combat_item_bar() {
    if(!('combat_item_bar' in desktop_dialogs)) {
        var dialog = invoke_combat_item_bar();
        if(dialog) {
            desktop_dialogs['combat_item_bar'] = dialog;
            SPUI.root.add_under(dialog);
        }
    }
}

function invoke_combat_item_bar() {
    var dialog_data = gamedata['dialogs']['combat_item_bar'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'combat_item_bar';
    dialog.user_data['context'] = null;
    dialog.user_data['scroll_pos'] = 0;
    dialog.transparent_to_mouse = true;
    dialog.widgets['scroll_left'].widgets['scroll_left'].onclick = function(w) {
        w.parent.parent.user_data['scroll_pos'] -= 1;
    };
    dialog.widgets['scroll_right'].widgets['scroll_right'].onclick = function(w) {
        w.parent.parent.user_data['scroll_pos'] += 1;
    };
    dialog.ondraw = update_combat_item_bar;
    return dialog;
}

/** return values from inventory_item_is_usable_in_combat()
    @enum {number} */
var UsableInCombat = {
    NOT_USABLE : 0,
    USABLE_BOOST : 1, // aura applier (low priority)
    USABLE_MISSILE : 2 // missile (high priority)
};

/** Determine if an item of this spec can be used during the current
    combat session. Does not check the "requires" predicate - returns
    true if item could potentially be used as long as "requires" is
    also satisfied.
    @param {!Object} spec
    @param {!Object} session
    @return {UsableInCombat} */
function inventory_item_is_usable_in_combat(spec, session) {
    if(!('use' in spec)) { return UsableInCombat.NOT_USABLE; } // item does not have a "use" action

    // case 1) - recursively search "requires" predicate for HAS_ATTACKED and HOME_BASE predicates
    if('requires' in spec) {

        // recursively look for a "target" predicate. Return null if
        // not found, true if target must be TRUE to satisfy, or false
        // if target must be FALSE to satisfy.
        var has_predicate = function(pred, target) {
            if(pred['predicate'] == target) {
                return true;
            } else if(pred['predicate'] == 'NOT') {
                var ret = has_predicate(pred['subpredicates'][0], target);
                if(ret !== null) { return !ret; } // negate the child predicate
            } else if('subpredicates' in pred) {
                var ret = null;
                for(var i = 0; i < pred['subpredicates'].length; i++) {
                    ret = has_predicate(pred['subpredicates'][i], target);
                    if(ret !== null) { return ret; }
                }
            }
            return null;
        };

        var requires_has_attacked = has_predicate(spec['requires'], 'HAS_ATTACKED');
        var requires_home_base = has_predicate(spec['requires'], 'HOME_BASE');

        // item has HAS_ATTACKED predicate, and either does NOT have a HOME_BASE predicate, or session.home_base satisfies it
        // actually, let's show the item in this case, but have the red requirement tooltip to teach player that it can only be used offensively
        if(requires_has_attacked === true /* && (requires_home_base === null || requires_home_base === !!session.home_base) */) {
            return UsableInCombat.USABLE_MISSILE;
        }
    }

    // case 2) - search for a "use" spellname associated with missiles or instant repair items
    var uselist = get_as_array(spec['use']);
    for(var m = 0; m < uselist.length; m++) {
        var use = uselist[m];
        if('spellname' in use) {
            var spell = gamedata['spells'][use['spellname']];
            if(goog.array.contains(['projectile_attack','instant_combat_repair'], spell['code'])) {
                // hide projectile_attack items if the current climate has an exclude_missiles flag
                if(spell['code'] == 'projectile_attack' && session.viewing_base.base_climate_data['exclude_missiles']) {
                    return UsableInCombat.NOT_USABLE;
                } else if(spell['code'] === 'instant_combat_repair' && session.home_base) {
                    return UsableInCombat.NOT_USABLE;
                }
                return UsableInCombat.USABLE_MISSILE;
            }
        }
    }

    // case 3) boost consumables (but note, missiles can also have APPLY_AURA in their uselist, so finish checking case 2) first)
    for(var m = 0; m < uselist.length; m++) {
        var use = uselist[m];
        if('spellname' in use) {
            if(use['spellname'] == 'APPLY_AURA') {
                var aura_name = use['spellarg'][1];

                // ignore boosts that you wouldn't want to use in combat, even though you technically could
                if(aura_name.indexOf('repair_boosted') !== -1 ||
                   aura_name.indexOf('research_boosted') !== -1 ||
                   aura_name.indexOf('production_boosted') !== -1) {
                    continue;
                }

                return UsableInCombat.USABLE_BOOST;
            }
        }
    }

    return UsableInCombat.NOT_USABLE;
}

/** @param {SPUI.Dialog} dialog */
function update_combat_item_bar(dialog) {
    var indices_by_spec = {}; // mapping from specname to index within entry_list
    var entry_list = [];

    var add_item = function(item, i) { // "i" is integer for ordinary inventory items, and {'obj_id':..., 'slot_type':..., 'slot_index':...} for equipped items
        if(inventory_item_is_usable_in_combat(ItemDisplay.get_inventory_item_spec(item['spec']), session) != UsableInCombat.NOT_USABLE) {
            if(item['spec'] in indices_by_spec) {
                // merge items of identical specs into a single entry in entry_list
                // note: the 'pending'/'pending_time' flags will only be taken from one item, the next one "in line" to be used
                var index = indices_by_spec[item['spec']];
                entry_list[index]['stack'] += (item['stack']||1);
                entry_list[index]['individual_stacks'].push([item, i, (item['stack']||1), ('expire_time' in item ? item['expire_time'] : -1)]);
            } else {
                indices_by_spec[item['spec']] = entry_list.length;
                entry_list.push({'item': item, 'slot': i, 'stack': (item['stack']||1),
                                 // list of data on about stack contributing to this entry: [item, slot, stack count, expire time]
                                 // will be used for sorting later
                                 'individual_stacks': [[item, i, (item['stack']||1), ('expire_time' in item ? item['expire_time'] : -1)]]
                                });
            }
        }
    }
    goog.array.forEach(player.inventory, add_item);
    goog.array.forEach(session.home_equip_items, function(entry) {
        // note: because the "entry" itself is used as the "slot" below, and is checked for identity
        // against any existing inventory_context dialog, we have to use the "entry" object itself
        add_item(entry['item'], entry);
    });

    // when there's more than one stack of same-spec items, choose the right one to use first
    goog.array.forEach(entry_list, function(entry) {
        if(entry['individual_stacks'].length > 1) {
            entry['individual_stacks'].sort(function(a,b) {
                var a_slot = a[1], b_slot = b[1];
                var a_stack = a[2], b_stack = b[2];
                var a_expire = (a[3] < 0 ? Infinity : a[3]), b_expire = (b[3] < 0 ? Infinity : b[3]);


                // first, prefer using items coming from earlier-expiring stacks.
                // then, prefer using items coming from smaller stacks.

                if(a_expire < b_expire) {
                    return -1;
                } else if(a_expire > b_expire ) {
                    return 1;
                } else if(a_stack < b_stack) {
                    return -1;
                } else if(a_stack > b_stack) {
                    return 1;
                } else if(a_slot < b_slot) { // tie-breaker
                    return -1;
                } else {
                    return 1;
                }
            });

            // the particular stack at the head of this list should be used before others of its spec
            // swap it into the 'item' field and repoint slot to it
            entry['item'] = entry['individual_stacks'][0][0];
            entry['slot'] = entry['individual_stacks'][0][1];
            //console.log(entry['individual_stacks'][0][0]);
        }
    });

    // choose order to display these in the GUI
    entry_list.sort(function(a,b) {
        var a_prio = inventory_item_is_usable_in_combat(ItemDisplay.get_inventory_item_spec(a['item']['spec']), session);
        var b_prio = inventory_item_is_usable_in_combat(ItemDisplay.get_inventory_item_spec(b['item']['spec']), session);
        // priority first
        if(a_prio > b_prio) {
            return -1;
        } else if(a_prio < b_prio) {
            return 1;
            // items equipped to buildings first
        } else if(typeof(a['slot']) === 'object' && typeof(b['slot']) !== 'object') {
            return -1;
        } else if(typeof(a['slot']) !== 'object' && typeof(b['slot']) === 'object') {
            return 1;
            // sort by building then slot number
        } else if(typeof(a['slot']) === 'object') {
            if(a['slot']['obj_id'] < b['slot']['obj_id']) {
                return -1;
            } else if(a['slot']['obj_id'] > b['slot']['obj_id']) {
                return 1;
            } else if(a['slot']['slot_index'] < b['slot']['slot_index']) {
                return -1;
            } else if(a['slot']['slot_index'] > b['slot']['slot_index']) {
                return 1;
            }
            // sort by slot number
        } else if(typeof(a['slot']) !== 'object') {
            if(a['slot'] < b['slot']) {
                return -1;
            } else {
                return 1;
            }
        }
        return 0;
    });

    dialog.user_data['item_list'] = goog.array.map(entry_list, function(entry) { return entry['item']; });
    dialog.user_data['slot_list'] = goog.array.map(entry_list, function(entry) { return entry['slot']; });
    dialog.user_data['stack_count_list'] = goog.array.map(entry_list, function(entry) { return entry['stack']; });

    if(entry_list.length < 1) { // no combat items
        dialog.show = false;
        return;
    } else {
        dialog.show = true;
    }

    dialog.xy = vec_copy(dialog.data['xy']);

    // show as many rows as will fit
    var show_rows = Math.max(1, Math.min(entry_list.length, Math.min(dialog.data['widgets']['item']['array'][1], Math.floor((canvas_height - dialog.xy[1] - dialog.data['dimensions'][1] - dialog.data['widgets']['item']['array_offset'][1])/dialog.data['widgets']['item']['array_offset'][1]))));
    dialog.user_data['show_rows'] = show_rows;

    dialog.wh = [dialog.data['dimensions'][0],
                 dialog.data['dimensions'][1] + dialog.data['widgets']['item']['array_offset'][1] * (show_rows-1)];
    dialog.widgets['bgrect'].wh = [dialog.data['widgets']['bgrect']['dimensions'][0],
                                   dialog.data['widgets']['bgrect']['dimensions'][1] + (show_rows - 1) * dialog.data['widgets']['item']['array_offset'][1]];

    var max_scroll = Math.max(0, entry_list.length - show_rows);
    dialog.user_data['scroll_pos'] = Math.min(dialog.user_data['scroll_pos'], max_scroll)
    dialog.user_data['scroll_pos'] = Math.max(dialog.user_data['scroll_pos'], 0);
    dialog.widgets['scroll_left'].widgets['scroll_left'].state = (dialog.user_data['scroll_pos'] > 0 ? 'normal' : 'disabled');
    var scroll_data = gamedata['dialogs'][dialog.data['widgets']['scroll_left']['dialog']]['widgets']['scroll_left_bg'];
    dialog.widgets['scroll_left'].widgets['scroll_left_bg'].fade_unless_hover = (dialog.user_data['scroll_pos'] > 0 ? scroll_data['fade_unless_hover'] : 0);
    dialog.widgets['scroll_left'].widgets['scroll_left_bg'].alpha = (dialog.user_data['scroll_pos'] > 0 ? 1 : scroll_data['alpha_disabled']);
    dialog.widgets['scroll_right'].widgets['scroll_right'].state = (dialog.user_data['scroll_pos'] < max_scroll ? 'normal' : 'disabled');
    dialog.widgets['scroll_right'].widgets['scroll_right_bg'].fade_unless_hover = (dialog.user_data['scroll_pos'] < max_scroll ? scroll_data['fade_unless_hover'] : 0);
    dialog.widgets['scroll_right'].widgets['scroll_right_bg'].alpha = (dialog.user_data['scroll_pos'] < max_scroll ? 1 : scroll_data['alpha_disabled']);

    dialog.widgets['scroll_right'].xy = [dialog.data['widgets']['scroll_right']['xy'][0],
                                         dialog.data['widgets']['scroll_right']['xy'][1] + (show_rows - 1) * dialog.data['widgets']['item']['array_offset'][1]];

    for(var y = 0; y < dialog.data['widgets']['item']['array'][1]; y++) {
        for(var x = 0; x < dialog.data['widgets']['item']['array'][0]; x++) {
            // widget index
            var i = y * dialog.data['widgets']['item']['array'][0] + x;

            if(i < dialog.user_data['item_list'].length && y < show_rows) {
                dialog.widgets['item'+i].show =
                    dialog.widgets['stack'+i].show =
                    dialog.widgets['frame'+i].show =
                    dialog.widgets['clock'+i].show = true;

                dialog.widgets['frame'+i].tooltip.str = null;

                // item index
                var item_i = i + dialog.user_data['scroll_pos'];
                var item = dialog.user_data['item_list'][item_i];
                var slot = dialog.user_data['slot_list'][item_i];
                var stack_count = dialog.user_data['stack_count_list'][item_i];
                var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
                dialog.widgets['item'+i].show = true;
                ItemDisplay.set_inventory_item_asset(dialog.widgets['item'+i], spec);
                ItemDisplay._set_inventory_item_stack(dialog.widgets['stack'+i], spec, stack_count); // note: use combined stack count here
                var can_activate = false;

                if(item['pending_time']) {
                    // flash frame on activation
                    dialog.widgets['clock'+i].flash_time = item['pending_time'];
                }

                var gcd = player.cooldown_togo('GCD');
                if(gcd > 0) {
                    // show gcd clock hands
                    dialog.widgets['clock'+i].cooldown_start = player.global_cooldown['start'];
                    dialog.widgets['clock'+i].cooldown_end = player.global_cooldown['end'];
                }

                if(!item['pending']) {
                    if('requires' in spec && !read_predicate(spec['requires']).is_satisfied(player,null)) {
                        dialog.widgets['frame'+i].tooltip.str = read_predicate(spec['requires']).ui_describe(player);
                        dialog.widgets['frame'+i].tooltip.text_color = SPUI.error_text_color;
                    } else if('use' in spec) {
                        var uselist = get_as_array(spec['use']);
                        can_activate = true;
                        for(var m = 0; m < uselist.length; m++) { // ALL conditions must be true
                            var use = uselist[m];
                            if('spellname' in use) {
                                var spellname = use['spellname'];
                                var spellarg = use['spellarg'] || null;
                                var spell = gamedata['spells'][spellname];
                                var temp_arg;
                                if(spell['activation'] && spell['activation'].indexOf('targeted') == 0) {
                                    temp_arg = [spellarg,null];
                                } else {
                                    temp_arg = spellarg;
                                }
                                can_activate = can_cast_spell(GameObject.VIRTUAL_ID, spellname, temp_arg);
                            } else if('consequent' in use) {
                                can_activate = true;
                            } else {
                                can_activate = false;
                            }
                            if(!can_activate) {
                                break;
                            }
                        }
                    } else if('consequent' in spec) {
                        can_activate = true;
                    }
                }

                if(can_activate) {
                    if(player.warehouse_is_busy()) { // XXX what to check for equip items?
                        can_activate = false;
                        dialog.widgets['frame'+i].tooltip.str = dialog.data['widgets']['frame']['ui_tooltip_warehouse_offline'];
                        dialog.widgets['frame'+i].tooltip.text_color = SPUI.error_text_color;
                    }
                }

                dialog.widgets['clock'+i].disabled = !can_activate;

                if(!can_activate || gcd > 0) {
                    dialog.widgets['frame'+i].state = 'disabled';
                } else if((dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === slot) ||
                          (selection.spellname && (selection.item === item))) {
                    // highlight if context menu is up OR a targeted spell cursor for this item is active
                    dialog.widgets['frame'+i].state = 'active';
                } else {
                    dialog.widgets['frame'+i].state = 'normal';
                }

                dialog.widgets['frame'+i].onenter = (function (_slot, _item) { return function(w) {
                    var inv_dialog = w.parent;
                    if(inv_dialog.user_data['context'] &&
                       inv_dialog.user_data['context'].user_data['slot'] === _slot &&
                       inv_dialog.user_data['context'].user_data['item'] === _item) { return; }
                    if(w.tooltip.str) { return; } // don't pop up context menu if there is already an error tooltip
                    invoke_inventory_context(w.parent, w, _slot, _item, false, {'position':'right'});
                }; })(slot, item);

                dialog.widgets['frame'+i].onclick = (function (_i, _slot, _item, _spec) { return function(w) {
                    // try to sync damage first, so repairs don't overlap
                    flush_dirty_objects({});
                    // queue a full heal effect if this is a field repair kit or equivalent
                    if(_spec && 'use' in _spec && 'spellname' in _spec['use']) {
                        var spell = gamedata['spells'][_spec['use']['spellname']];
                        if(spell && 'code' in spell && spell['code'] === 'instant_combat_repair') {
                            var world = (session.has_world() ? session.get_real_world() : null);
                            if(world){ world.combat_engine.queue_damage_effect(new CombatEngine.HealAllTeamDamageEffect(world.combat_engine.cur_tick, client_time, null, null, -1, {}, 'player')); }
                        };
                    }
                    if(inventory_action(_item, _slot, "INVENTORY_USE", {trigger_gcd: true})) {
                        // clear the tooltip if activation succeeds
                        invoke_inventory_context(w.parent, w, -1, null, false);
                    }
                }; })(i, slot, item, spec);
                dialog.widgets['frame'+i].onleave_cb = (function (_slot, _item) { return function(w) {
                    var inv_dialog = w.parent;
                    if(inv_dialog.user_data['context'] &&
                       inv_dialog.user_data['context'].user_data['slot'] === _slot &&
                       inv_dialog.user_data['context'].user_data['item'] === _item &&
                       (true || !inv_dialog.user_data['context'].user_data['show_dropdown'])) {
                        invoke_inventory_context(w.parent, w, -1, null, false);
                    }
                }; })(slot, item);
            } else {
                dialog.widgets['item'+i].show =
                    dialog.widgets['stack'+i].show =
                    dialog.widgets['frame'+i].show =
                    dialog.widgets['clock'+i].show = false;
            }
        }
    }
}

/** UI element that displays an outline where building would be built or moved if you clicked now
 * @constructor @struct
 * @extends SPUI.Element
 */
var BuildUICursor = function(obj, spec) {
    goog.base(this);
    this.user_data = {'cursor':'BuildUICursor'};
    this.obj = obj; // building to move (null for new construction)
    this.spec = spec;
};
goog.inherits(BuildUICursor, SPUI.Element);

function shade_quad(v) {
    SPUI.ctx.beginPath();
    SPUI.add_quad_to_path(v);
    SPUI.ctx.fill();
}
function shade_quad_quantize(v) {
    shade_quad([draw_quantize(v[0]), draw_quantize(v[1]), draw_quantize(v[2]), draw_quantize(v[3])]);
}

// 'xy' in screen coordinates, 'range' nad 'min_range' in map cell units
function draw_weapon_range(xy, range, friend, aoe, min_range, color) {
    if(!friend) { return; } // no range on enemy turrets

    ctx.save();

    var radius = 10*Math.sqrt(2)*range;
    var min_radius = (min_range > 0 ? 10*Math.sqrt(2)*min_range : -1);
    if(!color && friend) {
        color = new SPUI.Color(0.4, 0.7, 1.0);
    } else if (!color && !friend){
        color = new SPUI.Color(1.0, 0.25, 0.1);
    }

    ctx.transform(1, 0, 0, 0.5, xy[0], xy[1]);

    if(aoe) {
        // draw "clock ticks"
        color.a = 1;
        ctx.fillStyle = color.str();
        ctx.lineWidth = 4;
        ctx.beginPath();
        var NOTCHES = 48;
        var DELTA = 0.015;
        for(var i = 0; i < NOTCHES; i++) {
            var notch_rad = radius - 18;
            var angle = 2*Math.PI*(i/NOTCHES);
            var nx_l = Math.cos(angle-DELTA), ny_l = Math.sin(angle-DELTA);
            var nx_c = Math.cos(angle), ny_c = Math.sin(angle);
            var nx_r = Math.cos(angle+DELTA), ny_r = Math.sin(angle+DELTA);
            ctx.moveTo(radius*nx_l, radius*ny_l);
            ctx.lineTo(radius*nx_r, radius*ny_r);
            ctx.lineTo(notch_rad*nx_c, notch_rad*ny_c);
        }
        ctx.fill();
    }
    if(1) {
        // draw filled circle
        color.a = 0.07;
        ctx.fillStyle = color.str();
        color.a = 0.9;
        ctx.strokeStyle = color.str();
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, 2*Math.PI, false);
        if(min_radius > 0) {
            ctx.arc(0, 0, min_radius, 0, 2*Math.PI, true);
        }
        ctx.fill();
        ctx.stroke();
    }

    ctx.restore();
}

function draw_turret_ranges(world, ignore_obj) {
    world.objects.for_each(function(obj) {
        if(obj === ignore_obj) { return; }
        if(obj.is_building()) {
            var ran = obj.weapon_range();
            var spell = ran[0], range = (ran[3] > 0 ? ran[3] : ran[1]), aoe = ran[2], min_range = ran[4];
            if(range > 0) {
                var pos = obj.interpolate_pos(world);
                draw_weapon_range(ortho_to_draw(pos), range, obj.team === 'player', aoe, min_range, null);
            } else if(obj.has_permanent_auras()) {
                ran = obj.get_permanent_auras_range();
                spell = ran[0], range = (ran[3] > 0 ? ran[3] : ran[1]), aoe = ran[2], min_range = ran[4];
                if(range > 0) {
                    var pos = obj.interpolate_pos(world);
                    var color = new SPUI.Color(1.0, 0.5, 0.0);
                    draw_weapon_range(ortho_to_draw(pos), range, obj.team === 'player', aoe, min_range, color);
                }
            }
        }
    });
}

BuildUICursor.prototype.draw = function(offset) {
    var world = session.get_draw_world();

    SPUI.ctx.save();

    SPUI.ctx.save();
    set_playfield_draw_transform(SPUI.ctx);

    // draw base perimeter
    world.base.draw_base_perimeter(player.is_cheater ? 'dev_edit' : (!!this.spec['ignore_perimeter']) ? 'build_ignore_perimeter' : 'build');

    // draw blocked building locations
    SPUI.ctx.fillStyle = 'rgba(255,0,0,0.25)';
    world.objects.for_each(function(obj) {
        if(obj != selection.unit && obj.is_building() || (obj.is_inert() && (obj.spec['blocks_buildings'] || obj.spec['unit_collision_gridsize'][0] != 0))) {
            var bound = get_grid_bounds([obj.x,obj.y], obj.spec['gridsize']);
            shade_quad([draw_quantize(ortho_to_draw([bound[0][0], bound[1][0]])),
                        draw_quantize(ortho_to_draw([bound[0][1], bound[1][0]])),
                        draw_quantize(ortho_to_draw([bound[0][1], bound[1][1]])),
                        draw_quantize(ortho_to_draw([bound[0][0], bound[1][1]]))]);
        }
    }, this);

    // always draw around mouse location
    var ji = screen_to_ortho([mouse_state.last_x, mouse_state.last_y]);
    ji = vec_floor(player.quantize_building_location(ji, this.spec));

    // color cursor depending on whether the location is valid
    var valid = player.is_building_location_valid_detailed(ji, this.spec, this.obj, {ignore_perimeter: !!this.spec['ignore_perimeter']});
    var location_valid = valid[0], reason = valid[1];

    var xy = ortho_to_draw(ji);

    SPUI.ctx.strokeStyle = (location_valid ? '#FFFFFF' : '#FF0000');
    SPUI.ctx.fillStyle = (location_valid ? 'rgba(255,255,255,0.25)' : 'rgba(255,0,0,0.25)');
    var bound = get_grid_bounds(ji, this.spec['gridsize']);
    SPUI.ctx.beginPath();
    SPUI.add_quad_to_path([ortho_to_draw([bound[0][0], bound[1][0]]),
                           ortho_to_draw([bound[0][1], bound[1][0]]),
                           ortho_to_draw([bound[0][1], bound[1][1]]),
                           ortho_to_draw([bound[0][0], bound[1][1]])]);
    SPUI.ctx.fill();
    SPUI.ctx.stroke();

    // draw exclusion zone
    if(this.spec['exclusion_zone']) {
        var zone = this.spec['exclusion_zone'];
        SPUI.ctx.strokeStyle = SPUI.ctx.fillStyle = 'rgba(255,255,0,0.25)';
        SPUI.ctx.beginPath();
        SPUI.add_quad_to_path([ortho_to_draw([bound[0][0]-zone[0], bound[1][0]-zone[1]]),
                               ortho_to_draw([bound[0][1]+zone[0], bound[1][0]-zone[1]]),
                               ortho_to_draw([bound[0][1]+zone[0], bound[1][1]+zone[1]]),
                               ortho_to_draw([bound[0][0]-zone[0], bound[1][1]+zone[1]])]);
        // exclude inner area (backwards winding order to create a hole)
        SPUI.add_quad_to_path([ortho_to_draw([bound[0][0], bound[1][1]]),
                               ortho_to_draw([bound[0][1], bound[1][1]]),
                               ortho_to_draw([bound[0][1], bound[1][0]]),
                               ortho_to_draw([bound[0][0], bound[1][0]])]);
        SPUI.ctx.fill();
        SPUI.ctx.stroke();
    }

    var spell_range_aoe = [null,-1,false];
    var color = null;
    if(this.obj) {
        spell_range_aoe = this.obj.weapon_range();
    } else if(selection.spellkind && (selection.spellkind in gamedata['buildings'])) {
        spell_range_aoe = get_weapon_range(null, 1, get_auto_spell_raw(gamedata['buildings'][selection.spellkind])); // assume level 1 spell for newly-constructed buildings
    } else if(this.obj && this.obj.is_building() && this.obj.has_permanent_auras()) {
        spell_range_aoe = this.obj.get_permanent_auras_range();
        color = new SPUI.Color(0.3, 0.85, 0.24);
    }
    var spell = spell_range_aoe[0], range = (spell_range_aoe[3] > 0 ? spell_range_aoe[3] : spell_range_aoe[1]), aoe = spell_range_aoe[2], min_range = spell_range_aoe[4];
    if(range > 0 || (this.obj && this.obj.is_building() && (this.obj.is_minefield() || this.obj.is_ambush() || this.obj.is_security_node()))) {
        // manually draw prospective range at new location
        if(range > 0) {
            draw_weapon_range(xy, range, true, aoe, min_range, color);
        }
        draw_turret_ranges(world, this.obj);
    }

    SPUI.ctx.restore(); // pop playfield transform

    // draw text at cursor

    var text;
    if(reason == 'perimeter') {
        text = gamedata['strings']['cursors']['outside_perimeter'];
    } else if(reason == 'overlap') {
        text = gamedata['strings']['cursors']['location_blocked'];
    } else {
        if(this.obj) {
            text = gamedata['strings']['cursors']['click_to_move'].replace('%s', this.spec['ui_name'] || this.spec['name']);
        } else {
            text = gamedata['strings']['cursors']['click_to_build'].replace('%s', this.spec['ui_name_indefinite'] || this.spec['ui_name'] || this.spec['name']);
        }
    }
    if(!text) {
        SPUI.ctx.restore();
        throw Error('bad string spellname '+(selection.spellname ? selection.spellname : 'null')+' spellkind '+(selection.spellkind ? selection.spellkind : 'null')+' spec ' + (this.spec && this.spec['name'] ? this.spec['name'] : 'BAD'));
    }

    var text_pos = [-1,-1], text_style = 'BAD';
    try {
        text_pos = [mouse_state.last_x+10, mouse_state.last_y+25];
        SPUI.ctx.fillStyle = 'rgba(0,0,0,1)';
        SPUI.ctx.fillText(text, text_pos[0]+1, text_pos[1]+1);
        SPUI.ctx.fillStyle = text_style = (location_valid ? SPUI.default_text_color : SPUI.error_text_color).str();
        SPUI.ctx.fillText(text, text_pos[0], text_pos[1]);
    } catch(e) {
        log_exception(e, 'BuildUICursor.draw(): text_pos = '+text_pos[0].toString()+','+text_pos[1].toString()+' text_style '+text_style+' text '+text);
    }

    SPUI.ctx.restore();
};

// try to find coordinates near "loc" to place a building of kind "specname"
// returns null if we can't find one
function find_valid_building_location(loc, specname) {
    var spec = get_spec(specname);
    var gridsize = spec['gridsize'];
    var options = {ignore_perimeter: !!spec['ignore_perimeter']};
    if(player.is_building_location_valid(loc, spec, null, options)) { return loc; }
    var maxshift = session.viewing_base.get_base_radius();
    for(var shiftx = 0; shiftx < 2*maxshift; shiftx += 1) {
        var sx = Math.floor(shiftx/2) * ((shiftx & 1 ? -1 : 1));
        for(var shifty = 0; shifty < 2*maxshift; shifty += 1) {
            var sy = Math.floor(shifty/2) * ((shifty & 1 ? -1 : 1));
            var newloc = [loc[0]+sx, loc[1]+sy];
            if(player.is_building_location_valid(newloc, spec, null, options)) {
                return newloc;
            }
        }
    }
    return null;
};

// fire a BUILD spell

function do_build(ji) {
    if(selection.spellkind in gamedata['buildings']) {
        var spec = gamedata['buildings'][selection.spellkind];

        var proceed = true;
        var helper = null;

        if(!player.is_cheater) { // check resources
            var res_needed = {};
            for(var res in gamedata['resources']) {
                var cost = get_leveled_quantity(spec['build_cost_'+res]||0,1);
                if(cost > player.resource_state[res][1]) {
                    res_needed[res] = cost - player.resource_state[res][1];
                    proceed = false;
                }
            }
            if(goog.object.getCount(res_needed) > 0) {
                var cb = (function (_spec) { return function() {
                    // get us back in action
                    selection.spellname = "BUILD";
                    selection.spellkind = _spec['name'];
                    change_selection_ui_under(new BuildUICursor(null, _spec));
                }; })(spec);
                helper = get_requirements_help('resources', res_needed, {continuation:cb});
            }
        }

        if(!proceed) {
            change_selection(null);
            if(helper) { helper(); }
            return;
        }

        ji = player.quantize_building_location(ji, spec);
        if(player.is_building_location_valid(ji, spec, null, {ignore_perimeter: !!spec['ignore_perimeter']})) {
            if(selection.item) {
                inventory_send_request(selection.item, selection.slot, "INVENTORY_USE", [ji]);
            } else {
                send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID,
                                     selection.spellname,
                                     selection.spellkind,
                                     ji]);
            }

            // trigger visual effect
            var fx_data = ('upgrade_start_effect' in spec ?
                           spec['upgrade_start_effect'] :
                           gamedata['client']['vfx']['building_upgrade_start']);
            if(fx_data) {
                session.get_real_world().fxworld.add_visual_effect_at_time(ji, 0, [0,1,0], client_time, fx_data,
                                               true, // !spec['worth_less_xp'], // no sound for barrier upgrades?
                                               { '%OBJECT_SPRITE': get_leveled_quantity(spec['art_asset'], 1)});
            }

            if(player.tutorial_state === 'place_defensive_cannon' && selection.spellkind === gamedata['tutorial'][player.tutorial_state]['target']) {
                advance_tutorial();
                last_build_dialog_category = 'resources'; // flip back to 'resources' for after the tutorial
            }

            // keep build cursor if it's a barrier or minefield and the current # is less than the limit
            var current = count_objects_by_type(spec['name']);
            if((spec['worth_less_xp'] || (spec['equip_slots'] && spec['equip_slots']['mine'])) &&
               (player.is_cheater || (current+1) < get_leveled_quantity(spec['limit'], player.get_townhall_level())) &&
               (player.is_cheater || !('limit_requires' in spec) || (current+1 < spec['limit_requires'].length && read_predicate(spec['limit_requires'][current+1]).is_satisfied(player,null))) &&
               (player.is_cheater || (player.foremen_in_use() < player.stattab['total_foremen']))) {

            } else {
                change_selection(null);
                var after_build_cb = null;

                /*
                if(0 && ('limit_requires' in spec) && (current+1 < spec['limit_requires'].length && !read_predicate(spec['limit_requires'][current+1]).is_satisfied(player,null))) {
                    // instruct player what to do in order to build more
                    after_build_cb = (function (_spec, _current) { return function() {
                        var helper = get_requirements_help(read_predicate(_spec['limit_requires'][_current+1]));
                        if(helper) { helper(); }
                    }; })(spec, current);
                }
                */

                invoke_ui_locker(synchronizer.request_sync(), after_build_cb);
            }
        } else {
            if(player.tutorial_state === 'place_defensive_cannon') {
                // allow more attempts
            } else {
                // invalid location
                change_selection(null);
            }
        }
    } else if(player.is_cheater && selection.spellkind in gamedata['inert']) {
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, selection.spellname, selection.spellkind, ji]);
    } else {
        throw Error('unhandled BUILD spellkind '+selection.spellkind.toString());
    }
};

/**
 * @constructor @struct
 * @extends SPUI.Element
 */
var DeployUICursor = function() {
    goog.base(this);
    this.user_data = {'cursor':'DeployUICursor'};
    this.size = gamedata['client']['deploy_ui_cursor_size'] || 4; // (half) size of cursor, in map-cell units
};
goog.inherits(DeployUICursor, SPUI.Element);

DeployUICursor.prototype.destroy = function() {
    // subtract from session.deployed_unit_space
    goog.object.forEach(session.pre_deploy_units, function(obj, obj_id) {
        var space = get_leveled_quantity(gamedata['units'][obj['spec']]['consumes_space'] || 0, obj['level'] || 1);
        if(gamedata['unit_deploy_style'] != 'drip') {
            // batch-style unit deployment predicts deployed_unit_space as the cursor fills up, drip-style does not
            session.deployed_unit_space -= space;
        }
    }, this);
    session.pre_deploy_units = {};
};

DeployUICursor.prototype.draw = function(offset) {
    var world = session.get_draw_world();

    var has_state = true;
    SPUI.ctx.save();
    set_playfield_draw_transform(SPUI.ctx);

    session.viewing_base.draw_base_perimeter('deploy');

    // do not draw deployment box if no units are ready for deployment
    var any_selected = goog.object.getCount(session.pre_deploy_units) > 0;
    if(any_selected) {
        var ji = screen_to_ortho([mouse_state.last_x, mouse_state.last_y]);
        var location_valid = world.is_deployment_location_valid(ji);
        SPUI.ctx.strokeStyle = (location_valid ? '#00FF00' : '#FF0000');
        SPUI.ctx.fillStyle = (location_valid ? 'rgba(0,255,0,0.25)' : 'rgba(255,0,0,0.25)');

        // rectangle
        SPUI.ctx.beginPath();
        SPUI.add_quad_to_path([draw_quantize(ortho_to_draw([ji[0]-this.size, ji[1]-this.size])),
                               draw_quantize(ortho_to_draw([ji[0]+this.size, ji[1]-this.size])),
                               draw_quantize(ortho_to_draw([ji[0]+this.size, ji[1]+this.size])),
                               draw_quantize(ortho_to_draw([ji[0]-this.size, ji[1]+this.size]))]);
        SPUI.ctx.fill();
        SPUI.ctx.stroke();

        // lines off the edges
        SPUI.ctx.beginPath();
        var line = function(v0, v1) {
            v0 = draw_quantize(v0); v1 = draw_quantize(v1);
            SPUI.ctx.moveTo(v0[0], v0[1]);
            SPUI.ctx.lineTo(v1[0], v1[1]);
        };

        // left
        line(ortho_to_draw([ji[0]-2*this.size, ji[1]]), ortho_to_draw([ji[0]-this.size, ji[1]]));
        // right
        line(ortho_to_draw([ji[0]+this.size, ji[1]]), ortho_to_draw([ji[0]+2*this.size, ji[1]]));
        // top
        line(ortho_to_draw([ji[0], ji[1]-2*this.size]), ortho_to_draw([ji[0], ji[1]-this.size]));
        // bottom
        line(ortho_to_draw([ji[0], ji[1]+this.size]), ortho_to_draw([ji[0], ji[1]+2*this.size]));

        SPUI.ctx.stroke();

        // pop playfield transform
        has_state = false;
        SPUI.ctx.restore();

        var text_pos = [mouse_state.last_x+10, mouse_state.last_y+25];
        if(player.is_cheater) {
            SPUI.ctx.fillStyle = 'rgba(255,255,255,1)';
            SPUI.ctx.fillText(ji[0].toString()+','+ji[1].toString(), text_pos[0], text_pos[1]);
            text_pos[1] += 20;
        }

        var text = null;
        if(location_valid && 'click_to_deploy' in gamedata['strings']['cursors']) {
            // grab any unit spec
            for(var army_id in session.pre_deploy_units) {
                var spec = gamedata['units'][session.pre_deploy_units[army_id]['spec']];
                if(spec) {
                    text = gamedata['strings']['cursors']['click_to_deploy'].replace('%s', spec['ui_name_plural'] || spec['ui_name']);
                    break;
                }
            }
        } else if(!location_valid && 'location_blocked' in gamedata['strings']['cursors']) {
            text = gamedata['strings']['cursors']['location_blocked'];
        }

        if(text) {
            SPUI.ctx.fillStyle = 'rgba(0,0,0,1)';
            SPUI.ctx.fillText(text, text_pos[0]+1, text_pos[1]+1);
            SPUI.ctx.fillStyle = (location_valid ? SPUI.default_text_color : SPUI.error_text_color).str();
            SPUI.ctx.fillText(text, text_pos[0], text_pos[1]);
        }
    }
    if(has_state) {
        SPUI.ctx.restore();
    }
};

/** @param {!SPFX.FXWorld} fxworld
    @param {string} kind
    @param {!Array<number>} ji
    @param {!Object} spec
    @param {number} level
    @param {number} time_spread */
function add_unit_deployment_vfx(fxworld, kind, ji, spec, level, time_spread) {
    var vfx;

    if(kind+'_effect' in spec) { // is there a per-unit override?
        vfx = spec[kind+'_effect'];
    } else { // use default effect
        vfx = gamedata['client']['vfx'][kind] || null;
    }
    if(!vfx) { return; }

    // base some characteristics of the pre_deploy effect on the first unit that is being deployed
    var height = spec['flying'] ? spec['altitude'] : 0;
    var instance_data = { '%OBJECT_SPRITE': get_leveled_quantity(spec['art_asset'], level) };
    fxworld.add_visual_effect_at_time(ji, height, [0,0,0],
                                      // spread out the effect time
                                      client_time + Math.random() * time_spread,
                                      vfx, true, instance_data);
}

function unit_deployment_latency_high() { return (-2*server_time_offset) > gamedata['client']['unit_deployment_effect_latency_threshold']; };

/** @param {!Array.<number>} ji
    @param {Array.<Object>} objs_to_deploy (list of values in same format as values of session.pre_deploy_units) */
function do_deploy(ji, objs_to_deploy) {
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "DEPLOY_UNITS", ji, objs_to_deploy]);

    if(1) {
        // for the visual effect, just grab the first unit's spec
        var army_unit = objs_to_deploy[0];
        var fx_specname = army_unit['spec'];
        var fx_level = ('level' in army_unit ? army_unit['level'] : 1);
        // this is evaluated at high frequency, so only spread by TICK_INTERVAL
        add_unit_deployment_vfx(session.get_real_world().fxworld,
            // only use pre_deploy effect in high-latency environment - otherwise skip right to post_deploy
            unit_deployment_latency_high() ? 'pre_deploy' : 'post_deploy',
            ji, gamedata['units'][fx_specname], fx_level, TICK_INTERVAL);
    }

    // transfer from pre- to post-deploy
    goog.array.forEach(objs_to_deploy, function(obj) {
        var id = obj['obj_id'];
        if(!(id in session.pre_deploy_units)) { throw Error('obj_id '+id+' not in pre_deploy_units'); }
        session.post_deploy_units[id] = session.pre_deploy_units[id];
        delete session.pre_deploy_units[id];
    });

    if(player.tutorial_state === 'place_robots_action') {
        // once robots are deployed, set short battle end time
        session.set_attack_finish_time(Math.min(session.attack_finish_time, server_time + gamedata['tutorial_post_deploy_attack_time']));
        advance_tutorial();
    }
    player.quest_tracked_dirty = true;
};

/**
 * @constructor @struct
 * @extends SPUI.Element
 */
var CommandUICursor = function(col) {
    goog.base(this);
    this.color_str = new SPUI.Color(col[0], col[1], col[2], col[3]).str();
};
goog.inherits(CommandUICursor, SPUI.Element);
CommandUICursor.prototype.draw = function(offset) {
    var x = mouse_state.last_x, y = mouse_state.last_y;
    var inner = 7, len = 11;
    SPUI.ctx.save();
    SPUI.ctx.strokeStyle = this.color_str;
    SPUI.ctx.lineWidth = 3;
    SPUI.ctx.beginPath();
    SPUI.ctx.moveTo(x, y-inner); SPUI.ctx.lineTo(x, y-inner-len);
    SPUI.ctx.moveTo(x, y+inner); SPUI.ctx.lineTo(x, y+inner+len);
    SPUI.ctx.moveTo(x-inner, y); SPUI.ctx.lineTo(x-inner-len, y);
    SPUI.ctx.moveTo(x+inner, y); SPUI.ctx.lineTo(x+inner+len, y);
    SPUI.ctx.stroke();
    SPUI.ctx.restore();
};
function make_shoot_cursor() { return new CommandUICursor([1,0.05,0.05,0.7]); }
function make_move_cursor() { return new CommandUICursor([0.25,1,0.25,0.7]); }
function make_patrol_cursor() { return new CommandUICursor([0.25,0.5,1,0.7]); }

/**
 * @constructor @struct
 * @extends SPUI.Element
 */
var AOEUICursor = function(origin_unit, range, radius) {
    goog.base(this);
    this.origin_unit = origin_unit;
    this.range = range;
    this.radius = radius;
    this.stroke_color_str = new SPUI.Color(0.05, 1, 0.05, 1.0).str();
    this.fill_color_str = new SPUI.Color(0.05, 1, 0.05, 0.3).str();
};
goog.inherits(AOEUICursor, SPUI.Element);
AOEUICursor.prototype.draw = function(offset) {
    ctx.save();
    ctx.lineWidth = 2;

    ctx.save();
    set_playfield_draw_transform(ctx);

    // draw range circle
    if(this.origin_unit && this.range > 0) {
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.beginPath();
        var pos = this.origin_unit.raw_pos();
        var xy = ortho_to_draw(pos);
        ctx.save();
        ctx.transform(1, 0, 0, 0.5, xy[0], xy[1]);
        ctx.arc(0, 0, 10*Math.sqrt(2.0)*this.range, 0, 2*Math.PI, false);
        ctx.stroke();
        ctx.restore();
    }
    ctx.restore(); // pop playfield transform

    // draw targeting cursor
    var x = mouse_state.last_x, y = mouse_state.last_y;

    ctx.strokeStyle = this.stroke_color_str;
    ctx.fillStyle = this.fill_color_str;
    ctx.beginPath();
    ctx.transform(1, 0, 0, 0.5, x, y);
    ctx.arc(0, 0, 10*view_zoom*Math.sqrt(2.0)*this.radius, 0, 2*Math.PI, false);
    ctx.fill();
    ctx.stroke();

    ctx.restore();
};

function reload_game() {
    // running outside the frame
    // XXX this may have problems if spin_page_url points to the Facebook root and there is no valid signed request

    // remove any "deep link" parameters, since players usually do not want this
    var new_url = (new goog.Uri(spin_page_url))
        .removeParameter('replay')
        .removeParameter('player_info_statistics')
        .toString();

    if(location.href == new_url) {
        location.reload(true);
    } else {
        location.href = new_url;
    }
}

/** @param {!SPUI.DialogWidget} parent_widget
    @return {!SPUI.Dialog} */
function invoke_cheat_menu(parent_widget) {
    change_selection(player.virtual_units["CHEATMENU"]);

    /** @type {!Array.<ContextMenuButton>} */
    var buttons = [];

    buttons.push(new ContextMenuButton({ui_name: "Toggle Edit Mode", onclick: function() {
        player.is_cheater = !player.is_cheater;
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_REMOVE_LIMITS", player.is_cheater]);
    }}));

    buttons.push(new ContextMenuButton({ui_name: "Save base in /var/tmp", asset: 'menu_button_resizable', onclick: function() {
        var timestamp = server_time.toFixed(0);
        var filename = '/var/tmp/'+gamedata['game_id']+'_saved_ai_base_'+timestamp+'.json';
        save_ai_base(filename);
    }}));

    buttons.push(new ContextMenuButton({ui_name: "Clear", asset: 'menu_button_resizable', onclick: function() {
        destroy_all_enemies();
    }}));

    if(player.is_cheater) {
        buttons.push(new ContextMenuButton({ui_name: "Remove All Barriers", asset: 'menu_button_resizable', onclick: function() {
            session.get_real_world().remove_all_barriers(); }}));
        buttons.push(new ContextMenuButton({ui_name: "Upgrade All Barriers", asset: 'menu_button_resizable', onclick: function() {
            session.get_real_world().upgrade_all_barriers(); }}));
        buttons.push(new ContextMenuButton({ui_name: "Get 10k Gamebucks", onclick: function() {
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_GIVE_GAMEBUCKS", 10000]); }}));
        buttons.push(new ContextMenuButton({ui_name: "Get Daily Gifts", asset: 'menu_button_resizable', onclick: function() {
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_GIVE_GIFTS"]); }}));
        buttons.push(new ContextMenuButton({ui_name: "Drain Resources", asset: 'menu_button_resizable', onclick: function() {
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_DRAIN_RESOURCES"]); }}));
        buttons.push(new ContextMenuButton({ui_name: "Clear Cooldowns", asset: 'menu_button_resizable', onclick: function() {
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_CLEAR_COOLDOWNS"]);
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_CLEAR_PLAYER_AURAS"]); }}));
        buttons.push(new ContextMenuButton({ui_name: "Get Donated Units", asset: 'menu_button_resizable', onclick: function() {
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_GET_DONATED_UNITS"]); }}));
        buttons.push(new ContextMenuButton({ui_name: "Get PvP Points", asset: 'menu_button_resizable', onclick: function() {
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_MODIFY_SCORE", "trophies_pvp", "+=", 10000]); }}));
    }

    //buttons.push(new ContextMenuButton({ui_name: "Simulate Chargeback", onclick: function() { change_selection_ui(null); send_to_server.func(["FBPAYMENT_SIMULATE_REFUND"]); }}));

    buttons.push(new ContextMenuButton({ui_name: "Reset Game", onclick: function() {
        var msg = gamedata['strings']['reset_game_confirm'];
        invoke_child_message_dialog(msg['ui_title'], msg['ui_description'],
                                    {'cancel_button':true,
                                     'ok_button_ui_name': msg['ui_button'],
                                     //'dialog': 'message_dialog_big',
                                     'on_ok': function() {
                                         send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_RESET_GAME"]);
                                         inject_lag = 0;
                                         SPINPUNCHGAME.shutdown();
                                         // force refresh
                                         window.setTimeout(function() { reload_game(); }, 500);
                                     }});
    }}));

    buttons.push(new ContextMenuButton({ui_name: "Log Out", asset: 'menu_button_resizable', onclick: function() { SPINPUNCHGAME.shutdown(); }}));

    return invoke_generic_context_menu(vec_add(parent_widget.get_absolute_xy(), [Math.floor(parent_widget.wh[0]/2),65]), buttons);
};

function give_me_item(item) {
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_GIVE_ITEMS", item]);
}

function manipulate_ai_base(base, spellname, ui_name) {
    if(visit_base_pending) { return; }
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, spellname, base]);
    visit_base_pending = true;
    if(!loading_base_dialog_timer) {
        var dialog = invoke_loading_base_dialog('loading_base_dialog');
        dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name_'+ui_name];
    }
}

function load_ai_base(base) { manipulate_ai_base(base, "LOAD_AI_BASE", "loading"); }
function save_ai_base(base) { flush_dirty_objects({}); manipulate_ai_base(base, "SAVE_AI_BASE", "saving"); }
function publish_ai_base(base) { manipulate_ai_base(base, "PUBLISH_AI_BASE", "publishing"); }

/** Sometimes chat messages from the server call for a modification to
    a previous message (e.g. to hide it or update a unit donation request).
    Encapsulate the necessary modifications here.
    @constructor @struct
    @param {number} mod_time
    @param {string|null} mod_message_id
    @param {string|null} target_message_id
    @param {string|null} target_unit_donation_tag
    @param {number|null} target_unit_donation_recipient_id
    @param {string|null} target_help_request_id
*/
var ChatModifier = function(mod_time, mod_message_id, target_message_id, target_unit_donation_tag, target_unit_donation_recipient_id, target_help_request_id) {
    this.mod_time = mod_time;
    this.mod_message_id = mod_message_id;
    this.target_message_id = target_message_id;
    this.target_unit_donation_tag = target_unit_donation_tag;
    this.target_unit_donation_recipient_id = target_unit_donation_recipient_id;
    this.target_help_request_id = target_help_request_id;
};
/** @param {!SPUI.ScrollingTextField} output - widget containing the text node
    @param {!Object<string,?>|null} req - unit_donation_request entry from user_data of chat tab
    @param {!SPUI.TextNode} node - text node */
ChatModifier.prototype.apply = goog.abstractMethod;

/** Comparison operator for keeping modifiers in time-sorted order
    @param {!ChatModifier} a
    @param {!ChatModifier} b
    @return {number} */
ChatModifier.compare = function(a,b) {
    if(a.mod_time < b.mod_time) {
        return -1;
    } else if(a.mod_time > b.mod_time) {
        return 1;
    } else if(a.mod_message_id < b.mod_message_id) {
        return -1;
    } else if(b.mod_message_id > a.mod_message_id) {
        return 1;
    } else {
        return 0;
    }
};

/** @constructor @struct
    @extends ChatModifier
    @param {number} mod_time
    @param {string|null} mod_message_id
    @param {string} target_message_id
    @param {string|null} new_type */
var ChatHider = function(mod_time, mod_message_id, target_message_id, new_type) {
    goog.base(this, mod_time, mod_message_id, target_message_id, null, null, null);
    this.new_type = new_type;
};
goog.inherits(ChatHider, ChatModifier);
/** @override */
ChatHider.prototype.apply = function(output, req, node) {
    // revise, or just delete the message?
    if(this.new_type && node.user_data && (this.new_type in gamedata['strings']['chat_templates'])) {
        output.revise_text(node, SPText.cstring_to_ablocks_bbcode(gamedata['strings']['chat_templates'][this.new_type].replace('%sender_name', node.user_data['sender_name'])));
    } else {
        output.remove_text(node);
    }
};

/** @constructor @struct
    @extends ChatModifier
    @param {number} mod_time
    @param {string|null} mod_message_id
    @param {number} sender_user_id
    @param {string|null} tag
    @param {number} cur_space
    @param {number} max_space
    @param {number} xp_gained */
var ChatUnitDonation = function(mod_time, mod_message_id, sender_user_id, tag, cur_space, max_space, xp_gained) {
    goog.base(this, mod_time, mod_message_id, null, tag, null, null);
    this.sender_user_id = sender_user_id;
    this.cur_space = cur_space;
    this.max_space = max_space;
    this.xp_gained = xp_gained;
};
goog.inherits(ChatUnitDonation, ChatModifier);
/** @override */
ChatUnitDonation.prototype.apply = function(output, req, node) {
    if(this.sender_user_id === session.user_id) {
        req['i_donated'] = true;
        req['my_xp'] += this.xp_gained;
    }

    req['cur_space'] = this.cur_space;
    req['max_space'] = this.max_space;

    if(req['dialog']) { update_unit_donation_dialog(req['dialog']); }

    var pct = (100.0*(this.cur_space/this.max_space)).toFixed(0);
    var text;

    var region_ui_name = (req['region_id'] && req['region_id'] in gamedata['regions'] ? gamedata['regions'][req['region_id']]['ui_name'] : '');

    if(req['recipient_id'] === session.user_id) {
        text = SPText.cstring_to_ablocks_bbcode(gamedata['strings']['unit_donation_chat'][region_ui_name ? 'you_region' : 'you'].replace('%pct', pct).replace('%region', region_ui_name));
    } else {
        var kind = (req['i_donated'] ? 'you_have_donated' : 'you_have_not_donated');
        if(region_ui_name) {
            if(!session.region.data || (session.region.data['id'] !== req['region_id'])) {
                kind += '_different_region';
            } else {
                kind += '_region';
            }
        }
        text = SPText.cstring_to_ablocks_bbcode(gamedata['strings']['unit_donation_chat']['other'][kind].replace('%pct', pct).replace('%recipient',req['recipient_name']).replace('%xp', req['my_xp'].toString()).replace('%region', region_ui_name), req['callback'] ? {onclick:req['callback']} : null);
    }

    output.revise_text(node, text);
};

/** @constructor @struct
    @extends ChatModifier
    @param {number} mod_time
    @param {string|null} mod_message_id
    @param {number} sender_user_id
    @param {string|null} new_tag */
var ChatUnitDonationRequestInvalidation = function(mod_time, mod_message_id, sender_user_id, new_tag) {
    goog.base(this, mod_time, mod_message_id, null, null, sender_user_id, null);
    this.new_tag = new_tag;
};
goog.inherits(ChatUnitDonationRequestInvalidation, ChatModifier);
/** @override */
ChatUnitDonationRequestInvalidation.prototype.apply = function(output, req, node) {
    // do not apply invalidation to request matching the new_tag value - this can happen if
    // the chat buffer re-orders the two messages that are sent with the same "time" value
    if(req['tag'] !== this.new_tag) {
        req['cur_space'] = req['max_space'];
        if(node) {
            var new_template = gamedata['strings']['unit_donation_chat']['other']['stale'];
            if(new_template) {
                var text = SPText.cstring_to_ablocks_bbcode(new_template.replace('%recipient',req['recipient_name']));
                output.revise_text(node, text);
            } else {
                output.remove_text(node); // the destroy() callback will remove it from tab.user_data['unit_donation_requests']
            }
        }
    }
};

/** @param {!Object<string,?>} req_props
    @return {string} */
var help_request_ui_descr = function(req_props) {
    if(req_props['kind'] == 'speedup' && req_props['action'] == 'upgrade' &&
       req_props['action_spec'] && req_props['action_spec'] in gamedata['buildings']) {
        var spec = gamedata['buildings'][req_props['action_spec']];
        return spec['ui_name'] + ' L' + req_props['action_level'].toString();
    }
    return '???';
};

/** @constructor @struct
    @extends ChatModifier
    @param {number} mod_time
    @param {string|null} mod_message_id
    @param {number} sender_user_id
    @param {string|null} req_id
    @param {number} cur_helpers
    @param {number} max_helpers
    @param {number|null} xp_gained */
var ChatHelpResponse = function(mod_time, mod_message_id, sender_user_id, req_id, cur_helpers, max_helpers, xp_gained) {
    goog.base(this, mod_time, mod_message_id, null, null, null, req_id);
    this.sender_user_id = sender_user_id;
    this.cur_helpers = cur_helpers;
    this.max_helpers = max_helpers;
    this.xp_gained = xp_gained;
};
goog.inherits(ChatHelpResponse, ChatModifier);
/** @override */
ChatHelpResponse.prototype.apply = function(output, req, node) {
    if(this.sender_user_id === session.user_id) {
        req['i_helped'] = true;
        req['my_xp'] += this.xp_gained;
    }

    req['cur_helpers'] = this.cur_helpers;
    req['max_helpers'] = this.max_helpers;

    var text;

    var region_ui_name = (req['region_id'] && req['region_id'] in gamedata['regions'] ? gamedata['regions'][req['region_id']]['ui_name'] : '');
    var ui_descr = help_request_ui_descr(req['req_props']);

    if(req['recipient_id'] === session.user_id) {
        text = SPText.cstring_to_ablocks_bbcode(gamedata['strings']['help_request_chat'][region_ui_name ? 'you_region' : 'you'].replace('%cur', this.cur_helpers.toString()).replace('%max', this.max_helpers.toString()).replace('%region', region_ui_name).replace('%descr', ui_descr));
    } else {
        var kind = (req['i_helped'] ? 'you_have_helped' : 'you_have_not_helped');
        if(region_ui_name) {
            if(!session.region.data || (session.region.data['id'] !== req['region_id'])) {
                kind += '_different_region';
            } else {
                kind += '_region';
            }
        }
        text = SPText.cstring_to_ablocks_bbcode(gamedata['strings']['help_request_chat']['other'][kind].replace('%cur', this.cur_helpers.toString()).replace('%max', this.max_helpers.toString()).replace('%recipient',req['recipient_name']).replace('%xp', req['my_xp'].toString()).replace('%region', region_ui_name).replace('%descr', ui_descr), req['callback'] ? {onclick:req['callback']} : null);
    }

    output.revise_text(node, text);
};

/** @constructor @struct
    @extends ChatModifier
    @param {number} mod_time
    @param {string|null} mod_message_id
    @param {string|null} req_id
    @param {number} time_saved */
var ChatHelpComplete = function(mod_time, mod_message_id, req_id, time_saved) {
    goog.base(this, mod_time, mod_message_id, null, null, null, req_id);
    this.time_saved = time_saved;
};
goog.inherits(ChatHelpComplete, ChatModifier);
/** @override */
ChatHelpComplete.prototype.apply = function(output, req, node) {
    req['time_saved'] = this.time_saved;

    var region_ui_name = (req['region_id'] && req['region_id'] in gamedata['regions'] ? gamedata['regions'][req['region_id']]['ui_name'] : '');
    var ui_descr = help_request_ui_descr(req['req_props']);

    var template = (req['recipient_id'] === session.user_id ?
                    gamedata['strings']['help_request_chat'][region_ui_name ? 'you_completed_region' : 'you_completed'] :
                    gamedata['strings']['help_request_chat']['other'][region_ui_name ? 'completed_region' : 'completed']);
    var text = SPText.cstring_to_ablocks_bbcode(template
                                                .replace('%region', region_ui_name)
                                                .replace('%recipient',req['recipient_name'])
                                                .replace('%descr', ui_descr)
                                                .replace('%time_saved', pretty_print_time(this.time_saved)));
    output.revise_text(node, text);
};

/** @constructor @struct
    @extends ChatModifier
    @param {number} mod_time
    @param {string|null} mod_message_id
    @param {string|null} req_id
    @param {string|null} reason */
var ChatHelpFailed = function(mod_time, mod_message_id, req_id, reason) {
    goog.base(this, mod_time, mod_message_id, null, null, null, req_id);
    this.reason = reason;
};
goog.inherits(ChatHelpFailed, ChatModifier);
/** @override */
ChatHelpFailed.prototype.apply = function(output, req, node) {
    if(this.reason) {
        req['reason'] = this.reason;
    }
    var region_ui_name = (req['region_id'] && req['region_id'] in gamedata['regions'] ? gamedata['regions'][req['region_id']]['ui_name'] : '');
    var ui_descr = help_request_ui_descr(req['req_props']);

    var template = (req['recipient_id'] === session.user_id ?
                    gamedata['strings']['help_request_chat'][region_ui_name ? 'you_failed_region' : 'you_failed'] :
                    gamedata['strings']['help_request_chat']['other'][region_ui_name ? 'failed_region' : 'failed']);
    var text = SPText.cstring_to_ablocks_bbcode(template
                                                .replace('%region', region_ui_name)
                                                .replace('%recipient',req['recipient_name'])
                                                .replace('%descr', ui_descr));
    output.revise_text(node, text);
};

/** @constructor @struct
    @extends ChatModifier
    @param {number} mod_time
    @param {string|null} mod_message_id
    @param {number} sender_user_id
    @param {string|null} new_req_id */
var ChatHelpRequestInvalidation = function(mod_time, mod_message_id, sender_user_id, new_req_id) {
    goog.base(this, mod_time, mod_message_id, null, null, sender_user_id, null);
    this.new_req_id = new_req_id;
};
goog.inherits(ChatHelpRequestInvalidation, ChatModifier);
/** @override */
ChatHelpRequestInvalidation.prototype.apply = function(output, req, node) {
    // do not apply invalidation to request matching the new_req_id value - this can happen if
    // the chat buffer re-orders the two messages that are sent with the same "time" value
    if(req['req_id'] !== this.new_req_id) {
        req['cur_helpers'] = req['max_helpers'];
        if(node) {
            var new_template = gamedata['strings']['help_request_chat']['other']['stale'];
            if(new_template) {
                var text = SPText.cstring_to_ablocks_bbcode(new_template.replace('%recipient',req['recipient_name']));
                output.revise_text(node, text);
            } else {
                output.remove_text(node); // the destroy() callback will remove it from tab.user_data['help_requests']
            }
        }
    }
};

/** @param {!ChatModifier} modifier
    @param {!SPUI.Dialog} tab */
function chat_tab_apply_modifier(modifier, tab) {
    var persist = false; // whether we need to keep this modifier for use against any upcoming prepended messages

    if(modifier.target_message_id && modifier.target_message_id in tab.user_data['chat_messages_by_id']) {
        var node = tab.user_data['chat_messages_by_id'][modifier.target_message_id];
        modifier.apply(tab.widgets['output'], null, node);
    } else if(modifier.target_unit_donation_recipient_id) {
        // call on all outstanding requests for this recipient
        // note: only used for invalidations
        goog.array.forEach(goog.object.getValues(tab.user_data['unit_donation_requests']), function(req) {
            if(req['recipient_id'] === modifier.target_unit_donation_recipient_id) {
                modifier.apply(tab.widgets['output'], req, req['node'] || null);
            }
        });
        persist = true; // always persist
    } else if(modifier.target_unit_donation_tag && modifier.target_unit_donation_tag in tab.user_data['unit_donation_requests']) {
        var req = tab.user_data['unit_donation_requests'][modifier.target_unit_donation_tag];
        modifier.apply(tab.widgets['output'], req, req['node'] || null);
    } else if(modifier.target_help_request_id && modifier.target_help_request_id in tab.user_data['help_requests']) {
        var req = tab.user_data['help_requests'][modifier.target_help_request_id];
        modifier.apply(tab.widgets['output'], req, req['node'] || null);
    } else {
        persist = true; // haven't seen the target yet
    }

    var index = goog.array.binarySearch(tab.user_data['pending_modifiers'], modifier, ChatModifier.compare);
    if(persist) {
        if(index < 0) { // add persistence
            // keep sorted
            goog.array.binaryInsert(tab.user_data['pending_modifiers'], modifier, ChatModifier.compare);
        }
    } else {
        if(index >= 0) { // remove persistence
            tab.user_data['pending_modifiers'].splice(index, 1);
        }
    }
}

/** @param {!SPUI.Dialog} dialog
    @param {string} channel_name
    @param {!Object<string,?>} sender_info
    @param {string} wrapped_body
    @param {string|null} chat_msg_id
    @param {boolean} is_prepend */
function chat_frame_accept_message(dialog, channel_name, sender_info, wrapped_body, chat_msg_id, is_prepend) {
    /** @type {Array<!SPUI.Dialog>} */
    var tablist = [];

    if(channel_name == 'BROADCAST') {
        // spam to all open channels
        for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
            tablist.push(dialog.widgets['tabs'+i]);
        }
    } else if(channel_name in dialog.user_data['channel_to_tab']) {
        tablist.push(dialog.widgets['tabs'+dialog.user_data['channel_to_tab'][channel_name]]);
    } else {
        console.log("cannot find chat tab for channel "+channel_name+"!");
        return;
    }

    /** some messages modify previous messages instad of appending something new
        @type {ChatModifier|null} */
    var modifier = null;

    if(sender_info['type'] == 'message_hide') {
        if(sender_info['target_user_id'] == session.user_id) { return; } // keep showing to original sender
        modifier = new ChatHider(sender_info['time']||0, chat_msg_id,
                                 sender_info['target_message_id'], sender_info['new_type'] || null);
    } else if(sender_info['type'] == 'unit_donation_request_invalidation') {
        if(sender_info['user_id'] == session.user_id) { return; } // don't invalidate own requests
        modifier = new ChatUnitDonationRequestInvalidation(sender_info['time']||0, chat_msg_id,
                                                           sender_info['user_id'], sender_info['new_tag'] || null);
    } else if(sender_info['type'] == 'unit_donation') { // a donation to an existing request
        if(!player.unit_donation_enabled()) { return; }
        modifier = new ChatUnitDonation(sender_info['time']||0, chat_msg_id,
                                        sender_info['user_id'], sender_info['tag'] || null,
                                        sender_info['cur_space'], sender_info['max_space'],
                                        sender_info['xp_gained']||0);
    } else if(sender_info['type'] == 'help_response') { // a response to an existing request
        modifier = new ChatHelpResponse(sender_info['time']||0, chat_msg_id,
                                        sender_info['user_id'], sender_info['req_id'] || null,
                                        sender_info['cur_helpers'], sender_info['max_helpers'],
                                        sender_info['xp_gained']||0);
    } else if(sender_info['type'] == 'help_complete') { // a completion of an existing request
        modifier = new ChatHelpComplete(sender_info['time']||0, chat_msg_id,
                                        sender_info['req_id'] || null,
                                        sender_info['time_saved']||0);
    } else if(sender_info['type'] == 'help_failed') { // a failure of an existing request
        modifier = new ChatHelpFailed(sender_info['time']||0, chat_msg_id,
                                      sender_info['req_id'] || null,
                                      sender_info['reason'] || null);
    }
    if(modifier) {
        goog.array.forEach(tablist, goog.partial(chat_tab_apply_modifier, modifier));
        return;
    }

    // everything below adds a new message
    goog.array.forEach(tablist, goog.partial(chat_tab_accept_message, channel_name, sender_info, wrapped_body, chat_msg_id, is_prepend||false));
}

var chat_getmore_serial = 0;

/** @param {string} channel_name
    @param {!Object<string,?>} sender_info
    @param {string} wrapped_body
    @param {string|null} chat_msg_id
    @param {boolean} is_prepend
    @param {!SPUI.Dialog} tab */
function chat_tab_accept_message(channel_name, sender_info, wrapped_body, chat_msg_id, is_prepend, tab) {

    // for can_get_more messages, invent a fake chat_msg_id so that the message can reference
    // itself for deletion. But make sure it won't conflict with a true message ID.
    if(sender_info['type'] == 'can_get_more') {
        if(!chat_msg_id) {
            // note: the '*' first charcter signals that GETMORE should ignore this ID for query purposes
            chat_msg_id = '*getmore' + chat_getmore_serial.toString(); chat_getmore_serial += 1;
        }
    }

    if(sender_info['type'] == 'unit_donation_request') { // new unit donation request
        if(!player.unit_donation_enabled()) { return; }
        if(sender_info['time'] < server_time - gamedata['unit_donation_max_age']) {
            return; // request is stale
        }
        var tag = sender_info['tag'] || 0;
        var region_ui_name = (sender_info['region_id'] && sender_info['region_id'] in gamedata['regions'] ?
                              gamedata['regions'][sender_info['region_id']]['ui_name'] : '');

        if(tag in tab.user_data['unit_donation_requests']) { return; } // already seen (?)
        var req = tab.user_data['unit_donation_requests'][tag] = {'node':null, // updated below
                                                                  'callback': null, // updated below
                                                                  'tag':tag, 'cur_space': sender_info['cur_space'], 'max_space':sender_info['max_space'],
                                                                  'region_id': sender_info['region_id'] || null,
                                                                  'i_donated':false, 'my_xp': 0, 'dialog': null,
                                                                  'recipient_id': sender_info['user_id'],
                                                                  'recipient_fbid': sender_info['facebook_id'],
                                                                  'recipient_name': sender_info['chat_name']};
        var pct = (100.0*(sender_info['cur_space']/sender_info['max_space'])).toFixed(0);
        var text;
        if(req['recipient_id'] == session.user_id) {
            text = SPText.cstring_to_ablocks_bbcode(gamedata['strings']['unit_donation_chat'][region_ui_name ? 'you_region' : 'you'].replace('%pct', pct).replace('%region', region_ui_name));
        } else {
            var kind = 'you_have_not_donated';
            if(region_ui_name) {
                if(!session.region.data || (session.region.data['id'] !== sender_info['region_id'])) {
                    kind += '_different_region';
                } else {
                    kind += '_region';
                }
            }
            req['callback'] = (function (_req) { return function(w, mloc) {
                change_selection_ui(null);
                _req['dialog'] = invoke_unit_donation_dialog(_req);
            }; })(req);
            text = SPText.cstring_to_ablocks_bbcode(gamedata['strings']['unit_donation_chat']['other'][kind].replace('%pct', pct).replace('%recipient',req['recipient_name']).replace('%xp', req['my_xp'].toString()).replace('%region', region_ui_name), {onclick:req['callback']});
        }
        if(is_prepend) {
            req['node'] = tab.widgets['output'].prepend_text(text);
        } else {
            req['node'] = tab.widgets['output'].append_text(text);
        }
        req['node'].on_destroy = (function (_req, _tab) { return function(_node) {
            delete _tab.user_data['unit_donation_requests'][_req['tag']];
        }; })(req, tab);

    } else if(sender_info['type'] == 'help_request') { // new help request
        if(server_time >= sender_info['expire_time']) {
            return; // request is stale
        }
        var req_id = sender_info['req_id'] || '';
        var region_ui_name = (sender_info['region_id'] && sender_info['region_id'] in gamedata['regions'] ?
                              gamedata['regions'][sender_info['region_id']]['ui_name'] : '');

        var ui_descr = help_request_ui_descr(sender_info['req_props']);

        if(req_id in tab.user_data['help_requests']) { return; } // already seen (?)
        var req = tab.user_data['help_requests'][req_id] = {'node':null, // updated below
                                                            'callback': null, // updated below
                                                            'req_id': req_id, 'req_props': sender_info['req_props'], 'expire_time': sender_info['expire_time'],
                                                            'cur_helpers': sender_info['cur_helpers'], 'max_helpers':sender_info['max_helpers'],
                                                            'region_id': sender_info['region_id'] || null,
                                                            'i_helped':false, 'my_xp': 0, 'dialog': null,
                                                            'recipient_id': sender_info['user_id'],
                                                            'recipient_name': sender_info['chat_name']};
        var text;
        if(req['recipient_id'] == session.user_id) {
            text = SPText.cstring_to_ablocks_bbcode(gamedata['strings']['help_request_chat'][region_ui_name ? 'you_region' : 'you'].replace('%cur', sender_info['cur_helpers'].toString()).replace('%max', sender_info['max_helpers'].toString()).replace('%region', region_ui_name).replace('%descr', ui_descr));
        } else {
            var kind = 'you_have_not_helped';
            if(region_ui_name) {
                if(!session.region.data || (session.region.data['id'] !== sender_info['region_id'])) {
                    kind += '_different_region';
                } else {
                    kind += '_region';
                }
            }
            req['callback'] = (function (_req) { return function(w, mloc) {
                if(_req['i_helped']) { return; }
                if(_req['expire_time'] < server_time) {
                    // stale
                    var s = gamedata['errors']['HELP_REQUEST_STALE'];
                    invoke_child_message_dialog(s['ui_title'], s['ui_name'], {'dialog':'message_dialog_big'});
                    return;
                }

                if(_req['region_id'] && (!session.region.data || session.region.data['id'] !== _req['region_id'])) {
                    // wrong region - offer to relocate
                    invoke_find_on_map(_req['region_id'], [0,0]);
                    return;
                } else if('requires' in gamedata['spells']['GIVE_ALLIANCE_HELP']) {
                    var pred = read_predicate(gamedata['spells']['GIVE_ALLIANCE_HELP']['requires']);
                    if(!pred.is_satisfied(player)) {
                        var helper = get_requirements_help(pred);
                        if(helper) { helper(); }
                        return;
                    }
                }

                send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "GIVE_ALLIANCE_HELP", _req['recipient_id'], _req['req_id']]);
                _req['i_helped'] = true; // client-side predict
            }; })(req);
            text = SPText.cstring_to_ablocks_bbcode(gamedata['strings']['help_request_chat']['other'][kind].replace('%cur', sender_info['cur_helpers'].toString()).replace('%max', sender_info['max_helpers'].toString()).replace('%recipient',req['recipient_name']).replace('%xp', req['my_xp'].toString()).replace('%region', region_ui_name).replace('%descr', ui_descr), {onclick:req['callback']});
        }
        if(is_prepend) {
            req['node'] = tab.widgets['output'].prepend_text(text);
        } else {
            req['node'] = tab.widgets['output'].append_text(text);
        }
        req['node'].on_destroy = (function (_req, _tab) { return function(_node) {
            delete _tab.user_data['help_requests'][_req['req_id']];
        }; })(req, tab);
    } else {
        // normal chat message
        if(player.has_blocked_or_force_blocked_user(sender_info['user_id']) &&
           (sender_info['type'] != 'i_got_gagged') &&
           (channel_name !== 'DEVELOPER')) { return; }

        var body = SPHTTP.unwrap_string(wrapped_body);
        var props = {};

        if('muted' in sender_info) {
            props.color = '#ff0000';
        } else if(channel_name == 'BROADCAST') {
            props.color = '#ffff00';
        }

        // check for special message types
        var template = (sender_info['type'] && (sender_info['type'] in gamedata['strings']['chat_templates']) ? sender_info['type'] : 'default');

        var bb_text = gamedata['strings']['chat_templates'][template];

        // is this text reportable for abuse?
        // note: for the onclick handlers below to work, report_args must be set up even if it's your own message, or a private channel
        var report_args;
        if(chat_msg_id && bb_text.indexOf('%body') >= 0 && ('time' in sender_info) && ('chat_name' in sender_info) &&
           ('user_id' in sender_info) && sender_info['user_id'] > 0 && !is_ai_user_id_range(sender_info['user_id'])) {
            report_args = new AdvancedChatReportArgs(sender_info['user_id'], channel_name, sender_info['chat_name'], body, sender_info['time'], chat_msg_id);
        } else {
            report_args = null;
        }
        var alliance_id = ('alliance_id' in sender_info ? sender_info['alliance_id'] : -1);

        var bbcode_click_handlers = goog.object.clone(system_chat_bbcode_click_handlers);

        // special override for player names
        bbcode_click_handlers['player'] = { 'onclick': (function (_report_args, _alliance_id) { return function (_suser_id, _ui_name) {
            return function(w, mloc) {
                if(!_suser_id) { return; }
                var _user_id = parseInt(_suser_id,10);
                if(!_user_id || is_ai_user_id_range(_user_id) || _user_id < 0) { return; }

                // note: this might refer to a DIFFERENT player than the main message - if so, ignore report_args and alliance_id
                if(!_report_args || (_user_id !== _report_args.user_id)) {
                    _alliance_id = -1;
                    _report_args = null;
                }
                invoke_chat_player_context_menu(_user_id, _alliance_id, _ui_name, _report_args, mloc);
            }; }; })(report_args, alliance_id)};

        var base_props = {};
        if('time' in sender_info) {
            base_props.tooltip_func = (function (_send_time) { return function() {
                return gamedata['strings']['chat_age'].replace('%s', pretty_print_time(server_time - _send_time));
            }; })(sender_info['time']);
        }

        // set up a default onclick handler for the entire blob of text
        if(report_args) {
            base_props.onclick = bbcode_click_handlers['player']['onclick'](report_args.user_id.toString(), report_args.ui_name);
        }

        // replace message ID
        if(bb_text.indexOf('%chat_message_id') != -1 && chat_msg_id) {
                bb_text = bb_text.replace('%chat_message_id', chat_msg_id);
        }

        // inject raw body text into the BBCode string, INCLUDING LIVE BBCODE.
        // this is ONLY for system-generated chat messages. NOT safe to allow
        // regular users to inject arbitrary BBCode.
        if(bb_text.indexOf('%unsafe_body') != -1 && body) {
            bb_text = bb_text.replace('%unsafe_body', body);
        }

        // replace alliance chat tag
        if(bb_text.indexOf('%tag') != -1) {
            if((channel_name != 'ALLIANCE') && ('alliance_tag' in sender_info) && ('alliance_id' in sender_info) && (sender_info['alliance_id'] >= 0) &&
               player.get_any_abtest_value('enable_alliance_chat_tags', gamedata['client']['enable_alliance_chat_tags'])) {
                bb_text = bb_text.replace('%tag', gamedata['strings']['chat_templates']['alliance_tag'].replace('%alliance_tag', sender_info['alliance_tag']).replace('%alliance_id', sender_info['alliance_id']));
            } else {
                bb_text = bb_text.replace('%tag', '');
            }
        }

        // replace achievement name template
        if(bb_text.indexOf('%achievement_name') != -1 && ('achievement_name' in sender_info)) { // check if the template has "%achievement_name in it" AND if the message includes an "achievement_name" property

            // if global option is disabled, or global persist is disabled and message is from before login, do not show the message
            if(!player.get_any_abtest_value('chat_alliance_achievements', gamedata['chat_alliance_achievements']) ||
               ((sender_info['time'] < session.connect_time) &&
                !player.get_any_abtest_value('chat_alliance_achievements_persist', gamedata['chat_alliance_achievements_persist']))) {
                return; // ignore the message
            }

            var cheeve = gamedata['achievements'][sender_info['achievement_name']];
            if(cheeve) {
                if('chat_announce' in cheeve && !cheeve['chat_announce']) { return; } // disabled for this achievement
                bb_text = bb_text.replace('%achievement_name', cheeve['ui_name']);
                bb_text = bb_text.replace('%achievement_id', sender_info['achievement_name']);
            }
        }

        // other text replacements
        goog.object.forEach({'%sender_id': 'user_id',
                             '%sender_id2': 'user_id',
                             '%sender_name': 'chat_name',
                             '%target_id': 'target_user_id',
                             '%target_name': 'target_chat_name',
                             '%target_role': 'target_role_ui_name',
                             '%alliance_id': 'alliance_id',
                             '%alliance_name': 'alliance_name',
                             '%alliance_points': 'alliance_points',
                             '%points_to_win': 'points_to_win',
                             '%prev_alliance_id': 'prev_alliance_id',
                             '%prev_alliance_name': 'prev_alliance_name',
                             '%old_name': 'old_name',
                             '%region_name': 'region_name',
                             '%item_name': 'item_name',
                             '%channel_name': 'channel_name'
                            }, function(sender_key, repl_key) {
                                if(bb_text.indexOf(repl_key) != -1 && (sender_key in sender_info)) {
                                    bb_text = bb_text.replace(repl_key, SPText.bbcode_quote(sender_info[sender_key].toString()));
                                }
                            });

        var text = SPText.cstring_to_ablocks_bbcode(bb_text, base_props, bbcode_click_handlers);

        var disp_text, disp_user_data;

        if(gamedata['strings']['chat_templates'][template].indexOf('%body') != -1) {
            disp_user_data = {'prebody': text, 'unfiltered_body': body,
                              // for later abuse_violated override
                              'sender_name': ('chat_name' in sender_info ? SPText.bbcode_quote(sender_info['chat_name']) : 'Unknown')};
            if(sender_info['home_region']) { disp_user_data['home_region'] = sender_info['home_region']; }
            disp_text = display_user_chat_body_nodes(disp_user_data);
        } else {
            disp_text = text;
            disp_user_data = null;
        }

        var node;
        if(is_prepend) {
            node = tab.widgets['output'].prepend_text(disp_text, disp_user_data);
        } else {
            node = tab.widgets['output'].append_text(disp_text, disp_user_data);
        }
        if(chat_msg_id) {
            tab.user_data['chat_messages_by_id'][chat_msg_id] = node;
            node.on_destroy = (function (_tab, _chat_msg_id) { return function(_node) {
                delete _tab.user_data['chat_messages_by_id'][_chat_msg_id];
            }; })(tab, chat_msg_id);
            if(chat_msg_id[0] != '*' && /* ignore fake IDs generated for 'can_get_more' messages */
               (tab.user_data['earliest_id'] === null || chat_msg_id < tab.user_data['earliest_id'])) {
                tab.user_data['earliest_id'] = chat_msg_id;
            }
        }
        tab.user_data['earliest_timestamp'] = Math.min(tab.user_data['earliest_timestamp'], sender_info['time']);
    }

    // update timestamps for jewel notification, but not if we typed the message ourself, and not for non-text updates
    if(sender_info['user_id'] != session.user_id &&
       !goog.array.contains(['unit_donation', 'help_response', 'welcome', 'logged_in', 'logged_out', 'message_hide'], sender_info['type'])) {
        tab.user_data['last_timestamp'] = Math.max(tab.user_data['last_timestamp'], sender_info['time'] || server_time);
    }

    // see if any pending modifiers want to work on this message
    if(is_prepend) {
        // copy since the list may mutate
        goog.array.forEach(goog.array.clone(tab.user_data['pending_modifiers']), function(mod) {
            chat_tab_apply_modifier(mod, tab);
        });
    }
}

function change_chat_tab(dialog, new_tab) {
    if(!new_tab) {
        // pick a default
        new_tab = eval_cond_or_literal(gamedata['client']['default_chat_tab'], player, null);
    }

    var index = dialog.user_data['channel_to_tab'][new_tab];
    for(var i = 0; i < Math.min(dialog.data['widgets']['tab_button']['array'][0], dialog.user_data['channel_names'].length); i++) {
        // note: .show of the button is set by chat_frame_size(). Here we set only .state and .tooltip.str
        var w = dialog.widgets['tab_button'+i.toString()];
        w.tooltip.str = null;
        var channel = dialog.user_data['channel_names'][i];
        w.state = (new_tab == channel ? 'pressed' : 'normal');
        if(channel == 'ALLIANCE') {
            if(!session.is_in_alliance()) {
                // player is NOT in an alliance - gray out the button
                w.state = 'disabled';
                w.tooltip.str = dialog.data['widgets']['tab_button']['channels']['ALLIANCE']['ui_tooltip'];
            }
        } else if(channel == 'REGION') {
            if(!session.region || !session.region.data) {
                // player is NOT on the regional map - gray out the button
                w.state = 'disabled';

                // try to get a tooltip explaining what the player needs to do to get on the regional map
                var pred = read_predicate({"predicate": "LIBRARY", "name": "quarry_requirement"});
                if(pred.is_satisfied(player, null)) {
                    // player does fulfill predicate but is not on the map - this is a rare corner case - ignore it
                    w.tooltip.str = null; // remove the tooltip
                } else {
                    // player does not fulfill predicate - create a tooltip explaining why
                    w.tooltip.str = dialog.data['widgets']['tab_button']['channels']['REGION']['ui_tooltip'].replace('%s', pred.ui_describe(player));
                }
            }
        }
    }

    dialog.user_data['cur_tab'] = index;
    for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
        var tab = dialog.widgets['tabs'+i];
        tab.show = (i == dialog.user_data['cur_tab']);
    }
}

// functions run when part of the chat message is clicked
// user-typed messages
var user_chat_bbcode_click_handlers = {
    'map_coords': { 'onclick': function(_srxy) {
        return function(w, mloc) {
            if(!_srxy) { return; }
            var params = _srxy.split(',');
            var region = params[0], x = parseInt(params[1],10), y = parseInt(params[2],10);
            invoke_find_on_map(region, [x,y]);
        }; } }
};

// server-controlled messages
var system_chat_bbcode_click_handlers = {
    'url': { 'onclick': function(_url) { return function(w, mloc) {
        _url = url_put_info(_url, session.user_id, player.history['money_spent']||0);
        var handle = window.open(_url, '_blank');
        if(handle) { handle.focus(); }
    }; } },
    'alliance': { 'onclick': function(salliance_id) { return function(w, mloc) {
        var alliance_id = parseInt(salliance_id,10);
        if(alliance_id >= 0) {
            change_selection_ui(null); invoke_alliance_info(alliance_id);
        }
    }; } },
    'player': { 'onclick': function(splayer_id) { return function(w, mloc) {
        var player_id = parseInt(splayer_id,10);
        if(player_id >= 0) {
            change_selection_ui(null); PlayerInfoDialog.invoke(player_id);
        }
    }; } },
    'achievement': {'onclick': function(player_and_name) { return function(w, mloc) {
        var fields = player_and_name.split(':');
        var player_id = parseInt(fields[0],10), name = fields[1];
        if(name in gamedata['achievements']) {
            var cheeve = gamedata['achievements'][name];
            change_selection_ui(null);
            PlayerInfoDialog.invoke(player_id,
                                    (function (_cheeve) { return function(dialog) { PlayerInfoDialog.invoke_achievements_tab(dialog, _cheeve['category'], _cheeve['name']); }; })(cheeve)
                                   );
        }
    }; } },
    'sku': { 'onclick': function (path) { return (function (_path) { return function() {
        invoke_store('exact_path', _path);
        // play sound effect
        GameArt.play_canned_sound('action_button_resizable');
    }; })(path); } },
    'getmore': { 'onclick': function(chat_msg_id) { return (function (_chat_msg_id) { return function(w, mloc) {
        // for the "Click here to load earlier chat messages" message

        // find and delete this one message
        var tab = w.parent;
        if(tab && _chat_msg_id in tab.user_data['chat_messages_by_id']) {
            w.remove_text(tab.user_data['chat_messages_by_id'][_chat_msg_id]);
        }

        // perform the same checks as SPUI.ScrollingTextField.scroll_up(),
        // and then send the scrolling command.
        if(w.can_scroll_up() && w.buf_top >= w.buffer.length && !w.getmore_final && !w.getmore_pending) {
            w.scroll_up();
        }

    }; })(chat_msg_id); } }
};


// Convert body string of user chat message to SPText.ABlock array.
// Applies profanity filter and map coordinate detection.
// Does NOT otherwise allow BBCode, to prevent injection attacks.
function display_user_chat_body(body, base_props, home_region) {
    // profanity filter
    var do_filter = get_preference_setting(player.preferences, 'chat_filter');
    var disp_body = (do_filter ? ChatFilter.censor(body) : body);

    // escape out any special BBCode characters to avoid injection attacks
    var disp_body_safe = SPText.bbcode_quote(disp_body);
    var disp_body_final = '';

    // perform final BBCode substitution, eating head of disp_body_safe and appending to tail of disp_body_final
    if(gamedata['strings']['chat_map_coords_regex'] && home_region) {
        while(true) {
            var map_coords_re = new RegExp(gamedata['strings']['chat_map_coords_regex'], 'g');
            var result = map_coords_re.exec(disp_body_safe);
            if(result === null) { break; }
            // transfer the part of the string before the match
            disp_body_final += disp_body_safe.slice(0, result.index);
            disp_body_safe = disp_body_safe.slice(result.index + result[0].length, disp_body_safe.length);
            var x = parseInt(result[1],10).toString();
            var y = parseInt(result[2],10).toString();
            // sanity check - do not send bad coordinates
            if(!(home_region in gamedata['regions']) ||
               x < 0 || x >= gamedata['regions'][home_region]['dimensions'][0] ||
               y < 0 || y >= gamedata['regions'][home_region]['dimensions'][1]) {
                disp_body_final += result[0];
            } else {
                // add in the templated version of the match
                disp_body_final += gamedata['strings']['chat_templates']['map_coords'].replace('%region',home_region).replace('%x',x.toString()).replace('%x',x.toString()).replace('%y',y.toString()).replace('%y',y.toString());
            }
        }
    }
    // add last bit of input
    disp_body_final += disp_body_safe;
    var blocks = SPText.cstring_to_ablocks_bbcode(disp_body_final, base_props, user_chat_bbcode_click_handlers);
    if(blocks.length > 0) {
        return blocks[0];
    } else {
        return [];
    }
}

// Inject user-provided "body" string into %body contained in the SPText.ABlock array original_text.
// This is done as a later step after the initial BBCode parse, to avoid malicious injection attacks.
// Also, store a copy of the ABlocks before %body replacement, to allow toggling censorship later.
function display_user_chat_body_nodes(user_data) {
    var text = user_data['prebody'];
    var body = user_data['unfiltered_body'];
    var disp_text = [];
    // reconstruct disp_text from text, performing %body replacement
    for(var i = 0; i < text.length; i++) {
        disp_text.push([]);
        for(var j = 0; j < text[i].length; j++) {
            var idx = text[i][j].str.indexOf('%body');
            if(idx >= 0) {
                // break into 3 parts: before body, body, after body
                var before_body_str = text[i][j].str.slice(0,idx);
                var after_body_str = text[i][j].str.slice(idx+('%body'.length), text[i][j].length);
                if(before_body_str) { disp_text[i].push(new SPText.ABlock(before_body_str, text[i][j].props)); }
                // create BBCode blocks for %body
                var body_blocks = display_user_chat_body(body, text[i][j].props, user_data['home_region']||null);
                disp_text[i] = disp_text[i].concat(body_blocks);
                if(after_body_str) { disp_text[i].push(new SPText.ABlock(after_body_str, text[i][j].props)); }
            } else {
                disp_text[i].push(new SPText.ABlock(text[i][j].str, text[i][j].props));
            }
        }
    }
    return disp_text;
}

/** @param {SPUI.Dialog} dialog */
function recensor_chat_frame(dialog) {
    for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
        var tab = dialog.widgets['tabs'+i];
        tab.widgets['output'].revise_all_text(function(original_text, user_data) {
            if(!user_data) { return original_text; } // probably a non-standard template - no need to alter it
            return display_user_chat_body_nodes(user_data);
        });
    }
}

/**
    @param {!SPUI.Dialog} dialog
*/
function update_chat_frame(dialog) {
    // check for unseen chat messages, and set jewel states appropriately
    var any_unseen = false;
    var last_invert = dialog.user_data['last_invert'];
    var invert_chat_window = !!player.preferences['invert_chat_window'];
    for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
        var tab = dialog.widgets['tabs'+i];
        if(invert_chat_window){
            tab.widgets['output_bg'].xy = tab.data['widgets']['output_bg']['inverted_xy'];
            tab.widgets['output'].xy = tab.data['widgets']['output']['inverted_xy'];
            var invert = !tab.data['widgets']['output']['invert'];
            tab.widgets['output'].invert = invert;
            tab.widgets[(invert ? 'scroll_down' : 'scroll_up')].onclick = function(w) { w.parent.widgets['output'].scroll_up(); };
            tab.widgets[(invert ? 'scroll_up' : 'scroll_down')].onclick = function(w) { w.parent.widgets['output'].scroll_down(); };
        } else {
            tab.widgets['output_bg'].xy = tab.data['widgets']['output_bg']['xy'];
            tab.widgets['output'].xy = tab.data['widgets']['output']['xy'];
            var invert = tab.data['widgets']['output']['invert'];
            tab.widgets['output'].invert = invert;
            tab.widgets[(invert ? 'scroll_down' : 'scroll_up')].onclick = function(w) { w.parent.widgets['output'].scroll_up(); };
            tab.widgets[(invert ? 'scroll_up' : 'scroll_down')].onclick = function(w) { w.parent.widgets['output'].scroll_down(); };
        }
        // a mismatch signals that the player recently changed the orientation preference.
        // this refreshes the text so the orientation and message order is correct
        if(last_invert != invert_chat_window){
            tab.widgets['output'].update_text();
        }
        dialog.user_data['last_invert'] = invert_chat_window; // makes sure the dialog knows that the last_invert value matches the current invert_chat_window value
        var channel_name = tab.user_data['channel_name'];
        var unseen = false;
        if(dialog.user_data['size'] == 'big' && tab.show) {
            player.chat_seen[channel_name] = Math.ceil(server_time);
        } else if(tab.user_data['last_timestamp'] > (player.chat_seen[channel_name] || 0)) {
            unseen = true;
        }
        dialog.widgets['tab_jewel'+i].user_data['text'] = (unseen ? '!' : null);
        any_unseen |= unseen;

        tab.widgets['loading_spinner'].show = (!!tab.widgets['output'].getmore_pending && (dialog.user_data['size'] == 'big'));

        // update state of Reinforcements button
        tab.widgets['request_donation_button'].show = ((dialog.user_data['size'] == 'big') && (channel_name=='ALLIANCE') && player.unit_donation_enabled());

        var spell = gamedata['spells']['REQUEST_UNIT_DONATION'];
        var togo = player.cooldown_togo(spell['cooldown_name']);
        if(player.donated_units_space() >= player.donated_units_max_space()) {
            tab.widgets['request_donation_button'].state = 'disabled';
            tab.widgets['request_donation_button'].tooltip.str = tab.data['widgets']['request_donation_button']['ui_tooltip_space_limit'].replace('%s', gamedata['buildings'][gamedata['alliance_building']]['ui_name']);
        } else if(togo > 0) {
            tab.widgets['request_donation_button'].state = 'disabled';
            tab.widgets['request_donation_button'].tooltip.str = tab.data['widgets']['request_donation_button']['ui_tooltip_cooldown'].replace('%s', pretty_print_time(togo));
        } else {
            tab.widgets['request_donation_button'].state = (player.alliance_building_is_busy() ? 'disabled_clickable' : 'normal');
            tab.widgets['request_donation_button'].tooltip.str = tab.data['widgets']['request_donation_button']['ui_tooltip'];
        }
    }
    dialog.widgets['all_jewel'].user_data['text'] = (any_unseen ? '!' : null);

    // adjust size/position of NEW chat frame
    if(1) {

        var t = clamp((client_time - dialog.user_data['transition_start_time']) / dialog.data['transition_time'], 0, 1);
        dialog.xy = vec_floor(vec_lerp(dialog.data['xy'+(dialog.user_data['size']=='big'?'_minimized':'')],
                                                  dialog.data['xy'+(dialog.user_data['size']=='small'?'_minimized':'')], t));
        // crowd out the top/bottom consoles by this many pixels horizontally
        dialog.user_data['console_shift'] = lerp(dialog.data['console_shift'+(dialog.user_data['size']=='big'?'_minimized':'')],
                                                            dialog.data['console_shift'+(dialog.user_data['size']=='small'?'_minimized':'')], t);

        dialog.wh = [dialog.wh[0], canvas_height];
        dialog.widgets['bg_frame'].wh[1] = dialog.wh[1];
        dialog.widgets['grow_down'].xy = [dialog.data['widgets']['grow_down']['xy'][0],
                                                     Math.floor(dialog.wh[1]/2 - dialog.widgets['grow_down'].wh[1]/2)];
        dialog.widgets['grow_up'].xy = [dialog.data['widgets']['grow_up']['xy'][0],
                                                   dialog.widgets['grow_down'].xy[1]];
        dialog.widgets['grow_bg'].xy[1] = dialog.widgets['grow_down'].xy[1];
        dialog.widgets['all_jewel'].xy = [dialog.data['widgets']['all_jewel']['xy'][0],
                                                     dialog.widgets['grow_down'].xy[1] + (dialog.data['widgets']['all_jewel']['xy'][1] - dialog.data['widgets']['grow_down']['xy'][1])];

        for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
            var tab = dialog.widgets['tabs'+i.toString()];
            tab.wh = [tab.wh[0], dialog.wh[1]];
            tab.user_data['last_output_h'] = tab.widgets['output'].wh[1];
            tab.widgets['output_bg'].wh = [tab.data['widgets']['output_bg']['dimensions'][0], tab.wh[1] - (tab.data['dimensions'][1] - (tab.data['widgets']['output_bg']['xy'][1] + tab.data['widgets']['output_bg']['dimensions'][1]))];
            tab.widgets['output'].wh = [tab.data['widgets']['output']['dimensions'][0], tab.wh[1] - (tab.data['dimensions'][1] - (tab.data['widgets']['output']['xy'][1]+ tab.data['widgets']['output']['dimensions'][1]))];
            tab.widgets['output'].clip_to = [tab.widgets['output'].xy[0], tab.widgets['output'].xy[1],
                                             tab.widgets['output'].wh[0] + (tab.widgets['output'].data['clip_to'][2] - tab.widgets['output'].data['dimensions'][0]),
                                             tab.widgets['output'].wh[1] + (tab.widgets['output'].data['clip_to'][3] - tab.widgets['output'].data['dimensions'][1])];
            var input_bg_new_y_pos = 0;
            var input_new_y_pos = 0;
            if(invert_chat_window){
                // this repositions the input based on the output wh value
                // which is necessary for fullscreen
                input_bg_new_y_pos = tab.widgets['output_bg'].wh[1] + dialog.data['widgets']['input_bg']['inverted_y_offset'];
                // ensures the input widget xy position is adjusted based on the existing space offset between input and input_bg
                input_new_y_pos = input_bg_new_y_pos + (dialog.widgets['input'].xy[1] - dialog.widgets['input_bg'].xy[1]);
                dialog.widgets['input_bg'].xy[1] = input_bg_new_y_pos;
                dialog.widgets['input'].xy[1] = input_new_y_pos;
            } else {
                input_bg_new_y_pos = dialog.data['widgets']['input_bg']['xy'][1];
                input_new_y_pos = input_bg_new_y_pos + (dialog.data['widgets']['input']['xy'][1] - dialog.data['widgets']['input_bg']['xy'][1]);
                dialog.widgets['input_bg'].xy[1] = input_bg_new_y_pos;
                dialog.widgets['input'].xy[1] = input_new_y_pos;
            }
            if(tab.widgets['output'].wh[1] != tab.user_data['last_output_h']) {
                tab.widgets['output'].update_text();
            }
        }

        // adjust Z order
        if(dialog.parent === SPUI.root && ('desktop_top' in desktop_dialogs) && ('desktop_bottom' in desktop_dialogs)) {
            SPUI.root.unparent(dialog);
            if(vec_equals(dialog.xy, dialog.data['xy_minimized'])) {
                SPUI.root.add_before(desktop_dialogs['desktop_top'], dialog);
            } else {
                SPUI.root.add_after(desktop_dialogs['desktop_bottom'], dialog);
            }
        }
    }
}

/** scrolls chat window by the amount and direction of delta
    @param {!SPUI.Dialog} dialog
    @param {number} delta
*/
function scroll_chat_frame(dialog, delta) {
    // error catching to prevent attempting to scroll if not receiving a dialog or a delta
    if (!dialog || !delta) { return; }
    var invert_chat_window = !!player.preferences['invert_chat_window'];
    if(invert_chat_window) { delta = delta * -1; }
    var cur_tab = dialog.user_data['cur_tab'];
    // if no channel is selected, this will prevent any attempted scrolling
    if (cur_tab == null || cur_tab < 0) { return ;}
    var tab = 'tabs' + cur_tab.toString();
    var channel = dialog.widgets[tab].widgets['output'];
    if (delta > 0 && channel.can_scroll_up()) {
        channel.scroll_up();
    } else if (delta < 0 && channel.can_scroll_down()) {
        channel.scroll_down();
    }
}

var chat_getmore_receiver = new goog.events.EventTarget();

function init_chat_frame() {
    var dialog_data = gamedata['dialogs']['chat_frame2'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'chat_frame';
    dialog.user_data['size'] = 'uninitialized';
    dialog.user_data['console_shift'] = 0;
    dialog.user_data['transition_start_time'] = -1;
    dialog.user_data['cur_tab'] = -1;
    dialog.user_data['channel_to_tab'] = {};
    //dialog.ondraw = update_chat_frame; this is now called from the master do_draw() because it can change Z order of chat frame and desktop dialogs
    dialog.user_data['channel_names'] = [];
    dialog.on_mousewheel_function = scroll_chat_frame;
    if(player.get_any_abtest_value('enable_region_map', gamedata['enable_region_map'])) {
        dialog.user_data['channel_names'].push('REGION');
    }
    dialog.user_data['channel_names'].push('GLOBAL');
    if(player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) {
        dialog.user_data['channel_names'].push('ALLIANCE');
    }

    change_chat_tab(dialog, null);

    for(var i = 0; i < dialog.data['widgets']['tab_button']['array'][0]; i++) {
        var w = dialog.widgets['tab_button'+i.toString()];
        if(i < dialog.user_data['channel_names'].length) {
            var channel_name = dialog.user_data['channel_names'][i];
            w.str = dialog.data['widgets']['tab_button']['channels'][channel_name]['ui_name'];
            w.onclick = (function (_channel_name) { return function(w) {
                change_chat_tab(w.parent, _channel_name);
            }; })(channel_name);
        }
    }

    for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
        var tab = dialog.widgets['tabs'+i];
        dialog.widgets['tab_jewel'+i].user_data['text'] = null;
        dialog.widgets['tab_jewel'+i].ondraw = update_notification_jewel;

        if(i >= dialog.user_data['channel_names'].length) { tab.show = false; continue; }
        tab.transparent_to_mouse = true;
        tab.user_data['channel_name'] = dialog.user_data['channel_names'][i];
        dialog.user_data['channel_to_tab'][dialog.user_data['channel_names'][i]] = i;
        tab.user_data['last_timestamp'] = 0;
        tab.user_data['unit_donation_requests'] = {};
        tab.user_data['help_requests'] = {};
        tab.user_data['chat_messages_by_id'] = {};
        tab.user_data['pending_modifiers'] = []; // for prepended text
        tab.user_data['earliest_id'] = null;
        tab.user_data['earliest_timestamp'] = Infinity;
        var invert = !!tab.data['widgets']['output']['invert'];
        var invert_chat_window = !!player.preferences['invert_chat_window'];
        dialog.user_data['last_invert'] = invert_chat_window;
        tab.widgets['output'].scroll_up_button = tab.widgets[(invert ? 'scroll_down' : 'scroll_up')];
        tab.widgets['output'].scroll_down_button = tab.widgets[(invert ? 'scroll_up' : 'scroll_down')];
        tab.widgets['output'].getmore_cb = (gamedata['client']['enable_chat_getmore'] ? function(w) {
            var tab = w.parent;

            // remove any lingering 'can_get_more' messages
            var to_remove = [];
            for(var chat_msg_id in tab.user_data['chat_messages_by_id']) {
                if(chat_msg_id.indexOf('getmore') === 0) {
                    to_remove.push(chat_msg_id);
                }
            }
            goog.array.forEach(to_remove, function(chat_msg_id) {
                tab.widgets['output'].remove_text(tab.user_data['chat_messages_by_id'][chat_msg_id]);
            });

            var tag = 'cgm'+(last_query_tag++).toString();
            chat_getmore_receiver.listenOnce(tag, (function (_tab) { return function(event) {
                goog.array.forEach(event.response, function(data) {
                    var channel_name = data[1];
                    var sender_info = data[2];
                    var wrapped_body = data[3] || '';
                    var chat_msg_id = data[4];
                    var is_prepend = data[5];
                    chat_frame_accept_message(global_chat_frame, channel_name, sender_info, wrapped_body, chat_msg_id, is_prepend);
                });
                tab.widgets['output'].getmore_responded(event.is_final);
            }; })(tab));
            send_to_server.func(["CHAT_GETMORE", tab.user_data['channel_name'], tab.user_data['earliest_timestamp']+5 /* fudge time */, tab.user_data['earliest_id'], tag]);
        } : null);
        tab.widgets['output'].update_text();
        tab.widgets[(invert ? 'scroll_down' : 'scroll_up')].onclick = function(w) { w.parent.widgets['output'].scroll_up(); };
        tab.widgets[(invert ? 'scroll_up' : 'scroll_down')].onclick = function(w) { w.parent.widgets['output'].scroll_down(); };
        tab.widgets['request_donation_button'].onclick = function(w) {
            if(resolve_unit_donation_problem()) { return; }
            request_unit_donation(find_object_by_type(gamedata['alliance_building']));
            GameArt.play_canned_sound('request_unit_donation_sound');
        };
    }

    dialog.widgets['all_jewel'].user_data['text'] = null;
    dialog.widgets['all_jewel'].ondraw = update_notification_jewel;

    if('fullscreen_button' in dialog.widgets) { dialog.widgets['fullscreen_button'].onclick = toggle_true_fullscreen; }

    var grow_func = function (big) { return function(w) {
        chat_frame_size(w.parent, big, false);
        player.preferences['chat_frame_minimized'] = !big;
        send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
    }; };
    dialog.widgets['grow_up'].onclick = grow_func(true);
    dialog.widgets['grow_down'].onclick = grow_func(false);

    dialog.widgets['input'].max_chars = gamedata['chat_length_limit'];
    dialog.widgets['input'].onfocus =
        dialog.widgets['input'].ontype =
        function(w) {
            //change_selection_ui(null);
            chat_frame_size(w.parent, true, false);
        };
    dialog.widgets['input'].onunfocus = function(w) {
        if(!w.str) {
            // reset "type here to chat" text
            w.str = w.data['ui_name'];
            w.has_typed = false;
        }
    };
    dialog.widgets['input'].ontextready = function(w, str) {
        if(!str) { return; }

        var channel = dialog.widgets['tabs'+dialog.user_data['cur_tab']].user_data['channel_name'];
        var is_public_channel = goog.array.contains(['GLOBAL','REGION'], channel);

        if(is_public_channel && ChatFilter.is_bad(str)) {
            var after_warn = (function (_w) { return function() {
                // restore keyboard focus after warning closes
                _w.has_typed = true;
                SPUI.set_keyboard_focus(_w);
            }; })(w);
            if(invoke_chat_filter_warning(after_warn)) {
                // restore the text that was typed, but don't send the message
                w.set_str(str);
                return;
            }
        }
        var encoded_str = SPHTTP.wrap_string(str);

        send_to_server.func(["CHAT_SEND", channel, encoded_str]);
        dialog.widgets['tabs'+dialog.user_data['cur_tab']].widgets['output'].scroll_to_bottom();

        // play a click effect
        GameArt.play_canned_sound('action_button_134px');

        // client-side predict for quest purposes
        player.history['chat_messages_sent'] = (player.history['chat_messages_sent'] || 0) + 1;
        if(player.history['chat_messages_sent'] < 2) { // avoid this calculation after many have been sent
            player.invalidate_quest_cache();
        }

        if(channel == 'ALLIANCE') {
            player.record_feature_use('alliance_chat');
        } else if(is_public_channel) {
            player.record_feature_use('public_chat');
        }
    };
    chat_frame_size(dialog, false, false);
    return dialog;
};

function chat_frame_size(dialog, big, forced) {
    var newsize = (big ? 'big' : 'small');
    if(dialog.user_data['size'] === newsize) { return; }
    dialog.user_data['size'] = newsize;
    dialog.user_data['transition_start_time'] = client_time;

    for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
        var tab = dialog.widgets['tabs'+i];
        tab.widgets['output_bg'].show =
            tab.widgets['output'].show =
            tab.widgets['scroll_up'].show =
            tab.widgets['scroll_down'].show =
            dialog.widgets['tab_jewel'+i].show = (!!big);
    }

    for(var i = 0; i < dialog.data['widgets']['tab_button']['array'][0]; i++) {
        dialog.widgets['tab_button'+i.toString()].show = !!big && (i < dialog.user_data['channel_names'].length);
    }

    dialog.widgets['grow_up'].show = !big; dialog.widgets['grow_down'].show = !!big;
    dialog.widgets['all_jewel'].show = !big;

    dialog.widgets['input_bg'].show = dialog.widgets['input'].show = !!big;
    dialog.widgets['fullscreen_button'].show = !!big && has_true_fullscreen();

    if(big) {
        dialog.widgets['bg_frame'].fade_unless_hover =
            dialog.widgets['input_bg'].fade_unless_hover =
            dialog.widgets['input'].fade_unless_hover = false;
        dialog.widgets['grow_bg'].fade_unless_hover = false;
    } else {
        dialog.widgets['bg_frame'].fade_unless_hover = dialog.data['widgets']['bg_frame']['fade_unless_hover'];
        dialog.widgets['input_bg'].fade_unless_hover = dialog.data['widgets']['input_bg']['fade_unless_hover'];
        dialog.widgets['input'].fade_unless_hover = dialog.data['widgets']['input']['fade_unless_hover'];
        dialog.widgets['grow_bg'].fade_unless_hover = dialog.data['widgets']['grow_bg']['fade_unless_hover'];
    }
};

/** Warn player that they are sending a message that could get them violated.
 @return {boolean} if the warning was shown (rather than muted by player preference) */
function invoke_chat_filter_warning(cb) {
    // don't bother elder players (created before Jan 9, 2016)
    if(player.preferences['chat_filter_warning_seen'] ||
       player.creation_time < 1452328211 ||
       !gamedata['strings']['chat_filter_warning']) {
        return false;
    }
    var s = gamedata['strings']['chat_filter_warning'];
    var dialog = invoke_child_message_dialog(s['ui_title'],
                                             s['ui_description'],
                                             {'dialog': 'message_dialog_big',
                                              'use_bbcode': true,
                                              'ok_button_ui_name': s['ui_button'],
                                              'on_ok': cb
                                             });
    dialog.widgets['ignore_button'].show = true;
    dialog.widgets['ignore_button'].str = s['ui_ignore'];
    dialog.widgets['ignore_button'].onclick = function(w) {
        w.state = (w.state == 'active' ? 'normal' : 'active');
        player.preferences['chat_filter_warning_seen'] = (w.state == 'active' ? 1 : 0);
        send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
    };
    return true;
}

/** @constructor @struct
    @param {number} user_id of offender
    @param {string} channel in which offensive text was said
    @param {string} ui_name of the offender to show in the GUI
    @param {string} ui_context offensive txt string to show in the GUI
    @param {number} context_time - timestamp of the offensive text
    @param {string} message_id - unique database ID of the offensive text
*/
var AdvancedChatReportArgs = function(user_id, channel, ui_name, ui_context, context_time, message_id) {
    this.user_id = user_id;
    this.channel = channel;
    this.ui_name = ui_name;
    this.ui_context = ui_context;
    this.context_time = context_time;
    this.message_id = message_id;
};

/** @param {number} user_id
    @param {number} alliance_id
    @param {string} ui_name of the user to show in the GUI
    @param {AdvancedChatReportArgs|null} report_args
    @param {!Array.<number>} mloc */
function invoke_chat_player_context_menu(user_id, alliance_id, ui_name, report_args, mloc) {
    var buttons = [];
    buttons.push(new ContextMenuButton({ui_name: gamedata['dialogs']['chat_player_context_menu']['widgets']['button']['ui_name_player_info'],
                                        onclick: (function (_user_id) { return function(w) {
                                            close_parent_dialog(w); // change_selection_ui(null); safe?
                                            PlayerInfoDialog.invoke(_user_id);
                                        }; })(user_id)}));
    if(alliance_id > 0) {
        buttons.push(new ContextMenuButton({ui_name: gamedata['dialogs']['chat_player_context_menu']['widgets']['button']['ui_name_alliance_info'],
                                            onclick: (function (_alliance_id) { return function(w) {
                                                close_parent_dialog(w); // change_selection_ui(null); safe?
                                                invoke_alliance_info(_alliance_id);
                                            }; })(alliance_id)}));
    }

    if(user_id !== session.user_id) {
        if(player.has_blocked_user(user_id)) {
            buttons.push(new ContextMenuButton({ui_name: gamedata['dialogs']['chat_player_context_menu']['widgets']['button']['ui_name_unblock'],
                                                ui_tooltip: gamedata['dialogs']['chat_player_context_menu']['widgets']['button']['ui_tooltip_unblock'],
                                                onclick: (function (/** number */ _user_id, /** string */ _ui_name) { return function(w) {
                                                    close_parent_dialog(w);
                                                    player.unblock_user(_user_id);
                                                    var s = gamedata['strings']['chat_unblocked'];
                                                    invoke_child_message_dialog(s['ui_title'],
                                                                                s['ui_description'].replace('%target', SPText.bbcode_quote(_ui_name)),
                                                                                {'dialog': 'message_dialog_big',
                                                                                 'use_bbcode': true});
                                                }; })(user_id, ui_name)
                                               }));
        } else {
            buttons.push(new ContextMenuButton({ui_name: gamedata['dialogs']['chat_player_context_menu']['widgets']['button']['ui_name_block'],
                                                ui_tooltip: gamedata['dialogs']['chat_player_context_menu']['widgets']['button']['ui_tooltip_block'],
                                                onclick: (function (/** number */ _user_id, /** string */ _ui_name) { return function(w) {
                                                    close_parent_dialog(w);
                                                    player.block_user(_user_id);
                                                    var s = gamedata['strings']['chat_blocked'];
                                                    invoke_child_message_dialog(s['ui_title'],
                                                                                s['ui_description'].replace('%target', SPText.bbcode_quote(_ui_name)),
                                                                                {'dialog': 'message_dialog_big',
                                                                                 'use_bbcode': true});
                                                }; })(user_id, ui_name)
                                               }));
        }
    }

    if(player.has_advanced_chat_reporting() && report_args && report_args.ui_context &&
       report_args.user_id !== session.user_id && report_args.channel !== 'ALLIANCE') {
        if(player.has_blocked_user(user_id)) {
            buttons.push(new ContextMenuButton({ui_name: gamedata['dialogs']['chat_player_context_menu']['widgets']['button']['ui_name_report'],
                                                state: 'disabled', ui_tooltip: gamedata['dialogs']['chat_player_context_menu']['widgets']['button']['ui_tooltip_already_reported']}));
        } else {
            buttons.push(new ContextMenuButton({ui_name: gamedata['dialogs']['chat_player_context_menu']['widgets']['button']['ui_name_report'],
                                                ui_tooltip: gamedata['dialogs']['chat_player_context_menu']['widgets']['button']['ui_tooltip_report'],
                                                onclick: (function (/** !AdvancedChatReportArgs */ _report_args) { return function(w) {
                                                    close_parent_dialog(w); // change_selection_ui(null); safe?
                                                    invoke_advanced_chat_report_dialog(_report_args);
                                                }; })(report_args)
                                               }));
        }
    }

    var dialog = invoke_generic_context_menu(vec_add(mloc, [0, 8]), buttons, 'chat_player_context_menu');
    dialog.widgets['title'].str = ui_name;
    var name_wh = dialog.widgets['title'].font.measure_string(dialog.widgets['title'].str);
    // abbreviate the name if it overflows
    if(name_wh[0] > dialog.widgets['title'].wh[0]) {
        ui_name = ui_name.slice(0, dialog.data['widgets']['title']['max_chars']) + '...';
        dialog.widgets['title'].str = ui_name;
    }
    return dialog;
}

/** Go through the main "Report Abuse" dialog first, to show other options like "Report offensive alliance name."
    @param {!AdvancedChatReportArgs} args */
function invoke_advanced_chat_report_dialog(args) {
    invoke_report_abuse_dialog(args.user_id, args);
}

/** @param {!AdvancedChatReportArgs} args */
function do_invoke_advanced_chat_report_dialog(args) {
    var s = gamedata['strings']['report_confirm'];
    var ui_context_censored = ChatFilter.censor(args.ui_context);
    return invoke_child_message_dialog(s['ui_title'],
                                       s['ui_description'].replace('%target', args.ui_name).replace('%context', SPText.bbcode_quote(args.ui_context)),
                                       {'dialog': 'message_dialog_big',
                                        'use_bbcode': true,
                                        'cancel_button': true,
                                        'ok_button_ui_name': s['ui_button'],
                                        'on_ok': (function (_args) { return function() {
                                            send_to_server.func(["CHAT_REPORT2", _args.user_id, _args.channel, _args.context_time, _args.message_id]);
                                            player.block_user(_args.user_id);
                                            invoke_ui_locker(synchronizer.request_sync(), function() {
                                                change_selection(null);
                                                var report_sent = gamedata['strings']['report_sent'];
                                                invoke_message_dialog(report_sent['ui_title'], report_sent['ui_description'], {'dialog':'message_dialog_big'});
                                            });
                                        }; })(args)}
                                      );
}

/** @param {number} user_id
    @param {AdvancedChatReportArgs|null=} chat_report_args to hook up the "Report Chat Abuse" button
    if no chat_report_args are present, then just give the player instructions to use the chat window's report function. */
function invoke_report_abuse_dialog(user_id, chat_report_args) {
    var dialog_data = gamedata['dialogs']['report_abuse_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'report_abuse_dialog';
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    goog.array.forEach(['chat_abuse', 'hacking', 'alliance_abuse', 'alt_accounts', 'other'], function(reason) {
        // don't show alt-account info unless in a region
        if(reason == 'alt_accounts' && !session.region.map_enabled()) {
            dialog.widgets[reason+'_button'].show = false;
            return;
        }
        if(reason == 'chat_abuse' && chat_report_args) {
            dialog.widgets[reason+'_button'].onclick = (function (_chat_report_args) { return function(w) {
                close_parent_dialog(w);
                do_invoke_advanced_chat_report_dialog(/** @type {!AdvancedChatReportArgs} */ (_chat_report_args));
            }; })(chat_report_args);
        } else {
            dialog.widgets[reason+'_button'].onclick = (function (_reason) { return function(w) {
                var s = w.parent.data['widgets'][reason+'_button'];
                close_parent_dialog(w);
                invoke_child_message_dialog(s['ui_name'], s['ui_instructions'].replace('%user_id', user_id.toString()),
                                            {'dialog': 'message_dialog_big', 'use_bbcode': true});
            }; })(reason);
        }
    });
}

/** Scan the alliance chat tab for all help requests that we can respond to,
    and display a GUI message offering to do so.*/
function help_request_reminder() {
    if(!global_chat_frame || !('ALLIANCE' in global_chat_frame.user_data['channel_to_tab'])) { return; }
    var tab = global_chat_frame.widgets['tabs'+global_chat_frame.user_data['channel_to_tab']['ALLIANCE'].toString()];
    var req_list = [];
    for(var req_id in tab.user_data['help_requests']) {
        var req = tab.user_data['help_requests'][req_id];
        if(req['i_helped'] ||
           req['recipient_id'] == session.user_id ||
           req['expire_time'] < server_time ||
           req['cur_helpers'] >= req['max_helpers'] ||
           (req['region_id'] && !(session.region.data && session.region.data['id'] === req['region_id']))) {
               continue;
        }
        req_list.push(req);
    }
    if(req_list.length < 1) { return; }
    var s = gamedata['strings']['help_respond_all_prompt'];
    invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%d', pretty_print_number(req_list.length)),
                                {'dialog': 'message_dialog_big',
                                 'cancel_button': true,
                                 'ok_button_ui_name': s['ui_button'],
                                 'on_ok': (function (_req_list) { return function() {
                                     goog.array.forEach(_req_list, function(req) {
                                         send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "GIVE_ALLIANCE_HELP", req['recipient_id'], req['req_id']]);
                                         req['i_helped'] = true; // client-side predict
                                     });
                                 }; })(req_list)});
}

function invoke_damage_protection_notice() {
    var dsk = desktop_dialogs['aura_bar'];

    if(!player.get_any_abtest_value('enable_damage_protection_notice', gamedata['client']['enable_damage_protection_notice']) ||
       player.resource_state['protection_end_time'] < server_time ||
       !dsk || !dsk.widgets['aura_glow0'] ||
       dsk.widgets['aura_icon0'].asset != 'inventory_protection') {
        return;
    }

    dsk.user_data['protection_time_glow'] = 1;
    var stop_glowing = (function (_dsk) { return function() {
        _dsk.user_data['protection_time_glow'] = 0;
    }; })(dsk);

    var msg = gamedata['strings']['damage_protection_notice'];

    var dialog = invoke_message_dialog(msg['ui_title'], msg['ui_description'],
                                       {'dialog': msg['dialog'],
                                        'on_ok': stop_glowing
                                       });
    dialog.modal = 0.33; // make background less dark
    return dialog;
};

/** Base damage calculator. Follows the base_damage_skip_partial setting unless count_partial option overrides it.
 * @param {{detail:(boolean|undefined),
 *          count_partial:(boolean|undefined)}=} options
 */
function do_calc_base_damage(options) {
    var damaged_objects = {};
    var base_hp_total = 0, base_hp_max = 0.1, barriers_damaged = 0;
    session.for_each_real_object(function(obj) {
        if(obj.is_building()) {
            if(obj.spec['worth_less_xp']) {
                // handle barriers separately
                if(obj.is_damaged() && obj.spec['name'] == 'barrier') {
                    barriers_damaged += 1;
                }
            } else {
                base_hp_max += obj.max_hp;

                if(!obj.is_destroyed() && gamedata['base_damage_skip_partial'] && !(options && options.count_partial)) {
                    // do not count damage from partially-damaged-but-not-destroyed objects
                    base_hp_total += obj.max_hp;
                } else {
                    base_hp_total += obj.hp;
                }

                if(options && options.detail && obj.is_damaged()) {
                    damaged_objects[obj.id] = {'spec':obj.spec['name'], 'hp':obj.hp, 'max_hp':obj.max_hp};
                    if(obj.is_producer()) {
                        damaged_objects[obj.id]['repair_finish_time'] = obj.repair_finish_time;
                        damaged_objects[obj.id]['produce_rate'] = obj.produce_rate;
                        damaged_objects[obj.id]['contents'] = obj.contents;
                    }
                }
            }
        }
    });
    base_hp_total = Math.floor(base_hp_total);
    base_hp_max = Math.floor(base_hp_max);
    var base_damage = (base_hp_max - base_hp_total) / Math.max(1,base_hp_max);

    // increment so that the repair dialog will fire even if only barriers are damaged
    if(barriers_damaged > 0) { base_damage += 0.0001; }
    base_damage = Math.min(Math.max(base_damage, 0), 1);

    return [base_damage, damaged_objects];
};

/** @param {{detail:(boolean|undefined),
             count_partial:(boolean|undefined)}=} options */
function calc_base_damage(options) { return do_calc_base_damage(options)[0]; }

function invoke_you_were_attacked_dialog(recent_attacks) {
    if(recent_attacks.length < 1) { return; }
    change_selection(null);

    var dialog_data = gamedata['dialogs']['you_were_attacked_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'you_were_attacked_dialog';

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    if('close_button' in dialog.widgets) { dialog.widgets['close_button'].onclick = function() { change_selection(null); }; }
    if('screenshot_button' in dialog.widgets) {
        dialog.widgets['screenshot_button'].show = post_screenshot_enabled();
        dialog.widgets['screenshot_button'].onclick = function(w) {
            var dialog = w.parent;
            invoke_post_screenshot(dialog, /* reason = */ dialog.user_data['dialog'],
                                   make_post_screenshot_caption(dialog.data['widgets']['screenshot_button']['ui_caption'],
                                                                player.get_player_cache_props()),
                                  false);
        };
    }

    // calculate statistics
    var current_base_damage = calc_base_damage();
    var displayed_base_damage = current_base_damage;

    var lost_res = {}, lost_units = 0, killed_units = 0, killed_units_res = {}, bonus_xp = 0;
    var trophy_delta = 0;
    var last_attack_time = 0, last_attacker_name = '';
    var prot_expire_time = 0;
    var attacker_ids = {};
    var num_unique_attackers = 0;
    var row = 0; // friend icon

    var show_attrition = false;

    for(var i = 0; i < recent_attacks.length; i++) {
        var a = recent_attacks[i];
        lost_units += a['lost_units'];
        for(var res in gamedata['resources']) {
            if('lost_'+res in a) {
                lost_res[res] = (lost_res[res]||0) + a['lost_'+res];
            }
            if('killed_units_'+res in a) {
                killed_units_res[res] = (killed_units_res[res]||0) + a['killed_units_'+res];
                if(killed_units_res[res] > 0) {
                    show_attrition = true;
                }
            }
        }
        if('defender_protection_expired_at' in a) {
            prot_expire_time = Math.max(prot_expire_time, a['defender_protection_expired_at']);
        }
        if('killed_units' in a) { killed_units += a['killed_units']; }
        if('defender_xp' in a) { bonus_xp += a['defender_xp']; }
        if('viewing_trophies_pvp' in a) { trophy_delta += a['viewing_trophies_pvp']; }
        if('base_damage' in a && a['base_damage'] > displayed_base_damage) {
            displayed_base_damage = a['base_damage'];
        }
        if(last_attack_time < a['time']) {
            last_attack_time = a['time'];
            last_attacker_name = a['attacker_name'];
        }
        if(a['attacker_user_id'] in attacker_ids) {
            // not unique
            continue;
        }

        attacker_ids[a['attacker_user_id']] = 1;
        num_unique_attackers += 1;
        if(row < 3) {
            dialog.widgets['friend_icon'+row].set_user(a['attacker_user_id']);
            dialog.widgets['friend_icon'+row].set_user_level(a['attacker_level']);
            row += 1;
        }
    }

    // clear remaining friend icons
    while(row < 3) {
        dialog.widgets['friend_icon'+row].show = 0;
        row += 1;
    }

    dialog.widgets['base_damage'].str = Math.floor(100*displayed_base_damage).toFixed(0) + '%';

    var attack_time_str = dialog.data['widgets']['attack_time']['ui_name'].replace('%s', pretty_print_time_brief(server_time - last_attack_time));
    if(prot_expire_time > 0) {
        attack_time_str += dialog.data['widgets']['attack_time']['ui_name_prot'].replace('%prot', pretty_print_time_brief(server_time - prot_expire_time));
    }
    dialog.widgets['attack_time'].str = attack_time_str;

    var str = dialog.data['widgets']['attacked_by']['ui_name'+ (num_unique_attackers > 2 ? '_many_others': (num_unique_attackers > 1 ? '_one_other' : ''))];
    dialog.widgets['attacked_by'].str = str.replace('%s',last_attacker_name).replace('%d',(num_unique_attackers-1).toString());

    for(var res in gamedata['resources']) {
        if(res+'_amount' in dialog.widgets) {
            dialog.widgets[res+'_amount'].show = dialog.widgets[res+'_icon'].show = !!(lost_res[res]||0);
            dialog.widgets[res+'_icon'].asset = gamedata['resources'][res]['icon_small'];
            dialog.widgets[res+'_amount'].str = pretty_print_number(lost_res[res]||0);
        }
    }

    var outcome_win = 0, outcome_loss = 0, outcome_unknown = 0;
    goog.array.forEach(recent_attacks, function(a) {
        if(a['defender_outcome'] == 'victory') {
            outcome_win += 1;
        } else if(a['defender_outcome'] == 'defeat') {
            outcome_loss += 1;
        } else {
            outcome_unknown += 1;
        }
    });

    if(outcome_unknown == 0 && gamedata['common_win_condition'] == 'battle_stars') {
        dialog.widgets['you_endured'].str = dialog.data['widgets']['you_endured']['ui_name_winloss'].replace('%total', pretty_print_number(recent_attacks.length)).replace('%win', pretty_print_number(outcome_win)).replace('%loss', pretty_print_number(outcome_loss));
    } else {
        dialog.widgets['you_endured'].str = dialog.data['widgets']['you_endured']['ui_name_waves'].replace('%total', pretty_print_number(recent_attacks.length));
    }

    dialog.widgets['you_destroyed'].show = (killed_units>0);
    dialog.widgets['you_destroyed'].str = dialog.data['widgets']['you_destroyed']['ui_name'].replace('%d', pretty_print_number(killed_units));


    if(show_attrition) {
        var att_list = [];
        for(var res in gamedata['resources']) {
            if(killed_units_res[res]) {
                att_list.push(pretty_print_number(killed_units_res[res]) + ' ' + gamedata['resources'][res]['ui_name']);
            }
        }
        var att_str = att_list.join(', ');
        dialog.widgets['attrition'].str = dialog.data['widgets']['attrition']['ui_name'].replace('%COST', att_str);
    }

    dialog.widgets['attrition'].show = show_attrition;

    if(trophy_delta != 0) {
        dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_label'].show =
            dialog.widgets['trophy_sunken'].show =
            dialog.widgets['trophy_shine'].show =
            dialog.widgets['trophy_amount'].show = true;
        var sign = (trophy_delta > 0 ? 'plus' : 'minus');
        dialog.widgets['trophy_amount'].str = dialog.data['widgets']['trophy_amount']['ui_name_'+sign].replace('%d', pretty_print_number(Math.abs(trophy_delta)));
        dialog.widgets['trophy_amount'].text_color = SPUI.make_colorv(dialog.data['widgets']['trophy_amount']['text_color_'+sign]);
        dialog.widgets['trophy_label'].str = dialog.data['widgets']['trophy_label']['ui_name'].replace('%s', gamedata['events']['challenge_pvp_ladder']['ui_name']);
    }

    // check base for building action interrupts
    var interrupts = [];
    session.for_each_real_object(function(obj) {
        if(obj.is_building() && obj.team === 'player' && obj.is_damaged()) {
            if(obj.is_manufacturing() && obj.manuf_start_time <= 0) {
                interrupts.push(dialog.data['widgets']['halt_message']['ui_name_production'].replace('%s',obj.spec['ui_name']).replace('%INTERRUPTED',gamedata['spells']['MAKE_DROIDS']['ui_name_interrupted']));
            } else if(obj.is_researching() && obj.research_start_time <= 0) {
                interrupts.push(dialog.data['widgets']['halt_message']['ui_name_research'].replace('%s',obj.spec['ui_name']));
            } else if(obj.is_crafting()) {
                var craft_queue = obj.get_crafting_queue();
                for(var i = 0; i < craft_queue.length; i++) {
                    if(craft_queue[i]['start_time'] <= 0) {
                        var cat = gamedata['crafting']['categories'][gamedata['crafting']['recipes'][craft_queue[i]['craft']['recipe']]['crafting_category']];
                        if(('haltable' in cat) && !cat['haltable']) {
                            // not haltable
                        } else {
                            interrupts.push(dialog.data['widgets']['halt_message']['ui_name_crafting'].replace('%s',obj.spec['ui_name']));
                            break;
                        }
                    }
                }
            } else if(obj.is_upgrading() && obj.upgrade_start_time <= 0) {
                interrupts.push(dialog.data['widgets']['halt_message']['ui_name_upgrade'].replace('%s',obj.spec['ui_name']));
            } else if(obj.is_enhancing()) { // reuse upgrade text
                interrupts.push(dialog.data['widgets']['halt_message']['ui_name_upgrade'].replace('%s',obj.spec['ui_name']));
            }
        }
    });

    dialog.widgets['halt_bg'].show = dialog.widgets['halt_message'].show = (interrupts.length > 0);

    if(interrupts.length > 0) {
        dialog.widgets['halt_bg'].wh[1] = dialog.widgets['halt_message'].wh[1] = interrupts.length*(dialog.widgets['halt_message'].font.leading)+10;
        dialog.widgets['halt_message'].str = interrupts.join('\n');
    }

    init_dialog_repair_buttons(dialog, current_base_damage, true);

    notification_queue.push(invoke_damage_protection_notice);

    if(gamedata['client']['auto_show_battle_log']) {
        notification_queue.push(function() { invoke_battle_history_dialog(session.user_id, -1, session.alliance_id, '', -1); });
    }

    var most_recent_summary = recent_attacks[recent_attacks.length-1];

    // replay or show deployments
    // don't bother doing a round-trip to check for existence of replay - just assume it's there if the version
    // matches in the summary and the battle is fairly recent
    if(can_show_replay_for_battle_summary(most_recent_summary) && most_recent_summary['time'] >= server_time - 7*86400) {
        dialog.widgets['replay_button'].show = true;
        dialog.widgets['replay_button'].onclick = (function (_summary) { return function(w) {
            var dialog = w.parent;
            // XXX note: "recent attack" version of battle summary uses attacker_user_id not attacker_id,
            // and is missing defender_id

            var fail_cb = (function (_dialog) { return function() {
                _dialog.widgets['replay_button'].state = 'disabled';
                _dialog.widgets['replay_button'].tooltip.str = _dialog.data['widgets']['replay_button']['ui_tooltip_unavailable'];
            }; })(dialog);

            download_and_play_replay(_summary['time'], _summary['attacker_user_id'], session.user_id, _summary['base_id'], null, fail_cb);

        }; })(most_recent_summary);

    }
};

function test_you_were_attacked_dialog() {
    var at = {'defender_outcome': 'victory', 'lost_iron':100, 'lost_water':200, 'lost_units':5, 'defender_protection_expired_at':server_time-60, 'killed_units':5, 'killed_units_water':300, 'killed_units_iron':400, 'defender_xp': 123, 'time': server_time-30, 'attacker_name': 'FOO', 'attacker_user_id':1112, 'attacker_facebook_id':'example1', 'attacker_level':5, 'viewing_trophies_pvp':20};
    invoke_you_were_attacked_dialog([at,at]);
}

// hack - make sure repairs are only started once on login
var repairs_started = false;

function start_slow_repairs() {
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "REPAIR", session.viewing_base.base_id]);

    session.for_each_real_object(function(obj) {
        if(obj.is_building() && obj.is_damaged() && !obj.is_repairing()) {
            // client-side predict
            var health = (obj.hp) / (1.0*obj.max_hp);
            health = Math.max(0.0, Math.min(health, 1.0))
            var repair_time = Math.max(1, Math.floor((1.0-health)*(obj.get_leveled_quantity(obj.spec['repair_time'])/obj.get_stat('repair_speed',1))))
            obj.repair_finish_time = server_time + repair_time;
            obj.update_all_actions(server_time);
        }
    });

    if(('enable_defending_units' in gamedata) && !gamedata['enable_defending_units']) {
        // also check army for repair candidates
        for(var id in player.my_army) {
            var unit = player.my_army[id];
            if((unit['squad_id']||0) == SQUAD_IDS.BASE_DEFENDERS) {
                var curmax = army_unit_hp(unit);
                if(curmax[0]<curmax[1] && !army_unit_is_under_repair(unit['obj_id']) && player.can_repair_unit_of_spec(gamedata['units'][unit['spec']], curmax[0])) {
                    send_to_server.func(["UNIT_REPAIR_QUEUE", unit['obj_id']]);
                }
            }
        }
        unit_repair_sync_marker = synchronizer.request_sync();
    }
}

function confirm_instant_repairs(price, ok_cb) {
    var dialog_data = gamedata['dialogs']['instant_repair_confirm_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var default_button_name = player.get_any_abtest_value('confirm_instant_repairs_default_button', gamedata['client']['confirm_instant_repairs_default_button'] || "close_button");
    if(!(default_button_name in dialog.widgets)) { throw Error('bad default_button_name '+default_button_name); }
    dialog.default_button = dialog.widgets[default_button_name];

    dialog.widgets['description'].set_text_with_linebreaking(dialog.data['widgets']['description']['ui_name'].replace('%GAMEBUCKS', Store.gamebucks_ui_name()));
    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
    dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);
    dialog.widgets['price_display'].onclick =
        dialog.widgets['ok_button'].onclick = (function (_ok_cb) { return function(w) { close_parent_dialog(w); _ok_cb(); }; })(ok_cb);
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    return dialog;
}

/** @param {function()} cb to call once order is submitted
    @return {boolean} whether repairs actually took place (may be cancelled if insufficient funds) */
function do_instant_repairs(cb) {
    return Store.place_user_currency_order(GameObject.VIRTUAL_ID, "REPAIR_ALL_FOR_MONEY",
                                           session.viewing_base.base_id,
                                           (function (_cb) { return function() {
                                               session.for_each_real_object(function(obj) {
                                                   if(obj.is_building() && obj.is_damaged()) {
                                                       if(obj.is_destroyed()) { // reblock
                                                           obj.block_map(1, 'REPAIR_ALL_FOR_MONEY predict');
                                                       }
                                                       obj.hp = obj.max_hp; obj.repair_finish_time = -1; // client-side predict
                                                       obj.update_all_actions(server_time);
                                                   }
                                               });
                                               _cb();
                                           }; })(cb)
                                          );
}


/** Set up the instant/slow repair buttons and price display.
    Shared functionality for several different dialogs.
    @param {!SPUI.Dialog} dialog
    @param {number} base_damage
    @param {boolean} enable_confirm - if true, enable the "are you sure?" confirmation */
function init_dialog_repair_buttons(dialog, base_damage, enable_confirm) {
    var cost_res = {};
    var do_units = true;
    var any_unit_damage = false;

    if(do_units) {
        session.for_each_real_object(function(obj) {
            if(obj.team === 'player' && obj.is_mobile() && obj.is_damaged() && !obj.is_under_repair() && player.can_repair_unit(obj)) {
                any_unit_damage = true;
                var obj_cost = obj.cost_to_repair(player);
                for(var res in obj_cost) {
                    if(res == 'time' || obj_cost[res] == 0) { continue; }
                    cost_res[res] = (cost_res[res]||0) + obj_cost[res];
                }
            }
        });
        if(('enable_defending_units' in gamedata) && !gamedata['enable_defending_units']) {
            // also check army for repair candidates
            for(var id in player.my_army) {
                var unit = player.my_army[id];
                if((unit['squad_id']||0) == SQUAD_IDS.BASE_DEFENDERS) {
                    var curmax = army_unit_hp(unit);
                    if(curmax[0]<curmax[1] && !army_unit_is_under_repair(unit['obj_id']) && player.can_repair_unit_of_spec(gamedata['units'][unit['spec']], curmax[0])) {
                        any_unit_damage = true;
                        var obj_cost = mobile_cost_to_repair(gamedata['units'][unit['spec']], unit['level']||1, curmax[0], curmax[1], player);
                        for(var res in obj_cost) {
                            if(res == 'time' || obj_cost[res] == 0) { continue; }
                            cost_res[res] = (cost_res[res]||0) + obj_cost[res];
                        }
                    }
                }
            }
        }
    }
    dialog.user_data['repair_cost_res'] = cost_res;

    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();

    if(base_damage > 0 || (player.unit_speedups_enabled() && any_unit_damage)) { // also check for unit repair cost?
        var instant_price = Store.get_user_currency_price(GameObject.VIRTUAL_ID, gamedata['spells']['REPAIR_ALL_FOR_MONEY'], session.viewing_base.base_id);
        dialog.widgets['price_display'].str = Store.display_user_currency_price(instant_price); // PRICE
        dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(instant_price);

        if(instant_price < 1) {
            dialog.widgets['price_display'].onclick =
                dialog.widgets['repair_instant_button'].onclick = function(w) {
                    // manually send REPAIR followed by SPEEDUP_FOR_FREE on each damaged building
                    close_parent_dialog(w);
                    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "REPAIR", session.viewing_base.base_id]);

                    session.for_each_real_object(function(obj) {
                        if(obj.is_building() && obj.is_damaged()) {
                            send_to_server.func(["CAST_SPELL", obj.id, "SPEEDUP_FOR_FREE"]);
                            if(obj.is_destroyed()) { // reblock
                                obj.block_map(1, 'REPAIR/SPEEDUP_FOR_FREE predict');
                            }
                            obj.hp = obj.max_hp; obj.repair_finish_time = -1; // client-side predict
                            obj.update_all_actions(server_time);
                        }
                    });

                    // no such thing as free unit repairs
                    //send_to_server.func(["UNIT_REPAIR_SPEEDUP_FOR_FREE"]);
                };
        } else {
            var begin = (function (_dialog) { return function() {
                var on_start = (function (__dialog) { return function() {
                    __dialog.widgets['repair_instant_button'].str = __dialog.data['widgets']['repair_instant_button']['ui_name_pending'];
                    __dialog.widgets['repair_instant_button'].state = 'disabled'; __dialog.widgets['price_display'].onclick = null;
                }; })(_dialog);
                var on_complete = (function (__dialog) { return function() { close_dialog(__dialog); }; })(_dialog);
                if(do_instant_repairs(on_complete)) {
                    on_start();
                }
            }; })(dialog);

            var do_confirm = enable_confirm && player.get_any_abtest_value('confirm_instant_repairs', gamedata['client']['confirm_instant_repairs']);

            dialog.widgets['price_display'].onclick =
                dialog.widgets['repair_instant_button'].onclick = (do_confirm ? (function (_instant_price, _begin) { return function(w) {
                    confirm_instant_repairs(_instant_price, _begin);
                }; })(instant_price, begin) : begin);
        }

        dialog.widgets['repair_slow_button'].onclick = function(w) {
            close_parent_dialog(w);
            start_slow_repairs();
        };

        if(!session.enable_progress_timers) {
            // prevent player from seeing for-pay options, force "slow" path
            dialog.widgets['repair_instant_button'].show =
                dialog.widgets['price_display'].show = false;
            dialog.widgets['repair_slow_button'].state = 'active';
            dialog.default_button = dialog.widgets['repair_slow_button'];
        }

    } else {
        // base is not damaged
        dialog.widgets['price_display'].show =
        dialog.widgets['repair_slow_button'].show =
            dialog.widgets['repair_instant_button'].show = false;
        dialog.widgets['repair_not_necessary_button'].show = true;
        dialog.widgets['repair_not_necessary_button'].onclick = (any_unit_damage ? function(w) {
            close_parent_dialog(w);
            start_slow_repairs();
        } : close_parent_dialog);
        dialog.default_button = dialog.widgets['repair_not_necessary_button'];
    }
};

function do_invoke_repair_dialog() {
    var dialog_data = gamedata['dialogs']['repair_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'repair_dialog';
    dialog.modal = true;
    init_dialog_repair_buttons(dialog, calc_base_damage({count_partial:true}), false);
    // count # of things needing repair, for UI only
    var buildings = 0, units = 0, barriers = 0, beyond_tech = 0, beyond_tech_types = {};
    session.for_each_real_object(function(obj) {
        if(obj.team === 'player' && obj.is_damaged()) {
            if(obj.is_building()) {
                if(obj.spec['name'] == 'barrier') {
                    barriers += 1;
                } else {
                    buildings += 1;
                }
            } else if(obj.is_mobile()) {
                if(player.can_repair_unit(obj)) {
                    units += 1;
                } else {
                    beyond_tech += 1;
                    if(!(obj.spec['name'] in beyond_tech_types)) {
                        beyond_tech_types[obj.spec['name']] = 0;
                    }
                    beyond_tech_types[obj.spec['name']] += 1;
                }
            }
        }
    });

    if(('enable_defending_units' in gamedata) && !gamedata['enable_defending_units']) {
        // also check army for repair candidates
        for(var id in player.my_army) {
            var unit = player.my_army[id];
            if((unit['squad_id']||0) == SQUAD_IDS.BASE_DEFENDERS) {
                var curmax = army_unit_hp(unit);
                if(curmax[0]<curmax[1] && !army_unit_is_under_repair(unit['obj_id']) && player.can_repair_unit_of_spec(gamedata['units'][unit['spec']], curmax[0])) {
                    units += 1;
                }
            }
        }
    }

    var txt = '';
    if(buildings > 0) {
        txt += buildings.toString()+' '+gamedata['strings']['object_kinds']['buildings'][((buildings!=1)?'plural':'singular')].toLowerCase();
    }

    if(barriers > 0) {
        if(txt.length > 0) { txt += ', '; }
        txt += barriers.toString()+' '+gamedata['buildings']['barrier']['ui_name'+((barriers!=1)?'_plural':'')].toLowerCase();
    }

    var do_units = true;
    if(do_units && units > 0 && !session.is_quarry()) {
        if(txt.length > 0) { txt += ', '; }
        txt += units.toString()+' '+gamedata['strings']['object_kinds']['units'][((units!=1)?'plural':'singular')].toLowerCase();
    }

    var extra = '';
    if(beyond_tech > 0) {
        extra += '\n\n'+beyond_tech.toString()+' '+gamedata['strings']['object_kinds']['units'][((beyond_tech!=1)?'plural':'singular')].toLowerCase();
        extra += ' '+dialog.data['widgets']['description']['ui_name_need_research_'+((beyond_tech>1)?'many':'one')];

        var typelist = [];
        for(var specname in beyond_tech_types) {
            typelist.push(beyond_tech_types[specname].toString()+'x '+gamedata['units'][specname]['ui_name']);
        }
        extra += ' ('+typelist.join(', ')+')';
    }

    if(goog.object.getCount(dialog.user_data['repair_cost_res']) > 0) {
        extra += '\n\n';
        var ls = [];
        for(var res in dialog.user_data['repair_cost_res']) {
            if(dialog.user_data['repair_cost_res'][res] > 0) {
                ls.push(pretty_print_number(dialog.user_data['repair_cost_res'][res]) + ' ' + gamedata['resources'][res]['ui_name']);
            }
        }
        extra += dialog.data['widgets']['description']['ui_name_resources'].replace('%s', ls.join(', '));
    }

    dialog.widgets['description'].set_text_with_linebreaking(dialog.data['widgets']['description']['ui_name'].replace('%s', txt).replace('%extra',extra));
    return dialog;
};

function invoke_repair_dialog() {
    if(!session.enable_progress_timers) {
        // in "conceal timers" mode, just skip this dialog entirely
        start_slow_repairs();
        return null;
    }

    change_selection(null);
    var dialog = do_invoke_repair_dialog();
    change_selection_ui(dialog);
    dialog.auto_center();
    return dialog;
};

function invoke_repair_dialog_conditional() {
    var needs_rep = false;

    if(!repairs_started) {
        if(session.for_each_real_object(function(obj) {
            if(obj.team === 'player' && obj.is_building() && obj.is_damaged() && (session.is_quarry() || !obj.is_repairing())) {
                return true;
            }
            if(obj.is_mobile() && obj.is_damaged() && !obj.is_under_repair() && obj.team === 'player' && !session.is_quarry() && player.can_repair_unit(obj)) {
                return true;
            }
        })) {
            needs_rep = true;
        }
        if(('enable_defending_units' in gamedata) && !gamedata['enable_defending_units']) {
            // also check army for repair candidates
            for(var id in player.my_army) {
                var unit = player.my_army[id];
                if((unit['squad_id']||0) == SQUAD_IDS.BASE_DEFENDERS) {
                    var curmax = army_unit_hp(unit);
                    if(curmax[0]<curmax[1] && !army_unit_is_under_repair(unit['obj_id']) && player.can_repair_unit_of_spec(gamedata['units'][unit['spec']], curmax[0])) {
                        needs_rep = true;
                        break;
                    }
                }
            }
        }
    }
    if(needs_rep) {
        invoke_repair_dialog();
    }
};

function invoke_child_repair_dialog() {
    if(!selection.ui) {
        return invoke_repair_dialog();
    }
    var dialog = do_invoke_repair_dialog();
    install_child_dialog(dialog);
    dialog.auto_center();
    //dialog.xy[0] = Math.floor((selection.ui.wh[0]-dialog.wh[0])/2);
    ///dialog.xy[1] = Math.floor((selection.ui.wh[1]-dialog.wh[1])/2);
    //selection.ui.add(dialog);
    //var closure = function(w) { var dialog = w.parent; if(dialog && dialog.parent) { dialog.parent.remove(dialog); } };
    return dialog;
};

function invoke_recycle_dialog(obj) {
    // NOTE! with squads, or no defending units, "obj" will be the entry in player.my_army, NOT a GameObject
    var dialog = new SPUI.Dialog(gamedata['dialogs']['recycle_message']);
    dialog.user_data['dialog'] = 'recycle_message';
    dialog.user_data['is_army'] = (player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units']));

    dialog.modal = true;
    if(selection.ui) {
        selection.ui.add(dialog);
        dialog.xy[0] = Math.floor((selection.ui.wh[0]-dialog.wh[0])/2);
        dialog.xy[1] = Math.floor((selection.ui.wh[1]-dialog.wh[1])/2);
    } else {
        change_selection_ui(dialog);
        dialog.auto_center();
    }

    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['ok_button'].onclick = (function(_obj) { return function(w) {
        var dialog = w.parent;
        close_parent_dialog(w);
        if(dialog.user_data['is_army']) {
            if(_obj['obj_id'] in player.my_army) {
                send_to_server.func(["RECYCLE_UNIT", _obj['obj_id']]);
                // snoop update into my_army
                player.army_unit_drop(_obj['obj_id']);
                if(session.get_real_world().objects.has_object(_obj['obj_id'])) {
                    session.get_real_world().objects.rem_object(session.get_real_world().objects.get_object(_obj['obj_id']));
                }
                session.clear_building_idle_state_caches();
            }
        } else {
            if(_obj.id && _obj.id !== GameObject.DEAD_ID) { // check obj.id rather than is_destroyed() because you CAN recycle destroyed (hp=0) units
                send_to_server.func(["RECYCLE_UNIT", _obj.id]);
                unit_repair_sync_marker = synchronizer.request_sync();
                // snoop update into my_army
                player.army_unit_drop(_obj.id);
                if(session.get_real_world().objects.has_object(_obj.id)) {
                    session.get_real_world().objects.rem_object(_obj);
                }
                session.clear_building_idle_state_caches();
            }
        }
    }; })(obj);

    var spec, level, hp, max_hp;
    if(dialog.user_data['is_army']) {
        spec = gamedata['units'][obj['spec']]; level = obj['level'] || 1;
        var cur_max = army_unit_hp(obj); hp = cur_max[0]; max_hp = cur_max[1];
    } else {
        spec = obj.spec; level = obj.level; hp = obj.hp; max_hp = obj.max_hp;
    }

    dialog.widgets['title'].str = gamedata['spells']['RECYCLE_UNIT']['ui_prompt'].replace('%d', spec['ui_name']).replace('%level', pretty_print_number(level));
    dialog.widgets['ok_button'].str = gamedata['spells']['RECYCLE_UNIT']['ui_name'];
    dialog.widgets['tip_text'].str = dialog.data['widgets']['tip_text']['ui_name'].replace('%s', gamedata['spells']['RECYCLE_UNIT']['ui_name']);

    // compute and display refund amounts
    var cost = mobile_cost_to_repair(spec, level, max_hp - hp, max_hp, player, COST_MODE.RECYCLE, null);
    for(var res in gamedata['resources']) {
        if('resource_bar_'+res+'_amount' in dialog.widgets) {
            dialog.widgets['resource_bar_'+res+'_amount'].str = pretty_print_number(cost[res]);
        }
    }
    return dialog;
};

/** invoke the "Buy Resources" dialog
 * @param {Object} amounts - dictionary of {res:amount}
 * @param {?} continuation - optional callback to call after the purchase
 */
function invoke_buy_resources_dialog(amounts, continuation) {
    if(!('BUY_RESOURCES_TOPUP' in gamedata['spells'])) {
        throw Error('game has no BUY_RESOURCES_TOPUP spell');
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['buy_resources_dialog']);
    dialog.user_data['dialog'] = 'buy_resources_dialog';
    dialog.user_data['amounts'] = amounts;
    dialog.user_data['continuation'] = (continuation || null);
    dialog.modal = true;
    install_child_dialog(dialog);
    dialog.auto_center();

    dialog.widgets['close_button'].onclick = close_parent_dialog;

    var n_resources = 0;
    for(var res in gamedata['resources']) {
        var cost = amounts[res] || 0;
        if('resource_bar_'+res+'_amount' in dialog.widgets) {
            dialog.widgets['resource_bar_'+res+'_amount'].str = pretty_print_number(cost);
        }
        if(cost > 0) { n_resources++; }
    }

    // piece together the GUI sentence
    var ui_res = dialog.data['widgets']['description']['ui_name_res'+n_resources.toString()];
    var n = 0;
    for(var res in gamedata['resources']) {
        var cost = amounts[res] || 0;
        if(cost > 0) {
            ui_res = ui_res.replace('%d'+n.toString(), pretty_print_number(cost)).replace('%s'+n.toString(), gamedata['resources'][res]['ui_name']);
            n += 1;
        }
    }

    var price = Store.get_user_currency_price(GameObject.VIRTUAL_ID, gamedata['spells']['BUY_RESOURCES_TOPUP'], dialog.user_data['amounts']);

    dialog.widgets['description'].set_text_with_linebreaking(ui_res.replace('%GAMEBUCKS_QTY', Store.display_user_currency_price(price)).replace('%GAMEBUCKS_NAME', Store.gamebucks_ui_name()));

    var closure = function(w) {
        var dialog = w.parent;
        if(Store.place_user_currency_order(GameObject.VIRTUAL_ID, "BUY_RESOURCES_TOPUP", dialog.user_data['amounts'],
                                           (function (_dialog) { return function() {
                                               var cb = _dialog.user_data['continuation'] || null;
                                               close_dialog(_dialog);
                                               if(cb) { cb(); }
                                           }; })(dialog)
                                          )) {
            if(true && dialog.user_data['continuation']) {
                var cb = dialog.user_data['continuation'];
                dialog.user_data['continuation'] = null;
                cb();
            } else {
                invoke_ui_locker();
            }
            dialog.widgets['ok_button'].str = dialog.data['widgets']['ok_button']['ui_name_pending'];
            dialog.widgets['ok_button'].state = 'disabled';
            dialog.widgets['price_display'].onclick = null;
        }

        if(gamedata['client']['log_insufficient_resources']) {
            metric_event('5203_insufficient_resources_topup_buy_now', {});
        }
    }

    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
    dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);

    dialog.widgets['ok_button'].onclick =
        dialog.widgets['price_display'].onclick = closure;

    if(gamedata['client']['log_insufficient_resources']) {
        metric_event('5202_insufficient_resources_topup_dialog', {});
    }

    return dialog;
};

function invoke_idle_check_dialog(request) {
    var ui_question = request['ui_question'];
    var tag = request['tag'];

    var dialog = new SPUI.Dialog(gamedata['dialogs']['icheck_dialog']);
    dialog.user_data['dialog'] = 'icheck_dialog';
    dialog.user_data['tag'] = tag;
    dialog.user_data['pending'] = false;
    change_selection_ui(dialog);
    dialog.modal = true;
    dialog.auto_center();

    // randomize position
    dialog.xy[0] += Math.floor(Math.random()*200-100);
    dialog.xy[1] += Math.floor(Math.random()*200-100);

    dialog.widgets['ok_button'].onclick = dialog.widgets['input'].ontextready = function(w) {
        var dialog = w.parent;
        var response = dialog.widgets['input'].str;
        if(!dialog.user_data['pending'] && response) {
            dialog.user_data['pending'] = true;
            send_to_server.func(["IDLE_CHECK_RESPONSE", {'tag': dialog.user_data['tag'], 'answer': response}])
            close_parent_dialog(w);
        }
    };

    var str = dialog.data['widgets']['description']['ui_name'].replace('%s', ui_question);
    dialog.widgets['description'].set_text_with_linebreaking(str);
    dialog.ondraw = update_idle_check_dialog;
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_idle_check_dialog(dialog) {
    dialog.widgets['ok_button'].state = (dialog.widgets['input'].str ? 'normal' : 'disabled');
}

/** @type {!Array.< {user_id: number, info: Object, loot: Object} >} */
var gift_received_list = [];

function gift_received(user_id, info, loot) {
    if(gamedata['client']['collapse_received_gifts']) {
        gift_received_list.push({user_id: user_id, info: info, loot: loot});
        if(gift_received_list.length == 1) {
            notification_queue.push(function() { invoke_gift_received_dialog(null); });
        }
    } else {
        var ls = [{user_id: user_id, info:info, loot:loot}];
        notification_queue.push((function (_ls) { return function() { invoke_gift_received_dialog(_ls); }; })(ls));
    }
}

function invoke_gift_received_dialog(override_ls) {
    var ls;
    if(override_ls !== null) { // use passed list
        ls = override_ls;
    } else { // grab global list
        ls = gift_received_list;
        gift_received_list = [];
    }

    if(ls.length < 1 ||
       !player.resource_gifts_enabled()) {
        // note: do not show dialog if gifting is turned off
        return;
    }

    change_selection(null);

    var dialog_data = gamedata['dialogs']['gift_received_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'gift_received_dialog';

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['close_button'].onclick = close_parent_dialog;

    // sort gifts by amount
    ls.sort(function(a, b) {
        var a_amt = Math.max.apply(Math, goog.object.getValues(a.loot)),
            b_amt = Math.max.apply(Math, goog.object.getValues(b.loot));
        if(a_amt > b_amt) {
            return -1;
        } else if(a_amt < b_amt) {
            return 1;
        } else {
            return 0;
        }
    });

    if(ls.length > 1) {
        dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name_plural'];
        dialog.widgets['and_others'].show = true;
        dialog.widgets['and_others'].str = dialog.data['widgets']['and_others']['ui_name'].replace('%d', pretty_print_number(ls.length-1));
    }

    // display loot
    var loot_i = 0;
    var total_loot = {};
    goog.array.forEach(ls, function(gift) {
        goog.object.extend(total_loot, gift.loot);
    });

    for(var res in gamedata['resources']) {
        if(res in total_loot && total_loot[res] > 0) {
            dialog.widgets['resource_icon'+loot_i.toString()].show =
                dialog.widgets['resource_amount'+loot_i.toString()].show = true;
            dialog.widgets['resource_icon'+loot_i.toString()].asset = gamedata['resources'][res]['icon_small'];
            dialog.widgets['resource_amount'+loot_i.toString()].str = pretty_print_number(total_loot[res]);
            loot_i += 1;
            if(loot_i >= dialog.data['widgets']['resource_icon']['array'][1]) { console.log('not enough resource widgets'); break; }
        }
    }
    if(loot_i == 1) {
        dialog.widgets['resource_icon0'].xy = dialog.data['widgets']['resource_icon']['xy_single'];
        dialog.widgets['resource_amount0'].xy = dialog.data['widgets']['resource_amount']['xy_single'];

    }

    // pick one sender to show friend and "say thanks" option
    var sender_user_id = ls[0].user_id;
    dialog.widgets['friend_icon'].set_user(ls[0].user_id);
    var info = ls[0].info;
    var sender_fbid = (info && info['facebook_id'] ? info['facebook_id'] : null);

    var sender_name;
    if(info) {
        if(info['facebook_name']) {
            sender_name = info['facebook_name'];
        } else {
            sender_name = PlayerCache.get_ui_name(info);
        }
    } else {
        sender_name = 'Unknown';
    }

    if(get_facebook_viral('say_thanks')) {
        dialog.widgets['say_thanks_button'].onclick = (function (_sender_name, _loot) { return function() {
            change_selection(null);
            invoke_say_thanks(_sender_name, _loot);
        }; })(sender_name, ls[0].loot);
    } else {
        dialog.widgets['say_thanks_button'].show = false;
    }

    dialog.widgets['send_button'].show = player.resource_gifts_enabled();
    dialog.widgets['send_button'].onclick = function() {
        change_selection(null);
        invoke_send_gifts(null, 'gift_received_dialog');
    };
};

function invoke_say_thanks(recipient_ui_name, loot) {
    var viral = get_facebook_viral('say_thanks');
    if(!viral) { return; }
    var loot_text = '';
    for(var res in gamedata['resources']) {
        if((res in loot) && loot[res] > 0) {
            loot_text += pretty_print_number(loot[res])+' '+gamedata['resources'][res]['ui_name'];
        }
    }
    if(loot_text === '') {
        loot_text += viral['ui_generic_loot'];
    }

    FBShare.invoke({name:viral['ui_post_headline'].replace('%LOOT', loot_text).replace('%THANKEE', recipient_ui_name),
                    description:viral['ui_post_description'].replace('%LOOT', loot_text).replace('%THANKEE', recipient_ui_name),
                    picture: gamedata['virals']['common_image_path'] + (('image' in viral) ? viral['image'] : gamedata['virals']['default_image']),
                    ref:'feed_thanks'});
};

// to stop the flashing "+Add" buttons
var invite_friends_dialog_shown_this_session = false;

function invoke_invite_friends_dialog(reason) {
    invite_friends_dialog_shown_this_session = true;

    if(spin_frame_platform == 'kg') {
        if(!spin_kongregate_enabled) { console.log('invoke_invite_friends_dialog('+reason+')'); return; }
        SPKongregate.showInvitationBox({'content': gamedata['virals']['invite_friends']['ui_post_message'],
                                        'filter': 'not_played',
                                        'kv_params': {'kv_spin_referer': session.user_id}});
    } else if(spin_frame_platform == 'fb') {
        if(!spin_facebook_enabled) { console.log('invoke_invite_friends_dialog('+reason+')'); return; }
        var direct_share = true; // as of April 2018, only this method works
        if(direct_share) {
            change_selection(null);
            invoke_invite_friends_dialog_fb_alternative(reason);
        } else {
            call_with_facebook_permissions('user_friends', (function (_reason) { return function() {
                FBInviteFriends.invoke_fb_invite_friends_dialog(reason);
            }; })(reason));
        }
    } else if(spin_frame_platform == 'bh') {
        if(!spin_battlehouse_enabled) { console.log('invoke_invite_friends_dialog('+reason+')'); return; }

        BHInvites.invoke_invite_friends_dialog(reason);

    } else {
        throw Error('unhandled frame_platform '+spin_frame_platform);
    }
}

// April 2018 update: Facebook has removed the API supporting the invitable_friends system
// this alternative offers to make a post to your News Feed instead.
function invoke_invite_friends_dialog_fb_alternative(reason) {
    invite_friends_dialog_shown_this_session = true; // stop the "+Add" button flashing
    metric_event('7103_invite_friends_fb_prompt', {'sum': player.get_denormalized_summary_props('brief'), 'method': 'share_invite'});
    FBShare.invoke({name: gamedata['virals']['invite_friends']['ui_post_message'],
                    description: gamedata['virals']['ui_post_description'],
                    link_qs: {'spin_campaign': 'share_invite'},
                    ref: 'share_invite'});
}

/** Check if screenshot posting is available
    @return {boolean} */
function post_screenshot_enabled() {
    if(spin_demographics['browser_name'] == "Chrome" && spin_demographics['browser_version'] < 17) { return false; }
    if(spin_demographics['browser_name'] == "Explorer" && spin_demographics['browser_version'] < 10) { return false; }
    if(spin_demographics['browser_name'] == "Firefox" && spin_demographics['browser_version'] < 9) { return false; }
    if(spin_frame_platform.indexOf('electron_') === 0) { return false; } // Electron clients never post screenshots

    return player.get_any_abtest_value('enable_post_screenshot', gamedata['client']['enable_post_screenshot']) &&
        (player.tutorial_state == 'COMPLETE') &&
        (spin_frame_platform == 'fb') && FBUploadPhoto.supported() && Screenshot.supported() &&
        !!gamedata['virals']['post_screenshot'] && !!gamedata['strings']['post_screenshot_success'];
}

/** Fill in the %PLAYER replacement in the default caption.
    @param {string} caption
    @param {Object|null} info - player cache entry
    @return {string|null} */
function make_post_screenshot_caption(caption, info) {
    if(!caption || !info) { return null; }
    var ui_player = PlayerCache.get_ui_name(info);
    if('alliance_id' in info && info['alliance_id'] >= 0) {
        var alinfo = AllianceCache.query_info_sync(info['alliance_id']);
        if(alinfo && alinfo['chat_tag']) {
            ui_player += ' ['+alinfo['chat_tag']+']';
        }
    }
    if('player_level' in info) {
        ui_player += ' L'+info['player_level'].toString();
    }
    caption = caption.replace('%PLAYER', ui_player);
    return caption;
}

/** Outer screenshot function. Ensure screenshot feature is available before calling.
    @param {SPUI.Dialog|null} dialog to capture - otherwise captures full screen
    @param {string} reason
    @param {string|null=} caption_prefix
    @param {boolean=} add_watermark
*/
function invoke_post_screenshot(dialog, reason, caption_prefix, add_watermark) {
    if(!canvas) { throw Error('no canvas'); }
    var codec = Screenshot.Codec.JPEG;
    var filename = 'SCREENSHOT.jpg';
    if(!caption_prefix) { caption_prefix = null; }

    /** @type {Screenshot.Watermark|null} */
    var watermark = null;
    if(add_watermark || (typeof(add_watermark) === 'undefined')) {
        var wm = gamedata['virals']['post_screenshot']['ui_watermark'];
        wm = wm.replace('%GAME_NAME', gamedata['strings']['game_name']);
        wm = wm.replace('%GAME_WWW_URL', gamedata['strings']['game_www_url']);
        wm = wm.replace('%CAPTION', caption_prefix);
        wm = goog.string.trim(wm);
        watermark = new Screenshot.Watermark(wm);
    }

    var dataURI;
    if(dialog) {
        var abs_xy = dialog.get_absolute_xy();
        var clip_to;
        if(dialog.data['screenshot_clip_to']) {
            clip_to = [dialog.data['screenshot_clip_to'][0] + abs_xy[0],
                       dialog.data['screenshot_clip_to'][1] + abs_xy[1],
                       dialog.data['screenshot_clip_to'][2],
                       dialog.data['screenshot_clip_to'][3]];
        } else {
            clip_to = [abs_xy[0], abs_xy[1], dialog.wh[0], dialog.wh[1]];
        }
        var topleft = vec_scale(canvas_oversample, [clip_to[0], clip_to[1]]);
        var dimensions = vec_scale(canvas_oversample, [clip_to[2], clip_to[3]]);
        dataURI = Screenshot.capture_subimage(canvas, topleft, dimensions, codec, watermark);
    } else {
        dataURI = Screenshot.capture_full(canvas, codec, watermark);
    }

    if(dataURI === null) {
        var s = gamedata['errors']['SCREENSHOT_FAILED'];
        invoke_child_message_dialog(s['ui_title'], s['ui_name'], {'dialog': 'message_dialog_big'});
        return;
    }

    invoke_post_screenshot_dialog(dataURI, filename, reason, caption_prefix);
}

/** Show the preview/caption GUI
    @param {string} data
    @param {string} filename
    @param {string} reason
    @param {string|null} caption_prefix
*/
function invoke_post_screenshot_dialog(data, filename, reason, caption_prefix) {
    var dialog_data = gamedata['dialogs']['post_screenshot_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'post_screenshot_dialog';
    dialog.user_data['image_data'] = data;
    dialog.user_data['image_filename'] = filename;
    dialog.user_data['reason'] = reason;
    dialog.user_data['caption_prefix'] = ''; // disabled due to FB no-pre-fill policy caption_prefix;
    dialog.user_data['privacy'] = player.preferences['fb_post_privacy'] || FBUploadPhoto.Privacy.EVERYONE;
    dialog.user_data['ui_locker'] = null;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var img = new Image();
    img.src = data;
    dialog.widgets['image'].raw_image = img;

    // set scaling on the image to fit
    post_screenshot_dialog_update_image_dimensions(dialog);

    // note: some browsers (Chrome) parse the image asynchronously, so we have to wait for it to complete
    if(img.width === 0 || img.height === 0) {
        img.addEventListener('load', goog.partial(post_screenshot_dialog_update_image_dimensions, dialog), false);
    }

    dialog.widgets['close_button'].onclick = dialog.widgets['cancel_button'].onclick = close_parent_dialog;
    dialog.widgets['caption_prefix'].str = caption_prefix; // dialog.user_data['caption_prefix'];

    //dialog.widgets['caption_input'].str = caption_prefix || '';

    dialog.widgets['caption_input'].ontextready =
        dialog.widgets['ok_button'].onclick = function(w) {
            var dialog = w.parent;
            var caption_list = [];
            if(dialog.user_data['caption_prefix']) {
                caption_list.push(dialog.user_data['caption_prefix']);
            }
            var player_caption = dialog.widgets['caption_input'].str;
            if(player_caption) {
                caption_list.push(player_caption);
            }
            var caption = caption_list.join(' - ');

            // this function locks up the GUI to prevent multiple clicks
            var on_launch = (function (_dialog) { return function() {
                _dialog.widgets['ok_button'].state = 'disabled';
                _dialog.widgets['ok_button'].str = dialog.data['widgets']['ok_button']['ui_name_pending'];
                _dialog.user_data['ui_locker'] = invoke_ui_locker_until_closed();
            }; })(dialog);

            var on_finish = (function (_dialog) { return function(success) {
                _dialog.widgets['ok_button'].state = 'normal';
                _dialog.widgets['ok_button'].str = _dialog.data['widgets']['ok_button']['ui_name'];
                if(_dialog.user_data['ui_locker']) {
                    close_dialog(_dialog.user_data['ui_locker']);
                    _dialog.user_data['ui_locker'] = null;
                }
                if(success) {
                    close_dialog(_dialog);
                }
            }; })(dialog);

            do_post_screenshot(dialog.user_data['image_data'], dialog.user_data['image_filename'],
                               caption, dialog.user_data['privacy'], dialog.user_data['reason'],
                               on_launch, on_finish);
    };

    post_screenshot_dialog_update_privacy(dialog, dialog.user_data['privacy']);
    SPUI.set_keyboard_focus(dialog.widgets['caption_input']);
}

/** Show the preview/caption GUI
    @param {!SPUI.Dialog} dialog
*/
function post_screenshot_dialog_update_image_dimensions(dialog) {
    if(!dialog.is_visible()) { return; }
    var img = dialog.widgets['image'].raw_image;

    var img_scale = 1/canvas_oversample;
    if(img_scale * img.width > dialog.data['widgets']['image']['dimensions'][0]) {
        img_scale *= dialog.data['widgets']['image']['dimensions'][0] / (img_scale*img.width);
    }
    if(img_scale * img.height > dialog.data['widgets']['image']['dimensions'][1]) {
        img_scale *= dialog.data['widgets']['image']['dimensions'][1] / (img_scale*img.height);
    }
    var img_dims = vec_floor(vec_scale(img_scale, [img.width, img.height]));

    dialog.widgets['image'].raw_image_rescale = false; // disable automatic rescaling
    dialog.widgets['image'].xy = vec_floor(vec_add(dialog.data['widgets']['image']['xy'],
                                                   vec_scale(0.5, vec_sub(dialog.data['widgets']['image']['dimensions'], img_dims))));
    dialog.widgets['image'].wh = [img.width, img.height];
    dialog.widgets['image'].transform = [img_scale,0,0,img_scale,0,0];
    dialog.widgets['image_bg'].xy = vec_add(dialog.widgets['image'].xy, vec_sub(dialog.data['widgets']['image_bg']['xy'],
                                                                                dialog.data['widgets']['image']['xy']));
    dialog.widgets['image_bg'].wh = vec_add(img_dims, vec_scale(2, vec_sub(dialog.data['widgets']['image']['xy'],
                                                                           dialog.data['widgets']['image_bg']['xy'])));
}

function post_screenshot_dialog_update_privacy(dialog, new_setting) {
    if(dialog.user_data['privacy'] !== new_setting) {
        player.preferences['fb_post_privacy'] = new_setting;
        send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
        dialog.user_data['privacy'] = new_setting;
    }

    var priv = {'EVERYONE': FBUploadPhoto.Privacy.EVERYONE,
                'ALL_FRIENDS': FBUploadPhoto.Privacy.ALL_FRIENDS,
                'SELF': FBUploadPhoto.Privacy.SELF};
    goog.object.forEach(priv, function(value, name) {
        dialog.widgets['privacy_'+name].onclick = (function (_value) { return function(w) {
            post_screenshot_dialog_update_privacy(w.parent, _value);
        }; })(value);
        dialog.widgets['privacy_'+name].state = (dialog.user_data['privacy'] === value ? 'active' : 'normal');
    });
}

/** Actually perform the upload. Request Facebook publish permission if necessary.
    @param {string} data
    @param {string} filename
    @param {string|null} player_caption
    @param {FBUploadPhoto.Privacy|null} privacy
    @param {string} reason
    @param {function()} launch_callback - called when we're about to start the post
    @param {function(boolean)} finish_callback - with success as the parameter
    @return {boolean} if the call was synchronous
*/
function do_post_screenshot(data, filename, player_caption, privacy, reason, launch_callback, finish_callback) {
    if(!player.get_any_abtest_value('enable_post_screenshot', gamedata['client']['enable_post_screenshot'])) { throw Error('enable_post_screenshot needs to be turned on'); }
    if(spin_frame_platform != 'fb' || !FBUploadPhoto.supported()) { throw Error('unsupported'); }
    if(!gamedata['virals']['post_screenshot'] || !gamedata['strings']['post_screenshot_success']) { throw Error('missing post_screenshot viral or strings entry'); }

    var viral = gamedata['virals']['post_screenshot'];
    var caption = goog.string.trim(viral[(player_caption ? 'ui_caption_custom' : 'ui_caption')].replace('%PLAYER_CAPTION', player_caption || ''));

    var cb = (function (_finish_callback) { return function(success) {
        if(_finish_callback) { _finish_callback(success); }
        if(success) {
            var s = gamedata['strings']['post_screenshot_success'];
            invoke_child_message_dialog(s['ui_title'], s['ui_description']);
            player.record_feature_use('post_screenshot');
        }
    }; })(finish_callback);

    if(!spin_facebook_enabled) {
        console.log('do_post_screenshot ('+(privacy || 'no-privacy-setting')+'): '+caption);
        cb(true);
        return true;
    }

    // 2018 Oct 19: this used to require 'publish_actions' permission, but Facebook removed that.
    if(launch_callback) { launch_callback(); }
    var metric_props = {'sum': player.get_denormalized_summary_props('brief'),
                        'facebook_id': spin_facebook_user,
                        'privacy': privacy,
                        'reason': reason};
    FBUploadPhoto.upload(data, filename, caption, privacy, true, cb, metric_props);
    return true;
}

// for analysis, take a screenshot of the entire game canvas, and upload it to our server
function upload_screen_capture() {
    if(!Screenshot.supported()) { return; }

    /** @type {!HTMLCanvasElement} */
    var canvas_to_capture = /** @type {!HTMLCanvasElement} */ (canvas);

    // scale down the big image by drawing it to an offscreen canvas
    var res_scale = 0.5;
    if(res_scale != 1) {
        /** @type {!HTMLCanvasElement} */
        var osc = /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));
        osc.width = Math.floor(canvas_width * res_scale);
        osc.height = Math.floor(canvas_height * res_scale);
        var osc_con = osc.getContext('2d');
        osc_con.drawImage(canvas, 0, 0, canvas_width * canvas_oversample, canvas_height * canvas_oversample, 0, 0, osc.width, osc.height);
        canvas_to_capture = osc;
    }

    var data_url = Screenshot.capture_full(canvas_to_capture, Screenshot.Codec.JPEG, null);
    if(!data_url) { return; }

    // check that we got a Base64-encoded JPEG, as we expected
    var prefix = 'data:image/jpeg;base64,';
    if(data_url.indexOf(prefix) !== 0) { return; }

    // send the raw Base64-encoded data
    var base64_data = data_url.slice(prefix.length, data_url.length);
    send_to_server.func(["UPLOAD_SCREEN_DATA", server_time, 'jpg', base64_data]);
}

var last_screen_capture_upload_time = -1;
function upload_screen_capture_check() {
    var cd = player.cooldown_find('uploading_screen_data');
    if(!cd) { return; }

    var interval = 30;
    if('data' in cd && 'interval' in cd['data']) {
        interval = cd['data']['interval'];
    }

    if(client_time >= last_screen_capture_upload_time + interval) {
        last_screen_capture_upload_time = client_time;
        upload_screen_capture();
    }
}

function invoke_gift_prompt_dialog() {
    if(player.tutorial_state != "COMPLETE") { return; }

    player.get_giftable_friend_info_list_async(function (ret) {
        if(ret.length < 1) {
            console.log('invoke_gift_prompt_dialog: no giftable friends');
            return;
        }

        change_selection(null);

        var dialog_data = gamedata['dialogs']['gift_prompt_dialog'];
        var dialog = new SPUI.Dialog(dialog_data);
        dialog.user_data['dialog'] = 'gift_prompt_dialog';

        change_selection_ui(dialog);
        dialog.auto_center();
        dialog.modal = true;

        dialog.widgets['close_button'].onclick = close_parent_dialog;

        if(!read_predicate(gamedata['client']['invite_prompt_closeable']).is_satisfied(player)) {
            dialog.widgets['close_button'].show = 0;
        }

        dialog.widgets['send_button'].onclick = (function (_info_list) { return function(w) {
            change_selection(null);
            invoke_send_gifts(null, 'gift_prompt_dialog', _info_list);
        }; })(ret);

        // customize text per platform
        goog.array.forEach(['title','description'], function(wname) {
            var widget = dialog.widgets[wname];
            if('ui_name_'+spin_frame_platform in widget.data) {
                widget.set_text_with_linebreaking(widget.data['ui_name_'+spin_frame_platform]);
            }
        });
    });
};

/** Start the send-gift process
 * @param {(number|null)} to_user - user_id of a friend to auto-select (may be null)
 * @param {string} reason for metrics purposes
 * @param {(!Array.<Object>|null)=} info_list - list of PlayerCache entries for giftable friends (if null, we will query)
 */
function invoke_send_gifts(to_user, reason, info_list) {
    if(spin_frame_platform === 'fb') {
        call_with_facebook_permissions('user_friends', (function (_to_user, _reason, _info_list) { return function() {
            FBSendRequests.invoke_send_gifts_dialog(_to_user, _reason, _info_list);
        }; })(to_user, reason, info_list));
        return null; // async!
    } else if(spin_frame_platform === 'ag') {
        return AGSendRequests.invoke_send_gifts_dialog(to_user, reason, info_list || null);
    } else if(spin_frame_platform === 'bh') {
        return BHInvites.invoke_send_gifts_dialog(reason);
    } else {
        throw Error('unhandled frame_platform '+spin_frame_platform);
    }
};

function invoke_motd_dialog(motd) {
    if(player.tutorial_state != "COMPLETE") { return; }

    change_selection(null);

    var dialog_data = gamedata['dialogs']['motd_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'motd_dialog';
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['close_button'].onclick =
        dialog.widgets['ok_button'].onclick =
        function() { change_selection(null); };

    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name'].replace('%GAME', gamedata['strings']['game_name']);
    dialog.widgets['subtitle'].str = motd['date'];
    dialog.widgets['description'].set_text_with_linebreaking(motd['text']);
};

function invoke_level_up_dialog() {
    if(player.tutorial_state != "COMPLETE") { return; }

    var next_level = player.can_level_up();
    if(!next_level) { return; }

    // try to get unit damage in sync so the "repair all" reward is less likely to fail due to a race condition
    flush_dirty_objects({});

    // just ask the server to level us up asynchronously
    send_to_server.func(["LEVEL_ME_UP", next_level]);
    SPFB.AppEvents.logEvent('ACHIEVED_LEVEL', null, {'LEVEL': next_level.toString()});

    if('level_up_notify' in gamedata['player_xp'] &&
       (!!gamedata['player_xp']['level_up_notify']) &&
       next_level < gamedata['player_xp']['level_up_notify'].length &&
       !gamedata['player_xp']['level_up_notify'][next_level]) {
        invoke_ui_locker();
        return;
    }

    change_selection(null);

    var dialog_data = gamedata['dialogs']['level_up_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'level_up_dialog';

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name'].replace('%d', next_level);
    //dialog.widgets['description'].str = gamedata['player_xp']['level_up_text'];

    // display reward consequent
    var level_up_rewards = player.get_any_abtest_value('level_up_reward', gamedata['player_xp']['level_up_reward'] || [null]);
    var reward_cons = level_up_rewards[Math.min(next_level, level_up_rewards.length-1)];

    if(reward_cons) {
        // awkward parsing for AND [HEAL_ALL_UNITS, something_else_hidden, ...]
        if(reward_cons['consequent'] == 'AND') {
            reward_cons = reward_cons['subconsequents'][0];
        }
    }

    if(reward_cons && reward_cons['consequent'] == 'GIVE_LOOT') {
        dialog.widgets['your_level_bonus'].str = dialog.data['widgets']['your_level_bonus']['ui_name_messages'];
        goog.array.forEach(['item_glow','slot','item','stack','frame'], function(n) { dialog.widgets['reward_'+n].show = true; });
        var item = reward_cons['loot'][0];
        var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
        ItemDisplay.set_inventory_item_asset(dialog.widgets['reward_item'], spec);
        ItemDisplay.set_inventory_item_stack(dialog.widgets['reward_stack'], spec, item);
        dialog.widgets['reward_frame'].onenter = (function (_slot, _item) { return function(w) {
            var inv_dialog = w.parent;
            if(inv_dialog.user_data['context']) {
                // do not switch if context for this item is already up
                if(inv_dialog.user_data['context'].user_data['slot'] === _slot &&
                   inv_dialog.user_data['context'].user_data['item'] === _item) {
                    return;
                }
            }
            invoke_inventory_context(w.parent, w, _slot, _item, false);
        }; })('reward_item', item);
        dialog.widgets['reward_frame'].onleave_cb = (function (_slot, _item) { return function(w) {
            var inv_dialog = w.parent;
            if(inv_dialog.user_data['context'] &&
               inv_dialog.user_data['context'].user_data['slot'] === _slot &&
               inv_dialog.user_data['context'].user_data['item'] === _item) {
                invoke_inventory_context(w.parent, w, -1, null, false);
            }
        }; })('reward_item', item);
    } else if(reward_cons && reward_cons['consequent'] == 'HEAL_ALL_UNITS') {
        dialog.widgets['your_level_bonus'].str = dialog.data['widgets']['your_level_bonus']['ui_name_heal_all_units'];
        dialog.widgets['repair_all_icon'].show = dialog.widgets['all_units_repaired'].show = true;
    } else if(reward_cons === null) {
        dialog.widgets['your_level_bonus'].show = false;
    } else {
        throw Error('cannot parse level_up_reward consequent: '+JSON.stringify(reward_cons));
    }

    if(friend_invites_enabled()) {
        dialog.widgets['spam_button_invite'].onclick = function() {
            change_selection(null);
            invoke_invite_friends_prompt('level_up_dialog');
        };

        // show "Inform Earth" for level 2 (on Facebook), and "Invite Friends" for level 3 and beyond
        if(next_level <= 2 && get_facebook_viral('level_advancement')) {
            dialog.widgets['spam_button_inform'].show = true;
            dialog.widgets['spam_button_invite'].show = false;
            dialog.widgets['spam_button_inform'].str = gamedata['virals']['level_advancement']['ui_button_text'];
            dialog.widgets['spam_button_inform'].onclick = (function (_next_level) {
                return function() { invoke_facebook_viral('level_advancement', {'%LEVEL': _next_level.toString()}); };
            })(next_level);
            dialog.default_button = dialog.widgets['spam_button_inform'];
        } else {
            dialog.widgets['spam_button_inform'].show = false;
            dialog.widgets['spam_button_invite'].show = true;
            dialog.default_button = dialog.widgets['spam_button_invite'];
        }
    } else {
        dialog.widgets['spam_button_invite'].show = false;
        dialog.widgets['spam_button_inform'].show = false;
        dialog.default_button = null;
    }

    dialog.widgets['glow'].show =
    dialog.widgets['screen_flash'].show =
    dialog.widgets['prog_bar_bg'].show =
    dialog.widgets['prog_bar1'].show =
    dialog.widgets['prog_bar2'].show =
    dialog.widgets['prog_bar3'].show =
        dialog.widgets['new_achievement'].show = true;

    dialog.widgets['screenshot_button'].show = post_screenshot_enabled();
    dialog.widgets['screenshot_button'].onclick = function(w) {
        var dialog = w.parent;
        invoke_post_screenshot(dialog, /* reason = */ dialog.user_data['dialog'],
                               make_post_screenshot_caption(dialog.data['widgets']['screenshot_button']['ui_caption'], player.get_player_cache_props()));
    };

    play_level_up_sound(null);
    invoke_ui_locker();
};

// don't spam the player with multiple loud level-up sounds if they cross multiple levels/get multiple upgrades at once
var last_level_up_sound_time = -1;
function play_level_up_sound(sound_asset) {
    if(!sound_asset) { sound_asset = 'level_up_sound'; }

    if(client_time - last_level_up_sound_time < 10.0) {
        sound_asset = 'menu_button_134px';
    } else {
        // play big sound
        last_level_up_sound_time = client_time;
    }
    GameArt.play_canned_sound(sound_asset);
}

// NEW metrics codes:
// 7270_feed_post_attempted
// 7271_feed_post_completed

function viral_string_subst(source, props) {
    var p = {'%NAME': player.facebook_name,
             '%FIRSTNAME': player.get_ui_name()
            };
    var ret = source;
    for(var key in p) {
        ret = ret.replace(key, p[key]);
    }
    if(props) {
        for(var key in props) {
            ret = ret.replace(key, props[key]);
        }
    }
    return ret;
}

function get_facebook_viral(vname) {
    if(spin_frame_platform != 'fb') { return null; }
    if('enable_if' in gamedata['virals'] && !read_predicate(gamedata['virals']['enable_if']).is_satisfied(player, null)) { return null; }
    if(!vname) { return null; }
    if(!(vname in gamedata['virals'])) { console.log('invalid viral '+vname); return null; }
    var viral = gamedata['virals'][vname];
    if('show_if' in viral && !read_predicate(viral['show_if']).is_satisfied(player, null)) { return null; }
    return viral;
}

function invoke_facebook_viral(vname, props) {
    var viral = get_facebook_viral(vname);
    if(!viral) { return; }

    FBShare.invoke({name: viral_string_subst(viral['ui_post_headline'], props),
                    description: viral_string_subst(gamedata['virals']['ui_post_description'], props),
                    picture: gamedata['virals']['common_image_path'] + (('image' in viral) ? viral['image'] : gamedata['virals']['default_image']),
                    ref: 'sp_game_viral' // can't use full ref_type here, there's a 15-char limit
                   });
}

function invoke_leaderboard_brag(rank, pct, ui_reason) {
    var viral = get_facebook_viral('leaderboard_brag');
    if(!viral) { return; }

    var ui_rank = percentile_ui_status(rank+1, pct, true);

    FBShare.invoke({name: viral['ui_post_headline'].replace('%PLAYER',player.facebook_name).replace('%RANK',ui_rank).replace('%REASON',ui_reason),
                    picture: gamedata['virals']['common_image_path'] + (('image' in viral) ? viral['image'] : gamedata['virals']['default_image']),
                    ref: 'leaderboard'});
}

function invoke_facebook_message_dialog(recipient_fbid, recipient_uid) {
    var props = { 'recipient_fb_id': recipient_fbid, 'recipient_user_id': recipient_uid };
    var viral = gamedata['virals']['facebook_message'];

    var cb = (function (pp) { return function(response) {
        // unreliable, but as good as we can do
        if(response !== null) {
            metric_event('7260_facebook_message_completed', pp);
        }
    }; })(props);

    metric_event('7250_facebook_message_attempted', props);

    var link_url = 'http://apps.facebook.com/'+spin_app_namespace+'/';
    // add acquisition tracking info
    link_url += '?spin_ref=facebook_message&spin_ref_user_id='+session.user_id.toString();

    var descr_list = viral['random_text'];
    var descr = descr_list[Math.floor(Math.random()*(descr_list.length))];

    if(!spin_facebook_enabled) {
        console.log('invoke_facebook_message_dialog('+recipient_fbid+','+recipient_uid+')');
        console.log(descr);
        return;
    }

    SPFB.ui({'method':'send', // send message
             'to': recipient_fbid,
             'link': link_url,
             'name': viral['ui_post_headline'],
             'picture': gamedata['virals']['common_image_path'] + (('image' in viral) ? viral['image'] : gamedata['virals']['default_image']),
             'description': descr
            }, cb);
}

function surrender_to_ai_attack() {
    var world = session.get_real_world();
    if(!world) { return; }

    if(session.surrender_pending) { return; }
    session.surrender_pending = true;

    // change the appearance of the surrender button
    desktop_dialogs['desktop_top'].widgets['surrender_button'].state = 'attack';
    desktop_dialogs['desktop_top'].widgets['surrender_button'].str = desktop_dialogs['desktop_top'].data['widgets']['surrender_button']['ui_name_pending'];

    // blow up the central computer and energy plants
    // (visually - the actual HP damage is done server-side, because otherwise you could just close
    // the browser window to avoid it!)
    world.objects.for_each(function(obj) {
        if(obj.team === 'player' && obj.spec['name'] === gamedata['townhall'] && !obj.is_destroyed()) {

            // change HP immediately just for visual effect - will get overridden by the upcoming OBJECT_STATE_UPDATE
            obj.hp = Math.max(1, Math.floor(0.5*obj.hp));

            if('explosion_effect' in obj.spec) {
                world.fxworld.add_visual_effect_at_tick(obj.raw_pos(), 0, [0,1,0], world.combat_engine.cur_tick, 0, obj.spec['explosion_effect'], true, null);
            }
        }
    });

    // queue a session change after a few seconds
    window.setTimeout(visit_base_after_attack, 1000.0 * gamedata['client']['surrender_delay']);
};

/** @param {boolean=} bypass_timer - skip retreat timer */
function retreat_from_attack(bypass_timer) {
    var retreat_time_table = player.get_any_abtest_value('retreat_time_table', gamedata['retreat_time_table']);
    var retreat_time = 0;

    if(session.has_deployed && session.deploy_time > 0 && retreat_time_table && player.tutorial_state == "COMPLETE" && session.viewing_user_id != session.user_id) {
        var attack_length = server_time - session.deploy_time;
        retreat_time = retreat_time_table[0][1];
        for(var i = 0; i < retreat_time_table.length; i++) {
            var entry = retreat_time_table[i];
            if(attack_length < entry[0]) {
                break;
            }
            retreat_time = entry[1];
        }
        //console.log('RETREAT attack '+attack_length.toString()+' = '+retreat_time.toString());
    }

    // cancel retreat timer if no friendly units are left
    if(retreat_time > 0) {
        var found = session.for_each_real_object(function(obj) { return obj.team === 'player'; });
        if(!found) {
            retreat_time = 0;
        }
    }

    // no retreat timer if battle outcome is decided
    if(retreat_time > 0) {
        if(calculate_battle_outcome() != 'undecided') {
            retreat_time = 0;
        }
    }

    // no retreat timer if attacking an AI and the CC is dead
    if(retreat_time > 0) {
        if(!session.home_base && session.viewing_ai && session.viewing_base.base_type === 'home') {
            var cc = find_object_by_type(gamedata['townhall']);
            if(cc && cc.team === 'enemy' && cc.hp <= 0) {
                retreat_time = 0;
            }
        }
    }

    // no retreat timer if manually disabled
    if(bypass_timer) {
        retreat_time = 0;
    }

    if(retreat_time <= 0) {
        // instant retreat
        visit_base_after_attack();
        return;
    }

    if(session.retreat_pending > 0) { return; }
    session.retreat_pending = client_time + retreat_time;

    // can't do it from ondraw since the UI may go away!
    window.setTimeout(visit_base_after_attack, 1000.0*retreat_time);
}

/** @param {SPUI.Dialog} dialog */
function update_attack_button_dialog(dialog) {
    var top = desktop_dialogs['desktop_top']; // since we need to adjust some widgets on there
    var placement = (session.has_attacked ? gamedata['client']['end_attack_button_placement'] || 'top_center' : 'top_center');

    // to avoid dependency cycle, manually compute the display coordinates from raw data rather than looking at the other dialogs
    if(placement == 'top_center') {
        dialog.xy = [canvas_width/2 - gamedata['dialogs']['desktop_top_visitor']['dimensions'][0]/2 + dialog.data['top_center_offset'][0],
                     dialog.data['top_center_offset'][1]];
    } else if(placement == 'bottom_left') {
        if(!session.enable_combat_resource_bars) {
            // when tutorial quests disable resource bars, this should go away too
            dialog.widgets['attack_button'].show = false;
            return;
        }
        dialog.xy = [dialog.data['bottom_left_offset'][0],
                     canvas_height + dialog.data['bottom_left_offset'][1]];
    } else {
        throw Error('unhandled placement '+placement);
    }

    dialog.widgets['attack_button'].show = true; // XXX hide when not applicable?
    //dialog.widgets['attack_button'].xy = dialog.data['widgets']['attack_button']['xy'+(canvas_is_fullscreen ? '_fullscreen' : '')];

    if(session.has_attacked) {
        if(session.retreat_pending > 0) {
            var str;
            dialog.widgets['attack_button'].state = 'disabled';
            var time_left = session.retreat_pending - client_time;
            if(time_left >= 1.0) {
                str = gamedata['dialogs']['retreating_dialog']['widgets']['loading_text']['ui_name'].replace('%d', time_left.toFixed(0));
            } else {
                str = gamedata['dialogs']['retreating_dialog']['widgets']['loading_text']['ui_name_now'];
            }
            dialog.widgets['attack_button'].str = str;
            dialog.widgets['auto_resolve_button'].show = false;

        } else { // retreat not pending
            dialog.widgets['attack_button'].state = 'end';
            if(player.tutorial_state != "COMPLETE" && player.tutorial_state != 'wait_battle_finish2') {
                dialog.widgets['attack_button'].state = 'disabled';
            }
            dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_'+ (session.viewing_user_id == session.user_id ? 'stop_reinforcing' : 'stop_attack')];
            dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_'+ (session.viewing_user_id == session.user_id ? 'stop_reinforcing' : 'stop_attack')];
            dialog.widgets['attack_button'].onclick = function(w) { retreat_from_attack(); };

            // only allow in squad battles, unless DEV edit mode is on
            dialog.widgets['auto_resolve_button'].show = player.auto_resolve_enabled() && (session.viewing_base.base_type === 'squad' || player.is_cheater) && !(!session.home_base && session.viewing_base.base_landlord_id === session.user_id);
            dialog.widgets['auto_resolve_button'].str = dialog.data['widgets']['auto_resolve_button'][(player.is_cheater && session.viewing_base.base_type !== 'squad') ? 'ui_name_dev': 'ui_name'];

            var auto_resolve_problem_ui_tooltip = null;
            var auto_resolve_problem_message_cb = null;

            // check in-battle unit space requirement for auto-resolve
            // the server uses a looser criterion of "all deployed+deployable live unit space" whereas client-side we use "all on-screen live unit space",
            // which is strictly tighter.
            var auto_resolve_max_relative_space = player.get_territory_setting('auto_resolve_max_relative_space');
            if(auto_resolve_max_relative_space > 0) {
                var my_alive_space = 0;
                var other_alive_space = 0;
                session.for_each_real_object(function(obj) {
                    if(obj.is_mobile() && !obj.is_destroyed()) {
                        var space = obj.get_leveled_quantity(obj.spec['consumes_space'] || 0);
                        if(obj.team === 'player') {
                            my_alive_space += space;
                        } else {
                            other_alive_space += space;
                        }
                    }
                });
                if(other_alive_space >= auto_resolve_max_relative_space * my_alive_space) {
                    auto_resolve_problem_ui_tooltip =
                        dialog.data['widgets']['auto_resolve_button']['ui_tooltip_defender_too_much_space']
                        .replace('%cur', pretty_print_number(my_alive_space))
                        .replace('%max', Math.floor(other_alive_space / auto_resolve_max_relative_space + 0.5).toFixed(0));
                    auto_resolve_problem_message_cb = (function (_max_rel_space) { return function(w) {
                        var s = gamedata['errors']['CANNOT_AUTO_RESOLVE_DEFENDER_TOO_MUCH_SPACE'];
                        invoke_child_message_dialog(s['ui_title'], s['ui_name'].replace('%d', (100.0*_max_rel_space).toFixed(0)),
                                                    {'dialog': 'message_dialog_big'});
                    }; })(auto_resolve_max_relative_space);
                }
            }

            if(auto_resolve_problem_ui_tooltip) {
                dialog.widgets['auto_resolve_button'].state = 'disabled_clickable';
                dialog.widgets['auto_resolve_button'].tooltip.str = auto_resolve_problem_ui_tooltip;
                dialog.widgets['auto_resolve_button'].onclick = auto_resolve_problem_message_cb;
            } else {
                dialog.widgets['auto_resolve_button'].state = 'normal';
                dialog.widgets['auto_resolve_button'].tooltip.str = dialog.data['widgets']['auto_resolve_button']['ui_tooltip'];
                dialog.widgets['auto_resolve_button'].onclick = function(w) {
                    var s = gamedata['strings']['auto_resolve_confirm'];
                    invoke_child_message_dialog(s['ui_title'], s['ui_description'],
                                                {'cancel_button': true,
                                                 'ok_button_ui_name': s['ui_button'],
                                                 'on_ok': function() {
                                                     send_to_server.func(["AUTO_RESOLVE"]);
                                                     retreat_from_attack(true);
                                                 }});
                };
            }
        }

    } else { // has_attacked is FALSE

        var is_under_protection = (session.viewing_player_home_base_id === session.viewing_base.base_id &&
                                   (enemy.resource_state["protection_end_time"] > server_time ||
                                    enemy.resource_state["protection_end_time"] == 1));
        var i_am_isolated = (player.isolate_pvp && !session.viewing_isolate_pvp && !session.viewing_ai);
        var they_are_isolated = (!player.isolate_pvp && session.viewing_isolate_pvp && !session.viewing_ai);

        var nopvp_violation = null;
        if(session.viewing_user_id != session.user_id && !session.is_remote_base() && !session.viewing_ai &&
           !session.using_squad_deployment() && !session.is_ladder_battle()) {
            if(!player.is_pvp_player()) {
                nopvp_violation = 'YOU';
            } else if(!enemy.is_pvp_player()) {
                nopvp_violation = 'THEM';
            }
        }

        var ladder_violation = null;
        if(session.viewing_user_id != session.user_id && !session.is_remote_base() && !session.viewing_ai &&
           !session.using_squad_deployment()) {
            if(player.is_ladder_player()) {
                if(!enemy.is_ladder_player()) {
                    ladder_violation = 'YOU';
                } else if(!session.is_ladder_battle()) {
                    ladder_violation = 'YOU';
                }
            } else {
                if(enemy.is_ladder_player()) {
                    ladder_violation = 'THEM';
                }
            }
        }

        var map_violation = null;
        if(session.viewing_user_id != session.user_id && !session.is_remote_base() && !session.viewing_ai && !session.using_squad_deployment() && !session.is_ladder_battle()) {
            if(!enemy.is_legacy_pvp_player()) {
                if(!player.is_legacy_pvp_player()) {
                    if(session.region.data && session.region.data['id'] == session.viewing_player_home_region) {
                        map_violation = 'BOTH_SAME_REGION';
                    } else if(!session.viewing_player_home_region) {
                        map_violation = 'YOU'; // they haven't been placed yet
                    } else {
                        map_violation = 'BOTH_DIFFERENT_REGION';
                    }
                } else {
                    map_violation = 'THEM';
                }
            } else if(!player.is_legacy_pvp_player()) {
                map_violation = 'YOU';
            }
        }

        var is_sandstorm = 0, is_sandstorm_max = false;
        for(var i = 0; i < player.player_auras.length; i++) {
            var code = gamedata['auras'][player.player_auras[i]['spec']]['code'];
            if(code == 'sandstorm_max') {
                is_sandstorm_max = true;
                break;
            } else if(code == 'sandstorm') {
                is_sandstorm = player.player_auras[i]['strength'] || 1;
                break;
            }
        }

        var limit_quarry_control = !(session.region.data && ('limit_quarry_control' in session.region.data) && !session.region.data['limit_quarry_control']);

        if(is_under_protection ||
                  (session.pvp_balance === 'player') ||
                  (session.pvp_balance === 'enemy_strict') ||
                  (session.pvp_balance === 'same_alliance') ||
                  (session.viewing_lock_state != 0 && session.viewing_base.base_landlord_id != session.user_id) ||
                  (session.viewing_base.deployment_allowed && session.count_deployable_units() < 1 && (session.viewing_base.base_landlord_id != session.user_id || !session.region.data || session.region.data['storage'] != 'nosql')) ||
                  session.repeat_attack_cooldown_expire > server_time ||
                  i_am_isolated || they_are_isolated || is_sandstorm_max || nopvp_violation || ladder_violation || map_violation ||
                  (session.is_alt_account && gamedata['prevent_alt_attacks']) ||
                  (session.viewing_base.base_type == 'quarry' && session.viewing_base.base_landlord_id != session.user_id && limit_quarry_control && session.region.num_quarries_owned() >= player.stattab['quarry_control_limit'])) {
            // unable to attack
            dialog.widgets['attack_button'].state = 'disabled';
            dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name'];
            dialog.widgets['attack_button'].onclick = null;

            if(i_am_isolated) {
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_you_are_isolated'];
            } else if(they_are_isolated) {
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_they_are_isolated'];
            } else if(session.is_alt_account && gamedata['prevent_alt_attacks']) {
                dialog.widgets['attack_button'].tooltip.str = gamedata['errors']['CANNOT_ATTACK_ALT_ACCOUNT']['ui_name'];
            } else if(nopvp_violation) {
                top.widgets['violation_message'].show = true;
                //var ui_req = read_predicate({'predicate':'LIBRARY', 'name':'pvp_requirement'}).ui_describe(player);
                var ui_req = gamedata['predicate_library']['pvp_requirement']['ui_name'];
                top.widgets['violation_message'].str = gamedata['errors']['CANNOT_ATTACK_NOPVP_'+nopvp_violation]['ui_name'];
                if(ui_req) { top.widgets['violation_message'].str += '\n'+gamedata['strings']['unmet_requirements'].replace('%s', ui_req); }
                dialog.widgets['attack_button'].tooltip.str = gamedata['errors']['CANNOT_ATTACK_NOPVP_'+nopvp_violation]['ui_name'];
            } else if(ladder_violation) {
                top.widgets['violation_message'].show = true;
                top.widgets['violation_message'].str = gamedata['errors']['CANNOT_ATTACK_LADDER_'+ladder_violation]['ui_instructions'];
                dialog.widgets['attack_button'].tooltip.str = gamedata['errors']['CANNOT_ATTACK_LADDER_'+ladder_violation]['ui_name'];
                // for games with no regions, don't even show the attack button here (not sure if this is right - check gamedata['ladder_pvp']?)
                if(goog.object.getCount(gamedata['regions']) < 1) {
                    top.widgets['violation_message'].show = false;
                    dialog.widgets['attack_button'].show = false;
                }
            } else if(map_violation) {
                top.widgets['violation_message'].show = true;
                var viewing_region = (session.viewing_player_home_region && session.viewing_player_home_region in gamedata['regions'] ? gamedata['regions'][session.viewing_player_home_region]['ui_name'] : gamedata['strings']['regional_map']['unknown_name']);
                var xs = '', ys = '';
                if(session.viewing_base.base_map_loc) { xs = session.viewing_base.base_map_loc[0].toString(); ys = session.viewing_base.base_map_loc[1].toString(); }
                top.widgets['violation_message'].str = gamedata['errors']['CANNOT_ATTACK_MAP_'+map_violation]['ui_instructions'].replace('%VIEWING_REGION', viewing_region).replace('%X',xs).replace('%Y',ys).replace('%TOWNHALL',gamedata['buildings'][gamedata['townhall']]['ui_name']);
                dialog.widgets['attack_button'].tooltip.str = gamedata['errors']['CANNOT_ATTACK_MAP_'+map_violation]['ui_name'];
                // for games with no regions, don't even show the attack button here (not sure if this is right - check gamedata['ladder_pvp']?)
                if(goog.object.getCount(gamedata['regions']) < 1) {
                    top.widgets['violation_message'].show = false;
                    dialog.widgets['attack_button'].show = false;
                }
            } else if(is_sandstorm_max) {
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['sandstorm_max_message']['ui_name'];
                top.widgets['sandstorm_max_message'].show = true;
                if(session.viewing_base.base_last_attack_time > 0) {
                    top.widgets['protection_defended'].show = true;
                    top.widgets['protection_defended'].str = top.widgets['protection_defended'].data['ui_name'].replace('%s', pretty_print_time_brief(server_time - session.viewing_base.base_last_attack_time));
                }
            } else if(session.pvp_balance === 'player') {
                dialog.widgets['attack_button'].state = 'looks_disabled';
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_lowlevel_rival'];
                dialog.widgets['attack_button'].onclick = invoke_attack_weaker_message;
                top.widgets['weaker_message'].show = true;
                if(session.viewing_base.base_last_attack_time > 0) {
                    top.widgets['protection_defended'].show = true;
                    top.widgets['protection_defended'].str = top.widgets['protection_defended'].data['ui_name'].replace('%s', pretty_print_time_brief(server_time - session.viewing_base.base_last_attack_time));
                }
            } else if(session.pvp_balance === 'enemy_strict') {
                dialog.widgets['attack_button'].state = 'looks_disabled';
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_highlevel_rival'];
                dialog.widgets['attack_button'].onclick = invoke_attack_stronger_strict_message;
                top.widgets['stronger_message'].show = true;
                if(session.viewing_base.base_last_attack_time > 0) {
                    top.widgets['protection_defended'].show = true;
                    top.widgets['protection_defended'].str = top.widgets['protection_defended'].data['ui_name'].replace('%s', pretty_print_time_brief(server_time - session.viewing_base.base_last_attack_time));
                }
            } else if(session.pvp_balance === 'same_alliance') {
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_same_alliance'];
            } else if((session.viewing_lock_state != 0 && session.viewing_base.base_landlord_id != session.user_id) || is_under_protection) {
                var str;
                if(session.is_remote_base()) {
                    str = dialog.data['widgets']['attack_button']['ui_tooltip_base_locked'];
                } else {
                    // not actually accurate since lock_state==2 implies under attack, but don't tell players that
                    str = dialog.data['widgets']['attack_button']['ui_tooltip_home_protection'];
                    top.widgets['protection_message'].show = true;
                    if(session.viewing_base.base_last_attack_time > 0) {
                        top.widgets['protection_defended'].show = true;
                        top.widgets['protection_defended'].str = top.widgets['protection_defended'].data['ui_name'].replace('%s', pretty_print_time_brief(server_time - session.viewing_base.base_last_attack_time));
                    }
                }
                dialog.widgets['attack_button'].tooltip.str = str;
            } else if(is_under_protection) {
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_protection'];
            } else if(session.viewing_base.deployment_allowed && session.count_deployable_units() < 1 &&
                      (session.viewing_base.base_landlord_id != session.user_id || !session.region.data || session.region.data['storage'] != 'nosql')) {
                if(session.deployable_squads.length < 1) {
                    if(session.viewing_base.base_landlord_id == session.user_id) {
                        // friendly base - no attack button
                        dialog.widgets['attack_button'].show = false;
                    } else {
                        // shouldn't get here via the map - enemy base but no squad within range
                        // (skill challenges set deployment_allowed = false)
                        dialog.widgets['attack_button'].show = false;
                    }
                } else if(!player.has_any_units()) {
                    dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_no_units'].replace('%MENU', gamedata['dialogs']['desktop_bottom']['widgets']['robots_button']['ui_name']).replace('%VERB', gamedata['spells']['MAKE_DROIDS']['ui_name'].toLowerCase());
                } else {
                    dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_no_units_for_climate'].replace('%name',session.viewing_base.climate.data['ui_name']).replace('%descr',session.viewing_base.climate.describe_climate_unit_restrictions());
                }
            } else if(session.repeat_attack_cooldown_expire > server_time) {
                dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_cooldown'].replace('%s', pretty_print_time_brief(session.repeat_attack_cooldown_expire-server_time));
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_cooldown'];
            } else if(session.viewing_base.base_type == 'quarry' && session.viewing_base.base_landlord_id != session.user_id && limit_quarry_control && session.region.num_quarries_owned() >= player.stattab['quarry_control_limit']) {
                var can_improve = get_next_level_with_stat_increase(gamedata['buildings'][gamedata['region_map_building']], 'provides_quarry_control', player.history[gamedata['region_map_building']+'_level']||1) > 0;
                top.widgets['violation_message'].show = true;
                top.widgets['violation_message'].str = gamedata['errors'][can_improve ? 'CANNOT_ATTACK_QUARRY_LIMIT_REACHED' : 'CANNOT_ATTACK_QUARRY_MAX_LIMIT_REACHED']['ui_name'];
                dialog.widgets['attack_button'].tooltip.str = top.widgets['violation_message'].str;
            }

        } else { // you CAN attack - no reason to prevent an attack right now
            if(!session.using_squad_deployment() &&
               session.is_remote_base() &&
               !player.travel_satisfied(session.viewing_base.base_map_loc)) {

                if(player.travel_state['dest_loc'] && vec_equals(player.travel_state['dest_loc'], session.viewing_base.base_map_loc)) {
                    // on the way
                    var to_go = player.travel_state['end_time'] - server_time;
                    var str_to_go = pretty_print_time_brief(to_go);
                    dialog.widgets['attack_button'].state = 'disabled';
                    dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_reinforce_pending'].replace('%s',str_to_go);
                    dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_reinforce_pending'].replace('%s',str_to_go);
                    dialog.widgets['attack_button'].onclick = function() { send_to_server.func(["TRAVEL_BEGIN", session.viewing_base.base_map_loc,
                                                                                                player.travel_time_to(session.viewing_base.base_map_loc)]); };
                } else {
                    // not on the way
                    dialog.widgets['attack_button'].state = 'end';
                    dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_reinforce'].replace('%s',pretty_print_time_brief(player.travel_time_to(session.viewing_base.base_map_loc)));
                    dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_reinforce'];
                    dialog.widgets['attack_button'].onclick = function() { send_to_server.func(["TRAVEL_BEGIN", session.viewing_base.base_map_loc,
                                                                                                player.travel_time_to(session.viewing_base.base_map_loc)]); };
                }
            } else if(session.using_squad_deployment() && (session.viewing_user_id == session.user_id)) {
                // disable reinforcement option when squad-spying on friendly stuff
                dialog.widgets['attack_button'].show = false;
            } else {
                dialog.widgets['attack_button'].state = (session.viewing_user_id == session.user_id ? 'end' : 'attack');
                dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name'+(session.viewing_user_id == session.user_id ? '_reinforce_now' : '')];
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip'+(session.viewing_user_id == session.user_id ? '_reinforce_now' : '')];

                if(session.is_ladder_battle() && !session.using_squad_deployment()) {
                    dialog.widgets['attack_button'].state = 'attack_once';
                    dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_attack_ladder'];
                    dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_attack_ladder'].replace('%s', gamedata['events']['challenge_pvp_ladder']['ui_name']);

                } else if((session.viewing_user_id != session.user_id) &&
                          !session.viewing_ai &&
                          !session.is_remote_base() &&
                          !player.in_attackable_level_range(enemy.level()) &&
                          player.cooldown_active('revenge_defender:'+session.viewing_user_id.toString()) &&
                          session.region.pvp_level_gap_enabled() &&
                          (player.is_ladder_player() || player.is_legacy_pvp_player()) &&
                          !session.is_ladder_battle()) {
                    dialog.widgets['attack_button'].state = 'attack_once';
                    dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_attack_revenge'];
                    dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_attack_revenge'];
                } else if(session.viewing_ai && session.viewing_base.base_type == 'home') {
                    var base = gamedata['ai_bases_client']['bases'][session.viewing_user_id.toString()];
                    if(base && ('persistent' in base) && !base['persistent']) {
                        dialog.widgets['attack_button'].state = 'attack_once';
                        dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_attack_once'];
                        dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_attack_once'];
                    }
                }

                var attack_cb = function() {
                    session.has_attacked = true;
                    player.quest_tracked_dirty = true;

                    if(player.tutorial_state === 'click_attack') { advance_tutorial(); }

                    // send an empty deployment request to get the write lock
                    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "DEPLOY_UNITS", [0,0], {}]);

                    // turn off top scores
                    if('skill_challenge_standings_dialog' in desktop_dialogs) {
                        close_dialog(desktop_dialogs['skill_challenge_standings_dialog']);
                    }

                    // turn on combat item bar
                    if(!session.home_base && session.viewing_base.deployment_allowed) {
                        init_combat_item_bar();
                    }

                    // automatically pan to centroid of polygonal deployment zone
                    if(session.viewing_base.has_deployment_zone()) {
                        var centroid = session.viewing_base.deployment_zone_centroid();
                        if(centroid) {
                            force_scroll(null, centroid, "on_attack");
                        }
                    }

                    // set up deployment cursor AFTER ui_locker goes away
                    // for tutorial, hold off until all units are readied for deployment
                    var setup_deployment_cursor = function() {
                        if(player.tutorial_state != "COMPLETE" && gamedata['tutorial'][player.tutorial_state]['next'] != 'place_robots_message') {
                        } else if(!session.viewing_base.deployment_allowed) {
                            // special case for self-contained AI bases
                            // select all friendly units immediately
                            if(player.unit_micro_enabled()) {
                                session.for_each_real_object(function(obj) {
                                    if(obj.is_mobile() && obj.team === 'player' && !obj.is_destroyed()) {
                                        add_unit_to_selection(obj);
                                    }
                                });
                            }
                        } else if(selection.spellname != "DEPLOY_UNITS") {
                            change_selection(player.virtual_units["DEPLOYER"]);
                            selection.spellname = "DEPLOY_UNITS";
                            var cursor = new DeployUICursor();
                            change_selection_ui_under(cursor);
                        }
                    };
                    invoke_ui_locker(null, setup_deployment_cursor);
                };

                if(is_sandstorm) {
                    top.widgets['sandstorm_message'].show = true;
                    top.widgets['sandstorm_message'].str = top.data['widgets']['sandstorm_message']['ui_name'].replace('%pct', (is_sandstorm*100.0).toFixed(0));
                }

                dialog.widgets['attack_button'].onclick = (function (cb) { return function() {
                    if(session.is_ladder_battle()) {
                        if(player.resource_state['protection_end_time'] > server_time) {
                            invoke_attack_through_protection_message(cb);
                        } else {
                            cb();
                        }
                    } else if(session.pvp_balance === 'player') {
                        // warn player that he is not allowed to prey on a weak enemy
                        invoke_attack_weaker_message();
                    } else if(session.pvp_balance === 'enemy_strict') {
                        // warn player that he is not allowed to touch a strong enemy
                        invoke_attack_stronger_strict_message();
                    } else if(session.pvp_balance === 'enemy') {
                        // warn player that he's about to attack a strong enemy, who can retaliate
                        invoke_attack_stronger_message(cb);
                    } else if(player.resource_state['protection_end_time'] > server_time &&
                              session.viewing_user_id != session.user_id &&
                              !session.viewing_ai &&
                              (!session.is_squad() || gamedata['territory']['squads_affect_protection']) &&
                              (!session.is_quarry() || gamedata['territory']['quarries_affect_protection'])) {
                        // warn player that attacking another human will disable your own protection timer
                        invoke_attack_through_protection_message(cb);

                    // warn player about to attack a Facebook friend for the first time (obsolete)
                    /*
                    } else if(session.viewing_friend != null &&
                              !session.viewing_friend.is_ai() &&
                              session.viewing_friend.is_real_friend &&
                              session.viewing_user_id != session.user_id &&
                              session.viewing_base.base_type == 'home' &&
                              session.viewing_friend.battle_count < 1) {
                        invoke_attack_friend_message(cb);
                    */
                    } else if(session.viewing_user_id == session.user_id) {
                        // warn player that donated units are given permanently
                        invoke_attack_reinforce_message(cb);
                    } else if((session.viewing_user_id != session.user_id) &&
                              !session.viewing_ai &&
                              !player.in_attackable_level_range(enemy.level()) &&
                              player.cooldown_active('revenge_defender:'+session.viewing_user_id.toString()) &&
                              session.region.pvp_level_gap_enabled() &&
                              (player.is_ladder_player() || player.is_legacy_pvp_player()) &&
                              !session.is_ladder_battle() &&
                              !session.using_squad_deployment() &&
                              !session.is_remote_base() &&
                              ('attack_revenge_lower_level_message' in gamedata['dialogs'])) {
                        // warn player that revenge is once-only now
                        invoke_attack_revenge_lower_level_message(cb);
                    } else {
                        // just do the attack
                        cb();
                    }
                }; })(attack_cb);
            } // attack_button is clickable with callback
        } // END you CAN attack

        dialog.widgets['auto_resolve_button'].show = false;
    } // END session.has_attacked is FALSE

}

/** @param {SPUI.Dialog} dialog */
function update_retreating_dialog(dialog) {
    var str;
    if(session.retreat_pending < 0 || client_time >= session.retreat_pending) {
        str = dialog.data['widgets']['loading_text']['ui_name_now'];
    } else {
        var time_left = session.retreat_pending - client_time;
        if(time_left >= 1.0) {
            str = dialog.data['widgets']['loading_text']['ui_name'].replace('%d', time_left.toFixed(0));
        } else {
            str = dialog.data['widgets']['loading_text']['ui_name_now'];
        }
    }
    dialog.widgets['loading_text'].str = str;
}

function invoke_defense_end_dialog(battle_type, battle_base, battle_opponent_user_id, battle_opponent_fbid, battle_opponent_level, battle_opponent_friend,
                                   battle_opponent_name,
                                   outcome, loot, battle_summary, ladder_state, replay_signature) {
    if(outcome == 'victory' &&
       player.get_any_abtest_value('fancy_victory_dialog', gamedata['client']['fancy_victory_dialog'])) {
        return invoke_fancy_victory_dialog(battle_type, battle_base, battle_opponent_user_id, battle_opponent_fbid, battle_opponent_level, battle_opponent_friend,
                                           battle_opponent_name,
                                           outcome, loot, battle_summary, ladder_state, replay_signature);
    }

    change_selection(null);

    var dialog_data = gamedata['dialogs']['defense_end_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'defense_end_dialog';

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    if(outcome != 'defeat') {
        outcome = 'victory';
    }

    dialog.widgets['title_'+outcome].show =
        dialog.widgets['subtitle_'+outcome].show = true;
    dialog.widgets['subtitle_'+outcome].str = dialog_data['widgets']['subtitle_'+outcome]['ui_name'].replace('%s', battle_opponent_name);

    // calculate statistics
    var base_damage = calc_base_damage({count_partial:true});
    dialog.widgets['base_damage'].str = Math.floor(100*base_damage).toFixed(0) + '%';

    var gained_xp = loot['xp'] || 0;
    if(player.get_any_abtest_value('show_xp_gains', gamedata['client']['show_xp_gains'])) {
        dialog.widgets['xp_amount'].str = pretty_print_number(gained_xp);
    } else {
        dialog.widgets['you_gained'].show =
            dialog.widgets['xp_amount'].show =
            dialog.widgets['xp_icon'].show = false;
    }

    dialog.widgets['units_destroyed'].str = get_loot_kills_list(loot, '\n', 5);
    for(var res in gamedata['resources']) {
        var lost = loot[res] || 0;
        if(res+'_amount' in dialog.widgets) {
            dialog.widgets[res+'_amount'].show = dialog.widgets[res+'_icon'].show = true;
            dialog.widgets[res+'_icon'].asset = gamedata['resources'][res]['icon_small'];
            dialog.widgets[res+'_amount'].str = pretty_print_number(lost);
        }
    }
    init_dialog_repair_buttons(dialog, base_damage, true);
    return dialog;
};

// tutorial UI elements don't use selection.ui because we need to
// ensure that they don't get closed accidentally
var tutorial_root = new SPUI.Container();
tutorial_root.xy = [0,0]; tutorial_root.wh = [99999,99999];
tutorial_root.transparent_to_mouse = true;
var tutorial_ui = null;
var tutorial_nonmodal_ui = null;

function tutorial_step(clear_nonmodal_ui) {

    if(player.is_developer()) {
        console.log('Tutorial step '+player.tutorial_state+(player.tutorial_hold ? ' (HOLD)' : ''));
    }

    if(tutorial_ui && tutorial_ui.parent) {
        tutorial_root.remove(tutorial_ui);
        tutorial_ui = null;
    }

    if(clear_nonmodal_ui) {
        if(tutorial_nonmodal_ui && tutorial_nonmodal_ui.parent) {
            tutorial_root.remove(tutorial_nonmodal_ui);
            tutorial_nonmodal_ui = null;
        }
    }

    if(player.tutorial_hold) { return; }

    if(gamedata['client']['instrument_tutorial'] ||
       goog.array.contains(["COMPLETE","congratulations_message"], player.tutorial_state)) {
        send_to_server.func(["TUTORIAL_STATE_UPDATE", player.tutorial_state]);
    }

    if(player.tutorial_state === "COMPLETE") {
        init_desktop_dialogs(); // refresh desktop dialog show settings
        return;
    }

    if(!(player.tutorial_state in gamedata['tutorial'])) {
        throw Error('invalid tutorial state '+player.tutorial_state);
    }
    var data = gamedata['tutorial'][player.tutorial_state];

    if('metric' in data) {
        var metric = data['metric'];
        metric_event(metric, {'sum': player.get_denormalized_summary_props('brief')});
    }

    if('force_scroll' in data) {
        var obj_type = (typeof(data['force_scroll'])=="string" ? data['force_scroll'] : null);
        var pos = (obj_type ? null : data['force_scroll']);
        force_scroll(obj_type, pos, player.tutorial_state);
    }

    if(data['kind'] === 'slideshow') {
        tutorial_step_slideshow(data);
    } else if(data['kind'] === 'valentina_help_message') {
        tutorial_step_valentina_help_message(data);
    } else if(data['kind'] === 'valentina_nonmodal_message') {
        tutorial_step_valentina_nonmodal_message(data);
    } else if(data['kind'] === 'click_on_rover_action') {
        make_tutorial_arrow_for_landscape(data['unit_type'], null, 'down');
    } else if(data['kind'] === 'move_rover_action') {
        make_tutorial_arrow_for_landscape(null, gamedata['tutorial']['move_rover_action']['coords'], 'down');
    } else if(data['kind'] === 'wait_for_battle_finish') {
        // no UI
    } else if(data['kind'] === 'repair_message') {
        tutorial_step_repair_message(data);
    } else if(data['kind'] === 'wait_for_repairs') {
        // no UI
    } else if(data['kind'] === 'open_buildings_dialog') {
        var arrow = make_tutorial_arrow_for_button('desktop_bottom', 'buildings_button', 'down');
        arrow.user_data['wave_amplitude'] = gamedata['tutorial']['open_buildings_dialog']['arrow_wave_amplitude'] || 25;
        arrow.user_data['scroll_down_hack'] = !!gamedata['tutorial']['open_buildings_dialog']['scroll_down_hack'];
    } else if(data['kind'] === 'go_to_defense_tab') {
        make_tutorial_arrow_for_button('build_dialog', 'defense_button', gamedata['tutorial']['go_to_defense_tab']['arrow_direction'] || 'down');
    } else if(data['kind'] === 'choose_defensive_cannon') {
        make_tutorial_arrow_for_button('build_dialog', 'grid1,0', 'down');
    } else if(data['kind'] === 'place_defensive_cannon') {
        make_tutorial_arrow_for_landscape(null, data['location'], 'down');
    } else if(data['kind'] === 'speedup_open_context_menu') {
        make_tutorial_arrow_for_landscape(data['target'], null, 'up');
    } else if(data['kind'] === 'speedup_open_speedup_menu') {
        make_tutorial_arrow_for_button('context_menu', 'button0', 'up');
    } else if(data['kind'] === 'speedup_click_finish') {
        make_tutorial_arrow_for_button('speedup_dialog', 'ok_button', 'down');
    } else if(data['kind'] === 'defensive_cannon_complete') {
        // no UI
    } else if(data['kind'] === 'ai_attack') {
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "TUTORIAL_AI_ATTACK"]);
        //player.tutorial_state = data['next'];
    } else if(data['kind'] === 'ai_attack_end') {
        make_tutorial_arrow_for_button('ai_attack_finish_dialog', 'ok_button', 'up');
    } else if(data['kind'] === 'open_map_dialog') {
        make_tutorial_arrow_for_button('desktop_bottom', 'map_button', 'down');
    } else if(data['kind'] === 'spy_on_ai') {
        make_tutorial_arrow_for_button('map_dialog', 'row_button0', 'down');
    } else if(data['kind'] === 'click_attack') {
        make_tutorial_arrow_for_button('attack_button_dialog', 'attack_button', 'up');
    } else if(data['kind'] === 'deploy_robots_action') {
        make_tutorial_arrow_for_button('desktop_bottom', data['button'], 'down'); // this really gets desktop_bottom_visitor
    } else if(data['kind'] === 'place_robots_action') {
        make_tutorial_arrow_for_landscape(null, gamedata['tutorial']['place_robots_action']['coords'], 'down');
    } else if(data['kind'] === 'wait_battle_finish2') {
        // no UI
    } else if(data['kind'] === 'battle_end_message') {
        make_tutorial_arrow_for_button('battle_dialog', 'ok_button', 'down');
    } else if(data['kind'] === 'congratulations_message') {
        tutorial_step_congratulations(data);
    } else if(data['kind'] === 'invite_friends') {
        tutorial_step_invite_friends(data);
    } else if(data['kind'] === 'open_missions_dialog') {
        make_tutorial_arrow_for_button('desktop_bottom', 'missions_button', 'down');
    } else if(data['kind'] === 'null') {
    } else {
        throw Error('unhandled tutorial kind '+data['kind']);
    }
}

function advance_tutorial() {
    if(player.is_developer()) {
        console.log('advance_tutorial(): '+player.tutorial_state+' -> '+gamedata['tutorial'][player.tutorial_state]['next']);
    }
    player.tutorial_state = gamedata['tutorial'][player.tutorial_state]['next'];
    tutorial_step(true);
}

function tutorial_step_slideshow(data) {
    var dialog_data = gamedata['dialogs']['tutorial_slideshow_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'tutorial_slideshow_dialog';
    tutorial_ui = dialog;
    tutorial_root.add(dialog);

    dialog.auto_center();

    dialog.widgets['image'].asset = data['asset'];
    dialog.widgets['description'].str = data['ui_description'];

    dialog.widgets['next_button'].onclick = (function (next) { return function() {
        player.tutorial_state = next;
        tutorial_step(true);
    }; })(data['next']);

    if(!spin_secure_mode && player.is_developer()) {
        // developer-mode-only button that skips the entire tutorial
        dialog.widgets['skip_button'].onclick = function() {
            var s = gamedata['strings']['dev_skip_rails_tutorial_confirm'];
            player.tutorial_state = "COMPLETE";
            tutorial_root.clear();
            invoke_child_message_dialog(s['ui_title'], s['ui_description'],
                                        {'dialog': 'message_dialog_big',
                                         'ok_button_ui_name': s['ui_button'],
                                         'on_ok': function() {
                                             destroy_all_enemies();
                                             init_desktop_dialogs();
                                             tutorial_step(true);
                                             player.quest_tracked_dirty = true;
                                         }});
        };
    } else {
        dialog.widgets['skip_button'].show = false;
    }

    if(data['next_button_arrow']) {
        var dir = 'down';
        var arrow = make_ui_arrow(dir);
        dialog.add(arrow);
        arrow.ondraw = update_tutorial_arrow_for_button(arrow, 'tutorial_slideshow_dialog', 'next_button', dir);
    }
}

function destroy_all_enemies() { session.get_real_world().destroy_all_enemies(); };

function tutorial_step_valentina_help_message(data) {
    var dialog_data = gamedata['dialogs']['tutorial_valentina_help_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'tutorial_valentina_help_message';
    tutorial_ui = dialog;
    tutorial_root.add(dialog);

    dialog.auto_center();

    dialog.widgets['title'].str = data['ui_name'];
    dialog.widgets['description'].str = data['ui_description'];
    dialog.widgets['ok_button'].str = data['ui_button'];

    dialog.widgets['ok_button'].onclick = (function (next) { return function() {
        // switch to combat music (use "recon" if "combat" not available)
        change_backdrop_music(/** @type {!GameArt.Sprite} */ (GameArt.assets['background_music'].states[(GameArt.assets['background_music'].has_state('combat') ? 'combat' : 'recon')]).audio);
        player.tutorial_state = next;
        tutorial_step(true);
    }; })(data['next']);

    if(data['ok_button_arrow']) {
        var dir = 'up';
        var arrow = make_ui_arrow(dir);
        dialog.add(arrow);
        arrow.ondraw = update_tutorial_arrow_for_button(arrow, 'tutorial_valentina_help_message', 'ok_button', dir);
    }
}

/** @param {SPUI.Dialog} dialog */
function update_valentina_nonmodal_message(dialog) {
    if(dialog.user_data['show_if']) {
        dialog.show = dialog.user_data['show_if'].is_satisfied(player, null);
    }

    // put in top third of screen
    dialog.xy = [Math.floor(canvas_width/2 - dialog.data['dimensions'][0]/2),
                 Math.floor(dialog.user_data['y_position']*canvas_height)];
    if(dialog.parent) { // might be ok to do this unconditionally
        dialog.xy = vec_sub(dialog.xy, dialog.parent.get_absolute_xy());
    }

    // make sure dialog does not actually go off screen
    var corner = dialog.get_absolute_xy();
    if(corner[1] < 0) {
        dialog.xy[1] += -corner[1];
    } else if(corner[1] + dialog.wh[1] >= canvas_height) {
        dialog.xy[1] -= (corner[1]+dialog.wh[1])-canvas_height;
    }

    goog.array.forEach(['enemy', 'player'], function(team) {
        goog.array.forEach(['rovers', 'townhall'], function(kind) {
            if(dialog.user_data[team+'_'+kind] ||
               (dialog.user_data['boxes'] && dialog.user_data['boxes'][team+'_'+kind])) {
                var ui_text, box_color, grid_pad = 1, opacity = 0.25;
                if(dialog.user_data['boxes']) {
                    ui_text = dialog.user_data['boxes'][team+'_'+kind]['ui_name'];
                    box_color = dialog.user_data['boxes'][team+'_'+kind]['color'];
                    grid_pad = (dialog.user_data['boxes'][team+'_'+kind]['grid_pad'] || 1);
                    if('opacity' in dialog.user_data['boxes'][team+'_'+kind]) {
                        opacity = dialog.user_data['boxes'][team+'_'+kind]['opacity'];
                    }
                } else {
                    ui_text = gamedata['tutorial']['click_on_rover_message'][team+'_'+kind+'_ui_name'];
                    box_color = gamedata['tutorial']['click_on_rover_message'][team+'_'+kind+'_color'] || 'rgba(60,255,150,';
                    if(team+'_'+kind+'_opacity' in gamedata['tutorial']['click_on_rover_message']) {
                        opacity = gamedata['tutorial']['click_on_rover_message'][team+'_'+kind+'_opacity'];
                    }
                }

                // draw transparent highlight box around enemy or friendly units
                var bounds = null;
                session.for_each_real_object(function(/** !GameObject */ obj) {
                    if(obj.team == team &&
                       ((kind=='rovers' && obj.is_mobile()) ||
                        (kind=='townhall' && obj.spec['name'] == gamedata['townhall']))) {

                        var points = [];
                        if(obj.is_building()) {
                            var gs = obj.spec['gridsize'];
                            goog.array.forEach([[-gs[0]/2,-gs[1]/2], // NW
                                                [gs[0]/2,-gs[1]/2], // NE
                                                [gs[0]/2,gs[1]/2], // SE
                                                [-gs[0]/2,gs[1]/2]], // SW
                                               function(offset) {
                                                   points.push(ortho_to_draw(vec_add(vec_scale(grid_pad, offset), obj.raw_pos())));
                                               });
                        } else {
                            points.push(ortho_to_draw(obj.raw_pos())); // center point
                        }

                        goog.array.forEach(points, function(xy) {
                            var pad = 25;
                            if(bounds === null) {
                                bounds = [[xy[0],xy[0]],[xy[1],xy[1]]];
                            } else {
                                bounds[0][0] = Math.min(bounds[0][0], xy[0]-pad);
                                bounds[0][1] = Math.max(bounds[0][1], xy[0]+pad);
                                bounds[1][0] = Math.min(bounds[1][0], xy[1]-pad);
                                bounds[1][1] = Math.max(bounds[1][1], xy[1]+pad);
                            }
                        });
                    }
                });

                if(bounds) {
                    bounds[0] = draw_quantize(bounds[0]); // mixes x and y coordinate math
                    bounds[1] = draw_quantize(bounds[1]); // mixes x and y coordinate math
                    var pad = 15;
                    bounds[0][0] -= pad; bounds[1][0] -= pad;
                    bounds[0][1] += pad; bounds[1][1] += pad;
                    bounds[0][0] -= 20; // addl left pad
                    bounds[1][0] -= 40; // addl top pad
                    bounds[0][1] += 30; // addl right pad

                    ctx.save();
                    set_playfield_draw_transform(ctx);
                    var c = box_color;
                    ctx.strokeStyle = c+(1-(1-opacity)*(1-opacity)).toString()+')';
                    ctx.fillStyle = c+opacity.toString()+')';
                    ctx.fillRect(bounds[0][0], bounds[1][0],
                                 bounds[0][1]-bounds[0][0],
                                 bounds[1][1]-bounds[1][0]);
                    ctx.strokeRect(bounds[0][0], bounds[1][0],
                                   bounds[0][1]-bounds[0][0],
                                   bounds[1][1]-bounds[1][0]);
                    if(ui_text) {
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText(ui_text, bounds[0][0]+pad, bounds[1][1]-pad);
                    }
                    ctx.restore();
                }
            }
        });
    });

    if(dialog.user_data['black_bar']) {
        // draw horizontal black bar behind Valentina dialog
        if(typeof dialog.user_data['black_bar'] == 'object') {
            var bar = dialog.user_data['black_bar'];
            if(bar['top']) {
                var h = Math.floor(bar['top']*canvas_height);
                dialog.widgets['black_bar_top'].show = true;
                dialog.widgets['black_bar_top'].xy = vec_scale(-1, dialog.get_absolute_xy());
                dialog.widgets['black_bar_top'].wh = [canvas_width, h];
                //ctx.fillRect(0, 0, canvas_width, h);
            }
            if(bar['bottom']) {
                var h = Math.floor(bar['bottom']*canvas_height);
                //ctx.fillRect(0, canvas_height - h, canvas_width, h);
                dialog.widgets['black_bar_bottom'].show = true;
                dialog.widgets['black_bar_bottom'].xy = vec_add([0, canvas_height-h], vec_scale(-1, dialog.get_absolute_xy()));
                dialog.widgets['black_bar_bottom'].wh = [canvas_width, h];
            }

        } else {
            ctx.save();
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas_width, dialog.xy[1] + dialog.wh[1] + 7);
            ctx.restore();
        }
    }
};

function tutorial_step_valentina_nonmodal_message(data) {
    var dialog_data = gamedata['dialogs']['tutorial_valentina_nonmodal_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    tutorial_nonmodal_ui = dialog;
    tutorial_root.add(dialog);

    dialog.ondraw = update_valentina_nonmodal_message;
    dialog.widgets['description'].str = eval_cond_or_literal(data['ui_description'], player, null);
    dialog.user_data['y_position'] = data['y_position'] || 0.3;
    dialog.user_data['black_bar'] = data['black_bar'] || false;
    dialog.user_data['enemy_rovers'] = data['enemy_rovers'] || false;
    dialog.user_data['player_rovers'] = data['player_rovers'] || false;
    if(data['bg_emphasis']) {
        dialog.widgets['bg'].widgets['bg'].asset = dialog.widgets['bg'].data['widgets']['bg']['asset_emphasis'];
    }
    if(dialog.user_data['enemy_rovers']) { session.has_attacked = true; }
    dialog.user_data['boxes'] = data['boxes'] || null;

    dialog.user_data['show_if'] = data['show_if'] ? read_predicate(data['show_if']) : null;

    // immediately proceed to next step, but don't clear the UI
    player.tutorial_state = data['next'];
    tutorial_step(false);
}

// maintain a tutorial arrow pointing to a feature on the regional map
function update_tutorial_arrow_for_region_map(_dialog, _my_home, _squad_id, _base_type, _base_template, _closest_to) {
    return (function (dialog, my_home, squad_id, base_type, base_template, closest_to) { return function() {
        var direction = 'down';
        var feature = null;
        var mapwidget = null;

        if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'region_map_dialog') {
            mapwidget = selection.ui.widgets['map'];
        }

        if(session.region) {
            if(my_home) {
                feature = session.region.find_home_feature();
            } else if(squad_id) {
                feature = session.region.find_feature_by_id(player.squad_base_id(squad_id));
            } else if(base_type || base_template) {
                // get list of all features that match these criteria
                var feature_list = session.region.find_features_by_type(base_type, base_template);
                if(closest_to === 'my_home') {
                    // sort by distance to home base
                    goog.array.sortByKey(feature_list, function(f) {
                        return hex_distance(player.home_base_loc, f['base_map_loc']);
                    });
                }
                feature = (feature_list.length >= 1 ? feature_list[0] : null);
            }
        }

        if(feature && mapwidget) {

            dialog.show = true;

            // hack - remove then add it back to make it on top (of the tutorial UI)
            var root = dialog.parent;
            if(root === tutorial_root) {
                root.unparent(dialog);
                root.add(dialog);
            }

            // widget coordinates of the center of the map cell
            var widget_xy = mapwidget.cell_to_widget(vec_add(feature['base_map_loc'], [0.5,0.5]));

            var xy = vec_add(mapwidget.get_absolute_xy(), widget_xy);

            // ?
            mapwidget.pan_to_cell(feature['base_map_loc'], {slowly:true});
            //mapwidget.zoom_all_the_way_in();

            dialog.user_data['reticle_loc'] = null;
            dialog.user_data['reticle_pos'] = vec_copy(xy);
            dialog.user_data['reticle_size'] = 70 * mapwidget.zoom;

            var arrow_dims = dialog.data['widgets']['arrow']['dimensions'];
            var wave = Math.floor(8*Math.sin(4*client_time));
            if(direction == 'down') {
                xy[1] -= arrow_dims[1] + Math.floor(20 * mapwidget.zoom);
            } else {
                xy[1] += Math.floor(arrow_dims[1]/2) - 10;
            }
            dialog.xy = [xy[0] - Math.floor(arrow_dims[0]/2),
                         xy[1] - 0];
            dialog.widgets['arrow'].xy = [0, wave];
            if(dialog.parent) { // might be ok to do this unconditionally
                dialog.xy = vec_sub(dialog.xy, dialog.parent.get_absolute_xy());
            }
        } else {
            dialog.show = false;
        }
    }; })(_dialog, _my_home, _squad_id, _base_type, _base_template, _closest_to);
}

// maintain a tutorial arrow pointing to a button on a specific UI dialog
function update_tutorial_arrow_for_button(_dialog, _parent_path, _widget_name, _direction) {
    return (function (dialog, parent_path, widget_name, direction) { return function() {
        var parent = null; // SPUI.Dialog hosting the widget to point at
        var parent_offset = [0,0]; // transformation stack
        var found_widget_name = widget_name; // name of widget to point at

        var parent_path_list = parent_path.split('/');

        // special case for desktop dialogs
        if(parent_path_list[0].indexOf("desktop_") === 0 || goog.array.contains(['attack_button_dialog','quest_bar','chat_frame'], parent_path_list[0])) {
            // pick desktop dialog directly
            parent = desktop_dialogs[parent_path_list[0]] || null;

            // handle entries in desktop_dialogs that are nested below other dialogs
            if(parent && parent.parent && parent.parent !== SPUI.root) {
                parent_offset = vec_add(parent_offset, parent.parent.get_absolute_xy());
            }

        } else if(parent_path_list[0].indexOf("_dialog") != -1 ||
                  parent_path_list[0].indexOf("_tab") != -1 ||
                  parent_path_list[0].indexOf("squad_") === 0 ||
                  parent_path_list[0].indexOf("_popup") != -1 ||
                  parent_path_list[0].indexOf("context_menu") != -1 ||
                  parent_path_list[0].indexOf("inventory_context") != -1 ||
                  parent_path_list[0].indexOf("tutorial") != -1 ||
                  parent_path_list[0] === "fullscreen_prompt") {

            // search for parent dialog by name
            var roots = [selection.ui, tutorial_root];

            for(var i = 0; i < roots.length && !parent; i++) {
                parent_offset = [0,0]; // reset offset
                var p = roots[i];

                while(p) {
                    if(p.user_data && ('dialog' in p.user_data) && match_dialog_name(parent_path_list[0], p.user_data['dialog'])) {
                        parent = p;
                        break; // found!
                    } else if(p.children && p.children.length > 0) {
                        parent_offset = vec_add(parent_offset, p.xy);
                        p = p.children[p.children.length-1]; // search final child
                    } else {
                        break; // dead end
                    }
                }
            }
        }

        // if the path has children, dive into sub-widgets
        if(parent) {
            for(var i = 1; i < parent_path_list.length; i++) {
                if(parent_path_list[i] in parent.widgets) {
                    parent_offset = vec_add(parent_offset, parent.xy);
                    parent = parent.widgets[parent_path_list[i]];
                } else {
                    parent = null; break;
                }
            }
        }

        if(!parent) {
            dialog.show = false;
            return;
        }

        // special-case hack to point at specific unit deployment
        // buttons when the order might change depending on what units
        // the player has and their damage state.
        if(widget_name && widget_name.indexOf('DEPLOY_UNIT:') == 0) {
            var spec_name = widget_name.split(':')[1];
            var ulist = desktop_dialogs['desktop_bottom'].user_data['deploy_button_specs'];
            found_widget_name = null;
            if(ulist) {
                for(var i = 0; i < ulist.length; i++) {
                    if(ulist[i] === spec_name) {
                        parent = desktop_dialogs['desktop_bottom'].widgets['unit_deployment_bar'].widgets['unit'+i.toString()];
                        parent_offset = desktop_dialogs['desktop_bottom'].widgets['unit_deployment_bar'].get_absolute_xy();
                        found_widget_name = 'plus_all';
                        break;
                    }
                }
            }
            if(!found_widget_name) {
                dialog.show = false; return;
            }
        } else if(widget_name && widget_name.indexOf('DEPLOY_SQUAD:') == 0) {
            var squad_id = parseInt(widget_name.split(':')[1], 10);
            var ulist = desktop_dialogs['desktop_bottom'].widgets['unit_deployment_bar'].user_data['deploy_button_squad_ids'];
            found_widget_name = null;
            if(ulist) {
                for(var i = 0; i < ulist.length; i++) {
                    if(ulist[i] === squad_id) {
                        parent = desktop_dialogs['desktop_bottom'].widgets['unit_deployment_bar'].widgets['squad'+i.toString()];
                        parent_offset = desktop_dialogs['desktop_bottom'].widgets['unit_deployment_bar'].get_absolute_xy();
                        found_widget_name = 'icon';
                        break;
                    }
                }
            }
            if(!found_widget_name) {
                dialog.show = false; return;
            }

        } else if(widget_name && widget_name.indexOf('BUILD:') == 0) {
            // similar special-case hack for Build dialog
            var spec_name = widget_name.split(':')[1];
            var slots = parent.user_data['slots_this_page'];
            found_widget_name = null;
            for(var i = 0; i < slots.length; i++) {
                if(slots[i][0] == spec_name) {
                    found_widget_name = 'grid'+(slots[i][1].toString())+','+(slots[i][2].toString());
                    break;
                }
            }
        } else if(widget_name && widget_name.indexOf('INVENTORY:') == 0) {
            // similar special-case hack for Inventory dialog
            var spec_name = widget_name.split(':')[1];
            var cols = parent.data['widgets']['slot']['array'][0];
            var slots_per_page = parent.user_data['rows_per_page'] * parent.user_data['cols_per_page'];
            found_widget_name = null;
            for(var y = 0; y < parent.data['widgets']['slot']['array'][1]; y++) {
                for(var x = 0; x < cols; x++) {
                    var wname = x.toString()+','+y.toString();
                    var slot = y*cols + x + parent.user_data['page'] * slots_per_page;
                    if(slot < player.inventory.length) {
                        var item = player.inventory[slot];
                        if(item['spec'] === spec_name) {
                            found_widget_name = 'frame'+wname;
                            break;
                        }
                    }
                }
                if(found_widget_name) { break; }
            }
        } else if(widget_name && widget_name.indexOf('MAP:') == 0) {
            var chapter = widget_name.split(':')[1];
            var index = parent.user_data['buttons'].indexOf(chapter);
            if(index >= 0) {
                found_widget_name = 'button'+index.toString();
            }
        } else if(widget_name && widget_name.indexOf('MAP_AI:') == 0) {
            var base_id = parseInt(widget_name.split(':')[1], 10);
            var entry = goog.array.findIndex(parent.user_data['friends_on_page'], function(fr) { return fr.user_id === base_id; });
            if(entry >= 0) {
                found_widget_name = 'row_button'+entry.toString();
            }
        } else if(widget_name && widget_name.indexOf('BUTTON:') == 0 /* && parent.user_data['buttons'] */) {
            // XXX somehow we were getting here with parent.user_data missing 'buttons'. Band-aid fix for now.
            var spellname = widget_name.split(':')[1];
            var index = goog.array.findIndex(parent.user_data['buttons'], function(but) { return but.spellname === spellname;});
            if(index >= 0) {
                found_widget_name = 'button'+index.toString();
            }
        } else if(widget_name && widget_name.indexOf('MAP_FINDER:') == 0) {
            var kind = widget_name.split(':')[1];
            found_widget_name = null;
            if('finder_states' in parent.user_data &&
               (kind in parent.user_data['finder_states']) &&
               !(parent.widgets.map.popup)) {
                var upd = region_map_finder_update(parent, kind, parent.user_data['finder_states'][kind]);
                if(upd.show) {
                    if(parent.user_data['finder_expanded']) {
                        if(kind in parent.user_data['finder_button_indexes']) {
                            var index = parent.user_data['finder_button_indexes'][kind];
                            if(index >= 0) {
                                found_widget_name = 'misc_finder'+index.toString();
                            }
                        }
                    } else {
                        // point to expand button
                        found_widget_name = 'finder_toggle';
                    }
                }
            }
        } else if(widget_name && widget_name.indexOf('MAP_POPUP:') == 0) {
            // one of the buttons on the region_map_popup_menu. parent dialog should be "region_map_dialog".
            var kind = widget_name.split(':')[1];
            found_widget_name = null;
            if(parent.widgets.map.popup && parent.widgets.map.popup.user_data['menu']) {
                parent_offset = parent.widgets.map.popup.get_absolute_xy();
                parent = parent.widgets.map.popup.user_data['menu'];
                var index = parent.user_data['visible_buttons'].indexOf(kind);
                if(index >= 0) {
                    found_widget_name = 'button'+index.toString();

                }
            }
        }



        var btn = parent.widgets[found_widget_name];
        if(!btn) {
            dialog.show = false;
            return;
        }

        dialog.show = true;

        // copy any animation the parent dialog is doing
        dialog.transform = parent.transform;

        // copy opacity of parent widget
        if(btn.alpha !== undefined) {
            dialog.widgets['arrow'].alpha = btn.alpha;
        } else {
            dialog.widgets['arrow'].alpha = 1;
        }

        // hack - remove then add it back to make it on top (of the tutorial UI)
        var root = dialog.parent;
        if(root === tutorial_root) {
            root.unparent(dialog);
            root.add(dialog);
        }

        var arrow_dims = dialog.data['widgets']['arrow']['dimensions'];

        var xy = vec_add(vec_add(parent.xy, parent_offset), btn.xy);
        // point at center of widget
        xy = vec_floor(vec_add(xy, vec_scale(0.5, btn.wh)));

        if(direction == 'left' || direction == 'right') {
            xy[1] -= Math.floor(arrow_dims[1]/2); // point at vertical center

            // leave a little space between the arrow tip and target
            if(direction == 'left') {
                xy[0] += Math.floor(0.1*arrow_dims[0]);
            } else {
                xy[0] -= arrow_dims[0] + Math.floor(0.1*arrow_dims[0]); // move dialog so tip points at target
            }
        } else {
            xy[0] -= Math.floor(arrow_dims[0]/2); // point at horizontal center
            if(direction == 'down') {
                xy[1] -= arrow_dims[1]; // move dialog so tip points at target
            } else { // assume "up"
                xy[1] += Math.floor(0.1*arrow_dims[1]); // move the dialog down to leave a little space between the arrow tip and target
            }
        }

        dialog.xy = xy;
        if(dialog.parent) { // might be ok to do this unconditionally
            dialog.xy = vec_sub(dialog.xy, dialog.parent.get_absolute_xy());
        }

        // animate the arrow moving up and down
        var wave = [0,0];
        if(direction == 'left' || direction == 'right') {
            // left/right
            wave[0] = Math.floor((dialog.user_data['wave_amplitude']||10)*(Math.sin(4*client_time)+(direction=='down'?-0.25:0.25)));
        } else {
            // up or down
            wave[1] = Math.floor((dialog.user_data['wave_amplitude']||10)*(Math.sin(4*client_time)+(direction=='down'?-0.25:0.25)));
        }

        var tip_y_canvas = dialog.get_absolute_xy()[1] + (direction == 'down' ? dialog.wh[1] + 10 : 10);
        var tip_y_client = canvas_div_offsetTop + tip_y_canvas;
        var client_height;

        if(fb_iframe_dims !== null && fb_iframe_offset !== null && fb_iframe_scroll !== null) {
            // use FB API-provided info about the iframe container to transform to browser-window coordinates
            client_height = fb_iframe_dims[1] - fb_iframe_offset[1] + fb_iframe_scroll[1];
        } else {
            // use natural window height (DOES NOT WORK WHEN IFRAMED!)
            client_height = window.innerHeight;
        }

        if((spin_frame_platform == 'kg' || spin_frame_platform == 'k2') && dialog.user_data['scroll_down_hack']) {
            // KG leaves us with no choice to figure out if the arrow is off screen, so use this ugly hack
            dialog.widgets['arrow'].show = true;
            dialog.widgets['scroll'].show = dialog.widgets['scroll_bg'].show = false;
            if('scroll_arrow' in dialog.widgets) { dialog.widgets['scroll_arrow'].show = false; }
            if('scroll_down_hack' in dialog.data['widgets']) {
                for(var i = 0; i < dialog.data['widgets']['scroll_down_hack']['array'][1]; i++) {
                    dialog.widgets['scroll_down_hack'+i.toString()].show = true;
                    dialog.widgets['scroll_down_hack'+i.toString()].alpha = dialog.data['widgets']['scroll_down_hack']['alpha'] * Math.pow(i, -1.25);
                }
            }

        } else if((tip_y_client + 10 >= client_height)) {
            // check for case where the bottom of the arrow would be below the visible window area
            dialog.widgets['scroll'].show = dialog.widgets['scroll_bg'].show = true;
            if('scroll_arrow' in dialog.widgets) {
                dialog.widgets['scroll_arrow'].show = true;
                dialog.widgets['arrow'].show = false;
            } else {
                dialog.widgets['arrow'].show = true;
            }
            dialog.xy[1] -= (tip_y_client - client_height) - 10;
            wave = vec_scale(0.25, wave); // less motion
        } else {
            dialog.widgets['scroll'].show = dialog.widgets['scroll_bg'].show = false;
            if('scroll_arrow' in dialog.widgets) { dialog.widgets['scroll_arrow'].show = false; }
            dialog.widgets['arrow'].show = true;
        }

        dialog.xy = vec_floor(vec_add(dialog.xy, wave));

    }; })(_dialog, _parent_path, _widget_name, _direction);
}

// maintain a tutorial arrow pointing to a place on the landscape
// if unit_name is non-null, the arrow points to the unit with that name
// otherwise, it points to grid location 'loc'
function update_tutorial_arrow_for_landscape(_dialog, _unit_name, _loc, _direction, _buildable) {
    return (function (dialog, unit_name, loc, direction, buildable) { return function() {
        dialog.show = true;
        dialog.user_data['reticle_loc'] = null;
        dialog.user_data['reticle_pos'] = null;
        dialog.user_data['reticle_size'] = 0;

        var unit = null;
        var reticle_size = 0;
        if(unit_name) {
            unit = find_object_by_type(unit_name);
            if(unit) {
                var effsize = ('unit_collision_gridsize' in unit.spec && unit.spec['unit_collision_gridsize'][0] > 0 ? unit.spec['unit_collision_gridsize'] : unit.spec['gridsize'])[0];
                reticle_size = 10 * effsize;
            } else {
                dialog.show = false;
            }
        }

        var xy;
        if(unit_name && unit) {
            var myloc = unit.raw_pos();
            dialog.user_data['reticle_loc'] = myloc;
            xy = ortho_to_screen(myloc);
            xy[0] -= 4; xy[1] -= 4;
            dialog.user_data['reticle_pos'] = [xy[0],xy[1]];
        } else if(loc != null) {
            if(buildable) {
                // shift location if necessary to find space to build a building
                var original_loc = loc;
                loc = find_valid_building_location(loc, buildable);
                if(!loc) { loc = original_loc; } // give up
            }
            dialog.user_data['reticle_loc'] = loc;
            xy = ortho_to_screen(loc);
            dialog.user_data['reticle_pos'] = [xy[0],xy[1]];
            reticle_size = 50;
        } else {
            xy = [0,0];
        }

        dialog.user_data['reticle_size'] = ('override_reticle_size' in dialog.user_data ?
                                            dialog.user_data['override_reticle_size'] :
                                            reticle_size);

        var arrow_dims = dialog.data['widgets']['arrow']['dimensions'];
        var wave = Math.floor(8*Math.sin(4*client_time));
        if(direction == 'down') {
            xy[1] -= arrow_dims[1] + 40;
        } else {
            xy[1] += Math.floor(arrow_dims[1]/2) - 10;
        }
        dialog.xy = [xy[0] - Math.floor(arrow_dims[0]/2),
                     xy[1] - 0];
        dialog.widgets['arrow'].xy = [0, wave];
    }; })(_dialog, _unit_name, _loc, _direction, _buildable);
}

function tutorial_arrow_draw_reticle(dialog, offset) {
    if(!dialog.user_data['reticle_pos'] || !dialog.user_data['reticle_size']) { return; }
    var xy = dialog.user_data['reticle_pos'];
    var size = view_zoom*dialog.user_data['reticle_size'];
    ctx.save();
    ctx.strokeStyle = 'rgba(0,255,255,1.0)';
    ctx.beginPath();
    ctx.arc(Math.floor(xy[0]), Math.floor(xy[1]), size, 0, 2*Math.PI, false);
    ctx.moveTo(Math.floor(xy[0]-size), Math.floor(xy[1]));
    ctx.lineTo(Math.floor(xy[0]-1.8*size), Math.floor(xy[1]));
    ctx.moveTo(Math.floor(xy[0]+size), Math.floor(xy[1]));
    ctx.lineTo(Math.floor(xy[0]+1.8*size), Math.floor(xy[1]));
    ctx.stroke();
    ctx.restore();
}

function make_ui_arrow(direction) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['tutorial_arrow_'+direction]);
    dialog.transparent_to_mouse = true;
    return dialog;
}

function make_tutorial_arrow_for_button(parent_path, widget_name, direction) {
    var dialog = make_ui_arrow(direction);
    tutorial_ui = dialog;
    tutorial_root.add(dialog);
    dialog.ondraw = update_tutorial_arrow_for_button(dialog, parent_path, widget_name, direction);
    return dialog;
}

function make_tutorial_arrow_for_landscape(unit_name, loc, direction) {
    var dialog = make_ui_arrow(direction);
    tutorial_ui = dialog;
    tutorial_root.add(dialog);
    dialog.ondraw = update_tutorial_arrow_for_landscape(dialog, unit_name, loc, direction, null);
    dialog.afterdraw = tutorial_arrow_draw_reticle;
    return dialog;
}

function tutorial_step_move_rover_action_command() {
    // called when player issues any command to a rover
    // put all friendly rovers into AI_ATTACK_ANY state so they fire as soon as enemies are in range
    if(player.get_any_abtest_value('tut_battle_interact', gamedata['client']['tut_battle_interact']) != 'manual') {
        session.for_each_real_object(function(obj) {
            if(obj.is_mobile() && obj.team === 'player') {
                var order = {'state': ai_states.AI_ATTACK_ANY};
                obj.new_order(session.get_real_world(), order, true);
            }
        });
    }
    advance_tutorial();
}

function tutorial_step_repair_message(data) {

    // switch back to calm bg music
    change_backdrop_music(/** @type {!GameArt.Sprite} */ (GameArt.assets['background_music'].states['normal']).audio);

    var dialog_data = gamedata['dialogs']['tutorial_repair_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'tutorial_repair_message';
    tutorial_ui = dialog;
    tutorial_root.add(dialog);

    dialog.auto_center();

    dialog.widgets['description'].str = data['ui_description'];

    var closure = (function (next) { return function() {
        var cc = find_object_by_type(gamedata['townhall']);
        if(!cc) { throw Error('townhall not found!'); }
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "REPAIR", session.viewing_base.base_id]);
        player.tutorial_state = next;
        if(!cc.is_damaged()) {
            // if player somehow repaired already, skip the wait_for_repairs step
            player.tutorial_state = gamedata['tutorial'][next]['next'];
        }
        tutorial_step(true);
    }; })(data['next']);

    dialog.widgets['use_resources_button'].onclick = (function (cl) { return function() {
        metric_event('0190_tutorial_start_repairs', {});
        cl();
    }; })(closure);
    dialog.widgets['instant_button'].onclick = (function (cl) { return function() {
        metric_event('0200_tutorial_instant_repair', {});
        cl();
    }; })(closure);

    if(data['use_resources_button_arrow']) {
        var dir = 'down';
        var arrow = make_ui_arrow(dir);
        dialog.add(arrow);
        arrow.ondraw = update_tutorial_arrow_for_button(arrow, 'tutorial_repair_message', 'use_resources_button', dir);
    }
}


// note: this is used for both the tutorial step and the on-login invite friends prompt
function setup_invite_friends_prompt(dialog, reason) {
    dialog.user_data['invite_friends_reason'] = reason;

    dialog.widgets['title'].set_text_with_linebreaking_and_shrink_font_to_fit(dialog.data['widgets']['title']['ui_name'].replace('%game', gamedata['strings']['game_name']));

    /** @type {string} */
    var value_prop;
    // customize text per platform
    if('ui_name_'+spin_frame_platform in dialog.data['widgets']['value_prop']) {
        value_prop = dialog.data['widgets']['value_prop']['ui_name_'+spin_frame_platform];
    } else {
        value_prop = dialog.data['widgets']['value_prop']['ui_name'];
    }
    dialog.widgets['value_prop'].set_text_with_linebreaking(value_prop.replace('%game', gamedata['strings']['game_name']));

    var num_friends = 0;
    var friend_name = '';

    for(var i = 0; i < player.friends.length; i++) {
        var friend = player.friends[i];
        if(!friend.is_ai() && friend.is_real_friend) {
            num_friends += 1;
            if(!friend_name) {
                friend_name = friend.get_ui_name();
            }
        }
    }

    var proof = '';

    if(num_friends < 1) {
        proof = dialog.data['widgets']['social_proof']['ui_name_has_no_friends'];
    } else if(num_friends < 2) {
        proof = dialog.data['widgets']['social_proof']['ui_name_has_one_friend'];
    } else if(num_friends < 3) {
        proof = dialog.data['widgets']['social_proof']['ui_name_has_two_friends'];
    } else {
        proof = dialog.data['widgets']['social_proof']['ui_name_has_many_friends'];
    }

    dialog.widgets['social_proof'].set_text_with_linebreaking(proof.replace('%game', gamedata['strings']['game_name']).replace('%s', friend_name).replace('%d', pretty_print_number(num_friends-1)));

    // fill in friend widgets
    var row = 0;
    var n_widgets = 5;
    for(i = 0; i < player.friends.length && row < n_widgets; i++) {
        var friend = player.friends[i];
        if(friend.is_ai() || !friend.is_real_friend) { continue; }
        dialog.widgets['friend_icon'+row].set_user(friend.user_id);
        row++;
    }

    // "direct_share" means we'll skip friend selector / membership rewards
    // and just offer to share a "join the game" link.

    var direct_share = (spin_frame_platform === 'fb'); // as of April 2018, this is the only method that works on FB

    if(direct_share) {
        dialog.widgets['ok_button'].show = false;
        dialog.widgets['fb_share_button'].show =
            dialog.widgets['fb_share_icon'].show = true;
        dialog.default_button = dialog.widgets['fb_share_button'];
        dialog.widgets['fb_share_button'].onclick = function(w) {
            var reason = w.parent.user_data['invite_friends_reason'];
            close_parent_dialog(w); // regardless of success or failure, close the prompt. (don't be too pushy...)
            invoke_invite_friends_dialog_fb_alternative(reason);
        };
    } else {
        dialog.widgets['ok_button'].show = true;
        dialog.widgets['fb_share_button'].show =
            dialog.widgets['fb_share_icon'].show = false;
        dialog.default_button = dialog.widgets['ok_button'];
        if('ui_name_'+spin_frame_platform in dialog.widgets['ok_button'].data) {
            dialog.widgets['ok_button'].str = dialog.widgets['ok_button'].data['ui_name_'+spin_frame_platform];
        }

        dialog.widgets['ok_button'].onclick = function(w) {
            // note: there used to be a special case here for the rails tutorial,
            // but it's no longer relevant because the invite prompt was moved
            // into the new quest-based tutorial system.
            var reason = w.parent.user_data['invite_friends_reason'];
            change_selection(null);
            invoke_invite_friends_dialog(reason);
        };
    }
}

function invoke_invite_friends_prompt(reason) {
    if(!friend_invites_enabled()) { return null; }

    change_selection(null);

    var dialog_data = gamedata['dialogs']['tutorial_congratulations'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'tutorial_congratulations';
    change_selection_ui(dialog);

    dialog.modal = true;
    dialog.auto_center();

    setup_invite_friends_prompt(dialog, reason);

    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    if(!read_predicate(gamedata['client']['invite_prompt_closeable']).is_satisfied(player)) {
        dialog.widgets['close_button'].show = 0;
    } else {
        dialog.widgets['close_button'].show = 1;
    }

    return dialog;
}

function tutorial_step_congratulations(data) {
    change_selection(null);

    if(player.get_any_abtest_value('tutorial_delay_invite', true)) { advance_tutorial(); advance_tutorial(); return; }

    var dialog_data = gamedata['dialogs']['tutorial_congratulations'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'tutorial_congratulations';
    tutorial_nonmodal_ui = dialog;
    tutorial_root.add(dialog);

    dialog.auto_center();

    setup_invite_friends_prompt(dialog, 'tutorial_step_congratulations');

    dialog.widgets['close_button'].show = false;

    // have to set a timer in case dialog goes away without clicking 'OK'
    window.setTimeout(function() {
        if(player.tutorial_state === 'congratulations_message') {
            advance_tutorial();
        }
    }, 20000);

    make_tutorial_arrow_for_button('tutorial_congratulations', 'ok_button', 'up');
    make_tutorial_arrow_for_button('tutorial_congratulations', 'fb_share_button', 'up');

    GameArt.play_canned_sound('conquer_sound');
}

function tutorial_step_invite_friends(data) {
    change_selection(null);
    if(!friend_invites_enabled()) { advance_tutorial(); return; }
    invoke_invite_friends_dialog('tutorial_step_invite_friends');
    if(player.tutorial_state === 'invite_friends') {
        advance_tutorial();
    }
}

/** @param {string} title_text
    @param {string} body_text
    @param {Object=} props */
function invoke_message_dialog(title_text, body_text, props) {
    if(typeof props == 'undefined') { props = {}; }

    var dialog_data = gamedata['dialogs'][props['dialog'] || 'message_dialog'];

    // instantiate the dialog
    var dialog = new SPUI.Dialog(dialog_data);

    // make the dialog modal and add it to the "desktop"
    if(!props.parentless) {
        change_selection_ui(dialog);
        dialog.auto_center();
        dialog.modal = true;
    }

    dialog.widgets['title'].str = title_text;
    if('title_text_color' in props) {
        dialog.widgets['title'].text_color = SPUI.make_colorv(props['title_text_color']);
    }

    if(props['use_bbcode']) {
        dialog.widgets['description_bbcode'].set_text_bbcode(body_text, {}, system_chat_bbcode_click_handlers);
        dialog.widgets['description_bbcode'].show = true;
        dialog.widgets['description'].show = false;
    } else {
        dialog.widgets['description'].set_text_with_linebreaking(body_text);
    }

    if('close_button' in props && !props['close_button']) {
        dialog.widgets['close_button'].show = false;
    }
    if('cancel_button' in props && props['cancel_button']) {
        dialog.widgets['cancel_button'].show = true;
    }

    var make_go_away = function (_action) { return function() { change_selection(null); if(_action) { _action(); } }; };
    if('close_button' in dialog.widgets) { dialog.widgets['close_button'].onclick = make_go_away(null); }
    dialog.widgets['ok_button'].onclick = make_go_away(props['on_ok'] || null);
    if('ok_button_ui_name' in props) { dialog.widgets['ok_button'].str = props['ok_button_ui_name']; }
    if('ok_button_state' in props) { dialog.widgets['ok_button'].state = props['ok_button_state']; }
    if('ok_button_tooltip' in props) { dialog.widgets['ok_button'].tooltip.str = props['ok_button_tooltip']; }
    if('cancel_button' in dialog.widgets) { dialog.widgets['cancel_button'].onclick = dialog.widgets['close_button'].onclick; }
    return dialog;
}

// same as above but presents message as a child of the current selection.ui
/** @param {string} title_text
    @param {string} body_text
    @param {Object=} props */
function invoke_child_message_dialog(title_text, body_text, props) {
    if(typeof props == 'undefined') { props = {}; }

    // note: this should ideally be a check to make sure selection.ui inherits from SPUI.Container
    if(!selection.ui || !selection.ui.add) {
        return invoke_message_dialog(title_text, body_text, props);
    }

    var dialog_template_name = props['dialog'] || 'message_dialog';
    var dialog_data = gamedata['dialogs'][dialog_template_name];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = dialog_template_name;

    if(!props.parentless) {
        /* XXXXXX this code is actually more correct - try it sometime
           dialog.modal = true;
           install_child_dialog(dialog);
           dialog.auto_center();
        */
        dialog.xy[0] = Math.floor((selection.ui.wh[0]-dialog.wh[0])/2);
        dialog.xy[1] = Math.floor((selection.ui.wh[1]-dialog.wh[1])/2);
        dialog.modal = true;
        selection.ui.add(dialog);
    }

    dialog.widgets['title'].str = title_text;
    if('title_text_color' in props) {
        dialog.widgets['title'].text_color = SPUI.make_colorv(props['title_text_color']);
    }

    if(props['use_bbcode']) {
        dialog.widgets['description_bbcode'].set_text_bbcode(body_text, {}, system_chat_bbcode_click_handlers);
        dialog.widgets['description_bbcode'].show = true;
        dialog.widgets['description'].show = false;
    } else {
        dialog.widgets['description'].set_text_with_linebreaking(body_text);
    }

    if('close_button' in props && !props['close_button']) {
        dialog.widgets['close_button'].show = false;
    }
    if('ok_button' in props && !props['ok_button']) {
        dialog.widgets['ok_button'].show = false;
    }
    if('cancel_button' in props && props['cancel_button']) {
        dialog.widgets['cancel_button'].show = true;
    }

    var make_go_away = function (_action) { return function(w) {
        close_parent_dialog(w);
        player.quest_tracked_dirty = true;
        if(_action) { _action(); }
    }; };
    if('close_button' in dialog.widgets) { dialog.widgets['close_button'].onclick = make_go_away(props['on_cancel'] || null); }
    if('cancel_button' in dialog.widgets) { dialog.widgets['cancel_button'].onclick = dialog.widgets['close_button'].onclick; }

    dialog.widgets['ok_button'].onclick = make_go_away(props['on_ok'] || null);
    if('ok_button_ui_name' in props) { dialog.widgets['ok_button'].str = props['ok_button_ui_name']; }
    if('ok_button_state' in props) { dialog.widgets['ok_button'].state = props['ok_button_state']; }
    if('ok_button_tooltip' in props) { dialog.widgets['ok_button'].tooltip.str = props['ok_button_tooltip']; }
    return dialog;
}

/** Same parameters as invoke_child_message_dialog(). If the Region Map is up, use the nonmodal error log there,
    otherwise display a conventional error.
    @param {string} title_text
    @param {string} body_text */
function invoke_squad_error(title_text, body_text) {
    var map_dialog = (selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] === 'region_map_dialog') ? selection.ui : null;

    if(player.preferences['nonmodal_squad_errors'] && map_dialog) {
        body_text = body_text.replace(/\n/g, ' '); // get rid of newlines
        region_map_display_notification(map_dialog, '[color=#ffff00]'+title_text + ': ' + body_text+'[/color]');
        GameArt.play_canned_sound('error_sound'); // play a sound so player knows something happened
        return;
    }

    var dialog = invoke_child_message_dialog(title_text, body_text, {'dialog': 'message_dialog_big'});

    if(map_dialog) { // offer preference setting only if region map displayed - otherwise may hit non-map players
        dialog.widgets['ignore_button'].show = true;
        dialog.widgets['ignore_button'].onclick = function(w) {
            w.state = (w.state == 'active' ? 'normal' : 'active');
            player.preferences['nonmodal_squad_errors'] = (w.state == 'active' ? 1 : 0);
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
        };
    }
}

function invoke_insufficient_alloy_message(reason, amount, order) {
    if(player.get_any_abtest_value('skip_insufficient_gamebucks', gamedata['store']['skip_insufficient_gamebucks'])) {
        return invoke_buy_gamebucks_dialog(reason, amount, order);
    }

    var dialog_data = gamedata['dialogs']['insufficient_alloy_message'];
    var dialog = new SPUI.Dialog(dialog_data);

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var ui_alloy = Store.gamebucks_ui_name();
    dialog.widgets['title'].str = dialog.widgets['title'].data['ui_name'].replace('%s', ui_alloy);
    dialog.widgets['ok_button'].str = dialog.widgets['ok_button'].data['ui_name'].replace('%s', ui_alloy);

    var text = SPText.cstring_to_ablocks_bbcode(dialog.data['widgets']['description']['ui_name'].replace('%cur', Store.display_user_currency_amount(player.resource_state['gamebucks'], 'compact')).replace('%gamebucks1',ui_alloy).replace('%gamebucks2',ui_alloy).replace('%need', Store.display_user_currency_amount(amount, 'compact')));
    dialog.widgets['description'].append_text(text);

    dialog.widgets['alloy_icon'].bg_image = player.get_any_abtest_value('gamebucks_icon_med', gamedata['store']['gamebucks_icon_med']);

    dialog.widgets['alloy_icon'].onclick =
        dialog.widgets['ok_button'].onclick = (function (_dialog, _reason, _amount, _order) { return function(w) {
            close_parent_dialog(w);
            invoke_buy_gamebucks_dialog(_reason, -1, _order); // raw dialog
        }; })(dialog, reason, amount, order);
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    purchase_ui_event('4400_insufficient_gamebucks_message', {'method': reason});
    return dialog;
}

/** @param {Object.<string,number>} cost
    @param {string} headline
    @param {string=} extra */
function invoke_insufficient_resources_message(cost, headline, extra) {
    if(!extra) { extra = ''; }
    var ls = [];
    for(var res in cost) {
        // cost sometimes includes "time" so check if it's actually a resource
        if(res in gamedata['resources'] && player.resource_state[res][1] < cost[res]) {
            ls.push(gamedata['resources'][res]['ui_name']);
        }
    }
    var resname = ls.join('/');
    invoke_child_message_dialog(headline, gamedata['strings']['more_resources_needed'].replace('%res',resname) + ' '+extra);
}

/** @param {Object.<string,number>} cost
    @param {number=} squad_id */
function invoke_insufficient_resources_for_repair_message(cost, squad_id) {
    var helper;
    var options = {};

    // continuation callback to start squad repair
    var cbmaker = function (_squad_id) { return function() {
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_REPAIR_QUEUE", _squad_id]);
    }; };

    if(player.squads_enabled() && (squad_id || squad_id===0) && player.squads && (squad_id.toString() in player.squads)) {
        cost['squad_id'] = squad_id;
        helper = get_requirements_help('insufficient_resources_to_repair_squad', cost, {continuation:cbmaker(squad_id)});
    } else {
        helper = get_requirements_help('insufficient_resources_to_repair_units', cost, {continuation:cbmaker(SQUAD_IDS.BASE_DEFENDERS)});
    }

    if(helper) {
        helper();
    } else {
        invoke_insufficient_resources_message(cost, gamedata['errors']['INSUFFICIENT_RESOURCES_TO_REPAIR']['ui_name']);
    }
}

function invoke_speedup_dialog(kind) {
    var dialog = do_invoke_speedup_dialog(kind);
    if(!dialog) { return null; }
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.widgets['close_button'].onclick = (player.tutorial_state == "COMPLETE" ? function() { change_selection(null); } : null);
    if(player.tutorial_state == 'speedup_click_finish') { dialog.widgets['close_button'].show = false; }
    return dialog;
}

function invoke_child_speedup_dialog(kind) {
    if(!selection.ui || !selection.ui.add) {
        return invoke_speedup_dialog(kind);
    }
    var dialog = do_invoke_speedup_dialog(kind);
    if(!dialog) { return null; }
    dialog.modal = true;
    //selection.ui.add(dialog);
    //dialog.xy[0] = Math.floor((selection.ui.wh[0]-dialog.wh[0])/2);
    //dialog.xy[1] = Math.floor((selection.ui.wh[1]-dialog.wh[1])/2);
    install_child_dialog(dialog);
    dialog.auto_center();

    dialog.widgets['close_button'].onclick = (player.tutorial_state == "COMPLETE" ? close_parent_dialog : null);
    if(player.tutorial_state == 'speedup_click_finish') { dialog.widgets['close_button'].show = false; }

    return dialog;
}

// note: 'kind' must be 'speedup' (for a manual speedup) or 'busy'
// (for the error you get when attempting an action that requires the
// foreman to be free, and the foreman isn't free)
function do_invoke_speedup_dialog(kind) {
    if(!selection.unit) { throw Error('nothing selected'); }

    var dialog_data = gamedata['dialogs']['speedup_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'speedup_dialog';

    dialog.modal = true;

    // show the title and description corresponding to the kind of speedup

    dialog.widgets['title_'+kind].show = true;

    var time_left = selection.unit.time_until_finish();
    var min_left = Math.floor(time_left/60);
    if(min_left < 1) { min_left = 1; }

    var description_finish;
    if(selection.unit.is_building() && selection.unit.is_repairing()) {
        description_finish = gamedata['strings']['speedup']['finish_repairing'].replace('%s', selection.unit.spec['ui_name']);
    } else if(selection.unit.is_building() && selection.unit.is_under_construction()) {
        description_finish = gamedata['strings']['speedup']['finish_building'].replace('%s', selection.unit.spec['ui_name']);
    } else if(selection.unit.is_building() && selection.unit.is_upgrading()) {
        description_finish = gamedata['strings']['speedup']['finish_upgrading'].replace('%s', selection.unit.spec['ui_name']);
    } else if(selection.unit.is_removing()) {
        description_finish = gamedata['strings']['speedup']['finish_removing'].replace('%s', selection.unit.spec['ui_name']);
    } else if(selection.unit.is_building() && selection.unit.is_enhancing()) {
        // reuse the finish_upgrading text (?)
        description_finish = gamedata['strings']['speedup']['finish_upgrading'].replace('%s', selection.unit.spec['ui_name']);
    } else if(selection.unit.is_building() && selection.unit.is_researching()) {
        var techname = selection.unit.research_item;
        if(techname in player.tech) {
            description_finish = gamedata['strings']['speedup']['finish_tech_upgrade'].replace('%s', gamedata['tech'][selection.unit.research_item]['ui_name']);
        } else {
            description_finish = gamedata['strings']['speedup']['finish_tech_unlock'].replace('%s', gamedata['tech'][selection.unit.research_item]['ui_name']);
        }
    } else if(selection.unit.is_building() && selection.unit.is_crafting()) {
        if(selection.unit.is_crafting_grid_weapon()) {
            time_left = selection.unit.crafting_time_left_all();
        }
        if(selection.unit.is_emplacement()) {
            var product = selection.unit.turret_head_inprogress_item();
            var ui_name = ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(product['spec']));
            description_finish = gamedata['strings']['speedup']['finish_turret_head'].replace('%s', ui_name);
        } else if(selection.unit.is_security_node()) {
            var product = selection.unit.security_node_inprogress_item();
            var ui_name = ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(product['spec']));
            description_finish = gamedata['strings']['speedup']['finish_security_node'].replace('%s', ui_name);
        } else if(selection.unit.is_trapped_barrier()) {
            var product = selection.unit.barrier_trap_inprogress_item();
            var ui_name = ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(product['spec']));
            description_finish = gamedata['strings']['speedup']['finish_barrier_trap'].replace('%s', ui_name);
        } else if(selection.unit.is_armed_building()) {
            var product = selection.unit.building_weapon_inprogress_item();
            var ui_name = ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(product['spec']));
            description_finish = gamedata['strings']['speedup']['finish_building_weapon'].replace('%s', ui_name);
        } else if(selection.unit.is_armed_townhall()) {
            var product = selection.unit.townhall_weapon_inprogress_item();
            var ui_name = ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(product['spec']));
            description_finish = gamedata['strings']['speedup']['finish_townhall_weapon'].replace('%s', ui_name);
        } else {
            description_finish = gamedata['strings']['speedup']['finish_crafting'].replace('%s', selection.unit.spec['ui_name']);
        }
    } else if(selection.unit.is_building() && selection.unit.is_manufacturing()) {
        description_finish = gamedata['strings']['speedup']['finish_manufacturing'].replace('%s', selection.unit.spec['ui_name']);
    } else {
        console.log('Unhandled case in invoke_speedup_dialog()');
        change_selection_ui(null);
        return null;
    }

    var description_before;
    if(kind === 'busy') {
        description_before = gamedata['strings']['speedup']['before_building'];
    } else if(kind === 'production') {
        description_before = gamedata['strings']['speedup']['before_manufacturing'];
    } else if(kind === 'research') {
        description_before = gamedata['strings']['speedup']['before_research'];
    } else if(kind === 'crafting') {
        description_before = gamedata['strings']['speedup']['before_crafting'];
    } else {
        description_before = gamedata['strings']['speedup']['before_generic'];
    }

    var description = gamedata['strings']['speedup']['template'].replace('%TIME',pretty_print_time(time_left)).replace('%FINISH', description_finish).replace('%BEFORE', description_before);
    dialog.widgets['description'].set_text_with_linebreaking(description);

    var price, closure;
    price = Store.get_user_currency_price(selection.unit.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null);
    if(price == 0) {
        closure = (function (unit) {
            return function(w) {
                send_to_server.func(["CAST_SPELL", unit.id, "SPEEDUP_FOR_FREE"]);
                invoke_ui_locker(unit.request_sync(), (function (_w) { return function() { close_parent_dialog(_w); }; })(w));
            };
        })(selection.unit);
    } else {
        closure = (function (unit) {
            return function(w) {
                var dialog = w.parent;

                // update price since time may have passed
                var new_price = Store.get_user_currency_price(unit.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null);
                if(new_price === 0) {
                    // convert to free speedup
                    send_to_server.func(["CAST_SPELL", unit.id, "SPEEDUP_FOR_FREE"]);
                    invoke_ui_locker(unit.request_sync(), (function (_w) { return function() { close_parent_dialog(_w); }; })(w));
                } else if(new_price < 0) {
                    // order became invalid, maybe the building finished what it was doing
                    close_parent_dialog(w);
                } else {
                    if(Store.place_user_currency_order(unit.id, "SPEEDUP_FOR_MONEY", null,
                                                       (function (_w) { return function() { close_parent_dialog(_w); }; })(w)
                                                      )) {
                        invoke_ui_locker(unit.request_sync());
                        dialog.widgets['ok_button'].str = dialog.data['widgets']['ok_button']['ui_name_pending'];
                        dialog.widgets['ok_button'].state = 'disabled'; dialog.widgets['price_display'].onclick = null;
                    }
                }
            };
        })(selection.unit);
    }

    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    if(session.enable_progress_timers) {
        dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
        dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);
    } else {
        // conceal for tutorial purposes
        dialog.widgets['price_display'].str = dialog.widgets['price_display'].tooltip.str = '';
    }

    dialog.widgets['ok_button'].onclick =
        dialog.widgets['price_display'].onclick = closure;

    // alliance help system
    if(price > 0 && player.alliance_help_enabled() && !session.is_quarry() &&
       selection.unit.is_building() && !selection.unit.is_damaged() && selection.unit.is_upgrading() &&
       !('show_if' in gamedata['spells']['REQUEST_ALLIANCE_HELP'] && !read_predicate(gamedata['spells']['REQUEST_ALLIANCE_HELP']['show_if']).is_satisfied(player))) {
        var spell = gamedata['spells']['REQUEST_ALLIANCE_HELP'];
        dialog.widgets['help_request_button'].show = true;
        dialog.widgets['help_request_button'].str = spell['ui_name'];
        if(selection.unit.upgrade_help.help_completed) {
            dialog.widgets['help_request_button'].state = 'disabled';
            dialog.widgets['help_request_button'].tooltip.str = spell['ui_tooltip_already_completed'].replace('%time', pretty_print_time(selection.unit.upgrade_help.time_saved));
        } else if(selection.unit.upgrade_help.help_requested && selection.unit.upgrade_help.help_request_expire_time < 0) {
            // help request is in progress, with unknown expire time
            dialog.widgets['help_request_button'].state = 'disabled';
            dialog.widgets['help_request_button'].tooltip.str = spell['ui_tooltip_already_requested'];
        } else if(selection.unit.upgrade_help.help_requested && selection.unit.upgrade_help.help_request_expire_time > server_time && (selection.unit.upgrade_help.help_request_expire_time - server_time >= selection.unit.upgrade_time_left())) {
            // help request is in progress, and won't expire until after the upgrade finishes naturally
            dialog.widgets['help_request_button'].state = 'disabled';
            dialog.widgets['help_request_button'].tooltip.str = spell['ui_tooltip_already_requested'];
        } else if(selection.unit.upgrade_help.help_requested && selection.unit.upgrade_help.help_request_expire_time > server_time && (selection.unit.upgrade_help.help_request_expire_time - server_time < selection.unit.upgrade_time_left())) {
            // help request is in progress, and will expire before the upgrade finishes naturally
            dialog.widgets['help_request_button'].state = 'disabled';
            dialog.widgets['help_request_button'].tooltip.str = spell['ui_tooltip_already_requested_expires'].replace('%s', pretty_print_time(selection.unit.upgrade_help.help_request_expire_time - server_time));
        } else if(!session.is_in_alliance()) {
            dialog.widgets['help_request_button'].state = 'disabled';
            dialog.widgets['help_request_button'].tooltip.str = spell['ui_tooltip_no_alliance'];
        } else if(player.cooldown_active(spell['cooldown_name']) >= player.alliance_help_daily_limit()) {
            dialog.widgets['help_request_button'].state = 'disabled';
            dialog.widgets['help_request_button'].tooltip.str = spell['ui_tooltip_cooldown'].replace('%s', pretty_print_time(player.cooldown_togo(spell['cooldown_name'])));
        } else if('requires' in spell && !read_predicate(spell['requires']).is_satisfied(player)) {
            var pred = read_predicate(spell['requires']);
            dialog.widgets['help_request_button'].state = 'disabled_clickable';
            dialog.widgets['help_request_button'].onclick = get_requirements_help(pred);
            dialog.widgets['help_request_button'].tooltip.str = pred.ui_describe(player);
            dialog.widgets['help_request_button'].tooltip.text_color = SPUI.error_text_color;
        } else {
            var estimated_speedup = Math.min(selection.unit.upgrade_time_left(),
                                             Math.max(gamedata['alliance_help_speedup_min_time'],
                                                      Math.floor(gamedata['alliance_help_speedup_fraction'] * selection.unit.upgrade_total_time)));
            dialog.widgets['help_request_button'].tooltip.str = spell['ui_tooltip']
                                                                .replace('%est', pretty_print_time(estimated_speedup))
                                                                .replace('%d', pretty_print_number(player.alliance_help_daily_limit() - player.cooldown_active(spell['cooldown_name'])));
            dialog.widgets['help_request_button'].onclick = function(w) {
                var s = gamedata['strings']['help_request_confirm'];
                invoke_child_message_dialog(s['ui_title'], s['ui_description']
                                            .replace('%max', pretty_print_number(gamedata['alliance_help_quorum']))
                                            .replace('%duration', pretty_print_time(gamedata['alliance_help_request_duration']))
                                            .replace('%pct', (100.0*gamedata['alliance_help_speedup_fraction']).toFixed(0))
                                            .replace('%min_time', pretty_print_time(gamedata['alliance_help_speedup_min_time']))
                                            .replace('%times', pretty_print_number(player.alliance_help_daily_limit()))
                                            .replace('%cooldown', pretty_print_time(spell['cooldown'])),
                                            {'dialog': 'message_dialog_big',
                                             'cancel_button': true,
                                             'ok_button_ui_name': s['ui_button'],
                                             'on_ok': (function (_unit) { return function() {
                                                 change_selection_ui(null);
                                                 send_to_server.func(["CAST_SPELL", _unit.id, "REQUEST_ALLIANCE_HELP"]);
                                                 _unit.upgrade_help.help_requested = true; // client-side predict
                                             }; })(selection.unit)});
            };
        }
    }

    if(player.tutorial_state === 'speedup_open_speedup_menu' &&
       selection.unit.spec['name'] === gamedata['tutorial'][player.tutorial_state]['target'] &&
       selection.unit.is_building() &&
       selection.unit.is_under_construction()) {
        advance_tutorial();
    }

    return dialog;
}


function invoke_player_aura_speedup_dialog(aura_name) {
    var aura_spec = gamedata['auras'][aura_name];
    var aura = goog.array.find(player.player_auras, function(a) {
        return (a['spec'] == aura_name) && ('end_time' in a);
    });
    if(!aura) { return null; }

    var dialog_data = gamedata['dialogs']['speedup_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'speedup_dialog';
    dialog.modal = true;
    install_child_dialog(dialog);
    dialog.auto_center();

    dialog.widgets['title_speedup'].show = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    var time_left = aura['end_time'] - server_time;

    var description_finish = gamedata['strings']['speedup']['finish_player_aura'].replace('%s', aura_spec['ui_name']);
    var description_before = gamedata['strings']['speedup']['before_generic'];
    var description = gamedata['strings']['speedup']['template'].replace('%TIME',pretty_print_time(time_left)).replace('%FINISH', description_finish).replace('%BEFORE', description_before);
    dialog.widgets['description'].set_text_with_linebreaking(description);

    var price, closure;
    price = Store.get_user_currency_price(GameObject.VIRTUAL_ID, gamedata['spells']['PLAYER_AURA_SPEEDUP_FOR_MONEY'], aura_name);
    if(price == 0) {
        closure = (function (_aura_name) { return function(w) {
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "PLAYER_AURA_SPEEDUP_FOR_FREE", _aura_name]);
            invoke_ui_locker(synchronizer.request_sync(), (function (_w) { return function() { close_parent_dialog(_w); }; })(w));
        }; })(aura_name);
    } else {
        closure = (function (_aura_name) {
            return function(w) {
                var dialog = w.parent;

                // update price since time may have passed
                var new_price = Store.get_user_currency_price(GameObject.VIRTUAL_ID, gamedata['spells']['PLAYER_AURA_SPEEDUP_FOR_MONEY'], _aura_name);
                if(new_price === 0) {
                    // convert to free speedup
                    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "PLAYER_AURA_SPEEDUP_FOR_FREE", _aura_name]);
                    invoke_ui_locker(synchronizer.request_sync(), (function (_w) { return function() { close_parent_dialog(_w); }; })(w));
                } else if(new_price < 0) {
                    // order became invalid, maybe the building finished what it was doing
                    close_parent_dialog(w);
                } else {
                    if(Store.place_user_currency_order(GameObject.VIRTUAL_ID, "PLAYER_AURA_SPEEDUP_FOR_MONEY", _aura_name,
                                                       (function (_w) { return function() { close_parent_dialog(_w); }; })(w)
                                                      )) {
                        invoke_ui_locker(synchronizer.request_sync());
                        dialog.widgets['ok_button'].str = dialog.data['widgets']['ok_button']['ui_name_pending'];
                        dialog.widgets['ok_button'].state = 'disabled'; dialog.widgets['price_display'].onclick = null;
                    }
                }
            };
        })(aura_name);
    }

    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
    dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);

    dialog.widgets['ok_button'].onclick =
        dialog.widgets['price_display'].onclick = closure;

    return dialog;
}

/** @param {string} type - "upgrade", "research", etc
    @param {function()} cancel_cb - callback for "OK"
    @param {boolean=} ingredient_loss - if true, warn about losing ingredient items */
function invoke_confirm_cancel_message(type, cancel_cb, ingredient_loss) {
    var dialog_data = gamedata['dialogs']['confirm_cancel_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var txt = dialog.data['widgets']['description']['ui_name_'+type]
    if(ingredient_loss) {
        txt += ' ' + dialog.data['widgets']['description']['ui_name_ingredient_loss'];
    }
    dialog.widgets['description'].set_text_with_linebreaking(txt);
    dialog.widgets['ok_button'].str = dialog.data['widgets']['ok_button']['ui_name_'+type];
    dialog.widgets['ok_button'].onclick = (function (_cancel_cb) { return function(w) { close_parent_dialog(w); cancel_cb(); }; })(cancel_cb);
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    return dialog;
}

function invoke_attack_through_protection_message(do_attack_cb) {
    var dialog_data = gamedata['dialogs']['attack_through_protection_message'];
    var dialog = new SPUI.Dialog(dialog_data);

    dialog.auto_center();
    dialog.modal = true;
    install_child_dialog(dialog);

    dialog.widgets['yes_button'].onclick = (function (cb) { return function(w) { close_parent_dialog(w); cb(); }; })(do_attack_cb);
    dialog.widgets['no_button'].onclick = function(w) { close_parent_dialog(w); visit_base_home(); };
    return dialog;
}

function invoke_attack_friend_message(do_attack_cb) {
    var dialog_data = gamedata['dialogs']['attack_friend_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    change_selection_ui(dialog);
    dialog.auto_center();

    dialog.widgets['description'].str = dialog_data['widgets']['description']['ui_name'].replace('%s', session.viewing_friend.get_ui_name());
    dialog.widgets['yes_button'].onclick = (function (cb) { return function() { change_selection(null); cb(); }; })(do_attack_cb);
    dialog.widgets['no_button'].onclick = function() { visit_base_home(); };
    return dialog;
}

function invoke_attack_reinforce_message(do_attack_cb) {
    var dialog_data = gamedata['dialogs']['attack_reinforce_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    change_selection_ui(dialog);
    dialog.auto_center();

    dialog.widgets['yes_button'].onclick = (function (cb) { return function() { change_selection(null); cb(); }; })(do_attack_cb);
    dialog.widgets['no_button'].onclick = function() { change_selection(null); };
    return dialog;
}

function invoke_attack_revenge_lower_level_message(do_attack_cb) {
    var dialog_data = gamedata['dialogs']['attack_revenge_lower_level_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    change_selection_ui(dialog);
    dialog.auto_center();

    dialog.widgets['yes_button'].onclick = (function (cb) { return function() { change_selection(null); cb(); }; })(do_attack_cb);
    dialog.widgets['no_button'].onclick = function() { change_selection(null); };
    return dialog;
}

function invoke_attack_stronger_message(do_attack_cb) {
    var replacements = {'%duration':  pretty_print_time(gamedata['matchmaking']['revenge_time'])};
    var dialog = invoke_ingame_tip('attack_stronger_confirm',
                                   {frequency: GameTipFrequency.ALWAYS_UNLESS_IGNORED,
                                    replacements: replacements,
                                    ignore_button_ui_name: gamedata['strings']['attack_stronger_confirm']['ui_ignore_button'],
                                    dialog_options: {'on_ok': do_attack_cb, 'cancel_button': true,
                                                     'ok_button_ui_name': gamedata['strings']['attack_stronger_confirm']['ui_button']}});
    if(dialog) {
        return dialog; // will chain to the callback
    } else {
        // attack immediately
        do_attack_cb();
    }
}

function invoke_attack_stronger_strict_message() { return invoke_attack_level_range_message('stronger_strict'); };
function invoke_attack_weaker_message() { return invoke_attack_level_range_message('weaker'); };
function invoke_attack_level_range_message(mode) {
    var dialog_data = gamedata['dialogs']['attack_level_range_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    change_selection_ui(dialog);
    dialog.auto_center();
    var level = Math.max(1, player.attackable_level_range()[(mode == 'stronger_strict' ? 1 : 0)]);
    dialog.widgets['description'].str = dialog_data['widgets']['description']['ui_name_'+mode].replace('%s', session.ui_name).replace('%d', level.toString());
    dialog.widgets['return_button'].onclick = visit_base_home;
    return dialog;
}


/** @param {Object} data
    @param {Object=} context */
function create_splash_message(data, context) {
    var dialog = new SPUI.Dialog(gamedata['dialogs'][data['dialog']]);
    if(data['ui_title']) {
        dialog.widgets['title'].set_text_with_linebreaking(data['ui_title']);
    } else {
        if('title' in dialog.widgets) { dialog.widgets['title'].show = 0; }
    }
    dialog.widgets['ok_button'].onclick = close_parent_dialog;
    if('close_button' in dialog.widgets) {
        dialog.widgets['close_button'].onclick = dialog.widgets['ok_button'].onclick;
    }
    if(('ai_name' in dialog.widgets) && ('ai_name' in data)) {
        dialog.widgets['ai_name'].str = data['ai_name'];
    }
    if('picture' in data) {
        dialog.widgets['picture'].asset = data['picture'];
    }
    if('sound' in data) {
        GameArt.play_canned_sound(data['sound']);
    }
    apply_dialog_hacks(dialog, data, context);
    return dialog;
}

// "data" = JSON spec for the dialog
// "context" = argument to pass to any consequents invoked by this dialog
function invoke_splash_message(data, context) {
    var dialog = create_splash_message(data, context);
    change_selection_ui(dialog);
    dialog.modal = true;
    dialog.auto_center();
}

function invoke_flash_offer(data) {
    var sku_name = data['spell'];
    var sku = gamedata['spells'][sku_name];

    // make sure the offer can take effect
    var spellname = sku['effect']['spellname'];
    var spellarg = sku['effect']['spellarg'];
    if(!can_cast_spell(GameObject.VIRTUAL_ID, spellname, spellarg)) {
        console.log('cannot accept flash offer! '+data['name']);
        return;
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs'][data['dialog'] || 'flash_offer_dialog']);
    change_selection_ui(dialog);
    dialog.modal = true;
    dialog.auto_center();

    if('picture' in data) {
        dialog.widgets['picture'].asset = data['picture'];
    }
    dialog.widgets['close_button'].onclick = function() { change_selection(null); };

    var price = Store.get_user_currency_price(GameObject.VIRTUAL_ID, sku, null);
    var closure = (function (_sku_name) {
        return function(w) {
            var dialog = w.parent;

            if(Store.place_user_currency_order(GameObject.VIRTUAL_ID, sku_name, null, function() { change_selection(null); })) {
                dialog.widgets['ok_button'].str = dialog.data['widgets']['ok_button']['ui_name_pending'];
                dialog.widgets['ok_button'].state = 'disabled'; dialog.widgets['price_display'].onclick = null;
            }
        }; })(sku_name);

    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
    dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);

    dialog.widgets['ok_button'].onclick =
        dialog.widgets['price_display'].onclick = closure;

    apply_dialog_hacks(dialog, data);
    return dialog;
}

function test_flash_offer(offer) {
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_EXECUTE_CONSEQUENT", {'consequent':'FLASH_OFFER','offer':offer}]);
}

function invoke_battle_end_dialog(battle_type, battle_base, battle_opponent_user_id, battle_opponent_fbid, battle_opponent_level, battle_opponent_friend,
                                  battle_opponent_name,
                                  outcome, loot, battle_summary, ladder_state, replay_signature)
{
    // home-base and hive victories go through the fancy version of this dialog
    if(outcome == 'victory' &&
       player.tutorial_state == "COMPLETE" &&
       (battle_base.base_type == 'home' || battle_base.base_type == 'hive' || !battle_base.base_type) &&
       player.get_any_abtest_value('fancy_victory_dialog', gamedata['client']['fancy_victory_dialog'])) {
        return invoke_fancy_victory_dialog(battle_type, battle_base, battle_opponent_user_id, battle_opponent_fbid, battle_opponent_level, battle_opponent_friend,
                                           battle_opponent_name,
                                           outcome, loot, battle_summary, ladder_state, replay_signature);
    }

    var trophy_delta = 0, trophy_type = null;
    goog.array.forEach(['pvp','pvv'], function(t) {
        if((loot['trophies_'+t] || 0)) {
            trophy_delta = loot['trophies_'+t];
            trophy_type = t;
        }
    });

    // skippable: any squad battle, any LOSS at a quarry, hive, or human home where no trophies were gained or lost
    var skippable = (battle_type === 'squad' ||
                     ((battle_base.base_type === 'quarry' ||
                       battle_base.base_type === 'hive' ||
                       (battle_base.base_type === 'home' && !is_ai_user_id_range(battle_base.base_landlord_id)))
                      && outcome !== 'victory')) &&
        (trophy_delta === 0) &&
        (player.tutorial_state === 'COMPLETE');

    if(skippable && player.preferences['ignore_squad_battle_end_dialog']) {
        return null; // player wants to skip
    }

    // do this first so it pops under
    if(player.tutorial_state === 'wait_battle_finish2') {
        metric_event('0330_tutorial_battle_ended', {});
        advance_tutorial();
    }

    var dialog_data = gamedata['dialogs']['battle_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'battle_dialog';

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['title'].str = gamedata['strings']['battle_end'][battle_type][outcome]['ui_title'];
    dialog.widgets['description'].set_text_with_linebreaking(gamedata['strings']['battle_end'][battle_type][outcome]['ui_description'].replace('%LADDER_WIN_DAMAGE',
                                                                                                                                               Math.floor(100.0*gamedata['matchmaking']['ladder_win_damage']).toFixed(0)));

    if(outcome === 'defeat') {
    } else {
        if(player.tutorial_state == "COMPLETE") {
            var viral_name = null;
            var viral_props = {'%ENEMY': battle_opponent_name, '%ENEMY_LEVEL': battle_opponent_level.toString()};
            if(is_ai_user_id_range(battle_opponent_user_id)) {
                viral_name = 'defeat_computer';
            } else if(battle_opponent_friend && battle_opponent_friend.is_real_friend) {
                viral_name = 'defeat_facebook_friend';
            }
            if(viral_name) {
                var viral = get_facebook_viral(viral_name);
                if(viral) {
                    dialog.widgets['viral_button'].show = true;
                    dialog.widgets['viral_button'].str = viral['ui_button_text'];
                    dialog.widgets['viral_button'].onclick = (function (_vname, _vprops) { return function() {
                        invoke_facebook_viral(_vname, _vprops);
                    }; })(viral_name, viral_props);
                }
            }
        }
    }

    if(outcome === 'defeat') {
        dialog.widgets['splash_image'].asset = 'splash_defeat';
        dialog.widgets['bg'].sound = null;
    } else {
        dialog.widgets['splash_image'].asset = 'splash_victory';
    }

    var gained_anything = false;

    if(skippable) {
        dialog.widgets['squad_ignore_button'].show = true;
        dialog.widgets['squad_ignore_button'].onclick = function(w) {
            w.state = (w.state == 'active' ? 'normal' : 'active');
            player.preferences['ignore_squad_battle_end_dialog'] = (w.state == 'active' ? 1 : 0);
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
        };
    }

    for(var res in gamedata['resources']) {
        if('loot_'+res+'_amount' in dialog.widgets) {
            var amount;
            if(gamedata['show_uncapped_loot']) {
                amount = loot['looted_uncapped_'+res] || 0;
            } else {
                amount = loot[res] || 0;
            }
            dialog.widgets['loot_'+res+'_amount'].str = pretty_print_number(amount);
            dialog.widgets['loot_'+res+'_icon'].asset = gamedata['resources'][res]['icon_small'];
            if(amount) {
                gained_anything = true;
                dialog.widgets['loot_'+res+'_amount'].show = dialog.widgets['loot_'+res+'_icon'].show = true;
            }
        }
    }
    if(loot['xp'] || 0 > 0) {
        gained_anything = true;
        dialog.widgets['loot_xp_amount'].str = pretty_print_number(loot['xp'] || 0);
    }
    dialog.widgets['you_gained'].show = !!gained_anything;

    if(trophy_delta != 0) {
        dialog.widgets['trophy_sunken'].show =
            dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_amount'].show =
            dialog.widgets['trophy_shine'].show = true;
        dialog.widgets['trophy_icon'].state = trophy_type;

        var sign = (trophy_delta > 0 ? 'plus' : 'minus');
        dialog.widgets['trophy_amount'].str = dialog.data['widgets']['trophy_amount']['ui_name_'+sign].replace('%d', pretty_print_number(Math.abs(trophy_delta)));
        dialog.widgets['trophy_amount'].text_color = SPUI.make_colorv(dialog.data['widgets']['trophy_amount']['text_color_'+sign]);
        dialog.widgets['trophy_sunken'].tooltip.str = dialog.data['widgets']['trophy_sunken']['ui_tooltip'].replace('%s', gamedata['strings']['leaderboard']['categories']['trophies_'+trophy_type]['short_title']);
    }

    dialog.widgets['ok_button'].onclick = (function (_outcome, _base) { return function(w) {
        close_parent_dialog(w);
        if(player.tutorial_state === 'battle_end_message') {
            advance_tutorial();
        }
        var options = {frequency:GameTipFrequency.ALWAYS_UNLESS_IGNORED};
        if(_base.base_type == 'quarry' && outcome === 'victory') {
            invoke_ingame_tip((session.region.data['storage'] == 'nosql') ? 'quarry_conquer_tip2_nosql' : 'quarry_conquer_tip2', options);
        } else if(_base.base_type == 'hive') {
            invoke_ingame_tip('hive_battle_'+outcome+'_tip', options);
        }
    }; })(outcome, battle_base);

    // have to set a timer in case dialog goes away without clicking 'OK'
    window.setTimeout(function() {
        if(player.tutorial_state === 'battle_end_message') {
            advance_tutorial();
        }
    }, 15000);

    return dialog;
}

function test_fancy_victory_dialog(ai_id, kind, has_trophies, has_item_loot) { // kind should be "home"/"away"/"ladder"
    var ladder_state = {'points':{'victory':{},'defeat':{}}};
    ladder_state['points']['victory'][session.user_id.toString()] = 30;
    ladder_state['points']['victory'][ai_id.toString()] = 30;
    ladder_state['points']['defeat'][session.user_id.toString()] = -30;
    ladder_state['points']['defeat'][ai_id.toString()] = -30;
    var units = {};
    for(var n in gamedata['units']) {
        units[n] = 999;
    }
    var loot =  {'iron':12345, 'looted_uncapped_iron':12345,
                 'water':5432, 'looted_uncapped_water':12345,
                 'res3':543, 'looted_uncapped_res3':543,
                 'units_killed':units,
                 'units_lost':units,
                 'items': (has_item_loot ? [{'spec':'token','stack':1000},{'spec':'inventory_unknown','stack':5}] : [])};
    if(has_trophies) {
        loot['trophies_pvp'] = 30;
        loot['battle_stars'] = {'foo':1,'bar':2,'baz':3};
    }
    invoke_fancy_victory_dialog(kind, {base_type:'home'}, ai_id, '-1', 10, null,
                                'Test AI', 'victory',
                                loot,
                                {'base_damage': 0.51,
                                 'attacker_id': session.user_id,
                                 'defender_id': ai_id,
                                 'timed_challenge': gamedata['ai_bases_client']['bases'][ai_id.toString()]['timed_challenge'],
                                 'time': Math.floor(server_time),
                                 'duration': 945,
                                 'base_id': 'h'+ai_id.toString(),
                                 'deployed_units':units,
                                 'replay_version': gamedata['replay_version']},
                                (kind == 'ladder' ? ladder_state : null),
                               'abcdef');
}

// get a string representing the units you killed in battle
function get_loot_kills_list(loot, separator, max_count) {
    var units_destroyed = [];
    if('units_killed' in loot) {
        for(var specname in loot['units_killed']) {
            var qty = loot['units_killed'][specname];
            var spec = gamedata['units'][specname];
            units_destroyed.push(qty.toString() + ' ' + (qty>1 && spec['ui_name_plural'] ? spec['ui_name_plural'] : spec['ui_name']));
        }
    }

    // if the list is too long to fit the dialog area, list by category instead
    if(units_destroyed.length > max_count) {
        var cat_list = goog.object.getKeys(gamedata['strings']['manufacture_categories']);
        var cat_kills = {};
        goog.array.forEach(cat_list, function(cat) { cat_kills[cat] = 0; });
        for(var specname in loot['units_killed']) {
            var qty = loot['units_killed'][specname];
            cat_kills[gamedata['units'][specname]['manufacture_category']] += qty;
        }
        units_destroyed = [];
        for(var i = 0; i < cat_list.length; i++) {
            var cat = cat_list[i];
            if(cat_kills[cat] > 0) {
                units_destroyed.push(cat_kills[cat].toString() + ' ' + gamedata['strings']['manufacture_categories'][cat][(cat_kills[cat] == 1 ? 'singular' : 'plural')]);
            }
        }
    }
    return units_destroyed.join(separator);
}

function invoke_fancy_victory_dialog(battle_type, battle_base, battle_opponent_user_id, battle_opponent_fbid, battle_opponent_level, battle_opponent_friend,
                                     battle_opponent_name,
                                     outcome, loot, battle_summary, ladder_state, replay_signature) {
    // do this first so it pops under
    if(player.tutorial_state === 'wait_battle_finish2') {
        metric_event('0330_tutorial_battle_ended', {});
        advance_tutorial();
    }

    var dialog_data = gamedata['dialogs']['fancy_victory_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'fancy_victory_dialog';
    dialog.user_data['context'] = null;
    dialog.user_data['anim_start_time'] = client_time;
    dialog.user_data['replay_signature'] = replay_signature;
    dialog.user_data['summary'] = battle_summary;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    if(player.tutorial_state == 'COMPLETE' && session.enable_progress_timers &&
       can_show_replay_for_battle_summary(battle_summary)) {
        set_up_replay_sharing_button(dialog, battle_summary, dialog.user_data['replay_signature'], player.get_ui_name(), battle_opponent_name);
    }

    dialog.widgets['winner_name'].str = player.get_ui_name();
    dialog.widgets['loser_name'].str = battle_opponent_name;

    dialog.widgets['winner_portrait'].set_user(session.user_id);
    if(battle_opponent_user_id === null) {
        // for defenses, we don't get the user_id yet
        dialog.widgets['loser_portrait'].show = false;
    } else {
        dialog.widgets['loser_portrait'].set_user(battle_opponent_user_id);
    }

    var units_killed = 0, units_lost = 0;

    if(gamedata['client']['enable_defending_units']) {
        if('units_killed' in loot) {
            for(var specname in loot['units_killed']) {
                var qty = loot['units_killed'][specname];
                units_killed += qty;
            }
        }
        if('units_lost' in loot) {
            for(var specname in loot['units_lost']) {
                var qty = loot['units_lost'][specname];
                units_lost += qty;
            }
        }
    }

    // scale loser_inner bar width according to how well the loser did in terms of kills vs. losses
    var loser_width; // 84-259
    if(units_lost < 1) {
        loser_width = 0;
    } else if(units_lost >= units_killed) {
        loser_width = 1;
    } else {
        loser_width = units_lost/(units_killed+1);
    }
    // set .data to a modified copy of the original so that the size_change animation picks up the new final "dimensions"
    dialog.widgets['loser_inner'].data = goog.object.clone(dialog.widgets['loser_inner'].data);
    dialog.widgets['loser_inner'].wh[0] = dialog.widgets['loser_inner'].data['dimensions'][0] = Math.floor(84 + loser_width*(dialog.data['widgets']['loser_inner']['dimensions'][0]-84));

    if(player.get_any_abtest_value('show_xp_gains', gamedata['client']['show_xp_gains'])) {
        dialog.widgets['loot_xp_amount'].num_val = loot['xp'] || 0;
        dialog.widgets['loot_xp_amount'].str = pretty_print_number(loot['xp'] || 0);
    } else {
        dialog.widgets['loot_xp_icon'].show =
            dialog.widgets['loot_xp_amount'].show = false;
    }

    var looted_res = {};
    for(var res in gamedata['resources']) {
        if(battle_type !== 'home') {
            if(gamedata['show_uncapped_loot']) {
                looted_res[res] = loot['looted_uncapped_'+res] || 0;
            } else {
                looted_res[res] = loot[res] || 0;
            }
        } else {
            looted_res[res] = 0;
        }
    }

    var trophies = (loot['trophies_pvp'] || 0) + (loot['trophies_pve'] || 0) + (loot['trophies_pvv'] || 0);
    dialog.user_data['trophy_type'] = ((loot['trophies_pvv'] || 0) != 0 ? 'pvv' : ((loot['trophies_pvp'] || 0) != 0 ? 'pvp' : 'pve'));

    if(battle_type !== 'home' && !battle_summary['timed_challenge']) {
        // OFFENSE, non-timed-challenge: show loot display

        // loot amounts
        for(var res in gamedata['resources']) {
            if('row_'+res+'_amount' in dialog.widgets) {
                /* dialog.widgets['total_'+res+'_amount'].num_val = */ dialog.widgets['row_'+res+'_amount'].num_val = looted_res[res];
                /* dialog.widgets['total_'+res+'_amount'].str = */ dialog.widgets['row_'+res+'_amount'].str = pretty_print_number(looted_res[res]);
            }
            if(looted_res[res]) {
                goog.array.forEach(['row_%s_icon', 'row_%s_amount', 'total_%s_icon', 'total_%s_amount'], function(s) {
                    var wname = s.replace('%s', res);
                    if(wname in dialog.widgets) {
                        dialog.widgets[wname].show = true;
                    }
                });
            }
        }

        // spent units
        if(gamedata['client']['battle_end_dialog_show_units_deployed'] && ('deployed_units' in battle_summary)) {
            dialog.widgets['you_spent'].show = true;
            var i = 0, j = 0;
            for(var specname in gamedata['units']) {
                if(specname in battle_summary['deployed_units']) {
                    var spec = gamedata['units'][specname];
                    var qty = battle_summary['deployed_units'][specname];

                    var d = dialog.widgets[SPUI.get_array_widget_name('spent_unit', dialog.data['widgets']['spent_unit']['array'], [i,j])];
                    d.show = true;
                    d.user_data['specname'] = specname;
                    if('icon' in spec) {
                        d.widgets['item'].asset = get_leveled_quantity(spec['icon'],1);
                    } else {
                        d.widgets['item'].asset = get_leveled_quantity(spec['art_asset'],1);
                    }
                    d.widgets['item'].state = GameArt.assets[d.widgets['item'].asset].has_state('icon') ? 'icon' : 'normal';
                    d.widgets['stack'].str = pretty_print_number(qty);
                    d.widgets['frame'].state = 'normal_nohighlight'; // 'disabled' use grayed-out frame
                    d.widgets['frame'].tooltip.str = pretty_print_number(qty)+'x '+((spec['ui_name_plural'] && qty != 1) ? spec['ui_name_plural'] : spec['ui_name']);
                    i += 1;
                    if(i >= dialog.data['widgets']['spent_unit']['array'][0]) {
                        i = 0;
                        j += 1;
                        if(j >= dialog.data['widgets']['spent_unit']['array'][1]) {
                            console.log('ran out of space to display units!');
                            break;
                        }
                    }
                }
            }
        }
    } else {
        // no loot display - DEFENSE or timed challenge

        if(!trophies) {
            dialog.widgets['you_gained'].show = false; // nothing "gained", so don't show it
        }
        for(var res in gamedata['resources']) {
            goog.array.forEach(['row_%s_icon', 'row_%s_amount', 'total_%s_icon', 'total_%s_amount'], function(s) {
                var wname = s.replace('%s', res);
                if(wname in dialog.widgets) {
                    dialog.widgets[wname].show = false;
                }
            });
        }

        if(battle_summary['timed_challenge']) {
            // fetch scores, both personal and leaders
            dialog.widgets['skill_challenge_stats'].show = true;
            var extra_axes = {'challenge': ['key', battle_summary['timed_challenge']]};
            query_player_scores2([session.user_id], [scores2_query_addr('battle_duration', 'week', extra_axes)],
                                 (function (dialog) { return function(user_ids, datas) {
                                     if(!dialog.parent) { return; } // dialog died
                                     var my_score = datas[0][0];
                                     query_score_leaders('battle_duration', 'week', extra_axes, 5,
                                                         (function (dialog, my_score) { return function(cat, period, leaders) {
                                                             if(!dialog.parent) { return; } // dialog was killed
                                                             var bbstr = dialog.data['widgets']['skill_challenge_stats']['ui_name_header'];
                                                             var ui_duration = pretty_print_time(dialog.user_data['summary']['duration']);
                                                             var ui_best_duration = my_score ? pretty_print_time(my_score['absolute']) : '?';
                                                             var ui_best_rank = my_score ? (my_score['rank']+1).toString() : '?';
                                                             bbstr = bbstr
                                                                 .replace('%SCORE', ui_duration)
                                                                 .replace('%BEST_SCORE', ui_best_duration)
                                                                 .replace('%BEST_RANK', ui_best_rank);
                                                             for(var y = 0; y < 5; y++) {
                                                                 if(y < leaders.length) {
                                                                     var ui_row_name = PlayerCache.get_ui_name(leaders[y]);
                                                                     if('player_level' in leaders[y]) {
                                                                         ui_row_name += ' L'+leaders[y]['player_level'].toString();
                                                                     }
                                                                     var ui_row_score = pretty_print_time(leaders[y]['absolute']);
                                                                     bbstr += dialog.data['widgets']['skill_challenge_stats']['ui_name_row']
                                                                         .replace('%RANK', (y+1).toString())
                                                                         .replace('%NAME', ui_row_name)
                                                                         .replace('%SCORE', ui_row_score);
                                                                 }
                                                             }
                                                             dialog.widgets['skill_challenge_stats'].set_text_bbcode(bbstr);
                                                         }; })(dialog, my_score));
                                 }; })(dialog), {get_rank: true});
        }
    }

    // battle stats
    if(!battle_summary['timed_challenge']) {
        dialog.widgets['row_battle_stats'].show = true;
        var bbstr = dialog.data['widgets']['row_battle_stats']['ui_name'];
        bbstr = bbstr.replace('%DURATION', pretty_print_time(battle_summary['duration']));
        var kills_list = get_loot_kills_list(loot, ', ', 3 /* dialog.widgets['row_battle_stats'].data['max_lines'] */);
        if(kills_list && kills_list.length > 0) {
            bbstr += dialog.data['widgets']['row_battle_stats']['ui_name_units_killed'].replace('%KILLED', kills_list);
        }
        dialog.widgets['row_battle_stats'].set_text_bbcode(bbstr);
        /*
        // so that typewriter animation will work
        dialog.widgets['row_defense'].data = goog.object.clone(dialog.widgets['row_defense'].data);
        dialog.widgets['row_defense'].data['ui_name'] = dialog.widgets['row_defense'].str;
        */
    }

    if(trophies > 0) {
        dialog.widgets['trophy_label'].show =
            dialog.widgets['trophy_bg'].show =
            dialog.widgets['trophy_shine'].show =
            dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_amount'].show = true;
        dialog.widgets['trophy_expires'].show = (gamedata['matchmaking']['ladder_point_frequency'] !== 'season');
        dialog.widgets['trophy_icon'].state = dialog.user_data['trophy_type'];
        dialog.widgets['trophy_label'].str = dialog.data['widgets']['trophy_label']['ui_name'].replace('%d', pretty_print_number(current_pvp_week()));
        dialog.widgets['trophy_amount'].num_val = trophies;
        dialog.widgets['trophy_amount'].str = pretty_print_number(trophies);
    }

    // upper base damage display (redundant with bottom display when battle_type == 'home')
    if(battle_type != 'home' && 'base_damage' in battle_summary) {
        dialog.widgets['battle_stars_base_damage'].show = true;
        var pct = Math.floor(100*battle_summary['base_damage']).toFixed(0);
        dialog.widgets['battle_stars_base_damage'].str = dialog.data['widgets']['battle_stars_base_damage']['ui_name'].replace('%d', pct);
    }

    if('battle_stars' in loot && 'base_damage' in battle_summary) {
        dialog.widgets['battle_stars_bg'].show = true;
        var count = goog.object.getCount(loot['battle_stars']);
        for(var i = 0; i < dialog.data['widgets']['battle_stars_hole']['array'][0]; i++) {
            dialog.widgets['battle_stars_hole'+i.toString()].show = true;
            dialog.widgets['battle_stars_star'+i.toString()].show = (i < count);
        }
    }

    for(var i = 0; i < dialog.data['widgets']['itemrow_bg']['array'][1]; i++) {
        dialog.widgets['itemrow_bg_highlight'+i].show =
            dialog.widgets['itemrow_bg'+i].show = false;
    }

    var token_qty = 0, token_spec = null;

    if('items' in loot && loot['items'].length > 0) {

        dialog.widgets['splash_image'].show = dialog.widgets['splash_image_frame'].show = false;
        dialog.widgets['items_found'].show = true;

        for(var i = 0; i < dialog.data['widgets']['itemrow_bg']['array'][1]; i++) {
            if(loot['items'].length > i*dialog.data['widgets']['slot']['array'][0]) {
                dialog.widgets['itemrow_bg'+i].show = true;
            }
        }

        for(var i = 0; i < loot['items'].length; i++) {
            var item = loot['items'][i];
            var item_spec = ItemDisplay.get_inventory_item_spec(item['spec']);

            if(item_spec['category'] === 'token') {
                token_spec = item_spec;
                token_qty = (('stack' in item) ? item['stack'] : 1);
            }

            // if only one item, center it
            if(loot['items'].length == 1 && i == 0) {
                i = 1;
            }

            var x = i % dialog.data['widgets']['slot']['array'][0];
            var y = Math.floor(i / dialog.data['widgets']['slot']['array'][0]);
            if(y >= dialog.data['widgets']['slot']['array'][1]) {
                break;
            }
            var xy = x.toString()+','+y.toString();
            dialog.widgets['slot_bg'+xy].show =
                dialog.widgets['slot'+xy].show =
                dialog.widgets['item_icon'+xy].show =
                dialog.widgets['item_stack'+xy].show =
                dialog.widgets['item_frame'+xy].show = true;


            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            ItemDisplay.set_inventory_item_asset(dialog.widgets['item_icon'+xy], spec);
            ItemDisplay.set_inventory_item_stack(dialog.widgets['item_stack'+xy], spec, item);
            dialog.widgets['item_frame'+xy].onclick = null;
            dialog.widgets['item_frame'+xy].state = (player.get_any_abtest_value('modal_looting', gamedata['modal_looting']) ? 'normal_nohighlight' : 'normal');

            dialog.widgets['item_frame'+xy].onenter = (function (_i, _item) { return function(w) {
                var dialog = w.parent;
                if(dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === _i) { return; }

                // only show tooltip when modal looting is off
                if(!player.get_any_abtest_value('modal_looting', gamedata['modal_looting'])) {
                    w.state = 'active_nopushed';
                    invoke_inventory_context(w.parent, w, _i, _item, false);
                }

                // set transparent so that onleave is always called reliably
                if(dialog.user_data['context']) { dialog.user_data['context'].transparent_to_mouse = true; }
            }; })(i, item);

            dialog.widgets['item_frame'+xy].onleave_cb = (function (_i, _item) { return function(w) {
                w.state = (player.get_any_abtest_value('modal_looting', gamedata['modal_looting']) ? 'normal_nohighlight' : 'normal');
                if(dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === _i) {
                    invoke_inventory_context(w.parent, w, -1, null, false);
                }
            }; })(i, item);
        }
    }

    // make a private copy of widget.data here so the animation will work, since it repeatedly pulls .str from from widget.data
    if(1) {
        dialog.widgets['valentina_says'].data = goog.object.clone(dialog.widgets['valentina_says'].data);

        /** @type {string} template for what she says (random alternatives separated by "|") */
        var valentina_says;
        /** @type {Object.<string, string>} substrings to replace inside the template*/
        var replacements = {};

        if(is_ai_user_id_range(battle_opponent_user_id) && battle_opponent_user_id.toString() in gamedata['ai_bases_client']['bases'] &&
           'ui_fancy_victory_text' in gamedata['ai_bases_client']['bases'][battle_opponent_user_id.toString()]) {
            valentina_says = gamedata['ai_bases_client']['bases'][battle_opponent_user_id.toString()]['ui_fancy_victory_text'];
        } else if(trophies > 0) {
            valentina_says = dialog.widgets['valentina_says'].data['ui_name_trophies_'+dialog.user_data['trophy_type']] || dialog.widgets['valentina_says'].data['ui_name_trophies'];
            replacements['%d'] = pretty_print_number(trophies);
        } else {
            var win_type = (gamedata['common_win_condition'] == 'battle_stars' ? battle_type+'_battle_stars' : battle_type);
            if(!('ui_name_'+win_type in dialog.widgets['valentina_says'].data)) {
                throw Error('no ui_name_'+win_type+' in valentina_says');
            }
            valentina_says = dialog.widgets['valentina_says'].data['ui_name_'+win_type];
            replacements['%LADDER_WIN_DAMAGE'] = (100.0*gamedata['matchmaking']['ladder_win_damage']).toFixed(0);
            replacements['%TOWNHALL'] = gamedata['buildings'][gamedata['townhall']]['ui_name'];
        }
        var alternatives = valentina_says.split('|');
        var idx = Math.floor(Math.random() * alternatives.length);
        valentina_says = alternatives[idx];
        for(var k in replacements) { valentina_says = valentina_says.replace(k, replacements[k]); }
        dialog.widgets['valentina_says'].data['ui_name'] = valentina_says;
    }

    if(battle_type == 'home') {
        // defensive battle
        var damage = calc_base_damage({count_partial:true});
        dialog.widgets['base_damage'].str = dialog.widgets['base_damage'].data['ui_name'].replace('%pct', Math.floor(100*damage).toFixed(0) + '%');
        init_dialog_repair_buttons(dialog, damage, true);
        dialog.default_button = dialog.widgets[(damage > 0 ? 'repair_instant_button' : 'repair_not_necessary_button')];
        dialog.widgets['close_button'].show = false;
        dialog.widgets['close_button'].onclick = null; // prevent ESC from working
        dialog.widgets['ok_button'].show = false;
    } else {
        dialog.widgets['base_damage'].show =
            dialog.widgets['price_display'].show =
            dialog.widgets['repair_instant_button'].show =
            dialog.widgets['repair_slow_button'].show =
            dialog.widgets['repair_not_necessary_button'].show = false;

    dialog.widgets['close_button'].onclick =
        dialog.widgets['ok_button'].onclick = (function (_outcome, _base) { return function(w) {
            close_parent_dialog(w);
            if(player.tutorial_state === 'battle_end_message') {
                advance_tutorial();
            }
            var options = {frequency: GameTipFrequency.ALWAYS_UNLESS_IGNORED};
            if(_base.base_type == 'quarry' && outcome === 'victory') {
                invoke_ingame_tip((session.region.data['storage'] == 'nosql') ? 'quarry_conquer_tip2_nosql' : 'quarry_conquer_tip2', options);
            } else if(_base.base_type == 'hive') {
                var tipname = 'hive_battle_'+outcome+'_tip';

                if(outcome === 'victory' && token_qty > 0) {
                    tipname += '_with_tokens';
                    options.replacements = {'%d': pretty_print_number(token_qty), '%s': token_spec['ui_name']};
                } else if(outcome === 'victory' && loot['hive_kill_points']) {
                    tipname += '_with_kill_points';
                    options.replacements = {'%s': loot['hive_kill_points'].toString()};
                }
                invoke_ingame_tip(tipname, options);
            }
        }; })(outcome, battle_base);

    // have to set a timer in case dialog goes away without clicking 'OK'
    window.setTimeout(function() {
        if(player.tutorial_state === 'battle_end_message') {
            advance_tutorial();
        }
    }, 15000);
    }

    dialog.ondraw = update_fancy_victory_dialog;
    return dialog;
}

function apply_animation(dialog, wname, widget, anim_data, anim_time, anim) {
    if(!widget) { throw Error('unknown widget: '+wname); }
    if(!widget.show) { return; }

    if(anim === undefined) { throw Error('bad animation for widget: '+wname); }
    if(Array.isArray(anim)) {
        // it's an array
        for(var i = 0; i < anim.length; i++) {
            apply_animation(dialog, wname, widget, anim_data, anim_time, anim[i]);
        }
        return;
    }

    if(anim['type'] == 'same_as') {
        if('delay' in anim) { anim_time -= anim['delay']; }
        return apply_animation(dialog, wname, widget, anim_data, anim_time, anim_data[anim['ref']]);
    }

    var t = (anim_time - dialog.user_data['anim_start_time'] - anim['start_time'])/(anim['end_time']-anim['start_time']);
    t = clamp(t, 0, 1);
    if(anim['type'] == 'translate') {
        var start_pos = ('start_pos' in anim ? anim['start_pos'] : widget.data['xy']);
        var end_pos = ('end_pos' in anim ? anim['end_pos'] : widget.data['xy']);
        widget.xy = vec_add(start_pos, vec_scale(t, vec_sub(end_pos, start_pos)));
    } else if(anim['type'] == 'fadein') {
        widget.alpha = t;
    } else if(anim['type'] == 'size_change') {
        var start_dimensions = ('start_dimensions' in anim ? anim['start_dimensions'] : widget.data['dimensions']);
        var end_dimensions = ('end_dimensions' in anim ? anim['end_dimensions'] : widget.data['dimensions']);
        widget.wh = vec_floor(vec_add(start_dimensions, vec_scale(t, vec_sub(end_dimensions, start_dimensions))));
    } else if(anim['type'] == 'transform') {
        var start_xform = ('start_transform' in anim ? anim['start_transform'] : [1,0,0,1,0,0]);
        var end_xform = ('end_transform' in anim ? anim['end_transform'] : [1,0,0,1,0,0]);
        var xform = [0,0,0,0,0,0];
        for(var i = 0; i < 6; i++) {
            xform[i] = start_xform[i] + t*(end_xform[i]-start_xform[i]);
        }
        widget.transform = xform;
    } else if(anim['type'] == 'count_up') {
        if(t <= 0) {
            widget.str = '';
        } else {
            var val = Math.floor(widget.num_val * t);
            widget.str = pretty_print_number(val);
        }
    } else if(anim['type'] == 'typewriter') {
        var source = widget.data['ui_name'];
        var s = '';
        if(t >= 1) {
            s += source;
        } else {
            var last_char = t * source.length;
            for(var i = 0; i < last_char; i++) {
                s += source.charAt(i);
            }
        }
        if(anim['cursor'] && (client_time % 1.0) > 0.5) {
            s += '|';
        }
        widget.str = s;
    } else if(anim['type'] == 'SPFX') {
        if(!('spfx' in dialog.user_data)) { dialog.user_data['spfx'] = {}; }
        var offset = ('offset' in anim ? anim['offset'] : [0,0]);
        var widget_xy = widget.data['xy'];
        if('array_offset' in widget.data) {
            widget_xy = vec_add(widget_xy, vec_mul(widget.array_pos, widget.data['array_offset']));
        }
        var pos = vec_add(vec_add(vec_add(dialog.xy, widget_xy), vec_scale(0.5, widget.data['dimensions'])), offset);
        if(!(wname in dialog.user_data['spfx'])) {
            // SPFX wants time in terms of "start time", not "time relative to start", so invert the sense of time delays
            var spfx_start_time = client_time + (client_time-anim_time);
            dialog.user_data['spfx'][wname] = session.get_draw_world().fxworld.add_visual_effect_at_time(pos, 0, [0,1,0], spfx_start_time, anim['effect'], true, {'is_ui':true});
        }
        //dialog.user_data['spfx'][wname].where = pos; // XXX how to track moving UI objects?
    } else {
        throw Error('unknown animation type '+anim['type']);
    }
}

/** @param {SPUI.Dialog} dialog */
function update_fancy_victory_dialog(dialog) {
    if(dialog.widgets['trophy_expires'].show) {
        var togo = player.current_trophy_challenge_togo();
        dialog.widgets['trophy_expires'].str = (togo > 0 ? dialog.data['widgets']['trophy_expires']['ui_name'].replace('%expiry',gamedata['strings']['trophies_expire_in']).replace('%s', pretty_print_time_brief(togo)) : null);
    }

    var anim_data = dialog.data['animation'];
    for(var wname in anim_data) {
        apply_animation(dialog, wname, dialog.widgets[wname], anim_data, client_time, anim_data[wname]);
    }
}

function start_incoming_attack() {
    if(session.incoming_attack_time > 0) {
        // tell server to spawn units
        send_to_server.func(["BEGIN_AI_ATTACK"]);
        session.incoming_attack_time = -1;

        // under automatic unit control, set "relentless" mode on all defending units that don't have "hold position" or "patrol" orders
        var use_auto_aggressive = get_preference_setting(player.preferences, 'auto_unit_control');

        if(use_auto_aggressive && (player.tutorial_state == "COMPLETE" || gamedata['tutorial'][player.tutorial_state]['make_units_aggressive'])) {
            session.for_each_real_object(function(obj) {
                if(obj.is_mobile() && obj.team == 'player') {
                    if(obj.patrol || (obj.orders && obj.orders.length == 1 && obj.orders[0]['state'] == ai_states.AI_ATTACK_STATIONARY)) {
                        // don't make aggressive
                    } else {
                        var order = {'state': ai_states.AI_ATTACK_ANY, 'aggressive': true};
                        obj.new_order(session.get_real_world(), order, true);
                    }
                }
            });
        }
    }
    change_selection(null);
}

function invoke_ai_attack_warning_dialog(text) {
    var template = (player.tutorial_state === "COMPLETE" ? 'daily_attack_dialog' : 'ai_attack_warning_dialog');

    var dialog_data = gamedata['dialogs'][template];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = template;

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var attacker_name = session.incoming_attacker_name;

    if(template === 'ai_attack_warning_dialog') {
        dialog.widgets['description'].str = gamedata['tutorial']['ai_attack_begin']['ui_warning'].replace('%d',
                                                                                                          pretty_print_time(session.incoming_attack_time - server_time)).replace('%s', attacker_name);

        dialog.widgets['ai_name'].str = attacker_name;
        dialog.widgets['ok_button'].onclick = start_incoming_attack;
    } else {
        dialog.widgets['title'].str = dialog_data['widgets']['title']['ui_name'].replace('%s', attacker_name);
        dialog.widgets['description'].str = text;
        // show the icon of the most expensive unit
        var icon_asset = 'inventory_unknown';
        var max_cost = 0;
        var unit_list = [];

        // collapse all waves into one dictionary
        var waves = {};
        for(var i = 0; i < session.incoming_attack_units.length; i++) {
            var thiswave = session.incoming_attack_units[i];
            for(var specname in thiswave) {
                if(specname == 'direction') { continue; }
                waves[specname] = (waves[specname] || 0) + thiswave[specname];
            }
        }

        for(var specname in waves) {
            var qty = waves[specname];
            var cost = get_leveled_quantity(gamedata['units'][specname]['max_hp'],1);
            if(cost > max_cost) {
                max_cost = cost;
                icon_asset = get_leveled_quantity(gamedata['units'][specname]['art_asset'],1);
            }
            unit_list.push(qty+'x '+gamedata['units'][specname]['ui_name']);
        }
        dialog.widgets['unit_icon'].asset = icon_asset;
        dialog.widgets['unit_list'].str = unit_list.join('\n');
        dialog.widgets['delay_button'].onclick = function() { change_selection(null); }
        dialog.widgets['fight_button'].onclick = start_incoming_attack;
    }
    return dialog;
}

function invoke_ai_attack_finish_dialog(loot) {
    // do this first so it pops under
    if(player.tutorial_state === 'ai_attack_during') {
        metric_event('0270_tutorial_ai_attack_end', {});
        advance_tutorial(); // to ai_attack_end
    }

    var dialog_data = gamedata['dialogs']['ai_attack_finish_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'ai_attack_finish_dialog';

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var attacker_name = session.incoming_attacker_name;
    dialog.widgets['ai_name'].str = attacker_name;
    dialog.widgets['description'].str = gamedata['tutorial']['ai_attack_end']['ui_message'];

    dialog.widgets['ok_button'].onclick = function() {
        change_selection(null);
        if(player.tutorial_state === 'ai_attack_end') {
            advance_tutorial();
        }
    };

    // have to set a timer in case dialog goes away without clicking 'OK'
    window.setTimeout(function() {
        if(player.tutorial_state === 'ai_attack_end') {
            advance_tutorial();
        }
    }, 15000);

    return dialog;
}

// check whether player has unlocked unit whose spec name is 'name'
// returns 0 if not unlocked, otherwise returns the level of unit the player can build
function unit_unlock_level(name) {
    var spec = gamedata['units'][name];
    if(('requires' in spec) && !player.is_cheater) {
        var pred = read_predicate(get_leveled_quantity(spec['requires'], 1));
        if(!pred.is_satisfied(player, null)) {
            return 0;
        }
    }
    var level = 1;
    if('level_determined_by_tech' in spec) {
        level = 0; // not unlocked unless this tech is at L1 or higher
        var techname = spec['level_determined_by_tech'];
        if(techname in player.tech) {
            level = player.tech[techname];
        }
    }
    return level;
}

function do_harvest(all) {
    if(!selection.unit || !selection.unit.is_producer()) { return; }

    // check if storage is full

    // if doing a single collection on a harvester whose resource is full, show message and abort
    // if doing a collect-all, and one (but not all) resources are full, show message but continue collection
    // if doing a collect-all, and all resources are full, show message and abort

    var full = [], damaged = false;
    var doit = true;
    var num_resources = 0;

    // check for fullness
    for(var rsrc in gamedata['resources']) {
        var resdata = gamedata['resources'][rsrc];
        if(all) {
            if(!find_object_by_type(resdata['harvester_building'])) { // player has no harvesters that yield this resource
                // note: this won't catch remote quarries that yield the resource
                // but, the plan is to have an unlock requirement that prevents you from
                // attacking a quarry until you have a storage for the contained resources.
                continue;
            }
        } else if(!(('produces_'+rsrc) in selection.unit.spec)) {
            continue; // for single-harvester collect, skip resources other than the one this harvester produces
        }

        if(('loot_storage_warning_if' in resdata) && !read_predicate(resdata['loot_storage_warning_if']).is_satisfied(player,null)) { continue; }

        num_resources += 1;
        if(player.resource_state[rsrc][1] >= player.resource_state[rsrc][0]) {
            full.push(rsrc);
        }
    }

    if(num_resources > 0 && full.length >= num_resources) {
        // only prevent collection when ALL affected resource storages are full
        doit = false;
    }

    if(doit) {
        if(all) {
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "HARVEST_ALL2"]);

            // set sync marker on all harvesters
            var marker = synchronizer.request_sync();
            session.for_each_real_object(function(obj) {
                if(obj.is_building() && obj.is_producer()) {
                    obj.sync_marker = Math.max(obj.sync_marker, marker);
                }
            });

            // collect from quarries
            do_harvest_quarries();

        } else {
            if(selection.unit.is_in_sync()) {
                send_to_server.func(["CAST_SPELL", selection.unit.id, "HARVEST"]);
                selection.unit.request_sync();
            }
        }
    }

    change_selection(null);

    if(full.length > 0) {
        var rsrc = full[0];

        // first try to use the "plus button" helper before resorting to a normal error message
        var helper = get_requirements_help('storages_full', rsrc);
        if(helper) {
            return helper();
        }

        var data = gamedata['strings']['storages_full'];

        // if any storage buildings are damaged, tell the player to repair them rather than construct/upgrade
        // disabled for now, since we changed destroyed storages to still count towards your capacity
        /*
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.is_building() && obj.is_storage() && obj.is_damaged()) {
                title = "Storage buildings are damaged";
                msg = "Repair your storage buildings to make room\nbefore collecting resources.";
                break;
            }
        }
        */
        var ui_rsrc = gamedata['resources'][rsrc]['ui_name'];
        var title = data['ui_title'].replace('%s', ui_rsrc);
        var descr = data['ui_description'].replace('%s1', ui_rsrc).replace('%s2', ui_rsrc);

        invoke_message_dialog(title, descr);
        GameArt.play_canned_sound('error_sound');
    }
}

// to reduce player confusion, do not show "Quarries: 59s" cooldown message unless we've actually seen a quarry harvest in this session.
var seen_quarry_harvest = false;

function do_harvest_quarries() {
    if(!session.region.map_enabled()) { return; }

    var needs_poll = false;
    var togo = player.cooldown_togo('quarry_collect');
    if(togo > 0) {
        if(seen_quarry_harvest) {
            // send a fake on-cooldown response so we don't spam the server
            handle_server_message(["HARVESTED_RESOURCES", {'cooldown':server_time+togo+1}, -1, null, 'quarry', null]);
        }
        return;
    }

    send_to_server.func(["QUARRY_COLLECT"]);

    session.quarry_harvest_sync_marker = synchronizer.request_sync();
    if(gamedata['client']['quarry_collect_poll_interval'] > 0 && !player.cooldown_active('quarry_collect_poll')) {
        player.cooldown_client_trigger('quarry_collect_poll', gamedata['client']['quarry_collect_poll_interval']);
        window.setTimeout(function() {
            send_to_server.func(["PING_CHAT", player.chat_seen]);
            session.region.ping_contest_rank();
        }, gamedata['client']['quarry_collect_poll_interval']*1000);
    }
}

/** Collect a deposit, but if storage is full, tell player to add storage instead.
    @param {Inert} deposit */
function do_collect_deposit(deposit) {
    if(deposit.metadata) {
        for(var res in gamedata['resources']) {
            if(res in deposit.metadata && (deposit.metadata[res] > (player.resource_state[res][0]-player.resource_state[res][1]))) {
                var s = gamedata['strings']['requirements_help']['storages_full']['trying_to_collect_deposit'];
                invoke_message_dialog(s['ui_title'], s['ui_description']);
                return;
            }
        }
    }
    if(deposit.collect_sent) { return; }
    deposit.collect_sent = true;
    send_to_server.func(["CAST_SPELL", deposit.id, "COLLECT_DEPOSIT"]);
    change_selection_unit(null);
}

/** @param {Array.<ContextMenuButton>} buttons */
function add_change_region_button(buttons) {
    if(player.get_any_abtest_value('enable_region_map', gamedata['enable_region_map']) && player.get_any_abtest_value('change_region_requirement', gamedata['territory']['change_region_requirement'])['predicate'] != 'ALWAYS_FALSE') {
        var pred = read_predicate(player.get_any_abtest_value('change_region_requirement', gamedata['territory']['change_region_requirement']));
        var spell = gamedata['spells']['CHANGE_REGION'];
        var ui_name = spell['ui_name'];
        var togo = player.cooldown_togo(spell['cooldown_name']);
        if(!pred.is_satisfied(player, null)) {
            buttons.push(new ContextMenuButton({ui_name: ui_name, onclick: get_requirements_help(pred), state: 'disabled_clickable', ui_tooltip: spell['ui_tooltip_unmet'].replace('%s',pred.ui_describe(player)), asset: 'menu_button_resizable'}));
        } else if(togo > 0) {
            if(player.squads_enabled() || player.get_any_abtest_value('show_base_relocation_in_store', gamedata['store']['show_base_relocation_in_store'])) {
                buttons.push(new ContextMenuButton({ui_name: ui_name, onclick: function() { change_selection_ui(null); invoke_change_region_offer_dialog(); }, ui_tooltip: spell['ui_tooltip_cooldown'].replace('%s', pretty_print_time(togo)), asset: 'menu_button_resizable'}));
            } else {
                buttons.push(new ContextMenuButton({ui_name: ui_name, state: 'disabled', ui_tooltip: spell['ui_tooltip_cooldown'].replace('%s', pretty_print_time(togo)), asset: 'menu_button_resizable'}));
            }
        } else {
            buttons.push(new ContextMenuButton({ui_name: ui_name, onclick: function() { change_selection_ui(null); invoke_change_region_dialog(null, 'CHANGE_REGION'); }, ui_tooltip: spell['ui_tooltip'], asset: 'menu_button_resizable'}));
        }
    }
}

/** @param {Array.<ContextMenuButton>} buttons */
function add_regional_map_button(buttons) {
    var pred = read_predicate({'predicate':'LIBRARY', 'name':'quarry_play_requirement'});
    var can_view_quarries = pred.is_satisfied(player, null);
    if(can_view_quarries) {
        buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['SHOW_REGIONAL_MAP']['ui_name'],
                                            spellname: 'SHOW_REGIONAL_MAP',
                                            onclick: function() { change_selection_ui(null); invoke_region_map(); }, asset: 'menu_button_resizable'}));
    } else {
        buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['SHOW_REGIONAL_MAP']['ui_name'],
                                            spellname: 'SHOW_REGIONAL_MAP',
                                            onclick: get_requirements_help(pred), state: 'disabled_clickable',
                                            ui_tooltip: gamedata['spells']['SHOW_REGIONAL_MAP']['ui_tooltip_unmet'].replace('%s',pred.ui_describe(player)), asset: 'menu_button_resizable'}));
    }
}

/** @param {Array.<ContextMenuButton>} buttons */
function add_migrate_turret_heads_button(buttons) {
    var spell = gamedata['spells']['MIGRATE_TURRET_HEADS'];
    buttons.push(new ContextMenuButton({ui_name: spell['ui_name'], onclick: (function (_spell) { return function() {
        invoke_child_message_dialog(_spell['ui_title'],
                                    _spell['ui_description'],
                                    {'dialog': 'message_dialog_big',
                                     'title_text_color': _spell['title_text_color'],
                                     'cancel_button': true,
                                     'ok_button_ui_name': _spell['ui_button'],
                                     'on_ok': function() {
                                         send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "MIGRATE_TURRET_HEADS"]);
                                         invoke_ui_locker();
                                     } });
    }; })(spell)}));
}

/** @param {Array.<ContextMenuButton>} buttons */
function add_deploy_squads_button(buttons) {
    var pred = read_predicate({'predicate': 'AND', 'subpredicates':[
        {'predicate':'LIBRARY', 'name':'quarry_play_requirement'},
        {'predicate':'LIBRARY', 'name':'squad_play_requirement'},
        {'predicate':'LIBRARY', 'name':'in_nosql_region'}
    ]});
    var can_view_quarries = pred.is_satisfied(player, null);
    if(can_view_quarries) {
        buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['DEPLOY_SQUADS']['ui_name'],
                                            asset: 'menu_button_resizable',
                                            onclick: function() {
                                               change_selection_ui(null);
                                               var map = invoke_region_map();
                                               if(map) {
                                                   SquadControlDialog.invoke_deploy(player.home_base_loc);
                                               }
                                            }}));
    } else {
        buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['DEPLOY_SQUADS']['ui_name'], onclick: get_requirements_help(pred), state: 'disabled_clickable',
                                            ui_tooltip: gamedata['spells']['DEPLOY_SQUADS']['ui_tooltip_unmet'].replace('%s',pred.ui_describe(player))}));
    }
}

function invoke_building_context_menu(mouse_xy) {
    // assumes relevant building is already selected
    change_selection_ui(null);

    var obj = selection.unit;

    if(!obj || !(obj.is_building() || (obj.is_inert() && obj.team == 'player') || player.is_cheater)) {
        throw Error('context menu invoked without a building or player-owned inert object selected');
    }

    var spec = obj.spec;

    var quarry_movable = (session.is_quarry() && obj.spec['quarry_movable'] && session.viewing_base.base_landlord_id == session.user_id && session.region.data && session.region.data['storage'] == 'nosql');
    var quarry_stats_viewable = (session.is_quarry() && obj.spec['quarry_stats_viewable'] && session.region.data && session.region.data['storage'] == 'nosql');

    var quarry_upgradable = (session.is_quarry() && obj.spec['quarry_upgradable'] && session.viewing_base.base_landlord_id == session.user_id && session.region.data && session.region.data['storage'] == 'nosql');

    var dialog_name = 'building_context_menu';

    // by default, the "Upgrade" button will have the active (yellow) appearance.
    // if you add another button that should take over the active appearance, set this to false.
    var upgrade_is_active = true;

    // need to figure out how many and what buttons to display first,
    // because there are different dialog templates depending on the
    // number of buttons.

    /** @type {Array.<ContextMenuButton>} */
    var buttons = [];

    /** @type {Object.<string, Array.<ContextMenuButton> >} */
    var special_buttons = {}; // for turret heads etc

    if(obj.is_building()) {

        if(session.home_base && obj.is_lottery_building() && !obj.is_under_construction()) {
            upgrade_is_active = false;
            var state = player.get_lottery_state(/** @type {!Building} */ (obj));
            buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['LOTTERY_SCAN']['ui_name'],
                                                state: (state.can_scan ? 'normal': 'disabled_clickable'),
                                                asset: 'action_button_resizable',
                                                ui_tooltip: state.fail_ui_reason,
                                                tooltip_text_color: SPUI.error_text_color,
                                                text_color: (state.can_scan ?
                                                             null // SPUI.make_colorv([0,0,1])
                                                             : SPUI.disabled_text_color),
                                                onclick: (state.can_scan ?
                                                          (function (_obj) { return function() { invoke_lottery_dialog(_obj, 'building_context'); }; })(obj) : state.fail_helper)
                                               }));
        }

        if(session.home_base && obj.is_warehouse() && !obj.is_under_construction()) {
            upgrade_is_active = false; // XXX may want to check for fullness!
            if(player.warehouse_is_busy()) {
                buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['SHOW_INVENTORY']['ui_name'], state: 'disabled', ui_tooltip: gamedata['spells']['SHOW_INVENTORY']['ui_name_busy']}));
            } else {
                buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['SHOW_INVENTORY']['ui_name'], onclick: function(w) { invoke_inventory_dialog(); }}));
            }
        }

        if(session.home_base && obj.spec['name'] == gamedata['squad_building'] && !obj.is_under_construction()) {
            if(obj.spec['name'] !== gamedata['townhall']) { upgrade_is_active = false; }
            if(player.squads_enabled()) {
                // MANAGE SQUADS button
                buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['MANAGE_SQUADS']['ui_name'],
                                                    spellname: 'MANAGE_SQUADS',
                                                    onclick: function() { change_selection_ui(null); SquadControlDialog.invoke_normal(); }}));
                add_deploy_squads_button(buttons);
            }
        }

        if(session.home_base && obj.spec['name'] === gamedata['alliance_building'] && !obj.is_under_construction()) {
            // TRANSMITTER
            upgrade_is_active = false;

            // REINFORCEMENTS button
            var reinforcements_button = null;
            if(player.unit_donation_enabled()) {
                var spell = gamedata['spells']['REQUEST_UNIT_DONATION'];
                var togo = player.cooldown_togo(spell['cooldown_name']);
                if(!session.is_in_alliance()) {
                    reinforcements_button = new ContextMenuButton({ui_name: spell['ui_name'], state: 'disabled', ui_tooltip: spell['ui_tooltip_no_alliance'], asset: 'menu_button_resizable'});
                } else if(player.alliance_building_is_busy()) {
                    reinforcements_button = new ContextMenuButton({ui_name: spell['ui_name'], state: 'disabled', ui_tooltip: spell['ui_tooltip_busy'], asset: 'menu_button_resizable'});
                } else if(player.donated_units_space() >= player.donated_units_max_space()) {
                    reinforcements_button = new ContextMenuButton({ui_name: spell['ui_name'], state: 'disabled', ui_tooltip: spell['ui_tooltip_no_space'], asset: 'menu_button_resizable'});
                } else if(togo > 0) {
                    reinforcements_button = new ContextMenuButton({ui_name: spell['ui_name'], state: 'disabled', ui_tooltip: spell['ui_tooltip_cooldown'].replace('%s',pretty_print_time(togo))});
                } else {
                    reinforcements_button = new ContextMenuButton({ui_name: spell['ui_name'], onclick: (function(_obj) { return function() {
                        request_unit_donation(_obj);
                        GameArt.play_canned_sound('request_unit_donation_sound');
                        change_selection_ui(null);

                        if(gamedata['client']['unit_donation_request_maximize_chat']) {
                            // pop up Alliance chat
                            if(global_chat_frame) {
                                change_chat_tab(global_chat_frame, 'ALLIANCE');
                                chat_frame_size(global_chat_frame, true, true);
                            }
                        }
                        if(1) {
                            // show rising "Reinforcements Requested" text message
                            session.get_real_world().fxworld.add(new SPFX.CombatText([_obj.x,_obj.y], 0,
                                                         gamedata['strings']['combat_messages']['reinforcement_request_sent'],
                                                         [1,1,0.3],
                                                         session.get_real_world().fxworld.now_time(), 3.0,
                                                         { drop_shadow: true, font_size: 20, text_style: 'thick' }));
                        }
                    }; })(obj)});
                }
            }

            // ALLIANCES button
            var alliances_button = null;
            if(1) {
                var pred = read_predicate({'predicate':'LIBRARY','name':'alliance_join_requirement'});
                if(!pred.is_satisfied(player, null)) {
                    alliances_button = new ContextMenuButton({ui_name: gamedata['spells']['SHOW_ALLIANCES']['ui_name'],
                                                              spellname: 'SHOW_ALLIANCES',
                                                              onclick: get_requirements_help(pred,null), state: 'disabled_clickable', ui_tooltip: gamedata['spells']['SHOW_ALLIANCES']['ui_name_unmet'].replace('%s',pred.ui_describe(player))});
                    upgrade_is_active = true; // re-enable upgrade because it might be essential to join an alliance
                } else {
                    alliances_button = new ContextMenuButton({ui_name: gamedata['spells']['SHOW_ALLIANCES']['ui_name'], onclick: invoke_alliance_dialog,
                                                              spellname: 'SHOW_ALLIANCES',
                                                              asset: (session.is_in_alliance() ? 'menu_button_resizable' : 'action_button_resizable')});
                }
            }

            // put most relevant button at top
            if(session.is_in_alliance()) {
                if(reinforcements_button) {
                    buttons.push(reinforcements_button);
                }
                if(alliances_button) {
                    buttons.push(alliances_button);
                }
            } else {
                if(alliances_button) {
                    buttons.push(alliances_button);
                }
                if(reinforcements_button) {
                    buttons.push(reinforcements_button);
                }
            }
        }

        // note: redundant with townhall check below if region_map_building is the same as townhall
        if(session.home_base && obj.spec['name'] === gamedata['region_map_building'] && gamedata['region_map_building'] !== gamedata['townhall'] && !obj.is_under_construction()) {
            // SHOW MAP button
            //add_regional_map_button(buttons);

            // CHANGE REGION button
            add_change_region_button(buttons);
        }

        if(obj.is_damaged() && (!session.home_base || !obj.is_repairing())) {
            buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['REPAIR']['ui_name'], onclick: invoke_repair_dialog}));
        } else if((session.home_base || quarry_upgradable) && (obj.is_repairing() || obj.is_under_construction() || obj.is_removing())) {
            // offer to speed up repairs or construction
            upgrade_is_active = false;
            buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['SPEEDUP_FOR_MONEY']['ui_name'],
                                                spellname: 'SPEEDUP_FOR_MONEY',
                                                onclick: (function (_obj) { return function() {change_selection_unit(_obj); invoke_speedup_dialog('speedup');}; })(obj)
                                               }));
        } else if((session.home_base || quarry_upgradable) && (obj.is_upgrading() || obj.is_enhancing())) {

            // if always_allow_show_building_stats is enabled, show "View Stats";
            if(gamedata['always_allow_show_building_stats']) {
                var spell = gamedata['spells']['SHOW_UPGRADE']
                buttons.push(new ContextMenuButton({ui_name: spell['ui_name_maxlevel'],
                                                    onclick: (function (_obj) { return function() { invoke_upgrade_building_dialog(_obj); }; })(obj),
                                                    spellname: 'INVOKE_UPGRADE_DIALOG',
                                                    asset: 'action_button_resizable'}));
            }

            // if upgrading or enhancing, then just show speedup and cancel
            buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['SPEEDUP_FOR_MONEY']['ui_name'],
                                                spellname: 'SPEEDUP_FOR_MONEY',
                                                onclick: (function (_obj) { return function() {change_selection_unit(_obj); invoke_speedup_dialog('speedup');}; })(obj)
                                               }));
            buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['CANCEL_UPGRADE']['ui_name'],
                                                spellname: 'CANCEL_UPGRADE',
                                                onclick: (function (_obj) { return function() {
                                                    change_selection_ui(null);
                                                    var ingredient_loss = false;
                                                    if(_obj.is_enhancing()) {
                                                        var enh_spec = gamedata['enhancements'][_obj.enhancing['enhance']['spec']];
                                                        if(_obj.enhancing['enhance']['ingredients'] && !enh_spec['refund_ingredients']) {
                                                            ingredient_loss = true;
                                                        }
                                                    }
                                                    invoke_confirm_cancel_message((_obj.is_enhancing() ? 'enhance' : 'upgrade'), (function (__obj) { return function() { send_to_server.func(["CAST_SPELL", __obj.id, (__obj.is_enhancing() ? "CANCEL_ENHANCE" : "CANCEL_UPGRADE")]); }; })(_obj), ingredient_loss);
                                                }; })(selection.unit), asset: 'menu_button_resizable'}));
        } else {
            // not damaged and not upgrading

            if(obj.is_producer()) {
                upgrade_is_active = false;
                if(!session.home_base && gamedata['client']['quarry_collect_poll_interval'] < 0) {
                    // placeholder that tells you to go back home and collect all
                    buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['HARVEST']['ui_name'], state: 'disabled', ui_tooltip: gamedata['spells']['HARVEST']['ui_name_quarry']}));
                } else if(session.home_base) {
                    if(obj.interpolate_contents() >= 1) {
                        buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['HARVEST']['ui_name'], onclick: function() { do_harvest(false); }}));
                    } else {
                        buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['HARVEST']['ui_name'], state: 'disabled',
                                                            ui_tooltip: gamedata['errors']['CANNOT_COLLECT_INSUFFICIENT_CONTENTS']['ui_name'].replace('%s', gamedata['resources'][obj.produces_res()]['ui_name'])}));
                    }

                    if(player.get_any_abtest_value('enable_harvest_all', gamedata['enable_harvest_all'])) {
                        buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['HARVEST_ALL2']['ui_name'], onclick: function() { do_harvest(true); }}));
                    }
                }
            }

            if(session.home_base && obj.is_factory()) {
                upgrade_is_active = false;
                if(obj.is_manufacturing() && player.unit_speedups_enabled()) {
                    buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['SPEEDUP_FOR_MONEY']['ui_name'],
                                                        onclick: (function (_obj) { return function() {change_selection_unit(_obj); invoke_speedup_dialog('speedup');}; })(obj)
                                                       }));
                }
                buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['MAKE_DROIDS']['ui_name'],
                                                    onclick: (function (_obj) { return function() {
                                                       invoke_manufacture_dialog('building_context', _obj.spec['manufacture_category'], null, _obj);
                                                    }; })(obj)}));
            }

            if(session.home_base && obj.is_researcher()) {
                upgrade_is_active = false; // XXX check idle_state for things we can research
                if(obj.is_researching()) {
                    buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['SPEEDUP_FOR_MONEY']['ui_name'],
                                                        spellname: 'SPEEDUP_FOR_MONEY',
                                                        onclick: (function (_obj) { return function() {change_selection_unit(_obj); invoke_speedup_dialog('speedup');}; })(obj)
                                                       }));
                    buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['CANCEL_RESEARCH']['ui_name'],
                                                        onclick: (function (_id) { return function() {
                                                            change_selection_ui(null);
                                                            invoke_confirm_cancel_message('research', (function (__id) { return function() { send_to_server.func(["CAST_SPELL", __id, "CANCEL_RESEARCH"]); }; })(_id));
                                                        }; })(selection.unit.id), asset: 'menu_button_resizable'}));
                } else {
                    buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['RESEARCH_FOR_FREE']['ui_name'],
                                                        spellname: 'RESEARCH_FOR_FREE',
                                                        onclick: (function (_obj) { return function() {
                                                            var category = _obj.spec['research_categories'][0];
                                                            invoke_research_dialog(null, category);
                                                        }; })(obj)}));
                }
            }

            if(obj.is_crafter() && (session.home_base || quarry_upgradable)) {
                upgrade_is_active = false;
                var crafter_cats = obj.spec['crafting_categories'];
                goog.array.forEach(obj.spec['crafting_categories'], function(cat) {
                    if(cat && Array.isArray(cat)){
                        crafter_cats = obj.get_leveled_quantity(obj.spec['crafting_categories']);
                    }
                }, obj);
                var cat = gamedata['crafting']['categories'][crafter_cats[0]];
                if(!cat) {
                    throw Error('Missing crafting_categories for crafter: ' + obj.spec['ui_name']);
                }

                if(!obj.is_emplacement() && !obj.is_security_node_only() && !obj.is_trapped_barrier() && !obj.is_armed_building() && !obj.is_armed_townhall()) { // mounted weapons have special case, see below
                    buttons.push(new ContextMenuButton({ui_name: cat['ui_verb'] || gamedata['spells']['CRAFT_FOR_FREE']['ui_name'],
                                                        asset: 'action_button_resizable',
                                                        onclick: (function (_cat) { return function() {
                                                           if(_cat['dialog'] == 'fishing_dialog') {
                                                               invoke_fishing_dialog();
                                                           } else if(_cat['table_of_contents']) {
                                                               invoke_crafting_table_of_contents_dialog(_cat['name']);
                                                           } else {
                                                               invoke_crafting_dialog(_cat['name']);
                                                           }
                                                        }; })(cat)}));
                }

                if(obj.is_crafting()) {
                    // for turret emplacements, add the speedup/cancel buttons above the divider
                    var which_buttons;
                    if(obj.is_emplacement() || obj.is_security_node_crafting() || obj.is_trapped_barrier() || obj.is_armed_building() || obj.is_armed_townhall()) {
                        if(!special_buttons['mounted']) {special_buttons['mounted'] = [];}
                        which_buttons = special_buttons['mounted'];
                    } else {
                        which_buttons = buttons;
                    }

                    cat = gamedata['crafting']['categories'][gamedata['crafting']['recipes'][obj.is_crafting()]['crafting_category']];
                    if(player.crafting_speedups_enabled() && obj.crafting_progress_one() >= 0) {
                        if(('speedupable' in cat) && !cat['speedupable']) {
                            // cannot be sped up
                        } else {
                            which_buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['SPEEDUP_FOR_MONEY']['ui_name'],
                                                                      onclick: (function (_obj) { return function() {change_selection_unit(_obj); invoke_speedup_dialog('speedup');}; })(obj)
                                                                     }));
                        }
                    }
                    if(('cancelable' in cat) && !cat['cancelable']) {
                        // not cancelable
                    } else if(obj.crafting_progress_one() >= 0) {
                        which_buttons.push(new ContextMenuButton({ui_name: cat['ui_cancel_verb'] || gamedata['spells']['CANCEL_CRAFT']['ui_name'],
                                                                  onclick: (function (_unit, _cat) { return function() {
                                                                      change_selection_ui(null);
                                                                      invoke_confirm_cancel_message(cat['confirm_cancel_kind'] || 'crafting', (function (__unit) {
                                                                          return function() {
                                                                              cancel_unfinished_crafting(__unit);
                                                                          }; })(_unit));
                                                                  }; })(selection.unit, cat), asset: 'menu_button_resizable'}));
                    }
                }
            }

            if(session.home_base && (obj.is_minefield() || obj.is_ambush())) {
                var building_context = '';
                var crafting_category = '';
                var grid_item_name = null;
                if (obj.is_minefield()) {
                    building_context = 'ui_name_building_context_minefield';
                    crafting_category = 'mines';
                    grid_item_name = obj.minefield_item();
                } else if (obj.is_ambush()) {
                    building_context = 'ui_name_building_context_ambush_point';
                    crafting_category = 'ambushes';
                    grid_item_name = obj.ambush_item();
                }
                if(!gamedata['spells']['CRAFT_FOR_FREE'][building_context]) {
                    throw Error('Missing CRAFT_FOR_FREE building context, ' + building_context);
                }
                buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['CRAFT_FOR_FREE'][building_context],
                                                    onclick: (function (_obj) { return function() {
                                                        invoke_crafting_dialog(crafting_category);
                                                    }; })(obj), asset: 'menu_button_resizable'}));
                if(grid_item_name) {
                    var grid_item = ItemDisplay.get_inventory_item_spec(grid_item_name);
                    if(grid_item && grid_item['associated_tech']) {
                        buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['UPGRADE_FOR_FREE']['ui_name'],
                                                            onclick: (function (_techname) { return function() {
                                                                invoke_upgrade_tech_dialog(_techname, null);
                                                            }; })(grid_item['associated_tech']), asset: 'menu_button_resizable'}));
                    }
                }
            }

            if((obj.is_emplacement() || obj.is_security_node() || obj.is_trapped_barrier() || obj.is_armed_building() || obj.is_armed_townhall()) && (session.home_base || quarry_upgradable)) { // special case for mounted weapons
                dialog_name = 'mounted_weapon_context_menu';
                var cur_item = null;
                if (obj.is_emplacement()) {
                    cur_item = obj.turret_head_item();
                } else if (obj.is_trapped_barrier()) {
                    cur_item = obj.barrier_trap_item();
                } else if (obj.is_armed_building()) {
                    cur_item = obj.building_weapon_item();
                } else if (obj.is_armed_townhall()) {
                    cur_item = obj.townhall_weapon_item();
                } else if (obj.is_security_node()) {
                    cur_item = obj.security_node_item();
                }
                var item_spec = (cur_item ? ItemDisplay.get_inventory_item_spec(cur_item['spec']) : null);
                var under_leveled = false;
                if(item_spec && item_spec['associated_tech']) {
                    var tech_level = player.tech[item_spec['associated_tech']] || 0;
                    var item_level = ItemDisplay.get_inventory_item_level(cur_item);
                    if(tech_level > item_spec['level']) {
                        under_leveled = true;

                        // but also check recipe predicate (quarries)
                        if('associated_crafting_recipes' in item_spec) {
                            var recipe = gamedata['crafting']['recipes'][item_spec['associated_crafting_recipes'][0]];
                            goog.array.forEach(['show_if', 'requires'], function(pred) {
                                if(pred in recipe && !read_predicate(recipe[pred]).is_satisfied(player, null)) {
                                    under_leveled = false;
                                }
                            });
                        }
                    }
                }

                if(obj.time_until_finish() <= 0 || (obj.is_security_node() && !obj.is_security_node_crafting())) {
                    var spell = gamedata['spells']['CRAFT_FOR_FREE'];
                    var this_ui_context = 'ui_name_building_context_emplacement';
                    if(!special_buttons['mounted']) {special_buttons['mounted'] = [];}
                    if (obj.is_trapped_barrier()) {
                        this_ui_context = 'ui_name_building_context_barrier_trap';
                    } else if (obj.is_armed_townhall()) {
                        this_ui_context = 'ui_name_building_context_building_weapon';
                    } else if (obj.is_armed_building()) {
                        this_ui_context = 'ui_name_building_context_townhall_weapon';
                    } else if (obj.is_security_node()) {
                        this_ui_context = 'ui_name_building_context_security_node';
                    }
                    special_buttons['mounted'].push(new ContextMenuButton({ui_name: spell[this_ui_context],
                                                                           onclick: (function (_obj) { return function(w) { MountedWeaponDialog.invoke(_obj); }; })(obj),
                                                                           asset: (cur_item && !under_leveled ? 'menu_button_resizable' : null) // yellow only if no mounted weapon is equipped, or weapon is under-leveled
                                                                       }));
                }

                // avoid showing "research" button outside home base
                if(session.home_base && cur_item) {
                    upgrade_is_active = !under_leveled;
                    var upgr_spell = gamedata['spells']['RESEARCH_FOR_FREE'];
                    if(!special_buttons['mounted']) {special_buttons['mounted'] = [];}
                    special_buttons['mounted'].push(new ContextMenuButton({ui_name: upgr_spell[this_ui_context],
                                                                           onclick: (function (_techname) { return function() {
                                                                            // hack (?) to work around issues with upgrade dialog
                                                                            // when looking at a weapon tech with selection.unit still set
                                                                            // (it incorrectly keys the level off the unit, not player.tech)
                                                                            change_selection_unit(null);
                                                                            invoke_upgrade_tech_dialog(_techname, null);
                                                                        }; })(item_spec['associated_tech']), asset: (under_leveled ? 'menu_button_resizable' : 'action_button_resizable')}));
                }
            }

            // can building be upgraded further?

            if(obj.time_until_finish() > 0) {
                // object is busy with something, cannot upgrade
            } else if((session.home_base || quarry_upgradable || quarry_stats_viewable) &&
                      (obj.get_max_ui_level() > 1 || obj.is_storage() ||
                       (('equip_slots' in obj.spec) && !obj.is_minefield() && !obj.is_ambush()))
                     ) {
                var spell = gamedata['spells']['SHOW_UPGRADE'];
                if(obj.level < obj.get_max_ui_level()) {
                    if(gamedata['store']['enable_upgrade_all_barriers'] && (obj.spec['name'] === 'barrier')) {
                        buttons.push(new ContextMenuButton({ui_name: spell['ui_name_all'],
                                                            onclick: function() {
                                                                change_selection_ui(null);
                                                                invoke_store('barriers');
                                                            }}));
                    }
                }

                var migrate_spell = gamedata['spells']['MIGRATE_TURRET_HEADS'];
                if(migrate_spell && obj.spec['history_category'] == 'turrets' && read_predicate(migrate_spell['requires']).is_satisfied(player, null)) {
                    add_migrate_turret_heads_button(buttons);
                } else {
                    // UPGRADE BUTTON

                    // show "View Stats" rather than "Upgrade" if at max level
                    var stats_only = (obj.level >= obj.get_max_ui_level() ||
                                      // or, in a quarry, it's a quarry_stats_viewable but not quarry_upgradable object
                                      (!session.home_base && !quarry_upgradable && quarry_stats_viewable));

                    buttons.push(new ContextMenuButton({ui_name: spell['ui_name'+ (stats_only ? '_maxlevel' : (obj.is_emplacement() ? '_emplacement' : ''))],
                                                        onclick: (function (_obj) { return function() { invoke_upgrade_building_dialog(_obj); }; })(obj),
                                                        spellname: 'INVOKE_UPGRADE_DIALOG',
                                                        asset: (!stats_only && upgrade_is_active ? 'action_button_resizable' : 'menu_button_resizable')}));
                }
            }

            if(session.home_base && obj.spec['name'] == gamedata['townhall']) {
                add_change_region_button(buttons);
            }

        } // END not damaged and not upgrading

    // END is_building()
    } else if(obj.is_inert() && session.home_base && ('spells' in obj.spec)) {
        goog.array.forEach(obj.spec['spells'], function(spellname) {
            if(spellname == "COLLECT_DEPOSIT") {
                var collect_func = (function (_obj) { return function() { do_collect_deposit(_obj); }; })(/** @type {!Inert} */ (obj));
                if(gamedata['enable_oneclick_harvest']) {
                    collect_func();
                } else {
                    var spell = gamedata['spells']['COLLECT_DEPOSIT'];
                    buttons.push(new ContextMenuButton({ui_name: spell['ui_name'], onclick: collect_func}));
                }
            } else if(spellname == "REMOVE_OBSTACLE_FOR_FREE") {
                if(obj.is_removing()) {
                    buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['SPEEDUP_FOR_MONEY']['ui_name'],
                                                        onclick: (function (_obj) { return function() {change_selection_unit(_obj); invoke_speedup_dialog('removing');}; })(obj)
                                                       }));
                } else {
                    var spell = gamedata['spells'][spellname];
                    buttons.push(new ContextMenuButton({ui_name: spell['ui_name'],
                                                        onclick: goog.partial(ObstacleDialog.invoke, obj)}));
                }
            }
        });
    }

    if((obj.is_building() ||
        (obj.is_inert() && player.is_cheater)) &&
       (session.home_base ||
        (quarry_movable &&
         (!(session.viewing_base.base_climate in gamedata['climates']) || !gamedata['climates'][session.viewing_base.base_climate]['exclude_ground_units']))
       )) {
        // "Move" is always the last button
        if(obj.is_building() && (obj.is_repairing() || obj.is_under_construction() || obj.is_upgrading() || obj.is_enhancing() || obj.is_removing()) && !(gamedata['always_allow_move_building'])) {
            // moves are not allowed while repairing, constructing, or upgrading
            // unless 'always_allow_move_building' is set in main.json
        } else {
            buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['MOVE_BUILDING']['ui_name'],
                                                onclick: (function (_obj) { return function() {
                                                    selection.spellname = "MOVE_BUILDING";
                                                    change_selection_ui_under(new BuildUICursor(_obj, _obj.spec));
                                                }; })(obj), asset: 'menu_button_resizable'}));
        }
    }

    if(player.is_cheater) {
        // DEV Delete button
        buttons.push(new ContextMenuButton({ui_name: gamedata['spells']['REMOVE_OBJECT']['ui_name'],
                                            onclick: function() { session.get_real_world().send_and_remove_object(selection.unit); },
                                            asset: 'menu_button_resizable'}));
    }

    if(buttons.length < 1) { return; }

    selection.unit.speak('click');

    if(special_buttons['mounted'] && special_buttons['mounted'].length > gamedata['dialogs']['mounted_weapon_context_menu']['widgets']['mounted_button']['array'][1]) {
        var mounted_error = spec['ui_name'] || spec['name'];
        throw Error('Invalid number of mounted buttons from ' + mounted_error);
    }

    var dialog = invoke_generic_context_menu(mouse_xy, buttons, dialog_name, special_buttons);

    dialog.widgets['bg_close_button'].show = false;

    // fill in building name and level text
    dialog.widgets['title'].str = spec['ui_name'] || spec['name'];

    if(obj.is_building() && obj.get_max_ui_level() > 1) {
        var cur_level = obj.level;
        if(obj.is_upgrading()) {
            cur_level = cur_level.toString() + '->' + (cur_level+1).toString();
        } else {
            cur_level = cur_level.toString();
        }
        var max_level = obj.get_max_ui_level().toString();
        dialog.widgets['level'].str = dialog.data['widgets']['level']['ui_name'].replace('%d0', cur_level).replace('%d1', max_level);
    } else if(obj.is_building() && obj.is_minefield() && (obj.id in session.minefield_tags_by_obj_id)) {
        dialog.widgets['level'].str = session.minefield_tags_by_obj_id[obj.id];

        dialog.widgets['level'].str += ' ('+gamedata['strings'][obj.is_minefield_armed() ? 'minefield_armed' : 'minefield_not_armed']+')';
    } else if(obj.is_building() && obj.is_ambush() && (obj.id in session.ambush_point_tags_by_obj_id)) {
        dialog.widgets['level'].str = session.ambush_point_tags_by_obj_id[obj.id];

        dialog.widgets['level'].str += ' ('+gamedata['strings'][obj.is_ambush_armed() ? 'ambush_point_armed' : 'ambush_point_not_armed']+')';
    }  else if(obj.is_inert() && ('ui_description' in spec)) {
        // this used to be an amount specified in obj.metadata (iron_deposit contents), but we decided to hide it from players
        dialog.widgets['level'].str = obj.get_leveled_quantity(spec['ui_description']).replace('%d', '??');
    } else {
        dialog.widgets['level'].str = '';
    }

    if(dialog_name == 'mounted_weapon_context_menu') {
        var cur_item = false;
        if (obj.is_emplacement()) {
            cur_item = obj.turret_head_item() || obj.turret_head_inprogress_item();
        } else if (obj.is_security_node()) {
            if(obj.is_security_node_crafting()) {
                cur_item = obj.security_node_inprogress_item();
            } else {
                cur_item = obj.security_node_item();
            }
        }  else if (obj.is_trapped_barrier()) {
            cur_item = obj.barrier_trap_item() || obj.barrier_trap_inprogress_item();
        } else if (obj.is_armed_building()) {
            cur_item = obj.building_weapon_item() || obj.building_weapon_inprogress_item();
        } else if (obj.is_armed_townhall()) {
            cur_item = obj.townhall_weapon_item() || obj.townhall_weapon_inprogress_item();
        }
        if(cur_item) {
            var item_spec = ItemDisplay.get_inventory_item_spec(cur_item['spec']);
            if(item_spec) {
                dialog.widgets['mounted_title'].str = ItemDisplay.strip_inventory_item_ui_name_level_suffix(ItemDisplay.get_inventory_item_ui_name(item_spec));
                if(item_spec['associated_tech']) {
                    var item_cur_level = ItemDisplay.get_inventory_item_level(cur_item); // note: level of item itself, NOT the tech
                    var tech_max_level = get_max_ui_level(gamedata['tech'][item_spec['associated_tech']]);
                    dialog.widgets['mounted_level'].show = true;
                    dialog.widgets['mounted_level'].str = dialog.data['widgets']['level']['ui_name'].replace('%d0', item_cur_level).replace('%d1', tech_max_level);
                }
            }
        } else {
            dialog.widgets['mounted_title'].str = dialog.data['widgets']['mounted_title']['ui_name_empty'];
            dialog.widgets['mounted_level'].show = false;
        }
    }

    if(player.tutorial_state === 'speedup_open_context_menu') {
        // hide all buttons except first
        for(var i = 1; i < buttons.length; i++) {
            dialog.widgets['button'+i.toString()].state = 'disabled';
        }
        if(obj.spec['name'] === gamedata['tutorial'][player.tutorial_state]['target']) {
            advance_tutorial();
        }
    }

    return dialog;
}

/** button description for generic context menu
    @constructor @struct
    @param {{ui_name: string,
             onclick: (function(SPUI.DialogWidget)|null|undefined),
             state: (string|null|undefined),
             text_color: (SPUI.Color|null|undefined),
             tooltip_text_color: (SPUI.Color|null|undefined),
             ui_tooltip: (string|null|undefined),
             asset: (string|null|undefined),
             spellname: (string|null|undefined)}} props - spellname is only for tutorial arrow identification
*/
function ContextMenuButton(props) {
    this.ui_name = props.ui_name;
    this.onclick = props.onclick || null;
    this.state = props.state || null;
    this.text_color = props.text_color || null;
    this.tooltip_text_color = props.tooltip_text_color || null;
    this.ui_tooltip = props.ui_tooltip || null;
    this.asset = props.asset || null;
    this.spellname = props.spellname || null;

    // sanity-check parameters
    if(this.asset && !goog.array.contains(['menu_button_resizable','action_button_resizable',null], this.asset)) {
        throw Error('invalid asset '+this.asset);
    }
    if(this.state && !goog.array.contains(['normal','disabled','disabled_clickable'], this.state)) {
        throw Error('invalid state'+this.state);
    }
};

/** @param {!Array.<number>} xy position at which to pop up (screen coordinates)
    @param {Array.<ContextMenuButton>} buttons
    @param {string=} dialog_name from gamedata['dialogs']
    @param {Object.<string, Array.<ContextMenuButton> >=} special_buttons that go in a separately-named widget array, e.g. for turret heads
    @return {!SPUI.Dialog} */
function invoke_generic_context_menu(xy, buttons, dialog_name, special_buttons) {
    dialog_name = dialog_name || 'generic_context_menu';
    if(buttons.length < 1) {
        throw Error('bad number of buttons for '+dialog_name+': '+buttons.length.toString());
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs'][dialog_name]);
    dialog.user_data['dialog'] = 'context_menu';
    dialog.user_data['buttons'] = buttons;
    install_child_dialog(dialog);

    // construct button widgets dynamically
    for(var i = 0; i < buttons.length; i++) {
        var w = SPUI.instantiate_widget(dialog.data['widgets']['button']);
        w.xy = vec_add(dialog.data['widgets']['button']['xy'], vec_scale(i, dialog.data['widgets']['button']['array_offset']));
        dialog.add(w);
        var wname = 'button'+i.toString();
        dialog.widgets[wname] = w;
        if(wname == dialog.data['default_button']) {
            dialog.default_button = w;
        }
    }

    // center the dialog horizontally on xy, and shift it upwards so
    // that the first button is directly underneath the cursor
    var default_button = ('default_button' in dialog.data ? dialog.widgets[dialog.data['default_button']] : dialog.widgets['button0']);
    xy = vec_add(xy, [-Math.floor(dialog.wh[0]/2),Math.floor(-(default_button.xy[1] + default_button.wh[1]/2 + 7))]);

    // resize dialog to fit the proper number of buttons
    var wh = [dialog.wh[0], dialog.data['dimensions'][1] + buttons.length * dialog.data['widgets']['button']['array_offset'][1]];

    // but don't let it go off screen
    if(xy[0] < 0) { xy[0] = 0; }
    if(xy[0] + wh[0] >= canvas_width) { xy[0] = canvas_width - wh[0]; }
    if(xy[1] < 0) { xy[1] = 0; }
    if(xy[1] + wh[1] >= canvas_height) { xy[1] = canvas_height - wh[1]; }
    dialog.xy = vec_sub(xy, dialog.get_absolute_xy());
    dialog.wh = wh;
    dialog.widgets['bg'].wh = wh;

    dialog.widgets['bg_close_button'].onclick = close_parent_dialog;

    // play a "click" sound effect
    GameArt.play_canned_sound('action_button_resizable');

    // fill in buttons
    var button_dict = {'': buttons};
    if(special_buttons) { for(var k in special_buttons) { button_dict[k] = special_buttons[k]; } };

    goog.object.forEach(button_dict, function(buttons, prefix) {
        var i;
        for(i = 0; i < buttons.length; i++) {
            var but = buttons[i];
            var wname = (prefix ? prefix+'_' : '')+'button'+i.toString();
            if(!(wname in dialog.widgets)) {
                var wname_error = null;
                wname_error = 'bad wname '+ wname;
                if(dialog_name === 'mounted_weapon_context_menu') {
                    wname_error = 'bad wname '+ wname + ' for ' + dialog.widgets['title'].str;
                }
                throw Error(wname_error);
            }
            var widget = dialog.widgets[wname];
            if(!but.ui_name) { throw Error('blank ui_name for button on '+dialog_name); }
            widget.str = but.ui_name;
            if(but.text_color) {
                widget.text_color = but.text_color;
            }
            widget.onclick = (function (_cb) { return function(w) {
                close_parent_dialog(w);
                if(_cb) { _cb(w); }
            }; })(but.onclick);
            widget.state = but.state || 'normal';
            widget.tooltip.str = but.ui_tooltip || null;
            if(but.tooltip_text_color) {
                widget.tooltip.text_color = but.tooltip_text_color;
            }
            widget.bg_image = but.asset || widget.data['bg_image'];
        }
        for(; i < dialog.data['widgets'][(prefix ? prefix+'_' : '')+'button']['array'][1]; i++) {
            dialog.widgets[(prefix ? prefix+'_' : '')+'button'+i.toString()].show = false;
        }
    });

    return dialog;
}

// mode is "squads" or "quarries"
function setup_region_map_feature_list_header(dialog, mode) {
    dialog.user_data['mode'] = mode;
    dialog.user_data['expanded'] = false;
    dialog.user_data['expand_time'] = -1;
    dialog.widgets['label'].str = dialog.data['widgets']['label']['ui_name_'+mode];
    dialog.widgets['bgrect'].onclick = function(w) {
        w.parent.user_data['expanded'] = !w.parent.user_data['expanded'];
        if(w.parent.user_data['expanded']) {
            w.parent.user_data['expand_time'] = client_time;
            // contract other lists
            for(var wname in w.parent.parent.widgets) {
                if(wname.indexOf("_list") != -1) {
                    var v = w.parent.parent.widgets[wname];
                    if(v.user_data['expanded'] && v.user_data['mode'] != w.parent.user_data['mode']) {
                        v.user_data['expanded'] = false;
                    }
                }
            }
        }
    };
    dialog.user_data['page'] = 0;
    dialog.ondraw = update_region_map_feature_list_header;
    dialog.on_mousewheel_function = scroll_region_map_feature_list_header;
}

/** @param {SPUI.Dialog} dialog */
function scroll_region_map_feature_list_header(dialog, delta) {
    var current_page = dialog.user_data['page'];
    var mode = dialog.user_data['mode'];
    var feature_list = dialog.user_data['feature_list'] = session.region.find_own_features_by_type((mode == 'squads' ? 'squad' : 'quarry'));
    var max_page = feature_list.length - dialog.data['widgets']['element']['array'][1];
    if(max_page < 1) { return; }
    if(delta < 0 && current_page === 0) { return; }
    if(delta > 0 && current_page === max_page) { return; }
    if(delta > 0) { current_page += 1; }
    if(delta < 0) { current_page -= 1; }
    dialog.user_data['page'] = current_page;
}

/** @param {SPUI.Dialog} dialog */
function update_region_map_feature_list_header(dialog) {
    var mode = dialog.user_data['mode'];
    var feature_list = dialog.user_data['feature_list'] = session.region.find_own_features_by_type((mode == 'squads' ? 'squad' : 'quarry'));
    var display_feature_list = [];
    var current_page = dialog.user_data['page'];
    var max_feature_length = dialog.data['widgets']['element']['array'][1];
    var max_page = feature_list.length - dialog.data['widgets']['element']['array'][1];
    if(max_page < 0) { max_page = 0; }
    dialog.widgets['number'].str = feature_list.length.toString();
    for(var i = current_page; i < (dialog.data['widgets']['element']['array'][1] + max_page); i++) {
        var ft = (i < feature_list.length && dialog.user_data['expanded'] ? feature_list[i] : null);
        display_feature_list.push(ft);
    }
    for(var i = 0; i < dialog.data['widgets']['element']['array'][1]; i ++){
        var ft = (i < display_feature_list.length && dialog.user_data['expanded'] ? display_feature_list[i] : null);
        update_region_map_feature_list_element(dialog.widgets['element'+i.toString()], i, ft);
    }
    dialog.widgets['expand'].show = !dialog.user_data['expanded'];
    dialog.widgets['contract'].show = dialog.user_data['expanded'];
}
function update_region_map_feature_list_element(dialog, i, feature) {
    dialog.user_data['feature'] = feature;
    dialog.show = !!feature;
    if(!feature) { return; }

    if(dialog.parent.user_data['expanded']) {
        var expand_time = dialog.parent.user_data['expand_time'];
        var total_time = dialog.parent.data['widgets']['element']['expand_time']; //  * dialog.parent.user_data['feature_list'].length;
        var progress = clamp((client_time-expand_time)/total_time, 0, 1);
        var end_pos = dialog.parent.data['widgets']['element']['xy'][1] + i*dialog.parent.data['widgets']['element']['array_offset'][1];
        var start_pos = dialog.parent.data['widgets']['element']['xy'][1] - (dialog.parent.user_data['feature_list'].length-i)*dialog.parent.data['widgets']['element']['array_offset'][1];
        dialog.xy = [dialog.xy[0],
                     Math.floor(start_pos + progress*(end_pos-start_pos))];
    }

    dialog.widgets['squad_hp_bar'].show = dialog.widgets['squad_space_bar'].show = (feature['base_type']=='squad');
    dialog.widgets['qicon'].show = dialog.widgets['qsize'].show = (feature['base_type']=='quarry');

    var coords = (feature['base_map_loc'] ? session.region.feature_interpolate_pos(feature)[0] : null);
    if(coords) {
        if(coords[0] === undefined || coords[1] === undefined) {
            throw Error('bad feature_interpolate_pos: '+JSON.stringify(feature));
        }
    }
    dialog.user_data['coords'] = coords;

    dialog.widgets['coords'].str = (coords ? dialog.data['widgets']['coords']['ui_name'].replace('%x', coords[0].toString()).replace('%y', coords[1].toString()) : dialog.data['widgets']['coords']['ui_name_unknown']);

    var onclick = (function (_dialog) { return function(w) {
        var feature = _dialog.user_data['feature'];
        var coords = _dialog.user_data['coords'];
        var mapwidget = _dialog.parent.parent.widgets['map'];
        mapwidget.follow_travel = false;
        if(coords) {
            mapwidget.pan_to_cell(coords, {slowly:true, with_zoom:true});
            // note: re-find the feature here, in case it's a squad stationed at a quarry
            mapwidget.select_feature_at(coords);
        }
    }; })(dialog);

    dialog.widgets['bgrect'].onclick = onclick;

    if(feature['base_type'] == 'squad') {
        var squad_id = parseInt(feature['base_id'].split('_')[1],10);
        if(squad_id === undefined) {
            throw Error('feature with base_type squad but non-squad id: '+(feature['base_id'] ? feature['base_id'] : 'undefined'));
        }
        var squad_data = player.squads[squad_id.toString()] || {};
        var stats = player.get_squad_hp_and_space(squad_id);
        dialog.widgets['name'].str = (squad_data['ui_name'] ? squad_data['ui_name'] : gamedata['strings']['regional_map']['unknown_name']);

        dialog.widgets['icon'].widgets['icon'].transform = null;
        unit_icon_set(dialog.widgets['icon'], feature['base_icon'], 1, null, onclick, null);
        dialog.widgets['icon'].widgets['frame'].tooltip.str = null; // don't want a tooltip

        dialog.widgets['squad_space_bar'].progress = stats['cur_space'] / Math.max(stats['max_space'],1);
        dialog.widgets['squad_hp_bar'].progress = (stats['max_hp'] > 0 ? (stats['cur_hp']/stats['max_hp']) : 0);
    } else if(feature['base_type'] == 'quarry') {
        unit_icon_set(dialog.widgets['icon'], null, -1, null, null, 'normal');
        dialog.widgets['icon'].widgets['icon'].show = dialog.widgets['icon'].widgets['frame'].show = true;
        dialog.widgets['icon'].widgets['icon'].asset = 'region_tiles';
        dialog.widgets['icon'].widgets['icon'].state = 'quarry_'+feature['base_icon'];
        // hack - shrink the icon to fit
        dialog.widgets['icon'].widgets['icon'].transform = [0.66,0,0,0.66,8,10];

        dialog.widgets['icon'].widgets['frame'].onclick = onclick;
        dialog.widgets['name'].str = (feature['base_ui_name'] ? feature['base_ui_name'] : gamedata['strings']['regional_map']['unknown_base']);
        dialog.widgets['qicon'].bg_image = 'resource_icon_'+feature['base_icon'];
        dialog.widgets['qsize'].str = quarry_richness_ui_str(feature['base_richness']);
    } else {
        throw Error('unhandled base_type '+feature['base_type']);
    }
}

/** @param {Array.<number>=} target_loc */
function invoke_region_map(target_loc) {
    change_selection_ui(null);
    if(!player.get_any_abtest_value('enable_region_map', gamedata['enable_region_map'])) { return null; }
    if(!read_predicate(player.get_any_abtest_value('quarry_requirement', gamedata['territory']['quarry_requirement'])).is_satisfied(player, null)) { return null; }
    if(!session.home_base) { return null; }
    if(!session.region.data) { return null; }
    if(!session.region.map_enabled()) { return null; }
    if(resolve_region_map_building_problem()) { return null; }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['region_map_dialog']);
    dialog.user_data['dialog'] = 'region_map_dialog';
    dialog.user_data['first_fetch'] = false;
    dialog.user_data['last_map_ping_time'] = -1;
    dialog.user_data['finder_expanded'] = false;
    dialog.user_data['finder_states'] = {
        'attacker': region_map_finder_state_init(),
        'hive': region_map_finder_state_init(),
        'hive_token': region_map_finder_state_init(),
        'raid': region_map_finder_state_init(),
        'strongpoint': region_map_finder_state_init(),
        'quarry_logistics': region_map_finder_state_init()
    };
    for(var res in gamedata['resources']) {
        dialog.user_data['finder_states']['quarry_'+res] = region_map_finder_state_init();
        if(gamedata['resources'][res]['show_hive_finder']) {
            dialog.user_data['finder_states']['hive_'+res] = region_map_finder_state_init();
        }
    }
    dialog.user_data['finder_button_indexes'] = {}; // for tutorial arrows, maps kind to misc_finder button index
    dialog.user_data['recent_attacker_ids'] = null; // for attacker finder

    dialog.user_data['refresh_text_start_time'] = -1;
    dialog.user_data['refresh_text_start_step'] = 0;

    change_selection_ui(dialog);
//    dialog.auto_center();
    dialog.modal = false; // !
    dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };
    dialog.widgets['map'].set_region(session.region);
    dialog.widgets['map'].gfx_detail = SPFX.detail;
    dialog.widgets['refresh_button'].state = 'disabled';
    dialog.widgets['refresh_button'].onclick = function(w) {
        session.region.dirty = true;
        w.parent.user_data['refresh_text_start_time'] = -1;

        session.region.call_when_fresh((function (_w) { return function() {
            var dialog = _w.parent;
            if(dialog) {
                if(!dialog.user_data['first_fetch']) {
                    // on manual clicks of refresh button, clear the PlayerCache (except for yourself) to get rid of stale info
                    PlayerCache.clear_all_except(session.user_id);
                    PlayerCache.force_fetch(session.user_id); // request fresh update of yourself immediately
                }

                // need this to snap to home location on first open of the Regional Map
                if(!dialog.user_data['first_fetch'] &&
                   dialog.widgets['map'].follow_travel) {
                    dialog.widgets['map'].go_home();
                    dialog.user_data['first_fetch'] = true;
                }
                dialog.user_data['refresh_text_start_time'] = client_time;
                dialog.user_data['refresh_text_start_step'] = 0;
            }
        }; })(w));
    }
    dialog.widgets['home_button'].onclick = function(w) {
        var dialog = w.parent;
        dialog.widgets['map'].follow_travel = false;
        dialog.widgets['map'].go_home({do_select:true, slowly:true, with_zoom:true});
    }
    dialog.widgets['finder_toggle'].onclick = function(w) {
        var dialog = w.parent;
        dialog.user_data['finder_expanded'] = !dialog.user_data['finder_expanded'];
    }
    dialog.widgets['manage_squads_button'].onclick = function(w) {
        SquadControlDialog.invoke_manage();
    };
    dialog.widgets['bookmarks_button'].onclick = function(w) {
        var dialog = w.parent;
        invoke_map_bookmarks_dialog(dialog.widgets['map']);
    };
    dialog.widgets['map'].set_zoom_buttons(dialog.widgets['zoom_in_button'], dialog.widgets['zoom_out_button']);

    if(session.region.data['storage'] == 'nosql') {
        setup_region_map_feature_list_header(dialog.widgets['squad_list'], 'squads');
    } else {
        dialog.widgets['squad_list'].show =
            dialog.widgets['help_button'].show =
            dialog.widgets['help_jewel'].show =
            dialog.widgets['manage_squads_button'].show = false;
    }
    setup_region_map_feature_list_header(dialog.widgets['quarry_list'], 'quarries');

    dialog.widgets['battle_history_button'].onclick = function(w) { invoke_battle_history_dialog(session.user_id, -1, session.alliance_id, '', -1, w); };
    dialog.widgets['battle_history_jewel'].ondraw = update_notification_jewel;
    dialog.widgets['help_button'].onclick = function(w) { invoke_region_map_help(); };
    dialog.widgets['help_jewel'].ondraw = update_notification_jewel;

    dialog.ondraw = update_region_map;
    map_dialog_default_page = 'quarries';

    if(target_loc) {
        dialog.widgets['map'].follow_travel = false;
        dialog.widgets['map'].pan_to_cell(target_loc);
    }

    if(player.get_any_abtest_value('region_map_scroll_help', gamedata['territory']['scroll_help']) &&
       !player.check_feature_use('region_map_scroll_help_closed')) {
        invoke_region_map_scroll_help(dialog);
    }
    return dialog;
}

function invoke_region_map_scroll_help(parent) {
    player.record_feature_use('region_map_scroll_help');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['region_map_scroll_help']);
    dialog.user_data['dialog'] = 'region_map_scroll_help';
    dialog.user_data['map_widget'] = parent.widgets['map'];
    dialog.modal = false;
    install_child_dialog(dialog);
    dialog.ondraw = update_region_map_scroll_help;
    dialog.widgets['close_button'].onclick = function(w) {
        close_parent_dialog(w);
        player.record_feature_use('region_map_scroll_help_closed');
    }
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_region_map_scroll_help(dialog) {
    if(dialog.user_data['map_widget'].parent) {
        // center on parent dialog's map widget
        dialog.xy = vec_add(dialog.user_data['map_widget'].xy,
                            vec_floor(vec_scale(0.5, vec_sub(vec_mul([1,0.66], dialog.user_data['map_widget'].wh), dialog.wh))));
    }
}

// if a home_base_relocator_anywhere item is available, return a function that will open the Store to it, otherwise null
/** @param {Array.<Object>=} skulist
    @param {Array.<Object>=} path */
function continent_bridge_available(skulist, path) {
    if(!skulist) { skulist = gamedata['store']['catalog']; }
    if(!path) { path = []; }

    for(var i = 0; i < skulist.length; i++) {
        var entry = skulist[i];
        if('skus' in entry) {
            var b = continent_bridge_available(entry['skus'], path.concat(entry));
            if(b) { return b; }
        } else if('item' in entry && entry['item'] == 'home_base_relocator_anywhere') {
            // found it
            console.log("HERE"); console.log(entry);
            return (function (_path) { return function() { invoke_new_store_category(_path[_path.length-1], (_path.length>1 ? _path.slice(0,_path.length-1) : null)); }; })(path);
        }
    }
    return null;
}

function invoke_find_on_map(region_id, target_loc) {
    if(!(region_id in gamedata['regions'])) { return; }
    if(session.region.data && session.region.data['id'] == region_id) {
        // in same region
        if(target_loc[0] >= 0 && target_loc[0] < session.region.data['dimensions'][0] &&
           target_loc[1] >= 0 && target_loc[1] < session.region.data['dimensions'][1]) {
            if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] === 'region_map_dialog') {
                // map dialog up, just move it there
                selection.ui.widgets['map'].pan_to_cell(target_loc, {slowly:1});
            } else {
                // map dialog not up
                invoke_region_map(target_loc);
            }
        }
    } else {
        // not in same region, prompt to relocate.
        var reg = gamedata['regions'][region_id];
        var pred_ok = ((!('show_if' in reg) || read_predicate(reg['show_if']).is_satisfied(player,null)) &&
                       (!('requires' in reg) || read_predicate(reg['requires']).is_satisfied(player,null)));
        if(pred_ok) {
            // reuse the code from the building context menu
            var btn = [];
            add_change_region_button(btn);
            var s = gamedata['strings']['find_in_different_region'];
            invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%region', gamedata['regions'][region_id]['ui_name']),
                                        {'dialog': 'message_dialog_big',
                                         'cancel_button':true, 'close_button':true,
                                         'ok_button_ui_name': s['ui_button'],
                                         'on_ok': btn[0].onclick,
                                         'ok_button_state': btn[0].state || 'normal',
                                         'ok_button_tooltip':btn[0].ui_tooltip});
        } else {
            // different continent
            var bridge = continent_bridge_available();
            if(bridge) {
                var s = gamedata['strings']['find_in_different_region_locked_bridge'];
                invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%region', gamedata['regions'][region_id]['ui_name']),
                                            {'dialog': 'message_dialog_big'});
                // link to store:
//                                            {'dialog': 'message_dialog_big', 'close_button':true, 'cancel_button': true,
//                                             'ok_button_ui_name': s['ui_button'], 'on_ok': bridge});
            } else {
                var s = gamedata['strings']['find_in_different_region_locked'];
                invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%region', gamedata['regions'][region_id]['ui_name']),
                                            {'dialog': 'message_dialog_big'});
            }
        }
    }
}

function toggle_region_map() {
    if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] === 'region_map_dialog') {
        change_selection_ui(null);
    } else {
        invoke_region_map();
    }
}

/** @param {SPUI.Dialog} dialog */
function update_region_map(dialog) {
    update_map_dialog_header_buttons(dialog.widgets['header_buttons']);

    if(player.raids_enabled()) {
        var left = player.raid_pvp_attempts_left();
        var togo = player.raid_pvp_attempt_next_in();
        var ui_text;
        if(togo > 0) {
            ui_text = dialog.data['widgets']['raid_pvp_attempts']['ui_name_next'].replace('%d', left).replace('%s', pretty_print_time(togo));
        } else {
            ui_text = dialog.data['widgets']['raid_pvp_attempts']['ui_name_full'].replace('%d', left);
        }
        dialog.widgets['raid_pvp_attempts'].set_text_bbcode(ui_text);

    } else {
        dialog.widgets['raid_pvp_attempts'].show = false;
    }

    dialog.widgets['map'].time = server_time;

    dialog.widgets['battle_history_jewel'].user_data['count'] = player.new_battle_histories;
    dialog.widgets['help_jewel'].user_data['count'] = (player.check_feature_use('region_map_help') ? 0 : 1);

    var ok_to_send_query = (last_quarry_query_time == -1 ||
                            (last_quarry_query_time > 0 && client_time > (last_quarry_query_time+gamedata['rival_query_cooldown'])));

    dialog.widgets['refresh_button'].state = ok_to_send_query ? 'normal' : 'disabled';

    if(last_quarry_query_time == -1 || session.region.dirty) {
        // start initial refresh
        dialog.widgets['refresh_button'].onclick(dialog.widgets['refresh_button']);
    }

    if(!gamedata['client']['enable_ajax_longpoll'] && last_quarry_query_time > 0 && ok_to_send_query && gamedata['client']['map_ping_interval'] > 0) {
        if(client_time - dialog.user_data['last_map_ping_time'] >= gamedata['client']['map_ping_interval']) {
            dialog.user_data['last_map_ping_time'] = client_time;
            send_to_server.func(["PING_MAP"]);
        }
    }

    // show "Loading..." only during true query latency
    dialog.widgets['loading_rect'].show =
        dialog.widgets['loading_text'].show =
        dialog.widgets['loading_spinner'].show = (last_quarry_query_time == 0);

    if(dialog.widgets['loading_text'].show) {
        var prog = session.region.refresh_progress();
        if(prog >= 0) {
            prog = Math.min(prog, 0.99);
            dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name_progress'].replace('%pct', (100.0*prog).toFixed(0));
        } else {
            dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name'];
        }
    }

    dialog.widgets['refresh_text'].show = !dialog.widgets['loading_rect'].show;
    if(dialog.widgets['refresh_text'].show) {
        if(dialog.user_data['refresh_text_start_time'] < 0) {
            dialog.user_data['refresh_text_start_time'] = client_time;
            dialog.user_data['refresh_text_start_step'] = 0;
        }
        var t = client_time - dialog.user_data['refresh_text_start_time'];
        var step = Math.floor(t / dialog.data['widgets']['refresh_text']['update_interval']) + dialog.user_data['refresh_text_start_step'];
        var words = dialog.data['widgets']['refresh_text']['ui_name_anim'].split('|');
        if(step < 0 || step >= words.length) {
            dialog.user_data['refresh_text_start_time'] = client_time;
            dialog.user_data['refresh_text_start_step'] = Math.floor(Math.random()*dialog.data['widgets']['refresh_text']['random_skip']);
            step = 0;
        }
        dialog.widgets['refresh_text'].str = words[step];
    }

    // update header/footer
    var region_name = session.region.data['ui_name'];
    var cursor_coords = (dialog.widgets['map'].hovercell ? '('+dialog.widgets['map'].hovercell[0].toString()+','+dialog.widgets['map'].hovercell[1].toString()+')' : '');
    goog.array.forEach(['region_name','cursor_coords'], function(wname) {
        dialog.widgets[wname].str = dialog.data['widgets'][wname]['ui_name'].replace('%REGION', region_name).replace('%CURSOR', cursor_coords);
    });

    if(session.region.data['enable_turf_control']) {
        var points_to_win = session.region.turf_points_to_win();
        if(points_to_win > 0) {
        // find last turf winner
        var turf_leader = AllianceCache.turf_get_leader_by_region(session.region.data['id']);
        var turf_leader_info = null;
        if(turf_leader && turf_leader['alliance_id'] >= 0) {
            turf_leader_info = AllianceCache.query_info(turf_leader['alliance_id'], null);
        }
        dialog.widgets['turf_winner'].show = true; // !!turf_winner_alliance;
        if(dialog.widgets['turf_winner'].show) {
            if(turf_leader_info && turf_leader['points'] >= points_to_win) {
                // clear winner
                dialog.widgets['turf_winner'].str = dialog.data['widgets']['turf_winner']['ui_name'].replace('%s', alliance_display_name(turf_leader_info));
                dialog.widgets['turf_winner'].text_color = SPUI.make_colorv(dialog.data['widgets']['turf_winner']['text_color']);
                dialog.widgets['turf_winner'].onclick = (function (_id) { return function() { invoke_alliance_info(_id); }; })(turf_leader['alliance_id']);
            } else if(turf_leader && turf_leader['points'] >= points_to_win) {
                // tie
                dialog.widgets['turf_winner'].str = dialog.data['widgets']['turf_winner']['ui_name_tie'].replace('%d', turf_leader['points'].toString());
                dialog.widgets['turf_winner'].text_color = SPUI.make_colorv(dialog.data['widgets']['turf_winner']['text_color_tie']);
                dialog.widgets['turf_winner'].onclick = null;
            } else {
                // nobody crossed the threshold
                dialog.widgets['turf_winner'].str = dialog.data['widgets']['turf_winner']['ui_name_insufficient_points'].replace('%d', points_to_win.toString());
                dialog.widgets['turf_winner'].text_color = SPUI.make_colorv(dialog.data['widgets']['turf_winner']['text_color_insufficient_points']);
                dialog.widgets['turf_winner'].onclick = null;
            }
        }

        var next_check = AllianceCache.turf_get_next_check_by_region(session.region.data['id']);
        dialog.widgets['turf_standings_label'].show = (next_check > 0);
        if(next_check > 0) {
            var soon_minutes = dialog.data['widgets']['turf_standings_label']['soon_minutes'];
            var togo_min = Math.ceil((next_check - server_time)/60.0);
            togo_min = Math.max(togo_min, soon_minutes);
            if(togo_min <= soon_minutes) {
                dialog.widgets['turf_standings_label'].str = dialog.data['widgets']['turf_standings_label']['ui_name_soon'].replace('%d', soon_minutes.toFixed(0));
            } else {
                dialog.widgets['turf_standings_label'].str = dialog.data['widgets']['turf_standings_label']['ui_name'].replace('%d', togo_min.toFixed(0));
            }

            dialog.widgets['turf_standings'].show = true;
            dialog.widgets['turf_standings'].str = session.region.display_turf_standings(dialog.data['widgets']['turf_standings']);
        }
    } }

    dialog.widgets['hover_alliance'].show = (dialog.widgets['map'].hover_alliance >= 0 && dialog.widgets['map'].zoom < gamedata['territory']['tile_fade_zoom'][0]);
    if(dialog.widgets['hover_alliance'].show) {
        var alinfo = AllianceCache.query_info(dialog.widgets['map'].hover_alliance);
        var name = (alinfo && ('ui_name' in alinfo)) ? alliance_display_name(alinfo) : '';
        dialog.widgets['hover_alliance'].str = dialog.data['widgets']['hover_alliance']['ui_name'].replace('%ALLIANCE', name);
        dialog.widgets['hover_alliance'].text_color = SPUI.make_colorv(gamedata['territory']['influence']['hover_alliance_'+(dialog.widgets['map'].hover_alliance == session.alliance_id ? 'friendly' : 'hostile')]['label_color']);
    }

    // fade notifications
    dialog.widgets['notifications'].revise_all_text(function(original_text, user_data) {
        var elapsed = client_time - user_data['time'];
        var hold_time = 3, fade_time = 3;
        var alpha;
        if(elapsed < hold_time) {
            alpha = 1;
        } else {
            alpha = Math.max(0, 1 - (elapsed - hold_time)/fade_time);
        }
        goog.array.forEach(original_text[0], function(ablock) {
            ablock.props.alpha = alpha;
            if(alpha <= 0) {
                ablock.props.onclick = null;
            }
        });
        return original_text;
    });

    // update bookmarks state
    dialog.widgets['bookmarks_button'].state = ((dialog.widgets['map'].region && (dialog.widgets['map'].region.data['id'] in player.map_bookmarks) && (player.map_bookmarks[dialog.widgets['map'].region.data['id']].length >= 1)) ? 'normal' : 'disabled');

    // get finder state updates
    var finder_updates = goog.object.map(dialog.user_data['finder_states'], function(state, kind) {
        if(kind == 'attacker' || dialog.user_data['finder_expanded']) {
            return region_map_finder_update(dialog, kind, state);
        } else {
            return null; // don't bother updating if hidden
        }
    });

    // attacker_finder is always available even if the other buttons are collapsed
    finder_updates['attacker'].apply_to_button(dialog.widgets['attacker_finder']);
    dialog.widgets['attacker_finder_spinner'].show = finder_updates['attacker'].show && finder_updates['attacker'].pending;

    dialog.widgets['finder_toggle'].str = dialog.data['widgets']['finder_toggle'][dialog.user_data['finder_expanded'] ? 'ui_name_expanded' : 'ui_name_collapsed'];
    dialog.widgets['finder_toggle'].state = dialog.data['widgets']['finder_toggle'][dialog.user_data['finder_expanded'] ? 'state_expanded' : 'state_collapsed'];
    dialog.widgets['finder_bgrect'].show = dialog.user_data['finder_expanded'];
    var n_finders_shown = 0;
    dialog.user_data['finder_button_indexes'] = {};
    if(dialog.user_data['finder_expanded']) {
        var kinds = goog.object.getKeys(finder_updates);

        // establish the order they will appear in the GUI, bottom-to-top
        kinds.sort();

        goog.array.forEach(kinds, function(kind) {
            if(kind == 'attacker') { return; }
            var update = finder_updates[kind];
            if(!update) { return; }
            if(n_finders_shown >= dialog.data['widgets']['misc_finder']['array'][1]) { return; } // can't show
            if(update.show) {
                update.apply_to_button(dialog.widgets['misc_finder'+n_finders_shown.toString()]);
                dialog.user_data['finder_button_indexes'][kind] = n_finders_shown;
                n_finders_shown += 1;
            }
        });

        // resize bgrect to fit around visible buttons
        dialog.widgets['finder_bgrect'].wh = [dialog.data['widgets']['finder_bgrect']['dimensions'][0],
                                              dialog.data['widgets']['finder_bgrect']['dimensions'][1] + n_finders_shown * Math.abs(dialog.data['widgets']['misc_finder']['array_offset'][1])];
    }
    for(var i = n_finders_shown; i < dialog.data['widgets']['misc_finder']['array'][1]; i++) {
        dialog.widgets['misc_finder'+i.toString()].show = false;
    }

    // dynamic resizing, making room for chat
    var console_shift = get_console_shift();
    dialog.wh = vec_max(vec_floor(vec_scale(0.9, [canvas_width-console_shift, canvas_height])), dialog.data['min_dimensions']);
    dialog.widgets['bg'].wh = dialog.wh;
    dialog.apply_layout();
//    dialog.auto_center();
    dialog.xy = vec_floor(vec_add(vec_scale(0.05, [canvas_width,canvas_height]), [Math.floor(console_shift),0]));
    dialog.on_resize();

    if(dialog.user_data['finder_expanded']) {
        // manual reposition, since layout doesn't work for an upwardly-expanding box
        dialog.widgets['finder_bgrect'].xy = [dialog.data['widgets']['finder_bgrect']['xy'][0],
                                              dialog.wh[1] - dialog.data['dimensions'][1] + dialog.data['widgets']['finder_bgrect']['xy'][1] -
                                              n_finders_shown * Math.abs(dialog.data['widgets']['misc_finder']['array_offset'][1])];
    }
}

/** Add a new message to the notification widget
    @param {!SPUI.Dialog} dialog
    @param {string} bbcode
    @param {Object=} props for SPText */
function region_map_display_notification(dialog, bbcode, props) {
    if(!props) { props = {}; }
    // save client_time for fading animation
    dialog.widgets['notifications'].append_text(SPText.cstring_to_ablocks_bbcode(bbcode, props), {'time': client_time});
}

function region_map_finder_state_init() { return {'time':-1, 'found':null, 'index':-1, 'pred':null}; };

/** @constructor @struct
    @param {boolean} show
    @param {boolean} pending
    @param {string|null} button_name
    @param {string|null} button_state
    @param {string|null} tooltip_str
    @param {function(!SPUI.DialogWidget=)|null} onclick */
function RegionMapFinderUpdateResult(show, pending, button_name, button_state, tooltip_str, onclick) {
    this.show = show;
    this.pending = pending;
    this.button_name = button_name;
    this.button_state = button_state;
    this.tooltip_str = tooltip_str;
    this.onclick = onclick;
};
/** @param {!SPUI.ActionButton} w */
RegionMapFinderUpdateResult.prototype.apply_to_button = function(w) {
    w.show = this.show;
    if(this.show) {
        w.state = this.button_state || 'disabled';
        w.str = this.button_name;
        w.tooltip.str = this.tooltip_str;
        w.onclick = this.onclick;
    }
};

/** @return {!RegionMapFinderUpdateResult} */
function region_map_finder_update(dialog, kind, state) {
    var kind_root = kind.split('_')[0]; // raid, hive, quarry, etc
    var kind_res = (kind.indexOf('_') > 0 ? kind.split('_')[1] : null);

    if(kind == 'attacker') {
        // send battle history query
        if(dialog.user_data['recent_attacker_ids'] === null ||
           dialog.user_data['recent_attacker_ids']['pending']) {
            if(dialog.user_data['recent_attacker_ids'] === null) {
                dialog.user_data['recent_attacker_ids'] = {'pending':1};
                query_recent_attackers((function (_dialog) { return function(attacker_id_list) {
                    _dialog.user_data['recent_attacker_ids'] = {};
                    goog.array.forEach(attacker_id_list, function(other_id) {
                        if(other_id && !is_ai_user_id_range(other_id)) {
                            _dialog.user_data['recent_attacker_ids'][other_id] = 1;
                        }
                    });
                }; })(dialog));
            }
            return new RegionMapFinderUpdateResult(true, true, dialog.data['widgets']['attacker_finder']['ui_name'], 'disabled', dialog.data['widgets']['attacker_finder']['ui_tooltip'], null);
        }
    }

    // clear state if enough time has passed
    if(client_time - state['time'] >= gamedata['territory']['finder_reset_time']) {
        state['time'] = -1;
        state['index'] = -1;
//        state['found'] = null; // rescan?
//        state['pred'] = null;
    }

    if(state['found'] === null && !session.region.dirty) {
        state['found'] = [];
        var min_difficulty = Infinity;

        dialog.widgets['map'].region.for_each_feature(function(f) {
            var found = null;

            // hive_token: attackable hive with ui_tokens2
            if(kind_root == 'raid' || kind_root == 'hive') {
                if(f['base_type'] == kind_root &&
                   (kind_root == 'raid' ||
                    (kind_res == 'token' && ('base_template' in f) && (f['base_template'] in gamedata[kind_root+'s_client']['templates']) &&
                     gamedata[kind_root+'s_client']['templates'][f['base_template']]['ui_tokens2']) ||
                    (kind_res && kind_res in gamedata['resources'] && ('base_resource_loot' in f) && f['base_resource_loot'][kind_res] || 0) ||
                    kind_res === null
                   )) {
                    var pred = (!player.is_cheater && ('activation' in gamedata[kind_root+'s_client']['templates'][f['base_template']]) ? read_predicate(gamedata[kind_root+'s_client']['templates'][f['base_template']]['activation']) : null);
                    if(pred && !pred.is_satisfied(player, null)) {
                        // locked
                        // remember the "easiest" unsatisfied predicate, so that players see the least amount of work they need to do to unlock any hive
                        var difficulty = pred.ui_difficulty();
                        if (difficulty < min_difficulty) {
                            state['pred'] = pred;
                            min_difficulty = difficulty;
                        }
                        return;
                    }
                    // unlocked
                    found = f;
                }
            } else if(kind_root == 'strongpoint' || kind_root == 'quarry') {
                if(f['base_landlord_id'] != session.user_id &&
                   f['base_type'] == 'quarry' &&
                   ((kind_root == 'strongpoint' && ('base_template' in f) && (f['base_template'] in gamedata['quarries_client']['templates']) &&
                     gamedata['quarries_client']['templates'][f['base_template']]['turf_points']) ||
                    (kind_root == 'quarry' && kind_res && f['base_icon'] == kind_res))) {

                    if(session.is_in_alliance()) {
                        var info = PlayerCache.query_sync_fetch(f['base_landlord_id']);
                        if(info && ('alliance_id' in info) && info['alliance_id'] == session.alliance_id) {
                            return; // owned by alliancemate
                        }
                    }

                    var pred = (!player.is_cheater && (f['base_template'] in gamedata['quarries_client']['templates']) && ('activation' in gamedata['quarries_client']['templates'][f['base_template']]) ? read_predicate(gamedata['quarries_client']['templates'][f['base_template']]['activation']) : null);
                    if(pred && !pred.is_satisfied(player, null)) {
                        // locked
                        state['pred'] = pred;
                        return;
                    }
                    // unlocked
                    found = f;
                }
            } else if(kind == 'attacker') {
                // attacker: someone who attacked us recently
                if(f['base_type'] == 'home' && f['base_landlord_id'] && (f['base_landlord_id'] in dialog.user_data['recent_attacker_ids'])) {
                    found = f;
                }
            }

            if(found) {
                state['found'].push(f);
            }
        });

        // sort in order of distance to home base
        state['found'].sort(function(a, b) {
            var da = vec_length2(vec_sub(a['base_map_loc'], player.home_base_loc));
            var db = vec_length2(vec_sub(b['base_map_loc'], player.home_base_loc));
            if(da < db) {
                return -1;
            } else if(da > db) {
                return 1;
            } else {
                return 0;
            }
        });
    }

    var show = ((state['found'] !== null && state['found'].length > 0) || !!state['pred']);
    var button_name;
    var button_state = 'disabled';
    var tooltip_str;
    var onclick;
    if(show) {
        var ui_res = ''; // "Iron/Water/Logistics" etc for quarries
        if(kind_res) {
            if(kind_res in gamedata['resources']) {
                ui_res = gamedata['resources'][kind_res]['ui_name'];
            } else if(kind_res in gamedata['items']) {
                ui_res = gamedata['items'][kind_res]['ui_name'];
            } else if(kind_res in gamedata['strings']['regional_map']) {
                ui_res = goog.string.trim(gamedata['strings']['regional_map'][kind_res].replace('%s',''));
            } else {
                throw Error('ui_res not found for '+kind_res);
            }
        }

        if(kind_root == 'quarry') {
            if('ui_name_quarry_'+kind_res in dialog.data['widgets']['misc_finder']) {
                button_name = dialog.data['widgets']['misc_finder']['ui_name_quarry_'+kind_res].replace('%s', ui_res);
                tooltip_str = dialog.data['widgets']['misc_finder']['ui_tooltip_quarry_'+kind_res].replace('%s', ui_res);
            } else {
                button_name = dialog.data['widgets']['misc_finder']['ui_name_quarry'].replace('%s', ui_res);
                tooltip_str = dialog.data['widgets']['misc_finder']['ui_tooltip_quarry'].replace('%s', ui_res);
            }
            player.record_feature_use('quarry_finder_seen');
        } else {
            button_name = dialog.data['widgets']['misc_finder']['ui_name_'+kind].replace('%s', ui_res);
            tooltip_str = dialog.data['widgets']['misc_finder']['ui_tooltip_'+kind].replace('%s', ui_res);
            player.record_feature_use(kind+'_finder_seen');
        }

        if(state['found'] !== null && state['found'].length > 0) {
            // valid base
            button_state = (kind == 'attacker' ? 'attack' : 'normal');

            onclick = (function (_kind, _state) { return function(w) {
                player.record_feature_use(_kind.indexOf('quarry_') == 0 ? 'quarry_finder_used' : (_kind+'_finder_used'));
                var dialog = w.parent;
                var idx = (_state['index']+1) % _state['found'].length;
                var feature = _state['found'][idx];
                // record state so we don't find it again for a while
                _state['time'] = client_time;
                _state['index'] = idx;
                dialog.widgets['map'].follow_travel = false;
                dialog.widgets['map'].pan_to_cell(feature['base_map_loc'], {slowly:true, with_zoom:false});
                dialog.widgets['map'].select_feature_at(feature['base_map_loc']);
            }; })(kind, state);
        } else {
            // all locked
            tooltip_str = dialog.data['widgets']['misc_finder']['ui_tooltip_locked'].replace('%s', state['pred'].ui_describe(player, null));
            var helper = get_requirements_help(state['pred'], null);
            if(helper) {
                button_state = 'disabled_clickable';
                onclick = (function (_helper) { return function(w) { _helper(); }; })(helper);
            } else {
                button_state = 'disabled';
            }
        }
    }

    return new RegionMapFinderUpdateResult(show, false, button_name, button_state, tooltip_str, onclick);
}

/** @param {SPUI.Dialog} dialog */
function update_map_dialog_header_buttons(dialog) {
    dialog.user_data['buttons'] = [];
    var i = 0;

    // RIVALS button

    // use this instead of player.is_ladder_player() since that one checks pvp_requirement predicate
    var ladder_available = gamedata['ladder_pvp'] || (session.region && session.region.data && session.region.data['ladder_pvp']);

    if(player.tutorial_state === "COMPLETE" &&
       (player.is_legacy_pvp_player() || ladder_available)) {
        var pvp_pred = read_predicate({'predicate':'LIBRARY', 'name':'pvp_requirement'});

        if(!pvp_pred.is_satisfied(player,null)) {
            dialog.user_data['buttons'].push('rivals');
            dialog.widgets['button'+i.toString()].show = true;
            dialog.widgets['button'+i.toString()].str = dialog.data['widgets']['button']['ui_name_rivals'];
            dialog.widgets['warning_text'+i.toString()].show = false;
            dialog.widgets['button'+i.toString()].state = 'disabled_clickable';
            var ui_req = pvp_pred.ui_describe(player);
            dialog.widgets['button'+i.toString()].tooltip.str = (ui_req ? dialog.data['widgets']['button']['ui_tooltip_unmet'].replace('%s', ui_req) : null);
            dialog.widgets['button'+i.toString()].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['button'+i.toString()].onclick = get_requirements_help(pvp_pred);
            i += 1;
        } else {
            dialog.user_data['buttons'].push('rivals');
            dialog.widgets['button'+i.toString()].show = true;
            dialog.widgets['button'+i.toString()].str = dialog.data['widgets']['button']['ui_name_rivals'];
            dialog.widgets['warning_text'+i.toString()].show = false;
            dialog.widgets['button'+i.toString()].state = (dialog.parent.user_data['dialog'] === 'map_ladder_pvp_dialog' || (dialog.parent.user_data['dialog'] === 'map_dialog' && dialog.parent.user_data['chapter'] === 'rivals') ? 'active' : 'normal');
            dialog.widgets['button'+i.toString()].onclick = function(w) {
                if(w.parent.parent.user_data['dialog'] === 'map_ladder_pvp_dialog') {
                    return;
                } else if(player.is_ladder_player()) {
                    invoke_map_ladder_pvp();
                } else if(w.parent.parent.user_data['dialog'] !== 'map_dialog') {
                    invoke_map_dialog('rivals');
                } else if(w.parent.parent.user_data['dialog']['chapter'] !== 'rivals') {
                    map_dialog_change_page(w.parent.parent, 'rivals', 0);
                }
            }
            i += 1;
        }
    }

    // REGIONAL MAP button
    if(player.tutorial_state === "COMPLETE" &&
       player.get_any_abtest_value('enable_region_map', gamedata['enable_region_map']) &&
       !(session.region && session.region.data && ('enable_map' in session.region.data) && !session.region.data['enable_map'])) {

        var quarry_pred = read_predicate(player.get_any_abtest_value('quarry_play_requirement', gamedata['territory']['quarry_play_requirement']));
        var can_view_quarries = quarry_pred.is_satisfied(player, null);

        dialog.user_data['buttons'].push('quarries');
        dialog.widgets['button'+i.toString()].show = true;
        dialog.widgets['button'+i.toString()].str = dialog.data['widgets']['button']['ui_name_quarries'];
        dialog.widgets['warning_text'+i.toString()].show = false;

         dialog.widgets['button'+i.toString()].state = (dialog.parent.user_data['dialog'] === 'region_map_dialog' ? 'active' : (can_view_quarries ? 'normal' : 'disabled_clickable'));
        if(dialog.parent.user_data['dialog'] === 'region_map_dialog') {
            dialog.widgets['button'+i.toString()].onclick = null;
            dialog.widgets['button'+i.toString()].tooltip.str = null;
        } else if(can_view_quarries) {
            dialog.widgets['button'+i.toString()].onclick = function() { invoke_region_map(); };
            dialog.widgets['button'+i.toString()].tooltip.str = null;
        } else {
            dialog.widgets['button'+i.toString()].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['button'+i.toString()].tooltip.str = gamedata['spells']['SHOW_REGIONAL_MAP']['ui_tooltip_unmet'].replace('%s', quarry_pred.ui_describe(player));
            dialog.widgets['button'+i.toString()].onclick = get_requirements_help(quarry_pred);
        }
        i += 1;
    }

    // SINGLE PLAYER
    dialog.user_data['buttons'].push('computers');
    dialog.widgets['button'+i.toString()].show = true;
    dialog.widgets['warning_text'+i.toString()].show = false;
    dialog.widgets['button'+i.toString()].str = dialog.data['widgets']['button']['ui_name_computers'];
    dialog.widgets['button'+i.toString()].tooltip.str = null;
    dialog.widgets['button'+i.toString()].onclick = function(w) {
        if(w.parent && w.parent.parent && w.parent.parent.user_data['dialog'] === 'map_dialog') {
            if(w.parent.parent.user_data['chapter'] !== 'computers') { map_dialog_change_page(w.parent.parent, 'computers', 0); }
        } else {
            invoke_map_dialog('computers');
        }
    };
    dialog.widgets['button'+i.toString()].state = ((dialog.parent.user_data['dialog'] === 'map_dialog' && dialog.parent.user_data['chapter'] === 'computers') ? 'active' : 'normal');
    i += 1;

    // HITLIST button
    if(player.tutorial_state === "COMPLETE" &&
       ('hitlist_show_if' in gamedata['predicate_library']) &&
       read_predicate({'predicate':'LIBRARY', 'name':'hitlist_show_if'}).is_satisfied(player, null)) {
        dialog.user_data['buttons'].push('hitlist');
        dialog.widgets['button'+i.toString()].show = true;
        dialog.widgets['button'+i.toString()].str = dialog.data['widgets']['button']['ui_name_hitlist'];
        dialog.widgets['warning_text'+i.toString()].show = true;
        dialog.widgets['warning_text'+i.toString()].str = dialog.data['widgets']['warning_text']['ui_name_limited_time'];

        var hitlist_pred = ('hitlist_requirement' in gamedata['predicate_library'] ? read_predicate({'predicate':'LIBRARY', 'name':'hitlist_requirement'}) : null);
        if(hitlist_pred && !hitlist_pred.is_satisfied(player,null)) {
            dialog.widgets['button'+i.toString()].state = 'disabled_clickable';
            dialog.widgets['button'+i.toString()].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['button'+i.toString()].tooltip.str = dialog.data['widgets']['button']['ui_tooltip_unmet'].replace('%s', hitlist_pred.ui_describe(player));
            dialog.widgets['button'+i.toString()].onclick = get_requirements_help(hitlist_pred);
        } else {
            dialog.widgets['button'+i.toString()].state = ((dialog.parent.user_data['dialog'] === 'map_dialog' && dialog.parent.user_data['chapter'] === 'hitlist') ? 'active' : 'normal');
            dialog.widgets['button'+i.toString()].tooltip.text_color = SPUI.default_text_color;
            dialog.widgets['button'+i.toString()].tooltip.str = dialog.data['widgets']['button']['ui_tooltip_hitlist'];
            dialog.widgets['button'+i.toString()].onclick = function(w) {
                if(w.parent && w.parent.parent && w.parent.parent.user_data['dialog'] === 'map_dialog') {
                    if(w.parent.parent.user_data['chapter'] !== 'hitlist') { map_dialog_change_page(w.parent.parent, 'hitlist', 0); }
                } else {
                    invoke_map_dialog('hitlist');
                }
            };
        }
        i += 1;
    }

    while(i < dialog.data['widgets']['button']['array'][0]) {
        dialog.widgets['button'+i.toString()].show = dialog.widgets['warning_text'+i.toString()].show = false;
        i += 1;
    }
}

var map_log_receiver = new goog.events.EventTarget();
function query_map_log(region_id, time_range, callback) {
    last_query_tag += 1;
    var tag = 'qml'+last_query_tag.toString();
    // need this adaptor to pull the .result property out of the event object
    map_log_receiver.listenOnce(tag, (function (_cb) { return function(event) { _cb(event.result); }; })(callback));
    send_to_server.func(["QUERY_MAP_LOG", region_id, time_range, tag]);
};

var player_alliance_membership_history_receiver = new goog.events.EventTarget();
function query_player_alliance_membership_history(user_id, callback) {
    last_query_tag += 1;
    var tag = 'qpamh'+last_query_tag.toString();
    // need this adaptor to pull the .result property out of the event object
    player_alliance_membership_history_receiver.listenOnce(tag, (function (_cb) { return function(event) { _cb(event.result); }; })(callback));
    send_to_server.func(["QUERY_PLAYER_ALLIANCE_MEMBERSHIP_HISTORY", tag, user_id]);
};

function invoke_map_ladder_pvp() {
    var template = 'map_ladder_pvp_dialog';
    var transition = false;
    if((template+'_'+gamedata['game_id']) in gamedata['dialogs']) {
        template = template+'_'+gamedata['game_id'];
        transition = true;
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs'][template]);
    dialog.user_data['dialog'] = 'map_ladder_pvp_dialog';
    dialog.user_data['transition'] = transition;
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };

    dialog.widgets['text1a'].str = dialog.data['widgets']['text1a']['ui_name'].replace('%GAME', gamedata['strings']['game_name']);
    map_dialog_default_page = 'rivals';
    dialog.ondraw = update_map_ladder_pvp_dialog;
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_map_ladder_pvp_dialog(dialog) {
    update_map_dialog_header_buttons(dialog.widgets['header_buttons']);
    if(dialog.user_data['transition']) {
        // TEMPORARY TR ladder->map transition version
        var btn = [];
        add_change_region_button(btn); // reuse the code from the building context menu
        dialog.widgets['relocate_button'].onclick = btn[0].onclick;
        dialog.widgets['relocate_button'].state = btn[0].state || 'normal';
        dialog.widgets['relocate_button'].tooltip.str = btn[0].ui_tooltip;
    }

    // update fight button based on how many resources the user now has and their army size
    var has_cost = (gamedata['matchmaking']['ladder_match_life'] < 0);
    // show price when rival querying is mandatory (SG)

    var missing_res = null, missing_res_amount = 0;
    if(has_cost) {
        dialog.widgets['fight_button'].xy = dialog.data['widgets']['fight_button']['xy_priced'];

        var cost = eval_cond_or_literal(gamedata['matchmaking']['ladder_match_switch_cost'], player, null);
        for(var res in cost) {
            // note: can't display multiple resources
            dialog.widgets['ladder_switch_price_icon'].asset = gamedata['resources'][res]['icon_small'];
            dialog.widgets['ladder_switch_price'].str = pretty_print_number(cost[res]);
        }
        for(var res in cost) {
            if(player.resource_state[res][1] < cost[res]) {
                missing_res = res;
                missing_res_amount = cost[res] - player.resource_state[res][1];
                break;
            }
        }
    }

    if(has_cost && goog.object.getCount(player.my_army) < 1) {
        dialog.widgets['fight_button'].state = 'disabled_clickable';
        dialog.widgets['fight_button'].onclick = function() {
            var s = gamedata['strings']['ladder_switch_no_army'];
            invoke_message_dialog(s['ui_title'], s['ui_description'], {'dialog':'message_dialog_big'});
        };
    } else if(!missing_res) {
        dialog.widgets['fight_button'].state = 'normal';
        dialog.widgets['fight_button'].onclick = function() { do_visit_base(-1, {ladder_battle:1}); };
    } else {
        dialog.widgets['fight_button'].state = 'disabled_clickable';
        dialog.widgets['fight_button'].onclick = get_requirements_help(missing_res, missing_res_amount);
    }

    if('ladder_switch_price' in dialog.widgets) {
        dialog.widgets['ladder_switch_price_icon'].show =
            dialog.widgets['ladder_switch_price'].show = has_cost;
        dialog.widgets['ladder_switch_price'].onclick = dialog.widgets['fight_button'].onclick;
    }
}


function invoke_change_alias_dialog(callback, spellname) {
    var spell = gamedata['spells'][spellname];
    var dialog = new SPUI.Dialog(gamedata['dialogs']['change_alias_dialog']);
    dialog.user_data['dialog'] = 'change_alias_dialog';
    dialog.user_data['spellname'] = spellname;
    dialog.user_data['callback'] = callback;
    dialog.user_data['pending'] = false;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick =
        dialog.widgets['cancel_button'].onclick = close_parent_dialog;
    dialog.widgets['title'].str = spell['ui_name'];
    dialog.widgets['input'].str = player.alias || '';
    dialog.widgets['input'].disallowed_chars = ['\\', '/', ' ', '.', ':', ';', '+', '*', '(', ')', '<', '>', '[', ']', '{', '}', ',', '|', '"', "'", '_', '&', '^', '%', '$', '#', '@', '!', '~', '?', '`']; // keep in sync: ChatFilter.py, main.js: alias_disallowed_chars, errors.json: ALIAS_BAD
    // note: we should have prevented - and = here (--==xxDeathManxx==--), but it's too late for existing games

    var descr1 = spell['ui_description'];
    var descr2 = gamedata['errors']['ALIAS_BAD']['ui_name'];
    while(descr2.indexOf('\n\n') >= 0) { // replace double line breaks with single
        descr2 = descr2.replace('\n\n', '\n');
    }
    var descr = descr1 + '\n\n' + descr2;
    dialog.widgets['description'].set_text_with_linebreaking(descr);
    dialog.widgets['ok_button'].onclick = dialog.widgets['input'].ontextready = function(w) {
        var dialog = w.parent;
        var new_name = dialog.widgets['input'].str;
        var cb = dialog.user_data['callback'];
        var spell = gamedata['spells'][dialog.user_data['spellname']];

        if(!dialog.user_data['pending'] && new_name && new_name.length >= 3) {
            var do_it = (function (_new_name, _cb) { return function() {
                close_parent_dialog(w);
                _cb([SPHTTP.wrap_string(_new_name)]);
            }; })(new_name, cb);

            dialog.user_data['pending'] = true; // prevent successive Enter presses from re-entering here
            invoke_child_message_dialog(spell['ui_name']+'?', spell['ui_confirm'].replace('%s', new_name),
                                        {'cancel_button': true,
                                         'on_cancel': (function(_dialog) { return function() { dialog.user_data['pending'] = false; }; })(dialog),
                                         'on_ok': do_it});
        }
    };
    SPUI.set_keyboard_focus(dialog.widgets['input']);
    dialog.ondraw = update_change_alias_dialog;
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_change_alias_dialog(dialog) {
    var ok = true;
    var s = dialog.widgets['input'].str;
    if(s.length < 4 || s.length >= 24 || s == player.alias /* || ChatFilter.is_bad(s) */) {
        ok = false;
    }

    dialog.widgets['ok_button'].state = (ok ? 'normal' : 'disabled');
}

function invoke_change_title_dialog(callback, spellname) {
    var spell = gamedata['spells'][spellname];
    var dialog = new SPUI.Dialog(gamedata['dialogs']['change_title_dialog']);
    dialog.user_data['dialog'] = 'change_title_dialog';
    dialog.user_data['spellname'] = spellname;
    dialog.user_data['callback'] = callback;
    dialog.user_data['new_title'] = player.title || gamedata['default_title'];
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['choice']['array'][1];
    dialog.user_data['cols_per_page'] = dialog.data['widgets']['choice']['array'][0];
    dialog.user_data['rowfunc'] = change_title_rowfunc;
    dialog.user_data['rowdata'] = []; // title names
    dialog.user_data['scroll_by_row'] = true;
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;
    goog.object.forEach(gamedata['titles'], function(data, name) {
        if(!('show_if' in data) || read_predicate(data['show_if']).is_satisfied(player, null)) {
            dialog.user_data['rowdata'].push(name);
        }
    });
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick =
        dialog.widgets['cancel_button'].onclick = close_parent_dialog;
    dialog.widgets['title'].str = spell['ui_name'];
    var descr = spell['ui_description'];
    dialog.widgets['description'].set_text_with_linebreaking(descr);
    dialog.widgets['ok_button'].onclick = function(w) {
        var dialog = w.parent;
        var new_title = dialog.user_data['new_title'];
        var cb = dialog.user_data['callback'];
        close_parent_dialog(w);
        if(new_title && new_title != player.title) {
            cb([new_title]);
        }
    };
    scrollable_dialog_change_page(dialog, dialog.user_data['page']);
    return dialog;
}
function change_title_rowfunc(dialog, row_col, rowdata) {
    var wname = SPUI.get_array_widget_name('choice', dialog.data['widgets']['choice']['array'], row_col);
    dialog.widgets[wname].show = !!rowdata;
    if(rowdata) {
        var name = rowdata;
        var data = gamedata['titles'][rowdata];
        dialog.widgets[wname].str = data['ui_name'];
        var pred = read_predicate(data['requires'] || {'predicate':'ALWAYS_TRUE'});
        if(pred.is_satisfied(player, null)) {
            dialog.widgets[wname].state = (dialog.user_data['new_title'] == name ? 'active' : 'normal');
            dialog.widgets[wname].text_color = SPUI.default_text_color;
            dialog.widgets[wname].tooltip.str = null;
            dialog.widgets[wname].onclick = (function (_name) { return function(w) {
                var dialog = w.parent;
                dialog.user_data['new_title'] = _name;
                scrollable_dialog_change_page(dialog, dialog.user_data['page']);
            }; })(name);
        } else {
            dialog.widgets[wname].state = 'disabled_clickable';
            dialog.widgets[wname].text_color = SPUI.disabled_text_color;
            dialog.widgets[wname].tooltip.str = dialog.data['widgets']['choice']['ui_tooltip_requires'].replace('%s', pred.ui_describe(player));
            dialog.widgets[wname].onclick = get_requirements_help(pred, null);
        }
    }
}

function invoke_change_region_offer_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['change_region_offer_dialog']);
    dialog.user_data['dialog'] = 'change_region_offer_dialog';

    dialog.modal = true;
    install_child_dialog(dialog);
    dialog.auto_center();

    var time_left = player.cooldown_togo(gamedata['spells']['CHANGE_REGION']['cooldown_name']);
    var last_relocate = server_time - player.cooldowns[gamedata['spells']['CHANGE_REGION']['cooldown_name']]['start'];
    dialog.widgets['description'].set_text_with_linebreaking(dialog.data['widgets']['description']['ui_name'].replace('%last',pretty_print_time(last_relocate)).replace('%s', pretty_print_time(time_left)).replace('%currency', Store.gamebucks_ui_name()));

    var price = Store.get_user_currency_price(GameObject.VIRTUAL_ID, gamedata['spells']['CHANGE_REGION_INSTANTLY'], null);

    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
    dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    dialog.widgets['ok_button'].onclick =
        dialog.widgets['price_display'].onclick = function(w) {
            change_selection_ui(null);
            var order_cb = function(override_spellarg) {
                if(Store.place_order(Store.get_user_currency(), GameObject.VIRTUAL_ID, 'CHANGE_REGION_INSTANTLY', override_spellarg, null)) {
                    player.cooldown_client_trigger(gamedata['spells']['CHANGE_REGION']['cooldown_name'], gamedata['spells']['CHANGE_REGION']['cooldown']);
                    return true;
                }
                return false;
            };
            invoke_change_region_dialog(order_cb, 'CHANGE_REGION_INSTANTLY');
        };

    return dialog;
}

// if "callback" is null, this tries to use the free relocation.
// otherwise, callback should be a function that accepts the spellargs for a paid or item-based CHANGE_REGION
// and returns 'true' if the order has been placed

function change_region_for_free(spellarg) {
    change_region(spellarg[0], spellarg[1]);
    return true;
}

function invoke_change_region_dialog(callback, spellname) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['change_region_dialog']);
    dialog.user_data['dialog'] = 'change_region_dialog';
    dialog.user_data['spellname'] = spellname;

    // note: if the free region change is not on cooldown, and we're doing a plain (non-anywhere) change, then ignore the provided callback and use the free path instead
    if(!callback || ((spellname == 'CHANGE_REGION_INSTANTLY') && !player.cooldown_active(gamedata['spells']['CHANGE_REGION']['cooldown_name']))) {
        dialog.user_data['callback'] = change_region_for_free;
    } else {
        dialog.user_data['callback'] = callback;
    }

    dialog.user_data['alliancemates_by_region'] = {};
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['region_name']['array'][1];
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.user_data['region_button_states'] = {};
    dialog.user_data['region_button_strs'] = {};
    dialog.user_data['region_button_tooltips'] = {};

    dialog.ondraw = update_change_region_dialog;
    dialog.user_data['rowdata'] = []; // wait until query completes
    dialog.user_data['populations'] = null;
    query_region_pop((function (_dialog) { return function(pops) { change_region_dialog_pop_results(_dialog, pops); } })(dialog));
    dialog.widgets['loading_spinner'].show = true;
    dialog.user_data['rowfunc'] = change_region_dialog_setup_row;
    scrollable_dialog_change_page(dialog, 0);
    return dialog;
}

function change_region_dialog_pop_results(dialog, populations) {
    if(!dialog.is_visible()) { return; }
    dialog.widgets['loading_spinner'].show = false;
    dialog.user_data['populations'] = populations;
    dialog.user_data['rowdata'] = [];
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;
    var ignore_pred = (dialog.user_data['spellname'] == 'CHANGE_REGION_INSTANTLY_ANYWHERE');

    for(var id in gamedata['regions']) {
        if(!player.is_developer() && gamedata['regions'][id]['developer_only']) { continue; }
        if(('show_if' in gamedata['regions'][id]) && !read_predicate(gamedata['regions'][id]['show_if']).is_satisfied(player, null)) { continue; }
        dialog.user_data['rowdata'].push(id);
    }

    dialog.user_data['rowdata'].sort(function (a,b) {
        // sort by ui_priority, then predicate, then fullness (low to high), then name
        var ra = gamedata['regions'][a], rb = gamedata['regions'][b];
        var pa = eval_cond_or_literal(ra['ui_priority'] || 0, player, null), pb = eval_cond_or_literal(rb['ui_priority'] || 0, player, null);
        var pred_oka = ignore_pred || (!('requires' in ra) || read_predicate(ra['requires']).is_satisfied(player, null));
        var pred_okb = ignore_pred || (!('requires' in rb) || read_predicate(rb['requires']).is_satisfied(player, null));
        var popa = (ra['open_join'] && pred_oka && populations[a] ? populations[a] : {'state':'full','rank':99999});
        var popb = (rb['open_join'] && pred_okb && populations[b] ? populations[b] : {'state':'full','rank':99999});
        if(pa > pb) {
            return -1;
        } else if(pa < pb) {
            return 1;
        } else if(popa['state'] != 'full' && popb['state'] == 'full') {
            return -1;
        } else if(popa['state'] == 'full' && popb['state'] != 'full') {
            return 1;
        } else if(popa['rank'] > popb['rank']) {
            return -1;
        } else if(popa['rank'] < popb['rank']) {
            return 1;
        } else if(ra['ui_name'] < rb['ui_name']) {
            return -1;
        } else if(ra['ui_name'] > rb['ui_name']) {
            return 1;
        } else {
            return 0;
        }
    });

    scrollable_dialog_change_page(dialog, dialog.user_data['page']); // update the dialog

    // kick off query for alliancemates
    if(session.is_in_alliance()) {
        dialog.widgets['loading_spinner'].show = true;
        AllianceCache.query_members(session.alliance_id, false, null, (function (_dialog) { return function(info) {
            dialog.widgets['loading_spinner'].show = false;
            if(!info || !info['members']) { return; }
            goog.array.forEach(info['members'], function(member_info) {
                var member_id = member_info['user_id'];
                if(member_id == session.user_id) { return; }
                var player_info = PlayerCache.query_sync(member_id);
                if(player_info && player_info['home_region'] && player_info['home_base_loc']) {
                    var reg = player_info['home_region'];
                    if(!(reg in dialog.user_data['alliancemates_by_region'])) { dialog.user_data['alliancemates_by_region'][reg] = []; }
                    dialog.user_data['alliancemates_by_region'][reg].push(member_id);
                }
            });
            scrollable_dialog_change_page(dialog, dialog.user_data['page']); // update the dialog
        }; })(dialog));
    }
}

/** @param {SPUI.Dialog} dialog */
function update_change_region_dialog(dialog) {
    for(var row = 0; row < dialog.data['widgets']['region_button']['array'][1]; row++) {
        var w = dialog.widgets['region_button'+row];
        if(w.show && (row in dialog.user_data['region_button_states'])) {
            if(change_region_pending) {
                w.state = 'disabled';
                w.str = dialog.data['widgets']['region_button']['ui_name_processing'];
                w.tooltip.str = null;
            } else {
                w.state = dialog.user_data['region_button_states'][row];
                w.str = dialog.user_data['region_button_strs'][row];
                w.tooltip.str = dialog.user_data['region_button_tooltips'][row] || null;
            }
        }
    }
}

function change_region_dialog_setup_row(dialog, row, rowdata) {
    var present = (rowdata !== null && dialog.user_data['populations'] !== null);

    dialog.widgets['separator'+(row+1)].show =
        dialog.widgets['region_name'+row].show =
        dialog.widgets['region_status'+row].show =
        dialog.widgets['region_alliancemates'+row].show =
        dialog.widgets['region_info'+row].show =
        dialog.widgets['region_button'+row].show = present;

    if(present) {
        var ignore_pred = (dialog.user_data['spellname'] == 'CHANGE_REGION_INSTANTLY_ANYWHERE');
        var data = gamedata['regions'][rowdata];
        var already_here = (session.region.data === data);
        var open = data['open_join'] && (rowdata in dialog.user_data['populations']) && (dialog.user_data['populations'][rowdata]['state'] != 'full');

        var pred = ('requires' in data ? read_predicate(data['requires']) : null);
        var pred_ok = ignore_pred || (pred ? pred.is_satisfied(player, null) : true);

        dialog.widgets['region_name'+row].str = data['ui_name'].toUpperCase();
        dialog.widgets['region_name'+row].text_color = (!pred_ok ? SPUI.warning_text_color : (('text_color' in data) ? SPUI.make_colorv(eval_cond_or_literal(data['text_color'], player, null)) : SPUI.default_text_color));

        dialog.widgets['region_status'+row].str = dialog.data['widgets']['region_status']['ui_name_'+(already_here ? 'here' : (!open ? 'full' : (!pred_ok ? 'locked' : 'open')))];
        dialog.widgets['region_status'+row].text_color = (already_here ? dialog.widgets['region_name'+row].text_color : ((open && pred_ok) ? (('text_color' in data) ? SPUI.make_colorv(eval_cond_or_literal(data['text_color'], player, null)) : SPUI.good_text_color) : SPUI.error_text_color));
        dialog.widgets['region_info'+row].str = eval_cond_or_literal(data['ui_description_short'], player, null);
        dialog.widgets['region_info'+row].text_color = SPUI.make_colorv(('info_color' in data) ? eval_cond_or_literal(data['info_color'], player, null) : dialog.data['widgets']['region_info']['text_color']);
        dialog.widgets['region_info'+row].tooltip.str = SPText.bbcode_strip(eval_cond_or_literal(data['ui_description_long'], player, null));


        // remember state/str since update_change_region_dialog may want to override it
        // allow relocation within region (session.region.data === data);
        dialog.user_data['region_button_states'][row] = (already_here ? 'normal' : (!open ? 'disabled' : (!pred_ok ? 'disabled_clickable' : 'normal')));
        dialog.user_data['region_button_strs'][row] = dialog.data['widgets']['region_button']['ui_name'+((open&&!pred_ok&&!already_here) ? '_locked' : (already_here?'_here':''))];
        dialog.user_data['region_button_tooltips'][row] = (open&&!pred_ok&&!already_here ? dialog.data['widgets']['region_button']['ui_tooltip_unmet'].replace('%s',pred.ui_describe(player)) : null);

        var mate_count = 0;
        if(data['id'] in dialog.user_data['alliancemates_by_region']) {
            mate_count = dialog.user_data['alliancemates_by_region'][data['id']].length;
        }
        dialog.widgets['region_alliancemates'+row].show = (mate_count > 0);
        if(dialog.widgets['region_alliancemates'+row].show) {
            dialog.widgets['region_alliancemates'+row].str = dialog.data['widgets']['region_alliancemates']['ui_name'].replace('%d', mate_count.toString());
            dialog.widgets['region_alliancemates'+row].text_color = dialog.widgets['region_info'+row].text_color;
        }
        if(!pred_ok) {
            dialog.widgets['region_button'+row].onclick = get_requirements_help(pred);

        } else {
            dialog.widgets['region_button'+row].onclick = (function (_id) { return function(w) {
                var start_execute_cb = (function (__id, _w) { return function() {
                    var _dialog = _w.parent;

                    var callback = _dialog.user_data['callback'];
                    var finish_execute_cb = (function (___id, _callback) { return function(dest_coords) {
                        if(_callback([___id, dest_coords])) {
                            change_region_pending = (_callback === change_region_for_free ? 'free' : 'paid');
                            invoke_ui_locker(synchronizer.request_sync());
                        }
                    }; })(__id, callback);

                    if((_id in dialog.user_data['alliancemates_by_region']) && dialog.user_data['alliancemates_by_region'][_id].length >= 1) {
                        // player has alliancemates in region - ask which one to move near
                        invoke_change_region_mates_dialog(_id, dialog.user_data['alliancemates_by_region'][_id], finish_execute_cb);
                    } else {
                        // no alliancemates in region - execute now
                        finish_execute_cb(null);
                    }

                }; })(_id, w);

                var within_region = (session.region.data && session.region.data['id'] == _id);
                var old_is_ladder = (session.region.data && session.region.data['ladder_pvp']);
                var new_is_ladder = !!(gamedata['regions'][_id]['ladder_pvp']);
                var ladder_reset = (old_is_ladder && !new_is_ladder) && gamedata['matchmaking']['zero_points_on_ladder_exit'];

                var old_is_pvp = !(session.region.data && session.region.data['zero_points_on_entry']);
                var new_is_pvp = !(gamedata['regions'][_id]['zero_points_on_entry']);
                if(old_is_pvp && !new_is_pvp) { ladder_reset = true; }

                var msg = gamedata['strings']['change_region_confirm' + (within_region ? '_within_region' : (ladder_reset ? '_ladder_reset': '' ))];
                invoke_child_message_dialog(msg['ui_title'].replace('%s', gamedata['regions'][_id]['ui_name']),
                                            msg['ui_description'].replace('%s', gamedata['regions'][_id]['ui_name'])+'\n\n'+gamedata['strings']['regional_map']['change_region_feature_info'].replace('%NAME',gamedata['regions'][_id]['ui_name']).replace('%DESCR',eval_cond_or_literal(gamedata['regions'][_id]['ui_description_long'], player, null)),
                                            {'use_bbcode': true,
                                             'cancel_button': true,
                                             'ok_button_ui_name': msg['ui_button'],
                                             'dialog': 'message_dialog_big',
                                             'on_ok': start_execute_cb});
            }; })(rowdata);
        }
    }
}

function invoke_change_region_mates_dialog(region_id, id_list, callback) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['change_region_mates_dialog']);
    dialog.user_data['dialog'] = 'change_region_mates_dialog';
    dialog.user_data['callback'] = callback;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['portrait']['array'][1];
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    // build list of alliancemates in the region
    dialog.user_data['rowdata'] = [];
    goog.array.forEach(id_list, function(id) {
        var info = PlayerCache.query_sync(id);
        if(info && info['home_region'] == region_id && info['home_base_loc']) {
            dialog.user_data['rowdata'].push(id);
        }
    });

    if(dialog.user_data['rowdata'].length < 1) {
        // no friends - skip!
        callback(null);
        return;
    }

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    // sort alphabetically
    dialog.user_data['rowdata'].sort(function (a,b) {
        var na = PlayerCache.get_ui_name(PlayerCache.query_sync(a));
        var nb = PlayerCache.get_ui_name(PlayerCache.query_sync(b));
        if(na < nb) {
            return -1;
        } else if(na > nb) {
            return 1;
        } else {
            return 0;
        }
    });

    // prepend -1 for "random"
    dialog.user_data['rowdata'] = [-1].concat(dialog.user_data['rowdata']);

    dialog.user_data['rowfunc'] = change_region_mates_dialog_setup_row;
    scrollable_dialog_change_page(dialog, 0);
    return dialog;
}

function change_region_mates_dialog_setup_row(dialog, row, rowdata) {
    dialog.widgets['separator'+(row+1)].show =
        dialog.widgets['portrait'+row].show =
        dialog.widgets['portrait_random'+row].show =
        dialog.widgets['name'+row].show =
        dialog.widgets['button'+row].show = (rowdata !== null);

    if(rowdata !== null) {
        var id = rowdata;
        var coords;
        if(id < 0) {
            // random location
            coords = null;
            dialog.widgets['portrait'+row].show = false;
            dialog.widgets['portrait_random'+row].show = true;
            dialog.widgets['name'+row].str = dialog.data['widgets']['name']['ui_name_random'];
        } else {
            dialog.widgets['portrait'+row].show = true;
            dialog.widgets['portrait_random'+row].show = false;

            var info = PlayerCache.query_sync(id);
            coords = info['home_base_loc']; // guaranteed to exist by invoke_change_region_mates_dialog()
            dialog.widgets['portrait'+row].set_user(id);

            dialog.widgets['name'+row].str = dialog.data['widgets']['name']['ui_name_mate'].replace('%s', PlayerCache.get_ui_name(info) + ' (L'+(info['player_level']||1).toString()+')');
        }

        dialog.widgets['button'+row].onclick = (function (_id) { return function(w) {
            var _cb = w.parent.user_data['callback'];
            close_parent_dialog(w);
            _cb(_id < 0 ? null : PlayerCache.query_sync(_id)['home_base_loc']);
        }; })(id);
    }
}

function invoke_map_bookmarks_dialog(mapwidget) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['map_bookmarks_dialog']);
    dialog.user_data['dialog'] = 'map_bookmarks_dialog';
    dialog.user_data['mapwidget'] = mapwidget;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['name']['array'][1];
    dialog.user_data['rowdata'] = [];
    dialog.user_data['scroll_by_row'] = true;
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;
    dialog.user_data['rowfunc'] = map_bookmarks_dialog_setup_row;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    refresh_map_bookmarks_dialog(dialog);
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function refresh_map_bookmarks_dialog(dialog) {
    var mapwidget = dialog.user_data['mapwidget'];
    var region = mapwidget.region.data['id'];
    if(!(region in player.map_bookmarks)) {
        player.map_bookmarks[region] = [];
    }
    dialog.user_data['rowdata'] = player.map_bookmarks[region];
    scrollable_dialog_change_page(dialog, (dialog.user_data['page'] >= 0 ? dialog.user_data['page'] : 0));
    return dialog;
}
function map_bookmarks_dialog_setup_row(dialog, row, rowdata) {
    dialog.widgets['separator'+(row+1)].show =
        dialog.widgets['icon'+row].show =
        dialog.widgets['name'+row].show =
        dialog.widgets['coords'+row].show =
        dialog.widgets['time'+row].show =
        dialog.widgets['delete_button'+row].show =
        dialog.widgets['rename_button'+row].show =
        dialog.widgets['go_button'+row].show = (rowdata !== null);

    if(rowdata !== null) {
        var ui_name_prefix = '';
        var show_prefix = !!player.preferences['map_bookmark_show_prefix'];
        var show_time = ('time' in rowdata && !!player.preferences['map_bookmark_show_time']);
        if(show_prefix) {
            ui_name_prefix = (dialog.user_data['page'] + row + 1).toString() + ': '
        }
        dialog.widgets['name'+row].str = ui_name_prefix + rowdata['ui_name'];
        dialog.widgets['coords'+row].str = dialog.data['widgets']['coords']['ui_name'].replace('%x', rowdata['coords'][0].toString()).replace('%y', rowdata['coords'][1].toString());
        dialog.widgets['time'+row].show = (show_time);
        if(show_time) {
            dialog.widgets['time'+row].str = dialog.data['widgets']['time']['ui_name'].replace('%s', pretty_print_time_brief(server_time - rowdata['time']));
        }

        dialog.widgets['delete_button'+row].onclick = (function (_rowdata) { return function(w) {
            var _dialog = w.parent;
            var msg = gamedata['strings']['map_bookmark_delete_confirm'];
            invoke_child_message_dialog(msg['ui_title'],
                                        msg['ui_description'].replace('%s', _rowdata['ui_name']),
                                        {'cancel_button': true,
                                         'ok_button_ui_name': msg['ui_button'],
                                         'dialog': 'message_dialog',
                                         'on_ok': (function (__dialog, __rowdata) { return function() {
                                             player.map_bookmark_delete(__dialog.user_data['mapwidget'].region.data['id'], __rowdata['coords']);
                                             refresh_map_bookmarks_dialog(__dialog);
                                         }; })(_dialog, _rowdata)});
        }; })(rowdata);
        dialog.widgets['rename_button'+row].onclick = (function (_rowdata) { return function(w) {
            invoke_map_bookmark_rename_dialog(w.parent, _rowdata);
        }; })(rowdata);

        dialog.widgets['go_button'+row].onclick = (function (_rowdata) { return function(w) {
            var coords = _rowdata['coords'];
            var mapwidget = w.parent.user_data['mapwidget'];
            close_parent_dialog(w);
            mapwidget.pan_to_cell(coords, {slowly:true, with_zoom:true});
        }; })(rowdata);
    }
}
function invoke_map_bookmark_rename_dialog(bookmarks_dialog, bookmark) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['map_bookmark_rename_dialog']);
    dialog.user_data['dialog'] = 'map_bookmark_rename_dialog';
    dialog.user_data['bookmarks_dialog'] = bookmarks_dialog;
    dialog.user_data['bookmark'] = bookmark;
    dialog.widgets['close_button'].onclick =  dialog.widgets['cancel_button'].onclick = close_parent_dialog;
    dialog.widgets['rename_button'].onclick = dialog.widgets['input'].ontextready = function(w) {
        var _dialog = w.parent;
        var bookmark = _dialog.user_data['bookmark'];
        var new_name = _dialog.widgets['input'].str;
        if(new_name) {
            if(new_name != bookmark['ui_name']) {
                player.map_bookmark_rename(bookmark['region'], new_name, bookmark['coords']);
                refresh_map_bookmarks_dialog(_dialog.user_data['bookmarks_dialog']);
            }
            close_parent_dialog(w);
        }
    };
    dialog.widgets['input'].str = bookmark['ui_name'];
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    SPUI.set_keyboard_focus(dialog.widgets['input']);

    return dialog;
}

function scrollable_dialog_change_page(dialog, page) {
    var scroll_by_row = dialog.user_data['scroll_by_row'] || false;
    var rowdata_incomplete = dialog.user_data['rowdata_incomplete'] || false;
    var rows_per_page = dialog.user_data['rows_per_page'];
    var cols_per_page = dialog.user_data['cols_per_page'] || 1;
    var rowfunc = dialog.user_data['rowfunc'];
    var roworder = dialog.user_data['roworder'] || 'top_bottom_left_right';
    var chapter_items = dialog.user_data['rowdata'].length;
    var items_per_page = rows_per_page * cols_per_page;
    var chapter_pages = Math.max(1,Math.floor((chapter_items+items_per_page-1)/items_per_page));
    if(scroll_by_row) {
        chapter_pages = Math.max(1,Math.floor(chapter_items - items_per_page + 1));
    }
    dialog.user_data['page'] = page = (chapter_items == 0 ? 0 : clamp(page, 0, chapter_pages-1));

    var item_num = 0, row = 0, col = 0;
    if(chapter_items > 0) {
        var first_on_page = page * items_per_page;
        var last_on_page = (page+1)*items_per_page - 1;
        if(scroll_by_row) {
            first_on_page = page;
            last_on_page = page + items_per_page - 1;
            last_on_page = Math.max(0, Math.min(last_on_page, chapter_items-1));
        }
        last_on_page = Math.max(0, Math.min(last_on_page, chapter_items-1));
        if('scroll_text' in dialog.widgets) {
            dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_on_page+1).toString()).replace('%d2',(last_on_page+1).toString()).replace('%d3',chapter_items.toString());
            if(rowdata_incomplete) {
                dialog.widgets['scroll_text'].str = dialog.widgets['scroll_text'].str + '+';
            }
        }
        for(var i = first_on_page; i <= last_on_page; i++) {
            var coord = (cols_per_page == 1 ? row : [col,row]);
            rowfunc(dialog, coord, dialog.user_data['rowdata'][i]);
            item_num += 1;
            if(roworder == 'left_right_top_bottom') {
               col += 1;
                if(col >= cols_per_page) {
                    col = 0;
                    row += 1;
                }
            } else {
                row += 1;
                if(row >= rows_per_page) {
                    row = 0;
                    col += 1;
                }
            }
        }
    } else {
        if('scroll_text' in dialog.widgets) {
            dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(0).toString()).replace('%d2',(0).toString()).replace('%d3',(0).toString());
        }
    }

    while(item_num < items_per_page) { // hide remaining rows
        var coord = (cols_per_page == 1 ? row : [col,row]);
        rowfunc(dialog, coord, null);
        item_num += 1;
        if(roworder == 'left_right_top_bottom') {
            col += 1;
            if(col >= cols_per_page) {
                col = 0;
                row += 1;
            }
        } else {
            row += 1;
            if(row >= rows_per_page) {
                row = 0;
                col += 1;
            }
        }
    }

    // set clickability of scroll arrows
    // checks dialog info for which arrows to use
    // gives preference to left/right arrows if there are both up/down and left/right,
    // but uses up/down arrows if there are no left/right
    var scroll_back = 'scroll_left';
    var scroll_forward = 'scroll_right';
    if(('scroll_up' in dialog.data['widgets']) && !('scroll_left' in dialog.data['widgets'])) {
        scroll_back = 'scroll_up';
    }
    if(('scroll_down' in dialog.data['widgets']) && !('scroll_right' in dialog.data['widgets'])) {
        scroll_forward = 'scroll_down';
    }
    dialog.widgets[scroll_back].state = (page != 0 ? 'normal' : 'disabled');
    dialog.widgets[scroll_forward].state = (page < (chapter_pages-1) ? 'normal' : 'disabled');
    dialog.widgets[scroll_back].onclick =  (function (_dialog) { return function() { scrollable_dialog_change_page(_dialog, _dialog.user_data['page']-1); }; })(dialog);
    dialog.widgets[scroll_forward].onclick = (function (_dialog) { return function() { scrollable_dialog_change_page(_dialog, _dialog.user_data['page']+1); }; })(dialog);
}

/** scrolls any scrollable dialog by the amount and direction of delta
    @param {SPUI.Dialog|null} dialog
    @param {number} delta
*/
function scrollable_dialog_mousewheel(dialog, delta) {
    var scroll_by_row = dialog.user_data['scroll_by_row'] || false;
    var page = dialog.user_data['page'];
    var rows_per_page = dialog.user_data['rows_per_page'];
    var cols_per_page = dialog.user_data['cols_per_page'] || 1;
    var chapter_items = dialog.user_data['rowdata'].length;
    var items_per_page = rows_per_page * cols_per_page;
    var chapter_pages = Math.max(1,Math.floor((chapter_items+items_per_page-1)/items_per_page));
    if(scroll_by_row) {
        chapter_pages = Math.max(1,Math.floor(chapter_items - items_per_page + 1));
    }
    if(delta < 0 && page != 0) {
        scrollable_dialog_change_page(dialog, page - 1);
    } else if(delta > 0 && page < (chapter_pages - 1)) {
        scrollable_dialog_change_page(dialog, page + 1);
    } else {
        return;
    }
}

/** Find the 'row' coordinates, as passed to rowfunc, of the visible elements for this rowdata element.
    If not visible, returns null
    @param {!SPUI.Dialog} dialog
    @param {*} rowdata
    @return {null|number|!Array<number>} */
function scrollable_dialog_find_row(dialog, rowdata) {
    var index = dialog.user_data['rowdata'].indexOf(rowdata);
    if(index < 0) { return null; }
    var rows_per_page = dialog.user_data['rows_per_page'];
    var cols_per_page = dialog.user_data['cols_per_page'] || 1;
    var items_per_page = rows_per_page * cols_per_page;
    var page_num = Math.floor(index / items_per_page);
    if(page_num !== dialog.user_data['page']) { return null; }

    var roworder = dialog.user_data['roworder'] || 'top_bottom_left_right';
    var page_index = index - page_num * items_per_page;
    var row, col;
    if(roworder === 'left_right_top_bottom') {
        row = Math.floor(page_index / cols_per_page);
        col = page_index % cols_per_page;
    } else {
        col = Math.floor(page_index / rows_per_page);
        row = page_index % rows_per_page;
    }
    return (cols_per_page == 1 ? row : [col,row]);
}

function invoke_mail_dialog(do_animation) {
    if(!player.get_any_abtest_value('enable_inventory', gamedata['enable_inventory'])) { return null; }
    var dialog = new SPUI.Dialog(gamedata['dialogs']['mail_dialog']);
    dialog.user_data['dialog'] = 'mail_dialog';
    dialog.user_data['anim_start_time'] = (do_animation ? client_time : -1);
    dialog.user_data['selected_row'] = -1; // index of selected row in UI
    dialog.user_data['selected_msg_id'] = null; // ID of selected mail message
    dialog.user_data['visible_rows'] = dialog.data['widgets']['row']['array'][1]; // # visible rows in UI
    dialog.user_data['first_row'] = 0; // index of top row that appears in UI
    dialog.user_data['attach_page'] = 0; // scroll page for list of attachments
    dialog.user_data['context'] = null; // context-tooltop Dialog for attachment items

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['missions_button'].onclick = function() { invoke_missions_dialog(false); };
    dialog.widgets['messages_button'].onclick = null;
    dialog.widgets['scroll_left'].onclick = function(w) { var dialog = w.parent; mail_dialog_scroll(dialog, dialog.user_data['first_row']-dialog.user_data['visible_rows']); };
    dialog.widgets['scroll_right'].onclick = function(w) { var dialog = w.parent; mail_dialog_scroll(dialog, dialog.user_data['first_row']+dialog.user_data['visible_rows']); };

    dialog.ondraw = animate_valentina_dialog;
    dialog.ondraw = frame_update_mail_dialog;
    update_mail_dialog(dialog, true);

    return dialog;
}

/** player.mailbox has mutated - update the dialog accordingly
    @param {!SPUI.Dialog} dialog
    @param {boolean} is_first_open - true on initial open. Controls whether we immediately jump to next unread message.
*/
function update_mail_dialog(dialog, is_first_open) {
    player.prune_expired_mail();

    dialog.widgets['pending_missions_icon'].show =
        dialog.widgets['pending_missions_icon_glow'].show = (player.claimable_quests > 0);
    dialog.widgets['pending_messages_icon'].show =
        dialog.widgets['pending_messages_icon_glow'].show = player.has_unread_mail();

    var pre_select = -1; // index of mail to pre-select

    // if the currently-selected mail is still visible, maintain the selection
    if(dialog.user_data['selected_msg_id']) {
        var found = player.get_mail_by_msg_id(dialog.user_data['selected_msg_id']);
        player.mailbox_iter(function(mail, i) {
            if(mail === found) {
                pre_select = i;
                return true;
            }
        });
    }

    // if currently-selected mail disappeared, or there wasn't one before...
    if(pre_select < 0 && is_first_open) {
        // first look for uncollected important attachments (only on initial open)
        player.mailbox_iter(function(mail, i) {
            if(player.mail_message_has_money(mail)) {
                pre_select = i;
                return true;
            }
        });
    }

    if(pre_select < 0 && is_first_open) {
        // then look for first unread mail (only on initial open)
        player.mailbox_iter(function(mail, i) {
            if(!mail['read']) {
                pre_select = i;
                return true;
            }
        });
    }

    if(pre_select < 0 && !is_first_open) {
        // stay at same rough visual position as before
        pre_select = dialog.user_data['selected_row'];
    }

    var first_row = 0;
    if(pre_select >= 0) {
        // adjust scroll position up or down to make sure the pre-selected mail is visible
        if(pre_select < first_row) { first_row = pre_select; }
        else if(pre_select >= first_row + dialog.user_data['visible_rows']) { first_row = pre_select; }
    } else {
        // no pre-selection yet
        pre_select = first_row;
    }
    dialog.user_data['selected_row'] = pre_select; // mail_dialog_scroll() -> mail_dialog_select_message() will update selected_msg_id
    dialog.user_data['first_row'] = first_row;
    mail_dialog_scroll(dialog, dialog.user_data['first_row']);
}

function mail_dialog_scroll(dialog, first_row) {
    var count = player.mailbox_count();

    // constrain first_row to valid range
    first_row = Math.max(Math.min(first_row, count - 1), 0);
    // quantize first_row to pages
    first_row = Math.floor(first_row/dialog.user_data['visible_rows'])*dialog.user_data['visible_rows'];
    dialog.user_data['first_row'] = first_row;

    // fill in UI quest list at left-hand side of dialog
    var ui_row = 0;
    for(var i = first_row; i < count; i++) {
        var mail = player.mailbox_nth(i);
        var rowname = 'row'+ui_row.toString();
        dialog.widgets[rowname].show = true;
        var subj = mail['subject'];
        var max_len = dialog.data['widgets']['row']['max_len'];
        if(subj.length >= max_len) {
            subj = subj.slice(0,max_len) + '...';
        }
        dialog.widgets[rowname].str = subj;
        dialog.widgets[rowname].onclick = (function (rownum) { return function (w) {
            mail_dialog_select_mail(w.parent, rownum); }; })(i);
        dialog.widgets['row_icon'+ui_row.toString()].show = !mail['read'];
        dialog.widgets['row_attachment_icon'+ui_row.toString()].show = (('attachments' in mail) && (mail['attachments'].length > 0));
        ui_row += 1;
        if(ui_row >= dialog.user_data['visible_rows']) {
            break;
        }
    }
    // hide remaining rows
    while(ui_row < dialog.user_data['visible_rows']) {
        dialog.widgets['row'+ui_row.toString()].show =
            dialog.widgets['row_icon'+ui_row.toString()].show =
            dialog.widgets['row_attachment_icon'+ui_row.toString()].show = false;
        ui_row += 1;
    }

    // set scroll widget clickability
    dialog.widgets['scroll_left'].state = (first_row > 0 ? 'normal':'disabled');
    dialog.widgets['scroll_left'].text_color = (first_row > 0 ? SPUI.default_text_color : SPUI.disabled_text_color);
    dialog.widgets['scroll_right'].state = (count > first_row+dialog.user_data['visible_rows'] ? 'normal':'disabled');
    dialog.widgets['scroll_right'].text_color = (count > first_row+dialog.user_data['visible_rows'] ? SPUI.default_text_color : SPUI.disabled_text_color);

    dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1', count > 0 ? first_row+1 : 0).replace('%d2', Math.min(first_row+dialog.user_data['visible_rows'], count)).replace('%d3', count);

    // get rid of attachment context dialog, if any
    mail_dialog_invoke_context(dialog, -1, null);

    // select the pre-selection, or any row that's visible
    mail_dialog_select_mail(dialog, dialog.user_data['selected_row']);
}

/** @param {SPUI.Dialog} dialog */
function frame_update_mail_dialog(dialog) {
    if(dialog.user_data['selected_row'] < 0 || dialog.user_data['selected_row'] >= player.mailbox_count()) {
        return;
    }

    var mail = player.mailbox_nth(dialog.user_data['selected_row']);
    dialog.widgets['expiration'].show = (('expire_time' in mail) && mail['expire_time'] > 0);
    if(dialog.widgets['expiration'].show) {
        dialog.widgets['expiration'].str = dialog.data['widgets']['expiration']['ui_name'].replace('%s', pretty_print_time_brief(mail['expire_time']-server_time));
    }
}

/** @param {SPUI.Dialog} dialog
    @param {number} row */
function mail_dialog_select_mail(dialog, row) {
    dialog.user_data['selected_row'] = row;
    dialog.user_data['selected_row'] = Math.min(Math.max(dialog.user_data['selected_row'], dialog.user_data['first_row']), Math.min(dialog.user_data['first_row']+dialog.user_data['visible_rows']-1, player.mailbox_count()-1));


    //dialog.widgets['attach_take'].show =
        dialog.widgets['attach_rect'].show =
        dialog.widgets['attach_scroll_left'].show =
        dialog.widgets['attach_scroll_right'].show =
        dialog.widgets['attach_taken'].show =
        dialog.widgets['attach_label'].show =
        dialog.widgets['attach_label2'].show =
        dialog.widgets['attach_label3'].show = false;
    //dialog.widgets['attach_more'].show = false;
    for(var i = 0; i < dialog.data['widgets']['attach_icon']['array'][0]; i++) {
        dialog.widgets['attach_slot'+i.toString()].show =
            dialog.widgets['attach_icon'+i.toString()].show =
            dialog.widgets['attach_stack'+i.toString()].show =
            dialog.widgets['attach_timer'+i.toString()].show =
            dialog.widgets['attach_timer_icon'+i.toString()].show =
            dialog.widgets['attach_frame'+i.toString()].show = false;
    }

    dialog.widgets['from_subj_rect'].show =
        dialog.widgets['body_rect'].show =
        dialog.widgets['from_label'].show =
        dialog.widgets['from_name'].show =
        dialog.widgets['subj_label'].show =
        dialog.widgets['subj_name'].show =
        dialog.widgets['delete_button'].show =
        dialog.widgets['body'].show =
        dialog.widgets['body_scroll_left'].show =
        dialog.widgets['body_scroll_right'].show =
        dialog.widgets['expiration'].show = (dialog.user_data['selected_row'] >= 0);

    dialog.widgets['nomail'].show = !dialog.widgets['body'].show;
    if(dialog.user_data['selected_row'] < 0) { // no mail
        dialog.widgets['selected_row'].show = false;
        return;
    }

    var mail = player.mailbox_nth(dialog.user_data['selected_row']);
    dialog.user_data['selected_msg_id'] = mail['msg_id'];
    dialog.user_data['body_scroll_pos'] = 0;
    dialog.widgets['delete_button'].show = dialog.widgets['body'].show && player.mail_message_is_discardable(mail);

    if('expire_time' in mail && mail['expire_time'] > 0 && server_time >= mail['expire_time']) {
        update_mail_dialog(dialog, false);
        return;
    }

    // update highlight on left-hand display
    var highlight_color = new SPUI.Color(0.75,0.75,0.75,1);
    var white = new SPUI.Color(1,1,1,1);
    for(var i = 0; i < dialog.user_data['visible_rows']; i++) {
        var select_this = (i+dialog.user_data['first_row'] == dialog.user_data['selected_row']);
        var rowname = 'row'+i.toString();
        dialog.widgets[rowname].text_color = (select_this ? white : SPUI.disabled_text_color);
        dialog.widgets[rowname].text_style = (select_this ? 'bold' : 'normal');
        dialog.widgets[rowname].highlight_text_color = (select_this ? white : highlight_color);
        if(select_this) {
            var spacing = dialog.data['widgets']['row']['array_offset'][1];
            dialog.widgets['selected_row'].xy[1] = dialog.data['widgets']['row']['xy'][1]+i*spacing-2;
            dialog.widgets['selected_row'].show = true;
        }
    }

    // update info at right
    dialog.widgets['from_name'].str = mail['from_name'];
    dialog.widgets['subj_name'].str = mail['subject'];

    dialog.widgets['attach_rect'].show = ('attachments' in mail || 'attachments_ghost' in mail);
    dialog.widgets['expiration'].xy = dialog.data['widgets']['expiration'][(dialog.widgets['attach_rect'].show ? 'xy' : 'xy_no_attachments')];
    goog.array.forEach(['body','body_rect'], function(wname) {
        dialog.widgets[wname].wh = dialog.data['widgets'][wname][(dialog.widgets['attach_rect'].show ? 'dimensions' : 'dimensions_no_attachments')];
    });
    dialog.widgets['body'].clip_to = dialog.data['widgets']['body'][(dialog.widgets['attach_rect'].show ? 'clip_to' : 'clip_to_no_attachments')];

    dialog.widgets['body'].scroll_up_button = dialog.widgets['body_scroll_left'];
    dialog.widgets['body'].scroll_down_button = dialog.widgets['body_scroll_right'];
    dialog.widgets['body'].clear_text();
    dialog.widgets['body'].append_text_with_linebreaking_bbcode(mail['body'], {}, system_chat_bbcode_click_handlers);

    var scroller = function (incr) { return function(w) {
        var dialog = w.parent;
        if(incr < 0) {
            dialog.widgets['body'].scroll_up();
        } else if(incr > 0) {
            dialog.widgets['body'].scroll_down();
        }
        dialog.user_data['body_scroll_pos'] = dialog.widgets['body'].get_scroll_pos_from_head_to_bot();
    }; };
    dialog.widgets['body_scroll_left'].onclick = scroller(-1);
    dialog.widgets['body_scroll_right'].onclick = scroller(1);
    dialog.widgets['body'].scroll_to_top();

    dialog.widgets['delete_button'].onclick = (function (_msg_id) { return function(w) {
        var _mail = player.get_mail_by_msg_id(_msg_id);
        if(!_mail) { return; }

        var deleter = (function(__msg_id) { return function() {
            var __mail = player.get_mail_by_msg_id(__msg_id);
            if(!__mail) { return; }

            player.mailbox_remove(__mail);
            // note: we really should do full client-side
            // prediction of mailbox contents. But because MAIL_DELETE is the
            // only way the mailbox gets mutated (other than tweaks
            // to "read" flag or attachments on existing mails),
            // we can get away with just throwing away any MAIL_UPDATEs that
            // come in while we have another request in flight.
            player.mailbox_sync_marker = synchronizer.request_sync();
            send_to_server.func(["MAIL_DELETE", __mail['msg_id']]);
            update_mail_dialog(w.parent, false);
        }; })(_msg_id);

        // only ask for confirmation if it has attachments
        if('attachments' in _mail) {
            var s = gamedata['strings']['mail_confirm_delete'];
            invoke_child_message_dialog(s['ui_title'],
                                        s['ui_description'],
                                        {'cancel_button': true,
                                         'ok_button_ui_name': s['ui_button'],
                                         'on_ok': deleter});
        } else {
            deleter();
        }

    }; })(mail['msg_id']);

    if('attachments' in mail) {
        dialog.widgets['attach_label'].show =
            dialog.widgets['attach_label2'].show =
            dialog.widgets['attach_label3'].show =
            dialog.widgets['attach_scroll_left'].show =
            dialog.widgets['attach_scroll_right'].show = true;
        mail_dialog_attach_scroll(dialog, 0);
    } else if('attachments_ghost' in mail) {
        for(var i = 0; i < mail['attachments_ghost'].length; i++) {
            var ghost = mail['attachments_ghost'][i];
            if(ghost && ghost['collected_at']) {
                dialog.widgets['attach_taken'].show = true;
                dialog.widgets['attach_taken'].str = dialog.data['widgets']['attach_taken']['ui_name'].replace('%s', pretty_print_date_utc(ghost['collected_at']));
                break;
            }
        }
    }

    // mark the mail as read
    if(!mail['read']) {
        mail['read'] = 1;
        send_to_server.func(["MAIL_READ", mail['msg_id']]);
        dialog.widgets['pending_messages_icon'].show =
            dialog.widgets['pending_messages_icon_glow'].show = player.has_unread_mail();
        dialog.widgets['row_icon'+(dialog.user_data['selected_row']-dialog.user_data['first_row']).toString()].show = false;
    }
}

function mail_dialog_attach_scroll(dialog, page) {
    // clear out context menu
    mail_dialog_invoke_context(dialog, -1, null);
    var any_expiring = false;
    var count = player.mailbox_count();

    if(dialog.user_data['selected_row'] < 0 || dialog.user_data['selected_row'] >= count) { return; } // XXXXXX?
    dialog.user_data['attach_page'] = page;
    var mail = player.mailbox_nth(dialog.user_data['selected_row']);
    if(!('attachments' in mail) || mail['attachments'].length < 1) { return; } // XXXXXX?
    var row = 0;
    var rows_per_page = dialog.data['widgets']['attach_icon']['array'][0];
    var chapter_items = mail['attachments'].length;
    var chapter_pages = Math.floor((chapter_items+rows_per_page-1)/rows_per_page);
    dialog.user_data['attach_page'] = page = (chapter_pages === 0 ? 0 : clamp(page, 0, chapter_pages-1));
    if(chapter_pages > 0) {
        var first_on_page = page * rows_per_page;
        var last_on_page = Math.min(Math.max((page+1)*rows_per_page - 1, 0), chapter_items-1);
        dialog.widgets['attach_label3'].str = dialog.data['widgets']['attach_label3']['ui_name'].replace('%d1',(first_on_page+1).toString()).replace('%d2',(last_on_page+1).toString()).replace('%d3',chapter_items.toString());
        for(var i = first_on_page; i <= last_on_page; i++) {
            var at = mail['attachments'][i];
            var spec = ItemDisplay.get_inventory_item_spec(at['spec']);
            dialog.widgets['attach_slot'+row.toString()].show = true;
            dialog.widgets['attach_icon'+row.toString()].show = true;
            ItemDisplay.set_inventory_item_asset(dialog.widgets['attach_icon'+row.toString()], spec);
            dialog.widgets['attach_icon'+row.toString()].bg_image_offset = [0,0];

            ItemDisplay.set_inventory_item_stack(dialog.widgets['attach_stack'+row.toString()], spec, at);

            dialog.widgets['attach_timer_icon'+row.toString()].show =
                dialog.widgets['attach_timer'+row.toString()].show = ('expire_time' in at);
            if('expire_time' in at) {
                any_expiring = true;
                dialog.widgets['attach_timer'+row.toString()].str = do_pretty_print_time(at['expire_time']-server_time,1,false);
            }

            dialog.widgets['attach_frame'+row.toString()].show = true;
            dialog.widgets['attach_frame'+row.toString()].state = (('pending' in mail) && !synchronizer.is_in_sync(mail['pending']) ? 'cooldown' : 'normal');
            dialog.widgets['attach_frame'+row.toString()].bg_image_offset = [0,0];
            dialog.widgets['attach_frame'+row.toString()].onenter = (function (_msg_id, _row, _slot, _item) { return function (w) {
                var _mail = player.get_mail_by_msg_id(_msg_id);
                if(!_mail) { return; }
                w.state = (('pending' in _mail) && !synchronizer.is_in_sync(_mail['pending']) ? 'cooldown' : 'active');
                var stickout = [0,-1];
                w.bg_image_offset = stickout;
                w.parent.widgets['attach_icon'+_row.toString()].bg_image_offset = stickout;
                w.parent.widgets['attach_stack'+_row.toString()].text_offset = stickout;
                mail_dialog_invoke_context(w.parent, _slot, _item);
            }; })(mail['msg_id'], row, i, at);
            dialog.widgets['attach_frame'+row.toString()].onclick = (function (_msg_id, _row, _slot, _item) { return function (w) {
                var _mail = player.get_mail_by_msg_id(_msg_id);
                if(!_mail) { return; }
                if(!(('pending' in _mail) && !synchronizer.is_in_sync(_mail['pending']))) {
                    _mail['pending'] = synchronizer.request_sync();
                    for(var j = 0; j < w.parent.data['widgets']['attach_icon']['array'][0]; j++) {
                        if(w.parent.widgets['attach_frame'+j.toString()].show) {
                            w.parent.widgets['attach_frame'+j.toString()].state = 'cooldown';
                        }
                    }
                    w.state = 'cooldown';
                    send_to_server.func(["MAIL_TAKE_ATTACHMENTS", _mail['msg_id'], _slot, _item['spec'], _item['stack'] || 1, null]);
                }
            }; })(mail['msg_id'], row, i, at);
            dialog.widgets['attach_frame'+row.toString()].onleave_cb = (function (_msg_id, _row, _slot, _item) { return function (w) {
                var _mail = player.get_mail_by_msg_id(_msg_id);
                if(!_mail) { return; }

                var inv_dialog = w.parent;
                if(inv_dialog.user_data['context'] &&
                   inv_dialog.user_data['context'].user_data['slot'] === _slot &&
                   inv_dialog.user_data['context'].user_data['item'] === _item) {
                    mail_dialog_invoke_context(w.parent, -1, null);
                    w.state = (('pending' in _mail) && !synchronizer.is_in_sync(_mail['pending']) ? 'cooldown' : 'normal');
                    var stickout = [0,0];
                    w.bg_image_offset = stickout;
                    w.parent.widgets['attach_icon'+_row.toString()].bg_image_offset = stickout;
                    w.parent.widgets['attach_stack'+_row.toString()].text_offset = stickout;
                }
            }; })(mail['msg_id'], row, i, at);
            row += 1;
        }
    } else {
        // nothing to list
        dialog.widgets['attach_label3'].str = dialog.data['widgets']['attach_label3']['ui_name'].replace('%d1',0).replace('%d2',0).replace('%d3',0);
    }

    // clear out empty rows
    while(row < rows_per_page) {
        dialog.widgets['attach_slot'+row.toString()].show =
            dialog.widgets['attach_icon'+row.toString()].show =
            dialog.widgets['attach_stack'+row.toString()].show =
            dialog.widgets['attach_timer_icon'+row.toString()].show =
            dialog.widgets['attach_timer'+row.toString()].show =
            dialog.widgets['attach_frame'+row.toString()].show = false;
        row += 1;
    }

    // set clickability of scroll arrows
    if(page != 0) {
        dialog.widgets['attach_scroll_left'].state = 'normal';
    } else {
        dialog.widgets['attach_scroll_left'].state = 'disabled';
    }

    if(page < (chapter_pages-1)) {
        dialog.widgets['attach_scroll_right'].state = 'normal';
    } else {
        dialog.widgets['attach_scroll_right'].state = 'disabled';
    }

    dialog.widgets['attach_scroll_left'].onclick = function(w) { mail_dialog_attach_scroll(w.parent, w.parent.user_data['attach_page']-1); };
    dialog.widgets['attach_scroll_right'].onclick = function(w) { mail_dialog_attach_scroll(w.parent, w.parent.user_data['attach_page']+1); };

    dialog.widgets['instructions_expire'].show =
        dialog.widgets['instructions_expire_icon'].show = any_expiring;
}

function mail_dialog_invoke_context(inv_dialog, slot, item) {
    var show_dropdown = false;
    if(inv_dialog.user_data['context']) {
        var dialog = inv_dialog.user_data['context'];
        if(dialog.user_data['slot'] === slot && dialog.user_data['item'] === item &&
           dialog.user_data['show_dropdown'] === show_dropdown) {
            return;
        }
        inv_dialog.widgets['attach_frame'+dialog.user_data['x'].toString()].state = 'normal';
        inv_dialog.remove(dialog);
        inv_dialog.user_data['context'] = null;
    }
    if(slot < 0) { return null; }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['inventory_context']);
    var cols = inv_dialog.data['widgets']['attach_frame']['array'][0];
    var x = (slot % cols), y = Math.floor(slot / cols);
    dialog.user_data['slot'] = slot;
    dialog.user_data['item'] = item;
    dialog.user_data['show_dropdown'] = show_dropdown;
    dialog.user_data['x'] = x; dialog.user_data['y'] = y;

    var spec = ItemDisplay.get_inventory_item_spec(item['spec']);


    dialog.widgets['title'].str = ItemDisplay.get_inventory_item_ui_name_long(spec);
    dialog.widgets['title'].text_color = ItemDisplay.get_inventory_item_color(spec);

    // resize width of tooltip area to fit name text
    var name_wh = dialog.widgets['title'].font.measure_string(dialog.widgets['title'].str);
    if(name_wh[0] > dialog.data['dimensions'][0]) {
        dialog.wh = [name_wh[0] + 2 * dialog.data['widgets']['title']['xy'][0], dialog.wh[1]];
        dialog.widgets['bgrect'].wh = vec_copy(dialog.wh); // note: height is reset down below
        dialog.widgets['description'].wh = vec_sub(dialog.widgets['bgrect'].wh, [2 * dialog.data['widgets']['description']['xy'][0],0]);
    }

    // resize height to fit description text
    dialog.widgets['description'].set_text_bbcode(ItemDisplay.get_inventory_item_ui_description(item));
    dialog.widgets['description'].update_dims(); // force immediate text layout so we can determine how much space it takes up
    dialog.widgets['bgrect'].wh[1] = dialog.widgets['title'].wh[1] + dialog.widgets['description'].wh[1];

    var slot_xy = inv_dialog.widgets['attach_frame'+x.toString()].xy;
    var slot_wh = inv_dialog.data['widgets']['attach_frame']['dimensions'];
    dialog.xy = [Math.floor(slot_xy[0]+slot_wh[0]/2 - dialog.wh[0]/2),
                 Math.floor(slot_xy[1]+slot_wh[1]+1)];

    if('expire_time' in item) {
        dialog.widgets['expires'].show = true;
        dialog.widgets['expires'].xy[1] = dialog.widgets['description'].xy[1] + dialog.widgets['description'].wh[1] - dialog.widgets['description'].font.size;
        dialog.widgets['bgrect'].wh[1] += dialog.widgets['expires'].wh[1];
    }
    dialog.widgets['bgrect'].wh[1] += 2;
    dialog.ondraw = update_mail_dialog_context;
    inv_dialog.user_data['context'] = dialog;
    inv_dialog.add(dialog);
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_mail_dialog_context(dialog) {
    var item = dialog.user_data['item'];
    if('expire_time' in item) {
        dialog.widgets['expires'].str = dialog.widgets['expires'].data['ui_name_item'].replace('%s', pretty_print_time_brief(item['expire_time']-server_time));
    }
}

/** If any items in item_list is marked "ui_precious", pop up a confirmation dialog about deleting them.
    Otherwise run the callback immediately.
    @param {!Array.<!Object>} item_list
    @param {function()} action_cb
    @param {boolean} multi - operate on entire stack, not just one from each stack
    @param {string|null|undefined=} refund_str - if present, confirm for a refund instead of a deletion
*/
function confirm_item_delete(item_list, action_cb, multi, refund_str) {
    var need_confirm = goog.array.some(item_list, function(item) {
        var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
        return !!spec['ui_precious'];
    });
    if(need_confirm) {
        var precious_first = goog.array.clone(item_list);
        precious_first.sort(function(a, b) {
            var a_is_precious = !!(ItemDisplay.get_inventory_item_spec(a['spec'])['ui_precious']);
            var b_is_precious = !!(ItemDisplay.get_inventory_item_spec(b['spec'])['ui_precious']);
            if(a_is_precious && !b_is_precious) {
                return -1;
            } else if(!a_is_precious && b_is_precious) {
                return 1;
            } else {
                return 0;
            }
        });

        var ui_item_list = goog.array.map(precious_first, function(item) {
            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            var ui_name = ItemDisplay.get_inventory_item_ui_name(spec);
            var descr = ((multi && 'stack' in item) ? ItemDisplay.get_inventory_item_stack_prefix(spec, item['stack']) : '') + ui_name;
            return descr;
        });
        invoke_item_delete_confirm_dialog(action_cb, ui_item_list, refund_str);
        return;
    } else {
        action_cb();
    }
}

/** @param {function()} action_cb
    @param {!Array.<string>} ui_item_list
    @param {string|null|undefined?} refund_str - if present, confirm for a refund instead of a deletion
*/
function invoke_item_delete_confirm_dialog(action_cb, ui_item_list, refund_str) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['item_delete_confirm_dialog']);
    dialog.user_data['dialog'] = 'item_delete_confirm_dialog';
    dialog.user_data['action_cb'] = action_cb;
    dialog.user_data['want_refund'] = !!refund_str;

    dialog.modal = true;
    install_child_dialog(dialog);

    dialog.widgets['close_button'].onclick = close_parent_dialog;

    dialog.widgets['title'].str = dialog.data['widgets']['title'][refund_str ? 'ui_name_refund' : 'ui_name'];

    var ui_descr = dialog.data['widgets']['description'][refund_str ? 'ui_name_refund' : 'ui_name'];
    dialog.widgets['description'].set_text_bbcode(ui_descr.replace('%thing',ui_item_list.join(', ')).replace('%refund',refund_str));

    dialog.widgets['ok_button'].onclick = dialog.widgets['input'].ontextready = function(w) {
        var dialog = w.parent;
        if(dialog.widgets['input'].str.toUpperCase() != dialog.data['widgets']['input'][dialog.user_data['want_refund'] ? 'require_string_refund' : 'require_string']) { return; } // mismatch
        var cb = dialog.user_data['action_cb'];
        close_parent_dialog(w);
        cb();
    };
    dialog.widgets['input'].ontype = function(w) {
        var dialog = w.parent;
        dialog.widgets['ok_button'].state = (dialog.widgets['input'].str.toUpperCase() == dialog.data['widgets']['input'][dialog.user_data['want_refund'] ? 'require_string_refund' : 'require_string']) ? 'normal' : 'disabled';
    };
    SPUI.set_keyboard_focus(dialog.widgets['input']);

    // dynamic resizing, making room for description text
//    dialog.widgets['description'].wh = [dialog.data['widgets']['description']['dimensions'][0],
//                                        dialog.widgets['description'].font.leading * (dialog.widgets['description'].str.split('\n').length - 1)];
    dialog.widgets['description'].update_dims();
    dialog.wh = [dialog.data['dimensions'][0],
                 dialog.data['dimensions'][1] + Math.max(0, dialog.widgets['description'].wh[1] - dialog.data['widgets']['description']['dimensions'][1] )];
    dialog.widgets['bg'].wh = dialog.wh;
    dialog.apply_layout();
    dialog.auto_center();

    return dialog;
}

/** @type {SPUI.Dialog|null } reference to the one-and-only loot_dialog, if it's on screen */
var global_loot_dialog = null;

/** @param {string=} msg */
function invoke_loot_dialog(msg) {
    if(player.loot_buffer.length < 1) { return null; } // nothing in the loot buffer

    if(!session.home_base) { return null; } // can't use this outside home base
    // (it will be picked up upon return to home base)

    if(global_loot_dialog) {
        // return current dialog rather than refreshing
        return global_loot_dialog;
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['loot_dialog']);
    dialog.user_data['dialog'] = 'loot_dialog';
    dialog.user_data['pending'] = 0;
    dialog.user_data['anim_data'] = {};
    // loot and inventory share init_inventory_grid
    // this adds the 'category' field used for inventory
    // tabs so loot will show all items in inventory
    dialog.user_data['category'] = 'ALL';
    // run inventory_dialog_change_category() to update the inventory grid, but pass 'ALL' because loot only shows 'ALL'
    inventory_dialog_change_category(dialog, 'ALL');
    install_child_dialog(dialog);
    global_loot_dialog = dialog;
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['help_button'].onclick = function(w) {
        invoke_ingame_tip('loot_help_tip', {frequency: GameTipFrequency.ALWAYS});
    };

    dialog.widgets['close_button'].onclick = function(w) {
        var _dialog = w.parent;
        if(player.loot_buffer.length < 1) {
            close_parent_dialog(w); return;
        }
        invoke_inventory_context(_dialog, null, -1, null, false);
        var s = gamedata['strings']['loot_abandon_confirm'];
        invoke_child_message_dialog(s['ui_title'], s['ui_description'],
                                    {'cancel_button': true,
                                     'ok_button_ui_name': s['ui_button'],
                                     'on_ok': (function (_w) { return function() {

                                         confirm_item_delete(player.loot_buffer, (function (__w) { return function() {
                                             if(__w.parent) { close_parent_dialog(__w); }
                                             send_to_server.func(["LOOT_BUFFER_RELEASE", player.loot_buffer]);
                                             player.loot_buffer = [];
                                         }; })(_w), true);

                                     }; })(w)});
    };
    init_inventory_grid(dialog);

    // scroll to final page on first open
    dialog.user_data['page'] = Math.floor(player.inventory.length / (dialog.user_data['rows_per_page'] * dialog.user_data['cols_per_page']));

    dialog.ondraw = update_loot_dialog;

    var warehouse = find_object_by_type(gamedata['inventory_building']);
    if(!warehouse) { throw Error('player has no warehouse'); }
    dialog.user_data['warehouse'] = warehouse;
    change_selection_unit(warehouse);

    if(msg) {
        ItemDisplay.add_inventory_item_effect(session.get_draw_world().fxworld, dialog.widgets['loot_item0,0'], msg, [1,1,0.3]);
    }

    dialog.ondraw(dialog);

    // auto-click the helper if warehouse is inoperative
    if(dialog.widgets['coverup_button'].show) {
        dialog.widgets['coverup_button'].onclick(dialog.widgets['coverup_button']);
    }

    // listen for inventory updates, because they affect inventory grid listings
    dialog.user_data['inventory_update_receiver'] = (function (_dialog) { return function() {
        // run inventory_dialog_change_category() to update the inventory grid, but pass 'ALL' because loot only shows 'ALL'
        inventory_dialog_change_category(_dialog, 'ALL');
    }; })(dialog);
    inventory_update_receivers.push(dialog.user_data['inventory_update_receiver']);
    dialog.on_destroy = function(dialog) {
        goog.array.remove(inventory_update_receivers, dialog.user_data['inventory_update_receiver']);
        global_loot_dialog = null;
    };

    return dialog;
}

function find_dialog(name) {
    var d = selection.ui;
    while(d) {
        if(d.user_data && d.user_data['dialog'] === name) {
            return d;
        } else if(d.children && d.children.length > 0) {
            d = d.children[d.children.length-1];
        } else {
            d = null;
        }
    }
    return d;
}

// match against dialogs that have substitute names
function match_dialog_name(dialog_name, n) {
    if(n === dialog_name) { return true; }
    if(dialog_name === 'map_dialog') {
        if(n === 'map_ladder_pvp_dialog') { return true; }
        if(n === 'region_map_dialog') { return true; }
    }
    return false;
}

function refresh_loot_dialog() {
    var dialog = global_loot_dialog;
    //console.log('refresh_loot_dialog '+(dialog ? 'found' : 'NOT found'));
    if(dialog) {
        dialog.user_data['pending'] = 0;
    }
}

var loot_dialog_fast_anim = false;
function make_loot_dialog_anim_data(dialog, w, asset) {
    var ret = {'start_time': client_time,
               'end_time': client_time + dialog.data['widgets']['loot_anim']['anim_time' + (loot_dialog_fast_anim ? '_fast':'')],
               'orig_pos': vec_copy(w.xy),
               'asset': asset};
    // after first execution, make all future animations fast
    loot_dialog_fast_anim = true;
    return ret;
}

function warehouse_busy_helper(warehouse) {
    change_selection_unit(warehouse);
    if(warehouse.is_damaged() && !warehouse.is_repairing()) {
        invoke_child_repair_dialog();
    } else {
        invoke_child_speedup_dialog('speedup');
    }
}

/** @param {SPUI.Dialog} dialog */
function update_loot_dialog(dialog) {
    // reuse inventory code
    update_inventory_grid(dialog);

    var warehouse = dialog.user_data['warehouse'];
    var warehouse_busy = player.warehouse_is_busy();
    var busy_reason = null;
    if(warehouse_busy) {
        if(warehouse && warehouse.is_damaged()) {
            if(warehouse.is_repairing()) {
                busy_reason = 'repair_speedup';
            } else {
                busy_reason = 'repair';
            }
        } else if(warehouse && (warehouse.is_upgrading() || warehouse.is_enhancing() || warehouse.is_removing())) {
            busy_reason = 'upgrade_speedup';
        } else {
            throw Error("cannot determine warehouse busy reason");
        }
    }

    var can_fit_all = inventory_items_can_all_fit(player.loot_buffer, player.inventory, player.max_usable_inventory());
    var can_fit_item = [];
    var need_storage_for_resource = null;
    for(var i = 0; i < player.loot_buffer.length; i++) {
        var item = player.loot_buffer[i];
        var can_fit = inventory_item_can_fit(item, player.inventory, player.max_usable_inventory());
        can_fit_item.push(can_fit ? 1 : 0);
        if(!can_fit) {
            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            if(spec['fungible'] && spec['resource'] in gamedata['resources']) {
                need_storage_for_resource = [spec['resource'], ('stack' in item ? item['stack'] : 1)];
            }
        }
    }

    // help prompt for warehouse space
    var helper = null;
    if(warehouse_busy) {
        helper = (function(_warehouse) { return function() {
            warehouse_busy_helper(_warehouse);
        }; })(dialog.user_data['warehouse']);
    } else if(need_storage_for_resource) {
        var res = need_storage_for_resource[0], amt = need_storage_for_resource[1];
        helper = get_requirements_help('storages_full', res);
    } else {
        helper = get_requirements_help('inventory_space_need',null);
    }


    // update loot items on left-hand side
   for(var y = 0; y < dialog.data['widgets']['loot_slot']['array'][1]; y++) {
        for(var x = 0; x < dialog.data['widgets']['loot_slot']['array'][0]; x++) {
            var wname = x.toString()+','+y.toString();

            // update animation
            if(wname in dialog.user_data['anim_data']) {
                var data = dialog.user_data['anim_data'][wname];
                var t = (client_time - data['start_time']) / (data['end_time'] - data['start_time']);
                if(t >= 1) {
                    delete dialog.user_data['anim_data'][wname];
                } else {
                    var orig_pos = data['orig_pos'];
                    var targ_pos = dialog.data['widgets']['loot_anim']['target_xy'];
                    var bounce = (1 - (2*t-1)*(2*t-1)) * dialog.data['widgets']['loot_anim']['bounce'];
                    dialog.widgets['loot_anim'+wname].xy = vec_add(vec_add(orig_pos, vec_scale(t, vec_sub(targ_pos, orig_pos))),
                                                                   [0, -bounce]);
                    dialog.widgets['loot_anim'+wname].asset = data['asset'];
                    dialog.widgets['loot_anim'+wname].alpha = dialog.data['widgets']['loot_anim']['alpha'] * Math.min(Math.max(1-t+0.2,0,1));
                }
            }
            dialog.widgets['loot_anim'+wname].show = (wname in dialog.user_data['anim_data']);

            var slot = y * dialog.data['widgets']['loot_slot']['array'][0] + x;
            dialog.widgets['loot_slot'+wname].show =
                dialog.widgets['loot_item'+wname].show =
                dialog.widgets['loot_stack'+wname].show =
                dialog.widgets['loot_pending'+wname].show =
                dialog.widgets['loot_frame'+wname].show = (slot < player.loot_buffer.length);
            if(slot >= player.loot_buffer.length) {
                continue;
            }
            var context_slot = 999 + slot; // distinguish these slots from the ones on the right-hand side

            var item = player.loot_buffer[slot];
            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            ItemDisplay.set_inventory_item_asset(dialog.widgets['loot_item'+wname], spec);
            ItemDisplay.set_inventory_item_stack(dialog.widgets['loot_stack'+wname], spec, item);

            dialog.widgets['loot_pending'+wname].show = !!item['pending'];
            dialog.widgets['loot_frame'+wname].state = ((dialog.user_data['pending'] || item['pending']) ? 'disabled' : (can_fit_item[slot] ? (dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === context_slot ? 'active' : 'normal') : 'disabled_clickable'));

            dialog.widgets['loot_frame'+wname].onenter = (function (_slot, _item) { return function(w) {
                var inv_dialog = w.parent;
                if(inv_dialog.user_data['context'] &&
                   inv_dialog.user_data['context'].user_data['item'] === _item) { return; }
                invoke_inventory_context(w.parent, w, _slot, _item, false);
            }; })(context_slot, item);

            dialog.widgets['loot_frame'+wname].onclick = (function (_wname, _asset, _slot, _item, _can_fit_this, _helper) { return function(w) {
                if(player.warehouse_is_busy() || !_can_fit_this) {
                    if(_helper) { _helper(); }
                } else {
                    // take one item
                    invoke_inventory_context(w.parent, w, -1, null, false);
                    var _d = w.parent;
                    _d.user_data['pending'] = 1;
                    _d.widgets['glow'].show = true;
                    _d.widgets['glow'].reset_fx();
                    send_to_server.func(["LOOT_BUFFER_TAKE", player.loot_buffer, _slot]);
                    _item['pending'] = 1;
                    if(ItemDisplay.get_inventory_item_spec(item['spec'])['fungible']) {
                        ItemDisplay.add_inventory_item_effect(session.get_draw_world().fxworld, w, gamedata['strings']['combat_messages']["collected"], [1,1,0.3,1]);
                    } else {
                        _d.user_data['anim_data'][wname] = make_loot_dialog_anim_data(_d, w, _asset);
                    }
                    // scroll to final page upon "take" action
                    dialog.user_data['page'] = Math.floor(player.inventory.length / (dialog.user_data['rows_per_page'] * dialog.user_data['cols_per_page']));
                }
            }; })(wname, dialog.widgets['loot_item'+wname].asset, slot, item, can_fit_item[slot], helper);

            dialog.widgets['loot_frame'+wname].onleave_cb = (function (_slot, _item) { return function(w) {
                var inv_dialog = w.parent;
                if(inv_dialog.user_data['context'] &&
                   inv_dialog.user_data['context'].user_data['item'] === _item) {
                    invoke_inventory_context(w.parent, w, -1, null, false);
                }
            }; })(slot, item);

            // make item/frame stick out a little bit on mouseover to look more "clickable"
            var stickout = [0,0];
            if(dialog.user_data['context'] && dialog.user_data['context'].user_data['item'] == item) {
                if(!dialog.widgets['loot_frame'+wname].pushed) { stickout = [0,-1]; }
            }
            dialog.widgets['loot_item'+wname].bg_image_offset = stickout;
            dialog.widgets['loot_stack'+wname].text_offset = stickout;
            dialog.widgets['loot_frame'+wname].bg_image_offset = stickout;
        }
   }

    dialog.widgets['store_all_button'].state = ((dialog.user_data['pending'] == 0 && player.loot_buffer.length > 0) ? ((can_fit_all && !warehouse_busy) ? 'normal' : 'disabled_clickable') : 'disabled');
    dialog.widgets['store_all_button'].tooltip.str = null;
    dialog.widgets['warehouse_busy'].show = false; // warehouse_busy;
    dialog.widgets['warehouse_full'].show = (!warehouse_busy && !can_fit_all);
    if(dialog.widgets['warehouse_full'].show) {
        dialog.widgets['warehouse_full'].str = dialog.data['widgets']['warehouse_full'][need_storage_for_resource ? 'ui_name_resource' : 'ui_name'];
    }

    dialog.widgets['coverup_all'].show =
        dialog.widgets['coverup_icon'].show =
        dialog.widgets['coverup_text'].show =
        dialog.widgets['coverup_button'].show = warehouse_busy;
    dialog.widgets['loot_arrow'].show = !warehouse_busy;

    if(warehouse_busy) {
        dialog.widgets['coverup_icon'].asset = get_leveled_quantity(gamedata['buildings'][gamedata['inventory_building']]['art_asset'], 1);
        dialog.widgets['coverup_text'].str = dialog.data['widgets']['coverup_text']['ui_name_'+busy_reason];
        dialog.widgets['coverup_button'].str = dialog.data['widgets']['coverup_button']['ui_name_'+busy_reason];
        dialog.widgets['coverup_button'].onclick = (function(_helper) { return function(w) {
            var dialog = w.parent;
            if(dialog.children[dialog.children.length-1].user_data) {
                // already has a child window
                return;
            } else {
                helper();
            }
        }; })(helper);
        dialog.default_button = dialog.widgets['coverup_button'];
    } else {
        dialog.default_button = dialog.widgets['store_all_button'];
    }

    if(dialog.widgets['store_all_button'].state == 'disabled_clickable') {
        // help prompt for warehouse space
        if(helper) {
            dialog.widgets['store_all_button'].onclick = helper;
            dialog.widgets['store_all_button'].tooltip.str = dialog.data['widgets']['store_all_button']['ui_tooltip_' + (warehouse_busy ? 'warehouse_busy' : (need_storage_for_resource  ? 'need_storage ' : 'need_space'))];
            dialog.widgets['store_all_button'].tooltip.text_color = SPUI.error_text_color;
        } else {
            dialog.widgets['store_all_button'].state = 'disabled';
        }
    } else {
        dialog.widgets['store_all_button'].onclick = function(clicked_widget) {
            var _dialog = clicked_widget.parent;
            _dialog.user_data['pending'] = -1;
            _dialog.widgets['glow'].show = true;
            _dialog.widgets['glow'].reset_fx();
            send_to_server.func(["LOOT_BUFFER_TAKE", player.loot_buffer, -1]);
            for(var i = 0; i < player.loot_buffer.length; i++) {
                player.loot_buffer[i]['pending'] = 1;
            }

            for(var y = 0; y < _dialog.data['widgets']['loot_slot']['array'][1]; y++) {
                for(var x = 0; x < _dialog.data['widgets']['loot_slot']['array'][0]; x++) {
                    var wname = x.toString()+','+y.toString();
                    var w = _dialog.widgets['loot_item'+wname];
                    if(w.show) {
                        var slot = y * _dialog.data['widgets']['loot_slot']['array'][0] + x;
                        var item = player.loot_buffer[slot];

                        if(ItemDisplay.get_inventory_item_spec(item['spec'])['fungible']) {
                            ItemDisplay.add_inventory_item_effect(session.get_draw_world().fxworld, w, gamedata['strings']['combat_messages']["collected"], [1,1,0.3,1]);
                        } else {
                            _dialog.user_data['anim_data'][wname] = make_loot_dialog_anim_data(_dialog, w, w.asset);
                        }
                    }
                }
            }
        };
    }

    if(player.loot_buffer.length < 1 &&
       (!dialog.user_data['pending'] && dialog.widgets['glow'].fx_time_remaining() <= 0)) {
        close_parent_dialog(dialog.widgets['store_all_button']);
    }
}

/** @type {!Array.<function()>} list of callbacks listening for INVENTORY_UPDATE */
var inventory_update_receivers = [];

/** @param {boolean=} force it to open even away from home */
function invoke_inventory_dialog(force) {
    if(!player.get_any_abtest_value('enable_inventory', gamedata['enable_inventory'])) { return null; }
    if(!session.home_base && !force) { return null; }
    // note: assumes the warehouse is already selected

    var dialog = new SPUI.Dialog(gamedata['dialogs']['inventory_dialog']);
    dialog.user_data['dialog'] = 'inventory_dialog';
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    // dialog.user_data['category_list'] is null when in 'ALL' mode,
    // otherwise list of visible entries in gamedata['strings']['inventory_tabs'], unless the inventory show_if predicate is not met
    if(gamedata['strings']['inventory_tabs'] && (!('show_if' in gamedata['strings']['inventory_tabs']) || read_predicate(gamedata['strings']['inventory_tabs']['show_if']).is_satisfied(player, null))) {
        dialog.user_data['category_list'] = goog.array.filter(gamedata['strings']['inventory_tabs']['tabs'], function(entry) {
            return !('show_if' in entry) || read_predicate(entry['show_if']).is_satisfied(player, null);
        });
    } else {
        dialog.user_data['category_list'] = null;
    }

    // turns off the static "Items" label if categories are enabled
    dialog.widgets['section'].show = !dialog.user_data['category_list'];

    if(dialog.user_data['category_list']) {
        var used = dialog.user_data['category_list'].length;
    	var i = 0;

        var x_spacing = dialog.data['widgets']['category_button']['array_offset'][0];
        var x_start = dialog.data['widgets']['category_button']['topbar_width'] / 2 - ((used-1)/2) * x_spacing;

        goog.array.forEach(dialog.user_data['category_list'], function(entry) {
            // manually compute X coordinate to center all the visible buttons
            var x = Math.floor(x_start + i * x_spacing + dialog.data['widgets']['category_button']['xy'][0] - dialog.data['widgets']['category_button']['dimensions'][0]/2);
            dialog.widgets['category_button'+i.toString()].xy = [x, dialog.data['widgets']['category_button']['xy'][1]];

            dialog.widgets['category_button'+i.toString()].str = entry['ui_name'];
            dialog.widgets['category_button'+i.toString()].onclick = (function (_catname) { return function(w) { inventory_dialog_change_category(dialog, _catname); }; })(entry['name']);
            i++;
            if(i >= dialog.data['widgets']['category_button']['array'][0]) { throw Error('not enough category_button array entries!'); }
        });
        while(i < dialog.data['widgets']['category_button']['array'][0]) {
            dialog.widgets['category_button'+i.toString()].show = false;
            i++;
        }
    }

    // set default category to show all items even if category tabs are disabled
    inventory_dialog_change_category(dialog, 'ALL');

    init_inventory_grid(dialog);
    dialog.ondraw = update_inventory_grid;

    // listen for inventory updates, because they affect category grid listings
    dialog.user_data['inventory_update_receiver'] = (function (_dialog) { return function() {
        // run inventory_dialog_change_category() to update the inventory grid, but pass the current category so the category doesn't change
        inventory_dialog_change_category(dialog, dialog.user_data['category']);
    }; })(dialog);
    inventory_update_receivers.push(dialog.user_data['inventory_update_receiver']);
    dialog.on_destroy = function(dialog) { goog.array.remove(inventory_update_receivers, dialog.user_data['inventory_update_receiver']); };

    update_inventory_header_buttons(dialog, find_object_by_type(gamedata['inventory_building']), 'inventory');
    return dialog;
}

/** @param {SPUI.Dialog} dialog
    @param {string} category*/
function inventory_dialog_change_category(dialog, category) {
    dialog.user_data['category'] = category;
    // check if an inventory item is open and close if it is
    if(dialog.user_data['context']) {
        close_dialog(dialog.user_data['context']);
    }
    if(dialog.user_data['category_list']) {
        goog.array.forEach(dialog.user_data['category_list'], function(entry, i) {
            var w = dialog.widgets['category_button'+i.toString()];
            w.text_color = (category === entry['name'] ? SPUI.default_text_color : SPUI.disabled_text_color);
            w.state = (category === entry['name'] ? 'active' : 'normal');
        });
    }
    // reset the category index
    dialog.user_data['category_index'] = [];
    // if the category is 'ALL', the category_inventory is the player's whole inventory
    if (category === 'ALL') {
        dialog.user_data['category_inventory'] = Array.from(player.inventory);
        // if the category is 'ALL', the category_index will just match the index of player.inventory
        goog.array.forEach(player.inventory, function(ply_inv, i) {
            dialog.user_data['category_index'].push(i);
        });
    } else {
        var check_category = goog.array.find(dialog.user_data['category_list'], function(entry){
            return entry['name'] == category;
        });
        if(!check_category) { throw Error('unknown category '+category); }
        var show_categories = check_category['categories'];
        var category_inventory = []
        goog.array.forEach(player.inventory, function(item, i) {
            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            var item_category = ItemDisplay.get_inventory_item_category(spec);
            if (goog.array.contains(show_categories, item_category)) {
                category_inventory.push(item);
                dialog.user_data['category_index'].push(i); // category_index is populated with the player.inventory index entry for each item added to the category_inventory
            };
        });
        dialog.user_data['category_inventory'] = category_inventory; // all items in the player's inventory matching the subcategories are sent back to the dialog
    }
}

var inventory_restack_sync_marker = Synchronizer.INIT;
// the "inventory grid" functions are used by both inventory_dialog and loot_dialog
/** @param {SPUI.Dialog} dialog */
function init_inventory_grid(dialog) {
    dialog.user_data['restack_sort_order'] = 1;
    dialog.user_data['context'] = null;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['item']['array'][1];
    dialog.user_data['cols_per_page'] = dialog.data['widgets']['item']['array'][0];
    // updating is done through the dialog's update_inventory_grid(), not rowfunc.
    dialog.user_data['rowfunc'] = function (dialog, data) { };
    dialog.user_data['roworder'] = 'left_right_top_bottom';
    dialog.user_data['rowdata'] = [];
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;
    dialog.user_data['page'] = -1;
    scrollable_dialog_change_page(dialog, dialog.user_data['page']);
}

/** @param {SPUI.Dialog} dialog */
function update_inventory_grid(dialog) {
    var any_expiring = false;
    var category_inventory = dialog.user_data['category_inventory'];

    var provides = gamedata['buildings'][gamedata['inventory_building']]['provides_inventory'];
    var max_possible_slots = Math.max((typeof(provides) === 'number' ? provides : provides[provides.length-1]), player.inventory.length); // allow for over-stuffed inventory
    var warehouse_busy = player.warehouse_is_busy();
    var max_usable_inventory = Math.max(player.max_usable_inventory(), player.inventory.length); // allow for over-stuffed inventory
    var craft_products = [], craft_product_i = 0;

    // need to update scrolling per-frame as category_inventory changes
    var slots_per_page = dialog.user_data['rows_per_page'] * dialog.user_data['cols_per_page'];
    // add as many rowdata entries as necessary to fill the final page, but not beyond that
    var shown_slots = Math.min(max_possible_slots, slots_per_page * Math.floor((max_usable_inventory-1)/slots_per_page)+ slots_per_page - max_usable_inventory % slots_per_page);

    // note: rowdata here is just a placeholder null (so that scrollable_dialog_change_page() works)
    // the actual data is in category_inventory
    if(dialog.user_data['rowdata'].length != shown_slots) {
        dialog.user_data['rowdata'] = [];
        for(var s = 0; s < shown_slots; s++) { dialog.user_data['rowdata'].push(null); }
    }
    scrollable_dialog_change_page(dialog, dialog.user_data['page']);
    dialog.widgets['custom_scroll_text'].str = dialog.data['widgets']['custom_scroll_text']['ui_name'].replace('%d1', pretty_print_number((slots_per_page * dialog.user_data['page'])+1)).replace('%d2', pretty_print_number(Math.min(slots_per_page * (dialog.user_data['page']+1), max_usable_inventory))).replace('%d3', pretty_print_number(player.max_usable_inventory()));
    // hide scroll text if beyond end of usable slots
    dialog.widgets['custom_scroll_text'].show = (dialog.user_data['category'] === 'ALL') &&
        ((slots_per_page * dialog.user_data['page'])+1 <= max_usable_inventory);

    if('no_items_this_category' in dialog.widgets) {
        dialog.widgets['no_items_this_category'].show =
            (dialog.user_data['category'] !== 'ALL') && (category_inventory.length == 0);
    }

    var cols = dialog.data['widgets']['slot']['array'][0];
    for(var y = 0; y < dialog.data['widgets']['slot']['array'][1]; y++) {
        for(var x = 0; x < cols; x++) {
            var wname = x.toString()+','+y.toString();

            // index of slot in the visible GUI
            var ui_slot = y*cols + x + dialog.user_data['page'] * slots_per_page;
            // index of slot in player.inventory
            var inv_slot = dialog.user_data['category_index'][ui_slot];

            dialog.widgets['item'+wname].show =
                dialog.widgets['slot'+wname].show =
                dialog.widgets['stack'+wname].show =
                dialog.widgets['timer_icon'+wname].show =
                dialog.widgets['timer'+wname].show =
                dialog.widgets['pending'+wname].show =
                dialog.widgets['frame'+wname].show = false;

            if(ui_slot < max_usable_inventory) {
                if(ui_slot < category_inventory.length) {
                    // there's an item here
                    var item = category_inventory[ui_slot];
                    var spec = ItemDisplay.get_inventory_item_spec(item['spec']);

                    dialog.widgets['slot'+wname].show = true;
                    dialog.widgets['slot'+wname].state = 'normal';
                    dialog.widgets['item'+wname].show = true;
                    ItemDisplay.set_inventory_item_asset(dialog.widgets['item'+wname], spec);
                    ItemDisplay.set_inventory_item_stack(dialog.widgets['stack'+wname], spec, item);

                    dialog.widgets['frame'+wname].show = true;

                    if('expire_time' in item) {
                        any_expiring = true;
                        dialog.widgets['timer_icon'+wname].show = true;
                        dialog.widgets['timer'+wname].show = true;
                        dialog.widgets['timer'+wname].str = do_pretty_print_time(item['expire_time']-server_time, 1, false);
                    }

                    var can_activate;
                    if('fungible' in spec) {
                        can_activate = true;
                    } else if('use' in spec) {
                        can_activate = true;
                        if('requires' in spec && !read_predicate(spec['requires']).is_satisfied(player,null)) {
                            can_activate = false;
                        }
                        if(can_activate) {
                            var uselist = get_as_array(spec['use']);
                            for(var m = 0; m < uselist.length; m++) {
                                var use = uselist[m];
                                if('spellname' in use) {
                                    var spellname = use['spellname'];
                                    var spellarg = use['spellarg'] || null;
                                    var spell = gamedata['spells'][spellname];
                                    var temp_arg;
                                    if(spell['activation'] && spell['activation'].indexOf('targeted') == 0) {
                                        temp_arg = [spellarg,null];
                                    } else {
                                        temp_arg = spellarg;
                                    }
                                    can_activate = can_cast_spell(GameObject.VIRTUAL_ID, spellname, temp_arg);
                                } else if('consequent' in use) {
                                    can_activate = true;
                                } else {
                                    can_activate = false;
                                }
                                if(!can_activate) { break; }
                            }
                        }
                    } else if('equip' in spec && (spec['equip']['kind'] == 'mobile' && 'name' in spec['equip'])) {
                        can_activate = true; // unit equips pop up upgrade dialog
                    } else {
                        can_activate = false;
                    }

                    if(item['pending']) { can_activate = false; }
                    if(warehouse_busy) { can_activate = false; }
                    if(!synchronizer.is_in_sync(inventory_restack_sync_marker)) { can_activate = false; }

                    dialog.widgets['frame'+wname].state = (!can_activate ? 'cooldown' : (dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === inv_slot ? 'active' : 'normal'));

                    dialog.widgets['frame'+wname].onenter = (function (_inv_slot, _item) { return function(w) {
                        var inv_dialog = w.parent;
                        // XXX awkward hack to do nothing if another dialog is obscuring this one
                        if(inv_dialog.children[inv_dialog.children.length-1] instanceof SPUI.Dialog &&
                           inv_dialog.children[inv_dialog.children.length-1].user_data['dialog']) {
                            return;
                        }

                        if(inv_dialog.user_data['context']) {
                            // do not switch if context for this item is already up
                            if(inv_dialog.user_data['context'].user_data['slot'] === _inv_slot &&
                               inv_dialog.user_data['context'].user_data['item'] === _item) {
                                return;
                            }
                            if(inv_dialog.user_data['context'].user_data['show_dropdown']) {
                                // do not switch if mouse is still somewhat within bounds of current context
                                var c = inv_dialog.user_data['context'];
                                var abs_xy = c.get_absolute_xy();
                                if((mouse_state.last_raw_x >= abs_xy[0]) && (mouse_state.last_raw_x < (abs_xy[0]+c.wh[0])) &&
                                   (mouse_state.last_raw_y >= abs_xy[1])) { // note: no check on Y max
                                    return;
                                }
                            }
                        }
                        invoke_inventory_context(w.parent, w, _inv_slot, _item, false);
                    }; })(inv_slot, item);
                    dialog.widgets['frame'+wname].onclick = (function (_inv_slot, _item) { return function(w) {
                        var inv_dialog = w.parent;

                        if(inv_dialog.user_data['context'] &&
                           inv_dialog.user_data['context'].user_data['slot'] === _inv_slot &&
                           inv_dialog.user_data['context'].user_data['item'] === _item &&
                           inv_dialog.user_data['context'].user_data['show_dropdown']) {
                            // if context menu is already up for this item, simulate a click on "Activate"

                            // pop up helper when item can't be used
                            if(player.warehouse_is_busy()) {
                                warehouse_busy_helper(find_object_by_type(gamedata['inventory_building']));
                                return;
                            }

                            var spec = ItemDisplay.get_inventory_item_spec(_item['spec']);

                            if('requires' in spec && !read_predicate(spec['requires']).is_satisfied(player,null)) { return; } // cannot use
                            if('use' in spec) {
                                var uselist = get_as_array(spec['use']);
                                for(var m = 0; m < uselist.length; m++) {
                                    var use = uselist[m];
                                    if('spellname' in use) {
                                        var spellname = use['spellname'];
                                        var spellarg = use['spellarg'] || null;
                                        var spell = gamedata['spells'][spellname];
                                        var temp_arg;
                                        if(spell['activation'] && spell['activation'].indexOf('targeted') == 0) {
                                            temp_arg = [spellarg,null];
                                        } else {
                                            temp_arg = spellarg;
                                        }
                                        var can_cast_detailed = (_item['pending'] ? [false, gamedata['strings']['inventory']['pending'], null] :
                                                                 can_cast_spell_detailed(GameObject.VIRTUAL_ID, spellname, temp_arg));
                                        if(!can_cast_detailed[0] && can_cast_detailed[2]) {
                                            // cannot cast
                                            var helper = get_requirements_help(can_cast_detailed[2][0], can_cast_detailed[2][1], can_cast_detailed[2][2] || null);
                                            if(helper) { helper(); }
                                            return;
                                        }
                                    }
                                }
                            }
                            if(inv_dialog.user_data['context'].widgets['button0'].state != 'disabled') {
                                inv_dialog.user_data['context'].widgets['button0'].onclick(inv_dialog.user_data['context'].widgets['button0']);
                            }

                        } else {
                            invoke_inventory_context(w.parent, w, _inv_slot, _item, true);
                        }
                    }; })(inv_slot, item);
                    dialog.widgets['frame'+wname].onleave_cb = (function (_inv_slot, _item) { return function(w) {
                        var inv_dialog = w.parent;
                        if(inv_dialog.user_data['context'] &&
                           inv_dialog.user_data['context'].user_data['slot'] === _inv_slot &&
                           inv_dialog.user_data['context'].user_data['item'] === _item &&
                           !inv_dialog.user_data['context'].user_data['show_dropdown']) {
                            invoke_inventory_context(w.parent, w, -1, null, false);
                        }
                    }; })(inv_slot, item);
                    // make item/frame stick out a little bit on mouseover to look more "clickable"
                    var stickout = [0,0];
                    if(dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] == inv_slot && dialog.user_data['context'].user_data['item'] == item) {
                        if(!dialog.widgets['frame'+wname].pushed) { stickout = [0,-1]; }
                    }
                    dialog.widgets['item'+wname].bg_image_offset = stickout;
                    dialog.widgets['stack'+wname].text_offset = stickout;
                    dialog.widgets['frame'+wname].bg_image_offset = stickout;
                } else {
                    // it's an open slot
                    if(dialog.user_data['category'] === 'ALL') {
                        // show as empty
                        dialog.widgets['slot'+wname].show = true;
                        dialog.widgets['slot'+wname].state = 'normal';
                    } else {
                        // in filtered view, hide empty slots
                        dialog.widgets['slot'+wname].show = false;
                    }
                }
            } else if(ui_slot < player.max_inventory) {
                // it's a reserved slot for crafting
                dialog.widgets['slot'+wname].show = true;
                dialog.widgets['frame'+wname].show = true;
                dialog.widgets['frame'+wname].state = 'disabled';
                dialog.widgets['pending'+wname].show = true;
                if(craft_product_i < craft_products.length) {
                    var item = craft_products[craft_product_i];
                    var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
                    dialog.widgets['item'+wname].show = true;
                    ItemDisplay.set_inventory_item_asset(dialog.widgets['item'+wname], spec);
                    ItemDisplay.set_inventory_item_stack(dialog.widgets['stack'+wname], spec, item);
                    craft_product_i++;
                } else {
                    // unknown
                }
            } else if(ui_slot < max_possible_slots && dialog.user_data['category'] === 'ALL') {
                dialog.widgets['slot'+wname].show = true;
                dialog.widgets['slot'+wname].state = 'locked';
                dialog.widgets['slot'+wname].onclick = function(w) {
                    var helper = get_requirements_help('inventory_space_offer', null);
                    if(helper) { helper(); }
                };
            } else {
                // do not show even a padlock
            }
        }
    }
    if('instructions_expire' in dialog.widgets) {
        dialog.widgets['instructions_expire'].show =
            dialog.widgets['instructions_expire_icon'].show = any_expiring;
    }

    if('upgrade_level' in dialog.widgets) {
        dialog.widgets['upgrade_level'].show = dialog.widgets['upgrade_button'].show = false;
        var warehouse = find_object_by_type(gamedata['inventory_building']);
        if('warehouse_label' in dialog.widgets) {
            dialog.widgets['warehouse_label'].show = !!warehouse;
            dialog.widgets['warehouse_label'].str = dialog.data['widgets']['warehouse_label']['ui_name'].replace('%d', (warehouse ? warehouse.level.toString() : 'unknown'));
        }

        if(warehouse) {
            var max_level = warehouse.get_max_ui_level();
            if(warehouse.level < max_level) {
                dialog.widgets['upgrade_level'].show = dialog.widgets['upgrade_button'].show = true;
                var cur_slots = get_leveled_quantity(provides, warehouse.level);
                var next_slots = get_leveled_quantity(provides, Math.min(max_level, warehouse.level+1));
                var add_slots = next_slots - cur_slots;

                for(var w in {'upgrade_level':1,'upgrade_button':1}) {
                    dialog.widgets[w].str = dialog.data['widgets'][w]['ui_name'].replace('%CUR', warehouse.level.toString()).replace('%NEXT', (warehouse.level+1).toString()).replace('%SLOT', add_slots.toString()).replace('%plural', (add_slots == 1 ? '' : 's'));
                }

                dialog.widgets['upgrade_button'].onclick = (function (_warehouse) { return function(w) {
                    change_selection_unit(_warehouse);
                    invoke_upgrade_building_dialog();
                }; })(warehouse);
            }
        }
    }

    if('overstuffed_warning' in dialog.widgets) {
        dialog.widgets['overstuffed_warning'].show = (player.inventory.length > player.max_usable_inventory());
        dialog.widgets['overstuffed_warning'].str = dialog.data['widgets']['overstuffed_warning'][(warehouse && warehouse.level < warehouse.get_max_ui_level() ? 'ui_name': 'ui_name_maxlevel')].replace('%s', warehouse.spec['ui_name']);
    }

    dialog.widgets['restack_button'].show = (dialog.user_data['category'] === 'ALL') && !warehouse_busy && eval_cond_or_literal(gamedata['client']['enable_inventory_restack'] || 0, player, null);
    dialog.widgets['restack_button'].onclick = function(w) {
        var dialog = w.parent;
        if(dialog.user_data['context']) {
            invoke_inventory_context(dialog, null, -1, null, false);
        }
        if(!synchronizer.is_in_sync(inventory_restack_sync_marker)) { return; }
        send_to_server.func(["INVENTORY_RESTACK", dialog.user_data['restack_sort_order']]);
        dialog.user_data['restack_sort_order'] *= -1;
        inventory_restack_sync_marker = synchronizer.request_sync();
    };
    dialog.widgets['restack_spinner'].show =
        dialog.widgets['pending_all_mask'].show = !synchronizer.is_in_sync(inventory_restack_sync_marker);
};

/** @constructor @struct
    @param {{ui_name: string,
             ui_name_pending: string,
             state: (string|undefined),
             spellname: string,
             max_count: (number|undefined),
             associated_recipe_name: (string|undefined),
             associated_recipe_level: (number|undefined)}} props */
var InventoryContextButton = function(props) {
    this.ui_name = props.ui_name;
    this.ui_name_pending = props.ui_name_pending;
    this.state = props.state || 'passive';
    if(!goog.array.contains(['active','passive'], this.state)) { throw Error('bad state '+this.state); }
    this.spellname = props.spellname;
    this.max_count = props.max_count || 1;
    this.associated_recipe_name = props.associated_recipe_name || null;
    this.associated_recipe_level = props.associated_recipe_level || 1;
}

/** @param {SPUI.Dialog|SPUI.Element} inv_dialog
    @param {SPUI.DialogWidget} parent_widget
    @param {?} slot
    @param {Object} item
    @param {boolean} show_dropdown
    @param {Object=} props */
function invoke_inventory_context(inv_dialog, parent_widget, slot, item, show_dropdown, props) {

    if(inv_dialog.user_data['context']) {
        var dialog = inv_dialog.user_data['context'];
        if(dialog.user_data['slot'] === slot && dialog.user_data['item'] === item &&
           dialog.user_data['show_dropdown'] === show_dropdown) {
            return dialog;
        }
        if(dialog.parent) { dialog.parent.remove(dialog); }
        //inv_dialog.remove(dialog);
        inv_dialog.user_data['context'] = null;
    }
    player.quest_tracked_dirty = true;

    if(slot < 0) { return null; }

    // SPUI.Container to which this widget will be parented (usually inv_dialog, but may be overridden)
    var parent_dialog = (props && props['parent_dialog'] ? props['parent_dialog'] : inv_dialog);

    var dialog = new SPUI.Dialog(gamedata['dialogs']['inventory_context']);
    dialog.user_data['dialog'] = 'inventory_context';
    dialog.user_data['props'] = props || null;
    dialog.user_data['parent_widget'] = parent_widget;
    dialog.user_data['parent_dialog'] = parent_dialog;
    dialog.user_data['slot'] = slot;
    dialog.user_data['item'] = item;
    if('expire_time' in item) { dialog.user_data['expire_time'] = item['expire_time']; }
    if('melt_duration' in item) { dialog.user_data['melt_duration'] = item['melt_duration']; }
    dialog.user_data['show_dropdown'] = show_dropdown;


    var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
    var can_cast_detailed = null;
    if('fungible' in spec) {
        can_cast_detailed = [true,null,null];
    } else if('use' in spec) {
        if('requires' in spec && !read_predicate(spec['requires']).is_satisfied(player,null)) {
            var pred = read_predicate(spec['requires']);
            can_cast_detailed = [false, pred.ui_describe(player), [pred, null]];
        } else {
            var uselist = get_as_array(spec['use']);
            for(var m = 0; m < uselist.length; m++) {
                var use = uselist[m];
                if('spellname' in use) {
                    var spellname = use['spellname'];
                    var spellarg = use['spellarg'] || null;
                    var spell = gamedata['spells'][spellname];
                    var temp_arg;
                    if(spell['activation'] && spell['activation'].indexOf('targeted') == 0) {
                        temp_arg = [spellarg,null];
                    } else {
                        temp_arg = spellarg;
                    }
                    can_cast_detailed = (item['pending'] ? [false, gamedata['strings']['inventory']['pending'], null] :
                                         can_cast_spell_detailed(GameObject.VIRTUAL_ID, spellname, temp_arg));
                } else if('consequent' in use) {
                    can_cast_detailed = [true,null,null];
                }
                if(!can_cast_detailed[0]) {
                    // stop at first false condition
                    break;
                }
            }
        }
    } else if('equip' in spec && spec['equip']['kind'] == 'building') {
        can_cast_detailed = [false, gamedata['strings']['inventory']['building_equip_tooltip'], null];
    } else if('equip' in spec && spec['equip']['kind'] == 'mobile') {
        if('name' in spec['equip']) {
            can_cast_detailed = [true,null,null];
        } else {
            can_cast_detailed = [false, gamedata['strings']['inventory']['unit_equip_tooltip'], null];
        }
    } else {
        can_cast_detailed = [false,null,null];
    }

    if(can_cast_detailed === null) { throw Error('cannot determine usability of item '+spec['name']); }
    var can_cast = can_cast_detailed[0];


    dialog.widgets['title'].str = ItemDisplay.get_inventory_item_ui_name_long(spec);
    dialog.widgets['title'].text_color = ItemDisplay.get_inventory_item_color(spec);

    // add optional subtitle and move description downward
    var subtitle = ItemDisplay.get_inventory_item_ui_subtitle(spec);
    if(subtitle) {
        dialog.widgets['subtitle'].wh = [dialog.data['widgets']['subtitle']['dimensions'][0], dialog.data['widgets']['description']['dimensions'][1]];
        dialog.widgets['subtitle'].str = subtitle;
        dialog.widgets['subtitle'].show = true;
        dialog.widgets['description'].xy = vec_add(dialog.data['widgets']['description']['xy'], [0,dialog.widgets['subtitle'].wh[1]]);
    }

    // enlarge width of tooltip area to fit name text, if necessary
    var name_w = Math.max(dialog.widgets['title'].font.measure_string(dialog.widgets['title'].str)[0],
                          dialog.widgets['subtitle'].font.measure_string(dialog.widgets['subtitle'].str)[0]);

    // add extra padding for set-bonus items to help avoid extra line breaks in the set-bonus tooltip
    if(spec['item_set']) {
        name_w += dialog.widgets['subtitle'].font.measure_string('(0/0):')[0]; // My Item set (0/0):
        // max() of sibling item name lengths
        var item_set = gamedata['item_sets'][spec['item_set']];
        goog.array.forEach(item_set['members'], function(sibling) {
            var sibling_name = gamedata['items'][sibling]['ui_name'];
            name_w = Math.max(name_w, dialog.widgets['subtitle'].font.measure_string(sibling_name)[0]);
        });
    }

    if((name_w + 2 * dialog.data['widgets']['title']['xy'][0]) > dialog.data['dimensions'][0]) {
        dialog.wh = [name_w + 2 * dialog.data['widgets']['title']['xy'][0], dialog.wh[1]];
        dialog.widgets['bgrect'].wh = vec_copy(dialog.wh); // note: height is reset down below
        dialog.widgets['description'].wh = vec_sub(dialog.widgets['bgrect'].wh, [2 * dialog.data['widgets']['description']['xy'][0],0]);

        // recenter buttons
        dialog.widgets['buttonbg'].xy = [Math.floor((dialog.wh[0] - dialog.data['widgets']['buttonbg']['dimensions'][0])/2), dialog.widgets['buttonbg'].xy[1]];
        for(var i = 0; i < dialog.data['widgets']['button']['array'][1]; i++) {
            dialog.widgets['button'+i].xy = [Math.floor((dialog.wh[0]-dialog.data['widgets']['button']['dimensions'][0])/2),
                                             dialog.widgets['button'+i].xy[1]];
        }
    }

    // enlarge height to fit description text
    dialog.widgets['description'].set_text_bbcode(ItemDisplay.get_inventory_item_ui_description(item));
    dialog.widgets['description'].update_dims(); // force immediate text layout so we can determine how much space it takes up
    dialog.widgets['bgrect'].wh[1] = dialog.widgets['title'].wh[1] + dialog.widgets['subtitle'].wh[1] + dialog.widgets['description'].wh[1];

    // optionally add expiration timer
    if(('expire_time' in item) || ('melt_duration' in item) || (props && props['error_text'])) {
        dialog.widgets['expires'].show = true;
        dialog.widgets['expires'].xy[1] = dialog.widgets['description'].xy[1] + dialog.widgets['description'].wh[1] - dialog.widgets['description'].font.size;
        if(props && props['error_text']) {
            dialog.widgets['expires'].set_text_with_linebreaking(props['error_text']);
            // have to pre-measure here since setting xy requires a correct value for this.wh[0]
            dialog.widgets['expires'].wh = dialog.widgets['expires'].font.measure_string(dialog.widgets['expires'].str);
        }

        dialog.widgets['bgrect'].wh[1] += dialog.widgets['expires'].wh[1];
    }
    dialog.widgets['bgrect'].wh[1] += 4;

    // position relative to parent
    var slot_xy = vec_sub(parent_widget.get_absolute_xy(), parent_dialog.get_absolute_xy()); // parent_widget.xy;
    var slot_wh = parent_widget.wh;
    if(props && props['position'] == 'top_or_bottom') {
        if(parent_widget.get_absolute_xy()[1] + slot_wh[1] + dialog.widgets['bgrect'].wh[1] >= canvas_height) {
            props['position'] = 'top';
        } else {
            props['position'] = 'bottom';
        }
    }
    if(props && props['position'] == 'right') {
        dialog.xy = [slot_xy[0] + slot_wh[0] + 1,
                     slot_xy[1]];
    } else if(props && props['position'] == 'top') {
        dialog.xy = [Math.floor(slot_xy[0]+slot_wh[0]/2 - dialog.wh[0]/2),
                     slot_xy[1] - dialog.widgets['bgrect'].wh[1] - 2];
    } else {
        dialog.xy = [Math.floor(slot_xy[0]+slot_wh[0]/2 - dialog.wh[0]/2),
                     Math.floor(slot_xy[1]+slot_wh[1]+1)];
    }

    dialog.user_data['base_xy'] = dialog.xy;

    // initialize button drop-down
    dialog.user_data['anim_start'] = (show_dropdown ? client_time : -1);

    var make_button_cb = function (_slot, _item, _butt) { return function(w) {
        if(_butt.spellname === "SPEEDUP") {
            warehouse_busy_helper(find_object_by_type(gamedata['inventory_building']));
        } else if(_butt.spellname === "CRAFT_FOR_FREE") {
            var rec_spec = gamedata['crafting']['recipes'][_butt.associated_recipe_name];
            var dialog = invoke_crafting_dialog(rec_spec['crafting_category'], rec_spec['associated_item_set'] || null);
            if(dialog) {
                var rec = goog.array.find(dialog.user_data['recipes'] || [], function(entry) {
                    return (entry['spec'] === _butt.associated_recipe_name && (entry['level']||1) === _butt.associated_recipe_level);
                });
                if(rec) {
                    crafting_dialog_select_recipe(dialog.widgets['recipe'], rec);
                }
            }
        } else if(_butt.spellname === "EQUIP_UNIT") {
            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            var unit_name = spec['equip']['name'];
            var d = invoke_upgrade_tech_dialog(gamedata['units'][unit_name]['level_determined_by_tech'], null);
            if(d && d.user_data['dialog'] == 'upgrade_dialog') {
                // pop up chooser
                // is item already equipped?
                var identical_found = false, any_found = false;
                var eq = player.unit_equipment;
                if(unit_name in eq) {
                    if(spec['equip']['slot_type'] in eq[unit_name]) {
                        for(var i = 0; i < eq[unit_name][spec['equip']['slot_type']].length; i++) {
                            any_found = true;
                            if(eq[unit_name][spec['equip']['slot_type']][i] === item['spec']) {
                                identical_found = true; break;
                            }
                        }
                    }
                }
                if(!identical_found && (spec['equip']['slot_type'] in d.user_data['equip_slots_by_type'])) {
                    var slot_i = d.user_data['equip_slots_by_type'][spec['equip']['slot_type']];
                    d.widgets['equip_frame'+slot_i].mouse_enter_time = client_time; //state = 'active';
                    var chooser = invoke_equip_chooser_dialog(d, d.widgets['equip_frame'+slot_i], d.user_data['tech'], d.user_data['unit'], spec['equip']['slot_type'], 0, slot_i);
                    // if there are two possibilities, and the slot is empty, just do the equip immediately
                    if(!any_found && chooser.widgets['equip_frame0'].show && !chooser.widgets['equip_frame1'].show && chooser.widgets['equip_frame0'].state != 'disabled') {
                        chooser.widgets['equip_frame0'].onclick(chooser.widgets['equip_frame0']);
                    }
                }
            }

        } else if(inventory_action(_item, _slot, _butt.spellname, {trigger_gcd: session.has_deployed, // trigger GCD during combat only
                                                                  max_count: _butt.max_count})) {
            w.str = _butt.ui_name_pending;
            w.state = 'disabled';

            // disable all other buttons
            if(w.parent) {
                for(var j = 0; j < w.parent.user_data['buttons'].length; j++) {
                    w.parent.widgets['button'+j.toString()].state = 'disabled';
                }
            }
        }
    }; };

    if(player.warehouse_is_busy()) {
        dialog.user_data['buttons'] = [new InventoryContextButton({ui_name:gamedata['strings']['inventory']['warehouse_busy'],
                                                                   ui_name_pending:'',
                                                                   state:'active',
                                                                   spellname:"SPEEDUP"})];
    } else {
        dialog.user_data['buttons'] = [];
        if('equip' in spec && spec['equip']['kind'] == 'mobile' && ('name' in spec['equip'])) {
            dialog.user_data['buttons'].push(new InventoryContextButton({ui_name:gamedata['strings']['inventory']['equip_button'],
                                                                         ui_name_pending:gamedata['strings']['inventory']['equip_button_pending'],
                                                                         state:'active',
                                                                         spellname:"EQUIP_UNIT"}));
        } else {
            dialog.user_data['buttons'].push(new InventoryContextButton({ui_name: spec['ui_activate_button'] || gamedata['strings']['inventory']['activate_button'],
                                                                         ui_name_pending: spec['ui_activate_button_pending'] || gamedata['strings']['inventory']['activate_button_pending'],
                                                                         state:'active',
                                                                         spellname: "INVENTORY_USE"}));

            // multi-activate for stacked units
            if(item['stack'] && item['stack'] > 1 && spec['use'] && ('spellname' in spec['use']) && spec['use']['spellname'] == 'GIVE_UNITS') {
                dialog.user_data['buttons'].push(new InventoryContextButton({ui_name:gamedata['strings']['inventory']['activate_all_button'],
                                                                             ui_name_pending:gamedata['strings']['inventory']['activate_all_button_pending'],
                                                                             state:'active',
                                                                             spellname:"INVENTORY_USE", max_count: item['stack']}));
            }
        }

        if(spec['associated_crafting_recipes']) { // upgradable item
            for(var i = 0; i < spec['associated_crafting_recipes'].length; i++) {
                var rec_name = spec['associated_crafting_recipes'][i];
                var rec_spec = gamedata['crafting']['recipes'][rec_name];
                var rec_level = ('max_level' in rec_spec ? (item['level'] || 1) + 1 : 1); // assume recipe level is item level + 1, if recipe is leveled
                if('max_level' in rec_spec && rec_level > rec_spec['max_level']) { continue; }
                if('show_if' in rec_spec && !read_predicate(get_leveled_quantity(rec_spec['show_if'], rec_level)).is_satisfied(player, null)) { continue; }
                dialog.user_data['buttons'].push(new InventoryContextButton({ui_name:gamedata['crafting']['categories'][rec_spec['crafting_category']]['ui_verb'],
                                                                             ui_name_pending:gamedata['strings']['inventory']['pending'],
                                                                             state:'active',
                                                                             spellname:"CRAFT_FOR_FREE",
                                                                             associated_recipe_name:rec_name,
                                                                             associated_recipe_level:rec_level}));
                break;
            }
        }

        // show refund button when a refund exists and show_refundable_when is true
        if(ItemDisplay.inventory_item_is_refundable(item)) {
            if(!(item['stack'] && item['stack'] >= 500)) {
                // show single-refund option unless it's a huge stack
                dialog.user_data['buttons'].push(new InventoryContextButton({ui_name:gamedata['strings']['inventory']['refund_button'],
                                                                             ui_name_pending:gamedata['strings']['inventory']['refund_button_pending'],
                                                                             spellname:"INVENTORY_REFUND"}));
            }
            if(item['stack'] && item['stack'] > 1) { // stack >=1
                dialog.user_data['buttons'].push(new InventoryContextButton({ui_name:gamedata['strings']['inventory']['refund_all_button'],
                                                                             ui_name_pending:gamedata['strings']['inventory']['refund_all_button_pending'],
                                                                             spellname:"INVENTORY_REFUND_ALL"}));
            }
        }

        if(!(item['stack'] && item['stack'] >= 500)) {
            // show single-discard option unless it's a huge stack
            dialog.user_data['buttons'].push(new InventoryContextButton({ui_name:gamedata['strings']['inventory']['discard_button'],
                                                                         ui_name_pending:gamedata['strings']['inventory']['discard_button_pending'],
                                                                         spellname:"INVENTORY_TRASH"}));
        }
        if(item['stack'] && item['stack'] > 1) {
            dialog.user_data['buttons'].push(new InventoryContextButton({ui_name:gamedata['strings']['inventory']['discard_all_button'],
                                                                         ui_name_pending:gamedata['strings']['inventory']['discard_all_button_pending'],
                                                                         spellname:"INVENTORY_TRASH_ALL"}));
        }
    }

    dialog.widgets['buttonbg'].wh[1] = 6 + 36 * dialog.user_data['buttons'].length;

    // figure out pop-out animation
    var anim_dir = ((parent_dialog.get_absolute_xy()[1]+dialog.user_data['base_xy'][1]+dialog.widgets['bgrect'].wh[1]+dialog.widgets['buttonbg'].wh[1]) > canvas_height ? 'right' : 'down');
    var start_pos, final_pos; // final position of dropdown's buttonbg
    if(anim_dir == 'down') {
        start_pos = [dialog.widgets['buttonbg'].xy[0], 0];
        final_pos = [dialog.widgets['buttonbg'].xy[0], dialog.widgets['bgrect'].wh[1]];
        dialog.wh[1] = (show_dropdown ? (dialog.widgets['buttonbg'].xy[1] + dialog.widgets['buttonbg'].wh[1]) : dialog.widgets['bgrect'].wh[1]);
    } else if(anim_dir == 'right') {
        start_pos = [dialog.widgets['buttonbg'].xy[0], 0];
        final_pos = [dialog.widgets['bgrect'].wh[0], 0];
        dialog.wh[0] = (show_dropdown ? (dialog.widgets['bgrect'].wh[0] + dialog.widgets['buttonbg'].wh[0]) : dialog.widgets['bgrect'].wh[0]);
    } else {
        throw Error('bad anim_dir '+anim_dir.toString());
    }
    dialog.widgets['buttonbg'].xy = final_pos;

    // anim_data has start and end XY coordinates for bgrect and each button
    dialog.user_data['anim_data'] = {'buttonbg': [start_pos, final_pos]};

    for(var i = 0; i < dialog.data['widgets']['button']['array'][1]; i++) {
        var widget = dialog.widgets['button'+i.toString()];
        // offset relative to upper-left corner of bgrect
        var offset = [(dialog.data['widgets']['button']['xy'][0]-dialog.data['widgets']['buttonbg']['xy'][0]),
                      (dialog.data['widgets']['button']['xy'][1]-dialog.data['widgets']['buttonbg']['xy'][1]) + i * dialog.data['widgets']['button']['array_offset'][1]];

        widget.xy = vec_add(final_pos, offset);
        dialog.user_data['anim_data']['button'+i.toString()] = [vec_add(start_pos, offset), vec_add(final_pos, offset)];

        if(i >= dialog.user_data['buttons'].length) {
            widget.show = 0;
        } else {
            var butt = dialog.user_data['buttons'][i];
            widget.show = 1;
            widget.str = (item['pending'] && item['pending_action'] == butt.spellname ? butt.ui_name_pending : butt.ui_name);
            widget.state = ((item['pending'] || ((butt.spellname.indexOf("INVENTORY_USE")==0)&&!can_cast)) ? 'disabled' : 'normal');
            widget.bg_image = dialog.data['widgets']['button']['bg_image_'+butt.state];
            var cb = make_button_cb(slot, item, butt);
            if(butt.spellname.indexOf("INVENTORY_USE")==0 && !can_cast) { // add tooltip
                var tooltip_str = SPUI.break_lines(can_cast_detailed[1], SPUI.desktop_font, widget.data['max_tooltip_dimensions'])[0];
                widget.tooltip.str = tooltip_str;
                widget.tooltip.text_color = SPUI.error_text_color;
                if(!can_cast_detailed[0] && can_cast_detailed[2]) {
                    var helper = get_requirements_help(can_cast_detailed[2][0], can_cast_detailed[2][1], can_cast_detailed[2][2] || null);
                    if(helper) {
                        widget.onclick = (function (_inv_dialog, _helper) { return function(w) {
                            // clear the context menu before invoking helper, since player state may change as a result of the helper
                            // before the context menu is otherwise closed.
                            invoke_inventory_context(_inv_dialog, null, -1, null, false);
                            _helper();
                            }; })(inv_dialog, helper);
                        widget.state = 'disabled_clickable';
                    }
                }
            } else if(butt.spellname.indexOf("INVENTORY_TRASH") == 0 || butt.spellname.indexOf("INVENTORY_REFUND") == 0) { // add confirmation prompt
                var want_refund = (butt.spellname.indexOf("INVENTORY_REFUND") == 0);
                var multi = (butt.spellname.indexOf("_ALL") != -1);

                if(item['undiscardable']) { // really for tutorial only
                    widget.state = 'disabled';
                    widget.tooltip.str = gamedata['strings']['inventory']['undiscardable_tooltip'];
                } else if(want_refund) {
                    var pred = ('refundable_when' in spec) ? read_predicate(spec['refundable_when']) : null;
                    if(pred && !pred.is_satisfied(player, null)) {
                        widget.state = 'disabled';
                        widget.tooltip.str = gamedata['strings']['inventory']['unrefundable_tooltip'].replace('%s', pred.ui_describe(player));
                    }
                }

                widget.onclick = (function (_cb, _item, _i, _want_refund, _multi) { return function (w) {
                    var butt = w.parent.user_data['buttons'][_i];
                    var s;
                    if(_want_refund) {
                        s = gamedata['strings']['inventory_confirm_refund'];
                    } else {
                        s = gamedata['strings']['inventory_confirm_discard_'+(_multi ? 'all':'one')];
                    }
                    var spec = ItemDisplay.get_inventory_item_spec(_item['spec']);
                    var ui_name = ItemDisplay.get_inventory_item_ui_name(spec);
                    var descr = s['ui_description'].replace('%s', ui_name).replace('%d', ((_multi && 'stack' in _item) ? ItemDisplay.get_inventory_item_stack_prefix(spec, _item['stack']) : ''));
                    var refund_str = null;
                    if(_want_refund) {
                        refund_str = ItemDisplay.get_inventory_item_refund_str(_item, (_multi && 'stack' in _item) ? _item['stack'] : 1);
                        descr = descr.replace('%refund', refund_str);
                    }
                    invoke_child_message_dialog(s['ui_title'].replace('%s', ui_name), descr,
                                                {'cancel_button': true,
                                                 'ok_button_ui_name': s['ui_button'],
                                                 'on_ok': (function (__cb, _w, __item, __multi, _refund_str) { return function() {
                                                     // extra layer of confirmation for precious items
                                                     confirm_item_delete([__item], (function (___cb, __w) { return function() {
                                                         ___cb(__w);
                                                     }; })(__cb, _w), __multi, _refund_str);
                                                 }; })(_cb, w, _item, _multi, refund_str)});
                }; })(cb, item, i, want_refund, multi);
            } else {
                widget.onclick = cb;
            }
        }
    }

    dialog.ondraw = update_inventory_context;

    inv_dialog.user_data['context'] = dialog;
    parent_dialog.add(dialog);
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_inventory_context(dialog) {
    var props = dialog.user_data['props'];
    var parent_dialog = dialog.user_data['parent_dialog'];

    if(props && ('parent_offset' in props)) {
        dialog.xy = vec_add(dialog.user_data['base_xy'], props['parent_offset']);
    }

    // don't let it get cut off the left edge of the screen
    if(parent_dialog.xy[0]+dialog.xy[0] < 0) {
        dialog.xy[0] = -parent_dialog.xy[0];
    }

    var anim_progress = Math.min((client_time - dialog.user_data['anim_start'])/0.2, 1);
    for(var name in dialog.widgets) {
        if(name in dialog.user_data['anim_data']) {
            dialog.widgets[name].show = dialog.user_data['show_dropdown'] && (dialog.user_data['buttons'].length > 0);
            var start = dialog.user_data['anim_data'][name][0], end = dialog.user_data['anim_data'][name][1];
            dialog.widgets[name].xy = vec_floor(vec_add(start, vec_scale(anim_progress, vec_sub(end,start))));
        }
    }
    if('expire_time' in dialog.user_data) {
        var kind = ('aura' in dialog.user_data ? 'aura' : 'item');
        var template = dialog.widgets['expires'].data['ui_name_'+kind];
        if(kind === 'aura') {
            // optional override for the wording of the expiration message
            var aura_spec = gamedata['auras'][dialog.user_data['aura']['spec']];
            if('ui_expires' in aura_spec) {
                template = aura_spec['ui_expires'];
            }
        }
        dialog.widgets['expires'].str = template.replace('%s', pretty_print_time(dialog.user_data['expire_time']-server_time));
    } else if('melt_duration' in dialog.user_data) {
        dialog.widgets['expires'].str = dialog.widgets['expires'].data['ui_name_melt_duration'].replace('%s', pretty_print_time(dialog.user_data['melt_duration']));
    }
}

/** @typedef {{trigger_gcd: (boolean|undefined),
               max_count: (number|undefined)}} */
var InventoryActionOptions;

/** @param {!Object} item
    @param {number|!Object} slot
    @param {string} action
    @param {InventoryActionOptions=} options */
function inventory_action(item, slot, action, options) {
    if(('pending' in item) || player.cooldown_active('GCD')) { return false; }

    if(action == "INVENTORY_USE") {
        // see if we need to do a targeted activation
        var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
        if('use' in spec) {
            var uselist = get_as_array(spec['use']);
            for(var m = 0; m < uselist.length; m++) {
                var use = uselist[m];
                if('spellname' in use) {
                    var spellname = use['spellname'];
                    var spellarg = use['spellarg'] || null;
                    var spell = gamedata['spells'][spellname];
                    if(spellname === "SHOW_STORE") {
                        change_selection_ui(null);
                        invoke_store();
                        return true;
                    } else if(spellname === "CLIENT_CONSEQUENT") {
                        read_consequent(spellarg).execute();
                        return true;
                    } else if(spellname.indexOf("CHANGE_REGION_INSTANTLY") == 0) {
                        invoke_change_region_dialog((function (_item, _slot, _action, _options) { return function(spellarg) {
                            inventory_send_request(_item, _slot, _action, spellarg, _options);
                            return true;
                        }; })(item, slot, action, options), spellname);
                        return true;
                    } else if(spellname === "CHANGE_ALIAS") {
                        invoke_change_alias_dialog((function (_item, _slot, _action, _options) { return function(spellarg) {
                            inventory_send_request(_item, _slot, _action, spellarg, _options);
                            return true;
                        }; })(item, slot, action, options), spellname);
                        return true;
                    } else if(spellname === "APPLY_AURA") {
                        var aura_name = spellarg[1];
                        var overlap = null;
                        for(var i = 0; i < player.player_auras.length; i++) {
                            if(player.player_auras[i]['spec'] == aura_name) {
                                overlap = aura_name;
                                break;
                            }
                        }
                        if(overlap) {
                            // warn player that this will overwrite instead of stacking on top of the current aura
                            var do_it = (function (_item, _slot, _action, _options) { return function(spellarg) {
                                inventory_send_request(_item, _slot, _action, spellarg, _options);
                                return true;
                            }; })(item, slot, action, options);
                            var msg = gamedata['strings']['player_aura_confirm_overwrite'];
                            invoke_child_message_dialog(msg['ui_title'],
                                                        msg['ui_description'].replace('%item', spec['ui_name']).replace('%existing', gamedata['auras'][aura_name]['ui_name']),
                                                        {'cancel_button':true,
                                                         'ok_button_ui_name': msg['ui_button'],
                                                         'dialog': 'message_dialog_big',
                                                         'on_ok': do_it});
                            return false;
                        } else {
                            continue; // no problem
                        }
                    } else if(spell['activation'] == 'instant') {
                        // fall through; this just sends it with no further UI
                        continue;
                    } else if(spell['activation'] == 'targeted_build') {
                        change_selection(null);
                        selection.spellname = "BUILD";
                        selection.spellkind = spellarg;
                        selection.slot = slot;
                        selection.item = item;
                        change_selection_ui_under(new BuildUICursor(null, gamedata['buildings'][spellarg]));
                        return true;
                    } else if(spell['activation'] == 'targeted_area') {
                        change_selection(null);
                        selection.spellname = spellname;
                        selection.spellkind = null;
                        selection.slot = slot;
                        selection.item = item;
                        var splash = gamedata['map']['splash_range_conversion'] * get_leveled_quantity(spell['splash_range'] || 0, 1);
                        change_selection_ui_under(new AOEUICursor(null, -1, splash));
                        return true;
                    } else if(spell['activation'] == 'targeted_alliance_mate') {
                        invoke_alliance_mate_gift_dialog(ItemDisplay.get_inventory_item_ui_name(spec),
                                                         (function (_item, _slot, _action, _options) { return function(recipient_id) {
                                                             inventory_send_request(_item, _slot, _action, [recipient_id], _options);
                                                             return true;
                                                         }; })(item, slot, action, options));
                        return false;
                    } else if(spell['activation'] == 'targeted_friend') {
                        invoke_friend_gift_dialog((function (_item, _slot, _action, _options) { return function(recipient_id) {
                            inventory_send_request(_item, _slot, _action, [recipient_id], _options);
                            return true;
                        }; })(item, slot, action, options),
                                                  spec['pre_use'] || spell['pre_activation'] || null);
                        return false;
                    } else {
                        throw Error('unhandled inventory item spell activation type '+spell['activation'].toString()+' for '+spec['name']);
                    }
                }
            }
        }
    }
    inventory_send_request(item, slot, action, null, options);
    return true;
}

/** @param {!Object} item
    @param {number|!Object} slot
    @param {string} action
    @param {?} spellargs
    @param {InventoryActionOptions=} options */
function inventory_send_request(item, slot, action, spellargs, options) {
    item['pending'] = 1;
    item['pending_time'] = client_time;
    item['pending_action'] = action;
    if(options && options.trigger_gcd) { player.cooldown_client_trigger('GCD', gamedata['client']['global_cooldown']); }
    if(!spellargs) { spellargs = null; }

    var msg;
    if(action == 'INVENTORY_USE') {
        msg = [action, slot, item, (options ? (options.max_count||1) : 1), spellargs];
    } else {
        msg = [action, slot, item['spec'], spellargs];
    }
    send_to_server.func(msg);

    if(action == 'INVENTORY_USE' && typeof(slot) == 'object') {
        // for equip items, remove from home_equip_items here
        // note, if the USE fails, then we'll be missing the item!
        goog.array.remove(session.home_equip_items, slot);
    }
}

/** @param {string} item_ui_name
    @param {function(number)} callback */
function invoke_alliance_mate_gift_dialog(item_ui_name, callback) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['alliance_mate_gift_dialog']);
    dialog.user_data['dialog'] = 'alliance_mate_gift_dialog';
    dialog.user_data['item_ui_name'] = item_ui_name;
    dialog.user_data['callback'] = callback;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['portrait']['array'][1];
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    // list of pcache data for alliancemates
    dialog.user_data['rowdata'] = [];
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    AllianceCache.query_members(session.alliance_id, false, null, (function (_dialog) { return function(info) {
        invoke_alliance_mate_gift_dialog_members(_dialog, info);
    }; })(dialog));
    invoke_ui_locker();
    return dialog;
}

function invoke_alliance_mate_gift_dialog_members(dialog, info) {
    goog.array.forEach(['scroll_left','scroll_right','scroll_text'], function(wname) {
        dialog.widgets[wname].show = true;
    });

    if(info && info['members']) {
        goog.array.forEach(info['members'], function(member_info) {
            var member_id = member_info['user_id'];
            if(member_id == session.user_id) { return; }
            var player_info = PlayerCache.query_sync(member_id);
            if(player_info && player_info['player_level']) {
                dialog.user_data['rowdata'].push(player_info);
            }
        });
    }

    if(dialog.user_data['rowdata'].length < 1) {
        // no friends - skip!
        dialog.widgets['close_button'].onclick(dialog.widgets['close_button']);
        var s = gamedata['strings']['requirements_help']['alliance']['need_mates'];
        invoke_child_message_dialog(s['ui_title'], s['ui_description'], {'dialog':'message_dialog_big'});
        return;
    }

    // sort alphabetically
    dialog.user_data['rowdata'].sort(function (a,b) {
        var na = PlayerCache.get_ui_name(a);
        var nb = PlayerCache.get_ui_name(b);
        if(na < nb) {
            return -1;
        } else if(na > nb) {
            return 1;
        } else {
            return 0;
        }
    });
    dialog.user_data['rowfunc'] = alliance_mate_gift_dialog_setup_row;
    scrollable_dialog_change_page(dialog, 0);
    return dialog;
}

function alliance_mate_gift_dialog_setup_row(dialog, row, rowdata) {
    dialog.widgets['separator'+(row+1)].show =
        dialog.widgets['portrait'+row].show =
        dialog.widgets['name'+row].show =
        dialog.widgets['button'+row].show = (rowdata !== null);

    if(rowdata !== null) {
        var info = rowdata;
        dialog.widgets['portrait'+row].set_user(info['user_id']);
        dialog.widgets['name'+row].str = dialog.data['widgets']['name']['ui_name'].replace('%s', PlayerCache.get_ui_name(info) + ' (L'+(info['player_level']||1).toString()+')');

        dialog.widgets['button'+row].onclick = (function (_id) { return function(w) {
            var _cb = w.parent.user_data['callback'];
            var ui_name = w.parent.user_data['item_ui_name'];
            if(_id <= 0) { close_parent_dialog(w); return; }

            var info = PlayerCache.query_sync(_id);

            // if we're going through a Facebook request, wrap the cb inside a request prompt
            var wrapped_cb;
            if('send_alliance_gift' in gamedata['virals'] && spin_frame_platform == 'fb' && spin_facebook_enabled &&
               info && info['facebook_id'] &&
               ((goog.array.find(player.friends, function(f) { return f.user_id == _id; }) !== null) ||
                (!info['uninstalled'] && ('last_login_time' in info) && info['last_login_time'] >= server_time - 5*86400 &&
                 !(_id.toString() in FBSendRequests.user_id_blacklist)))) {
                FBSendRequests.invoke_send_single_dialog('send_alliance_gift', ui_name, _id, info['facebook_id'],
                                                         (function (__cb, __id, _w) { return function() {
                                                             close_parent_dialog(_w);
                                                             __cb(__id);
                                                             invoke_ui_locker();
                                                         }; })(_cb, _id, w));

            } else {
                close_parent_dialog(w);
                _cb(_id);
                invoke_ui_locker();
            }

        }; })(rowdata['user_id']);
    }
}

// this is for giving in-game items via FRIEND_GIFT_LOOT spells. NOT for social-network gifting.
function invoke_friend_gift_dialog(callback, pre_use_consequent) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['alliance_mate_gift_dialog']);
    dialog.user_data['dialog'] = 'alliance_mate_gift_dialog';
    dialog.user_data['callback'] = callback;
    dialog.user_data['pre_use_consequent'] = pre_use_consequent;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['portrait']['array'][1];
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    // list of pcache data for friends
    dialog.user_data['rowdata'] = [];
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;
    goog.array.forEach(player.friends, function(friend) {
        if(friend.is_real_friend) {
            dialog.user_data['rowdata'].push(PlayerCache.query_sync(friend.user_id));
        }
    });
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

//    AllianceCache.query_members(session.alliance_id, false, null, (function (_dialog) { return function(info) {
    invoke_friend_gift_dialog_members(dialog, null);
//    }; })(dialog));
//    invoke_ui_locker();
    return dialog;
}

function invoke_friend_gift_dialog_members(dialog, info) {
    goog.array.forEach(['scroll_left','scroll_right','scroll_text'], function(wname) {
        dialog.widgets[wname].show = true;
    });

    if(dialog.user_data['pre_use_consequent']) {
        read_consequent(dialog.user_data['pre_use_consequent']).execute({'num_friends': dialog.user_data['rowdata'].length});
    }

    if(dialog.user_data['rowdata'].length < 1) {
        // no friends - skip!
        dialog.widgets['close_button'].onclick(dialog.widgets['close_button']);
        var helper = get_requirements_help('friends', 'invite_for_gift');
        if(helper) { helper(); }
        return;
    }

    // sort alphabetically
    dialog.user_data['rowdata'].sort(function (a,b) {
        var na = PlayerCache.get_ui_name(a);
        var nb = PlayerCache.get_ui_name(b);
        if(na < nb) {
            return -1;
        } else if(na > nb) {
            return 1;
        } else {
            return 0;
        }
    });
    dialog.user_data['rowfunc'] = friend_gift_dialog_setup_row;
    scrollable_dialog_change_page(dialog, 0);
    return dialog;
}

function friend_gift_dialog_setup_row(dialog, row, rowdata) {
    dialog.widgets['separator'+(row+1)].show =
        dialog.widgets['portrait'+row].show =
        dialog.widgets['name'+row].show =
        dialog.widgets['button'+row].show = (rowdata !== null);

    if(rowdata !== null) {
        var info = rowdata;
        dialog.widgets['portrait'+row].set_user(info['user_id']);
        dialog.widgets['name'+row].str = dialog.data['widgets']['name']['ui_name'].replace('%s', PlayerCache.get_ui_name(info) + ' (L'+(info['player_level']||1).toString()+')');

        dialog.widgets['button'+row].onclick = (function (_id) { return function(w) {
            var _cb = w.parent.user_data['callback'];
            close_parent_dialog(w);
            if(_id > 0) {
                _cb(_id);
                invoke_ui_locker();
            }
        }; })(rowdata['user_id']);
    }
}

function invoke_equip_chooser_dialog(inv_dialog, parent_widget, tech, unit, slot_type, slot_n, ui_slot) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['equip_chooser_dialog']);
    dialog.user_data['dialog'] = 'equip_chooser_dialog';
    dialog.xy = [parent_widget.xy[0] + parent_widget.wh[0] + 10, parent_widget.xy[1] + parent_widget.wh[1] - dialog.wh[1]]; // - 60];
    dialog.user_data['context'] = null;
    dialog.user_data['scroll_by_row'] = true;
    dialog.user_data['tech'] = tech;
    dialog.user_data['unit'] = unit;
    dialog.user_data['slot_type'] = slot_type;
    dialog.user_data['slot_n'] = slot_n;
    dialog.user_data['ui_slot'] = ui_slot;
    dialog.modal = 0.5;
    dialog.widgets['bg_close_button'].onclick =
        dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['equip_frame']['array'][0];
    dialog.user_data['rowdata'] = [];
    dialog.user_data['scroll_by_row'] = true;
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;
    var equip = null, host_spec = null;
    if(tech && ('associated_unit' in tech)) {
        // unit equipment
        host_spec = gamedata['units'][tech['associated_unit']];
        equip = player.unit_equipment[tech['associated_unit']] || {};
    } else if(!tech && unit) {
        // building equipment
        host_spec = unit.spec;
        equip = unit.equipment;
    }
    dialog.user_data['host_spec'] = host_spec;
    dialog.user_data['equip'] = equip;
    // see what is equipped already, if anything
    var equipped_now = null;
    var equipped_now_specname = null, equipped_now_level = 1;
    if(equip && (slot_type in equip) && (slot_n < equip[dialog.user_data['slot_type']].length) && equip[dialog.user_data['slot_type']][dialog.user_data['slot_n']]) {
        equipped_now = player.decode_equipped_item(equip[slot_type][dialog.user_data['slot_n']]);
        equipped_now_specname = equipped_now['spec'];
        equipped_now_level = equipped_now['level'] || 1;
    }
    dialog.user_data['equipped_now'] = equipped_now;
    dialog.user_data['equipped_now_specname'] = equipped_now_specname;
    dialog.user_data['equipped_now_level'] = equipped_now_level;
    var seen_specs = {};
    for(var i = 0; i < player.inventory.length; i++) {
        var item = player.inventory[i];
        if(item['spec'] == equipped_now_specname && ((item['level']||1) == equipped_now_level)) { continue; } // don't list items the same type as what is already equipped
        var seen_key = item['spec']+':L'+(item['level']||1).toString();
        if(seen_key in seen_specs) { continue; } // don't list duplicates
        seen_specs[seen_key] = 1;
        var espec = ItemDisplay.get_inventory_item_spec(item['spec']);
        if('equip' in espec) {
            var can_equip_at_any_level, can_equip_now;
            var min_level = -1; // only >0 if we don't meet the requirement right now
            if(tech) {
                var crit = equip_is_compatible_with_unit(tech['name'], tech['associated_unit'], slot_type, espec, item, true);
                can_equip_at_any_level = !!crit;
                can_equip_now = can_equip_at_any_level && !!equip_is_compatible_with_unit(tech['name'], tech['associated_unit'], slot_type, espec, item, false);
                if(can_equip_at_any_level && !can_equip_now && crit['min_level']) { min_level = crit['min_level']; }
            } else {
                var crit = equip_is_compatible_with_building(unit, slot_type, espec, item, true);
                can_equip_at_any_level = !!crit;
                can_equip_now = can_equip_at_any_level && !!equip_is_compatible_with_building(unit, slot_type, espec, item, false);
                if(can_equip_at_any_level && !can_equip_now && crit['min_level']) { min_level = crit['min_level']; }
            }
            if(!can_equip_at_any_level) { continue; }

            // note: still show items that don't fit the level or uniqueness requirement
            var unique_conflict = '';
            if('unique_equipped' in espec) {
                var func = function(other_item) {
                    var other_name = other_item['spec'];
                    var other_spec = ItemDisplay.get_inventory_item_spec(other_name);
                    if(other_spec && other_spec['unique_equipped']==espec['unique_equipped'] &&
                       ((!equipped_now_specname) || (gamedata['items'][equipped_now_specname]||{})['unique_equipped'] != other_spec['unique_equipped'])) {
                        unique_conflict = other_name;
                        return true;
                    }
                }
                player.equipped_item_iter(func);
            }

            var failed_pred = null;
            if('requires' in espec['equip']) {
                var pred = read_predicate(espec['equip']['requires']);
                if(!pred.is_satisfied(player, null)) {
                    failed_pred = pred;
                }
            }
            dialog.user_data['rowdata'].push({'inv_slot': i, 'item':item, 'min_level': min_level, 'unique_conflict':unique_conflict, 'failed_pred':failed_pred});
        }
    }

    // if no applicable equipment is available, give a help dialog
    if(dialog.user_data['rowdata'] < 1 && !equipped_now_specname) {
        invoke_ingame_tip('no_equipment_tip', {frequency: GameTipFrequency.ALWAYS});
        return false;
    }

    // sort items by level, then rarity
    dialog.user_data['rowdata'].sort(function(a, b) {
        var aspec = ItemDisplay.get_inventory_item_spec(a['item']['spec']), bspec = ItemDisplay.get_inventory_item_spec(b['item']['spec']);
        var al = aspec['level'] || 1, bl = bspec['level'] || 1;
        var ar = aspec['rarity'] || 0, br = bspec['rarity'] || 0;
        if(al > bl) {
            return -1;
        } else if(al < bl) {
            return 1;
        } else if(ar > br) {
            return -1;
        } else if(ar < br) {
            return 1;
        } else if(aspec['name'] > bspec['name']) {
            return 1;
        } else if(aspec['name'] < bspec['name']) {
            return -1;
        } else {
            return 0;
        }
    });
    // handlers for the "equip nothing" button
    dialog.widgets['equip_nothing_frame'].state = 'normal';
    dialog.widgets['equip_nothing_frame'].tooltip.str = null;
    if(equipped_now_specname) {
        var spec = ItemDisplay.get_inventory_item_spec(equipped_now_specname);
        if(!spec || !('equip' in spec)) {
            throw Error('Item ' + equipped_now_specname + ' missing spec value or equip field.');
        }
        // check predicate
        var pred = ('unequip_requires' in spec['equip'] ? read_predicate(spec['equip']['unequip_requires']) : null);
        if(pred && !pred.is_satisfied(player, null)) {
            dialog.widgets['equip_nothing_frame'].state = 'disabled_clickable';
            var help_func = get_requirements_help(pred);
            if(help_func) {
                dialog.widgets['equip_nothing_frame'].onclick = (function (_help_func) { return function(w) {
                    // need to close equip chooser because the game state might change in a way that re-enables this,
                    // and we are not updating after invoke()
                    close_parent_dialog(w);
                    _help_func();
                }; })(help_func);
            } else {
                dialog.widgets['equip_nothing_frame'].onclick = null;
            }
            dialog.widgets['equip_nothing_frame'].tooltip.str = dialog.data['widgets']['equip_nothing_frame']['ui_tooltip_unmet'].replace('%s', pred.ui_describe(player));
        } else {
            // check for full warehouse
            var full = (player.inventory.length >= player.max_usable_inventory());
            dialog.widgets['equip_nothing_frame'].tooltip.str = dialog.data['widgets']['equip_nothing_frame']['ui_tooltip_'+(full?'full':'remove')].replace('%s', ItemDisplay.get_inventory_item_ui_name(spec));
            if(full) {
                dialog.widgets['equip_nothing_frame'].state = 'disabled';
            } else {
                // clicking on the "nothing" item removes whatever was equipped
                dialog.widgets['equip_nothing_frame'].onclick = (function (_equipped_now, _tech, _unit, _slot_type, _slot_n, _ui_slot) { return function(w) {
                    if(_tech) {
                        // unit equipment
                        if(!(_tech['associated_unit'] in player.unit_equipment)) { player.unit_equipment[tech['associated_unit']] = {}; }
                        player.unit_equipment[tech['associated_unit']]['equip_pending'] = 1;
                        send_to_server.func(["EQUIP_UNIT", tech['associated_unit'], [_slot_type, _slot_n], -1, null, _equipped_now, _ui_slot]);
                    } else {
                        _unit.equip_pending = true;
                        send_to_server.func(["EQUIP_BUILDING", _unit.id, [_slot_type, _slot_n], -1, null, _equipped_now, _ui_slot]);
                    }
                    close_parent_dialog(w);
                }; })(equipped_now, tech, unit, slot_type, slot_n, ui_slot);
            }
        }
    } else {
        dialog.widgets['equip_nothing_frame'].onclick = close_parent_dialog;
    }
    dialog.user_data['rowfunc'] = equip_chooser_dialog_setup_row;
    if(!refresh_equip_chooser_dialog(dialog)) { // didn't open
        return null;
    }
    dialog.ondraw = refresh_equip_chooser_dialog;
    inv_dialog.add(dialog);
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function refresh_equip_chooser_dialog(dialog) {
    var rows_per_page = dialog.user_data['rows_per_page'];
    var total_rows = dialog.user_data['rowdata'].length;
    if(total_rows <= rows_per_page) {
        dialog.widgets['scroll_left'].show = false;
        dialog.widgets['scroll_right'].show = false;
    }
    scrollable_dialog_change_page(dialog, (dialog.user_data['page'] >= 0 ? dialog.user_data['page'] : 0));
    return dialog;
}

/** @param {SPUI.Dialog} dialog
    @param {number} row
    @param {Object} rowdata */
function equip_chooser_dialog_setup_row(dialog, row, rowdata) {
    var equipped_now = dialog.user_data['equipped_now'];
    var equipped_now_specname = dialog.user_data['equipped_now_specname'];
    var equipped_now_level = dialog.user_data['equipped_now_level'];
    var host_spec = dialog.user_data['host_spec'];
    var equip = dialog.user_data['equip'];
    var unit = dialog.user_data['unit'];
    var tech = dialog.user_data['tech'];
    var slot_type = dialog.user_data['slot_type'];
    var slot_n = dialog.user_data['slot_n'];
    var ui_slot = dialog.user_data['ui_slot'];
    dialog.widgets['equip_frame'+row.toString()].show =
        dialog.widgets['equip_stack'+row.toString()].show =
        dialog.widgets['equip_item'+row.toString()].show = (rowdata !== null);
    if(rowdata !== null) {
        dialog.widgets['equip_frame'+row.toString()].state = 'normal';
        dialog.widgets['equip_frame'+row.toString()].tooltip.str = null;
        var inv_slot = rowdata['inv_slot'], item = rowdata['item'], min_level = rowdata['min_level'], unique_conflict = rowdata['unique_conflict'], failed_pred = rowdata['failed_pred'];
        var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
        ItemDisplay.set_inventory_item_asset(dialog.widgets['equip_item'+row], spec);
        ItemDisplay.set_inventory_item_stack(dialog.widgets['equip_stack'+row], spec, item);
        var context_props = {};
        if(min_level > 0) {
            // show red text saying that player needs to upgrade the building
            dialog.widgets['equip_frame'+row.toString()].state = 'disabled_clickable';
            context_props['error_text'] = gamedata['errors'][(tech ? 'EQUIP_TECH_LEVEL_TOO_LOW' : 'EQUIP_BUILDING_LEVEL_TOO_LOW')]['ui_name'].replace('%s', min_level.toString());
            var helper = get_requirements_help(read_predicate(tech ? {'predicate': 'TECH_LEVEL', 'tech': tech['name'], 'min_level': min_level} :
                                                {'predicate': 'BUILDING_LEVEL', 'building_type': unit.spec['name'], 'trigger_level': min_level}), null);
            dialog.widgets['equip_frame'+row.toString()].onclick = (function (_helper) { return function(w) {
                if(helper) {
                    w.parent.widgets['close_button'].onclick(w.parent.widgets['close_button']);
                    helper();
                }
            }; })(helper);
        } else if(unique_conflict !== '') {
            dialog.widgets['equip_frame'+row.toString()].state = 'disabled';
            dialog.widgets['equip_frame'+row.toString()].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['equip_frame'+row.toString()].tooltip.str = gamedata['errors']['EQUIP_INVALID_UNIQUE']['ui_name'].replace('%s', ItemDisplay.get_inventory_item_spec(unique_conflict)['ui_name']);
        } else if(failed_pred) {
            dialog.widgets['equip_frame'+row.toString()].state = 'disabled_clickable';
            dialog.widgets['equip_frame'+row.toString()].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['equip_frame'+row.toString()].tooltip.str = failed_pred.ui_describe(player);
            var help_func = get_requirements_help(failed_pred);
            if(help_func) {
                dialog.widgets['equip_frame'+row.toString()].onclick = (function (_help_func) { return function(w) {
                    // need to close equip chooser because the game state might change in a way that re-enables this,
                    // and we are not updating after invoke()
                    close_parent_dialog(w);
                    _help_func();
                }; })(help_func);
            } else {
                dialog.widgets['equip_frame'+row.toString()].onclick = null;
            }
        } else {
            dialog.widgets['equip_frame'+row.toString()].onclick = (function (_inv_slot, _item, _tech, _unit, _slot_type, _slot_n, _ui_slot, _equipped_now) { return function(w) {
                if(_tech) {
                    // unit equipment
                    if(!(_tech['associated_unit'] in player.unit_equipment)) { player.unit_equipment[tech['associated_unit']] = {}; }
                    player.unit_equipment[tech['associated_unit']]['equip_pending'] = 1;
                    send_to_server.func(["EQUIP_UNIT", tech['associated_unit'], [_slot_type, _slot_n], _inv_slot, _item, _equipped_now, _ui_slot]);
                } else {
                    _unit.equip_pending = true;
                    send_to_server.func(["EQUIP_BUILDING", _unit.id, [_slot_type, _slot_n], _inv_slot, _item, _equipped_now, _ui_slot]);
                }

                close_parent_dialog(w);
            }; })(inv_slot, item, tech, unit, slot_type, slot_n, ui_slot, equipped_now);
        }

        if(unique_conflict === '' && !failed_pred) {
            dialog.widgets['equip_frame'+row.toString()].onenter = (function (_inv_slot, _item, _context_props) { return function(w) {
                var dialog = w.parent;
                if(dialog.user_data['context'] &&
                   dialog.user_data['context'].user_data['slot'] === _inv_slot) { return; }
                _context_props['position'] = 'top_or_bottom';
                invoke_inventory_context(w.parent, w, _inv_slot, _item, false, _context_props);
            }; })(inv_slot, item, context_props);

            dialog.widgets['equip_frame'+row.toString()].onleave_cb = (function (_inv_slot, _item) { return function(w) {
                if(dialog.user_data['context'] &&
                   dialog.user_data['context'].user_data['slot'] === _inv_slot) {
                    invoke_inventory_context(w.parent, w, -1, null, false);
                }
            }; })(inv_slot, item);
        }
    }
}

function invoke_aura_context(inv_dialog, slot_xy, slot, aura, show_dropdown) {
    if(inv_dialog.user_data['aura_context']) {
        var dialog = inv_dialog.user_data['aura_context'];
        if(dialog.user_data['slot'] === slot && dialog.user_data['aura'] === aura &&
           dialog.user_data['show_dropdown'] === show_dropdown) {
            return;
        }
        inv_dialog.remove(dialog);
        inv_dialog.user_data['aura_context'] = null;
    }
    if(slot < 0) { return null; }

    var spec = gamedata['auras'][aura['spec']];
    var level = ('level' in aura ? aura['level'] : 1);
    var dialog = new SPUI.Dialog(gamedata['dialogs']['inventory_context']);
    var cols = inv_dialog.data['widgets']['aura_frame']['array'][0];
    var x = (slot % cols), y = Math.floor(slot / cols);
    dialog.user_data['parent_dialog'] = inv_dialog;
    dialog.user_data['props'] = null;
    dialog.user_data['slot'] = slot;
    dialog.user_data['aura'] = aura;
    if(('end_time' in aura) && (aura['end_time'] > 0)) { dialog.user_data['expire_time'] = aura['end_time']; }
    dialog.user_data['show_dropdown'] = show_dropdown;
    var slot_wh = [50,50]; // hard-coded icon size

    dialog.xy = [Math.floor(slot_xy[0]+slot_wh[0]/2 - dialog.wh[0]/2),
                 Math.floor(slot_xy[1]+slot_wh[1]+0)]; // note: no gap, so mouseover does not kill the popup

    // don't let it get cut off the left edge of the screen
    if(inv_dialog.xy[0]+dialog.xy[0] < 0) {
        dialog.xy[0] = -inv_dialog.xy[0];
    }
    dialog.user_data['base_xy'] = dialog.xy;

    /////////////////////////////

    // TITLE
    var ui_name = spec['ui_name'];
    if(ui_name.indexOf('%level') >= 0) {
        ui_name = ui_name.replace('%level', pretty_print_number(level));
    }
    dialog.widgets['title'].str = ui_name;
    dialog.widgets['title'].text_color = ('name_color' in spec ? SPUI.make_colorv(spec['name_color']) : SPUI.default_text_color);

    // DESCRIPTION
    var descr = spec['ui_description' + (('stack' in aura) && (aura['stack'] > 1) && ('ui_description_plural' in spec) ? '_plural' : '')];
    var strength = ('strength' in aura ? aura['strength'] : 1);
    while(descr.indexOf('%abspct') >= 0) {
        descr = descr.replace('%abspct', ((1.0+strength)*100.0).toFixed(0));
    }
    while(descr.indexOf('%pct') >= 0) {
        var ui_pct;
        if(strength < 0.10) { // 10% or less
            ui_pct = ((strength)*100.0).toFixed(2);
        } else {
            ui_pct = ((strength)*100.0).toFixed(0);
        }
        descr = descr.replace('%pct', ui_pct);
    }
    while(descr.indexOf('%oneminuspct') >= 0) {
        descr = descr.replace('%oneminuspct', ((1.0-strength)*100.0).toFixed(0));
    }
    while(descr.indexOf('%price') != -1) {
        descr = descr.replace('%price', Store.display_user_currency_amount(Store.convert_credit_price_to_user_currency(strength), 'full'));
    }
    while(descr.indexOf('%secteam') != -1) {
        var unit_dic = strength[0]['units'];
        var ls = [];
        goog.object.forEach(unit_dic, function(qty, specname) {
            ls.push(qty.toString()+'x '+gamedata['units'][specname]['ui_name']);
        });
        descr = descr.replace("%secteam", ls.join(', '));
    }
    while(descr.indexOf('%stack') != -1) {
        descr = descr.replace('%stack', pretty_print_number(('stack' in aura ? aura['stack'] : 1)));
    }
    if('ui_description_extra' in aura) {
        descr += aura['ui_description_extra'];
    }
    while(descr.indexOf('%level') >= 0) {
        descr = descr.replace('%level', pretty_print_number(level));
    }
    while(descr.indexOf('%gamebucks') >= 0) {
        descr = descr.replace('%gamebucks', player.get_any_abtest_value('gamebucks_ui_name', gamedata['store']['gamebucks_ui_name']));
    }
    while(descr.indexOf('%modstats') >= 0) {
        var ui_modstat_buff_list = [], ui_modstat_nerf_list = [];
        goog.array.forEach(spec['effects'], function(eff) {
            var ui_effect = ModChain.display_modstat_effect(eff, level);
            if(ui_effect.is_different) {
                if(ui_effect.is_better) {
                    ui_modstat_buff_list.push(ui_effect.ui_effect);
                } else {
                    ui_modstat_nerf_list.push(ui_effect.ui_effect);
                }
            }
        });
        var ui_modstat_list = ui_modstat_buff_list.concat(ui_modstat_nerf_list);
        descr = descr.replace('%modstats', ui_modstat_list.join('\n'));
    }
    while(descr.indexOf('%quarries') >= 0) {
        var ui_quarries = '';
        if('data' in aura && ('ui_sources' in aura['data'])) {
            var ui_ls = goog.array.map(aura['data']['ui_sources'], function(src) {
                var ui_player = '';
                var pcache = PlayerCache.query_sync_fetch(src['base_landlord_id']);
                if(pcache) {
                    ui_player = PlayerCache.get_ui_name(pcache) + ' ';
                }
                var ui_level = '';
                if('level' in src) {
                    ui_level = ' L'+pretty_print_number(src['level']);
                }
                return ui_player + '(' + vec_print(src['base_map_loc']) + ')' + ui_level + ': ' + '+' + (100.0*src['strength']).toFixed(2) + '%';
            });
            ui_quarries += ui_ls.join('\n');
        }
        descr = descr.replace('%quarries', ui_quarries);
    }

    var effects_inhibited = (session.viewing_base && !session.viewing_base.deployment_allowed &&
                             !('cancelable' in spec && !spec['cancelable'] && spec['name'] != 'donated_units'));
    if(effects_inhibited) {
        descr += '\n\n' + dialog.widgets['description'].data['ui_name_aura_inhibited'];
    }

    //dialog.widgets['description'].set_text_with_linebreaking(descr);
    //dialog.widgets['description'].wh[1] = dialog.widgets['description'].str.split('\n').length * dialog.widgets['description'].font.leading + dialog.widgets['description'].font.size;
    dialog.widgets['description'].set_text_bbcode(descr);
    dialog.widgets['description'].update_dims(); // force immediate text layout so we can determine how much space it takes up
    dialog.widgets['bgrect'].wh[1] = dialog.widgets['title'].wh[1] + dialog.widgets['description'].wh[1];

    // EXPIRES
    if(('end_time' in aura) && (aura['end_time'] > 0)) {
        dialog.widgets['expires'].show = true;
        dialog.widgets['expires'].text_color = SPUI.make_colorv('expires_color' in spec ? spec['expires_color'] : dialog.data['widgets']['expires']['text_color']);

        dialog.widgets['expires'].xy[1] = dialog.widgets['description'].xy[1] + dialog.widgets['description'].wh[1] - dialog.widgets['description'].font.size;
        dialog.widgets['bgrect'].wh[1] += dialog.widgets['expires'].wh[1];
    }

    /////////////////////////////////////////////


    dialog.widgets['bgrect'].wh[1] += 2;

    // initialize button drop-down
    dialog.user_data['anim_start'] = (show_dropdown ? client_time : -1);

    dialog.widgets['buttonbg'].xy[1] = dialog.widgets['bgrect'].wh[1];
    // anim_data has start and end Y coordinates for bgrect and each button
    var start_pos = [dialog.widgets['buttonbg'].xy[0],0];
    var final_pos = vec_copy(dialog.widgets['buttonbg'].xy);
    dialog.user_data['anim_data'] = {'buttonbg': [start_pos, final_pos] };

    var make_button_cb = function (_slot, _aura, _parent, _butt) { return function(w) {
        if(!('pending' in _aura)) {
            _aura['pending'] = 1;
            _aura['pending_action'] = _butt[3];
            w.str = _butt[1];
            w.state = 'disabled';

            send_to_server.func([_butt[3], _aura['spec']]);
            // disable all other buttons
            for(var j = 0; j < _parent.user_data['buttons'].length; j++) {
                _parent.widgets['button'+j.toString()].state = 'disabled';
            }

        }
    }; };

    dialog.user_data['buttons'] = [];
    var removable = (('cancelable' in spec && !spec['cancelable']) ? false : true);
    if(removable) {
        dialog.user_data['buttons'].push([gamedata['strings']['auras']['remove_button'],
                                          gamedata['strings']['auras']['remove_button_pending'],
                                          1,"CANCEL_PLAYER_AURA"]);
    }

    if(spec['speedupable']) {
        dialog.user_data['buttons'].push([gamedata['strings']['auras']['speedup_button'],
                                          gamedata['strings']['auras']['speedup_button_pending'],
                                          1,"PLAYER_AURA_SPEEDUP_FOR_MONEY"]);
    }

    //if(dialog.user_data['buttons'].length < 1) { dialog.user_data['show_dropdown'] = false; }

    for(var i = 0; i < dialog.data['widgets']['button']['array'][1]; i++) {
        var widget = dialog.widgets['button'+i.toString()];
        // offset relative to upper-left corner of bgrect
        var offset = [(dialog.data['widgets']['button']['xy'][0]-dialog.data['widgets']['buttonbg']['xy'][0]),
                      (dialog.data['widgets']['button']['xy'][1]-dialog.data['widgets']['buttonbg']['xy'][1]) + i * dialog.data['widgets']['button']['array_offset'][1]];

        widget.xy = vec_add(final_pos, offset);
        dialog.user_data['anim_data']['button'+i.toString()] = [vec_add(start_pos, offset), vec_add(final_pos, offset)];

        if(i >= dialog.user_data['buttons'].length) {
            widget.show = 0;
        } else {
            var butt = dialog.user_data['buttons'][i];
            widget.show = 1;
            widget.str = (aura['pending'] && aura['pending_action'] == butt[3] ? butt[1] : butt[0]);
            widget.state = (aura['pending']  ? 'disabled' : 'normal');
            widget.bg_image = dialog.data['widgets']['button']['bg_image_'+(butt[2] ? 'active':'passive')];
            if(butt[3].indexOf("PLAYER_AURA_SPEEDUP") == 0) { // special case
                widget.onclick = (function (_aura) { return function(w) {
                    invoke_player_aura_speedup_dialog(_aura['spec']);
                }; })(aura);
                continue;
            }
            var cb = make_button_cb(slot, aura, dialog, butt);
            if(butt[3].indexOf("CANCEL_PLAYER_AURA") == 0) { // add confirmation prompt
                widget.onclick = (function (_cb, _aura, _i) { return function (w) {
                    var butt = w.parent.user_data['buttons'][_i];
                    var s = gamedata['strings']['player_aura_confirm_cancel'];
                    var spec = gamedata['auras'][_aura['spec']];
                    invoke_child_message_dialog(s['ui_title'].replace('%s', spec['ui_name']),
                                                s['ui_description'].replace('%s', spec['ui_name']),
                                                {'cancel_button': true,
                                                 'ok_button_ui_name': s['ui_button'],
                                                 'on_ok': (function (__cb, _w) { return function() { __cb(_w); }; })(_cb, w)});
                }; })(cb, aura, i);
            } else {
                widget.onclick = cb;
            }
        }
    }
    dialog.widgets['buttonbg'].wh[1] = 6 + 36 * dialog.user_data['buttons'].length;
    dialog.wh[1] = dialog.widgets['buttonbg'].xy[1] + dialog.widgets['buttonbg'].wh[1];
    dialog.ondraw = update_inventory_context; // reused

    inv_dialog.user_data['aura_context'] = dialog;
    inv_dialog.add(dialog);
    return dialog;
}

function request_unit_donation(alliance_building) {
    var spell = gamedata['spells']['REQUEST_UNIT_DONATION'];
    player.cooldown_client_trigger(spell['cooldown_name'], spell['cooldown']);
    send_to_server.func(["CAST_SPELL", alliance_building.id, 'REQUEST_UNIT_DONATION']);
    session.clear_building_idle_state_caches(); // for ALL buildings
}

function resolve_region_map_building_problem() { return resolve_building_problem(gamedata['region_map_building'], !!gamedata['territory']['region_map_available_during_transmitter_upgrade']); };
function resolve_alliance_building_problem() { return resolve_building_problem(gamedata['alliance_building'], false); };
function resolve_building_problem(specname, allow_upgrading) {
    var building = find_object_by_type(specname);
    if(!building) {
        var helper = get_requirements_help(read_predicate({'predicate': 'BUILDING_LEVEL', 'building_type': specname, 'trigger_level':1}), null);
        if(helper) { helper(); }
        return true;
    } else if(building.is_damaged() || (!allow_upgrading && (building.is_upgrading() || building.is_under_construction() || building.is_enhancing() || building.is_removing()))) {
        change_selection_unit(building);
        if(building.is_damaged() && !building.is_repairing()) {
            invoke_repair_dialog();
        } else {
            invoke_speedup_dialog('speedup');
        }
        return true;
    }
    return false;
}

/** @param {boolean} is_raid
    @param {number=} raid_distance - if is_raid, number of hexes away from base we want to travel
    @param {string|null=} raid_type - "pve" or "pvp"
    if player is limited from deploying an additional squad, get a predicate that explains why */
function get_squad_deployment_predicate(is_raid, raid_distance, raid_type) {
    var critical_stat = null;
    var critical_value = null;
    var error_upgrade = null, error_final = null;

    // this assumes the resolution is always to upgrade a single building
    if(player.num_deployed_squads() >= player.stattab['max_deployed_squads']) {
        critical_stat = 'provides_deployed_squads';
        error_upgrade = 'CANNOT_DEPLOY_SQUAD_LIMIT_REACHED';
        error_final = 'CANNOT_DEPLOY_SQUAD_MAX_LIMIT_REACHED';
    } else if(is_raid && player.num_deployed_raids() >= player.stattab['max_deployed_raids']) {
        // assume it's a single building you upgrade
        critical_stat = 'provides_deployed_raids';
        error_upgrade = 'CANNOT_DEPLOY_RAID_LIMIT_REACHED';
        error_final = 'CANNOT_DEPLOY_RAID_MAX_LIMIT_REACHED';
    } else if(is_raid && raid_distance > player.stattab['raid_range_'+raid_type]) {
        critical_stat = 'raid_range_'+raid_type;
        critical_value = raid_distance;
        error_upgrade = 'CANNOT_DEPLOY_RAID_DIST_LIMIT';
        error_final = 'CANNOT_DEPLOY_RAID_MAX_DIST_LIMIT';
    }

    if(critical_stat) {
        for(var specname in gamedata['buildings']) {
            var spec = gamedata['buildings'][specname];
            if(critical_stat in spec) {
                var cur_level = player.history[specname+'_level'] || 0;
                var next_level = get_next_level_with_stat_increase(spec, critical_stat, cur_level);
                console.log('cur_level '+cur_level+' next_level '+next_level);
                if((cur_level > 0 && next_level < 0) ||
                   (critical_value !== null && critical_value > get_leveled_quantity(spec[critical_stat], get_max_level(spec)))) {
                    // no further increase available, or can never get high enough
                    return {'predicate': 'ALWAYS_FALSE',
                            'ui_title': gamedata['errors'][error_final]['ui_title'],
                            'ui_name': gamedata['errors'][error_final]['ui_name']};
                } else {
                    return {'predicate': 'BUILDING_LEVEL', 'building_type': specname, 'trigger_level': next_level,
                            'ui_title': gamedata['errors'][error_upgrade]['ui_title'],
                            'ui_name': gamedata['errors'][error_upgrade]['ui_name']};
                }
            }
        }
    }
    return {'predicate':'ALWAYS_TRUE'};
}
/** @param {boolean} is_raid
    @param {number=} raid_distance - if is_raid, number of hexes away from base we want to travel
    @param {string|null=} raid_type - "pve" or "pvp" */
function resolve_squad_deployment_problem(is_raid, raid_distance, raid_type) {
    var rpred = read_predicate(get_squad_deployment_predicate(is_raid, raid_distance, raid_type));
    if(!rpred.is_satisfied(player,null)) {
        var helper = get_requirements_help(rpred);
        if(helper) { helper(); }
        return true;
    }
    return false;
}

// check for conditions that prevent requesting or making unit donations
// and pop up some UI to deal with them. Return true if there was a problem.
function resolve_unit_donation_problem() {
    if(!session.is_in_alliance()) { return true; }
    return resolve_alliance_building_problem();
}

function invoke_unit_donation_dialog(req) {
    if(resolve_unit_donation_problem()) { return null; }

    if(req['region_id'] && gamedata['unit_donation_restrict_region'] &&
       (!session.region.data || session.region.data['id'] !== req['region_id'])) {
        // wrong region - offer to relocate
        invoke_find_on_map(req['region_id'], [0,0]);
        return null;
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['unit_donation_dialog']);
    dialog.user_data['dialog'] = 'unit_donation_dialog';
    dialog.user_data['req'] = req;
    dialog.user_data['donation'] = [];
    dialog.user_data['pending'] = false;
    dialog.user_data['alliance_building'] = find_object_by_type(gamedata['alliance_building']);

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['cancel_button'].onclick = dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['recipient_portrait'].set_user(req['recipient_id']);

    var alliance_info = AllianceCache.query_info_sync(session.alliance_id);
    var player_info = PlayerCache.query_sync(req['recipient_id']);

    dialog.widgets['alliance_logo'].asset = (alliance_info['logo'] ? 'alicon_'+alliance_info['logo'] : 'inventory_unknown');
    dialog.widgets['donate_label'].str = dialog.data['widgets']['donate_label']['ui_name'].replace('%recipient', req['recipient_name']);

    dialog.widgets['donate_button'].onclick = function(w) {
        var _dialog = w.parent;
        if(!_dialog || _dialog.user_data['pending']) { return; }
        var alliance_building = find_object_by_type(gamedata['alliance_building']);
        if(alliance_building) {
            send_to_server.func(["CAST_SPELL", alliance_building.id, 'DONATE_UNITS', _dialog.user_data['req']['recipient_id'],
                                 _dialog.user_data['req']['tag'], _dialog.user_data['donation']]);

            // client-side prediction
            if(gamedata['client']['predict_donated_units']) {
                _dialog.user_data['pending'] = true;
                goog.array.forEach(_dialog.user_data['donation'], function(obj_id) {
                    // snoop update into my_army
                    if(obj_id in player.my_army) {
                        delete player.my_army[obj_id];
                        session.get_real_world().lazy_update_citizens();
                    }
                    // remove from session
                    if(session.get_real_world().objects.has_object(obj_id)) {
                        session.get_real_world().objects.rem_object(session.get_real_world().objects.get_object(obj_id));
                    }
                });
            } else {
                invoke_ui_locker();
            }
        }
    };

    dialog.ondraw = update_unit_donation_dialog;
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_unit_donation_dialog(dialog) {
    var req = dialog.user_data['req'];
    var donation = dialog.user_data['donation'];
    var pending = dialog.user_data['pending'];
    var alliance_building = dialog.user_data['alliance_building'];
    var proposed_space = 0;

    /** @type {Object.<string,number>} specname -> number proposed for donation */
    var donation_by_type = {};

    var max_individual_space = (alliance_building ? alliance_building.get_leveled_quantity(alliance_building.spec['max_individual_donation_space']) : 0);

    // "army" or "session"
    var source = gamedata['donated_units_source'] || 'session';
    if(!goog.array.contains(['army','session'], source)) { throw Error('bad donated_units_source '+source); }

    // trim nonexistent, damaged, or too-big units out of proposed donation
    for(var i = 0; i < donation.length; i++) {
        if((source == 'session' && !(session.get_real_world().objects.has_object(donation[i]))) ||
           (source == 'army' && !(donation[i] in player.my_army))) {
            donation.splice(i,1);
            i -= 1; // correction for loop iteration
            continue;
        }

        var obj_spec, obj_level, hp_ratio;
        if(source == 'session') {
            var obj = session.get_real_world().objects.get_object(donation[i]);
            obj_spec = obj.spec;
            obj_level = obj.level;
            hp_ratio = obj.hp / obj.max_hp;
        } else if(source == 'army') {
            var unit = player.my_army[donation[i]];
            if(SQUAD_IDS.is_mobile_squad_id(unit['squad_id']||0)) { // can't donate units in mobile squads
                donation.splice(i,1);
                i -= 1; // correction for loop iteration
                continue;
            }
            obj_spec = gamedata['units'][unit['spec']];
            obj_level = ('level' in unit ? unit['level'] : 1);
            hp_ratio = ('hp_ratio' in unit ? unit['hp_ratio'] : 1);
        }
        var space = get_leveled_quantity(obj_spec['consumes_space'], obj_level);
        proposed_space += space;

        if((hp_ratio < 1) || (proposed_space + req['cur_space'] > req['max_space'])) {
            // damaged, or won't fit
            proposed_space -= space;
            donation.splice(i,1);
            i -= 1; // correction for loop iteration
            continue;
        }
        if(!(obj_spec['name'] in donation_by_type)) { donation_by_type[obj_spec['name']] = 0; }
        donation_by_type[obj_spec['name']] += 1;
    }

    var cur_plus_proposed_space = req['cur_space']+proposed_space;

    /** @type {Array.<{obj_id:string, spec:string, level:number}>} */
    var available_unit_list = [];

    if(source == 'session') {
        session.for_each_real_object(function(obj) {
            if(obj.is_mobile() && (obj.team === 'player') && (obj.hp >= obj.max_hp) &&
               (!('donatable' in obj.spec) || obj.spec['donatable'])) {
                available_unit_list.push({obj_id: obj.id, spec: obj.spec['name'], level:obj.level});
            }
        });
    } else if(source == 'army') {
        goog.object.forEach(player.my_army, function(unit) {
            var spec = gamedata['units'][unit['spec']];
            if((!('hp_ratio' in unit) || unit['hp_ratio'] >= 1) &&
               (!('donatable' in spec) || spec['donatable']) &&
               !SQUAD_IDS.is_mobile_squad_id(unit['squad_id']||0)) {
                available_unit_list.push({obj_id: unit['obj_id'], spec: unit['spec'], level: ('level' in unit ? unit['level'] : 1)});
            }
        });
    }

    /** @type {Object.<string,number>} specname -> number available */
    var available_units_by_type = {};
    for(var i = 0; i < available_unit_list.length; i++) {
        var unit = available_unit_list[i];
        if(!(unit.spec in available_units_by_type)) {
            available_units_by_type[unit.spec] = 0;
        }
        available_units_by_type[unit.spec] += 1;
    }

    // iterate in order found in units.json

    /** @type {Array.<string>} list of specnames */
    var available_unit_types = [];
    /** @type {Array.<string>} list of specnames */
    var donation_unit_types = [];

    for(var specname in gamedata['units']) {
        if(specname in available_units_by_type) {
            available_unit_types.push(specname);
        }
        if(specname in donation_by_type) {
            donation_unit_types.push(specname);
        }
    }

    var my_unit_slot = 0;
    while((my_unit_slot < available_unit_types.length) && (my_unit_slot < dialog.data['widgets']['my_slot']['array'][0]*dialog.data['widgets']['my_slot']['array'][1])) {
        var x = my_unit_slot % dialog.data['widgets']['my_slot']['array'][0];
        var y = Math.floor(my_unit_slot / dialog.data['widgets']['my_slot']['array'][0]);
        var wname = x.toFixed(0)+','+y.toFixed(0);

        var specname = available_unit_types[my_unit_slot];
        var qty = available_units_by_type[specname] - (donation_by_type[specname] || 0);
        var space = get_leveled_quantity(gamedata['units'][specname]['consumes_space'],1);

        dialog.widgets['my_slot'+wname].show =
            dialog.widgets['my_item'+wname].show =
            dialog.widgets['my_stack'+wname].show =
            dialog.widgets['my_frame'+wname].show = true;
        var asset_name = get_leveled_quantity(gamedata['units'][specname]['icon'] || gamedata['units'][specname]['art_asset'],1);
        dialog.widgets['my_item'+wname].asset = asset_name;
        dialog.widgets['my_item'+wname].state = GameArt.assets[asset_name].has_state('icon') ? 'icon' : 'normal';
        dialog.widgets['my_stack'+wname].str = pretty_print_number(qty);

        var ttip, ttip_s = '', ttip_bldg = '', ttip_col = SPUI.default_text_color, upgrade_alliance_building_level = -1;
        if(space > max_individual_space) {
            var level;
            for(level = alliance_building.level; level <= alliance_building.get_max_ui_level(); level++) {
                if(get_leveled_quantity(alliance_building.spec['max_individual_donation_space'], level) >= space) {
                    break;
                }
            }
            if(level > alliance_building.get_max_ui_level()) {
                ttip = 'ui_tooltip_unit_too_big';
            } else {
                ttip = 'ui_tooltip_upgrade_transmitter';
                ttip_bldg = alliance_building.spec['ui_name'];
                ttip_s = level.toFixed(0);
                upgrade_alliance_building_level = level;
            }
            ttip_col = SPUI.error_text_color;
        } else if(cur_plus_proposed_space+space > req['max_space']) {
            ttip = 'ui_tooltip_no_space';
        } else {
            ttip = 'ui_tooltip';
        }

        dialog.widgets['my_frame'+wname].state = (upgrade_alliance_building_level > 0 ? 'disabled_clickable' : ((space <= max_individual_space) && (qty > 0) && (cur_plus_proposed_space+space <= req['max_space']) ? 'normal' : 'disabled'));
        dialog.widgets['my_frame'+wname].tooltip.str = dialog.data['widgets']['my_frame'][ttip].replace('%s', ttip_s).replace('%BUILDING', ttip_bldg).replace('%UNITNAME',gamedata['units'][specname]['ui_name']);
        dialog.widgets['my_frame'+wname].tooltip.text_color = ttip_col;

        if(upgrade_alliance_building_level > 0) {
            dialog.widgets['my_frame'+wname].onclick = (function (_lvl) { return function(w) {
                var helper = get_requirements_help(read_predicate({'predicate': 'BUILDING_LEVEL', 'building_type': gamedata['alliance_building'], 'trigger_level':_lvl}),null);
                if(helper) { helper(); }
            }; })(upgrade_alliance_building_level);
        } else {
            dialog.widgets['my_frame'+wname].onclick = (function (_source, _specname) { return function(w) {
                var _dialog = w.parent;

                // find ID of next unit to donate
                var obj_id = null;

                // XXX really inefficient
                if(_source == 'session') {
                    session.for_each_real_object(function(o) {
                        if((o.spec['name'] === _specname) && (o.team === 'player') && (o.hp >= o.max_hp)) {
                            if(!goog.array.contains(_dialog.user_data['donation'], o.id)) {
                                // found a new candidate
                                obj_id = o.id;
                                return true;
                            }
                        }
                    });
                } else if(_source == 'army') {
                    for(var id in player.my_army) {
                        var o = player.my_army[id];
                        if(o['spec'] == _specname && (!('hp_ratio' in o) || o['hp_ratio'] >= 1)) {
                            if(!goog.array.contains(_dialog.user_data['donation'], id)) {
                                // found a new candidate
                                obj_id = id;
                                break;
                            }
                        }
                    }
                }

                if(obj_id) {
                    _dialog.user_data['donation'].push(obj_id);
                } else {
                    // dripper normally can get here, just pass silently
                    //console.log('could not find unit to donate of type '+_specname);
                    return;
                }
            }; })(source, specname);
        }
        if(!gamedata['client']['unit_manufacture_dripper']) {
            dialog.widgets['my_frame'+wname].dripper_cb = null; // disable dripper behavior
        }
        my_unit_slot += 1;
    }

    // clear remaining "my unit" spaces
    while(my_unit_slot < dialog.data['widgets']['my_slot']['array'][0]*dialog.data['widgets']['my_slot']['array'][1]) {
        var x = my_unit_slot % dialog.data['widgets']['my_slot']['array'][0];
        var y = Math.floor(my_unit_slot / dialog.data['widgets']['my_slot']['array'][0]);
        var wname = x.toFixed(0)+','+y.toFixed(0);
        dialog.widgets['my_slot'+wname].show =
            dialog.widgets['my_item'+wname].show =
            dialog.widgets['my_stack'+wname].show =
            dialog.widgets['my_frame'+wname].show = false;
        my_unit_slot += 1;
    }

    var donate_unit_slot = 0;
    while((donate_unit_slot < donation_unit_types.length) && (donate_unit_slot < dialog.data['widgets']['donate_slot']['array'][0]*dialog.data['widgets']['donate_slot']['array'][1])) {
        var x = donate_unit_slot % dialog.data['widgets']['donate_slot']['array'][0];
        var y = Math.floor(donate_unit_slot / dialog.data['widgets']['donate_slot']['array'][0]);
        var wname = x.toFixed(0)+','+y.toFixed(0);
        dialog.widgets['donate_slot'+wname].show =
            dialog.widgets['donate_item'+wname].show =
            dialog.widgets['donate_stack'+wname].show =
            dialog.widgets['donate_cancel'+wname].show =
            dialog.widgets['donate_frame'+wname].show = true;

        var specname = donation_unit_types[donate_unit_slot];
        var qty = (donation_by_type[specname] || 0);

        var asset_name = get_leveled_quantity(gamedata['units'][specname]['icon'] || gamedata['units'][specname]['art_asset'],1);

        dialog.widgets['donate_item'+wname].asset = asset_name;
        dialog.widgets['donate_item'+wname].state = GameArt.assets[asset_name].has_state('icon') ? 'icon' : 'normal';
        dialog.widgets['donate_stack'+wname].str = pretty_print_number(qty);
        dialog.widgets['donate_frame'+wname].tooltip.str = gamedata['units'][specname]['ui_name'];
        dialog.widgets['donate_frame'+wname].onclick =
            dialog.widgets['donate_cancel'+wname].onclick = (function (_source, _specname) { return function(w) {
                var _dialog = w.parent;
                // XXX really inefficient
                for(var i = 0; i < _dialog.user_data['donation'].length; i++) {
                    if(_source == 'session') {
                        var o = session.get_real_world().objects._get_object(_dialog.user_data['donation'][i]);
                        if(o && o.spec['name'] === _specname) {
                            _dialog.user_data['donation'].splice(i, 1);
                            break;
                        }
                    } else if(_source == 'army') {
                        var o = player.my_army[_dialog.user_data['donation'][i]];
                        if(o['spec'] == _specname) {
                            _dialog.user_data['donation'].splice(i, 1);
                            break;
                        }
                    }
                }
            }; })(source, specname);

        if(!gamedata['client']['unit_manufacture_dripper']) {
            dialog.widgets['donate_frame'+wname].dripper_cb =
                dialog.widgets['donate_cancel'+wname].dripper_cb = null; // disable dripper behavior
        }
        donate_unit_slot += 1;
    }
    while(donate_unit_slot < dialog.data['widgets']['donate_slot']['array'][0]*dialog.data['widgets']['donate_slot']['array'][1]) {
        var x = donate_unit_slot % dialog.data['widgets']['donate_slot']['array'][0];
        var y = Math.floor(donate_unit_slot / dialog.data['widgets']['donate_slot']['array'][0]);
        var wname = x.toFixed(0)+','+y.toFixed(0);
        dialog.widgets['donate_slot'+wname].show =
            dialog.widgets['donate_item'+wname].show =
            dialog.widgets['donate_stack'+wname].show =
            dialog.widgets['donate_cancel'+wname].show =
            dialog.widgets['donate_frame'+wname].show = false;
        donate_unit_slot += 1;
    }


    // fainter bar that covers cur_plus_proposed
    dialog.widgets['space_prog_bg'].progress = cur_plus_proposed_space/req['max_space'];
    // brighter bar that covers cur_space only
    dialog.widgets['space_prog_fg'].progress = req['cur_space']/req['max_space'];

    dialog.widgets['space_value'].str = dialog.data['widgets']['space_value']['ui_name'].replace('%cur', cur_plus_proposed_space.toString()).replace('%max', req['max_space'].toString());

    dialog.widgets['donate_button'].state = ((donation.length > 0 && !pending) ? 'normal' : 'disabled');
    dialog.widgets['close_button'].state = dialog.widgets['cancel_button'].state = (pending ? 'disabled' : 'normal');
    dialog.widgets['pending_rect'].show = dialog.widgets['pending_text'].show = dialog.widgets['pending_spinner'].show = pending;
}

function update_inventory_header_buttons(dialog, obj, cur_mode) {
    var lottery_spell = gamedata['spells']['LOTTERY_SCAN'];
    var can_show = (('show_if' in lottery_spell ? read_predicate(lottery_spell['show_if']).is_satisfied(player) : true) &&
                    ('requires' in lottery_spell ? read_predicate(lottery_spell['requires']).is_satisfied(player) : true));

    if(can_show && obj && obj.is_warehouse() && obj.is_lottery_building()) {
        dialog.widgets['inventory_toggle'].show =
            dialog.widgets['lottery_toggle'].show = true;
        dialog.widgets['inventory_toggle'].state = (cur_mode === 'inventory' ? 'active' : 'normal');
        dialog.widgets['lottery_toggle'].state = (cur_mode === 'lottery' ? 'active' : 'normal');
        dialog.widgets['inventory_toggle'].onclick = (cur_mode === 'inventory' ? null : function(w) { invoke_inventory_dialog(); });
        dialog.widgets['lottery_toggle'].onclick = (cur_mode === 'lottery' ? null : (function (_obj) {
            return function(w) {
                invoke_lottery_dialog(_obj, 'inventory_dialog_header_button');
            }; })(obj) );
        dialog.widgets['lottery_toggle'].str = lottery_spell['ui_name'];
    } else {
        dialog.widgets['inventory_toggle'].show =
            dialog.widgets['lottery_toggle'].show = false;
    }
}

var lottery_slate_receivers = [];
function get_lottery_slate(scanner, callback) {
    lottery_slate_receivers.push(callback);
    send_to_server.func(["CAST_SPELL", scanner.id, "LOTTERY_GET_SLATE"]);
}

function invoke_lottery_dialog(scanner, reason) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['lottery_dialog']);
    dialog.user_data['dialog'] = 'lottery_dialog';
    dialog.user_data['scanner'] = scanner;
    dialog.user_data['last_contents'] = -1;
    dialog.user_data['slate'] = null;
    dialog.user_data['scan_pending'] = -1; // client_time scan was launched
    lottery_dialog_got_slate(dialog, null); // just to initialize user_data

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['title'].str = gamedata['spells']['LOTTERY_SCAN']['ui_name'];
    lottery_dialog_refresh_slate(dialog);
    dialog.ondraw = update_lottery_dialog;
    update_inventory_header_buttons(dialog, scanner, 'lottery');
    metric_event('1633_lottery_dialog_open', {'method': reason, 'sum': player.get_denormalized_summary_props('brief')});
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function lottery_dialog_refresh_slate(dialog) {
    dialog.user_data['slate_pending'] = true;
    get_lottery_slate(dialog.user_data['scanner'], (function (_dialog) { return function(result) { lottery_dialog_got_slate(_dialog, result); }; })(dialog));
}

function lottery_dialog_got_slate(dialog, result) {
    if(dialog.user_data['scan_pending'] >= 0) {
        // wait until it finishes
        dialog.user_data['incoming_slate'] = result;
    } else {
        lottery_dialog_accept_slate(dialog, result);
    }
}

function lottery_dialog_accept_slate(dialog, result) {
    dialog.user_data['slate'] = result;
    dialog.user_data['slate_pending'] = false;
    dialog.user_data['slot_offsets'] = {}; // random numbers for slate icon animation
    dialog.user_data['slate_permutation'] = {}; // mapping from slate name to slot number
    dialog.user_data['slate_permutation_inv'] = {}; // mapping from slot number (string) to slate name
    dialog.user_data['slate_last_randomized'] = {}; // time each slot_name was last permuted
    dialog.user_data['cursor_states'] = [];
    for(var c = 0; c < dialog.data['widgets']['cursor']['array'][0]; c++) {
        dialog.user_data['cursor_states'].push({'last':null, 'next':null, 'next_time': client_time, 'last_time':client_time});
    }

    if(!result) { return; }

    var i = 0;
    // create a randomized permutation
    // http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
    var permute_list = [null];

    for(var slot_name in result) {
        dialog.user_data['slot_offsets'][i.toString()] = Math.random();
        var j = Math.floor(Math.random()*(i+1));
        permute_list[i] = permute_list[j];
        permute_list[j] = slot_name;
        i += 1;
    }

    // store the permutation as a forward and inverse mapping
    goog.array.forEach(permute_list, function(slot_name, n) {
        dialog.user_data['slate_last_randomized'][slot_name] = client_time - dialog.data['widgets']['goodies']['randomize_period_normal']*Math.random();
        dialog.user_data['slate_permutation'][slot_name] = n;
        dialog.user_data['slate_permutation_inv'][n.toString()] = slot_name;
    });
}

function lottery_dialog_randomize_permutation(dialog, slot_name) {
    var period = dialog.data['widgets']['goodies'][(dialog.user_data['scan_pending']>0 ? 'randomize_period_scanning':'randomize_period_normal')];
    var max_i = goog.object.getCount(dialog.user_data['slate_permutation_inv']);
    var old_i = dialog.user_data['slate_permutation'][slot_name];
    var new_i = Math.floor(Math.random()*max_i);
    var swap_with = dialog.user_data['slate_permutation_inv'][new_i.toString()];
    if(period < 0 ||
       client_time - dialog.user_data['slate_last_randomized'][swap_with] < period ||
       client_time - dialog.user_data['slate_last_randomized'][slot_name] < period) {
        return; // too soon
    }
    dialog.user_data['slate_permutation'][slot_name] = new_i;
    dialog.user_data['slate_permutation_inv'][new_i.toString()] = slot_name;
    dialog.user_data['slate_permutation'][swap_with] = old_i;
    dialog.user_data['slate_permutation_inv'][old_i.toString()] = swap_with;
    dialog.user_data['slate_last_randomized'][slot_name] = client_time - period * Math.random();
}
function lottery_dialog_get_slot_widget(dialog, i) {
    var y = Math.floor(i / dialog.data['widgets']['goodies']['array'][0]);
    var x = i % dialog.data['widgets']['goodies']['array'][0];
    var wname = SPUI.get_array_widget_name('goodies', dialog.data['widgets']['goodies']['array'], [x,y]);
    return dialog.widgets[wname];
}
function lottery_dialog_randomize_cursor(dialog, state) {
    var max_i = goog.object.getCount(dialog.user_data['slate_permutation_inv']);
    var offset = dialog.data['widgets']['cursor']['xy'];
    if(state['next']) {
        state['last'] = state['next'];
    } else {
        var i = Math.floor(max_i*Math.random());
        state['last'] = vec_add(lottery_dialog_get_slot_widget(dialog, i).xy, offset);
    }
    var n = Math.floor(max_i*Math.random());
    state['next'] = vec_add(lottery_dialog_get_slot_widget(dialog, n).xy, offset);
    state['last_time'] = client_time;
    state['next_time'] = client_time + vec_distance(state['next'], state['last'])/dialog.data['widgets']['cursor']['anim_speed'];
}

/** @param {SPUI.Dialog} dialog */
function update_lottery_dialog(dialog) {

    // XXX horrible awkward hack to suppress lottery_dialog tooltips when covered by the item_discovered_dialog
    dialog.user_data['hide_tooltips'] = (selection.ui.children[selection.ui.children.length-1] instanceof SPUI.Dialog);

    var scanner = dialog.user_data['scanner'];
    var state = player.get_lottery_state(scanner);

    if(state.next_scan_method == 'cooldown' || state.next_scan_method == 'contents') {
        dialog.widgets['charges'].set_text_bbcode(gamedata['spells']['LOTTERY_SCAN']['ui_tooltip_remaining'].replace('%d', pretty_print_number(state.num_scans)));
    } else if(state.next_scan_method == 'aura') {
        dialog.widgets['charges'].set_text_bbcode(gamedata['spells']['LOTTERY_SCAN'][state.num_scans == 1 ? 'ui_tooltip_aura' : 'ui_tooltip_aura_plural'].replace('%d', pretty_print_number(state.num_scans)));
    } else if(state.next_scan_method == 'paid') {
        dialog.widgets['charges'].set_text_bbcode(gamedata['spells']['LOTTERY_SCAN']['ui_tooltip_on_cooldown'].replace('%s', '[color=#ffff00]'+pretty_print_time(player.cooldown_togo('lottery_free'))+'[/color]'));
    } else {
        throw Error('unhandled next_scan_method '+(state.next_scan_method || 'null'));
    }

    update_lottery_dialog_buttons(dialog, dialog);

    // show most recent loot
    if('history' in dialog.data['widgets']) {
        var history = player.session_lottery_loot;
        var history_i = Math.max(0, player.session_lottery_loot.length - dialog.data['widgets']['history']['array'][1]*dialog.data['widgets']['history']['array'][0]);
        for(var y = 0; y < dialog.data['widgets']['history']['array'][1]; y++) {
            for(var x = 0; x < dialog.data['widgets']['history']['array'][0]; x++) {
                var wname = SPUI.get_array_widget_name('history', dialog.data['widgets']['history']['array'], [x,y]);
                if(history_i < history.length) {
                    var item = history[history_i];
                    dialog.widgets[wname].show = true;
                    ItemDisplay.display_item(dialog.widgets[wname], item, {context_parent: dialog});
                    ItemDisplay.attach_inventory_item_tooltip(dialog.widgets[wname].widgets['frame'], item, dialog);
                    dialog.widgets[wname].widgets['frame'].state = 'disabled';
                } else {
                    dialog.widgets[wname].show = false;
                }
                history_i += 1;
            }
        }
    }

    // show slate
    for(var y = 0; y < dialog.data['widgets']['goodies_spinner']['array'][1]; y++) {
        for(var x = 0; x < dialog.data['widgets']['goodies_spinner']['array'][0]; x++) {
            var wname = SPUI.get_array_widget_name('goodies_spinner', dialog.data['widgets']['goodies_spinner']['array'], [x,y]);
            // show when slate is pending, but not if in the middle of a scan
            dialog.widgets[wname].show = dialog.user_data['slate_pending'] && (dialog.user_data['scan_pending'] < 0);
        }
    }

    var i = 0, max_i = goog.object.getCount(dialog.user_data['slate_permutation_inv']);
    var to_randomize = []; // slot_names to be re-permuted after this pass
    for(var y = 0; y < dialog.data['widgets']['goodies']['array'][1]; y++) {
        for(var x = 0; x < dialog.data['widgets']['goodies']['array'][0]; x++) {
            var wname = SPUI.get_array_widget_name('goodies', dialog.data['widgets']['goodies']['array'], [x,y]);

            if(i < max_i) {
                var slot_name = dialog.user_data['slate_permutation_inv'][i.toString()];
                var item_list = dialog.user_data['slate'][slot_name];
                if(item_list.length != 1) { throw Error('bad lottery loot '+JSON.stringify(item_list)); }
                var item = item_list[0];
                dialog.widgets[wname].show = true;
                var displayed_item = (player.get_any_abtest_value('lottery_conceal_slate',gamedata['lottery_conceal_slate']) ? {'spec':'unknown_lottery_item'} : item);
                ItemDisplay.display_item(dialog.widgets[wname], displayed_item, {context_parent: dialog});

                // pulse
                var phase = dialog.user_data['slot_offsets'][i.toString()];
                var amp = dialog.data['widgets']['goodies']['pulse_amplitude'];
                var period = dialog.data['widgets']['goodies'][dialog.user_data['scan_pending'] > 0 ? 'pulse_period_scanning': 'pulse_period_normal'];
                var alpha = (1-amp) + amp * Math.sin((client_time/period + phase)*2*Math.PI);
                dialog.widgets[wname].widgets['item'].alpha = alpha;
                to_randomize.push(slot_name);

                var rarity_wname = SPUI.get_array_widget_name('goodies_rarity', dialog.data['widgets']['goodies_rarity']['array'], [x,y]);
                var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
                var rarity = ('rarity' in spec ? spec['rarity'] : 1);
                if('asset_rarity'+rarity.toString() in dialog.data['widgets']['goodies_rarity']) {
                    dialog.widgets[rarity_wname].show = true;
                    dialog.widgets[rarity_wname].asset = dialog.data['widgets']['goodies_rarity']['asset_rarity'+rarity.toString()];
                    var amp2 = dialog.data['widgets']['goodies_rarity']['pulse_amplitude'];
                    var period2 = dialog.data['widgets']['goodies_rarity'][dialog.user_data['scan_pending'] > 0 ? 'pulse_period_scanning': 'pulse_period_normal'];
                    var alpha2 = (1-amp2) + amp2 * Math.sin((client_time/period2 + phase)*2*Math.PI);
                    dialog.widgets[rarity_wname].alpha = alpha2;
                } else {
                    dialog.widgets[rarity_wname].show = false;
                }
            } else {
                dialog.widgets[wname].show = false;
            }
            i += 1;
        }
    }
    goog.array.forEach(to_randomize, function(slot_name) { lottery_dialog_randomize_permutation(dialog, slot_name); });

    // show cursors
    for(var c = 0; c < dialog.data['widgets']['cursor']['array'][0]; c++) {
        dialog.widgets['cursor'+c.toString()].show = dialog.user_data['scan_pending'] > 0;
        if(dialog.user_data['scan_pending'] > 0) {
            var cs = dialog.user_data['cursor_states'][c];
            var t = (client_time - cs['last_time'])/(cs['next_time']-cs['last_time']);
            if(t >= 1 || !cs['next']) {
                lottery_dialog_randomize_cursor(dialog, cs);
                t = 0;
            }
            dialog.widgets['cursor'+c.toString()].xy = vec_add(cs['last'], vec_scale(t, vec_sub(cs['next'], cs['last'])));
        }
    }
}

/** update the price display and "buy" button. Used for item_discovered_dialog as well.
    @param {!SPUI.Dialog} dialog owning the buttons
    @param {!SPUI.Dialog} lottery_dialog the corresponding lottery_dialog */
function update_lottery_dialog_buttons(dialog, lottery_dialog) {
    var user_data = lottery_dialog.user_data;
    var state = player.get_lottery_state(user_data['scanner']);
    dialog.widgets['lottery_price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['lottery_price_display'].state = Store.get_user_currency();

    var spellarg = state.next_scan_method;
    var display_price;
    if(state.next_scan_method == 'contents' || state.next_scan_method == 'cooldown' || state.next_scan_method == 'aura') {
        // free version
        display_price = 0;
    }else {
        display_price = Store.get_price(Store.get_user_currency(), user_data['scanner'].id, gamedata['spells']['LOTTERY_SCAN'], spellarg, true);
    }

    if(user_data['scan_pending'] > 0 || user_data['slate_pending']) {
        dialog.widgets['lottery_price_display'].onclick =
            dialog.widgets['lottery_button'].onclick = null;
        dialog.widgets['lottery_button'].state = 'disabled';
        dialog.widgets['lottery_price_display'].str = '-';
        dialog.widgets['lottery_price_display'].tooltip.str = null;
        dialog.widgets['lottery_button'].str = (user_data['scan_pending'] > 0 ? gamedata['spells']['LOTTERY_SCAN']['ui_verb_pending'] : dialog.data['widgets']['lottery_button']['ui_name_loading']);
    } else {
        dialog.widgets['lottery_button'].state = 'normal';
        dialog.widgets['lottery_button'].tooltip.str = null;
        dialog.widgets['lottery_price_display'].str = Store.display_user_currency_price(display_price); // PRICE
        dialog.widgets['lottery_price_display'].tooltip.str = null; // this tends to show through item_discovered Store.display_user_currency_price_tooltip(display_price); // PRICE
        dialog.widgets['lottery_button'].str = gamedata['spells']['LOTTERY_SCAN'][((state.next_scan_method == 'paid' || (state.next_scan_method == 'aura' && !state.next_scan_free)) ? 'ui_verb_paid' : 'ui_verb')];

        if(!state.can_scan) {
            dialog.widgets['lottery_button'].state = 'disabled_clickable';
            dialog.widgets['lottery_button'].tooltip.str = state.fail_ui_reason;
            dialog.widgets['lottery_button'].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['lottery_price_display'].onclick =
                dialog.widgets['lottery_button'].onclick = state.fail_helper;
        } else if(state.next_scan_method == 'contents' || state.next_scan_method == 'cooldown' || state.next_scan_method == 'aura') {
            dialog.widgets['lottery_price_display'].onclick =
                dialog.widgets['lottery_button'].onclick = (function (_lottery_dialog, _spellarg) { return function(w) {
                    _lottery_dialog.user_data['scan_pending'] = client_time;
                    _lottery_dialog.widgets['glow'].show = true; _lottery_dialog.widgets['glow'].reset_fx();

                    if(gamedata['client']['vfx']['lottery_scan']) {
                        session.get_draw_world().fxworld.add_visual_effect_at_time([0,0], 0, [0,1,0], client_time, gamedata['client']['vfx']['lottery_scan'], true, null);
                    }

                    send_to_server.func(["CAST_SPELL", _lottery_dialog.user_data['scanner'].id, "LOTTERY_SCAN", _spellarg]);

                    // client-side predict aura update
                    if(_spellarg == 'aura') {
                        var aura = goog.array.find(player.player_auras, function(a) {
                            return (a['spec'] == 'lottery_scans') && (!('end_time' in a) || (server_time < a['end_time']));
                        });
                        if(aura) {
                            aura['stack'] = ('stack' in aura ? aura['stack'] - 1 : 0);
                            if(aura['stack'] <= 0) {
                                aura['end_time'] = server_time - 1;
                            }
                        }
                    }

                    lottery_dialog_refresh_slate(_lottery_dialog);
                    if(w.parent !== _lottery_dialog) {
                        close_dialog(w.parent);
                    }
                }; })(lottery_dialog, spellarg);
        } else {
            dialog.widgets['lottery_price_display'].onclick =
                dialog.widgets['lottery_button'].onclick = (function (_lottery_dialog, _spellarg) { return function(w) {
                    if(Store.place_user_currency_order(_lottery_dialog.user_data['scanner'].id, 'LOTTERY_SCAN', _spellarg, null)) {
                        _lottery_dialog.user_data['scan_pending'] = client_time;
                        _lottery_dialog.widgets['glow'].show = true; _lottery_dialog.widgets['glow'].reset_fx();
                        if(gamedata['client']['vfx']['lottery_scan']) {
                            session.get_draw_world().fxworld.add_visual_effect_at_time([0,0], 0, [0,1,0], client_time, gamedata['client']['vfx']['lottery_scan'], true, null);
                        }

                        lottery_dialog_refresh_slate(_lottery_dialog);
                        if(w.parent !== _lottery_dialog) {
                            close_dialog(w.parent);
                        }
                    }
                }; })(lottery_dialog, spellarg);
        }
    }
}


function lottery_dialog_scan_result(dialog, which_slot, loot) {
    dialog.user_data['scan_pending'] = -1;
    if(loot) {
        do_invoke_items_discovered(loot, -1, 'inventory', dialog);
    }

    // update the slate, if we received the new one
    if('incoming_slate' in dialog.user_data) { // may be null
        var slate = dialog.user_data['incoming_slate'];
        delete dialog.user_data['incoming_slate'];
        lottery_dialog_accept_slate(dialog, slate);
    }
}

function invoke_abtest_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['abtest_dialog']);
    dialog.user_data['dialog'] = 'abtest_dialog';
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };
    dialog.ondraw = update_abtest_dialog;
    // make copy of player.abtests
    dialog.user_data['abtests'] = {};
    for(var name in player.abtests) {
        dialog.user_data['abtests'][name] = player.abtests[name];
    }
    dialog.widgets['ok_button'].onclick = function(w) {
        var data = w.parent.user_data['abtests'];
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_MODIFY_ABTESTS", data]);
        // force reload
        SPINPUNCHGAME.shutdown();

        change_selection(null);
        window.setTimeout(function() { reload_game(); }, 500);
    };
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_abtest_dialog(dialog) {
    var NUM = 6, CNUM = 2;
    var i = 0;
    for(var name in gamedata['abtests']) {
        if(!(name in gamedata['abtests']) ||
           !gamedata['abtests'][name]['active'] ||
           name.indexOf('offer_wall') != -1) {
            continue;
        }
        dialog.widgets['name'+i.toString()].show = true;
        dialog.widgets['name'+i.toString()].str = name;

        var j = 0;
        for(var group in gamedata['abtests'][name]['groups']) {
            dialog.widgets['btn'+i.toString()+','+j.toString()].show = true;
            dialog.widgets['btn'+i.toString()+','+j.toString()].str = group;
            dialog.widgets['btn'+i.toString()+','+j.toString()].state = (dialog.user_data['abtests'][name] == group ? 'active':'normal');
            dialog.widgets['btn'+i.toString()+','+j.toString()].onclick = (function(_dialog, _name, _group) { return function() {
                if(_dialog.user_data['abtests'][_name] == _group) {
                    _dialog.user_data['abtests'][_name] = null;
                } else {
                    _dialog.user_data['abtests'][_name] = _group;
                }
            }; })(dialog, name, group);

            j += 1;
            if(j >= CNUM) { break; }
        }
        i += 1;
        if(i >= NUM) { break; }
    }
};

/** @param {number} from_id
    @param {number} user_id
    @param {number} from_alliance
    @param {string} name
    @param {number} level
    @param {boolean=} zoom_from_widget */
function invoke_battle_history_dialog(from_id, user_id, from_alliance, name, level, zoom_from_widget) {
    player.record_feature_use('battle_history');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['battle_history_dialog']);
    dialog.user_data['dialog'] = 'battle_history_dialog';
    dialog.user_data['anim_start_time'] = client_time;
    dialog.user_data['zoom_from_widget'] = (zoom_from_widget ? zoom_from_widget : ((desktop_dialogs['desktop_top']&&session.home_base) ? desktop_dialogs['desktop_top'].widgets['battle_history_button'] : null));
    dialog.user_data['from_id'] = from_id;
    dialog.user_data['user_id'] = user_id;
    dialog.user_data['from_alliance'] = from_alliance;
    dialog.user_data['scroll_by_row'] = true;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['row_name']['array'][1];
    dialog.user_data['rowdata'] = [];
    dialog.user_data['rowfunc'] = battle_history_setup_row;
    dialog.user_data['rowdata_incomplete'] = true;
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;

    if(from_id < 0 && from_alliance < 0) {
        throw Error('at least one of from_id or from_alliance must be >=0');
    }

    // flag that we're looking at another player's personal battles (only allowed if they are in the same alliance)
    dialog.user_data['alliancemate_flag'] = (!(gamedata['battle_logs_public'] || player.is_developer()) && from_id !== session.user_id && session.is_in_alliance() && from_alliance === session.alliance_id);
    dialog.user_data['sumlist'] = null;
    dialog.user_data['first_on_page'] = []; // index of first shown summary in sumlist
    dialog.user_data['chapter'] = null;
    dialog.user_data['page'] = -1;

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['single_player_button'].onclick = function(w) { battle_history_change_chapter(w.parent, 'ai'); };
    dialog.widgets['multiplayer_button'].onclick = function(w) { battle_history_change_chapter(w.parent, 'human'); };
    dialog.widgets['alliance_button'].onclick = function(w) { battle_history_change_chapter(w.parent, 'alliance'); };

    dialog.widgets['close_button'].onclick = close_parent_dialog;
    var dev_str = (!gamedata['battle_logs_public'] && from_id !== session.user_id && from_alliance !== session.alliance_id ? ' (As '+from_id.toString()+') ' : '');
    if(user_id > 0) {
        dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name_vs'].replace('%s', name.split(' ')[0] + ' (L'+ level.toString()+')') + dev_str;
    } else {
        dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name_all'] + dev_str;
    }

    // set up subtitle
    if(from_id > 0) {
        var pinfo = PlayerCache.query_sync(from_id);
        if(pinfo) {
            dialog.widgets['subtitle'].str = PlayerCache.get_ui_name(pinfo);
            if('player_level' in pinfo) {
                dialog.widgets['subtitle'].str += ' (L'+pinfo['player_level'].toString()+')';
            }
            if('alliance_id' in pinfo && pinfo['alliance_id'] >= 0) {
                var alinfo = AllianceCache.query_info_sync(pinfo['alliance_id']);
                if(alinfo && alinfo['chat_tag']) {
                    dialog.widgets['subtitle'].str += ' ['+alinfo['chat_tag']+']';
                }
            }
        }
    } else if(from_alliance > 0) {
        var alinfo = AllianceCache.query_info_sync(from_alliance);
        if(alinfo) {
            dialog.widgets['subtitle'].str = alliance_display_name(alinfo);
        }
    }

    dialog.widgets['column_header_time'].show = !!gamedata['client']['battle_history_time_column'];
    dialog.widgets['column_header_location'].show = !!gamedata['client']['battle_history_location_column'];
    dialog.widgets['column_header_outcome'].show = !dialog.widgets['column_header_location'].show;
    dialog.widgets['column_header_status'].str = dialog.data['widgets']['column_header_status'][(gamedata['client']['battle_history_location_column'] ? 'ui_name' : 'ui_name_loot')];

    battle_history_change_chapter(dialog, (from_id < 0 && from_alliance >= 0 ? 'alliance' : ((user_id > 0 && is_ai_user_id_range(user_id)) ? 'ai' : 'human')));

    dialog.ondraw = update_battle_history_dialog;
    return dialog;
};

/** @param {SPUI.Dialog} dialog
    @param {string} chapter */
function battle_history_change_chapter(dialog, chapter) {
    if(dialog.user_data['chapter'] === chapter) { return; }

    dialog.user_data['chapter'] = chapter;
    dialog.widgets['single_player_button'].state = (chapter === 'ai' ? 'active' : 'normal');
    dialog.widgets['multiplayer_button'].state = (chapter === 'human' ? 'active' : 'normal');
    dialog.widgets['alliance_button'].state = (chapter === 'alliance' ? 'active' : (dialog.user_data['from_alliance'] >= 0 ? 'normal' : 'disabled'));

    dialog.widgets['alliancemate_note'].show = (chapter !== 'alliance' && dialog.user_data['alliancemate_flag']);

    dialog.user_data['page'] = -1;
    dialog.user_data['pending'] = false;
    dialog.user_data['enable_buttons'] = true;
    dialog.user_data['sumlist'] = null;
    dialog.user_data['sumlist_is_final'] = true;
    dialog.user_data['sumlist_is_error'] = null;
    dialog.user_data['first_on_page'] = -1;
    dialog.user_data['rowdata'] = [];
    dialog.user_data['rowdata_incomplete'] = true;

    // if player is on the map, query the map so that feature status is accurate
    if(session.region.map_enabled()) {
        dialog.user_data['pending'] = true;
        dialog.user_data['enable_buttons'] = false;
        session.region.call_when_fresh((function(_dialog) { return function() {
            dialog.user_data['enable_buttons'] = true;
            send_battle_history_query(_dialog); // still pending
        }; })(dialog));
    } else {
        send_battle_history_query(dialog);
    }
    scrollable_dialog_change_page(dialog, 0);
}

/** Return timestamp of oldest battle summary in the dialog's sumlist, or -1 if no summaries exist */
/** @param {SPUI.Dialog} dialog */
function battle_history_oldest(dialog) {
    var oldest = -1;
    if(dialog.user_data['sumlist'] !== null) {
        oldest = goog.array.reduce(dialog.user_data['sumlist'], function(oldest, s) {
            return (oldest > 0 ? Math.min(oldest, s['time']) : s['time']);
        }, oldest);
    }
    return oldest;
}

/** @param {SPUI.Dialog} dialog */
function send_battle_history_query(dialog) {
    dialog.user_data['pending'] = true;
    dialog.user_data['sumlist_is_final'] = false;
    dialog.user_data['sumlist_is_error'] = null;
    var oldest = battle_history_oldest(dialog);
    var time_range = (oldest > 0 ? [-1, oldest] : null);
    query_battle_history(dialog.user_data['user_id'], // target of battles
                         (dialog.user_data['chapter'] === 'alliance' ? -1 : dialog.user_data['from_id']), // source of battles
                         (dialog.user_data['chapter'] === 'alliance' || dialog.user_data['alliancemate_flag'] ? dialog.user_data['from_alliance'] : -1), -1, // involved alliances
                         (dialog.user_data['chapter'] === 'alliance' ? 'human' : dialog.user_data['chapter']), // human/ai filter
                         time_range,
                         goog.partial(receive_battle_history_result, dialog, dialog.user_data['chapter'], time_range));
}

var battle_history_receiver = new goog.events.EventTarget();
function query_battle_history(target, source, alliance_A, alliance_B, ai_or_human, time_range, callback) {
    last_query_tag += 1;
    var tag = 'qbh'+last_query_tag.toString();
    // need this adaptor to pull the .result property out of the event object
    battle_history_receiver.listenOnce(tag, (function (_cb) { return function(event) { _cb(event.result, event.signatures, event.is_final, event.is_error); }; })(callback));
    send_to_server.func(["QUERY_BATTLE_HISTORY", target, source, alliance_A, alliance_B, tag, ai_or_human, time_range]);
}
function query_recent_attackers(callback) {
    last_query_tag += 1;
    var tag = 'qra'+last_query_tag.toString();
    // need this adaptor to pull the .result property out of the event object
    battle_history_receiver.listenOnce(tag, (function (_cb) { return function(event) { _cb(event.result); }; })(callback));
    send_to_server.func(["QUERY_RECENT_ATTACKERS", tag]);
}
/** @param {string} base_id
    @param {function((Object<string,?>|null))} callback */
function query_scout_reports(base_id, callback) {
    last_query_tag += 1;
    var tag = 'qsr'+last_query_tag.toString();
    // need this adaptor to pull the .result property out of the event object
    battle_history_receiver.listenOnce(tag, (function (_cb) { return function(event) { _cb(event.result); }; })(callback));
    send_to_server.func(["QUERY_SCOUT_REPORTS", base_id, tag]);
}

function receive_battle_history_result(dialog, q_chapter, q_time_range, sumlist, siglist, is_final, is_error) {
    if(q_chapter != dialog.user_data['chapter']) { return; } // wrong chapter

    // reset jewels on any successful query
    player.new_battle_histories = 0;
    send_to_server.func(["UPDATE_BATTLE_HISTORY_SEEN", server_time]);

    var oldest = battle_history_oldest(dialog);
    if((oldest < 0 && q_time_range) || (oldest > 0 && (!q_time_range || q_time_range[0] != -1 || q_time_range[1] != oldest))) {
        return; // not adjacent to current sumlist
    }

    dialog.user_data['pending'] = false;

    // note: assume summaries are already sorted by age by server

    dialog.user_data['sumlist_is_final'] = is_final;
    dialog.user_data['sumlist_is_error'] = is_error;

    if(dialog.user_data['sumlist'] !== null) {
        dialog.user_data['sumlist'] = dialog.user_data['sumlist'].concat(sumlist);
        dialog.user_data['siglist'] = dialog.user_data['siglist'].concat(siglist);
        scrollable_dialog_change_page(dialog, dialog.user_data['page']);
    } else {
        dialog.user_data['sumlist'] = sumlist;
        dialog.user_data['siglist'] = siglist;
        scrollable_dialog_change_page(dialog, 0);
    }
};

/** @param {SPUI.Dialog} dialog
    @param {number} row
    @param {Object} rowdata */
function battle_history_setup_row(dialog, row, rowdata) {
    dialog.widgets['row_prot'+row].show =
        dialog.widgets['row_cooldown'+row].show =
        dialog.widgets['row_portrait'+row].show =
        dialog.widgets['row_portrait_outline'+row].show =
        dialog.widgets['row_portrait2'+row].show =
        dialog.widgets['row_portrait2_outline'+row].show =
        dialog.widgets['row_name'+row].show =
        dialog.widgets['row_role'+row].show =
        dialog.widgets['row_location'+row].show =
        dialog.widgets['row_outcome'+row].show =
        dialog.widgets['row_loot'+row].show =
        dialog.widgets['row_time'+row].show =
        dialog.widgets['row_log_button'+row].show =
        dialog.widgets['row_revenge_button'+row].show = false;


    if(!rowdata) { return; }
    var signature = rowdata['signature'];
    var myrole, opprole;
    if(rowdata['attacker_id'] == dialog.user_data['from_id']) {
        myrole = 'attacker';
        opprole = 'defender';
    } else if(rowdata['defender_id'] == dialog.user_data['from_id']) {
        myrole = 'defender';
        opprole = 'attacker';
    } else if(dialog.user_data['from_alliance'] >= 0 && rowdata['attacker_alliance_id'] == dialog.user_data['from_alliance']) {
        myrole = 'attacker';
        opprole = 'defender';
    } else if(dialog.user_data['from_alliance'] >= 0 && rowdata['defender_alliance_id'] == dialog.user_data['from_alliance']) {
        myrole = 'defender';
        opprole = 'attacker';
    } else {
        console.log('battle history does not match from_id! att '+rowdata['attacker_id']+' def '+rowdata['defender_id']+' from '+dialog.user_data['from_id']); myrole = 'defender'; opprole = 'attacker';
    }
    var at_quarry = (rowdata['base_type'] == 'quarry');
    var at_hive = (rowdata['base_type'] == 'hive');
    var at_squad = (rowdata['base_type'] == 'squad');
    var at_raid = (rowdata['base_type'].indexOf('raid') === 0);
    var at_my_home = (rowdata['base_type'] == 'home' && rowdata['base_id'] == ('h'+session.user_id.toString()));
    var ladder_state = rowdata['ladder_state'] || null;
    var user_id = rowdata[opprole+'_id'];
    var time_ago = server_time - rowdata['time'];

    // portrait
    dialog.widgets['row_portrait'+row].show = true;
    dialog.widgets['row_portrait_outline'+row].show = (user_id === session.user_id || user_id === rowdata[myrole+'_id']);
    dialog.widgets['row_portrait'+row].set_user(user_id);

    dialog.widgets['row_portrait'+row].onclick =
        dialog.widgets['row_name'+row].onclick = (function (_uid) { return function() {
            if(!is_ai_user_id_range(_uid)) { PlayerInfoDialog.invoke(_uid); }
        }; })(user_id);
    dialog.widgets['row_portrait'+row].tooltip.str = rowdata[opprole+'_name'] + (rowdata[opprole+'_alliance_chat_tag'] ? ' ['+rowdata[opprole+'_alliance_chat_tag']+']' : '')+ ' (L'+rowdata[opprole+'_level'].toString()+')';

    // second portrait (for alliancemates)
    dialog.widgets['row_portrait2'+row].show = (dialog.user_data['chapter'] === 'alliance');
    dialog.widgets['row_portrait2_outline'+row].show = dialog.widgets['row_portrait2'+row].show;

    if(dialog.widgets['row_portrait2'+row].show) {
        dialog.widgets['row_portrait2'+row].set_user(rowdata[myrole+'_id']);
        dialog.widgets['row_portrait2'+row].onclick = (function (_uid) { return function() {
            if(!is_ai_user_id_range(_uid)) { PlayerInfoDialog.invoke(_uid); }
        }; })(rowdata[myrole+'_id']);
        dialog.widgets['row_portrait2'+row].tooltip.str = rowdata[myrole+'_name'] + (rowdata[myrole+'_alliance_chat_tag'] ? ' ['+rowdata[myrole+'_alliance_chat_tag']+']' : '') + ' (L'+rowdata[myrole+'_level'].toString()+')';
    }

    // shift name/role to accommodate second portrait
    goog.array.forEach(['row_portrait', 'row_name', 'row_role'], function(wname) {
        dialog.widgets[wname+row].xy = vec_add(vec_add(dialog.data['widgets'][wname]['xy'],
                                               vec_scale(row, dialog.data['widgets'][wname]['array_offset'])),
                                               (dialog.widgets['row_portrait2'+row].show ? [dialog.data['widgets']['row_portrait2']['dimensions'][0], 0] : [0,0]));
    });

    // name/level
    dialog.widgets['row_name'+row].show = true;
    var clip_to = dialog.data['widgets']['row_name'][(dialog.user_data['chapter'] === 'alliance') ? 'clip_to_alliance' : 'clip_to'];
    dialog.widgets['row_name'+row].clip_to = [clip_to[0], clip_to[1] + row * dialog.data['widgets']['row_name']['array_offset'][1], clip_to[2], clip_to[3]];

    var name_str = rowdata[opprole+'_name'];
    var max_len = dialog.data['widgets']['row_name'][(dialog.user_data['chapter'] === 'alliance') ? 'max_len_alliance' : 'max_len'];
    if(name_str.length >= max_len) {
        name_str = name_str.slice(0, max_len)+'...';
    }
    if(rowdata[opprole+'_alliance_chat_tag']) {
        name_str += ' ['+rowdata[opprole+'_alliance_chat_tag']+']';
    }
    name_str += ' (L'+rowdata[opprole+'_level']+')';
    dialog.widgets['row_name'+row].str = name_str;

    dialog.widgets['row_role'+row].show = true;

    var ui_role = dialog.data['widgets']['row_role']['ui_name_'+(opprole == 'defender' ? 'defender' : 'attacker')];
    var role_color = dialog.data['widgets']['row_role']['text_color'];

    // if no time column, the time goes into the "role" string
    if(!gamedata['client']['battle_history_time_column']) {
        ui_role = dialog.data['widgets']['row_role']['ui_name_time'].replace('%s', ui_role).replace('%d', pretty_print_time_very_brief(time_ago));
    } else {
        // if time column, color the role
        role_color = dialog.data['widgets']['row_role']['text_color_'+opprole];
    }

    dialog.widgets['row_role'+row].str = ui_role;
    dialog.widgets['row_role'+row].text_color = SPUI.make_colorv(role_color);

    var trophy_field = ((rowdata['loot'] && ('trophies_pve' in rowdata['loot'])) ? 'trophies_pve' : (opprole == 'defender' ? 'trophies_pvp' : 'viewing_trophies_pvp'));

    dialog.widgets['row_location'+row].show = !!gamedata['client']['battle_history_location_column'];
    dialog.widgets['row_outcome'+row].show = !gamedata['client']['battle_history_location_column'];

    if(dialog.widgets['row_location'+row].show) {
        dialog.widgets['row_location'+row].onclick = null;

        var base_ui_name = rowdata['base_ui_name'];
        if(base_ui_name) {
            if(at_squad) { base_ui_name = gamedata['strings']['squads']['squad']+' '+base_ui_name; }
            if(at_quarry || at_hive || at_squad || at_raid) {
                if(rowdata['base_map_loc']) {
                    if((at_quarry || at_hive || at_raid) && (!('base_id' in rowdata) || (session.region.data && !session.region.feature_exists_at(rowdata['base_id'], rowdata['base_ui_name'], rowdata['base_map_loc'])))) {
                        base_ui_name += '\n'+dialog.data['widgets']['row_location']['ui_name_'+(at_raid ? 'raid_depleted': (at_quarry ? 'quarry_depleted' : 'hive_destroyed'))];
                    } else {
                        base_ui_name += '\n('+rowdata['base_map_loc'][0].toString()+','+rowdata['base_map_loc'][1].toString()+')';
                        dialog.widgets['row_location'+row].onclick = (function (_loc) { return function() {
                            invoke_region_map(_loc);
                        }; })(rowdata['base_map_loc']);
                    }
                }
            }
        } else {
            if(!at_quarry) {
                base_ui_name = dialog.data['widgets']['row_location']['ui_name'];
            } else {
                base_ui_name = "?";
            }
        }
        // add PvP point delta below location
        if(rowdata['loot'] && rowdata['loot'][trophy_field]) {
            var count = rowdata['loot'][trophy_field];
            base_ui_name += '\n'+dialog.data['widgets']['row_location']['ui_name_points'].replace('%d', (count > 0 ? '+' : '-')+pretty_print_number(Math.abs(count)));
        }

        dialog.widgets['row_location'+row].set_text_with_linebreaking(base_ui_name);
    }

    var myout = rowdata[myrole+'_outcome'];
    var outcome_type;
    if(ladder_state) {
        outcome_type = 'ladder';
    } else if(rowdata['raid_mode']) {
        outcome_type = 'raid_'+rowdata['raid_mode'];
    } else if(at_squad) {
        outcome_type = 'squad';
    } else if(at_quarry) {
        outcome_type = 'quarry';
    } else {
        outcome_type = 'away';
    }
    var ui_outcome = gamedata['strings']['battle_end'][outcome_type][myout]['log_outcome'][myrole];

    // the "outcome" displayed here is the basic You Won/You Lost PLUS battle stars and PvP point delta
    if(dialog.widgets['row_outcome'+row].show) {
        var full_outcome = ui_outcome;
        if(rowdata['attacker_outcome'] == 'victory' && rowdata['loot'] && ('battle_stars' in rowdata['loot'])) {
            var star_count = goog.object.getCount(rowdata['loot']['battle_stars']);
            full_outcome += ' ('+gamedata['strings']['battle_end']['ladder'][(star_count == 1 ? 'stars_singular' : 'stars_plural')].replace('%s', star_count.toString())+')';
        }

        // add PvP point delta
        if(rowdata['loot'] && rowdata['loot'][trophy_field]) {
            var count = rowdata['loot'][trophy_field];
            full_outcome += '\n'+dialog.data['widgets']['row_outcome']['ui_name_points'].replace('%d', (count > 0 ? '+' : '-')+pretty_print_number(Math.abs(count)));
        }
        dialog.widgets['row_outcome'+row].str = full_outcome;
        dialog.widgets['row_outcome'+row].text_color = SPUI.make_colorv(dialog.data['widgets']['row_outcome']['text_color_'+(myout == 'victory' ? 'good' : 'bad')]);
    }


    rowdata['ui_outcome'] = ui_outcome; // save for later
    rowdata['at_quarry'] = at_quarry;
    rowdata['at_squad'] = at_squad;
    rowdata['at_raid'] = at_raid;


    dialog.widgets['row_loot'+row].show = true;
    if(at_quarry || at_squad || rowdata['raid_mode'] === 'scout') {
        // show status instead of loot here
        dialog.widgets['row_loot'+row].str = ui_outcome;
        dialog.widgets['row_loot'+row].text_color = (myout === 'defeat' ? new SPUI.Color(1,0,0,1) : new SPUI.Color(0,0.8,0,1));
    } else {
        dialog.widgets['row_loot'+row].text_color = SPUI.default_text_color;
        var is_lost = false;
        if(session.user_id == rowdata['defender_id']) {
            for(var res in gamedata['resources']) {
                if(rowdata['loot'] && (res+'_lost' in rowdata['loot'])) {
                    is_lost = true;
                }
            }
        }
        var s_list = [];

        for(var res in gamedata['resources']) {
            var amount;
            if(rowdata['loot']) {
                if(is_lost) {
                    amount = rowdata['loot'][res+'_lost']||0;
                } else {
                    if(gamedata['show_uncapped_loot']) {
                        amount = rowdata['loot']['looted_uncapped_'+res] || 0;
                    } else {
                        amount = rowdata['loot'][res] || 0;
                    }
                }
            } else {
                amount = 0;
            }

            if(amount != 0) {
                // Note, we add the minus sign here for lost amounts.
                s_list.push(((is_lost && amount > 0) ? '-' : '') + pretty_print_qty_brief(amount) + ' ' + gamedata['resources'][res]['ui_name']);
            }
        }
        dialog.widgets['row_loot'+row].str = s_list.join('\n');
    }

    if(gamedata['client']['battle_history_time_column']) {
        dialog.widgets['row_time'+row].show = true;
        dialog.widgets['row_time'+row].str = dialog.data['widgets']['row_time']['ui_name'].replace('%s', pretty_print_time_brief(time_ago));
    }

    // View Log button (opprole is for Facebook messaging only)
    var friendly_id = -1;
    if(rowdata['attacker_id'] == session.user_id) {
        friendly_id = rowdata['attacker_id'];
    } else if(rowdata['defender_id'] == session.user_id) {
        friendly_id = rowdata['defender_id'];
    } else if(rowdata['attacker_alliance_id'] > 0 && rowdata['attacker_alliance_id'] == session.alliance_id) {
        friendly_id = rowdata['attacker_id'];
    } else if(rowdata['defender_alliance_id'] > 0 && rowdata['defender_alliance_id'] == session.alliance_id) {
        friendly_id = rowdata['defender_id'];
    } else { // third-party log
        friendly_id = dialog.user_data['from_id'];
    }

    var callback = (function (_rowdata, _signature, _friendly_id) { return function() {
        player.record_feature_use('battle_log');
        invoke_battle_log_dialog(_rowdata, _signature, _friendly_id);
    }; })(rowdata, signature, friendly_id);

    dialog.widgets['row_log_button'+row].show = (player.is_developer() || player.get_any_abtest_value('enable_battle_logs',true));
    dialog.widgets['row_log_button'+row].state = 'normal';
    dialog.widgets['row_log_button'+row].onclick = callback;

    var info = PlayerCache.query_sync(user_id) || {};
    var prot_end_time = (info && ('protection_end_time' in info) ? info['protection_end_time'] : -1);
    var is_protected = (prot_end_time == 1 || prot_end_time > server_time);
    var is_logged_in = (info && info['LOCK_STATE'] == 1);
    var on_cooldown = ('attack_cooldown_expire' in rowdata && rowdata['attack_cooldown_expire'] > server_time);

    if(gamedata['client']['battle_history_show_attackability'] && (dialog.user_data['chapter'] !== 'alliance')) {
        dialog.widgets['row_prot'+row].show = (is_protected || (!player.raids_enabled() && is_logged_in));
        if(dialog.widgets['row_prot'+row].show) {
            dialog.widgets['row_prot'+row].str = dialog.data['widgets']['row_prot'][(player.raids_enabled() ? 'ui_name_prot' : 'ui_name')];
        }
        dialog.widgets['row_cooldown'+row].show = (!is_protected && !is_logged_in && on_cooldown);
        if(dialog.widgets['row_cooldown'+row].show) {
            dialog.widgets['row_cooldown'+row].str = dialog.data['widgets']['row_cooldown']['ui_name'].replace('%s', pretty_print_time_brief(rowdata['attack_cooldown_expire'] - server_time));
        }
    } else {
        dialog.widgets['row_prot'+row].show = dialog.widgets['row_cooldown'+row].show = false;
    }

    // Revenge button
    if(!user_id || is_ai_user_id_range(user_id)) {
        dialog.widgets['row_revenge_button'+row].show = false;
    } else if(session.region && session.region.data && session.region.data['storage'] == 'nosql' && session.region.map_enabled()) {
        dialog.widgets['row_revenge_button'+row].show = false;
        if(info && info['home_region'] == session.region.data['id'] && info['home_base_loc']) {
            dialog.widgets['row_revenge_button'+row].show = true;
            dialog.widgets['row_revenge_button'+row].state = 'normal';
            dialog.widgets['row_revenge_button'+row].str = dialog.data['widgets']['row_revenge_button']['ui_name_find_on_map'];
            dialog.widgets['row_revenge_button'+row].onclick = (function (_loc) { return function(w) {
                change_selection_ui(null);
                invoke_region_map(_loc);
            }; })(info['home_base_loc']);
        }
    } else {
        // only say "Revenge" if we can actually do a revenge attack
        var can_revenge = (player.cooldown_active('revenge_defender:'+user_id.toString()) &&
                           !is_protected && !is_logged_in && !on_cooldown &&
                           !(session.is_in_alliance() && session.alliance_id === info['alliance_id']));
        if(can_revenge) {
            dialog.widgets['row_revenge_button'+row].show = true;
            dialog.widgets['row_revenge_button'+row].bg_image = dialog.data['widgets']['row_revenge_button']['bg_image'+(can_revenge?'':'_spy')];
            dialog.widgets['row_revenge_button'+row].str = dialog.data['widgets']['row_revenge_button']['ui_name'+(can_revenge?'':'_spy')];
            dialog.widgets['row_revenge_button'+row].state = (can_revenge ? 'attack' : 'normal');

            dialog.widgets['row_revenge_button'+row].onclick = (function (_uid) { return function(w) {
                change_selection(null);
                visit_base(_uid);
            }; })(user_id);
        } else {
            dialog.widgets['row_revenge_button'+row].show = false;
        }
    }
}


/** @param {SPUI.Dialog} dialog */
function update_battle_history_dialog(dialog) {

    if(dialog.user_data['sumlist_is_error'] === 'offline') {
        dialog.widgets['loading_spinner'].show = false;
        dialog.widgets['loading_rect'].show =
            dialog.widgets['loading_text'].show = true;
        dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name_error'];
    } else if(dialog.user_data['sumlist'] !== null && dialog.user_data['sumlist'].length === 0) {
        dialog.widgets['loading_spinner'].show = false;
        dialog.widgets['loading_rect'].show =
            dialog.widgets['loading_text'].show = true;
        dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name_empty'];
    } else if(dialog.user_data['pending']) {
        dialog.widgets['loading_rect'].show =
            dialog.widgets['loading_spinner'].show =
            dialog.widgets['loading_text'].show = true;
        dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name'];
    } else {
        dialog.widgets['loading_rect'].show =
            dialog.widgets['loading_spinner'].show =
            dialog.widgets['loading_text'].show = false;
    }
    if(dialog.user_data['sumlist'] !== null && dialog.user_data['sumlist'].length > 0) {
        dialog.user_data['rowdata'] = [];
        for(var i = 0; i < dialog.user_data['sumlist'].length; i++) {
            var new_sum = null;
            new_sum = dialog.user_data['sumlist'][i];
            new_sum['signature'] = dialog.user_data['siglist'][i];
            dialog.user_data['rowdata'].push(new_sum);
        }
    }
    dialog.widgets['partial_error'].show = (dialog.user_data['sumlist_is_error'] === 'partial');

    // note: currently, AI battles do not record involved_alliances, so cannot be looked up for alliancemates.
    dialog.widgets['single_player_button'].show = dialog.user_data['enable_buttons'] && (dialog.user_data['user_id'] <= 0) && !dialog.user_data['alliancemate_flag'] && (dialog.user_data['from_id'] >= 0);

    dialog.widgets['multiplayer_button'].show = dialog.user_data['enable_buttons'] && (dialog.user_data['user_id'] <= 0) && (dialog.user_data['from_id'] >= 0);
    dialog.widgets['alliance_button'].show = eval_cond_or_literal(gamedata['client']['enable_alliance_battle_history'], player, null) && dialog.user_data['enable_buttons'] && (dialog.user_data['user_id'] <= 0) && (dialog.user_data['from_alliance'] >= 0 || dialog.user_data['from_id'] === session.user_id) && (dialog.user_data['from_id'] >= 0);
    if(dialog.widgets['alliance_button'].show && dialog.user_data['from_alliance'] < 0) {
        // for the player, who is not in an alliance
        dialog.widgets['alliance_button'].tooltip.str = dialog.data['widgets']['alliance_button']['ui_tooltip_no_alliance'];
    }

    // zoom effect
    animate_dialog_zoom_effect(dialog, dialog.user_data['zoom_from_widget']);

    var page = dialog.user_data['page'];
    var chapter_battles = (dialog.user_data['sumlist'] !== null ? dialog.user_data['sumlist'].length : 0)
    var rows_per_page = dialog.user_data['rows_per_page'];
    var chapter_pages = Math.floor(chapter_battles + rows_per_page - 1);
    var query_threshold = rows_per_page * 5;
    if(chapter_battles > 0) {
        dialog.widgets['scroll_text'].show = true;
    }

    // need to get more from server?
    // note: send query on the page before the data ends, so we never show an incomplete page, unless it's the final one.
    if(chapter_pages > 0 && page > 0 && page >= (chapter_pages - query_threshold) &&
       dialog.user_data['sumlist'] !== null &&
       !dialog.user_data['sumlist_is_final'] &&
       !dialog.user_data['sumlist_is_error'] &&
       !dialog.user_data['pending']) {
        send_battle_history_query(dialog);
    }

    if(dialog.user_data['sumlist_is_final'] && !dialog.user_data['sumlist_is_error']) {
        dialog.user_data['rowdata_incomplete'] = false;
    }
    if(chapter_pages > 0 && dialog.user_data['sumlist'] !== null) {
        dialog.user_data['rowdata'] = [];
        for(var i = 0; i < dialog.user_data['sumlist'].length; i++) {
            var new_sum = null;
            new_sum = dialog.user_data['sumlist'][i];
            new_sum['signature'] = dialog.user_data['siglist'][i];
            dialog.user_data['rowdata'].push(new_sum);
        }
    }
    scrollable_dialog_change_page(dialog, page)
};

/** scrolls battle log by the amount and direction of delta
    @param {SPUI.Dialog|null} dialog
    @param {number} delta
*/
function scroll_battle_log(dialog, delta){
    // error catching to prevent attempting to scroll if not receiving a dialog or a delta
    if (!dialog || !delta) { return; }
    if(dialog.user_data['log']) {
        if (delta < 0 && dialog.widgets['log'].can_scroll_up()) {
            dialog.widgets['log'].scroll_up();
            battle_log_change_page(dialog, dialog.user_data['page'] - 1);
        } else if (delta > 0 && dialog.widgets['log'].can_scroll_down()) {
            dialog.widgets['log'].scroll_down();
            battle_log_change_page(dialog, dialog.user_data['page'] + 1);
        }
    }
}

/** @param {Object} summary
    @param {Object} signature
    @param {number} friendly_id - the "good guy" in this battle - not necessarily the viewing player */
function invoke_battle_log_dialog(summary, signature, friendly_id) {
    if(!summary) {
        throw Error ('Battle log called with without summary');
    }
    var dialog = new SPUI.Dialog(gamedata['dialogs']['battle_log_dialog']);
    dialog.user_data['dialog'] = 'battle_log_dialog';
    dialog.user_data['friendly_id'] = friendly_id;
    dialog.user_data['time'] = summary['time'];
    dialog.user_data['summary'] = summary;
    dialog.user_data['signature'] = signature;
    dialog.user_data['log'] = null;
    dialog.user_data['page'] = -1;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.on_mousewheel_function = scroll_battle_log;
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    dialog.widgets['screenshot_button'].show = post_screenshot_enabled();
    dialog.widgets['screenshot_button'].onclick = function(w) {
        var dialog = w.parent;
        invoke_post_screenshot(dialog, /* reason = */ dialog.user_data['dialog'],
                               (dialog.user_data['friendly_id'] === session.user_id ? make_post_screenshot_caption(dialog.data['widgets']['screenshot_button']['ui_caption'], player.get_player_cache_props()) : null));
    };

    // pre-fill summary info
    if((summary['at_quarry'] || summary['at_squad'] || summary['at_raid']) && summary['base_ui_name']) {
        dialog.widgets['location'].show = true;
        dialog.widgets['location'].set_text_with_linebreaking(summary['base_ui_name']);
    } else if('base_damage' in summary) {
        dialog.widgets['base_damage'].show = dialog.widgets['base_damage_label'].show = true;
        dialog.widgets['base_damage'].str = Math.floor(100.0*summary['base_damage']).toFixed(0)+'%';
    }

    dialog.widgets['outcome'].str = summary['ui_outcome'];
    if(summary['loot'] && 'battle_stars' in summary['loot']) {
        var star_count = goog.object.getCount(summary['loot']['battle_stars']);
        if(star_count > 0) {
            dialog.widgets['outcome'].str += '\n(' + gamedata['strings']['battle_end']['ladder'][(star_count==1? 'stars_singular':'stars_plural')].replace('%s', star_count.toString()) + ')';
        }
    }

    // Facebook messaging for trash talk
    var messageable_opponent_id = (summary['defender_id'] === session.user_id ? summary['attacker_id'] : summary['defender_id']);
    var messageable_opponent_fbid =  (summary['defender_id'] === session.user_id ? summary['attacker_facebookd_id'] : summary['defender_facebook_id']);
    dialog.widgets['message_button'].show = (!!summary['facebook_friends'] && (spin_frame_platform == 'fb') && (summary['defender_id'] === session.user_id || summary['attacker_id'] === session.user_id) && messageable_opponent_fbid);
    dialog.widgets['message_button'].onclick = goog.partial(invoke_facebook_message_dialog, messageable_opponent_fbid, messageable_opponent_id);

    var is_lost = false;
    if(summary['loot']) {
        goog.object.forEach(gamedata['resources'], function(resdata, resname) {
            if(!('loot_'+resname in dialog.widgets)) { return; }
            var amount;
            if(dialog.user_data['friendly_id'] == summary['defender_id'] && (resname+'_lost' in summary['loot'])) {
                // display LOST, not LOOTED, if available
                amount = summary['loot'][resname+'_lost'];
                is_lost = true;
            } else {
                if(gamedata['show_uncapped_loot']) {
                    amount = summary['loot']['looted_uncapped_'+resname] || 0;
                } else {
                    amount = summary['loot'][resname] || 0;
                }
            }

            dialog.widgets['loot_'+resname+'_label'].show = dialog.widgets['loot_'+resname].show = !!amount;
            if(amount) {
                dialog.widgets['loot_'+resname].str = pretty_print_number(amount);
                dialog.widgets['loot_'+resname+'_label'].str = dialog.data['widgets']['loot_'+resname+'_label']['ui_name'+(is_lost?'_lost':'')].replace('%RES', resdata['ui_name']);
            }
        });
    }

    var trophy_field = ((summary['loot'] && ('trophies_pve' in summary['loot'])) ? 'trophies_pve' : (dialog.user_data['friendly_id'] == summary['defender_id'] ? 'viewing_trophies_pvp' : 'trophies_pvp'));
    var trophy_delta = (summary['loot'] ? (summary['loot'][trophy_field] || 0) : 0);

    if(trophy_delta != 0) {
        dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_sunken'].show =
            dialog.widgets['trophy_shine'].show =
            dialog.widgets['trophy_amount'].show = true;
        var sign = (trophy_delta > 0 ? 'plus' : 'minus');
        dialog.widgets['trophy_icon'].state = ((summary['loot'] && ('trophies_pve' in summary['loot'])) ? 'pve' : 'pvp');
        dialog.widgets['trophy_amount'].str = dialog.data['widgets']['trophy_amount']['ui_name_'+sign].replace('%d', pretty_print_number(Math.abs(trophy_delta)));
        dialog.widgets['trophy_amount'].text_color = SPUI.make_colorv(dialog.data['widgets']['trophy_amount']['text_color_'+sign]);
    }


    var roles = ['attacker', 'defender'];
    for(var i = 0; i < roles.length; i++) {
        var role = roles[i];
        dialog.widgets[role+'_portrait'].set_user(summary[role+'_id']);
        dialog.widgets[role+'_portrait'].set_user_level(summary[role+'_level']);

        dialog.widgets[role+'_portrait'].onclick = (function (_uid) { return function() {
            PlayerInfoDialog.invoke(_uid);
        } })(summary[role+'_id']);

        var name_str = summary[role+'_name'];
        var max_len = dialog.data['widgets'][role+'_name']['max_len'];
        if(name_str.length > max_len) {
            name_str = name_str.slice(0, max_len)+'...';
        }
        if(summary[role+'_alliance_chat_tag']) {
            name_str += ' ['+summary[role+'_alliance_chat_tag']+']';
        }
        dialog.widgets[role+'_name'].str = name_str;
    }
    dialog.widgets['time_since_battle'].str = dialog.data['widgets']['time_since_battle'][(summary['raid_mode'] === 'scout' || summary['raid_mode'] === 'pickup') ? 'ui_name_encounter' : 'ui_name_battle'].replace('%s', pretty_print_time_brief(server_time - summary['time']));
    dialog.widgets['revenge_note'].str = summary['is_revenge'] ? dialog.data['widgets']['revenge_note']['ui_name_revenge'] : null;
    if('duration' in summary && summary['duration']) {
        dialog.widgets['battle_duration'].str = dialog.data['widgets']['battle_duration']['ui_name'].replace('%s', pretty_print_time(summary['duration']));
    } else {
        dialog.widgets['battle_duration'].str = null;
    }

    dialog.widgets['scroll_up'].state = 'disabled';
    dialog.widgets['scroll_down'].state = 'disabled';

    battle_log_change_page(dialog, 0);

    if(summary['battle_type'] === 'raid') {
        receive_battle_log_result(dialog, {'log': RaidBattleLog.from_summary(summary)});
    } else {
        dialog.widgets['loading_rect'].show =
            dialog.widgets['loading_text'].show = true;
        get_battle_log(summary['time'], summary['attacker_id'], summary['defender_id'], summary['base_id'] || null, signature,
                       (function (_dialog) { return function(result) { receive_battle_log_result(_dialog, result); }; })(dialog));
    }

    return dialog;
};

var battle_log_receivers = {};
/** @param {number} battle_time
    @param {number} attacker_id
    @param {number} defender_id
    @param {string|null} base_id
    @param {Object} signature
    @param {function()=} cb */
function get_battle_log(battle_time, attacker_id, defender_id, base_id, signature, cb) {
    last_query_tag += 1;
    var tag = 'gbl'+last_query_tag.toString();
    battle_log_receivers[tag] = cb;
    send_to_server.func(["GET_BATTLE_LOG3", battle_time, attacker_id, defender_id, base_id, signature, tag]);
};

// given a battle summary, determine if we can show a replay (doesn't check for actual existence)
function can_show_replay_for_battle_summary(summary) {
    var can_show_replay = false;
    if(!read_predicate(gamedata['client']['enable_replay_playback']).is_satisfied(player, null)) { return can_show_replay; }
    var their_replay_version = summary['replay_version'] || 0;
    var cur_replay_version = gamedata['replay_version'] || 0;
    can_show_replay = their_replay_version === cur_replay_version;
    if (can_show_replay && 'time' in summary && 'replay_oldest_timestamp' in gamedata) {
        can_show_replay = summary['time'] >= gamedata['replay_oldest_timestamp'];
    }
    return can_show_replay;
}

/** @param {!SPUI.Dialog} dialog
    @param {Object<string,*>} battle_summary
    @param {string} replay_signature
    @param {string} attacker_name
    @param {string} defender_name

    Drives a "Share replay on Facebook" button on the UI.
    Common code for both the battle_log and fancy_victory dialogs.
*/
function set_up_replay_sharing_button(dialog, battle_summary, replay_signature, attacker_name, defender_name) {
    // initialize to blank state
    dialog.widgets['fb_share_button'].show =
        dialog.widgets['fb_share_icon'].show =
        dialog.widgets['fb_share_incentive_icon'].show = false;

    // get the URL link for sharing a battle replay
    var link_qs = battle_replay_link_qs(
        /** @type {number} */ (battle_summary['time']),
        /** @type {number} */ (battle_summary['attacker_id']),
        /** @type {number} */ (battle_summary['defender_id']),
        /** @type {string|null} */ (battle_summary['base_id']),
        replay_signature);

    if(!link_qs || !FBShare.supported()) {
        // no link or FB sharing is not available. Nothing to do.
        return;
    }

    // show button and icon
    dialog.widgets['fb_share_button'].show =
        dialog.widgets['fb_share_icon'].show = true;

    var text = gamedata['virals']['replay']['ui_post_headline'].replace('%ATTACKER', attacker_name).replace('%DEFENDER', defender_name);

    dialog.widgets['fb_share_button'].onclick = (function (_link_qs, _text) { return function(w) {
        FBShare.invoke({link_qs: _link_qs, name: _text, ref: 'replay'});
    }; })(link_qs, text);

    if(!gamedata['show_fb_share_replay_incentive']) {
        // checks for the fb_share_replay_incentive flag in main_options.json. If not there, the flashing icon is not needed.
        // Nothing to do.
        return;
    }

    // Check if a quest named "share_battle_replay" or "share_battle_replay_again" exists, is active, but is not complete yet.
    // If so, show the incentive icon on top of the button.

    goog.array.forEach(['share_battle_replay', 'share_battle_replay_again'], function(quest_name) {
        if(quest_name in gamedata['quests'] &&
           player.can_activate_quest(gamedata['quests'][quest_name]) &&
           !player.can_complete_quest(gamedata['quests'][quest_name])) {
            dialog.widgets['fb_share_incentive_icon'].show = true;
        }
    });
}

/** @param {!SPUI.Dialog} dialog
    @param {Object|null} ret */
function receive_battle_log_result(dialog, ret) {
    var log, replay_exists;
    if(!ret) {
        dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name_unavailable'];
        log = null;
        replay_exists = false;
    } else {
        log = ret['log'];
        replay_exists = ret['replay_exists'];
    }


    dialog.widgets['loading_rect'].show =
        dialog.widgets['loading_text'].show = false;
    dialog.widgets['scroll_text'].show = true;

    dialog.user_data['log'] = log;

    if(!log) {
        dialog.widgets['log'].append_text([[new SPText.ABlock(dialog.data['widgets']['loading_text']['ui_name_unavailable'], null)]]);
    } else {
        var parsed = BattleLog.parse(dialog.user_data['friendly_id'], session.user_id, dialog.user_data['summary'], dialog.user_data['log']);
        dialog.widgets['log'].max_lines = parsed.length+10;
        for(var line = 0; line < parsed.length; line++) {
            dialog.widgets['log'].append_text(parsed[line]);
        }

        // see if we can show deployment markers for this
        var summary = dialog.user_data['summary'];

        if(replay_exists && can_show_replay_for_battle_summary(summary)) {
            dialog.widgets['replay_button'].show = true;
            dialog.widgets['replay_button'].onclick = function(w) {
                var dialog = w.parent;
                var summary = dialog.user_data['summary'];
                var fail_cb = (function (_dialog) { return function() {
                    _dialog.widgets['replay_button'].state = 'disabled';
                    _dialog.widgets['replay_button'].tooltip.str = _dialog.data['widgets']['replay_button']['ui_tooltip_unavailable'];
                }; })(dialog);

                download_and_play_replay(summary['time'], summary['attacker_id'], summary['defender_id'], summary['base_id'],
                                         dialog.user_data['signature'], fail_cb);
            };

            set_up_replay_sharing_button(dialog, summary, dialog.user_data['signature'], dialog.widgets['attacker_name'].str, dialog.widgets['defender_name'].str);
        }
    }
    dialog.widgets['log'].scroll_to_top();

    battle_log_change_page(dialog, 0);
};

/** @param {number} battle_time
    @param {number} attacker_id
    @param {number} defender_id
    @param {string|null} base_id
    @param {string|null} signature
    @return {!Object<string,string>} */
function battle_replay_link_qs(battle_time, attacker_id, defender_id, base_id, signature) {
    // see server's AttackReplayReceiver
    var at = ((base_id && base_id.charAt(0) != 'h') ? '-at-'+base_id : '');
    var ret = {'replay': '%TIME-%ATTACKER-vs-%DEFENDER%AT'
               .replace('%TIME', battle_time.toString())
               .replace('%ATTACKER', attacker_id.toString())
               .replace('%DEFENDER', defender_id.toString())
               .replace('%AT', at)};
    if(signature) {
        ret['replay_signature'] = signature;
    }
    return ret;
}
/** @param {number} battle_time
    @param {number} attacker_id
    @param {number} defender_id
    @param {string|null} base_id
    @param {string|null} signature
    @return {string} */
function battle_replay_link_url(battle_time, attacker_id, defender_id, base_id, signature) {
    var link_qs = battle_replay_link_qs(battle_time, attacker_id, defender_id, base_id, signature);

    // strip existing query string out of game container URL
    var container = spin_game_container;
    var q_index = container.indexOf('?');
    if(q_index > 0) {
        container = container.substr(0, q_index);
    }
    var ret = container+'?replay='+link_qs['replay'];
    if(link_qs['replay_signature']) {
        ret += '&replay_signature='+encodeURIComponent(link_qs['replay_signature']);
    }
    return ret;
}

/** Download and start playing a replay. This handles locking the GUI during the round-trip,
    and displays an error message if the replay is not available. fail_cb can be used for additional cleanup.
    @param {number} battle_time
    @param {number} attacker_id
    @param {number} defender_id
    @param {string|null} base_id
    @param {string|null} signature
    @param {function()=} fail_cb */
function download_and_play_replay(battle_time, attacker_id, defender_id, base_id, signature, fail_cb) {
    last_query_tag += 1;
    var tag = 'gbr'+last_query_tag.toString();
    var locker = invoke_ui_locker_until_closed();
    battle_log_receivers[tag] = (function (_locker, _fail_cb) { return function (result) {
        close_dialog(_locker);
        if(result) {
            var pack = unwrap_and_uncompress_string(result[0], result[1]); // codec, z_result
            var replay_player = BattleReplay.replay_from_download(pack);
            if(replay_player) {
                session.push_world(replay_player.world);

                // kill desktop dialogs
                // need special handling for user_log since it is parented to desktop_top
                user_log.parent.unparent(user_log);
                SPUI.root.add(user_log);
                goog.array.forEach(['attack_button_dialog','aura_bar','combat_damage_bar','desktop_bottom','desktop_top','enemy_portrait_dialog','enemy_resource_bars','player_portrait_dialog','quest_bar'], function(dname) {
                    if(dname in desktop_dialogs) {
                        close_dialog(desktop_dialogs[dname]);
                        delete desktop_dialogs[dname];
                    }
                });
                init_playfield_speed_bar(replay_player); // but add speed bar

                // set up overlay GUI
                change_selection(null);
                var link_url = battle_replay_link_url(battle_time, attacker_id, defender_id, base_id, signature);
                var link_qs = battle_replay_link_qs(battle_time, attacker_id, defender_id, base_id, signature);
                var replay_overlay = BattleReplayGUI.invoke(replay_player, link_url, link_qs);
                replay_overlay.on_destroy = function() {
                    session.pop_to_real_world();
                    update_player_combat_time_scale(0);

                    // kick tutorial back into action
                    if(player.tutorial_state !== "COMPLETE") {
                        player.tutorial_hold = false;
                        tutorial_step(true);
                    }

                    init_desktop_dialogs();
                };
                return;
            }
        }

        // failure to download or play
        if(player.tutorial_state == "COMPLETE") {
            var s = gamedata['errors']['REPLAY_NOT_AVAILABLE'];
            invoke_child_message_dialog(s['ui_title'], s['ui_name'], {'dialog': 'message_dialog_big'});
        }

        if(_fail_cb) {
            _fail_cb();
        }

    }; })(locker, fail_cb);
    send_to_server.func(["GET_BATTLE_REPLAY", battle_time, attacker_id, defender_id, base_id, signature, tag]);
};

function battle_log_change_page(dialog, page) {
    // resize output area
    var show_ports;

    // XXX temp until scrolling gets better
    dialog.widgets['scroll_text'].show = 0;
    show_ports = true;
    dialog.widgets['log'].xy[1] = 172;
    dialog.widgets['log'].wh[1] = 221;

    /*
      show_ports = false;
      dialog.widgets['log'].xy[1] = 80;
      dialog.widgets['log'].wh[1] = 313;
    */

    dialog.widgets['attacker_portrait'].show =
        dialog.widgets['attacker_name'].show =
        dialog.widgets['attacker_type'].show =
        dialog.widgets['time_since_battle'].show =
        dialog.widgets['revenge_note'].show =
        dialog.widgets['defender_portrait'].show =
        dialog.widgets['defender_name'].show =
        dialog.widgets['defender_type'].show =
        dialog.widgets['battle_duration'].show = show_ports;

    // set clickability of scroll arrows
    if(dialog.user_data['log']) {
        if(dialog.widgets['log'].can_scroll_up()) {
            dialog.widgets['scroll_up'].state = 'normal';
        } else {
            dialog.widgets['scroll_up'].state = 'disabled';
        }

        if(dialog.widgets['log'].can_scroll_down()) {
            dialog.widgets['scroll_down'].state = 'normal';
        } else {
            dialog.widgets['scroll_down'].state = 'disabled';
        }

        dialog.widgets['scroll_up'].onclick = function(w) {
            var _dialog = w.parent;
            _dialog.widgets['log'].scroll_up();
            battle_log_change_page(_dialog, _dialog.user_data['page'] - 1);
        };
        dialog.widgets['scroll_down'].onclick = function(w) {
            var _dialog = w.parent;
            _dialog.widgets['log'].scroll_down();
            battle_log_change_page(_dialog, _dialog.user_data['page'] + 1);
        };
    }

    return dialog;
};


// keep a dictionary of callbacks awaiting query results for player scores and score leaders,
// indexed by tags so we can send the results to the right callback
var last_query_tag = 1234;
var score_leaders_receivers = {};
var search_player_cache_receivers = {};
var player_scores_receivers = {};
var rivals_receivers = {};
var last_rivals_query_time = -1;
var quarry_receivers = {};
var last_quarry_query_time = -1;
var region_pop_receivers = {};

/** @constructor @struct
 @param {string} stat
 @param {!Object<string,Array<(number|string)>>} axes
 @param {number} sort_order */
function Scores2QueryAddr(stat, axes, sort_order) {
    this.stat = stat;
    this.axes = axes;
    this.sort_order = sort_order;
}

/** @param {string} stat
    @param {string} time_scope
    @param {Object<string,string>|null=} extra_axes

    Tell Scores2 exactly what time/space point we want, for legacy code that only specifies the time scope.
    (Mimic behavior of server-side function for legacy code)

    @return {!Scores2QueryAddr}
*/
function scores2_query_addr(stat, time_scope, extra_axes) {
    var axes = {};
    if(time_scope === 'week') {
        // query current week
        axes['time'] = ['week', // Scores2.FREQ_WEEK
                        current_pvp_week()];
    } else if(time_scope === 'season') {
        // query current season
        axes['time'] = ['season', // Scores2.FREQ_SEASON
                        current_pvp_season()];
    } else if(time_scope === 'ALL') {
        // query all time
        axes['time'] = ['ALL', // Scores2.FREQ_ALL
                        0];
    } else {
        throw Error('unhandled time_scope ' +time_scope);
    }

    // look up the leaderboard score_fields entry
    var entry = gamedata['leaderboard']['score_fields'][stat];
    var sort_order = (entry && entry['method'] === 'min') ? 1 : -1;

    if(extra_axes) {
        // add extra axes
        goog.object.extend(axes, extra_axes);
    }

    // space scope

    // some stats are by default region-specific, depending on the score_fields entry
    if(entry && session.region.data && entry['region_specific'] && entry['leaderboard_query_is_region_specific'] !== 0) {
        axes['space'] = ['region', // Scores2.SPACE_REGION,
                         session.region.data['id']];
    } else {
        // otherwise default to the "wide space": continent for continent-based games, otherwise ALL
        var scores2_wide_space = gamedata['matchmaking']['scores2_wide_space'] || 'ALL';
        if(scores2_wide_space === 'continent' && player.home_continent()) {
            axes['space'] = ['continent', // Scores2.SPACE_CONTINENT
                             player.home_continent()];
        } else {
            axes['space'] = ['ALL', // Scores2.SPACE_ALL
                             '0']; // Scores2.SPACE_ALL_LOC
        }
    }
    return new Scores2QueryAddr(stat, axes, sort_order);
};

/** @param {string} stat
    @param {string} time_scope
    @param {Object<string,string>|null} extra_axes
    @param {number} limit
    @param {function(string, Object<string,?>, ?)} callback
*/
function query_score_leaders(stat, time_scope, extra_axes, limit, callback) {
    last_query_tag += 1;
    var tag = 'qsl'+last_query_tag.toString();
    score_leaders_receivers[tag] = (function (_callback) {
        // adapt new server return format to legacy callback arguments
        return function (stat, axes, result) {
            _callback(stat, axes['time'][0], result); // trim down to just the time_scope
        }; })(callback);
    var query_addr = scores2_query_addr(stat, time_scope, extra_axes);
    send_to_server.func(["QUERY_SCORE_LEADERS2", query_addr.stat, query_addr.axes, query_addr.sort_order, tag, limit]);
};

/** @param {Array<number>} id_list - list of player IDs
    @param {Array<string>} fields  - list of [['damage_inflicted', 'week', (optional time_loc override)]], ...]
    @param {function(Array)} callback
    @param {{get_rank: boolean}|null=} props */
function query_player_scores(id_list, fields, callback, props) {
    var get_rank = !!(props && props.get_rank);
    last_query_tag += 1;
    var tag = 'qps'+last_query_tag.toString();
    player_scores_receivers[tag] = callback;
    // convert fields to new-style stat_axes_list
    var stat_axes_list = goog.array.map(fields, function(stat_time_scope) {
        var stat = stat_time_scope[0], time_scope = stat_time_scope[1];
        var query_addr = scores2_query_addr(stat, time_scope);
        if(stat_time_scope.length >= 3) {
            var override_time_loc = stat_time_scope[2];
            query_addr.axes['time'][1] = override_time_loc;
        }
        return [query_addr.stat, query_addr.axes, query_addr.sort_order];
    });
    send_to_server.func(["QUERY_PLAYER_SCORES2", id_list, stat_axes_list, tag, get_rank]);
}
/** @param {Array<number>} id_list - list of player IDs
    @param {Array<Scores2QueryAddr>} query_addr_list
    @param {function(Array)} callback
    @param {{get_rank: boolean}|null=} props */
function query_player_scores2(id_list, query_addr_list, callback, props) {
    var get_rank = !!(props && props.get_rank);
    last_query_tag += 1;
    var tag = 'qps'+last_query_tag.toString();
    player_scores_receivers[tag] = callback;
    var stat_axes_list = goog.array.map(query_addr_list, function(addr) {
        return [addr.stat, addr.axes, addr.sort_order];
    });
    send_to_server.func(["QUERY_PLAYER_SCORES2", id_list, stat_axes_list, tag, get_rank]);
}

function search_player_cache(terms, callback) {
    last_query_tag += 1; var tag = 'spc'+last_query_tag.toString();
    search_player_cache_receivers[tag] = callback;
    send_to_server.func(["SEARCH_PLAYER_CACHE", SPHTTP.wrap_string(terms), tag]);
}
function query_rivals(callback, include_battled) {
    if(last_rivals_query_time == 0 ||
       (last_rivals_query_time > 0 && client_time < (last_rivals_query_time + gamedata['rival_query_cooldown']))) { return; }
    last_rivals_query_time = 0;
    last_query_tag += 1;
    var tag = 'qr'+last_query_tag.toString();
    rivals_receivers[tag] = callback;
    send_to_server.func(["QUERY_RIVALS", include_battled, tag]);
}
function query_quarries(callback, updated_since) {
    if(last_quarry_query_time == 0 ||
       (last_quarry_query_time > 0 && client_time < (last_quarry_query_time + gamedata['rival_query_cooldown']))) { return false; }
    last_quarry_query_time = 0;
    last_query_tag += 1;
    var tag = 'quar'+last_query_tag.toString();
    if(callback) { quarry_receivers[tag] = callback; }
    send_to_server.func(["QUARRY_QUERY", tag, updated_since]);
    return true;
}
function query_region_pop(callback) {
    last_query_tag += 1;
    var tag = 'pop'+last_query_tag.toString();
    region_pop_receivers[tag] = callback;
    send_to_server.func(["REGION_POP_QUERY", tag]);
}

var achievements_receivers = {};
function query_achievements(user_id, cb) {
    last_query_tag += 1;
    var tag = 'qa'+last_query_tag.toString();
    achievements_receivers[tag] = cb;
    send_to_server.func(["QUERY_ACHIEVEMENTS", user_id, tag]);
}

// achievement sorting function
// put completed achievements first, then rank by display order
// for COMPLETED achievements, "awesomer" ones are ranked HIGHER
// for INCOMPLETE achievements, "awesomer" ones are ranked LOWER
function compare_achievements(_achdata) {
    return function(a,b) {
        var order = 1;
        var ap = (('ui_priority' in a) ? a['ui_priority'] : (('fb_open_graph' in a) && ('display_order' in a['fb_open_graph']) ? a['fb_open_graph']['display_order'] : 0));
        var bp = (('ui_priority' in b) ? b['ui_priority'] : (('fb_open_graph' in b) && ('display_order' in b['fb_open_graph']) ? b['fb_open_graph']['display_order'] : 0));

        if((a['name'] in _achdata) && !(b['name'] in _achdata)) {
            return -order;
        } else if(!(a['name'] in _achdata) && (b['name'] in _achdata)) {
            return order;
        } else if(ap > bp) {
            return -order;
        } else if(ap < bp) {
            return order;
        } else {
            return 0;
        }
    };
}

/** @param {string|null=} force_period
    @param {string|null=} force_mode
    @param {string|null=} force_chapter */
function invoke_leaderboard(force_period, force_mode, force_chapter) {
    player.record_feature_use('leaderboard');

    var dialog = new SPUI.Dialog(gamedata['dialogs']['leaderboard_dialog']);
    dialog.user_data['dialog'] = 'leaderboard_dialog';
    dialog.user_data['friend_id_list'] = null;
    dialog.user_data['enable_tokens'] = false;
    dialog.user_data['self'] = []; // score rows
    dialog.user_data['self_queries'] = {}; // field_freq -> 1(inflight),2(landed)
    dialog.user_data['chapter'] = null;
    dialog.user_data['period'] = gamedata['matchmaking']['ladder_point_frequency'];
    dialog.user_data['mode'] = 'all';
    dialog.user_data['page'] = -1;
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.ondraw = update_leaderboard_dialog;
    dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };

    // see if a token-based event is going on
    var event_data = player.get_event_data('current_event');
    if(event_data) {
        dialog.user_data['enable_tokens'] = !!event_data['enable_token_leaderboard'];
    }

    dialog.user_data['periods'] = ['week', 'season', 'ALL'];
    dialog.user_data['categories'] = [];

    goog.object.forEach(gamedata['strings']['leaderboard']['categories'], function(data, name) {
        var enabled = ('leaderboard_show_if' in data && read_predicate(data['leaderboard_show_if']).is_satisfied(player, null));
        if(name == 'money_spent' && player.enable_muffins) { enabled = true; }
        if(enabled) {
            dialog.user_data['categories'].push(name);
        }
    });
    dialog.user_data['categories'].reverse(); // make buttons match order in strings.json left-to-right

    for(var i = 0; i < dialog.data['widgets']['category_button']['array'][0]; i++) {
        if(i >= dialog.user_data['categories'].length) {
            dialog.widgets['category_button'+i.toString()].show = false;
            continue;
        }
        var data = gamedata['strings']['leaderboard']['categories'][dialog.user_data['categories'][i]];
        dialog.widgets['category_button'+i.toString()].show = true;
        dialog.widgets['category_button'+i.toString()].str = data['short_title'];
        dialog.widgets['category_button'+i.toString()].onclick = (function (_cat) { return function(w) { leaderboard_change_page(w.parent, null, null, _cat, 0); }; })(dialog.user_data['categories'][i]);
    }

    dialog.widgets['show_friends'].onclick = function(w) { leaderboard_change_page(w.parent, null, 'friends', null, 0); };
    dialog.widgets['show_all'].onclick = function(w) { leaderboard_change_page(w.parent, null, 'all', null, 0); };
    dialog.widgets['show_week'].onclick = function(w) { leaderboard_change_page(w.parent, 'week', null, null, 0); };
    dialog.widgets['show_season'].onclick = function(w) { leaderboard_change_page(w.parent, 'season', null, null, 0); };
    dialog.widgets['show_alltime'].onclick = function(w) { leaderboard_change_page(w.parent, 'ALL', null, null, 0); };
    dialog.widgets['friend_icon'].set_user(session.user_id);
    dialog.widgets['friend_icon'].onclick = function(w) { PlayerInfoDialog.invoke(session.user_id); };

    dialog.user_data['queries'] = []; // list of [category, period, extra_axes] tuples to send queries on
    dialog.user_data['data'] = {}; // indexed by [categotry][period]
    dialog.user_data['friend_data'] = {}; // indexed by [category][period]
    for(var i = 0; i < dialog.user_data['categories'].length; i++) {
        var cat = dialog.user_data['categories'][i];
        var catdata = gamedata['strings']['leaderboard']['categories'][cat];
        dialog.user_data['data'][cat] = {};
        dialog.user_data['friend_data'][cat] = {};
        for(var j = 0; j < dialog.user_data['periods'].length; j++) {
            var period = dialog.user_data['periods'][j];
            dialog.user_data['data'][cat][period] = null;
            dialog.user_data['friend_data'][cat][period] = null;
            // if no periods are specified, default to week/season only
            if(goog.array.contains(catdata['periods'] || ['week','season'], period)) {
                dialog.user_data['queries'].push([cat, catdata['stat_name'] || cat, period, catdata['extra_axes'] || null]);
            }
        }
    }

    var quarry_event = player.get_event_data('current_event', 'event_quarry_contest');
    if(quarry_event) {
        dialog.widgets['footer_bg'].show =
            dialog.widgets['footer_message'].show = true;
        dialog.widgets['footer_message'].set_text_with_linebreaking(quarry_event['ui_leaderboard_footer_message'].replace('%d', pretty_print_time_brief(-player.get_event_time('current_event', 'event_quarry_contest','end'))));
    }

    var default_period = (force_period ? force_period : null);
    var default_mode = (force_mode ? force_mode : 'all');
    var trophy_type = (player.is_ladder_player() ? 'pvp' : player.current_trophy_type());

    var default_chapter = (force_chapter ? force_chapter : eval_cond_or_literal(gamedata['strings']['leaderboard']['default_category'], player, null));

    // if chapter doesn't exist, fall back to the first one displayed
    if(!goog.array.contains(dialog.user_data['categories'], default_chapter)) { default_chapter = dialog.user_data['categories'][0]; }

    leaderboard_change_page(dialog, default_period, default_mode, default_chapter, 0);
    return dialog;
}

function leaderboard_query_self(dialog, chapter, frequency, ui_data) {
    var key = chapter+'_'+frequency;
    if(dialog.user_data['self_queries'][key] > 0) { return; } // already launched
    dialog.user_data['self_queries'][key] = 1; // mark launched
    // ask server for player's own standings
    var stat_name = ui_data['stat_name'] || chapter;
    var qls = [scores2_query_addr(stat_name, frequency, ui_data['extra_axes'] || null)];
    query_player_scores2([session.user_id], qls, (function (_dialog, _key, _chapter, _frequency) { return function(user_ids, datas) {
        if(!_dialog.parent) { return; } // dialog died
        _dialog.user_data['self_queries'][key] = 2; // mark landed
        var data = datas[0][0];
        if(data && ('absolute' in data)) {
            data['chapter'] = _chapter; data['frequency'] = _frequency;
            _dialog.user_data['self'].push(data);
        }
        leaderboard_change_page(_dialog, null, null, _dialog.user_data['chapter'], _dialog.user_data['page']);
    }; })(dialog, key, chapter, frequency), {get_rank:true});
}

// return localized description of player's rank/percentile standing
function percentile_ui_status(rank, pct, allow_you) {
    var status = '';
    var s = gamedata['strings']['percentiles'];
    if(rank <= 3 && allow_you) {
        status = s['ranknum'].replace('%d',rank.toString());
    } else if(pct >= 0.999) {
        status = s['top_001'];
    } else if(pct >= 0.75) {
        var breaks = [0.99, 0.98, 0.97, 0.96, 0.95, 0.9, 0.8, 0.75];
        for(var j = 0; j < breaks.length; j++) {
            if(pct >= breaks[j]) {
                status = s['top_pct'].replace('%pct', (100.0*(1.0-breaks[j])).toFixed(0));
                break;
            }
        }
    } else if(pct >= 0.5) {
        status = s['top_half'];
    }
    return status;
}

function leaderboard_change_page(dialog, period, mode, chapter, page) {
    if(period) { dialog.user_data['period'] = period; } else { period = dialog.user_data['period']; }
    if(chapter) { dialog.user_data['chapter'] = chapter; } else { chapter = dialog.user_data['chapter']; }
    if(mode) { dialog.user_data['mode'] = mode; } else { mode = dialog.user_data['mode']; }
    dialog.user_data['page'] = page;

    var ui_data = gamedata['strings']['leaderboard']['categories'][chapter];

    // restrict period to one(s) that is/are applicable to this chapter
    if(goog.array.indexOf(['trophies_pvp','trophies_pvv'], chapter) != -1) {
        dialog.widgets['show_week'].show = (gamedata['matchmaking']['ladder_point_frequency'] === 'week');
        dialog.widgets['show_season'].show = (gamedata['matchmaking']['ladder_point_frequency'] === 'season');
        dialog.widgets['show_alltime'].show = false;
    } else if('periods' in ui_data) {
        dialog.widgets['show_week'].show = goog.array.contains(ui_data['periods'], 'week');
        dialog.widgets['show_season'].show = goog.array.contains(ui_data['periods'], 'season');
        dialog.widgets['show_alltime'].show = goog.array.contains(ui_data['periods'], 'ALL');
    } else {
        dialog.widgets['show_week'].show = dialog.widgets['show_season'].show = true;
        dialog.widgets['show_alltime'].show = false;
    }

    if(period == 'ALL' && !dialog.widgets['show_alltime'].show) {
        period = dialog.user_data['period'] = 'season';
    } else if(period == 'week' && !dialog.widgets['show_week'].show) {
        if(dialog.widgets['show_season'].show) {
            period = dialog.user_data['period'] = 'season';
        } else if(dialog.widgets['show_alltime'].show) {
            period = dialog.user_data['period'] = 'ALL';
        }
    } else if(period == 'season' && !dialog.widgets['show_season'].show) {
        if(dialog.widgets['show_week'].show) {
            period = dialog.user_data['period'] = 'week';
        } else if(dialog.widgets['show_alltime'].show) {
            period = dialog.user_data['period'] = 'ALL';
        }
    }

    if(mode == 'friends') {
        if(dialog.user_data['friend_data'][chapter][period] === null) {
            var id_list = [];
            for(var i = 0; i < player.friends.length; i++) {
                if(player.friends[i].is_real_friend) { id_list.push(player.friends[i].user_id); }
            }
            if(id_list.length > 0) {
                // also query self
                id_list.push(session.user_id);

                // stash id_list for receiving the response
                dialog.user_data['friend_id_list'] = id_list;

                var friend_scores_cb = (function (dlg) { return function(user_ids, datas) {
                    // friend query result
                    // we send an ordinary PLAYER_SCORES query for each friend, then munge the returned data into the
                    // same format that SCORE_LEADERS returns
                    var queries = dlg.user_data['queries'];

                    var friend_map = {}; // map from user_id to player.friend

                    for(var i = 0; i < queries.length; i++) {
                        var ranklist = [];
                        for(var f = 0; f < user_ids.length; f++) {
                            var data = datas[f][i];
                            if(!data) { continue; } // friend is not ranked

                            if(user_ids[f] == session.user_id) {
                                // one of the entries will be self
                                ranklist.push({'absolute':data['absolute'],
                                               'user_id':user_ids[f],
                                               'player_level':player.resource_state["player_level"],
                                               'facebook_id':spin_facebook_user,
                                               'ui_name':player.get_ui_name()});
                            } else {
                                if(!(user_ids[f] in friend_map)) {
                                    var j;
                                    for(j = 0; j < player.friends.length; j++) {
                                        if(player.friends[j].user_id == user_ids[f]) {
                                            friend_map[user_ids[f]] = player.friends[j];
                                            break;
                                        }
                                    }
                                    if(j >= player.friends.length) {
                                        // friend not found
                                        continue;
                                    }
                                }
                                var friend = friend_map[user_ids[f]];
                                ranklist.push({'absolute':data['absolute'],
                                               'user_id':user_ids[f],
                                               'player_level':friend.get_player_level(),
                                               'facebook_id':friend.get_facebook_id(),
                                               'social_id':friend.get_social_id(),
                                               'ui_name':friend.get_ui_name()});
                            }
                        }
                        var compare_by_abs = function(a,b) {
                            if(a['absolute'] > b['absolute']) {
                                return -1;
                            } else if(a['absolute'] < b['absolute']) {
                                return 1;
                            } else {
                                return 0;
                            }
                        };
                        ranklist.sort(compare_by_abs);

                        // check the sort order for this query
                        var chapter = queries[i][0]; var stat_name = queries[i][1]; var period = queries[i][2]; var extra_axes = queries[i][3];
                        if(scores2_query_addr(stat_name, period, extra_axes).sort_order > 0) {
                            ranklist.reverse();
                        }

                        dlg.user_data['friend_data'][chapter][period]=ranklist;
                    }
                    dlg.widgets['leaderboard_loading'].show = false;
                    leaderboard_change_page(dlg, null, null, dlg.user_data['chapter'], 0);
                }; })(dialog);

                query_player_scores2(id_list,
                                     goog.array.map(dialog.user_data['queries'],
                                                    function(entry) {
                                                        var stat_name = entry[1]; var period = entry[2]; var extra_axes = entry[3];
                                                        return scores2_query_addr(stat_name, period, extra_axes);
                                                    }),
                                     friend_scores_cb);
                dialog.widgets['leaderboard_loading'].show = true;
            } else {
                // player has no friends!
                dialog.widgets['leaderboard_loading'].show = false;
            }
            for(var ch in dialog.user_data['friend_data']) {
                for(var p in dialog.user_data['friend_data'][ch]) {
                    dialog.user_data['friend_data'][ch][p] = (id_list.length > 0 ? 'PENDING' : []);
                }
            }
        } else if(dialog.user_data['friend_data'][chapter][period] === 'PENDING') {
            dialog.widgets['leaderboard_loading'].show = true;
        } else {
            dialog.widgets['leaderboard_loading'].show = false;
        }
    } else {
        if(dialog.user_data['data'][chapter][period] === null) {
            // ask server for top rankings
            dialog.widgets['leaderboard_loading'].show = true;
            dialog.user_data['data'][chapter][period] = 'PENDING';
            var cb = (function (_dlg, _chapter) { return function(cat, period, data) {
                _dlg.user_data['data'][_chapter][period] = data;
                leaderboard_change_page(_dlg, null, null, _dlg.user_data['chapter'], 0);
            }; })(dialog, chapter);
            query_score_leaders(ui_data['stat_name'] || chapter, period, ui_data['extra_axes'] || null, -1, cb);
        } else if(dialog.user_data['data'][chapter][period] === 'PENDING') {
            dialog.widgets['leaderboard_loading'].show = true;
        } else {
            dialog.widgets['leaderboard_loading'].show = false;
        }
    }

    for(var i = 0; i < dialog.data['widgets']['category_button']['array'][0]; i++) {
        if(i < dialog.user_data['categories'].length) {
            dialog.widgets['category_button'+i.toString()].state = (chapter === dialog.user_data['categories'][i] ? 'pressed' : 'normal');
        }
    }

    dialog.widgets['show_friends'].state = (mode === 'friends' ? 'active' : 'normal');
    dialog.widgets['show_all'].state = (mode === 'all' ? 'active' : 'normal');
    var region_specific = (ui_data['description'].indexOf('%REGION') != -1);
    dialog.widgets['show_all'].str = dialog.data['widgets']['show_all']['ui_name'+(region_specific ? '_region': '')];
    dialog.widgets['show_week'].state = (period === 'week' ? 'active' : 'normal');
    dialog.widgets['show_season'].state = (period === 'season' ? 'active' : 'normal');
    dialog.widgets['show_alltime'].state = (period === 'ALL' ? 'active' : 'normal');

    var is_contest_page = false;
    if(mode === 'all' && period === 'week' && chapter === 'quarry_resources' && player.get_event_time('current_event', 'event_quarry_contest', 'inprogress')) {
        is_contest_page = true;
    }
    var is_first_contest_page = (is_contest_page && page == 0);

    dialog.widgets['contest_leader_label'].show =
        dialog.widgets['contest_leader_rect'].show = is_first_contest_page;
    dialog.widgets['standings_label'].show = !is_first_contest_page;

    var ui_tournament = '';
    var challenge_name = player.current_trophy_pve_challenge_name();
    var challenge = (challenge_name ? gamedata['events'][challenge_name] : null);
    if(challenge && period === 'week') {
        ui_tournament = challenge['ui_name'] + ' ';
    }

    dialog.widgets['rankings_label'].str = dialog.data['widgets']['rankings_label']['ui_name'].replace('%s', ui_data['title'].replace('%PVP_CHALLENGE_NAME',gamedata['events']['challenge_pvp_ladder']['ui_name'])).replace('%when', gamedata['strings']['leaderboard']['periods'][period]['title'].replace('%SEASON',(current_pvp_season()+gamedata['matchmaking']['season_ui_offset']).toString()));
    dialog.widgets['rankings_description'].str = dialog.data['widgets']['rankings_description']['ui_name'].replace('%s', ui_data['description'].replace('%REGION',(session.region.data?gamedata['regions'][session.region.data['id']]['ui_name']:'')).replace('%PVP_CHALLENGE_NAME',gamedata['events']['challenge_pvp_ladder']['ui_name']).replace('%PVE_CHALLENGE_NAME',ui_tournament));
    dialog.widgets['your_total_label'].str = dialog.data['widgets']['your_total_label']['ui_name'].replace('%s1', gamedata['strings']['leaderboard']['periods'][period]['short']).replace('%s2', ui_data['short_title']);

    dialog.widgets['stat_challenge_icon'].asset = ui_data['challenge_icon'] || null;

    // fill in your own standings
    if(true) {
        var data = null;
        for(var i = 0; i < dialog.user_data['self'].length; i++) {
            var s = dialog.user_data['self'][i];
            if(s['chapter'] === chapter && s['frequency'] === period && ('absolute' in s)) {
                data = s;
                break;
            }
        }
        if(!data) { leaderboard_query_self(dialog, chapter, period, ui_data); }

        dialog.widgets['self_loading'].show = (dialog.user_data['self_queries'][chapter+'_'+period] < 2);

        var brag_reason = (ui_data['brag_reason'] || ui_data['title']).replace('%PVP_CHALLENGE_NAME', gamedata['events']['challenge_pvp_ladder']['ui_name']);
        if(brag_reason) {
            brag_reason += ' '+gamedata['strings']['leaderboard']['periods'][period]['brag'];
        }

        var rank = -1, pct = -1;
        if(mode == 'friends') {
            // compute rank/percentile among friends
            var ranklist = dialog.user_data['friend_data'][chapter][period];
            if(ranklist) {
                for(var i = 0; i < ranklist.length; i++) {
                    if(ranklist[i]['user_id'] == session.user_id) {
                        rank = i+1;
                        pct = 1.0-(i/ranklist.length);
                        break;
                    }
                }
            }
        } else {
            // use global rank/percentile
            if(data && ('rank' in data))  {
                rank = data['rank']+1;
                pct = 1.0-data['percentile'];
            }
        }
        var absolute = (data ? data['absolute'] : -1);
        var display_absolute = (data ? (dialog.user_data['chapter'].slice(0,8) === 'trophies' ? display_trophy_count(absolute, dialog.user_data['chapter'].slice(9)) : absolute) : -1);
        dialog.widgets['your_rank'].str = (rank >= 0 ? pretty_print_number(rank) : '-');
        dialog.widgets['your_pct'].str = (pct >= 0 && display_absolute > 0 ? (100.0*pct).toFixed(1)+'%' : '-');
        dialog.widgets['your_total'].str = (display_absolute > 0 ? (ui_data['display'] === 'seconds' ? pretty_print_time(display_absolute) : pretty_print_number(display_absolute)) : '-');
        dialog.widgets['your_rank_accent'].show = (pct >= 0.5);
        dialog.widgets['your_rank_accent'].state = (pct >= 0.99 ? 'top' : 'normal');
        dialog.widgets['your_status'].show = (pct >= 0.5);
        dialog.widgets['your_status'].str = percentile_ui_status(rank, pct, true);
        var viral = get_facebook_viral('leaderboard_brag');
        dialog.widgets['inform_button'].show = (pct >= 0.5) && (brag_reason != null) && (mode != 'friends') && viral;
        if(viral) {
            dialog.widgets['inform_button'].str = viral['ui_button_text'];
            dialog.widgets['inform_button'].state = 'normal';
            dialog.widgets['inform_button'].onclick = (function (_rank, _percentile, _reason) { return function() {
                invoke_leaderboard_brag(_rank-1, _percentile, _reason);
            }; })(rank, pct, brag_reason);
        }
    }

    // fill in rankings
    var row = 0;
    var rows_per_page = 10;

    var data_source = dialog.user_data[(mode == 'friends' ? 'friend_data' : 'data')][chapter][period];
    var chapter_players;
    if(!data_source || data_source === 'PENDING') {
        chapter_players = 0;
    } else {
        chapter_players = data_source.length;
    }
    var chapter_pages = Math.floor((chapter_players+rows_per_page-1)/rows_per_page);
    dialog.user_data['page'] = page = (chapter_pages === 0 ? 0 : clamp(page, 0, chapter_pages-1));
    if(chapter_pages > 0) {
        var first_player_on_page = page * rows_per_page;
        var last_player_on_page = (page+1)*rows_per_page - 1;
        last_player_on_page = Math.max(0, Math.min(last_player_on_page, chapter_players-1));

        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(page+1).toString()).replace('%d2',chapter_pages.toString());

        for(var i = first_player_on_page; i <= last_player_on_page; i++) {
            var data = data_source[i];
            var x = Math.floor(row/5), y = row % 5;
            var index = x.toString()+','+y.toString();

            var long_name = PlayerCache.get_ui_name(data);

            dialog.widgets['player_portrait'+index].show =
                dialog.widgets['player_portrait_frame'+index].show = true;
            dialog.widgets['player_portrait'+index].set_user(data['user_id']);
            dialog.widgets['player_portrait'+index].onclick =
                dialog.widgets['player_portrait_frame'+index].onclick =
                dialog.widgets['player_name'+index].onclick =
                dialog.widgets['rank_numeral'+index].onclick =
                dialog.widgets['player_value'+index].onclick = (function (_uid) { return function() {
                    PlayerInfoDialog.invoke(_uid);
                    // go directly to Spying rather than opening Player Info?
                    //if(_uid != session.user_id) { visit_base_with_loading_message(_uid); }
                }; })(data['user_id']);
            dialog.widgets['player_name'+index].show = true;
            var short_name = long_name;
            var max_len = 12;
            if(short_name.length > max_len) {
                short_name = short_name.slice(0,max_len);
            }
            dialog.widgets['player_name'+index].str = short_name+' (L'+(data['player_level'] || 1).toString()+')';
            dialog.widgets['player_value'+index].show = true;

            var display_absolute = (dialog.user_data['chapter'].slice(0,8) === 'trophies' ? display_trophy_count(data['absolute'], dialog.user_data['chapter'].slice(9)) : data['absolute']);
            dialog.widgets['player_value'+index].str = (ui_data['display'] === 'seconds' ? pretty_print_time(display_absolute) : pretty_print_number(display_absolute));
            dialog.widgets['rank_accent'+index].show = true;
            dialog.widgets['rank_accent'+index].state = ((i+1) <= 3 ? 'top' : 'normal');
            dialog.widgets['rank_numeral'+index].show = true;
            dialog.widgets['rank_numeral'+index].str = (i+1).toString();
            dialog.widgets['rank_numeral'+index].font = ((i+1) <= 3 ? SPUI.make_font(22,25,'bold') : SPUI.make_font(19,25,'normal'));

            row += 1;
        }
    } else {
        // no players in the list
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(0).toString()).replace('%d2',(0).toString()).replace('%d3',(0).toString());
    }


    // clear out empty rows
    while(row < rows_per_page) {
        var x = Math.floor(row/5), y = row % 5;
        var index = x.toString()+','+y.toString();
        dialog.widgets['rank_accent'+index].show =
            dialog.widgets['rank_numeral'+index].show =
            dialog.widgets['player_portrait'+index].show =
            dialog.widgets['player_portrait_frame'+index].show =
            dialog.widgets['player_name'+index].show =
            dialog.widgets['player_value'+index].show = false;
        row += 1;
    }

    // set clickability of scroll arrows
    if(page != 0) {
        dialog.widgets['scroll_left'].state = 'normal';
    } else {
        dialog.widgets['scroll_left'].state = 'disabled';
    }

    if(page < (chapter_pages-1)) {
        dialog.widgets['scroll_right'].state = 'normal';
    } else {
        dialog.widgets['scroll_right'].state = 'disabled';
    }

    dialog.widgets['scroll_left'].onclick = function(w) { leaderboard_change_page(w.parent, null, null, selection.ui.user_data['chapter'], selection.ui.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function(w) { leaderboard_change_page(w.parent, null, null, selection.ui.user_data['chapter'], selection.ui.user_data['page']+1); };
}

/** @param {SPUI.Dialog} dialog */
function update_leaderboard_dialog(dialog) {
    if(dialog.widgets['contest_leader_rect'].show) {
        dialog.widgets['contest_leader_rect'].opacity = 0.5 + 0.5*(0.5*(1+Math.sin(client_time/0.25)));
    }
}

function test_notify_achievements() {
    var name = null;
    for(var n in gamedata['achievements']) {
        name = n; break;
    }
    if(name) {
        notification_queue.achievements = [gamedata['achievements'][name]];
        notify_achievements();
    }
}

function notify_achievements() {
    var ach_list = notification_queue.achievements;
    if(ach_list.length < 1) { return; }
    notification_queue.achievements = [];

    ach_list.sort(compare_achievements(player.achievements));

    var dialog_data = gamedata['dialogs']['achievements_claimed'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'achievements_claimed';
    dialog.user_data['ach_list'] = ach_list;
    dialog.user_data['open_time'] = client_time;
    dialog.user_data['anim_start_time'] = -1;
    change_selection_ui(dialog); // install_child_dialog(dialog);

    dialog.widgets['close_button'].onclick =
        dialog.widgets['close_button2'].onclick = function(w) {
            var dialog = w.parent;
            if(dialog.user_data['anim_start_time'] < 0) {
                dialog.user_data['anim_start_time'] = client_time;
            }
        };

    if(get_facebook_viral('achievement_brag')) {
        dialog.widgets['inform_button'].onclick = (function (_ach) { return function(w) { invoke_achievement_brag(_ach); }; })(ach_list[0]);
        dialog.widgets['inform_button'].str = get_facebook_viral('achievement_brag')['ui_button_text'];
    } else {
        dialog.widgets['inform_button'].show = false;
    }

    var height_bump = (ach_list.length - 1) * dialog.data['widgets']['ach']['array_offset'][1];
    dialog.widgets['inform_button'].xy = vec_add(dialog.widgets['inform_button'].xy, [0,height_bump]);
    dialog.widgets['close_button'].xy = vec_add(dialog.widgets['close_button'].xy, [0,height_bump]);
    dialog.wh = vec_add(dialog.wh, [0,height_bump]);

    dialog.ondraw = animate_notify_achievements;
    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name' + (ach_list.length > 1 ? '_multiple': '')];

    for(var i = 0; i < dialog.data['widgets']['ach']['array'][1]; i++) {
        var w = dialog.widgets['ach'+i];
        if(i < ach_list.length) {
            achievement_widget_setup(w, ach_list[i], player.achievements, null);
            SPFB.AppEvents.logEvent('UNLOCKED_ACHIEVEMENT', null, {'DESCRIPTION': ach_list[i]['name']});

        } else {
            w.show = false;
        }

        dialog.widgets['ach_glow'+i].show =
            dialog.widgets['prog_bar1'+i].show =
            dialog.widgets['prog_bar2'+i].show =
            dialog.widgets['prog_bar3'+i].show = (i < ach_list.length);

        if(i > 0) {
            // only play sounds on first widget
            dialog.widgets['prog_bar1'+i].sound_played =
                dialog.widgets['prog_bar2'+i].sound_played =
                dialog.widgets['prog_bar3'+i].sound_played = true;
        }
    }

    dialog.modal = true;
    dialog.auto_center();
    play_level_up_sound(null);
    return dialog;
}

/** @param {string} _scope to request (comma-separated list)
    @param {function()=} _cb callback to call after permissions granted
    @param {function()=} _fail_cb callback to call after failure
*/
function invoke_facebook_permissions_dialog(_scope, _cb, _fail_cb) {
    var display_mode = gamedata['permissions_request_display']; // 'popup' or 'iframe' FB.ui mode - note that 'popup' must be triggered by a click to avoid popup blockers
    metric_event('0036_request_permission_add_scope_ingame', {'scope': _scope, 'method':'ingame', 'display':display_mode});
    SPFB.ui({'method':'permissions.request','perms':_scope, // request new permissions
             'display': display_mode},
            (function (__scope, __cb, __fail_cb) { return function (bad_resp) {
                console.log("permissions.request returned"); console.log(bad_resp);

                // note: resp doesn't contain anything, you have to query it manually...
                SPFB.api('/me/permissions', (function (___scope, ___cb, ___fail_cb) { return function(resp) { // confirm new permissions
                    if(resp && ('data' in resp) && (resp['data'].length>=1)) {
                        var new_perms = [];
                        if('permission' in resp['data'][0]) {
                            goog.array.forEach(resp['data'], function(x) {
                                if(x['status'] == 'granted') {
                                    new_perms.push(x['permission']);
                                }
                            });
                        } else {
                            for(var n in resp['data'][0]) {
                                new_perms.push(n);
                            }
                        }
                        player.facebook_permissions = new_perms;
                        var success = player.has_facebook_permissions(___scope);
                        send_to_server.func(["INVOKE_FACEBOOK_AUTH_RESPONSE", ___scope, new_perms.join(','), success]);

                        // asynchronously update oauth token
                        // XXXXXX replace with subscription https://developers.facebook.com/docs/reference/javascript/FB.Event.subscribe
                        if(success) {
                            SPFB.getLoginStatus((function (____cb, ____fail_cb) { return function(response) {
                                if(response['status'] === 'connected') {
                                    var new_token = response['authResponse']['accessToken'];
                                    console.log('Updating spin_facebook_oauth_token = "'+new_token+'"');
                                    spin_facebook_oauth_token = new_token;
                                    if(____cb) { ____cb(); }
                                } else {
                                    if(____fail_cb) { ____fail_cb(); }
                                }
                            }; })(___cb, ___fail_cb), true);
                        } else {
                            if(___fail_cb) { ___fail_cb(); }
                        }
                    }
                }; })(__scope, __cb, __fail_cb));
            }; })(_scope, _cb, _fail_cb));
}

/** @param {string} scope you want
    @param {function()=} cb callback to call after permissions granted
    @param {function()=} fail_cb callback to call after failure
    @return {boolean} if the call was synchronous */
function call_with_facebook_permissions(scope, cb, fail_cb) {
    if(!player.has_facebook_permissions(scope)) {
        // add an error message to fail_cb
        var wrapped_fail_cb = (function (_scope, _fail_cb) { return function() {
            if(_fail_cb) { _fail_cb(); }
            var error_name = 'FACEBOOK_PERMISSION_REQUIRED_'+_scope.toUpperCase();
            if(error_name in gamedata['errors']) {
                var s = gamedata['errors'][error_name];
                var descr = s['ui_name'];
                while(descr.indexOf('%game') >= 0) { descr = descr.replace('%game', gamedata['strings']['game_name']); }
                invoke_child_message_dialog(s['title'], descr, {'dialog': 'message_dialog_big'});
            }
        }; })(scope, fail_cb);

        invoke_facebook_permissions_dialog(scope, cb, wrapped_fail_cb);
        return false;
    } else {
        cb();
        return true;
    }
}

function invoke_achievement_brag(ach) {
    var viral = get_facebook_viral('achievement_brag');
    if(!viral) { return; }

    var picture_url;
    if(('fb_open_graph' in ach) && ('s3_image' in ach['fb_open_graph'])) {
        picture_url = gamedata['virals']['common_image_path'] + ach['fb_open_graph']['s3_image'];
    } else {
        picture_url = gamedata['virals']['common_image_path'] + (('image' in viral) ? viral['image'] : gamedata['virals']['default_image']);
    }

    FBShare.invoke({name: viral['ui_post_headline'].replace('%PLAYER',player.facebook_name).replace('%ACHIEVEMENT',ach['ui_name']),
                    description: ach['ui_description'],
                    picture: picture_url,
                    ref:'cheeve'});
}

/** @param {SPUI.Dialog} dialog */
function animate_notify_achievements(dialog) {
    var ach_list = dialog.user_data['ach_list'];

    for(var i = 0; i < dialog.data['widgets']['ach']['array'][1]; i++) {
        if(i < ach_list.length) {
            for(var wtype in {'ach':1,'ach_glow':1}) {
                var fadein_time = dialog.data['widgets'][wtype]['fadein_time'];
                var fadein_start = dialog.data['widgets'][wtype]['fadein_start'];

                var t = client_time - dialog.user_data['open_time'] - fadein_start;
                var prog = clamp(t/fadein_time, 0, 1);
                if(prog >= 1 && wtype == 'ach_glow') {
                    dialog.widgets[wtype+i].alpha = dialog.data['widgets'][wtype]['alpha'] * (0.15*Math.sin(dialog.data['widgets'][wtype]['pulse_frequency']*(client_time+i*0.5)/(2*Math.PI))+0.85);
                } else {
                    dialog.widgets[wtype+i].alpha = prog * (dialog.data['widgets'][wtype]['alpha'] || 1);
                }
            }
        }
   }

    if(dialog.user_data['anim_start_time'] < 0) { return; }

    var ANIM_TIME = player.get_any_abtest_value('valentina_dialog_anim_time', gamedata['client']['valentina_dialog_anim_time']);

    var progress = clamp((client_time - dialog.user_data['anim_start_time'])/ANIM_TIME, 0, 1);
    if(ANIM_TIME < 0 || dialog.user_data['anim_start_time'] < 0) { progress = 1; }

    var bottom = desktop_dialogs['desktop_top'];
    var valentina = bottom.widgets['player_portrait'];
    if(!valentina) { progress = 1; }

    dialog.modal = 1-progress;

    if(progress >= 1) {
        close_parent_dialog(dialog.widgets['close_button']);
    } else if(progress > 0) {
        if('bg_blanker' in dialog.widgets) { dialog.widgets['bg_blanker'].show = false; }
        // zoom into valentina (actually player portrait XXX centralize this code)
        progress = 1 - progress;
        progress = Math.pow(progress,2.0);
        var scale = progress;
        // centerpoint of scale effect
        var pivot = vec_add(dialog.xy, vec_scale(0.5, dialog.wh));
        // where centerpoint is at start of animation
        var startpos = vec_add(vec_add(bottom.xy, valentina.xy), vec_scale(0.5, valentina.wh));
        // where centerpoint is at end of animation
        var endpos = pivot;
        //startpos = [0,0]; endpos = [0,0];
        var origin = vec_add(startpos, vec_scale(progress, vec_sub(endpos, startpos)));

        dialog.transform = [scale, 0,
                            0, scale,
                            origin[0] + scale*(-origin[0]), origin[1] + scale*(-origin[1])];
    }
}


function achievement_widget_setup(dialog, rowdata, player_achievements, player_history) {
    var gotten = (rowdata['name'] in player_achievements) && ('time' in player_achievements[rowdata['name']]);
    var unnerfed = gotten && ('nerf_date' in rowdata) && (player_achievements[rowdata['name']]['time'] < rowdata['nerf_date']);

    var stat_str = null, col = null;
    if(gotten) {
        var d = new Date(player_achievements[rowdata['name']]['time'] * 1000);
        var date_str = d.getUTCFullYear() + ' ' + gamedata['strings']['months_short'][d.getUTCMonth()] + ' ' + d.getUTCDate();

        stat_str = dialog.data['widgets']['achstat']['ui_name_complete'].replace('%s', date_str);
        col = dialog.data['widgets']['achstat']['text_color_complete' + (unnerfed ? '_unnerfed' : '')];
    } else if(player_history && ('ui_progress' in rowdata) && ('progress_key' in rowdata) && ('progress_goal' in rowdata)) {

        stat_str = rowdata['ui_progress'].replace('%cur', pretty_print_number(player_history[rowdata['progress_key']] || 0)).replace('%goal', pretty_print_number(rowdata['progress_goal']));
        col = dialog.data['widgets']['achstat']['text_color_progress'];
    } else if(player_history && rowdata['goal']['predicate'] == 'PLAYER_HISTORY' && rowdata['goal']['method'] == '>=' && rowdata['goal']['key'].indexOf('ai_') != 0) {
        // default parsing of PLAYER_HISTORY predicates (but not ai_xxx, since that doesn't always look good together with the ui_description)
        stat_str = dialog.data['widgets']['achstat']['ui_name_progress'].replace('%cur', pretty_print_number(player_history[rowdata['goal']['key']] || 0)).replace('%goal', pretty_print_number(rowdata['goal']['value']));
        col = dialog.data['widgets']['achstat']['text_color_progress'];
    } else {
        stat_str = dialog.data['widgets']['achstat']['ui_name_incomplete'];
        col = dialog.data['widgets']['achstat']['text_color_incomplete'];
    }

    dialog.widgets['achstat'].str = stat_str;
    if(stat_str && col) {
        dialog.widgets['achstat'].text_color = SPUI.make_colorv(col);
    }
    dialog.widgets['achname'].text_color = SPUI.make_colorv(dialog.data['widgets']['achname']['text_color' + (unnerfed ? '_complete_unnerfed' : '')]);
    dialog.widgets['achbg'].tooltip.str = rowdata['ui_tooltip'] || null;
    dialog.widgets['achname'].str = rowdata['ui_name'];
    dialog.widgets['achtext'].set_text_with_linebreaking(rowdata['ui_description']);
    dialog.widgets['achicon'].asset = rowdata['icon'];
    col = dialog.data['widgets']['achiconbg']['color_' + (gotten ? (unnerfed ? 'yes_unnerfed' : 'yes') : 'no')];
    dialog.widgets['achiconbg'].color = SPUI.make_colorv(col);
    var points = ('achievement_points' in rowdata ? rowdata['achievement_points'] : 0);
    dialog.widgets['achpts'].show = (points > 0) && player.get_any_abtest_value('enable_achievement_points', gamedata['client']['enable_achievement_points']);
    if(dialog.widgets['achpts'].show) {
        dialog.widgets['achpts'].str = dialog.data['widgets']['achpts'][(points == 1 ? 'ui_name' : 'ui_name_plural')].replace('%d', pretty_print_number(points));
    }
    if(('achhider') in dialog.widgets) { dialog.widgets['achhider'].show = !gotten; }
}

var ALLIANCE_LIST_SEPARATOR = 'SEPARATOR';

// here "rowdata" is just the raw alliance_id, or ALLIANCE_LIST_SEPARATOR
function alliance_list_lazy_rowfunc(dialog, row, rowdata) {
    // awkward - set visibility of header elements here
    // this should really be a sub-dialog
    for(var name in dialog.widgets) {
        if(name.indexOf("header_") === 0) {
            dialog.widgets[name].show = false;
            if(dialog.user_data['page'] === 0 && dialog.user_data['has_header']) {
                dialog.widgets[name].show = true;
                if(name.indexOf("header_expires") === 0 && !dialog.user_data['has_header_expires']) {
                    dialog.widgets[name].show = false;
                } else if(name.indexOf("header_season") === 0 && dialog.user_data['has_header_expires']) {
                    dialog.widgets[name].show = false;
                } else if(name.indexOf("header_prize") === 0 && !dialog.user_data['has_header_prize']) {
                    dialog.widgets[name].show = false;
                }
            }
        }
    }

    var d = dialog.widgets['alliances'+row];
    d.show = !!rowdata;
    d.ondraw = alliance_list_row_update;
    if(rowdata) {
        if(rowdata === ALLIANCE_LIST_SEPARATOR) {
            return alliance_list_rowfunc(dialog, row, rowdata);
        } else {
            d.user_data['alliance_id'] = rowdata;
            d.widgets['loading_spinner'].show = true;
            d.widgets['bg'].show = true;
            d.widgets['rank_bg'].show =
                d.widgets['rank_bg_shine'].show =
                d.widgets['rank'].show =
                d.widgets['name'].show =
                d.widgets['logo'].show =
                d.widgets['logo_frame'].show =
                d.widgets['join_type'].show =
                d.widgets['members'].show =
                d.widgets['separator'].show =
                d.widgets['trophy_bg'].show =
                d.widgets['trophy_shine'].show =
                d.widgets['trophy_icon'].show =
                d.widgets['trophy_amount'].show =
                d.widgets['button'].show = false;

            d.widgets['logo_frame'].onclick = d.widgets['button'].onclick = alliance_list_onclick;

            AllianceCache.query_info(rowdata, (function (_d) { return function(info) {

                if(info && (_d.user_data['alliance_id'] != info['id'])) { return; }

                _d.widgets['loading_spinner'].show = false;
                _d.widgets['name'].show =
                    _d.widgets['logo'].show =
                    _d.widgets['logo_frame'].show =
                    _d.widgets['join_type'].show =
                    _d.widgets['members'].show =
                    _d.widgets['button'].show = !!info;

                if(!info) {
                    _d.widgets['name'].show = true;
                    _d.widgets['name'].str = _d.data['widgets']['name']['ui_name_error'];
                } else {
                    var point_stat = (_d.parent ? _d.parent.user_data['point_stat'] : null);

                    _d.widgets['rank_bg'].show =
                        _d.widgets['rank_bg_shine'].show =
                        _d.widgets['rank'].show =
                        _d.widgets['trophy_bg'].show =
                        _d.widgets['trophy_shine'].show =
                        _d.widgets['trophy_icon'].show =
                        _d.widgets['trophy_amount'].show = !!point_stat;
                    if(point_stat) {
                        _d.widgets['trophy_icon'].asset = _d.parent.user_data['point_icon_asset'];
                        _d.widgets['trophy_icon'].state = _d.parent.user_data['point_icon_state'];
                        if((point_stat['name'] in info) && ((point_stat['name']+'_rank') in info)) {
                            set_rank_widget(_d, info[point_stat['name']+'_rank']+1);
                            _d.widgets['trophy_amount'].str = pretty_print_number(info[point_stat['name']]);
                        } else {
                            console.log("RANK INFO MISSING: "); console.log(info);
                        }
                    }

                    _d.widgets['name'].str = alliance_display_name(info);
                    _d.widgets['logo'].asset = get_alliance_logo_asset(info['logo'] || null);
                    _d.widgets['join_type'].str = gamedata['strings']['alliance_join_types'][info['join_type']];
                    _d.widgets['members'].str = d.data['widgets']['members']['ui_name'].replace('%d1', info['num_members'].toString()).replace('%d2', gamedata['alliances']['max_members'].toString());
                }

            }; })(d));
        }
    }
}

function alliance_display_name(info) {
    var ret = info['ui_name'];
    if(('chat_tag' in info) && info['chat_tag'].length > 0 && player.get_any_abtest_value('enable_alliance_chat_tags', gamedata['client']['enable_alliance_chat_tags'])) {
        ret += ' ['+info['chat_tag']+']';
    }
    return ret;
}

function alliance_list_onclick(w) {
    var _d = w.parent;
    alliance_list_change_tab(_d.parent.parent, 'info', _d.user_data['alliance_id']);
}

/** @param {SPUI.Dialog} dialog */
function alliance_list_row_update(dialog) {
    if(!dialog.show) { return; }
    var togo = player.current_trophy_challenge_togo();
    dialog.widgets['trophy_bg'].tooltip.str = dialog.data['widgets']['trophy_bg']['ui_tooltip' + (((togo > 0) && (togo < gamedata['client']['infinite_trophy_togo'])) ? '_togo' : '')].replace('%s', pretty_print_time_brief(togo));
    dialog.widgets['trophy_bg'].fixed_tooltip_offset = dialog.data['widgets']['trophy_bg']['fixed_tooltip_offset'+ (((togo > 0) && (togo < gamedata['client']['infinite_trophy_togo'])) ? '_togo' : '')];
}

// here "rowdata" is the full alliance info entry
function alliance_list_rowfunc(dialog, row, rowdata) {
    var d = dialog.widgets['alliances'+row];
    d.show = !!rowdata;
    d.ondraw = alliance_list_row_update;

    if(rowdata) {
        d.widgets['rank_bg'].show =
            d.widgets['rank_bg_shine'].show =
            d.widgets['rank'].show =
            d.widgets['trophy_bg'].show =
            d.widgets['trophy_shine'].show =
            d.widgets['trophy_icon'].show =
            d.widgets['trophy_amount'].show = false; // no rank display here

        d.widgets['bg'].show =
            d.widgets['name'].show =
            d.widgets['logo'].show =
            d.widgets['logo_frame'].show =
            d.widgets['join_type'].show =
            d.widgets['members'].show =
            d.widgets['button'].show = (rowdata !== ALLIANCE_LIST_SEPARATOR);

        d.widgets['separator'].show = (rowdata === ALLIANCE_LIST_SEPARATOR);

        if(rowdata === ALLIANCE_LIST_SEPARATOR) {
        } else {
            d.user_data['alliance_id'] = rowdata['id'];
            d.widgets['name'].str = alliance_display_name(rowdata);
            d.widgets['logo'].asset = get_alliance_logo_asset(rowdata['logo'] || null);
            d.widgets['join_type'].str = gamedata['strings']['alliance_join_types'][rowdata['join_type']];
            d.widgets['members'].str = d.data['widgets']['members']['ui_name'].replace('%d1', rowdata['num_members'].toString()).replace('%d2', gamedata['alliances']['max_members'].toString());
            d.widgets['logo_frame'].onclick = d.widgets['button'].onclick = alliance_list_onclick;
        }
    }
}

var tag_chars_ext =
    ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
     'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
     '0','1','2','3','4','5','6','7','8','9'];
var name_chars_ext = tag_chars_ext.concat([' ',"'"]);

/** @param {SPUI.Dialog} dialog
    @param {string} newtab
    @param {number=} info_id alliance we want to look at */
function alliance_list_change_tab(dialog, newtab, info_id) {
    if(newtab != dialog.user_data['tab']) {
        if(dialog.user_data['tab'] !== 'modify') {
            dialog.user_data['prev_tab'] = dialog.user_data['tab'];
        }
        dialog.user_data['tab'] = newtab;
    }
    player.quest_tracked_dirty = true;

    var use_trophies = player.use_trophies(); // whether PvP points are enabled
    var event = player.current_alliance_stat_tournament_event(); // whether a stat tournament is going on
    var use_leaderboard = !!(use_trophies || event);

    dialog.widgets['top_tab'].show = (newtab == 'top');
    dialog.widgets['join_tab'].show = (newtab == 'join');
    dialog.widgets['create_tab'].show = (newtab == 'create' || newtab == 'modify');
    dialog.widgets['search_tab'].show = (newtab == 'search');
    dialog.widgets['search_player_tab'].show = (newtab == 'search_player');
    dialog.widgets['info_tab'].show = (newtab == 'info');
    dialog.widgets['your_tab'].show = (newtab == 'your');

    dialog.widgets['top_alliances_button'].state = (newtab == 'top' ? 'active' : 'normal');
    dialog.widgets['join_alliance_button'].state = (newtab == 'join' ? 'active' : 'normal');
    dialog.widgets['create_alliance_button'].state = (newtab == 'create' ? 'active' : 'normal');
    dialog.widgets['your_alliance_button'].state = (newtab == 'your' ? 'active' : 'normal');
    dialog.widgets['search_alliance_button'].state = (newtab == 'search' ? 'active' : 'normal');
    dialog.widgets['search_player_button'].state = (newtab == 'search_player' ? 'active' : 'normal');

    // set up back button
    dialog.widgets['back_button_bg'].show = dialog.widgets['back_button'].show = dialog.widgets['back_button_shine'].show = dialog.user_data['prev_tab'] && ((newtab == 'modify') || ((newtab == 'info')));
    if(dialog.widgets['back_button'].show) {
        dialog.widgets['back_button'].onclick = function(w) {
            var _dialog = w.parent;
            alliance_list_change_tab(_dialog, _dialog.user_data['prev_tab']);
        };
    }

    // Your Alliance/Create Alliance are mutually exclusive
    dialog.widgets['your_alliance_button'].show = session.is_in_alliance();
    dialog.widgets['create_alliance_button'].show = !dialog.widgets['your_alliance_button'].show;

    if(session.is_in_alliance()) {
        // Top Alliances/New Alliances mutually exclusive
        dialog.widgets['top_alliances_button'].show = use_leaderboard;
        dialog.widgets['join_alliance_button'].show = !use_leaderboard;
        dialog.widgets['top_alliances_button'].xy = dialog.data['widgets']['top_alliances_button']['xy'];
    } else {
        dialog.widgets['join_alliance_button'].show = true;
        // Awkwardly tack on Top Alliances at left for newbies
        dialog.widgets['top_alliances_button'].show = use_leaderboard && !dialog.widgets['back_button_bg'].show;
        dialog.widgets['top_alliances_button'].xy = dialog.data['widgets']['top_alliances_button']['xy_no_back'];
    }


    /*
    if(!session.is_in_alliance()) {
        // normal create button
        dialog.widgets['create_alliance_button'].show = true;
    } else {
        // diable create button when already in an alliance
        dialog.widgets['create_alliance_button'].state = 'disabled';
        dialog.widgets['create_alliance_button'].tooltip.str = dialog.data['widgets']['create_alliance_button']['ui_tooltip_leave_first'];
    }
    */

    if(newtab == 'top') {
        var d = dialog.widgets['top_tab'];
        d.user_data['page'] = -1;

        if((!d.user_data['rowdata'] || (d.user_data['rowdata'].length < 1)) && !d.user_data['pending']) {
            d.user_data['pending'] = true;
            d.widgets['loading_rect'].show = d.widgets['loading_text'].show = d.widgets['loading_spinner'].show = true;
            d.user_data['rows_per_page'] = d.data['widgets']['alliances']['array'][1];
            d.user_data['rowdata'] = []; // this holds the alliance ID list
            d.user_data['rowfunc'] = alliance_list_lazy_rowfunc;
            d.user_data['has_header'] = true;
            d.user_data['has_header_expires'] = false;
            d.user_data['has_header_prize'] = false;
            d.user_data['point_stat'] = null;

            var challenge, togo;
            if(event) { // stat tournament
                challenge = d.user_data['event'] = event;
                togo = player.current_alliance_stat_tournament_end_time() - player.get_absolute_time();
                d.user_data['point_stat'] = event['stat'];
                d.user_data['point_icon_asset'] = event['icon'];
                d.user_data['point_icon_state'] = 'icon_30x30';
                d.widgets['header_logo'].asset = event['icon'];
                d.widgets['header_logo'].state = 'normal';
            } else { // legacy PvP tournament
                var challenge_name = player.current_trophy_challenge_name();
                var trophy_type = player.current_trophy_type();
                if(!challenge_name) { throw Error('invoked alliances top_tab without a challenge or stat tournament active'); }

                challenge = d.user_data['event'] = gamedata['events'][challenge_name];
                togo = player.current_trophy_challenge_togo();
                d.user_data['point_stat'] = {'name': 'trophies_'+trophy_type,
                                             'time_scope': (trophy_type == 'pvp' ? gamedata['matchmaking']['ladder_point_frequency'] : 'week')};
                d.user_data['point_icon_asset'] = 'trophy_30x30';
                d.user_data['point_icon_state'] = trophy_type;
                d.widgets['header_logo'].state = trophy_type;
            }

            d.widgets['header_expires'].show = d.widgets['header_expires_label'].show = ((togo > 0) && (togo < gamedata['client']['infinite_trophy_togo']));
            if(d.widgets['header_expires'].show) {
                d.user_data['has_header_expires'] = true;
                d.widgets['header_expires'].str = d.data['widgets']['header_expires']['ui_name'].replace('%s', pretty_print_time_brief(togo));
            } else {
                d.widgets['header_season'].show = true;
                d.widgets['header_season'].str = d.data['widgets']['header_season']['ui_name'].replace('%s', (current_pvp_season()+gamedata['matchmaking']['season_ui_offset']).toString());
            }

            d.widgets['header_title'].str = (challenge['ui_top_alliances_header_title'] || d.data['widgets']['header_title']['ui_name']);
            d.widgets['header_title'].xy = d.data['widgets']['header_title']['xy' + (d.widgets['header_expires'].show ? '_togo' : '')];

            // PRICE
            d.widgets['header_prize_icon'].asset = player.get_any_abtest_value('gamebucks_icon_med', gamedata['store']['gamebucks_icon_med']);
            d.widgets['header_prize_icon'].tooltip.str = player.get_any_abtest_value('gamebucks_ui_name', gamedata['store']['gamebucks_ui_name']);
            d.widgets['header_img'].asset = challenge['logo'];
            var name = challenge[('ui_name_top_alliances' in challenge ? 'ui_name_top_alliances' : 'ui_name')];
            var descr;
            if(!player.is_ladder_player() && ('ui_description_nonladder' in challenge)) {
                descr = challenge['ui_description_nonladder'];
            } else {
                descr = challenge['ui_description'];
            }
            d.widgets['header_img'].tooltip.str = name + '\n\n' + descr;

            for(var i = 0; i < d.data['widgets']['header_prize_rank']['array'][1]; i++) {
                var font = SPUI.make_font(d.data['widgets']['header_prize_rank']['text_size'], d.data['widgets']['header_prize_rank']['text_size']+3, (i == 0 ? 'bold' : 'normal'));
                d.widgets['header_prize_rank'+i].font = d.widgets['header_prize_amount'+i].font = font;
                d.widgets['header_prize_rank'+i].str = d.data['widgets']['header_prize_rank']['ui_name'].replace('%d', (i+1).toString());
                d.widgets['header_prize_amount'+i].str = Store.display_user_currency_amount(Store.convert_credit_price_to_currency(challenge['prizes'][i], 'gamebucks'));
                if(challenge['prizes'][i] > 0) {
                    d.user_data['has_header_prize'] = true;
                }
                d.widgets['header_prize_rank'+i].show = d.widgets['header_prize_amount'+i].show = (challenge['prizes'][i]>0);
            }
            // hide prize-related widgets if there are no prizes
            d.widgets['header_prize_top'].show =
                d.widgets['header_prize_icon'].show = d.user_data['has_header_prize'];

            AllianceCache.query_score_leaders([d.user_data['point_stat']['name'], d.user_data['point_stat']['time_scope']], (session.alliance_id > 0), (function(_d) { return function(r) {
                var _dialog = _d.parent;
                _d.user_data['pending'] = false;
                _d.widgets['loading_rect'].show = _d.widgets['loading_text'].show = _d.widgets['loading_spinner'].show = false;

                if(!r || r.length < 1) {
                    _d.widgets['empty_results'].show = true;
                    return;
                }

                // insert a separator anywhere there is a gap in rank numbers
                for(var i = 0; i < r.length-1; i++) {
                    if(r[i+1]['rank'] > r[i]['rank']+1) {
                        r.splice(i+1, 0, ALLIANCE_LIST_SEPARATOR);
                        i++;
                    }
                }

                // insert two blanks at beginning for the header
                r.splice(0, 0, null);
                r.splice(0, 0, null);

                // insert separator at end
                if(r.length > 0 && r[r.length-1] !== ALLIANCE_LIST_SEPARATOR) {
                    r.push(ALLIANCE_LIST_SEPARATOR);
                }

                // insert ranks/scores into cache and build list for rowdata
                _d.user_data['rowdata'] = [];
                for(var i = 0; i < r.length; i++) {
                    if(r[i] === null || r[i] === ALLIANCE_LIST_SEPARATOR) {
                        _d.user_data['rowdata'].push(r[i]);
                        continue;
                    } else {
                        _d.user_data['rowdata'].push(r[i]['alliance_id']);
                        var props = {};
                        props[_d.user_data['point_stat']['name']] = r[i]['absolute'];
                        props[_d.user_data['point_stat']['name']+'_rank'] = r[i]['rank'];
                        AllianceCache.update(r[i]['alliance_id'], props);
                    }
                }

                scrollable_dialog_change_page(_d, 0);

            }; })(d));
        }

        scrollable_dialog_change_page(d, 0);
    } else if(newtab == 'join') {
        var d = dialog.widgets['join_tab'];
        d.user_data['page'] = -1;

        if((!d.user_data['rowdata'] || (d.user_data['rowdata'].length < 1)) && !d.user_data['pending']) {
            d.user_data['pending'] = true;
            d.widgets['loading_rect'].show = d.widgets['loading_text'].show = d.widgets['loading_spinner'].show = true;
            d.user_data['rows_per_page'] = d.data['widgets']['alliances']['array'][1];
            d.user_data['rowdata'] = []; // this holds the alliance ID list
            d.user_data['rowfunc'] = alliance_list_rowfunc;
            AllianceCache.query_list((function(_d) { return function(r) {
                var _dialog = _d.parent;
                _d.user_data['pending'] = false;
                _d.widgets['loading_rect'].show = _d.widgets['loading_text'].show = _d.widgets['loading_spinner'].show = false;

                // sort by ui_priority, then join type ('anyone' perferred), then number of members DESC (so alliances with *fewer* vacant spots appear first)
                var compare_for_list = function (a,b) {
                    var a_ui_priority = ('ui_priority' in a ? a['ui_priority'] : 0);
                    var b_ui_priority = ('ui_priority' in b ? b['ui_priority'] : 0);
                    if(a_ui_priority > b_ui_priority) {
                        // prefer higher ui_priority
                        return -1;
                    } else if(a_ui_priority < b_ui_priority) {
                        return 1;
                    } else if(a['join_type'] == 'anyone' && b['join_type'] != 'anyone') {
                        return -1;
                    } else if(a['join_type'] != 'anyone' && b['join_type'] == 'anyone') {
                        return 1;
                    } else if(a['num_members'] > b['num_members']) {
                        return -1;
                    } else if(a['num_members'] < b['num_members']) {
                        return 1;
                    } else {
                        return 0;
                    }
                };
                r.sort(compare_for_list);

                // add a separator on the end to emphasize that this is not a complete list
                r.push(ALLIANCE_LIST_SEPARATOR);

                // note: stashes full result, does NOT go through the global cache (should it?)
                _d.user_data['rowdata'] = r;
                scrollable_dialog_change_page(_d, 0);
            }; })(d));
        }

        scrollable_dialog_change_page(d, 0);
    } else if(newtab == 'search') {
        var d = dialog.widgets['search_tab'];
        if(!d.user_data['init']) {
            d.user_data['init'] = true;
            d.user_data['pending'] = false;
            d.user_data['page'] = -1;
            d.user_data['rows_per_page'] = d.data['widgets']['alliances']['array'][1];
            d.user_data['rowdata'] = []; // this holds the alliance ID list
            d.user_data['rowfunc'] = alliance_list_rowfunc;

            d.widgets['search_input'].allowed_chars = name_chars_ext;
            d.widgets['search_input'].ontype = function(w) {
                var _d = w.parent;
                _d.widgets['search_button'].state = (_d.user_data['pending'] || !_d.parent || !w.str || w.str.length < 1 ? 'disabled' : 'normal');
            };
            d.widgets['search_button'].state = 'disabled'; // until first character is typed
            d.widgets['likes_button'].show = (spin_frame_platform == 'fb');
            d.widgets['likes_button'].onclick = function(w) {
                w.state = (w.state == 'active' ? 'normal' : 'active');
            };

            d.widgets['search_input'].ontextready = d.widgets['search_button'].onclick = function(w) {
                var _d = w.parent;
                if(_d.user_data['pending'] || !_d.parent) { return; }
                var terms = _d.widgets['search_input'].str;
                if(!terms) {
                    return;
                    //terms = '';
                }
                _d.user_data['rowdata'] = [];
                _d.user_data['pending'] = true;
                _d.widgets['empty_results'].show = false;
                _d.widgets['search_button'].state = 'disabled';
                _d.widgets['search_input'].state = 'disabled';
                _d.widgets['search_button'].str = _d.data['widgets']['search_button']['ui_name_searching'];
                _d.widgets['loading_rect'].show = _d.widgets['loading_text'].show = _d.widgets['loading_spinner'].show = true;
                scrollable_dialog_change_page(_d, 0);

                AllianceCache.search_list(terms, (function(__d) { return function(r) {

                    // keep the dialog locked for a while longer to prevent ape-on-crack spam
                    window.setTimeout((function (___d, _r) { return function() {
                        // sort alphabetically
                        _r.sort(function (a,b) { return (a['ui_name'] > b['ui_name'] ? 1 : (a['ui_name'] < b['ui_name'] ? -1 : 0)) });
                        // note: stashes full result, does NOT go through the global cache (should it?)
                        ___d.user_data['rowdata'] = _r;

                        ___d.widgets['empty_results'].show = (_r.length < 1);

                        scrollable_dialog_change_page(___d, 0);

                        ___d.user_data['pending'] = false;
                        ___d.widgets['search_button'].state = 'normal';
                        ___d.widgets['search_input'].state = 'normal';
                        ___d.widgets['search_button'].str = ___d.data['widgets']['search_button']['ui_name'];
                        ___d.widgets['loading_rect'].show = ___d.widgets['loading_text'].show = ___d.widgets['loading_spinner'].show = false;
                    }; })(__d, r), 2000);

                }; })(_d));
            };
        }
        SPUI.set_keyboard_focus(d.widgets['search_input']);
        scrollable_dialog_change_page(d, 0);
    } else if(newtab == 'search_player') {
        var d = dialog.widgets['search_player_tab'];
        if(!d.user_data['init']) {
            d.user_data['init'] = true;
            d.user_data['pending'] = false;
            d.user_data['page'] = -1;
            d.user_data['rows_per_page'] = d.data['widgets']['players']['array'][1];
            d.user_data['rowdata'] = []; // this holds the player ID list
            d.user_data['point_stat'] = null;
            if(event) {
                d.user_data['event'] = event;
                d.user_data['event_end_time'] = player.current_alliance_stat_tournament_end_time();
                d.user_data['point_stat'] = event['stat'];
                d.user_data['point_icon_30x30_asset'] = dialog.user_data['point_icon_15x15_asset'] = event['icon'];
                d.user_data['point_icon_30x30_state'] = 'icon_30x30';
                d.user_data['point_icon_15x15_state'] = 'icon_15x15';
            } else {
                var trophy_type = player.current_trophy_type();
                if(trophy_type) {
                    var challenge_name = player.current_trophy_challenge_name();
                    d.user_data['event'] = gamedata['events'][challenge_name];
                    d.user_data['event_end_time'] = player.get_absolute_time() + player.current_trophy_challenge_togo();
                    d.user_data['point_stat'] = {'name': 'trophies_'+trophy_type,
                                                      'time_scope': (trophy_type == 'pvp' ? gamedata['matchmaking']['ladder_point_frequency'] : 'week')};
                    d.user_data['point_icon_30x30_asset'] = 'trophy_30x30';
                    d.user_data['point_icon_30x30_state'] = trophy_type;
                    d.user_data['point_icon_15x15_asset'] = 'trophy_15x15';
                    d.user_data['point_icon_15x15_state'] = trophy_type;
                }
            }

            d.user_data['rowfunc'] = function(dialog, row, rowdata) {
                var user_id = rowdata;
                var w = dialog.widgets['players'+row.toString()];
                w.user_data['user_id'] = user_id;
                if(user_id) {
                    w.show = true;
                    w.ondraw = alliance_info_member_row_update;

                    // hide unnecessary widgets
                    goog.array.forEach(['role_icon','manage_button'], function(wname) { w.widgets[wname].show = false; });

                    var r = w.user_data['user_info'] = PlayerCache.query_sync(user_id);
                    w.widgets['name'].str = PlayerCache.get_ui_name(r);
                    w.widgets['level'].str = w.data['widgets']['level']['ui_name'].replace('%d', (r['player_level'] || 1).toString());
                    w.widgets['portrait'].set_user(user_id);
                    w.widgets['info'].str = w.data['widgets']['info']['ui_player_id'].replace('%d', user_id.toString());
                    w.widgets['button'].show = (user_id != session.user_id); // no button for yourself
                    w.widgets['button'].str = w.data['widgets']['button']['ui_name_info'];

                    w.widgets['portrait'].onclick = w.widgets['button'].onclick = function(button) {
                        var _w = button.parent;
                        PlayerInfoDialog.invoke(_w.user_data['user_id']);
                    };
                } else {
                    w.show = false;
                }
            };

            d.widgets['search_input'].ontype = function(w) {
                var _d = w.parent;
                _d.widgets['search_button'].state = (_d.user_data['pending'] || !_d.parent || !w.str || w.str.length < 1 ? 'disabled' : 'normal');
            };
            d.widgets['search_button'].state = 'disabled'; // until first character is typed

            d.widgets['search_input'].ontextready = d.widgets['search_button'].onclick = function(w) {
                var _d = w.parent;
                if(_d.user_data['pending'] || !_d.parent) { return; }
                var terms = _d.widgets['search_input'].str;
                if(!terms) {
                    return;
                }
                _d.user_data['rowdata'] = [];
                _d.user_data['pending'] = true;
                _d.widgets['empty_results'].show = false;
                _d.widgets['search_button'].state = 'disabled';
                _d.widgets['search_input'].state = 'disabled';
                _d.widgets['search_button'].str = _d.data['widgets']['search_button']['ui_name_searching'];
                _d.widgets['loading_rect'].show = _d.widgets['loading_text'].show = _d.widgets['loading_spinner'].show = true;
                scrollable_dialog_change_page(_d, 0);

                search_player_cache(terms, (function(__d) { return function(r) {

                    // keep the dialog locked for a while longer to prevent ape-on-crack spam
                    window.setTimeout((function (___d, _r) { return function() {
                        // sort by name, then level
                        _r.sort(function (a,b) {
                            var data_a = PlayerCache.query_sync(a);
                            var data_b = PlayerCache.query_sync(b);
                            var na = PlayerCache.get_ui_name(data_a);
                            var nb = PlayerCache.get_ui_name(data_b);
                            var la = ('player_level' in data_a ? data_a['player_level'] : 1);
                            var lb = ('player_level' in data_b ? data_b['player_level'] : 1);
                            if(na < nb) {
                                return -1;
                            } else if(na > nb) {
                                return 1;
                            } else if(la > lb) {
                                return -1;
                            } else if(la < lb) {
                                return 1;
                            } else {
                                return 0;
                            }
                        });

                        ___d.user_data['rowdata'] = _r;

                        ___d.widgets['empty_results'].show = (_r.length < 1);

                        scrollable_dialog_change_page(___d, 0);

                        ___d.user_data['pending'] = false;
                        ___d.widgets['search_button'].state = 'normal';
                        ___d.widgets['search_input'].state = 'normal';
                        ___d.widgets['search_button'].str = ___d.data['widgets']['search_button']['ui_name'];
                        ___d.widgets['loading_rect'].show = ___d.widgets['loading_text'].show = ___d.widgets['loading_spinner'].show = false;
                    }; })(__d, r), 2000);

                }; })(_d));
            };
        }
        SPUI.set_keyboard_focus(d.widgets['search_input']);
        scrollable_dialog_change_page(d, 0);
    } else if(newtab == 'create' || newtab == 'modify') {
        var d = dialog.widgets['create_tab'];
        if(!d.user_data['init']) {
            d.user_data['init'] = true;
            d.user_data['pending'] = false;
            d.user_data['join_type'] = 'anyone';
            d.user_data['logo'] = 'circstar'; // default alliance logo
            d.user_data['modify'] = false;
            d.user_data['changed'] = false;

            d.widgets['name_input'].allowed_chars = name_chars_ext;
            d.widgets['descr_input'].disallowed_chars =
                d.widgets['motd_input'].disallowed_chars = ['\n', '\t', '\r'];
            d.widgets['tag_input'].allowed_chars = tag_chars_ext;

            d.widgets['tag_label'].show =
                d.widgets['tag_input_bg'].show =
                d.widgets['tag_input'].show = player.get_any_abtest_value('enable_alliance_chat_tags', gamedata['client']['enable_alliance_chat_tags']);

            // pre-fill fields
            if(newtab == 'modify') {
                d.user_data['modify'] = true;
                var info = AllianceCache.query_info_sync(session.alliance_id);
                if(info) {
                    d.widgets['name_input'].str = info['ui_name'] || '';
                    d.widgets['tag_input'].str = info['chat_tag'] || '';
                    d.widgets['descr_input'].str = info['ui_description'] || '';
                    d.widgets['motd_input'].str = info['chat_motd'] || gamedata['strings']['alliance_default_chat_motd'];
                    d.user_data['logo'] = info['logo'] || null;
                    d.user_data['join_type'] = info['join_type'] || 'anyone';
                }
            } else if(newtab == 'create') {
                d.widgets['motd_input'].str = gamedata['strings']['alliance_default_chat_motd'];
            }

            d.widgets['name_input'].ontype =
                d.widgets['tag_input'].ontype =
                d.widgets['descr_input'].ontype =
                d.widgets['motd_input'].ontype =
                function(w) {
                    w.parent.user_data['changed'] = true;
                    // enable "edit/create" button
                    alliance_list_create_tab_update_create_button(d);
                };

            for(var i = 0; i < d.data['widgets']['join_type_choice']['array'][0]; i++) {
                var w = d.widgets['join_type_choice'+i.toString()];
                var mytype = d.data['widgets']['join_type_choice']['join_types'][i];
                w.str = gamedata['strings']['alliance_join_types'][mytype];
                w.tooltip.str = gamedata['strings']['alliance_join_type_tips'][mytype];
                w.state = (mytype==d.user_data['join_type'] ? 'active' : 'normal');
                w.onclick = (function (_i) { return function(_w) {
                    var d = _w.parent;
                    d.user_data['changed'] = true;
                    d.user_data['join_type'] = d.data['widgets']['join_type_choice']['join_types'][_i];
                    for(var j = 0; j < d.data['widgets']['join_type_choice']['array'][0]; j++) {
                        d.widgets['join_type_choice'+j.toString()].state = (d.data['widgets']['join_type_choice']['join_types'][j] == d.user_data['join_type'] ? 'active' : 'normal');
                    }
                }; })(i);
            }

            d.widgets['logo_button'].onclick =
                d.widgets['logo_frame'].onclick =
                function(w) { invoke_alliance_logo_chooser(w.parent, w.parent.user_data['logo']); };
        }

        d.widgets['logo'].asset = get_alliance_logo_asset(d.user_data['logo'] || null);

        SPUI.set_keyboard_focus(d.widgets['name_input']);
        d.ondraw = function(d) {
            alliance_list_create_tab_update_create_button(d);
        };

    } else if(newtab == 'info') {
        var d = dialog.widgets['info_tab'];
        if(info_id) {
            // the info_id passed in may be undefined if we are returning from a child tab
            init_alliance_info_tab(d, info_id);
        }
    } else if(newtab == 'your') {
        init_alliance_info_tab(dialog.widgets['your_tab'], session.alliance_id);
    }
}

// GUI code is annoying :P - this function exists only to update the state of the "Create" button and its price display
function alliance_list_create_tab_update_create_button(d) {
        var spell = gamedata['spells'][(d.user_data['modify'] ? 'ALLIANCE_MODIFY' : 'ALLIANCE_CREATE')];
        var res = null;
        for(var r in spell['price']) { res = r; } // XXX hard-coded for one resource
        d.widgets['price_display'].str = pretty_print_number(spell['price'][res]);
        d.widgets['price_icon'].asset = gamedata['resources'][res]['icon_small'];
        var pred = read_predicate({'predicate':'LIBRARY','name':'alliance_create_requirement'});
        var pred_ok = pred.is_satisfied(player, null);

        d.widgets['create_button'].str = d.data['widgets']['create_button']['ui_name'+(d.user_data['modify'] ? '_modify' : '')];
        d.widgets['tag_instructions'].show = false;

        if(!pred_ok) {
            d.widgets['create_button'].state = 'disabled_clickable';
            d.widgets['create_button'].tooltip.str = d.data['widgets']['create_button']['ui_tooltip_unmet_requirement'].replace('%s',pred.ui_describe(player));
            d.widgets['create_button'].onclick = get_requirements_help(pred, null);
        } else if(!d.user_data['modify'] && gamedata['spells']['ALLIANCE_LEAVE']['cooldown'] > 0 && player.cooldown_active(gamedata['spells']['ALLIANCE_LEAVE']['cooldown_name'])) {
            d.widgets['create_button'].state = 'disabled';
            d.widgets['create_button'].tooltip.str = d.data['widgets']['create_button']['ui_tooltip_on_cooldown'].replace('%s', pretty_print_time(player.cooldown_togo(gamedata['spells']['ALLIANCE_LEAVE']['cooldown_name'])));
        } else if(d.widgets['tag_input'].show && d.widgets['tag_input'].str.length != 3) {
            d.widgets['create_button'].state = 'disabled';
            d.widgets['create_button'].tooltip.str = d.data['widgets']['create_button']['ui_tooltip_tag_missing'];
            d.widgets['tag_instructions'].show = true;
        } else if(player.resource_state[res][1] < spell['price'][res]) {
            d.widgets['create_button'].state = 'disabled_clickable';
            d.widgets['create_button'].tooltip.str = d.data['widgets']['create_button']['ui_tooltip_insuf'];
            d.widgets['create_button'].onclick = get_requirements_help(res, spell['price'][res] - player.resource_state[res][1]);
        } else {
            d.widgets['create_button'].state = 'normal';
            d.widgets['create_button'].tooltip.str = null;
                d.widgets['create_button'].onclick = function(w) {
                    var d = w.parent;
                    d.widgets['create_button'].state = 'disabled';
                    d.widgets['loading_rect'].show = d.widgets['loading_text'].show = d.widgets['loading_spinner'].show = true;
                    d.widgets['loading_text'].str = d.data['widgets']['loading_text']['ui_name'+(d.user_data['modify'] ? '_modify': '')];

                    var props = {'ui_name': d.widgets['name_input'].str,
                                 'chat_tag': d.widgets['tag_input'].str,
                                 'ui_descr': d.widgets['descr_input'].str,
                                 'chat_motd': d.widgets['motd_input'].str,
                                 'join_type': d.user_data['join_type'],
                                 'logo': d.user_data['logo'] };

                    var callback = (function (_d) { return function(new_id) {
                        _d.user_data['pending'] = false;
                        _d.widgets['loading_rect'].show = _d.widgets['loading_text'].show = _d.widgets['loading_spinner'].show = false;
                        if(new_id > 0) {
                            // creation/modification successful
                            change_selection_ui(null);
                            notification_queue.push_with_priority((function (_new_id) { return function() {
                                invoke_alliance_info(_new_id);
                            }; })(new_id), -3);
                        } else {
                            // failure, reinitialize dialog tab
                            if(_d.parent) {
                                alliance_list_change_tab(_d.parent, _d.parent.user_data['tab']);
                            }
                        }
                    }; })(d);

                    if(d.user_data['modify']) {
                        AllianceCache.send_modify(props, callback);
                    } else {
                        AllianceCache.send_create(props, callback);
                    }
                }
        }
}

function invoke_alliance_logo_chooser(parent, preselect) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['alliance_logo_chooser']);
    dialog.user_data['dialog'] = 'alliance_logo_chooser';
    dialog.user_data['logo'] = preselect;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['logo']['array'][0]*dialog.data['widgets']['logo']['array'][1];
    dialog.user_data['rowfunc'] = alliance_logo_chooser_rowfunc;
    dialog.user_data['rowdata'] = [];
    dialog.user_data['scroll_by_row'] = true;
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    for(var asset in GameArt.assets) {
        if(asset.indexOf('alicon_') !== 0) { continue; }
        var name = asset.slice('alicon_'.length);
        dialog.user_data['rowdata'].push(name);
    }
    scrollable_dialog_change_page(dialog, 0);
    return dialog;
}
function alliance_logo_chooser_rowfunc(dialog, row, name) {
    var x = row % dialog.data['widgets']['logo']['array'][0], y = Math.floor(row / dialog.data['widgets']['logo']['array'][0]);
    var wcoord = x.toString()+','+y.toString();
    var wname = 'logo'+wcoord;
    var w = dialog.widgets[wname];
    var fw = dialog.widgets['logo_frame'+wcoord];
    w.show = fw.show = !!name;

    if(w.show) {
        w.asset = get_alliance_logo_asset(name);
        fw.onclick = (function (_name) { return function(w) {
            var _dialog = w.parent;
            _dialog.user_data['logo'] = _name;
            if(_dialog.parent && _dialog.parent.widgets['create_tab'] &&
               _dialog.parent.widgets['create_tab'].user_data) {
                _dialog.parent.widgets['create_tab'].user_data['logo'] = _dialog.user_data['logo'];
                _dialog.parent.widgets['create_tab'].user_data['changed'] = true;
                alliance_list_change_tab(_dialog.parent, _dialog.parent.user_data['tab']);
            }
            close_parent_dialog(w);
        }; })(name);
    }
}

player.get_gift_order_candidates = function() {
    var ret = [];
    goog.array.forEach(player.friends, function(fr) {
        if(fr.is_real_friend) {
            ret.push({'user_id':fr.user_id,'facebook_id':fr.get_facebook_id(),'player_level':fr.get_player_level(),'ui_name':fr.get_ui_name()});
        }
    });
    return ret;
}

function invoke_choose_gift_order_dialog(parent, candidate_list) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['choose_gift_order_dialog']);
    dialog.user_data['dialog'] = 'choose_gift_order_dialog';
    dialog.user_data['parent'] = parent;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['portrait']['array'][1];
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    // build list of friends/alliancemates
    dialog.user_data['rowdata'] = [];
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;
    dialog.user_data['rowdata'] = dialog.user_data['rowdata'].concat(candidate_list);

    // sort alphabetically
    dialog.user_data['rowdata'].sort(function (a,b) {
        var na = a['ui_name'];
        var nb = b['ui_name'];
        if(na < nb) {
            return -1;
        } else if(na > nb) {
            return 1;
        } else {
            return 0;
        }
    });
    dialog.user_data['rowfunc'] = choose_gift_order_dialog_setup_row;
    scrollable_dialog_change_page(dialog, 0);
    return dialog;
}

function choose_gift_order_dialog_setup_row(dialog, row, rowdata) {
    dialog.widgets['separator'+(row+1)].show =
        dialog.widgets['portrait'+row].show =
        dialog.widgets['name'+row].show =
        dialog.widgets['button'+row].show = (rowdata !== null);
    if(rowdata !== null) {
        dialog.widgets['portrait'+row].set_user(rowdata['user_id']);

        dialog.widgets['name'+row].str = dialog.data['widgets']['name']['ui_name'].replace('%s', rowdata['ui_name']).replace('%d', rowdata['player_level'].toString());
        dialog.widgets['button'+row].onclick = (function (_rowdata) { return function(w) {
            var buy_dialog = w.parent.user_data['parent'];
            close_parent_dialog(w);
            buy_dialog.user_data['gift_order'] = {'gifts': [{'recipient_user_id':_rowdata['user_id'],
                                                             'recipient_facebook_id':_rowdata['facebook_id'],
                                                             'recipient_player_level':_rowdata['player_level'],
                                                             'recipient_ui_name':_rowdata['ui_name']}] };
        }; })(rowdata);
    }
}

function invoke_confirm_gift_order_dialog(gift_order, go_cb) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['confirm_gift_order_dialog']);
    dialog.user_data['dialog'] = 'you_sent_gift_order_dialog';
    dialog.user_data['go_cb'] = go_cb;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var entry = gift_order['gifts'][0];

    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name'].replace('%s', entry['recipient_ui_name']).replace('%GAMEBUCKS_NAME', player.get_any_abtest_value('gamebucks_ui_name', gamedata['store']['gamebucks_ui_name']));
    dialog.widgets['friend_icon'].set_user(entry['recipient_user_id']);
    dialog.widgets['player_id'].str = dialog.data['widgets']['player_id']['ui_name'].replace('%d',entry['recipient_user_id'].toString());
    dialog.widgets['gamebucks_icon'].asset = player.get_any_abtest_value('gamebucks_icon_med', gamedata['store']['gamebucks_icon_med']);
    dialog.widgets['gamebucks_amount'].str = Store.display_user_currency_amount(entry['gamebucks'], 'normal');
    dialog.widgets['cancel_button'].onclick = dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['ok_button'].onclick = function(w) { var cb = w.parent.user_data['go_cb']; close_parent_dialog(w); cb(); };
    return dialog;
}

function invoke_you_sent_gift_order_dialog(gift_order) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['you_sent_gift_order_dialog']);
    dialog.user_data['dialog'] = 'you_sent_gift_order_dialog';
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var entry = gift_order['gifts'][0];

    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name'].replace('%s', entry['recipient_ui_name']);
    dialog.widgets['friend_icon'].set_user(entry['recipient_user_id']);
    dialog.widgets['player_id'].str = dialog.data['widgets']['player_id']['ui_name'].replace('%d',entry['recipient_user_id'].toString());
    dialog.widgets['gamebucks_icon'].asset = player.get_any_abtest_value('gamebucks_icon_med', gamedata['store']['gamebucks_icon_med']);
    dialog.widgets['gamebucks_amount'].str = Store.display_user_currency_amount(entry['gamebucks'], 'normal');
    dialog.widgets['ok_button'].onclick = close_parent_dialog;
    return dialog;
}

function invoke_alliance_join_request(user_id) {
    var info = PlayerCache.query_sync(user_id);
    if(!info) { return null; }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['alliance_join_request_dialog']);
    dialog.user_data['dialog'] = 'alliance_join_request_dialog';
    dialog.user_data['user_id'] = user_id;
    dialog.user_data['user_info'] = info;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var ui_name = PlayerCache.get_ui_name(info);
    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name'].replace('%s', ui_name);
    dialog.widgets['description'].str = dialog.data['widgets']['description']['ui_name'].replace('%s', ui_name);
    dialog.widgets['friend_icon'].set_user(user_id);
    dialog.widgets['friend_icon'].onclick = (function (_user_id) { return function(w) { PlayerInfoDialog.invoke(_user_id); }; })(user_id);

    // trophy query
    var trophy_type = player.current_trophy_type();
    if(trophy_type) {
        var trophy_freq = (trophy_type == 'pvp' ? gamedata['matchmaking']['ladder_point_frequency'] : 'week');
        dialog.widgets['trophy_icon'].show = dialog.widgets['trophy_spinner'].show = true;
        dialog.widgets['trophy_icon'].state = trophy_type;
        query_player_scores([user_id], [['trophies_'+trophy_type, trophy_freq]], (function (_dialog, _trophy_type) { return function(user_ids, data) {
            if(!_dialog.parent) { return; }
            _dialog.widgets['trophy_spinner'].show = false;
            _dialog.widgets['trophy_count'].show = true;
            var count = 0;
            if(data[0][0]) { count = data[0][0]['absolute']; }
            _dialog.widgets['trophy_count'].str = pretty_print_number(display_trophy_count(count, _trophy_type));
        }; })(dialog, trophy_type));
    }

    // tournament stat query
    var event = player.current_alliance_stat_tournament_event();
    if(event) {
        dialog.widgets['stat_icon'].asset = event['icon'];
        dialog.widgets['stat_icon'].show = dialog.widgets['stat_spinner'].show = true;
        query_player_scores([user_id], [[event['stat']['name'], event['stat']['time_scope']]], (function (_dialog) { return function(user_ids, data) {
            if(!_dialog.parent) { return; }
            _dialog.widgets['stat_spinner'].show = false;
            _dialog.widgets['stat_count'].show = true;
            var count = 0;
            if(data[0][0]) { count = data[0][0]['absolute']; }
            _dialog.widgets['stat_count'].str = pretty_print_qty_brief(count);
        }; })(dialog));
    }

    if(info['home_region'] && info['home_region'] in gamedata['regions'] && session.region.data &&
       session.region.data['id'] != info['home_region'] &&
       'requires' in gamedata['regions'][info['home_region']] &&
       !read_predicate(gamedata['regions'][info['home_region']]['requires']).is_satisfied(player, null)) {
        dialog.widgets['region_lock_warning'].show = true;
    }

    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['accept_button'].onclick = function(w) {
        AllianceCache.ack_join_request(session.alliance_id, w.parent.user_data['user_id'], true, function() {});
        GameArt.play_canned_sound('success_playful_22');;
        close_parent_dialog(w);
    };
    dialog.widgets['reject_button'].onclick = function(w) {
        AllianceCache.ack_join_request(session.alliance_id, w.parent.user_data['user_id'], false, function() {});
        close_parent_dialog(w);
    };
    return dialog;
}

function _invoke_alliance_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['alliance_list_dialog']);
    dialog.user_data['dialog'] = 'alliance_list_dialog';
    dialog.user_data['tab'] = null;
    dialog.user_data['prev_tab'] = null;
    //change_selection_ui(dialog);
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['top_alliances_button'].onclick = function (w) { alliance_list_change_tab(w.parent, 'top'); };
    dialog.widgets['join_alliance_button'].onclick = function (w) { alliance_list_change_tab(w.parent, 'join'); };
    dialog.widgets['join_alliance_button'].str = dialog.data['widgets']['join_alliance_button']['ui_name_'+(session.is_in_alliance() ? 'in_alliance':'no_alliance')];
    dialog.widgets['create_alliance_button'].onclick = function (w) { alliance_list_change_tab(w.parent, 'create'); };
    dialog.widgets['your_alliance_button'].onclick = function (w) { alliance_list_change_tab(w.parent, 'your'); };
    dialog.widgets['search_alliance_button'].onclick = function (w) { alliance_list_change_tab(w.parent, 'search'); };
    dialog.widgets['search_player_button'].onclick = function (w) { alliance_list_change_tab(w.parent, 'search_player'); };
    dialog.widgets['search_player_button'].show = player.get_any_abtest_value('enable_player_search', gamedata['enable_player_search'] || false);

    return dialog;
}

function invoke_alliance_dialog() {
    if(session.is_in_alliance()) {
        return invoke_alliance_info(session.alliance_id);
    } else {
        return invoke_alliance_list();
    }
}

function invoke_alliance_list() {
    var dialog = _invoke_alliance_dialog();
    var default_tab;
    if(session.is_in_alliance()) {
        default_tab = 'your';
    } else {
        if(player.use_trophies() || player.current_alliance_stat_tournament_event()) {
            default_tab = 'top';
        } else {
            default_tab = 'join';
        }
    }
    alliance_list_change_tab(dialog, default_tab);
    return dialog;
}

function invoke_alliance_info(alliance_id) {
    if(alliance_id <= 0) { return null; }
    var dialog = _invoke_alliance_dialog();
    alliance_list_change_tab(dialog, (alliance_id == session.alliance_id ? 'your' : 'info'), alliance_id);
    return dialog;
}

function init_alliance_info_tab(dialog, alliance_id) {
    dialog.user_data['alliance_id'] = alliance_id;
    dialog.user_data['rowdata'] = []; // this holds the alliance member list, sorted in display order
    dialog.user_data['rowdata_role_first'] = []; // this holds the alliance member list, sorted by rank then trophy count
    dialog.user_data['rowdata_overall'] = []; // this holds the alliance member list, sorted purely by trophy count
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['members']['array'][1];
    dialog.user_data['rowfunc'] = alliance_info_member_rowfunc;
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;
    dialog.user_data['open_time'] = client_time;
    dialog.user_data['needs_sort'] = false;
    dialog.user_data['alliance_points'] = -1;
    dialog.user_data['event'] = null;
    dialog.user_data['point_stat'] = null;
    dialog.user_data['event_end_time'] = -1;

    var event = player.current_alliance_stat_tournament_event();
    if(event) {
        dialog.user_data['event'] = event;
        dialog.user_data['event_end_time'] = player.current_alliance_stat_tournament_end_time();
        dialog.user_data['point_stat'] = event['stat'];
        dialog.user_data['point_icon_30x30_asset'] = dialog.user_data['point_icon_15x15_asset'] = event['icon'];
        dialog.user_data['point_icon_30x30_state'] = 'icon_30x30';
        dialog.user_data['point_icon_15x15_state'] = 'icon_15x15';
    } else {
        var trophy_type = player.current_trophy_type();
        if(trophy_type) {
            var challenge_name = player.current_trophy_challenge_name();
            dialog.user_data['event'] = gamedata['events'][challenge_name];
            dialog.user_data['event_end_time'] = player.get_absolute_time() + player.current_trophy_challenge_togo();
            dialog.user_data['point_stat'] = {'name': 'trophies_'+trophy_type,
                                              'time_scope': (trophy_type == 'pvp' ? gamedata['matchmaking']['ladder_point_frequency'] : 'week')};
            dialog.user_data['point_icon_30x30_asset'] = 'trophy_30x30';
            dialog.user_data['point_icon_30x30_state'] = trophy_type;
            dialog.user_data['point_icon_15x15_asset'] = 'trophy_15x15';
            dialog.user_data['point_icon_15x15_state'] = trophy_type;
        }
    }

    dialog.ondraw = resort_alliance_info_tab;
    update_alliance_info_tab(dialog);
}

/** @param {SPUI.Dialog} dialog */
function resort_alliance_info_tab(dialog) {
    var trophy_type = dialog.user_data['trophy_type'];

    if(dialog.user_data['needs_sort']) {
        var alliance_info = AllianceCache.query_info_sync(dialog.user_data['alliance_id']);
        if(alliance_info) {
            dialog.user_data['needs_sort'] = false;

            // sort member list:
            // 0) if no cache entry, put player at bottom

            // IF NEW ROLE GUI IS ON:
            // 1) higher role first
            // 2) higher trophies first

            // IF NEW ROLE GUI IS OFF:
            // 1/2) by trophies, if enabled, otherwise higher role first

            // 3) higher level first
            // 4) alphabetical by name

            var compare_members = function (_stat_name, _by_role_first) { return function (a_mem,b_mem) {
                var a = a_mem['user_id'], b = b_mem['user_id'];
                var a_info = PlayerCache.query_sync(a), b_info = PlayerCache.query_sync(b);

                // sort by role BEFORE trophies if new GUI is enabled
                if(_by_role_first) {
                    var a_role = (a_mem['role']||0), b_role = (b_mem['role']||0);
                    if(a_role > b_role) {
                        return -1;
                    } else if(a_role < b_role) {
                        return 1;
                    }
                }

                if(!a_info && !b_info) {
                    return 0;
                }
                if(a_info && !b_info) {
                    return -1;
                } else if(!a_info && b_info) {
                    return 1;
                }

                if(_stat_name) {
                    var at = (_stat_name in a_info ? a_info[_stat_name] : 0), bt = (_stat_name in b_info ? b_info[_stat_name] : 0);
                    if(at > bt) {
                        return -1;
                    } else if(at < bt) {
                        return 1;
                    }
                } else {
                    var a_role = (a_mem['role']||0), b_role = (b_mem['role']||0);
                    if(a_role > b_role) {
                        return -1;
                    } else if(a_role < b_role) {
                        return 1;
                    }
                }

                var alvl = a_info['player_level'] || 1, blvl = b_info['player_level'] || 1;
                if(alvl > blvl) {
                    return -1;
                } else if(alvl < blvl) {
                    return 1;
                }

                var aname = PlayerCache.get_ui_name(a_info);
                var bname = PlayerCache.get_ui_name(b_info);
                if(aname > bname) {
                    return 1;
                } else if(aname < bname) {
                    return -1;
                }
                return 0;
            }; };

            // sort the member list TWICE!

            // first, sort a copy with role first, then trophy count
            dialog.user_data['rowdata_role_first'] = dialog.user_data['rowdata'].slice();
            dialog.user_data['rowdata_role_first'].sort(compare_members(dialog.user_data['point_stat'] ? dialog.user_data['point_stat']['name'] : null, true));

            // then, sort a copy purely with trophy count, disregarding roles
            // (we need this to determine overvall ranks)
            dialog.user_data['rowdata_overall'] = dialog.user_data['rowdata'].slice();
            dialog.user_data['rowdata_overall'].sort(compare_members(dialog.user_data['point_stat'] ? dialog.user_data['point_stat']['name'] : null, false));

            // which one to display depends on the alliance role GUI setting
            dialog.user_data['rowdata'] = dialog.user_data[(player.get_any_abtest_value('enable_alliance_role_gui', gamedata['client']['enable_alliance_role_gui']) ? 'rowdata_role_first' : 'rowdata_overall')];
        }
    }

    // stuff ranks into PlayerCache
    // also compute alliance trophy count
    if(dialog.user_data['point_stat'] && (dialog.user_data['rowdata'].length > 0)) {
        var total = 0;
        var table = gamedata['alliances']['trophy_weights'];

        for(var i = 0; i < dialog.user_data['rowdata_overall'].length; i++) {
            var user_id = dialog.user_data['rowdata_overall'][i]['user_id'];
            var info = PlayerCache.query_sync(user_id);
            var count = ((info && (dialog.user_data['point_stat']['name'] in info)) ? info[dialog.user_data['point_stat']['name']] : 0);
            if(i < table.length) {
                total += table[i] * (dialog.user_data['point_stat']['name'].indexOf('trophies_') == 0 ? display_trophy_count(count, dialog.user_data['point_stat']['name'].split('_')[1]) : count);
            }
            var props = {};
            props['_client_alliance_rank_'+dialog.user_data['point_stat']['name']] = i;
            PlayerCache.update(user_id, props, false);
        }
        total = Math.floor(total);
        dialog.user_data['alliance_points'] = total;

        // compute trophy ranks within roles
        var last_role = -1, last_count = 0, rank_within_role = 0;
        for(var i = 0; i < dialog.user_data['rowdata_role_first'].length; i++) {
            var mem = dialog.user_data['rowdata_role_first'][i];
            var user_id = mem['user_id'];
            var role = mem['role']||0;
            var props = {};
            var info = PlayerCache.query_sync(user_id);
            var count = ((info && (dialog.user_data['point_stat']['name'] in info)) ? info[dialog.user_data['point_stat']['name']] : 0);
            if(role != last_role) {
                rank_within_role = 0;
                last_count = 0;
            } else if(count == last_count) {
                // tie, do not increment rank_within_role
            } else {
                rank_within_role += 1;
            }
            // NOTE! rank_within_role can have duplicates due to the "tying" logic above!
            props['_client_alliance_rank_within_role_'+dialog.user_data['point_stat']['name']] = rank_within_role;
            PlayerCache.update(user_id, props, false);
            last_role = role;
            last_count = count;
        }

        dialog.widgets['points_label'].show = dialog.widgets['points_icon'].show = dialog.widgets['points'].show = true;
        dialog.widgets['points_icon'].asset = dialog.user_data['point_icon_15x15_asset'];
        dialog.widgets['points_icon'].state = dialog.user_data['point_icon_15x15_state'];
        dialog.widgets['points'].str = pretty_print_number(total);

        var togo = (dialog.user_data['event_end_time'] > 0 ? dialog.user_data['event_end_time'] - player.get_absolute_time() : -1);
        dialog.widgets['points_label'].tooltip.str = dialog.data['widgets']['points_label']['ui_tooltip'];
        if(togo > 0 && togo < gamedata['client']['infinite_trophy_togo']) {
            dialog.widgets['points_label'].tooltip.str += dialog.data['widgets']['points_label']['ui_tooltip_togo'].replace('%s', pretty_print_time_brief(togo));
        }
    }

    scrollable_dialog_change_page(dialog, dialog.user_data['page']);
}

/** Describe what will happen if player leaves the current alliance.
    Extracts the appropriate strings from gamedata['strings']['alliance_leave_*'].
    @param {!Object<string,string>} s - pass in gamedata['strings']['leave_alliance_confirm'] or 'disband_alliance_confirm'
    @param {boolean} is_last_member
    @param {boolean} is_leader
    @return {string} */
function alliance_leave_ui_description(s, is_last_member, is_leader) {
    var conditions = [];

    // check if point loss applies
    var loss_fraction = eval_cond_or_literal(gamedata['matchmaking']['alliance_leave_point_loss'] || 0, player, null);
    if(loss_fraction > 0) {
        conditions.push(gamedata['strings']['alliance_leave_point_loss'].replace('%pct', (100.0*loss_fraction).toFixed(0)));
    }

    if(is_last_member) {
        conditions.push(gamedata['strings']['alliance_leave_disband']);
    } else if(is_leader) {
        conditions.push(gamedata['strings']['alliance_leave_leader']);
    }

    // check if the cooldown will apply
    var spell = gamedata['spells']['ALLIANCE_LEAVE'];
    if('cooldown' in spell && (!('cooldown_if' in spell) || read_predicate(spell['cooldown_if']).is_satisfied(player, null))) {
        var cd_time = spell['cooldown'] || -1;
        if(cd_time > 0) {
            conditions.push(gamedata['strings']['alliance_leave_cooldown'].replace('%hours', (cd_time/3600).toFixed(0)));
        }
    } else {
        conditions.push(gamedata['strings']['alliance_leave_no_cooldown']);
    }

    var ui_conditions = goog.array.map(conditions, function(x) { return '- '+x; }).join('\n');

    return s['ui_description'].replace('%conditions', ui_conditions);
}

/** @param {SPUI.Dialog} dialog */
function update_alliance_info_tab(dialog) {
    var alliance_id = dialog.user_data['alliance_id'];

    dialog.widgets['loading_rect'].show = dialog.widgets['loading_text'].show = dialog.widgets['loading_spinner'].show = true;
    dialog.widgets['join_button'].show = dialog.widgets['leave_button'].show = dialog.widgets['edit_button'].show = false;

    dialog.widgets['points_label'].show = dialog.widgets['points_icon'].show = dialog.widgets['points'].show = false;

    dialog.user_data['rowdata'] = []; // clear member list

    scrollable_dialog_change_page(dialog, 0);

    // force refresh on next query
    //AllianceCache.invalidate(alliance_id);

    AllianceCache.query_info(alliance_id, (function (_dialog) { return function(r) {
        if(!r || !('num_members' in r) || !('join_type' in r)) {
            // handle invalid alliance
            _dialog.widgets['alliance_name'].str = _dialog.data['widgets']['alliance_name']['ui_name_invalid'];
            _dialog.widgets['loading_rect'].show = _dialog.widgets['loading_text'].show = _dialog.widgets['loading_spinner'].show = false;
            return;
        }

        if('ui_name' in r) {
            _dialog.widgets['alliance_name'].str = alliance_display_name(r);
        }

        _dialog.widgets['alliance_logo'].asset = get_alliance_logo_asset(r['logo'] || null);
        if('ui_description' in r) { _dialog.widgets['alliance_description'].set_text_with_linebreaking(r['ui_description']); }
        if('num_members' in r) { _dialog.widgets['num_members'].str = r['num_members'].toString() + '/' + gamedata['alliances']['max_members'].toString(); }

        _dialog.widgets['view_battles_button'].show = !!gamedata['battle_logs_public'];
        _dialog.widgets['view_battles_button'].onclick = (function (_r) { return function(w) {
            invoke_battle_history_dialog(-1, -1, _r['id'], '', -1);
        }; })(r);

        // start loading the alliance member info
        var join_type = r['join_type'];
        _dialog.user_data['join_type'] = join_type;
        var join_type_str = gamedata['strings']['alliance_join_types'][join_type];
        _dialog.widgets['join_type'].str = _dialog.data['widgets']['join_type']['ui_name'] + join_type_str;

        var check_for_invite = (!session.is_in_alliance() && join_type == 'invite_only');

        AllianceCache.query_members(_dialog.user_data['alliance_id'], check_for_invite,
                                    (_dialog.user_data['point_stat'] ? [[_dialog.user_data['point_stat']['name'],_dialog.user_data['point_stat']['time_scope']]] : null),
              (function (__dialog) { return function(info) {
                __dialog.widgets['loading_rect'].show = __dialog.widgets['loading_text'].show = __dialog.widgets['loading_spinner'].show = false;
                if(!info || !info['members']) { return; }

                // set up leave/join button
                if(session.alliance_id == alliance_id) {
                    __dialog.widgets['leave_button'].show = true;
                    var is_leader = session.check_alliance_perm('leader');
                    var is_last_member = (info['members'].length <= 1);
                    __dialog.widgets['leave_button'].str = __dialog.data['widgets']['leave_button']['ui_name'+(is_last_member ? '_disband':'')];
                    __dialog.widgets['leave_button'].onclick = (function (_alliance_id, _ui_name, _is_last_member, _is_leader) { return function(w) {

                        var s = gamedata['strings'][(_is_last_member ? 'disband_alliance_confirm' : 'leave_alliance_confirm')];

                        invoke_child_message_dialog(s['ui_title'], alliance_leave_ui_description(s, _is_last_member, _is_leader).replace('%s', _ui_name),
                                        {'dialog':'message_dialog_big',
                                         'cancel_button': true,
                                         'ok_button_ui_name': gamedata['dialogs']['alliance_info_tab']['widgets']['leave_button']['ui_name'+(_is_last_member ? '_disband':'')],
                                         'on_ok': (function (_w, __alliance_id) { return function() {
                                             _w.state = 'disabled';
                                             _w.parent.widgets['loading_text'].show = _w.parent.widgets['loading_rect'].show = _w.parent.widgets['loading_spinner'].show = true;
                                             send_to_server.func(["ALLIANCE_LEAVE", __alliance_id]);
                                         }; })(w, _alliance_id)
                                        }
                                                   );
                    }; })(info['id'], info['ui_name'], is_last_member, is_leader);

                    __dialog.widgets['edit_button'].show = true;
                    __dialog.widgets['edit_button'].state = (session.check_alliance_perm('admin') ? 'normal' : 'disabled');
                    __dialog.widgets['edit_button'].tooltip.str = (session.check_alliance_perm('admin') ? null : gamedata['dialogs']['alliance_member_row']['widgets']['manage_button']['ui_tooltip_no_permission']);

                    if(session.check_alliance_perm('admin')) {
                        __dialog.widgets['edit_button'].onclick = function(w) {
                            alliance_list_change_tab(w.parent.parent, 'modify');
                        };
                    }

                } else {
                    __dialog.widgets['join_button'].show = true;
                    __dialog.widgets['join_button'].state = 'normal';
                    __dialog.widgets['join_button'].onclick = null;
                    __dialog.widgets['join_button'].str = __dialog.data['widgets']['join_button']['ui_name'];
                    __dialog.widgets['join_button'].tooltip.str = __dialog.data['widgets']['join_button']['ui_tooltip'];

                    var join_cb = null;

                    if(info['num_members'] >= gamedata['alliances']['max_members']) {
                        __dialog.widgets['join_button'].state = 'disabled';
                        __dialog.widgets['join_button'].tooltip.str = __dialog.data['widgets']['join_button']['ui_tooltip_full'];
                    } else if(session.is_in_alliance()) {
                        __dialog.widgets['join_button'].state = 'disabled';
                        __dialog.widgets['join_button'].tooltip.str = _dialog.data['widgets']['join_button']['ui_tooltip_leave_first'];
                    } else if(!read_predicate({'predicate':'LIBRARY','name':'alliance_join_requirement'}).is_satisfied(player,null)) {
                        var pred = read_predicate({'predicate':'LIBRARY','name':'alliance_join_requirement'});
                        __dialog.widgets['join_button'].state = 'disabled_clickable';
                        __dialog.widgets['join_button'].tooltip.str = _dialog.data['widgets']['join_button']['ui_tooltip_unmet_requirement'].replace('%s', pred.ui_describe(player));
                        __dialog.widgets['join_button'].onclick = get_requirements_help(pred, null);
                    } else if(gamedata['spells']['ALLIANCE_LEAVE']['cooldown'] > 0 && player.cooldown_active(gamedata['spells']['ALLIANCE_LEAVE']['cooldown_name'])) {
                        __dialog.widgets['join_button'].state = 'disabled';
                        __dialog.widgets['join_button'].tooltip.str = _dialog.data['widgets']['join_button']['ui_tooltip_on_cooldown'].replace('%s', pretty_print_time(player.cooldown_togo(gamedata['spells']['ALLIANCE_LEAVE']['cooldown_name'])));
                    } else if(__dialog.user_data['join_type'] == 'anyone' || info['invite_status']) {
                        join_cb = (function (w, _alliance_id, _ui_name) { return function() {
                            player.quest_tracked_dirty = true;
                            var s = gamedata['strings']['join_alliance_confirm'];
                            invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%s', _ui_name),
                                                        {'cancel_button': true,
                                                         'ok_button_ui_name': gamedata['dialogs']['alliance_info_tab']['widgets']['join_button']['ui_name'],
                                                         'on_ok': (function (_w, __alliance_id) { return function() {
                                                             invoke_ui_locker();
                                                             send_to_server.func(["ALLIANCE_JOIN", __alliance_id]);
                                                         }; })(w, _alliance_id)
                                                        }
                                                       );
                        }; })(__dialog.widgets['join_button'], info['id'], info['ui_name']);
                    } else if(__dialog.user_data['join_type'] == 'invite_only' && player.cooldown_active('alliance_join_request:'+info['id'].toString())) {
                        __dialog.widgets['join_button'].state = 'disabled';
                        __dialog.widgets['join_button'].str = __dialog.data['widgets']['join_button']['ui_name_request_sent'];
                        __dialog.widgets['join_button'].tooltip.str = __dialog.data['widgets']['join_button']['ui_tooltip_request_sent'];
                    } else if(__dialog.user_data['join_type'] == 'invite_only') {
                        join_cb = (function (w, _alliance_id, _ui_name) { return function() {
                            player.quest_tracked_dirty = true;
                            var s = gamedata['strings']['send_alliance_join_request_confirm'];
                            invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%s', _ui_name),
                                                        {'cancel_button': true,
                                                         'ok_button_ui_name': s['ui_button'],
                                                         'on_ok': (function (_w, __alliance_id, __ui_name) { return function() {
                                                             invoke_ui_locker();

                                                             AllianceCache.send_join_request(__alliance_id, (function (__w, ___alliance_id, ___ui_name) { return function (success) {
                                                                 var s = gamedata['strings']['send_alliance_join_request_'+(success?'success':'failure')];
                                                                 invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%s', ___ui_name));
                                                                 if(__w.parent) {
                                                                     update_alliance_info_tab(__w.parent);
                                                                 }
                                                             }; })(_w, __alliance_id, __ui_name));

                                                         }; })(w, _alliance_id, _ui_name)
                                                        });
                        }; })(__dialog.widgets['join_button'], info['id'], info['ui_name']);
                        __dialog.widgets['join_button'].tooltip.str = _dialog.data['widgets']['join_button']['ui_tooltip_send_request'];
                    } else {
                        __dialog.widgets['join_button'].state = 'disabled';
                        __dialog.widgets['join_button'].tooltip.str = __dialog.data['widgets']['join_button']['ui_tooltip_no_invite'];
                    }

                    if(join_cb) {
                        // can send request or join, but first see if leader is in a different region
                        var alliance_in_different_continent = false, continent_info = null;
                        if(('continent' in info) && player.home_continent() != info['continent']) {
                            alliance_in_different_continent = true;
                            continent_info = gamedata['continents'][info['continent']];
                        }
                        if(alliance_in_different_continent && continent_info) {
                            var bridge = continent_bridge_available();
                            if(bridge) {
                                join_cb = (function (___dialog, _continent_info, _join_cb) { return function() {
                                    var s = gamedata['strings']['join_alliance_different_continent_locked_bridge'];
                                    invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%continent', _continent_info['ui_name']),
                                                                {'dialog': 'message_dialog_big', 'close_button':true, 'cancel_button': true,
                                                                 'ok_button_ui_name': ___dialog.data['widgets']['join_button']['ui_name'], 'on_ok': _join_cb});
                                }; })(__dialog, continent_info, join_cb);
                            } else {
                                join_cb = (function (___dialog, _continent_info, _join_cb) { return function() {
                                    var s = gamedata['strings']['join_alliance_different_continent_locked'];
                                    invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%continent', _continent_info['ui_name']),
                                                                {'dialog': 'message_dialog_big', 'close_button': true, 'cancel_button': true,
                                                                 'ok_button_ui_name': ___dialog.data['widgets']['join_button']['ui_name'], 'on_ok': _join_cb});
                                }; })(__dialog, continent_info, join_cb);
                            }
                        }
                        __dialog.widgets['join_button'].onclick = join_cb;
                    }
                }

                __dialog.user_data['rowdata'] = info['members'];
                __dialog.user_data['needs_sort'] = true;
                scrollable_dialog_change_page(__dialog, 0);
              }; })(_dialog));

    }; })(dialog), {force: true, get_private_fields: (session.alliance_id == alliance_id)} );
}

// set number and color of player/alliance ranking widget
function set_rank_widget(d, ui_rank) {
    d.widgets['rank'].str = pretty_print_number(ui_rank);
    var col_str = 'color_'+ui_rank.toString();
    var col = d.data['widgets']['rank_bg'][col_str] || d.data['widgets']['rank_bg']['color'];
    d.widgets['rank_bg'].color = new SPUI.Color(col[0], col[1], col[2], col[3]);
}

/** @param {SPUI.Dialog} dialog */
function alliance_info_member_row_update(dialog) {
    if(!dialog.show || !dialog.parent) { return; }
    // optional - may not be part of an alliance
    var alliance_info = (dialog.parent.user_data['alliance_id'] ? AllianceCache.query_info_sync(dialog.parent.user_data['alliance_id']) : null);
    var r = dialog.user_data['user_info'];

    // online indicator
    dialog.widgets['online'].show = false;
    if(gamedata['client']['show_alliance_mate_online_status'] &&
       session.is_in_alliance() && alliance_info && session.alliance_id == dialog.parent.user_data['alliance_id']) {
        dialog.widgets['online'].show = true;
        var state = 'gray', msg = 'offline';
        if('LOCK_STATE' in r && r['LOCK_STATE'] === 1) {
            state = 'normal'; // green
            msg = 'online';
        } else if('LOCK_STATE' in r && r['LOCK_STATE'] == 2) {
            state = 'yellow';
            msg = 'under_attack';
        }

        dialog.widgets['online'].state = state;
        if(msg) {
            dialog.widgets['online'].tooltip.str = dialog.data['widgets']['online']['ui_tooltip_'+msg].replace('%s', pretty_print_time(client_time - dialog.parent.user_data['open_time']));
        }
    }

    // alternate between different lines of tip_info
    if(dialog.user_data['tip_info']) {
        var period = dialog.data['widgets']['info']['blink_period'];
        var index = Math.floor(((client_time - dialog.user_data['anim_start'])/period) % dialog.user_data['tip_info'].length);
        dialog.widgets['info'].str = dialog.user_data['tip_info'][index];
    }


    // trophy count
    var point_stat = dialog.parent.user_data['point_stat'];
    if(point_stat) {
        var count = ((point_stat['name'] in r) ? r[point_stat['name']] : 0);
        dialog.widgets['trophy_bg'].show =
            dialog.widgets['trophy_shine'].show =
            dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_amount'].show = true;
        dialog.widgets['trophy_icon'].asset = dialog.parent.user_data['point_icon_30x30_asset'];
        dialog.widgets['trophy_icon'].state = dialog.parent.user_data['point_icon_30x30_state'];
        dialog.widgets['trophy_amount'].str = pretty_print_number(point_stat['name'].indexOf('trophies_') ==  0 ? display_trophy_count(count, point_stat['name'].split('_')[1]) : count);
        if(('home_region' in r) && (r['home_region'] in gamedata['regions']) && alliance_info && (alliance_info['continent'] in gamedata['continents']) &&
           alliance_info['continent'] != gamedata['regions'][r['home_region']]['continent_id']) {
            dialog.widgets['trophy_amount'].text_color = dialog.widgets['trophy_bg'].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['trophy_bg'].tooltip.str = dialog.data['widgets']['trophy_bg']['ui_tooltip_different_continent'].replace('%player', gamedata['continents'][gamedata['regions'][r['home_region']]['continent_id']]['ui_name']).replace('%alliance', gamedata['continents'][alliance_info['continent']]['ui_name']);
            dialog.widgets['trophy_bg'].fixed_tooltip_offset = null;
        } else {
            dialog.widgets['trophy_amount'].text_color = dialog.widgets['trophy_bg'].tooltip.text_color = SPUI.default_text_color;
            //dialog.widgets['trophy_bg'].tooltip.str = dialog.data['widgets']['trophy_bg']['ui_tooltip'];

            var togo = player.current_trophy_challenge_togo();
            dialog.widgets['trophy_bg'].tooltip.str = dialog.data['widgets']['trophy_bg']['ui_tooltip' + (((togo > 0) && (togo < gamedata['client']['infinite_trophy_togo'])) ? '_togo' : '')].replace('%s', pretty_print_time_brief(togo));
            dialog.widgets['trophy_bg'].fixed_tooltip_offset = dialog.data['widgets']['trophy_bg']['fixed_tooltip_offset'+ (((togo > 0) && (togo < gamedata['client']['infinite_trophy_togo'])) ? '_togo' : '')];

        }
    } else {
        dialog.widgets['trophy_bg'].show =
            dialog.widgets['trophy_shine'].show =
            dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_amount'].show = false;
    }


}

function alliance_info_member_rowfunc(dialog, row, rowdata) {
    var alliance_info = AllianceCache.query_info_sync(dialog.user_data['alliance_id']);
    dialog.widgets['members'+row].user_data['user_id'] = (rowdata ? rowdata['user_id'] : -1);
    if(!('user_info' in dialog.widgets['members'+row].user_data)) { dialog.widgets['members'+row].user_data['user_info'] = null; }
    dialog.widgets['members'+row].show = (rowdata && rowdata['user_id'] > 0 && alliance_info && ('members' in alliance_info));

    dialog.widgets['members'+row].ondraw = alliance_info_member_row_update;

    if(dialog.widgets['members'+row].show) {

        // note: the query SHOULD always return synchronously, since the
        // alliance member list query also pre-fills PlayerCache with
        // entries for each member.

        var got_info = (function (d, _rownum, member) { return function (r) {
            if(!d.parent) { return; } // dialog went away
            var dialog = d.parent;

            var alliance_info = AllianceCache.query_info_sync(d.parent.user_data['alliance_id']);
            if(!alliance_info) { throw Error('no alliance_info for '+d.parent.user_data['alliance_id'].toString()); }

            var user_id = member['user_id'];

            // check user_id match, in case the query is stale
            if(d.user_data['user_id'] != user_id) { console.log("stale result"); return; }

            // bad player data
            if(!r) { d.show = false; return; }

            // force a re-sort on the next draw after NEW info comes in
            if(!d.user_data['user_info'] && d.parent) { d.parent.user_data['needs_sort'] = true; }

            d.user_data['user_info'] = r;

            // role info
            if(!('roles' in alliance_info)) { throw Error('alliance_info without roles for '+alliance_info['id'].toString()); }
            var myrole = member['role'] || 0;
            d.user_data['ui_role'] = d.data['widgets']['info']['ui_role'].replace('%s', alliance_info['roles'][myrole.toString()]['ui_name']);

            d.user_data['ui_home'] = (r['home_region'] && (r['home_region'] in gamedata['regions']) ? d.data['widgets']['info']['ui_home'].replace('%s', gamedata['regions'][r['home_region']]['ui_name']) : d.data['widgets']['info']['ui_home_unknown']);


            d.user_data['ui_donations'] = d.data['widgets']['info']['ui_donations'].replace('%d', pretty_print_number(r['units_donated_cur_alliance'] || 0));
            d.user_data['ui_helps'] = d.data['widgets']['info']['ui_helps'].replace('%d', pretty_print_number(r['help_responses_cur_alliance'] || 0));

            // last played
            if(gamedata['client']['show_alliance_mate_last_played_time'] && (session.alliance_id == d.parent.user_data['alliance_id'])) {
                var s;
                if('last_login_time' in r) {
                    var ago = server_time - r['last_login_time'];
                    if(ago < 24*60*60) {
                        s = d.data['widgets']['info']['ui_last_played_today'];
                    } else if(ago < 2*24*60*60) {
                        s = d.data['widgets']['info']['ui_last_played_day'];
                    } else if(ago >= 99*24*60*60) {
                        s = d.data['widgets']['info']['ui_last_played_99days'];
                    } else {
                        s = d.data['widgets']['info']['ui_last_played_days'].replace('%d', Math.floor(ago/(24*60*60)).toFixed(0));
                    }
                } else {
                    s = d.data['widgets']['info']['ui_last_played_unknown'];
                }
                d.user_data['ui_last_played'] = s;
            } else {
                d.user_data['ui_last_played'] = null;
            }

            // member since
            if('join_time' in member) {
                d.user_data['ui_member_since'] = d.data['widgets']['info']['ui_member_since'].replace('%s', pretty_print_date_utc(member['join_time']));
            } else {
                d.user_data['ui_member_since'] = null;
            }

            // TOOLTIP: role, last played (if alliancemate), donations, helps, member since
            d.user_data['tip_info'] = [];
            d.user_data['tip_info'].push(d.user_data['ui_role']);
            if(player.get_any_abtest_value('enable_region_map', gamedata['enable_region_map'])) { d.user_data['tip_info'].push(d.user_data['ui_home']); }
            if(gamedata['client']['show_alliance_mate_last_played_time'] && (session.alliance_id == d.parent.user_data['alliance_id'])) {
                d.user_data['tip_info'].push(d.user_data['ui_last_played'] || '');
            }
            if(gamedata['enable_unit_donation']) { d.user_data['tip_info'].push(d.user_data['ui_donations']); }
            if(player.alliance_help_enabled()) {
                d.user_data['tip_info'].push(d.user_data['ui_helps']);
            }
            d.user_data['tip_info'].push(d.user_data['ui_member_since'] || '');
            if(!d.user_data['anim_start']) {
                d.user_data['anim_start'] = d.parent.user_data['open_time'] + d.data['widgets']['info']['blink_offset']*_rownum;
            }

            d.show = true;

            d.widgets['name'].str = PlayerCache.get_ui_name(r);
            d.widgets['level'].str = d.data['widgets']['level']['ui_name'].replace('%d', (r['player_level'] || 1).toString());
            d.widgets['portrait'].set_user(user_id);

            d.widgets['info'].str = null; // set from the update function
            d.widgets['info'].tooltip.str = d.user_data['tip_info'].join('\n');

            d.widgets['portrait'].onclick = function(w) {
                var _d = w.parent;
                PlayerInfoDialog.invoke(_d.user_data['user_id']);
            };

            var point_field = (dialog.user_data['point_stat'] ? dialog.user_data['point_stat']['name'] : '');
            setup_alliance_role_widget(d.widgets['role_icon'], alliance_info['roles'][(member['role']||0).toString()],
                                       ('_client_alliance_rank_'+point_field in r ? r['_client_alliance_rank_'+point_field] : -1),
                                       ('_client_alliance_rank_within_role_'+point_field in r ? r['_client_alliance_rank_within_role_'+point_field] : -1));

            // manage button
            if(session.alliance_id == dialog.user_data['alliance_id'] && user_id != session.user_id) {
                d.widgets['manage_button'].show = true;

                // INFO
                var buttons = [new ContextMenuButton({ui_name: d.data['widgets']['manage_button']['ui_name_info'],
                                                      onclick: (function (_user_id) { return function(w) {
                                                          PlayerInfoDialog.invoke(_user_id);
                                                      }; })(user_id),
                                                      ui_tooltip: d.data['widgets']['manage_button']['ui_tooltip_info']})];

                if(gamedata['gift_alliancemates'] && player.resource_gifts_enabled()) {
                    buttons.push(new ContextMenuButton({ui_name: d.data['widgets']['manage_button']['ui_name_gift'],
                                                        onclick: (function (_user_id) { return function(w) {

                                                           player.get_giftable_friend_info_list_async((function (__user_id) { return function (ret) {
                                                               if(ret.length > 0) {
                                                                   invoke_send_gifts(__user_id, 'alliance_manage', ret);
                                                               } else {
                                                                   var s = gamedata['errors']['NO_GIFTABLE_FRIENDS'];
                                                                   var options = {'dialog': 'message_dialog_big'};
                                                                   if(friend_invites_enabled()) {
                                                                       options['ok_button_ui_name'] = s['ui_button_invite'];
                                                                       options['cancel_button'] = false;
                                                                       options['on_ok'] = function() {
                                                                           invoke_invite_friends_dialog('alliance_manage_ungiftable');
                                                                       };
                                                                   }
                                                                   invoke_child_message_dialog(s['ui_title'], s['ui_name'], options);
                                                               }
                                                           }; })(_user_id));

                                                       }; })(user_id),
                                                        ui_tooltip: d.data['widgets']['manage_button']['ui_tooltip_gift']}));
                }

                // PROMOTE/DEMOTE
                if(user_id != session.user_id && player.get_any_abtest_value('enable_alliance_role_gui', gamedata['client']['enable_alliance_role_gui'])) {
                    goog.array.forEach([{'name':'promote','incr':1},{'name':'demote','incr':-1}], function(action) {
                        var cur_role = (member['role']||0), new_role = cur_role + action['incr'];

                        if(!(new_role.toString() in alliance_info['roles'])) { return; } // invalid new role

                        // can promote if you are leader or if you have "promote" permission and your role is higher than MAX(cur_role,new_role)
                        var perm_ok = session.check_alliance_perm('leader') ||
                            (session.check_alliance_perm('promote') && ((session.alliance_membership['role']||0) > Math.max(cur_role,new_role)));
                        if(!perm_ok) {
                            buttons.push(new ContextMenuButton({ui_name: d.data['widgets']['manage_button']['ui_name_'+action['name']],
                                                                state: 'disabled',
                                                                ui_tooltip: d.data['widgets']['manage_button']['ui_tooltip_no_permission']}));
                        } else {
                            buttons.push(new ContextMenuButton({ui_name: d.data['widgets']['manage_button']['ui_name_'+action['name']],
                                                                onclick: (function (_d, _user_id, _cur_role, _new_role) { return function(w) {
                                                                    invoke_alliance_promote_dialog(_d.parent, _user_id, _cur_role, _new_role);
                                                                }; })(d, user_id, cur_role, new_role),
                                                                ui_tooltip: d.data['widgets']['manage_button']['ui_tooltip_'+action['name']]}));
                        }
                    });
                }

                // KICK
                if(user_id == session.user_id) {
                    // no kick button on yourself
                } else if(session.check_alliance_perm('kick') && ((session.alliance_membership['role']||0) > (member['role']||0))) {
                    buttons.push(new ContextMenuButton({ui_name: d.data['widgets']['manage_button']['ui_name_kick'],
                                                        onclick: (function (_d, _user_id, _ui_name) { return function(w) {
                                                            var s = gamedata['strings']['alliance_kick_confirm'];
                                                            var ui_descr = s['ui_description'].replace('%s', _ui_name);
                                                            var loss_fraction = eval_cond_or_literal(gamedata['matchmaking']['alliance_leave_point_loss'] || 0, player, null);
                                                            ui_descr = ui_descr.replace('%pct', (100.0*loss_fraction).toFixed(0));
                                                            invoke_child_message_dialog(s['ui_title'], ui_descr,
                                                                                       {'dialog': 'message_dialog_big',
                                                                                        'cancel_button': true,
                                                                                        'ok_button_ui_name': s['ui_button'],
                                                                                        'on_ok': (function (__d, __user_id) { return function() {
                                                                                            __d.widgets['manage_button'].state = 'disabled';
                                                                                            invoke_ui_locker();
                                                                                            AllianceCache.send_kick(session.alliance_id, __user_id, (function (___d) { return function (success) {
                                                                                                ___d.widgets['manage_button'].state = 'normal';
                                                                                                if(!success) { return; }
                                                                                                // refresh the alliance info tab
                                                                                                if(___d.parent) { update_alliance_info_tab(___d.parent); }
                                                                                            }; })(__d));
                                                                                        }; })(_d, _user_id)
                                                                                       });
                                                       }; })(d, user_id, d.widgets['name'].str),
                                                        ui_tooltip: d.data['widgets']['manage_button']['ui_tooltip_kick']}));
                } else {
                    buttons.push(new ContextMenuButton({ui_name: d.data['widgets']['manage_button']['ui_name_kick'],
                                                        state: 'disabled',
                                                        ui_tooltip: d.data['widgets']['manage_button']['ui_tooltip_no_permission']}));
                }

                d.widgets['manage_button'].onclick = (function (_buttons) { return function(w) {
                    invoke_generic_context_menu([mouse_state.last_raw_x, mouse_state.last_raw_y], _buttons);
                }; })(buttons);

            } else {
                d.widgets['manage_button'].show = false;
            }

            // Info or View button
            if(user_id == session.user_id) {
                // do not show on yourself
                d.widgets['button'].show = false;
            } else {
                d.widgets['button'].show = true;
                if(session.alliance_id == dialog.user_data['alliance_id']) {
                    // "view" for clanmates
                    d.widgets['button'].str = d.data['widgets']['button']['ui_name_view'];
                    d.widgets['button'].onclick = function(w) {
                        var _d = w.parent;
                        visit_base(_d.user_data['user_id']);
                    };
                } else {
                    // "info" for non-clanmates
                    d.widgets['button'].str = d.data['widgets']['button']['ui_name_info'];
                    d.widgets['button'].onclick = function(w) {
                        var _d = w.parent;
                        PlayerInfoDialog.invoke(_d.user_data['user_id']);
                    };
                }

            }
        }; })(dialog.widgets['members'+row], row, rowdata);

        got_info(PlayerCache.query_sync_fetch(rowdata['user_id']));
    }
}

function setup_alliance_role_widget(dialog, role_info, points_rank_overall, points_rank_within_role) {
    var ckind;
    if(goog.array.contains(role_info['perms'], 'leader')) {
        ckind = 'color_leader';
    } else if(points_rank_within_role < 0) {
        ckind = 'color_generic';
    } else if(('color_points'+(points_rank_within_role+1).toString()) in dialog.data['widgets']['bg']) {
        ckind = 'color_points'+(points_rank_within_role+1).toString();
    } else {
        ckind = 'color_points_low';
    }

    dialog.widgets['bg'].color = SPUI.make_colorv(dialog.data['widgets']['bg'][ckind]);
    dialog.widgets['bg'].outline_width = dialog.data['widgets']['bg'][(ckind == 'color_leader' ? 'outline_width_leader' : 'outline_width')];
    dialog.widgets['bg'].outline_color = SPUI.make_colorv(dialog.data['widgets']['bg'][(ckind == 'color_leader' ? 'outline_color_leader' : 'outline_color')]);

    if(player.get_any_abtest_value('enable_alliance_role_gui', gamedata['client']['enable_alliance_role_gui'])) {
        dialog.widgets['numeral'].str = dialog.data['widgets']['numeral']['ui_name_role'+role_info['role'].toString()];
    } else {
        // legacy case
        dialog.widgets['numeral'].str = (points_rank_overall+1).toString();
        dialog.widgets['numeral'].tooltip.str = null;
    }
}

function invoke_alliance_promote_dialog(info_tab, promotee_id, cur_role, new_role) {
    var info = PlayerCache.query_sync(promotee_id);
    var roles = AllianceCache.query_info_sync(session.alliance_id)['roles'];
    var new_role_info = roles[new_role.toString()];

    var dialog = new SPUI.Dialog(gamedata['dialogs']['alliance_promote_dialog']);
    dialog.user_data['dialog'] = 'alliance_promote_dialog';
    dialog.user_data['info_tab'] = info_tab;
    dialog.user_data['promotee_id'] = promotee_id;
    dialog.user_data['cur_role'] = cur_role;
    dialog.user_data['new_role'] = new_role;

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name_'+(new_role>cur_role?'promote':'demote')].replace('%name', PlayerCache.get_ui_name(info)).replace('%role', new_role_info['ui_name']);

    goog.array.forEach(['new_role_rect', 'new_role_icon'], function(wname) {
        dialog.widgets[wname].xy = vec_add(dialog.data['widgets'][wname]['xy'], vec_scale(new_role, dialog.data['widgets']['role_list']['array_offset']));
    });

    setup_alliance_role_widget(dialog.widgets['new_role_icon'], new_role_info, -1, -1);

    goog.array.forEach(['arrow_promote', 'arrow_demote','portrait'], function(wname) {
        dialog.widgets[wname].xy = vec_add(dialog.data['widgets'][wname]['xy'], vec_scale(cur_role, dialog.data['widgets']['role_list']['array_offset']));
        if(dialog.data['widgets'][wname]['clip_to']) {
            var corner = vec_add([dialog.data['widgets'][wname]['clip_to'][0],dialog.data['widgets'][wname]['clip_to'][1]], vec_scale(cur_role, dialog.data['widgets']['role_list']['array_offset']));
            dialog.widgets[wname].clip_to = [corner[0],corner[1],
                                             dialog.data['widgets'][wname]['clip_to'][2],dialog.data['widgets'][wname]['clip_to'][3]];
        }
    });

    dialog.widgets['arrow_promote'].show = (new_role > cur_role);
    dialog.widgets['arrow_demote'].show = (new_role < cur_role);
    dialog.widgets['portrait'].set_user(promotee_id);

    for(var i = 0; i < dialog.data['widgets']['perm_list']['array'][1]; i++) {
        var perm = dialog.data['widgets']['perm_list']['perms'][i];
        dialog.widgets['perm_list'+i.toString()].str = dialog.data['widgets']['perm_list']['ui_name_'+perm];
    }

    for(var i = 0; i < dialog.data['widgets']['role_list']['array'][0]; i++) {
        dialog.widgets['role_list'+i.toString()].str = roles[i.toString()]['ui_name'];
    }

    for(var perm_num = 0; perm_num < dialog.data['widgets']['matrix']['array'][1]; perm_num++) {
        for(var role = 0; role < dialog.data['widgets']['matrix']['array'][0]; role++) {
            var w = dialog.widgets['matrix'+role.toString()+','+perm_num.toString()];
            var allowed = goog.array.contains(roles[role.toString()]['perms'], dialog.data['widgets']['perm_list']['perms'][perm_num]);
            w.str = dialog.data['widgets']['matrix']['ui_name_'+(allowed ? 'yes' : 'no')];
            w.text_color = SPUI.make_colorv(dialog.data['widgets']['matrix']['text_color_'+(allowed ? 'yes' : 'no')]);
        }
    }

    if(goog.array.contains(new_role_info['perms'], 'leader')) {
        dialog.widgets['succession_warning'].show = true;
        dialog.widgets['succession_warning'].str = dialog.data['widgets']['succession_warning']['ui_name'].replace('%name', PlayerCache.get_ui_name(info)).replace('%role', new_role_info['ui_name']).replace('%succession_role', roles[(session.alliance_membership['role']-1).toString()]['ui_name']);
    }

    dialog.widgets['close_button'].onclick = dialog.widgets['cancel_button'].onclick = close_parent_dialog;
    dialog.widgets['ok_button'].onclick = function(w) {
        var _dialog = w.parent;
        AllianceCache.send_promote(session.alliance_id, promotee_id, cur_role, new_role, (function (__dialog) { return function (success) {
            // refresh alliance info tab
            if(success) {
                if(__dialog.user_data['info_tab'].is_visible()) { update_alliance_info_tab(__dialog.user_data['info_tab']); }
                close_parent_dialog(__dialog.widgets['ok_button']);
            }
        }; })(_dialog));
        invoke_ui_locker();
    }
    return dialog;
}

// search player.friends by user id
function find_friend_by_user_id(uid) {
    for(var i = 0; i < player.friends.length; i++) {
        var friend = player.friends[i];
        if(uid === friend.user_id) {
            return friend;
        }
    }
    return null;
}


// fill in a unit_icon dialog widget
/** @param {SPUI.Dialog} dialog
    @param {string|null} specname
    @param {number=} qty, -1 if irrelevant
    @param {Object<string,?>|null=} obj
    @param {function(SPUI.DialogWidget)|null=} onclick
    @param {string|null=} frame_state_override
    @param {string|null=} tooltip_override
    @param {boolean=} enable_dripper */
function unit_icon_set(dialog, specname, qty, obj, onclick, frame_state_override, tooltip_override, enable_dripper) {
    var spec = (specname ? gamedata['units'][specname] : null);
    dialog.user_data['spec'] = spec;
    dialog.user_data['obj'] = obj;
    dialog.user_data['frame_state_override'] = frame_state_override || null;

    // persist this, since SPUI's dripper handling checks identity of callback
    if(!dialog.user_data['my_dripper_cb']) {
        dialog.user_data['my_dripper_cb'] = (function (_w) { return function(button) { return _w.onclick(_w, button); }; })(dialog.widgets['frame']);
    }

    dialog.widgets['icon'].show = dialog.widgets['slot'].show = dialog.widgets['stack'].show = dialog.widgets['frame'].show = !!spec;
    if(spec) {
        var max_level = get_max_ui_level(gamedata['tech'][spec['level_determined_by_tech']]);
        var cur_level = (obj && ('level' in obj) ? obj['level'] :
                         player.tech[spec['level_determined_by_tech']] || 1);
        var level_str = gamedata['strings']['cursors']['level_x_of_y'].replace('%cur', cur_level.toString()).replace('%max', max_level.toString());
        dialog.widgets['icon'].asset = get_leveled_quantity(spec['art_asset'], 1);
        dialog.widgets['icon'].state = 'icon';
        dialog.widgets['stack'].str = (qty > 1 ? pretty_print_number(qty) : null);
        dialog.widgets['frame'].onclick = (onclick ? onclick : null);
        dialog.widgets['frame'].tooltip.str = (tooltip_override ? tooltip_override :
                                               (onclick ? spec['ui_name'] + '\n'+level_str + (('ui_tip' in spec) ? '\n'+spec['ui_tip'] : '') :
                                                null));
        if(enable_dripper) {
            dialog.widgets['frame'].dripper_cb = dialog.user_data['my_dripper_cb'];
            dialog.widgets['frame'].dripper_rate = 4.0;
        } else {
            dialog.widgets['frame'].dripper_cb = null;
        }
    }
    dialog.ondraw = unit_icon_update;
}

/** @param {SPUI.Dialog} dialog */
function unit_icon_update(dialog) {
    // update repair/wrench icon
    var obj = dialog.user_data['obj'];
    dialog.widgets['wrench'].show = false;
    var obj_repair_state = 0;
    if(obj) {
        obj_repair_state = army_unit_repair_state(obj);
        dialog.widgets['wrench'].show = (obj_repair_state > 0);
        dialog.widgets['wrench'].asset = dialog.data['widgets']['wrench']['asset_'+(obj_repair_state == 2 ? 'active' : 'queued')];
        dialog.widgets['wrench'].rocking = (obj_repair_state == 2);
    }
    if(dialog.widgets['frame'].show) {
        if(dialog.user_data['frame_state_override']) {
            dialog.widgets['frame'].state = dialog.user_data['frame_state_override'];
        } else {
            dialog.widgets['frame'].state = (obj_repair_state > 0 ? 'disabled' : (dialog.widgets['frame'].onclick ? 'normal' : 'normal_nohighlight'));
        }
    }
}

var SQUAD_IDS = { BASE_DEFENDERS: 0, RESERVES: -1,
                  is_mobile_squad_id: function(id) { return id > 0; }
                };

// return [cur,max] HP for a persisted unit
function army_unit_hp(obj) {
    // 20160817 client exception debugging code
    // TypeError: Cannot read property 'max_hp' of undefined
    if(obj === undefined) {
        throw Error('obj is undefined');
    } else if(!obj['spec'] || !(obj['spec'] in gamedata['units'])) {
        throw Error('bad spec: '+(obj['spec'] ? obj['spec'] : 'missing'));
    }

    var level = obj['level'] || 1;
    var spec = gamedata['units'][obj['spec']];
    var max_hp = ('max_hp' in obj ? obj['max_hp'] : get_leveled_quantity(spec['max_hp']||0, level));
    var cur_hp;
    if('hp' in obj) {
        cur_hp = obj['hp'];
    } else if('hp_ratio' in obj) {
        cur_hp = Math.floor(obj['hp_ratio'] * max_hp);
    } else {
        cur_hp = max_hp;
    }
    return [cur_hp, max_hp];
}
function army_unit_space(obj) {
    var level = obj['level'] || 1;
    var spec = gamedata['units'][obj['spec']];
    return get_leveled_quantity(spec['consumes_space']||0, level);
}
// returns: 0 if not under repair, 1 if queued, 2 if active
function army_unit_repair_state(obj) {
    for(var i = 0; i < player.unit_repair_queue.length; i++) {
        var item = player.unit_repair_queue[i];
        if(item['obj_id'] == obj['obj_id']) {
            return (i == 0 ? 2 : 1);
        }
    }
    return 0;
}

// compare units/buildings by "coolnesss" - used for sorting units in squad displays
function compare_specnames(a,b) {
    // sort by max health then space consumption then alphabet of the ui_name
    var aspec = (gamedata['units'][a] || gamedata['buildings'][a]), bspec = (gamedata['units'][b] || gamedata['buildings'][b]);
    var amax = get_leveled_quantity(aspec['max_hp'] || 0,1);
    var bmax = get_leveled_quantity(bspec['max_hp'] || 0,1);
    if(amax < bmax) { return 1; }
    if(amax > bmax) { return -1; }
    var aspace = get_leveled_quantity(aspec['consumes_space'] || 0,1);
    var bspace = get_leveled_quantity(bspec['consumes_space'] || 0,1);
    if(aspace < bspace) { return 1; }
    if(aspace > bspace) { return -1; }
    var aname = aspec['ui_name'];
    var bname = bspec['ui_name'];
    if(aname < bname) { return 1; }
    if(aname > bname) { return -1; }
    return 0;
}
function army_unit_compare(a,b) {
    var cmp = compare_specnames(a['spec'], b['spec']);
    if(cmp != 0) { return cmp; }
    var alevel = a['level']||1, blevel = b['level']||1;
    // use level to break ties
    if(alevel < blevel) { return 1; }
    if(alevel > blevel) { return -1; }
    // use current health ratio to break ties
    var acurmax = army_unit_hp(a), aratio = acurmax[0]/Math.max(acurmax[1],1);
    var bcurmax = army_unit_hp(b), bratio = bcurmax[0]/Math.max(bcurmax[1],1);
    if(aratio < bratio) { return 1; }
    if(aratio > bratio) { return -1; }
    // use obj_id to break ties, for stable sort order
    if(a['obj_id'] < b['obj_id']) { return 1; }
    if(a['obj_id'] > b['obj_id']) { return -1; }
    return 0;
}

player.get_manufacture_queue_space_usage = function() {
    var usage = 0;
    session.for_each_real_object(function(obj) {
        if(obj.team === 'player' && obj.is_building() && obj.is_manufacturer()) {
            var manuf_queue = obj.get_client_prediction('manuf_queue', obj.manuf_queue);
            goog.array.forEach(manuf_queue, function(item) {
                var space = get_leveled_quantity(gamedata['units'][item['spec_name']]['consumes_space']||0, item['level']||1);
                usage += space;
            });
        }
    });
    return usage;
};

/** @return {Object.<string,number>} */
player.get_army_unit_count_by_specname = function() {
    var ret = {};
    // count objects in army
    goog.object.forEach(player.my_army, function(obj) {
        ret[obj['spec']] = (ret[obj['spec']]||0) + 1;
    });
    // also count units that are under construction
    session.for_each_real_object(function(obj) {
        if(obj.team === 'player' && obj.is_building() && obj.is_manufacturer()) {
            var manuf_queue = obj.get_client_prediction('manuf_queue', obj.manuf_queue);
            goog.array.forEach(manuf_queue, function(item) {
                ret[item['spec_name']] = (ret[item['spec_name']]||0) + 1;
            });
        }
    });
    return ret;
};

/** @return {Object.<string,number>} */
player.get_army_space_usage_by_squad = function() {
    var reserve_sid = SQUAD_IDS.RESERVES.toString();
    var ret = {'ALL': 0}; ret[reserve_sid] = 0;
    goog.object.forEach(player.squads, function(squad) { ret[squad['id'].toString()] = 0; });
    goog.object.forEach(player.my_army, function(obj) {
        var squad_id = obj['squad_id'] || 0;
        var space = army_unit_space(obj);
        ret[squad_id.toString()] += space;
        ret['ALL'] += space;
    });
    // also add space occupied by units that are under construction
    var space = player.get_manufacture_queue_space_usage();
    if(player.squads_enabled() && !gamedata['produce_to_reserves']) {
        ret[SQUAD_IDS.BASE_DEFENDERS.toString()] += space;
    }
    ret['ALL'] += space;
    return ret;
};

player.get_squad_hp_and_space = function(squad_id) {
    var cur_space = 0;
    var max_space = (squad_id === SQUAD_IDS.BASE_DEFENDERS ? player.stattab['main_squad_space'] : player.stattab['squad_space']);
    var cur_hp = 0, max_hp = 0;
    goog.object.forEach(player.my_army, function(obj, obj_id) {
        if((obj['squad_id']||0) !== squad_id) { return; }
        var spec = gamedata['units'][obj['spec']];
        var level = obj['level'] || 1;
        cur_space += get_leveled_quantity(spec['consumes_space']||0, level);
        var curmax = army_unit_hp(obj);
        cur_hp += curmax[0];
        max_hp += curmax[1];
    });
    return {'cur_space':cur_space, 'max_space':max_space, 'cur_hp':cur_hp, 'max_hp': max_hp};
};

player.which_squad_is_under_repair = function() {
    var squad_under_repair = null;
    for(var i = 0; i < player.unit_repair_queue.length; i++) {
        var item = player.unit_repair_queue[i];
        var obj = player.my_army[item['obj_id']] || null;
        if(!obj) { continue; }
        var squad_id = obj['squad_id'] || 0;
        squad_under_repair = squad_id;
        break;
    }
    return squad_under_repair;
};
player.squad_is_under_repair = function(squad_id) { return squad_id == player.which_squad_is_under_repair(); };
player.squad_is_deployed = function(squad_id) {
    var key = squad_id.toString();
    return (key in player.squads && ('map_loc' in player.squads[key]));
};
player.squad_base_id = function(squad_id) { return 's'+session.user_id.toString()+'_'+squad_id.toString(); };
player.squad_is_in_battle = function(squad_id) {
    var key = squad_id.toString();
    if(player.squad_is_deployed(squad_id) && session.region && session.region.data) {
        var feature = session.region.find_feature_by_id(player.squad_base_id(squad_id));
        if(feature && feature['LOCK_STATE']) { return true; }
    }
    return false;
};
player.squad_is_dead = function(squad_id) {
    var cur_hp = 0, max_hp = 0;
    goog.object.forEach(player.my_army, function(obj, obj_id) {
        if((obj['squad_id']||0) !== squad_id) { return; }
        var curmax = army_unit_hp(obj);
        cur_hp += curmax[0];
        max_hp += curmax[1];
    });
    return (max_hp > 0 && cur_hp <= 0);
};
player.squad_is_empty = function(squad_id) {
    for(var obj_id in player.my_army) {
        if((player.my_army[obj_id]['squad_id']||0) == squad_id) { return false; }
    }
    return true;
};
player.squad_is_raid = function(squad_id) {
    var squad_data = player.squads[squad_id.toString()];
    return ('raid' in squad_data && squad_data['raid']);
};

/** @constructor @struct */
var SquadCapabilities = function() {
    this.can_raid_offense = false;
    this.can_raid_defense = false;
    this.can_raid_scout = false;
    this.can_raid_pickup = false;
    /** @type {string|null} */
    this.icon_asset = null;
    /** @type {!Object<string,number>} */
    this.max_cargo = {};
    /** @type {!Object<string,number>} */
    this.total_raid_offense = {};
    /** @type {!Object<string,number>} */
    this.total_raid_defense = {};
    /** @type {!Object<string,number>} */
    this.total_raid_hp = {};
    /** @type {!Object<string,number>} */
    this.total_raid_space = {};

    /** @type {!Object<string,number>} */
    this.scout_raid_offense = {};
    /** @type {!Object<string,number>} */
    this.scout_raid_defense = {};
    /** @type {!Object<string,number>} */
    this.scout_raid_hp = {};
    /** @type {!Object<string,number>} */
    this.scout_raid_space = {};
};

/** Check if a map feature is always defenseless, i.e. subject to raid pickup
    @param {!Object<string,?>} feature
    @return {boolean} */
SquadCapabilities.feature_is_defenseless = function(feature) {
    if('base_template' in feature && feature['base_template'] in gamedata['raids_client']['templates']) {
        var template = gamedata['raids_client']['templates'][feature['base_template']];
        if(!template['has_units'] && !template['has_buildings']) {
            return true;
        }
    }
    return false;
};

/** @param {!Object<string,?>} feature
    @return {boolean} */
SquadCapabilities.prototype.can_pickup_feature = function(feature) {
    // "pickup" is allowed when the original template lists no defending units or buildings
    return !!(this.can_raid_pickup && SquadCapabilities.feature_is_defenseless(feature) &&
              (session.region.feature_stance(feature) & Region.Stance.HOSTILE));
};
/** @param {!Object<string,?>} feature
    @return {boolean} */
SquadCapabilities.prototype.can_attack_feature = function(feature) {
    return !!(this.can_raid_offense && !SquadCapabilities.feature_is_defenseless(feature) &&
              (session.region.feature_stance(feature) & Region.Stance.HOSTILE));
};
/** @param {!Object<string,?>} feature
    @return {boolean} */
SquadCapabilities.prototype.can_guard_feature = function(feature) {
    return player.alliance_raids_enabled() &&
        !!(this.can_raid_defense && (session.region.feature_stance(feature) & Region.Stance.ALLIANCEMATE));
};
/** @param {!Object<string,?>} feature
    @return {boolean} */
SquadCapabilities.prototype.can_scout_feature = function(feature) {
    return !!(this.can_raid_scout && !SquadCapabilities.feature_is_defenseless(feature) &&
              (session.region.feature_stance(feature) & Region.Stance.HOSTILE));
};
/** @param {!Object<string,?>} feature
    @return {boolean} */
SquadCapabilities.prototype.can_defend_feature = function(feature) { return false; } // not implemented
/** @param {!Object<string,?>} feature
    @return {boolean} */
SquadCapabilities.prototype.can_raid_feature = function(feature) {
    return (this.can_attack_feature(feature) ||
            this.can_scout_feature(feature) ||
            this.can_defend_feature(feature) ||
            this.can_guard_feature(feature) ||
            this.can_pickup_feature(feature));
};

/** For each mobile squad, return what types of raids it can do.
    Returns mapping of string(id) -> capabilities
    @return {!Object<string, !SquadCapabilities>} */
player.get_mobile_squad_capabilities = function() {
    var ret = {};
    for(var id in player.my_army) {
        var obj = player.my_army[id];
        var squad_id = obj['squad_id'] || 0;
        if(!SQUAD_IDS.is_mobile_squad_id(squad_id)) { continue; }
        var key = squad_id.toString();
        if(!(key in ret)) {
            ret[key] = new SquadCapabilities();
        }
        var entry = ret[key];
        var spec = gamedata['units'][obj['spec']];
        var obj_level = obj['level'] || 1;
        var cur_max_hp = army_unit_hp(obj);
        var hp_ratio = cur_max_hp[0] / cur_max_hp[1];

        // check scout ability
        var is_scout = ('defense_types' in spec && goog.array.contains(spec['defense_types'], 'scout'));
        if(is_scout) {
            entry.can_raid_scout = true;
        }

        entry.icon_asset = get_leveled_quantity(spec['art_asset'], obj_level);

        if('raid_offense' in spec || 'raid_defense' in spec) {
            goog.array.forEach(spec['defense_types'], function(key) {
                entry.total_raid_hp[key] = (entry.total_raid_hp[key] || 0) + cur_max_hp[0];
                if(is_scout) {
                    entry.scout_raid_hp[key] = (entry.scout_raid_hp[key] || 0) + cur_max_hp[0];
                }
                if('consumes_space' in spec) {
                    var spc = hp_ratio * get_leveled_quantity(spec['consumes_space'], obj_level);
                    entry.total_raid_space[key] = (entry.total_raid_space[key] || 0) + spc;
                    if(is_scout) {
                        entry.scout_raid_space[key] = (entry.scout_raid_space[key] || 0) + spc;
                    }
                }
            });
        }

        // check offense/defense stats
        goog.array.forEach([['raid_offense', entry.total_raid_offense, entry.scout_raid_offense],
                            ['raid_defense', entry.total_raid_defense, entry.scout_raid_defense]],
                           function(x) {
                               var spec_key = x[0], total = x[1], scout = x[2];
                               if(spec_key in spec) {
                                   var val_dict = get_leveled_quantity(spec[spec_key], obj_level);
                                   for(var k in val_dict) {
                                       var val = get_leveled_quantity(val_dict[k], obj_level);
                                       val *= hp_ratio; // ??
                                       if(val > 0) {
                                           total[k] = (total[k] || 0) + val;
                                           if(is_scout) {
                                               scout[k] = (scout[k] || 0) + val;
                                           }
                                           if(spec_key === 'raid_offense') {
                                               entry.can_raid_offense = true;
                                           } else if(spec_key === 'raid_defense') {
                                               entry.can_raid_defense = true;
                                           }
                                       }
                                   }
                               }
                           });
        // check cargo space
        if(cur_max_hp[0] > 0) {
            for(var res in gamedata['resources']) {
                if('cargo_'+res in spec) {
                    var val = get_leveled_quantity(spec['cargo_'+res], obj_level);
                    if(val) {
                        entry.max_cargo[res] = (entry.max_cargo[res] || 0) + val;
                        entry.can_raid_pickup = true;
                    }
                }
            }
        }
    }
    return ret;
};

player.squad_set_client_data = function(squad_id, k, v) {
    var key = squad_id.toString();
    if(!(key in player.squad_client_data)) { player.squad_client_data[key] = {}; }
    player.squad_client_data[key][k] = v;
};
player.squad_get_client_data = function(squad_id, k) {
    var key = squad_id.toString();
    if(!(key in player.squad_client_data)) { return null; }
    return player.squad_client_data[key][k];
};
player.squad_clear_client_data = function(squad_id) {
    var key = squad_id.toString();
    if(!(key in player.squad_client_data)) { return; }
    delete player.squad_client_data[key];
};

// squad travel time conventions:
// "travel_speed" of the squad is the maxvel of the slowest unit within it.
// this is MULTIPLIED by territory's travel_speed_factor and any stattab bonus to get the final speed.

/** @param {number} squad_id
    @return {number} */
player.squad_travel_speed = function(squad_id) {
    // undeployed squads will not have a travel_speed property
    var squad_data = player.squads[squad_id.toString()];
    if('travel_speed' in squad_data) {
        return squad_data['travel_speed'];
    }
    var travel_speed = -1;
    goog.object.forEach(player.my_army, function(obj, obj_id) {
        var obj_squad_id = obj['squad_id'] || 0;
        if(obj_squad_id === squad_id) {
            var speed = get_leveled_quantity(gamedata['units'][obj['spec']]['maxvel']||0, obj['level']||1);
            if(travel_speed < 0) {
                travel_speed = speed;
            } else {
                travel_speed = Math.min(travel_speed, speed);
            }
        }
    });
    return travel_speed;
};

/** @param {number} squad_id
    @param {string|null=} raid_mode - overrides what the squad currently is
    @return {number} */
player.squad_travel_time_per_hex = function(squad_id, raid_mode) {
    var squad_data = player.squads[squad_id.toString()];
    var travel_speed = player.squad_travel_speed(squad_id);
    var speed_factor_key = (squad_data['raid'] || raid_mode) ? 'raid_travel_speed_factor' : 'unit_travel_speed_factor';
    var speed_factor = player.get_territory_setting(speed_factor_key);
    return (1.0/(speed_factor*get_player_stat(player.stattab,'travel_speed')*travel_speed));
};
/** @param {number} squad_id
    @param {!Array<!Array<number>>} path
    @param {string|null=} raid_mode - overrides what the squad currently is
    @return {number} */
player.squad_travel_time = function(squad_id, path, raid_mode) {
    return path.length * player.squad_travel_time_per_hex(squad_id, raid_mode);
};

/** Return a path that ends on this feature.
    Avoids other features that block the map OTHER than the passed "feature".
    Returns null if no path exists.
    @param {!Array<number>} start_loc
    @param {!Object<string,?>} dest_feature
    @return {Array<Array<number>>|null} */
player.raid_find_path_to = function(start_loc, dest_feature) {
    if(!session.region || !session.region.data) { return null; }

    /** @type AStar.PathChecker */
    var raid_path_checker = function(cell, path) {
        if(cell.block_count > 0) {
            for(var i = 0; i < cell.blockers.length; i++) {
                var feature = cell.blockers[i];
                if(feature !== dest_feature && feature['base_type'] !== 'squad') {
                    return AStar.NOPASS;
                }
            }
        }
        return AStar.PASS;
    };
    if(hex_distance(start_loc, dest_feature['base_map_loc']) === 0) {
        return []; // already there
    }
    var path = session.region.hstar_context.search(start_loc, dest_feature['base_map_loc'], raid_path_checker);
    if(path && path.length >= 1 && hex_distance(path[path.length-1], dest_feature['base_map_loc']) == 0) {
        return path; // good path
    }
    return null;
};

/** NOT TO BE USED FOR RAIDS
    @param {number} squad_id
    @param {!Array<number>} dest
    @param {{bump_self:(boolean|undefined)}=} options
    @return {AStar.PathChecker|null} */
player.make_squad_path_checker = function(squad_id, dest, options) {
    // only applies to after_move mode; otherwise any blocker blocks.
    if(player.squad_block_mode() !== 'after_move') { return null; }
    var bumping_enabled = player.squad_bumping_enabled();

    return function(cell, path) {
        if(cell.block_count > 0) {
            for(var i = 0; i < cell.blockers.length; i++) {
                var feature = cell.blockers[i];
                if(((options && options.bump_self) || feature['base_landlord_id'] !== session.user_id) &&
                   session.region.feature_is_moving(feature)) {
                    var last_waypoint = feature['base_map_path'][feature['base_map_path'].length-1];
                    var their_arrival_time = last_waypoint['eta'];
                    var fudge_time = gamedata['territory']['pass_moving_squads_fudge_time'] || 0; // give some conservative leeway for network latency, otherwise players could get frustrated

                    if(!vec_equals(last_waypoint['xy'], cell.pos)) {
                        throw Error('last_waypoint '+JSON.stringify(last_waypoint)+' of feature '+JSON.stringify(feature)+' does not match cell.pos '+JSON.stringify(cell.pos));
                    }

                    if((bumping_enabled || !vec_equals(dest, cell.pos)) && // this exception does not apply to our final destination cell, unless bumping is enabled
                       their_arrival_time > server_time + player.squad_travel_time(squad_id, path) + fudge_time) {
                        continue; // not necessarily blocked! (there might be another feature here though)
                    }
                }
                return AStar.NOPASS; // blocked by this feature
            }
        }
        return AStar.PASS; // not blocked
    };
};
/** NOT TO BE USED FOR RAIDS
    @param {number=} at_time
    @param {{bump_self:(boolean|undefined)}=} options
    @param {Array<number>|undefined|null=} ignore_pos
    @return {AStar.BlockChecker|null} */
player.make_squad_cell_checker = function(at_time, options, ignore_pos) {
    if(!player.squad_bumping_enabled()) { return null; } // any blocker blocks
    if(!at_time) { at_time = server_time; }

    return function(cell) {
        if(ignore_pos && vec_equals(ignore_pos, cell.pos)) { return AStar.PASS; } // ignore blockage here
        if(cell.block_count > 0) {
            for(var i = 0; i < cell.blockers.length; i++) {
                var feature = cell.blockers[i];
                if(((options && options.bump_self) || feature['base_landlord_id'] !== session.user_id) &&
                   session.region.feature_is_moving(feature)) {
                    var last_waypoint = feature['base_map_path'][feature['base_map_path'].length-1];
                    var their_arrival_time = last_waypoint['eta'];
                    var fudge_time = gamedata['territory']['pass_moving_squads_fudge_time'] || 0; // give some conservative leeway for network latency, otherwise players could get frustrated

                    if(!vec_equals(last_waypoint['xy'], cell.pos)) {
                        throw Error('last_waypoint '+JSON.stringify(last_waypoint)+' of feature '+JSON.stringify(feature)+' does not match cell.pos '+JSON.stringify(cell.pos));
                    }

                    if(their_arrival_time > at_time + fudge_time) {
                        continue; // not necessarily blocked! (there might be another feature here though)
                    }
                }
                return AStar.NOPASS; // blocked by this feature
            }
        }
        return AStar.PASS; // not blocked
    };
};

/** Return a path that ends on hex "dest", or if "dest" is blocked, an open hex immediately adjacent to it
    Returns null if no path exists.
    @param {number} squad_id
    @param {!Array<number>} dest
    @param {{bump_self:(boolean|undefined)}=} options
    @return {Array<Array<number>>|null} */
player.squad_find_path_adjacent_to = function(squad_id, dest, options) {
    if(!session.region || !session.region.data) { return null; }
    if(player.squad_is_moving(squad_id)) { throw Error('squad '+squad_id.toString()+' is still moving'); }
    if(player.squad_is_raid(squad_id)) { throw Error('squad_find_path_adjacent_to() should not be used for raids'); }
    var squad_data = player.squads[squad_id.toString()];

    if(!squad_data['map_loc']) { throw Error('squad '+squad_id.toString()+' is not deployed'); }
    if(!dest) { throw Error('squad '+squad_id.toString()+' given null/undefined destination'); }

    // note! A* code tends to blow up memory/CPU if you ask it to go into a blocked destination

    // When squad_block_mode is 'after_move', allow travel through hexes that are reserved as the destination
    // of another squad before its arrival time. This requires a path-dependent blockage check, since the
    // arrival time to check against depends on how long it takes us to get there.

    // earliest possible arrival time - used to check for dynamic blockage at destination that can't be avoided by any A* path
    var earliest_arrival_at = function(d) {
        return server_time + player.squad_travel_time_per_hex(squad_id) * hex_distance(squad_data['map_loc'], d);
    };

    // calculate map connectivity - ignore blockage at the squad's starting location and ignore ALL moving squads
    // (this means connectivity will show regions as connected if they will later be separated by a moving squad
    // reaching its destination. That's OK because the actual A* search will find the location blocked. We just want
    // an early-out heuristic that will avoid fruitless A* searches).
    var connectivity_key = squad_data['map_loc'][0].toString()+','+squad_data['map_loc'][1].toString();
    var connectivity = session.region.ensure_connectivity(player.make_squad_cell_checker(-Infinity, // note: test against infinite past time to treat moving squads as transparent
                                                                                         {bump_self:true}, // always assume bump_self, since we're ignoring ALL moving squads for connectivity purposes
                                                                                         squad_data['map_loc']),
                                                          connectivity_key);

    // query speed benchmark
    var slow_threshold = (player.is_developer() ? 0.1 : 999);
    var start_time = (new Date()).getTime()/1000;

    // if dest is not blocked, try going directly there
    if(!session.region.occupancy.is_blocked(dest, player.make_squad_cell_checker(earliest_arrival_at(dest), options)) &&
       (!connectivity || (connectivity.region_num(dest) === connectivity.region_num(squad_data['map_loc'])))) {
        var path = session.region.hstar_context.search(squad_data['map_loc'], dest, player.make_squad_path_checker(squad_id, dest, options));
        if(path && path.length >= 1 && hex_distance(path[path.length-1], dest) == 0) {
            var end_time = (new Date()).getTime()/1000;
            if(end_time - start_time >= slow_threshold) {
                console.log('squad_find_path_adjacent_to slow: returned DEST path after '+(1000*(end_time - start_time)).toFixed(2)+' ms');
            }
            return path; // good path
        }
    }

    var end_time = (new Date()).getTime()/1000;
    if(end_time - start_time >= slow_threshold) {
        console.log('squad_find_path_adjacent_to slow: gave up on DEST after '+(1000*(end_time - start_time)).toFixed(2)+' ms');
    }
    start_time = end_time;

    // try aiming for neighbor squares around "dest"
    var neighbors = session.region.get_neighbors(dest);
    var best_path = null;
    var best_travel_time = -1;

    for(var i = 0; i < neighbors.length; i++) {
        var n = neighbors[i];
        if(!session.region.occupancy.is_blocked(n, player.make_squad_cell_checker(earliest_arrival_at(n), options)) &&
           (!connectivity || (connectivity.region_num(n) === connectivity.region_num(squad_data['map_loc'])))) {
            var path = session.region.hstar_context.search(squad_data['map_loc'], n, player.make_squad_path_checker(squad_id, n, options));
            // path must lead INTO n
            if(path && path.length >= 1 && hex_distance(path[path.length-1], n) == 0) {
                // good path
                // trim off unnecessary extra moves at the end of the path that just circle around the destination hex
                // note: need to check for blockage on this intermediate waypoint before changing the final destination to it,
                // because it might be the destination of another moving squad, where we aren't allowed to land.
                while(path.length >= 2 && hex_distance(path[path.length-2], dest) == 1 &&
                      !session.region.occupancy.is_blocked(path[path.length-2], player.make_squad_cell_checker(earliest_arrival_at(path[path.length-2]), options))) {
                    goog.array.removeAt(path, path.length-1);
                }
                var travel_time = player.squad_travel_time(squad_id, path);
                if(best_path === null || travel_time  < best_travel_time) {
                    best_path = path;
                    best_travel_time = travel_time;
                }
                //return path;
            }
        }
    }

    end_time = (new Date()).getTime()/1000;
    if(end_time - start_time >= slow_threshold) {
        console.log('squad_find_path_adjacent_to slow: returned NEIGHBOR path after '+(1000*(end_time - start_time)).toFixed(2)+' ms');
    }
    return best_path;
};


/** @param {number} squad_id
    @param {boolean=} assume_moving - if true, fudge time comparison in favor of "still moving" */
player.squad_is_moving = function(squad_id, assume_moving) {
    var squad_data = player.squads[squad_id.toString()];
    var fudge_time = (assume_moving ? -1 : 0) * 0.25; // should be similar to server's map_path_fudge_time
    return (('map_loc' in squad_data) &&
            (('map_path' in squad_data) && (squad_data['map_path'][squad_data['map_path'].length-1]['eta'] > server_time + fudge_time)));
};

player.squad_interpolate_pos_and_heading = function(squad_id) {
    var squad_data = player.squads[squad_id.toString()];
    if(player.squad_is_moving(squad_id)) {
        var path = squad_data['map_path'];
        var last_waypoint = path[0];
        for(var i = 1; i < path.length; i++) {
            var waypoint = path[i];
            if(waypoint['eta'] > server_time) {
                var delta = vec_sub(waypoint['xy'], last_waypoint['xy']);
                return [vec_add(last_waypoint['xy'], vec_scale((server_time-last_waypoint['eta'])/(waypoint['eta']-last_waypoint['eta']),delta)),
                        Math.atan2(delta[1], delta[0])];
            }
            last_waypoint = waypoint;
        }
    } else {
        return [squad_data['map_loc'], 0];
    }
};

// it is optional to provide the path home

/** @param {number} squad_id
    @param {Array.<Array.<number>>|null=} path */
player.squad_recall = function(squad_id, path) {
    // moving non-raids must halt before moving again
    if(!player.squad_is_moving(squad_id)) { // simple case - squad not moving. Just move.
        player.squad_recall_move(squad_id, path);
    } else if(player.squad_is_raid(squad_id)) {
        player.squad_recall_redirect(squad_id); // complex case - raid moving. Redirect.
    } else {
        // complex case - non-raid moving. Halt then move.
        if(!player.squad_get_client_data(squad_id, 'halt_pending')) {
            player.squad_halt(squad_id);
        }
        player.squad_set_client_data(squad_id, 'squad_orders', {'recall_after_halt': 1, 'recall_path': path || null});
    }
};

/** @param {number} squad_id - must be idle
    @param {Array<Array<number>>|null=} path to take back to home base (if null, find a new one)
    @return {boolean} true if we found a path home. False if squad is blocked from returning. */
player._squad_recall_move = function(squad_id, path) {
    var squad_data = player.squads[squad_id.toString()];

    // note: we can't just use home_base_loc here, because we need to path-find to it!
    var home_feature = session.region.find_home_feature();
    if(!home_feature) {
        return false;
    }
    var max_dist = (player.squad_is_raid(squad_id) ? 0 : 1); // raids need to be on top of base to exit
    var cur_dist = hex_distance(squad_data['map_loc'], player.home_base_loc);
    if(cur_dist <= max_dist) {
        // already in position. trigger SQUAD_EXIT_MAP at next opportunity.
        player.squad_set_client_data(squad_id, 'squad_orders', {'recall':1});
        return true;
    } else if(cur_dist == 1) {
        // one step away - for raids
        path = [player.home_base_loc];
    }

    if(!path) {
        if(player.squad_is_raid(squad_id)) {
            path = player.raid_find_path_to(squad_data['map_loc'], home_feature);
        } else {
            path = player.squad_find_path_adjacent_to(squad_id, player.home_base_loc);
        }
    }

    if(path) {
        player.squad_move(squad_id, path);
        // trigger SQUAD_EXIT_MAP at next opportunity after the move
        player.squad_set_client_data(squad_id, 'squad_orders', {'recall':1});
        return true;
    } else {
        // uh oh, no way home!
        return false;
    }
};
/** @param {number} squad_id - must be idle
    @param {Array<Array<number>>|null=} path to take back to home base (if null, find a new one)
    Same as above, but invokes a modal GUI error message when no path is found */
player.squad_recall_move = function(squad_id, path) {
    if(!player._squad_recall_move(squad_id, path)) {
        var s = gamedata['errors']['CANNOT_RECALL_SQUAD_MAP_BLOCKED'];
        invoke_child_message_dialog(s['ui_title'], s['ui_name'], {'dialog':'message_dialog_big'});
    }
};

player.squad_halt = function(squad_id) {
    if(!player.squad_is_moving(squad_id)) { throw Error('squad_halt but squad '+squad_id.toString()+' is not moving'); }
    var squad_data = player.squads[squad_id.toString()];
    squad_data['pending'] = true;
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_STEP", squad_id, null]);
    player.squad_clear_client_data(squad_id); // erase current movement orders
    player.squad_set_client_data(squad_id, 'halt_pending', true); // wait for squad to stop before issuing new orders
};
player.squad_move = function(squad_id, path) {
    if(player.squad_is_moving(squad_id)) { throw Error('squad_move but squad '+squad_id.toString()+' is still moving'); }
    if(!path || path.length < 1) { throw Error('squad_move with invalid path'); }
    var squad_data = player.squads[squad_id.toString()];
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_STEP", squad_id, path]);
    player.squad_clear_client_data(squad_id); // erase current movement orders
    player.squad_set_client_data(squad_id, 'move_pending', squad_data['map_loc']); // wait for squad to move before issuing new orders - remember original loc

    // client-side predict - assumes success, may get corrected by server later
    if(gamedata['client']['predict_squad_movement']) {
        // translate path into xy/eta format for the map feature
        var next_eta = server_time + (-server_time_offset); // add 1x your buest-guess network latency
        next_eta += gamedata['client']['predict_squad_movement_estimated_latency'] || 0; // even more optional latency prediction
        var map_path = [{'xy': squad_data['map_loc'], 'eta': next_eta}];

        var travel_speed = player.squad_travel_speed(squad_id);
        var speed_factor_key = (squad_data['raid'] ? 'raid_travel_speed_factor' : 'unit_travel_speed_factor');
        var speed_factor = player.get_territory_setting(speed_factor_key);

        for(var i = 0; i < path.length; i++) {
            next_eta += 1.0 / (speed_factor*get_player_stat(player.stattab, 'travel_speed')*travel_speed);
            map_path.push({'xy': path[i], 'eta': next_eta});
        }

        session.region.receive_feature_update({'base_id':player.squad_base_id(squad_id),
                                               'base_map_path': map_path,
                                               'base_map_loc': path[path.length-1],
                                               'preserve_locks': 1});
        squad_data['map_loc'] = path[path.length-1];
        squad_data['map_path'] = map_path;
    }
};

/** Special function for recalling a moving raid to base. Since this
    must halt and then step atomically (i.e. redirect a moving squad),
    we have to plot multiple paths to base, depending on exactly where
    the server stopped it.
    @param {number} squad_id - must be a MOVING raid
    @return {boolean} true if we found a path home. False if squad is blocked from returning. */
player.squad_recall_redirect = function(squad_id) {
    var squad_data = player.squads[squad_id.toString()];

    // note: we can't just use home_base_loc here, because we need to path-find to it!
    var home_feature = session.region.find_home_feature();
    if(!home_feature) {
        return false;
    }

    // compute a return-to-home path from every hex at which the raid might stop
    var paths = {};
    goog.array.forEach(squad_data['map_path'], function(waypoint) {
        // ignore waypoints way out of the time window
        if(waypoint['eta'] < server_time - 5 ||waypoint['eta'] > server_time + 10) { return; }
        var path = player.raid_find_path_to(waypoint['xy'], home_feature);
        if(path !== null) { // might be empty list if squad is at home_feature
            var key = waypoint['xy'][0].toFixed(0)+','+waypoint['xy'][1].toFixed(0);
            paths[key] = path;
        }
    });

    if(goog.object.isEmpty(paths)) {
        // uh oh, no way home!
        var s = gamedata['errors']['CANNOT_RECALL_SQUAD_MAP_BLOCKED'];
        invoke_child_message_dialog(s['ui_title'], s['ui_name'], {'dialog':'message_dialog_big'});
        return false;
    }

    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_STEP_MULTIPLE_CHOICE", squad_id, paths]);
    player.squad_clear_client_data(squad_id); // erase current movement orders
    player.squad_set_client_data(squad_id, 'move_pending', squad_data['map_loc']); // wait for squad to move before issuing new orders - remember original loc
    // trigger SQUAD_EXIT_MAP at next opportunity after the move
    player.squad_set_client_data(squad_id, 'squad_orders', {'recall':1});

    // note: don't attempt to client-side predict this
    squad_data['pending'] = true;

    return true;
};

player.advance_squads = function() {
    goog.object.forEach(player.squads, function(squad_data) {
        // don't touch squads that are involved in the current battle
        if(session.has_attacked && goog.array.contains(session.deployable_squads, squad_data['id'])) { return; }

        // when a "Halt" is issued, the server will respond with SQUADS_UPDATE with a new path, but the
        // squad will still need to move to the nearest cell before it really halts. We have to track
        // this state transition in order to gray out "Halt" buttons until the squad really stops
        if(player.squad_get_client_data(squad_data['id'], 'halt_pending') && !player.squad_is_moving(squad_data['id'])) {
            player.squad_set_client_data(squad_data['id'], 'halt_pending', false);
        }

        // reset "move_pending" flag if squad is actually moving, or if we found it somewhere other than where it was when we started the move
        if(player.squad_get_client_data(squad_data['id'], 'move_pending') &&
           (!player.squad_is_deployed(squad_data['id']) ||
            player.squad_is_moving(squad_data['id']) ||
            !vec_equals(squad_data['map_loc'], player.squad_get_client_data(squad_data['id'], 'move_pending')))) {
            player.squad_set_client_data(squad_data['id'], 'move_pending', false);
        }

        // don't touch squads that are on cooldown
        if(player.cooldown_active('squad_order:'+squad_data['id'].toString())) {
            return;
        }

        // don't try to drive squads around outside home base (only because the server doesn't take the commands)
        if(!gamedata['territory']['enable_squad_control_away_from_home'] && !session.home_base) { return; }

        var orders = player.squad_get_client_data(squad_data['id'], 'squad_orders');
        var max_dist_to_exit_map = (player.squad_is_raid(squad_data['id']) ? 0 : 1); // raids need to be on top of base to exit

        if(orders && 'recall_after_halt' in orders) {
            if(!player.squad_is_moving(squad_data['id'], true)) {
                player.squad_set_client_data(squad_data['id'], 'squad_orders', null);
                player.squad_recall_move(squad_data['id'], orders['recall_path']);
            }
        } else if(orders && 'recall' in orders) {
            if(player.squad_is_moving(squad_data['id'], true)) {
                // wait til it stops (assumes recall is preceded by a halt)
            } else if(!player.squad_is_deployed(squad_data['id'])) {
                // already made it home
                player.squad_clear_client_data(squad_data['id']);
            } else {
                // not moving
                if(hex_distance(squad_data['map_loc'], player.home_base_loc) <= max_dist_to_exit_map && !squad_data['pending']) {
                    squad_data['pending'] = true;
                    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_EXIT_MAP", squad_data['id']]);
                    player.squad_clear_client_data(squad_data['id']);
                }
            }
        } else if(orders && 'move' in orders) {
            var dest = orders['move'];
            if(player.squad_is_deployed(squad_data['id']) && !player.squad_is_moving(squad_data['id'])) {
                // when a squad has movement queued towards an unblocked hex on the map, move it into the hex itself,
                // not just and adjacent hex.
                var desired_distance = (session.region.occupancy.is_blocked(dest, player.make_squad_cell_checker()) ? 1 : 0);
                if(hex_distance(squad_data['map_loc'], dest) <= desired_distance) {
                    // already there
                } else {
                    var path = player.squad_find_path_adjacent_to(squad_data['id'], dest);
                    if(path && path.length >= 1 && hex_distance(path[path.length-1], dest) <= desired_distance) {
                        player.squad_move(squad_data['id'], path);
                    } else {
                        var s = gamedata['errors']['INVALID_MAP_LOCATION'];
                        invoke_squad_error(s['ui_title'], s['ui_name'].replace('%BATNAME', squad_data['ui_name']));
                    }
                }
                player.squad_clear_client_data(squad_data['id']);
            }
        } else if(squad_data['raid'] &&
                  player.squad_is_deployed(squad_data['id']) &&
                  !player.squad_is_moving(squad_data['id'], true)) {
            // stationary raid - need to resolve, recall, or dock at base
            if(hex_distance(squad_data['map_loc'], player.home_base_loc) <= max_dist_to_exit_map && !squad_data['pending']) {
                squad_data['pending'] = true;
                send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_EXIT_MAP", squad_data['id']]);
                player.squad_clear_client_data(squad_data['id']);
            } else if(!session.region.dirty) {
                var features = session.region.find_features_at_coords(squad_data['map_loc']);
                var need_resolve = false;
                var need_recall = true;
                goog.array.forEach(features, function(feature) {
                    if(feature['base_id'] === player.squad_base_id(squad_data['id'])) { return; } // self
                    var stance = session.region.feature_stance(feature);
                    if(player.alliance_raids_enabled() &&
                       feature['base_type'] == 'home' && (stance & (Region.Stance.ALLIANCEMATE | Region.Stance.UNKNOWN))) {
                        need_recall = false; // leave it there to guard
                    } else if((feature['base_type'] == 'raid' || feature['base_type'] == 'home') &&
                              (stance & Region.Stance.HOSTILE)) {
                        need_resolve = true;
                        need_recall = false;
                    }
                });

                if(need_resolve && !squad_data['pending']) {
                    squad_data['pending'] = true;
                    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_RESOLVE", squad_data['map_loc']]);
                } else if(need_recall && !squad_data['pending']) {
                    console.log('Auto-recalling idle raid squad '+squad_data['id'].toString());
                    // use underscore variant to avoid GUI error spam
                    if(player._squad_recall_move(squad_data['id'])) {
                        // XXX this is not symmetrical with maptool's resolution. Maybe unify into Raid.py?
                        invoke_squad_error(gamedata['strings']['squad_turnaround_mail']['ui_subject'].replace('%s',squad_data['ui_name'] || '?'),
                                           gamedata['strings']['squad_turnaround_mail']['ui_body'].replace('%s',squad_data['ui_name'] || '?'));
                    }
                }
            }
        }
    });
};

// put up the GUI confirmation, if necessary
function squad_delete_confirm(squad_id, finisher_cb) {
    var usage = player.get_army_space_usage_by_squad();
    if(!usage[squad_id.toString()]) {
        // no confirm for empty squads
        finisher_cb();
    } else {
        var s = gamedata['strings']['squad_delete_confirm'];
        invoke_child_message_dialog(s['ui_title'],
                                    s['ui_description'],
                                    {'cancel_button': true,
                                     'ok_button_ui_name': s['ui_button'],
                                     'on_ok': finisher_cb});
    }
};

var unit_repair_sync_marker = Synchronizer.INIT;
function invoke_repair_control() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['repair_control']);
    dialog.user_data['dialog'] = 'repair_control';
    dialog.user_data['page'] = -1;
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };
    init_army_dialog_buttons(dialog.widgets['army_dialog_buttons_army'], 'army', 'repair_control');

    // this dialog has two "modes": squads and non-squads. Show/hide certain widgets as appropriate:
    dialog.widgets['squad_radio_label'].show =
        dialog.widgets['squad_radio_base_defenders'].show =
        dialog.widgets['squad_radio_reserves'].show =
        dialog.widgets['squad_label1'].show =
        dialog.widgets['squad_label2'].show = player.squads_enabled();
    dialog.widgets['add_all_button'].show =
        dialog.widgets['requirements_water_icon'].show =
        dialog.widgets['requirements_water_value'].show =
        dialog.widgets['requirements_iron_icon'].show =
        dialog.widgets['requirements_iron_value'].show =
        dialog.widgets['requirements_time_icon'].show =
        dialog.widgets['requirements_time_value'].show =
        dialog.widgets['in_production_bg'].show =
        dialog.widgets['in_production_icon'].show =
        dialog.widgets['in_production_time'].show =
        dialog.widgets['in_production_wrench'].show =
        dialog.widgets['in_production_cancel'].show =
        dialog.widgets['in_production_health'].show =
        dialog.widgets['price_display'].show =
        dialog.widgets['price_spinner'].show =
        dialog.widgets['finish_button'].show = !dialog.widgets['squad_radio_label'].show;

    for(var i = 0; i < dialog.data['widgets']['queue']['array'][0]; i++) {
        dialog.widgets['queue'+i.toString()].show =
            dialog.widgets['queue_bg'+i.toString()].show =
            dialog.widgets['queue_counter_bg'+i.toString()].show =
            dialog.widgets['queue_counter'+i.toString()].show =
            dialog.widgets['queue_cancel'+i.toString()].show = !dialog.widgets['squad_radio_label'].show;
    }

    // whether we are looking at base defenders or reserves
    dialog.user_data['squad_id'] = (player.squads_enabled() ? get_preference_setting(player.preferences, 'repair_control_squad_id') : SQUAD_IDS.BASE_DEFENDERS);
    var set_squad = function(_id) { return function(w) {
        if(w.parent.user_data['squad_id'] != _id) {
            w.parent.user_data['squad_id'] = _id;
            player.preferences['repair_control_squad_id'] = _id;
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
        }
    }; };
    dialog.widgets['squad_radio_base_defenders'].onclick = set_squad(SQUAD_IDS.BASE_DEFENDERS);
    dialog.widgets['squad_radio_reserves'].onclick = set_squad(SQUAD_IDS.RESERVES);

    dialog.ondraw = update_repair_control;

    // mostly so self-destruction shows up
    flush_dirty_objects({});

    repair_control_change_page(0);
    return dialog;
}
function repair_control_change_page(pagenum) {
    var dialog = selection.ui;
    if(dialog.user_data['dialog'] != 'repair_control') { return; }
    dialog.user_data['page'] = pagenum;
}

// replace our unit_repair_queue with the one the server provides,
// and update under_repair flags

// throttle unit repair ping requests
var unit_repair_ping_sent = false;
var last_unit_repair_ping = 0;

function request_unit_repair_update() {
    if(unit_repair_ping_sent) { return; } // only one outstanding request
    if(client_time - last_unit_repair_ping < gamedata['client']['unit_repair_ping_interval']) { return; }
    unit_repair_ping_sent = true;
    last_unit_repair_ping = client_time;
    send_to_server.func(["UNIT_REPAIR_TICK"]);
}

function receive_unit_repair_update(data) {
    player.unit_repair_queue = data;
    // confirm receipt of response from the repair_control dialog
    unit_repair_ping_sent = false;
    apply_unit_repair_update();
}

// propagate finish times on to individual objects
function apply_unit_repair_update() {
    session.for_each_real_object(function(obj) {
        obj.under_repair_finish = -1;
    });
    for(var i = 0; i < player.unit_repair_queue.length; i++) {
        var item = player.unit_repair_queue[i];
        // can be race conditions here with server, so check to be careful
        var obj = session.get_real_world().objects._get_object(item['obj_id']);
        if(obj) {
            obj.under_repair_finish = item['finish_time'];
        }
    }
}

/** Client-side predict removal of one unit from repair queue
    (see Player.unit_repair_cancel() on server)
    @param {!GameObjectId} obj_id */
player.army_unit_cancel_repair = function(obj_id) {
    for(var i = 0; i < player.unit_repair_queue.length; i++) {
        var item = player.unit_repair_queue[i];
        if(item['obj_id'] === obj_id) {
            var time_remaining = (i === 0 ? item['finish_time'] - server_time :
                                  item['finish_time'] - player.unit_repair_queue[i-1]['finish_time']);
            // adjust timers on objects that remain in the repair queue
            for(var j = i+1; j < player.unit_repair_queue.length; j++) {
                player.unit_repair_queue[j]['finish_time'] -= time_remaining;
                player.unit_repair_queue[j]['start_time'] -= time_remaining;
            }
            player.unit_repair_queue.splice(i,1);
            apply_unit_repair_update();
            unit_repair_sync_marker = synchronizer.request_sync();
            break;
        }
    }
};
/** Client-side predict one unit disappearing from the army permanently
    @param {!GameObjectId} obj_id */
player.army_unit_drop = function(obj_id) {
    if(obj_id in player.my_army) {
        player.army_unit_cancel_repair(obj_id);
        delete player.my_army[obj_id];
        session.get_real_world().lazy_update_citizens();
    }
};

/** @param {!GameObjectId} obj_id
    @return {boolean} */
function army_unit_is_under_repair(obj_id) {
    for(var i = 0; i < player.unit_repair_queue.length; i++) {
        var item = player.unit_repair_queue[i];
        if(item['obj_id'] == obj_id) {
            return true;
        }
    }
    return false;
};

/** @param {SPUI.Dialog} dialog */
function update_repair_control(dialog) {

    dialog.widgets['squad_radio_base_defenders'].state = (dialog.user_data['squad_id'] == SQUAD_IDS.BASE_DEFENDERS ? 'active' : 'normal');
    dialog.widgets['squad_radio_reserves'].state = (dialog.user_data['squad_id'] == SQUAD_IDS.RESERVES ? 'active' : 'normal');

    // fill in the bottom of the dialog first, since we need the HP
    // estimate for the currently-under-repair unit for the grid above

    var total_res = {}, cur_repair_est_progress = 0, any_need_repair = false;

    // fill in current repair item
    dialog.widgets['in_production_icon'].show =
        dialog.widgets['in_production_time'].show =
        dialog.widgets['in_production_wrench'].show =
        dialog.widgets['in_production_health'].show = !player.squads_enabled() && (player.unit_repair_queue.length > 0 && (session.get_real_world().objects.has_object(player.unit_repair_queue[0]['obj_id']) || player.unit_repair_queue[0]['obj_id'] in player.my_army));
    dialog.widgets['in_production_cancel'].show = (dialog.widgets['in_production_icon'].show && gamedata['unit_repair_can_cancel'] && !player.squads_enabled());

    if(dialog.widgets['in_production_icon'].show) {
        var item = player.unit_repair_queue[0];
        var orig_hp = item['original_hp'];
        var cur_hp = null, max_hp = null;
        var obj_spec, obj_level;
        if(session.get_real_world().objects.has_object(item['obj_id'])) {
            var obj = session.get_real_world().objects.get_object(item['obj_id']);
            obj_spec = obj.spec;
            if(!obj_spec) { throw Error('bad obj.spec in cur_objects for '+item['obj_id']); }
            obj_level = obj.level;
            dialog.widgets['in_production_time'].str = pretty_print_time(item['finish_time'] - server_time);
            dialog.widgets['in_production_cancel'].onclick = (function (id) { return function() {
                send_to_server.func(["UNIT_REPAIR_CANCEL", id]);
                unit_repair_sync_marker = synchronizer.request_sync();
            }; })(item['obj_id']);
            cur_hp = obj.hp; max_hp = obj.max_hp;
        } else if(item['obj_id'] in player.my_army) {
            var obj = player.my_army[item['obj_id']];
            obj_spec = gamedata['units'][obj['spec']];
            if(!obj_spec) { throw Error('bad obj.spec in my_army for '+item['obj_id']); }
            obj_level = obj['level']||1;
            var cur_max_hp = army_unit_hp(obj); cur_hp = cur_max_hp[0]; max_hp = cur_max_hp[1];
        }

        dialog.widgets['in_production_icon'].bg_image = get_leveled_quantity(obj_spec['art_asset'], obj_level);
        dialog.widgets['in_production_icon'].alpha = (obj_spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1);

        // estimate current HP value
        var progress = 1.0 - (item['finish_time'] - server_time)/(item['finish_time']-item['start_time']);

        // try pinging for (start or) completion
        if(progress >= 1 || (cur_hp !== null && cur_hp === 0)) {
            request_unit_repair_update();
        }

        if(max_hp !== null) {
            progress = (orig_hp + progress*(max_hp-orig_hp))/max_hp;
            cur_repair_est_progress = progress;

            progress = Math.min(Math.max(progress, 0), 1);
            dialog.widgets['in_production_health'].progress = progress;
            for(var res in gamedata['resources']) {
                if(res in item) {
                    total_res[res] = (total_res[res]||0) + item[res];
                }
            }
        }
    }

    // fill in backed-up part of the queue
    var NBOXES = 8;
    var counters = [];
    for(var box = 0; box < NBOXES; box++) {
        dialog.widgets['queue'+box.toString()].show = false;
        dialog.widgets['queue_counter_bg'+box.toString()].show = false;
        dialog.widgets['queue_counter'+box.toString()].show = false;
        dialog.widgets['queue_cancel'+box.toString()].show = false;
        counters.push(0);
    }
    var box = -1;
    var kind = null;
    for(var i = 1; i < player.unit_repair_queue.length; i++) {
        var item = player.unit_repair_queue[i];
        var obj_spec, obj_level;

        if(session.get_real_world().objects.has_object(item['obj_id'])) {
            var obj = session.get_real_world().objects.get_object(item['obj_id']);
            obj_spec = obj.spec; obj_level = obj.level;
        } else if(item['obj_id'] in player.my_army) {
            var unit = player.my_army[item['obj_id']];
            obj_spec = gamedata['units'][unit['spec']]; obj_level = unit['level']||1;
        } else {
            continue;
        }

        for(var res in gamedata['resources']) {
            if(res in item) {
                total_res[res] = (total_res[res]||0) + item[res];
            }
        }
        if(obj_spec['name'] != kind) {
            // start new box
            box += 1;
            if(box < NBOXES) {
                counters[box] = 1;
                kind = obj_spec['name'];
                dialog.widgets['queue'+box.toString()].show = !player.squads_enabled();
                dialog.widgets['queue'+box.toString()].bg_image = get_leveled_quantity(obj_spec['art_asset'], obj_level);
                dialog.widgets['queue'+box.toString()].alpha = (obj_spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1);
                dialog.widgets['queue_counter_bg'+box.toString()].show =
                    dialog.widgets['queue_counter'+box.toString()].show = !player.squads_enabled();
                dialog.widgets['queue_cancel'+box.toString()].show = gamedata['unit_repair_can_cancel'] && !player.squads_enabled();
                dialog.widgets['queue_cancel'+box.toString()].onclick = (function (_id) { return function() {
                    send_to_server.func(["UNIT_REPAIR_CANCEL", _id]);
                    unit_repair_sync_marker = synchronizer.request_sync();
                }; })(item['obj_id']);
            }
        } else {
            if(box < NBOXES) {
                counters[box] += 1;
            }
        }
    }
    for(var b = 0; b < NBOXES; b++) {
        dialog.widgets['queue_counter'+b.toString()].str = counters[b].toString();
    }

    // collect and sort list of all mobile units to display
    var unit_list = [];

    if(player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units'])) {
        for(var id in player.my_army) {
            var obj = player.my_army[id];
            if((obj['squad_id'] || 0) === dialog.user_data['squad_id']) {
                unit_list.push(obj);
            }
        }
    } else {
        session.for_each_real_object(function(obj) {
            if(obj.team === 'player' && obj.is_mobile()) {
                unit_list.push(obj);
                if(obj.is_damaged() && !obj.is_under_repair()) {
                    any_need_repair = true;
                }
            }
        });
    }

    var compare_by_awesomeness = function(a,b) {
        var aq = a.get_leveled_quantity(a.spec['max_hp']),
        bq = b.get_leveled_quantity(b.spec['max_hp']);
        if(aq < bq) { return 1; }
        if(aq > bq) { return -1; }
        return 0;
    };
    unit_list.sort(player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units']) ? army_unit_compare : compare_by_awesomeness);

    // annoying paging code
    var page = dialog.user_data['page'], row = 0, rows_per_page = 20;
    var chapter_units = unit_list.length;
    var chapter_pages = Math.floor((chapter_units+rows_per_page-1)/rows_per_page);
    dialog.user_data['page'] = page = (chapter_units == 0 ? 0 : clamp(page, 0, chapter_pages-1));
    if(chapter_units > 0) {
        // show units!
        var first_on_page = page * rows_per_page;
        var last_on_page = (page+1)*rows_per_page-1;
        last_on_page = Math.max(0, Math.min(last_on_page, chapter_units-1));
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_on_page+1).toString()).replace('%d2',(last_on_page+1).toString()).replace('%d3',chapter_units.toString());
        for(var i = first_on_page; i <= last_on_page; i++) {
            var obj = unit_list[i];
            var coord = (row%10).toString()+','+Math.floor(row/10).toString();
            dialog.widgets['grid'+coord].show = true;

            var spec, level, hp, max_hp, obj_id, repair_progress, is_under_repair, allow_repair;

            if(player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units'])) {
                spec = gamedata['units'][obj['spec']]; level = obj['level'] || 1; obj_id = obj['obj_id'];
                var cur_max_hp = army_unit_hp(obj); hp = cur_max_hp[0]; max_hp = cur_max_hp[1];
                repair_progress = hp / Math.max(max_hp,1);
                if(player.squads_enabled()) {
                    is_under_repair = false;
                    allow_repair = false;
                } else {
                    is_under_repair = army_unit_is_under_repair(obj['obj_id']);
                    allow_repair = (hp < max_hp) && !is_under_repair;
                    if(allow_repair) { any_need_repair = true; }
                }
            } else {
                spec = obj.spec; level = obj.level; obj_id = obj.id;
                hp = obj.hp; max_hp = obj.max_hp;
                if(obj.is_under_repair() && obj_id == player.unit_repair_queue[0]['obj_id']) {
                    // for unit currently being repaired, use the more accurate estimated HP from the queue code above
                    repair_progress = cur_repair_est_progress;
                } else {
                    repair_progress = obj.hp / Math.max(obj.max_hp,1);
                }
                is_under_repair = obj.is_under_repair();
                allow_repair = obj.is_damaged() && !is_under_repair;
            }

            dialog.widgets['grid'+coord].asset = get_leveled_quantity(spec['art_asset'], level);
            dialog.widgets['grid'+coord].tooltip.str = dialog.data['widgets']['grid']['ui_tooltip'].replace('%s', spec['ui_name']).replace('%cur', pretty_print_number(level)).replace('%max', pretty_print_number(get_max_ui_level(spec)));
            dialog.widgets['grid'+coord].alpha = (spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1);
            dialog.widgets['grid_health'+coord].show = (hp != max_hp) && (hp>0);
            dialog.widgets['grid_health'+coord].progress = repair_progress;

            dialog.widgets['grid_skull'+coord].show = (hp <= 0) && !is_under_repair;
            dialog.widgets['grid_wrench'+coord].show = is_under_repair;
            if(is_under_repair) {
                var active = (player.unit_repair_queue[0]['obj_id'] === obj_id);
                dialog.widgets['grid_wrench'+coord].asset = dialog.data['widgets']['grid_wrench']['asset_'+(active ? 'active' : 'queued')];
                dialog.widgets['grid_wrench'+coord].rocking = active;
            }

            var show_recycle, show_repair, alpha = 0;
            if(dialog.widgets['grid'+coord].mouse_enter_time > 0) {
                show_recycle = true;
                show_repair = allow_repair;
                alpha = 0.75*clamp((client_time - dialog.widgets['grid'+coord].mouse_enter_time)/0.15, 0, 1); // fade in
                dialog.widgets['grid_repair'+coord].onclick = (function (_obj, _coord) { return function(w) {
                    w.parent.widgets['grid'+_coord].tooltip.onleave();

                    var cost, tech_alert = null, server_param;
                    if(player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units'])) {
                        server_param = _obj['obj_id'];
                        var curmax = army_unit_hp(_obj);
                        cost = mobile_cost_to_repair(gamedata['units'][_obj['spec']], _obj['level']||1, curmax[0], curmax[1], player);
                        if(!player.can_repair_unit_of_spec(gamedata['units'][_obj['spec']], curmax[0])) {
                            tech_alert = _obj['spec'];
                        }
                    } else {
                        server_param = _obj.id;
                        cost = _obj.cost_to_repair(player);
                        if(!player.can_repair_unit(_obj)) {
                            tech_alert = _obj.spec['name'];
                        }
                    }

                    var ls = [];

                    for(var res in gamedata['resources']) {
                        if(player.resource_state[res][1] < (cost[res]||0)) {
                            ls.push(pretty_print_number(cost[res]||0) + ' ' + gamedata['resources'][res]['ui_name']);
                        }
                    }
                    if(ls.length > 0) {
                        var s = gamedata['strings']['requirements_help']['insufficient_resources_to_repair_a_unit']['any'];
                        invoke_child_message_dialog(s['ui_title'],
                                                    s['ui_description'].replace('%res', ls.join(', ')));
                        return;
                    }

                    if(tech_alert) {
                        var helper = get_requirements_help('tech_for_repair', tech_alert);
                        if(helper) { helper(); }
                        return;
                    }
                    send_to_server.func(["UNIT_REPAIR_QUEUE", server_param]);
                    unit_repair_sync_marker = synchronizer.request_sync();
                }; })(obj, coord);
                dialog.widgets['grid_recycle'+coord].onclick = (function (_obj, _coord) { return function(w) {
                    w.parent.widgets['grid'+_coord].tooltip.onleave();
                    invoke_recycle_dialog(_obj);
                }; })(obj, coord);

            } else {
                show_recycle = false;
                show_repair = false;
                alpha = 0;
            }
            dialog.widgets['grid_recycle'+coord].show = show_recycle;
            dialog.widgets['grid_repair'+coord].show = show_repair;
            dialog.widgets['grid_recycle'+coord].alpha = alpha;
            dialog.widgets['grid_repair'+coord].alpha = alpha;
            row += 1;
        }
    } else {
        // no units to show
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(0).toString()).replace('%d2',(0).toString()).replace('%d3',(0).toString());
    }

    // clear out empty rows
    while(row < rows_per_page) {
        var coord = (row%10).toString()+','+Math.floor(row/10).toString();
        dialog.widgets['grid'+coord].show =
            dialog.widgets['grid_health'+coord].show =
            dialog.widgets['grid_wrench'+coord].show =
            dialog.widgets['grid_skull'+coord].show =
            dialog.widgets['grid_recycle'+coord].show =
            dialog.widgets['grid_repair'+coord].show = false;
        row += 1;
    }

    // set clickability of scroll arrows
    if(page != 0) {
        dialog.widgets['scroll_left'].state = 'normal';
    } else {
        dialog.widgets['scroll_left'].state = 'disabled';
    }
    if(page < (chapter_pages-1)) {
        dialog.widgets['scroll_right'].state = 'normal';
    } else {
        dialog.widgets['scroll_right'].state = 'disabled';
    }

    dialog.widgets['scroll_left'].onclick = function() { repair_control_change_page(selection.ui.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function() { repair_control_change_page(selection.ui.user_data['page']+1); };

    var in_sync = synchronizer.is_in_sync(unit_repair_sync_marker);

    var space_usage = player.get_army_space_usage_by_squad();
    dialog.widgets['resource_bar_cap_amount'].str = pretty_print_number(space_usage['ALL']) + '/' + pretty_print_number(player.stattab['total_space']);
    dialog.widgets['resource_bar_cap'].progress = space_usage['ALL']/Math.max(player.stattab['total_space'],1);

    dialog.widgets['add_all_button'].state = (any_need_repair && in_sync ? 'normal' : 'disabled');
    dialog.widgets['add_all_button'].str = dialog.data['widgets']['add_all_button']['ui_name'+(!in_sync ? '_pending' : '')];

    dialog.widgets['add_all_button'].onclick = function() {
        var to_repair = [];

        if(player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units'])) {
            for(var id in player.my_army) {
                var obj = player.my_army[id];
                var spec = gamedata['units'][obj['spec']]; var level = obj['level'] || 1;  var obj_id = obj['obj_id'];
                var cur_max_hp = army_unit_hp(obj); hp = cur_max_hp[0]; max_hp = cur_max_hp[1];
                if(hp < max_hp && !army_unit_is_under_repair(obj_id)) {
                    to_repair.push(obj);
                }
            }
        } else {
            session.for_each_real_object(function(obj) {
                if(obj.team === 'player' && obj.is_mobile() && obj.is_damaged() && !obj.is_under_repair() ) {
                    to_repair.push(obj);
                }
            });
        }

        // add quickest units first
        var compare_by_reptime = (function(_player) { return function(a, b) {
            var acost, bcost;
            if(player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units'])) {
                var acurmax = army_unit_hp(a), bcurmax = army_unit_hp(b);
                acost = mobile_cost_to_repair(gamedata['units'][a['spec']], a['level']||1, acurmax[0], acurmax[1], _player);
                bcost = mobile_cost_to_repair(gamedata['units'][b['spec']], b['level']||1, bcurmax[0], bcurmax[1], _player);
            } else {
                acost = a.cost_to_repair(_player);
                bcost = b.cost_to_repair(_player);
            }
            var aq = acost['time'], bq = bcost['time'];
            if(aq > bq) { return 1; }
            if(aq < bq) { return -1; }
            return 0;
        }; })(player);
        to_repair.sort(compare_by_reptime);

        var tech_alert = null;
        var enough_res = true;
        var total_cost = {};

        for(var i = 0; i < to_repair.length; i++) {
            var obj = to_repair[i];

            if(player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units'])) {
                var curmax = army_unit_hp(obj);
                if(!player.can_repair_unit_of_spec(gamedata['units'][obj['spec']], curmax[0])) {
                    tech_alert = obj['spec'];
                    continue;
                }
                var cost = mobile_cost_to_repair(gamedata['units'][obj['spec']], obj['level']||1, curmax[0], curmax[1], player);
                for(var resname in gamedata['resources']) {
                    total_cost[resname] = (total_cost[resname]||0) + cost[resname];
                    if(player.resource_state[resname][1] < total_cost[resname]) {
                        enough_res = false; // but keep going
                    }
                }

                if(enough_res) {
                    send_to_server.func(["UNIT_REPAIR_QUEUE", obj['obj_id']]);
                }
            } else {
                if(!player.can_repair_unit(obj)) {
                    tech_alert = obj.spec['name'];
                    continue;
                }

                var cost = obj.cost_to_repair(player);
                for(var resname in gamedata['resources']) {
                    total_cost[resname] = (total_cost[resname]||0) + cost[resname];
                    if(player.resource_state[resname][1] < total_cost[resname]) {
                        enough_res = false; // but keep going
                    }
                }

                if(enough_res) {
                    send_to_server.func(["UNIT_REPAIR_QUEUE", obj.id]);
                }
            }
        }

        unit_repair_sync_marker = synchronizer.request_sync();

        if(!enough_res) {
            invoke_insufficient_resources_for_repair_message(total_cost);
        } else if(tech_alert) {
            var helper = get_requirements_help('tech_for_repair', tech_alert);
            if(helper) { helper(); }
        }
    };

    // res/time display at bottom
    for(var res in gamedata['resources']) {
        if('requirements_'+res+'_value' in dialog.widgets) {
            var amount = total_res[res] || 0;
            dialog.widgets['requirements_'+res+'_value'].show =
                dialog.widgets['requirements_'+res+'_icon'].show = (amount > 0);
            if(amount > 0) {
                dialog.widgets['requirements_'+res+'_value'].str = pretty_print_number(amount);
            }
        }
    }

    if(player.unit_repair_queue.length > 0) {
        dialog.widgets['requirements_time_value'].str = pretty_print_time_brief(player.unit_repair_queue[player.unit_repair_queue.length-1]['finish_time'] - server_time);
    } else {
        dialog.widgets['requirements_time_value'].str = '-';
    }

    // price/finish button
    var price = Store.get_user_currency_price(GameObject.VIRTUAL_ID, gamedata['spells']['UNIT_REPAIR_SPEEDUP_FOR_MONEY'], null);
    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_short_asset', gamedata['store']['price_display_short_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].str = (!in_sync ? '' : Store.display_user_currency_price(price, 'compact')); // PRICE
    dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'+(!in_sync ? '_pending': '')];
    dialog.widgets['price_display'].tooltip.str = (!in_sync ? null : Store.display_user_currency_price_tooltip(price));
    dialog.widgets['price_spinner'].show = !in_sync && !player.squads_enabled();

    if(price == 0) {
        dialog.widgets['finish_button'].state = (!in_sync ? 'disabled': 'normal');
        dialog.widgets['finish_button'].onclick = function() {
            send_to_server.func(["UNIT_REPAIR_SPEEDUP_FOR_FREE"]);
            unit_repair_sync_marker = synchronizer.request_sync();
            invoke_ui_locker(unit_repair_sync_marker);
        };
        dialog.widgets['price_display'].onclick = (!in_sync ? null: dialog.widgets['finish_button'].onclick);
    } else if(price > 0) {
        dialog.widgets['finish_button'].state = (!in_sync ? 'disabled': 'normal');
        dialog.widgets['finish_button'].onclick = function() {
            if(Store.place_user_currency_order(GameObject.VIRTUAL_ID, "UNIT_REPAIR_SPEEDUP_FOR_MONEY", null, null)) {
                unit_repair_sync_marker = synchronizer.request_sync();
                invoke_ui_locker(unit_repair_sync_marker);
            }
        };
        dialog.widgets['price_display'].onclick = (!in_sync ? null: dialog.widgets['finish_button'].onclick);
    } else {
        dialog.widgets['finish_button'].state = 'disabled';
        dialog.widgets['price_display'].onclick = null;
    }
}

// set up the row of buttons for manufacture/upgrade/repair that go across the top of all "Army"/"Weapons" dialogs
var ARMY_DIALOG_BUTTONS = {
    'army': { 'production_button': { 'dialog_names': ['manufacture_dialog'],
                                     'spells': ['MAKE_DROIDS'],
                                     'onclick': function(w) {
                                         var _dialog = w.parent.parent;
                                         var category = (('category' in _dialog.user_data) ? _dialog.user_data['category'] : null);
                                         invoke_manufacture_dialog('production_button', category);
                                     } },
              'unlock_button': { 'dialog_names': ['research_dialog'],
                                 'spells': ['RESEARCH_FOR_FREE'],
                                 'onclick': function(w) {
                                     var _dialog = w.parent.parent;
                                     var category = (('category' in _dialog.user_data) ? _dialog.user_data['category'] : null);
                                     invoke_research_dialog('army', category);
                                 } },
              'repair_button': { 'dialog_names': ['repair_control'],
                                 'spells':['RECYCLE_UNIT'],
                                 'spells_nosquads': ['REPAIR','RECYCLE_UNIT'],
                                 'onclick': function(w) { invoke_repair_control(); } },
              'control_squads_button': { 'dialog_names': ['squad_control'],
                                         'spells': ['MANAGE_SQUADS'],
                                         'require_squads': true,
                                         'onclick': function(w) { change_selection_ui(null); SquadControlDialog.invoke_normal(); } },
              'army_help_button': { 'dialog_names': [],
                                    'require_squads': true,
                                    'onclick': function(w) { invoke_army_dialog_help(); } }
            },
    'crafting': { 'production_button': { 'dialog_names': ['crafting_dialog','crafting_table_of_contents_dialog'],
                                         'spells': ['CRAFT_FOR_FREE'],
                                         // require at least one crafting category that works with the generic crafting GUI
                                         'require_generic_crafting_category': 1,
                                         'onclick': function(w) {
                                             var _dialog = w.parent.parent;
                                             var category = (('category' in _dialog.user_data) ? _dialog.user_data['category'] : null);
                                             // check if we should go to table-of-contents dialog instead of directly to crafting dialog
                                             if(category) {
                                                 var catdata = gamedata['crafting']['categories'][category];
                                                 if(catdata && catdata['table_of_contents']) {
                                                     change_selection_ui(null);
                                                     invoke_crafting_table_of_contents_dialog(category);
                                                     return;
                                                 }
                                             }
                                             change_selection_ui(null);
                                             invoke_crafting_dialog(category);
                                         } },
                  'unlock_button': { 'dialog_names': ['research_dialog'],
                                     'spells': ['RESEARCH_FOR_FREE'],
                                     'onclick': function(w) {
                                         var _dialog = w.parent.parent;
                                         var category = (('category' in _dialog.user_data) ? _dialog.user_data['category'] : null);
                                         if(category) {
                                             var catspec = gamedata['crafting']['categories'][category];
                                             if(catspec['unlock_building_for_ui']) {
                                                 // no techs to research - point at building instead
                                                 var builder = find_object_by_type(catspec['unlock_building_for_ui']);
                                                 if(!builder) {
                                                     var helper = get_requirements_help(read_predicate({'predicate': 'BUILDING_LEVEL', 'building_type': catspec['unlock_building_for_ui'], 'trigger_level': 1}));
                                                     if(helper) {
                                                         helper();
                                                     } else {
                                                         console.log('unlock_building_for_ui not present and no helper available');
                                                     }
                                                     return;
                                                 }
                                                 change_selection_unit(builder);
                                                 invoke_upgrade_building_dialog();
                                                 return;
                                             }
                                         }
                                         invoke_research_dialog('crafting', category);
                                     } }
                },
    'leaders': { 'production_button': { 'dialog_names': ['crafting_dialog','crafting_table_of_contents_dialog'],
                                        'spells': ['CRAFT_FOR_FREE'],
                                        'onclick': function(w) {
                                            var _dialog = w.parent.parent;
                                            var category = (('category' in _dialog.user_data) ? _dialog.user_data['category'] : null);
                                            invoke_crafting_table_of_contents_dialog(category);
                                        } },
                  'unlock_button': { 'dialog_names': ['research_dialog'],
                                     'spells': ['RESEARCH_FOR_FREE'],
                                     'onclick': function(w) {
                                         var _dialog = w.parent.parent;
                                         var category = (('category' in _dialog.user_data) ? _dialog.user_data['category'] : null);
                                         invoke_research_dialog('leaders', category);
                                     } }
                }
};

/** @param {SPUI.Dialog} dialog
    @param {string|null} mode
    @param {string} my_dialog_name
    @param {(string|null)=} category_name optional research/crafting category name */
function init_army_dialog_buttons(dialog, mode, my_dialog_name, category_name) {
    var use_squads = player.squads_enabled();
    goog.object.forEach(ARMY_DIALOG_BUTTONS[mode], function(data, btn) {
        if(!(btn in dialog.widgets)) { return; }

        if(data['require_generic_crafting_category']) {
            if(!goog.object.some(gamedata['crafting']['categories'], function(cat) {
                return !('dialog' in cat) && (!('show_if' in cat) || read_predicate(cat['show_if']).is_satisfied(player, null));
            })) {
                // don't show the "Produce" buttona
                dialog.widgets[btn].show = false;
                return;
            }
        }

        dialog.widgets[btn].show = (use_squads || !data['require_squads']);
        var match = (data['dialog_names'] && goog.array.contains(data['dialog_names'], my_dialog_name));
        dialog.widgets[btn].onclick = (match ? null : data['onclick']);
        dialog.widgets[btn].state = (match ? 'active' : 'normal');
        var spells = data['spells'] || null;
        if(!use_squads) { // temporarily look different when squads are disabled
            if('spells_nosquads' in data) { spells = data['spells_nosquads']; }
            if('ui_name_nosquads' in dialog.data['widgets'][btn]) {
                dialog.widgets[btn].str = dialog.data['widgets'][btn]['ui_name_nosquads'];
            }
            if('xy_nosquads' in dialog.data['widgets'][btn]) {
                dialog.widgets[btn].xy = dialog.data['widgets'][btn]['xy_nosquads'];
            }
        }
        if(spells) {
            var spell_ui_names = [];
            goog.array.forEach(spells, function(spellname) {
                var ui_name = null;
                if(spellname == 'CRAFT_FOR_FREE' && mode in gamedata['crafting']['categories'] &&
                  'ui_verb' in gamedata['crafting']['categories'][mode]) {
                    ui_name = gamedata['crafting']['categories'][mode]['ui_verb'];
                } else {
                    var spell = gamedata['spells'][spellname];
                    ui_name = spell['ui_dialog_name'] || spell['ui_name'];
                }
                spell_ui_names.push(ui_name);
            });
            dialog.widgets[btn].str = spell_ui_names.join(' & ');
        }
    });
    if(mode === 'crafting' && category_name){
        dialog.widgets['production_button'].show = (category_name in gamedata['crafting']['categories'] && !('dialog' in gamedata['crafting']['categories'][category_name]));
    }
}
function hide_army_dialog_buttons(dialog, mode) {
    goog.object.forEach(ARMY_DIALOG_BUTTONS[mode], function(data, btn) {
        if(!(btn in dialog.widgets)) { return; }
        dialog.widgets[btn].show = false;
    });
}

/** @type {string|null} category name to use, unless another one is specified */
var last_manufacture_dialog_category = null;

/** @param {string} reason - arbitrary source ID, used for metrics only
    @param {string=} category - preselect a particular manufacture_category
    @param {string|null=} specname - preselect a particular unit (specname)
    @param {GameObject|null=} want_builder - use THIS factory building (otherwise pick any applicable factory) */
function invoke_manufacture_dialog(reason, category, specname, want_builder) {
    if(player.tutorial_state != "COMPLETE") {
        // during rails tutorial, force category to most basic one
        category = goog.object.getKeys(gamedata['strings']['manufacture_categories'])[0];
    }

    if(last_manufacture_dialog_category === null) {
        // default to first-listed manufacture category (the most basic one)
        last_manufacture_dialog_category = goog.object.getKeys(gamedata['strings']['manufacture_categories'])[0];
    }

    var dialog_data = gamedata['dialogs']['manufacture_dialog'];

    // instantiate the dialog
    var dialog = new SPUI.Dialog(dialog_data);

    // make the dialog modal and add it to the "desktop"
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'manufacture_dialog';
    dialog.user_data['reason'] = reason;
    dialog.user_data['category'] = null;
    dialog.user_data['page'] = 0;
    dialog.user_data['builder'] = null;
    dialog.user_data['units'] = null;
    dialog.user_data['units_this_page'] = null;
    dialog.user_data['current_unit'] = null;
    dialog.user_data['scrolled'] = false;
    dialog.user_data['want_builder'] = want_builder || null; // prefer this builder, if available

    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['dev_title'].show = player.is_cheater;

    init_army_dialog_buttons(dialog.widgets['army_dialog_buttons_army'], 'army', 'manufacture_dialog');

    // show labels for available manufacture categories and wire up click handlers
    var cat_i = 0;
    goog.object.forEach(gamedata['strings']['manufacture_categories'], function(data, cat) {
        if(!get_factory_for(cat)) { return; } // cannot be built
        if('show_if' in data && !read_predicate(data['show_if']).is_satisfied(player, null)) { return false; }

        if(cat_i < dialog.data['widgets']['cat_button']['array'][0]) {
            dialog.widgets['cat_button'+cat_i.toString()].str = data['plural'];
            dialog.widgets['cat_button'+cat_i.toString()].onclick = (function (_cat) { return function(w) { manufacture_dialog_change_category(w.parent, _cat); }; })(cat);
        }
        cat_i += 1;
    });

    // clear remaining unused labels
    while(cat_i < dialog.data['widgets']['cat_button']['array'][0]) {
        dialog.widgets['cat_button'+cat_i.toString()].show = false;
        cat_i += 1;
    }

    dialog.widgets['scroll_left'].onclick = function(w) { dialog.user_data['scrolled'] = true; manufacture_dialog_scroll(w.parent, w.parent.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function(w) { dialog.user_data['scrolled'] = true; manufacture_dialog_scroll(w.parent, w.parent.user_data['page']+1); };

    dialog.ondraw = update_manufacture_dialog;

    manufacture_dialog_change_category(dialog, category || last_manufacture_dialog_category, specname || null);
}

// return function that helps player to unlock unit "specname" (or units of category "category", whichever is non-null)
/** @param {string|null} category
    @param {string|null} specname
    @param {string} reason
    @return {function()|null} */
function manufacture_dialog_unlock_helper(category, specname, reason) {
    var builder_type = null;

    if(specname) {
        var spec = gamedata['units'][specname];
        builder_type = get_factory_for(spec['manufacture_category']);
        if(!builder_type) {
            throw Error('no factory can build '+spec['manufacture_category']);
        }

        var builder = find_object_by_type(builder_type);
        if(builder) {
            if(unit_unlock_level(specname) < 1) {
                var pred = get_leveled_quantity(spec['requires'] || null, 1);
                if(!pred) {
                    pred = {'predicate': 'TECH_LEVEL', 'tech': spec['level_determined_by_tech'], 'min_level':1};
                }
                // pass "even_if_tutorial_incomplete" option since this is vital for the manufacture_dialog to work properly, even during the tutorial
                return get_requirements_help(read_predicate(pred), null, {even_if_tutorial_incomplete:1});
            } else {
                throw Error('cannot determine what is wrong for '+specname+' reason '+reason+' current unlock level '+unit_unlock_level(specname).toString());
            }
        } else {
            // fall through
        }
    } else if(category) {
        builder_type = get_factory_for(category);
    }

    if(builder_type) {
        return get_requirements_help(read_predicate({'predicate': 'BUILDING_LEVEL', 'building_type': builder_type, 'trigger_level': 1}), null, {even_if_tutorial_incomplete:1});
    }
    throw Error('cannot determine what is wrong for cat '+ (category||'null') + ' spec '+(specname||'null')+' reason '+reason);
}


/** @param {SPUI.Dialog} dialog
    @param {string} catname
    @param {string|null=} preselect_specname */
function manufacture_dialog_change_category(dialog, catname, preselect_specname) {
    last_manufacture_dialog_category = catname;
    dialog.user_data['category'] = catname;

    // set appearance and state for category buttons
    var cat_i = 0;
    goog.object.forEach(gamedata['strings']['manufacture_categories'], function(data, cat) {
        if(!get_factory_for(cat)) { return; } // cannot be built
        if(cat_i < dialog.data['widgets']['cat_button']['array'][0]) {
            dialog.widgets['cat_button'+cat_i.toString()].state = (catname === cat ? 'active' : 'normal');
            dialog.widgets['cat_button'+cat_i.toString()].text_color = (catname === cat ? SPUI.default_text_color : SPUI.disabled_text_color);
        }
        cat_i += 1;
    });

    // select builder (may be null if no factory is present)
    var builder = null;
    var builder_type = get_factory_for(catname);
    if(dialog.user_data['want_builder'] && dialog.user_data['want_builder'].spec['name'] == builder_type) {
        builder = dialog.user_data['want_builder'];
    } else {
        builder = find_highest_level_object_by_type(builder_type);
    }

    // note: builder may be null here
    change_selection_unit(builder);
    dialog.user_data['builder'] = builder;

    // create list of units for this category
    dialog.user_data['units'] = [];
    // only sort if at least one item has ui_priority (otherwise leave in JSON order)
    var use_priority_sort = false;

    for(var name in gamedata['units']) {
        var spec = gamedata['units'][name];

        if(spec['manufacture_category'] != dialog.user_data['category']) {
            continue;
        }
        if((spec['developer_only'] || spec['ui_priority'] === -1) && (spin_secure_mode || !player.is_cheater)) { continue; }

        if('show_if' in spec && !read_predicate(spec['show_if']).is_satisfied(player, null)) { continue; }
        if('activation' in spec && !read_predicate(spec['activation']).is_satisfied(player, null)) { continue; }
        dialog.user_data['units'].push(name);
        if('ui_priority' in spec) { use_priority_sort = true; }
    }

    if(player.upgrade_bar_enabled()) {
        UpgradeBar.invoke(dialog, 'building', (builder ? builder.spec['name'] : null), (builder ? builder.level+1 : -1), (builder ? builder.id : null));
    }

    if(use_priority_sort) {
        dialog.user_data['units'].sort(function(a, b) {
            // first sort by ui_priority high to low
            var ui_priority_a = gamedata['units'][a]['ui_priority'] || 0;
            var ui_priority_b = gamedata['units'][b]['ui_priority'] || 0;
            if(ui_priority_a < ui_priority_b) {
                return 1;
            } else if(ui_priority_a > ui_priority_b) {
                return -1;
            }
            return 0;
        });
    }

    manufacture_dialog_scroll(dialog, 0);
    manufacture_dialog_select_unit(dialog, preselect_specname || null);
}

function manufacture_dialog_scroll(dialog, page) {
    dialog.user_data['units_this_page'] = null;
    var builder = dialog.user_data['builder'];

    var chapter_units = (dialog.user_data['units'] ? dialog.user_data['units'].length : 0);
    var units_per_page = dialog.data['widgets']['grid']['array'][0]*dialog.data['widgets']['grid']['array'][1];
    var chapter_pages = Math.floor((chapter_units+units_per_page-1)/units_per_page);
    dialog.user_data['page'] = page = (chapter_units === 0 ? 0 : clamp(page, 0, chapter_pages-1));

    if(chapter_pages > 0) {
        dialog.user_data['units_this_page'] = [];
        var first_unit_on_page = page * units_per_page;
        var last_unit_on_page = Math.max(0, Math.min((page+1)*units_per_page-1, chapter_units-1));
        for(var i = first_unit_on_page; i <= last_unit_on_page; i++) {
            var name = dialog.user_data['units'][i];
            dialog.user_data['units_this_page'].push(name);
        }
        dialog.widgets['scroll_text'].show = true;
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_unit_on_page+1).toString()).replace('%d2',(last_unit_on_page+1).toString()).replace('%d3',chapter_units.toString()).replace('%cat', gamedata['strings']['manufacture_categories'][dialog.user_data['category']]['plural']);
    } else {
        dialog.widgets['scroll_text'].show = false;
    }

    dialog.widgets['scroll_left'].state = (page != 0 ? 'normal' : 'disabled');
    dialog.widgets['scroll_right'].state = ((page < chapter_pages-1) ? 'normal' : 'disabled');

    player.quest_tracked_dirty = true;
}

/** "Select" a unit, meaning show its stats on the right-hand side
    @param {SPUI.Dialog} dialog
    @param {string|null} name - specname of the unit to select. If null, then show generic "<- Click to produce" message */
function manufacture_dialog_select_unit(dialog, name) {
    dialog.user_data['current_unit'] = name;

    //dialog.widgets['coverup_queue'].show =
    dialog.widgets['coverup_all'].show =
        dialog.widgets['click_to_unlock'].show =
        dialog.widgets['click_to_unlock_button'].show =
        dialog.widgets['click_to_produce_arrow'].show =
        dialog.widgets['click_to_produce'].show = false;

    if(!name) {
        dialog.widgets['coverup_all'].show =
            dialog.widgets['click_to_produce_arrow'].show =
            dialog.widgets['click_to_produce'].show = true;
        dialog.widgets['click_to_produce'].str = dialog.data['widgets']['click_to_produce']['ui_name'].replace('%VERB', gamedata['spells']['MAKE_DROIDS']['ui_name'].toLowerCase());
        return;
    }

    var spec = gamedata['units'][name];

    var level = unit_unlock_level(name);
    if(player.is_cheater) { level = Math.max(level, 1); }

    dialog.widgets['unit_name'].str = dialog.widgets['unit_name'].data[(level >= 1 ? 'ui_name' : 'ui_name_locked')].replace('%s', spec['ui_name']).replace('%d', level);
    dialog.widgets['unit_description'].str = spec['ui_tip'];

    var hero_asset, hero_state, hero_offset;
    if('splash_image' in spec) { // UNIT with splash image
        hero_asset = get_leveled_quantity(spec['splash_image'], Math.max(level, 1));
        hero_state = (level < 1 && GameArt.assets[hero_asset].has_state('normal_disabled') ? 'normal_disabled' : 'normal');
        hero_offset = dialog.data['widgets']['unit_hero_icon']['bg_image_offset_splash'];
    } else {
        hero_asset = get_leveled_quantity(spec['art_asset'], Math.max(level, 1));
        if(level < 1) {
            // player can't build this unit - show level 1 stats and gray out portrait
            level = 1;
            hero_state = 'hero_disabled';
        } else {
            hero_state = 'hero';
        }

        var voffset;
        if(spec['flying']) {
            voffset = -5*spec['altitude'];
        } else {
            voffset = 0;
        }
        hero_offset = vec_add(dialog.data['widgets']['unit_hero_icon']['bg_image_offset'], [0,voffset]);
    }
    dialog.widgets['unit_hero_icon'].bg_image = hero_asset;
    dialog.widgets['unit_hero_icon'].alpha = spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1;
    dialog.widgets['unit_hero_icon'].state = hero_state;

    dialog.widgets['unit_hero_icon'].bg_image_offset = hero_offset;

    // fill in unit stats
    var auto_spell = get_auto_spell_for_unit(player, spec);
    var auto_spell_level = Math.max(level, 1);

    var features = ['max_hp'];
    if(gamedata['show_armor_in_ui']) { features.push('armor'); }
    features.push('maxvel');
    if('ui_priority_vs' in spec) { features.push('ui_priority_vs'); }
    features.push('weapon_damage');
    if(!auto_spell || !is_melee_spell(auto_spell)) { // yes, things with no auto_spell can have ranges (at least the old code worked that way?)
        features.push('weapon_range');
    }
    if(auto_spell && ('splash_range' in auto_spell)) { features.push('splash_range'); }

    var row = 0;
    goog.array.forEach(features, function(stat) {
        var modchain = (player.stattab['units'][spec['name']] || {})[stat] || null;
        if(stat == 'maxvel') {
            // special case to rebase maxvel, which is a scaling factor from the point of view of mods
            var base_maxvel = get_leveled_quantity(spec['maxvel'], level);
            modchain = (modchain ? ModChain.recompute_with_new_base_val(modchain, base_maxvel, level) : ModChain.make_chain(base_maxvel, {'level':level}));
        }
        dialog.widgets['feature_value'+row.toString()].show = dialog.widgets['feature_label'+row.toString()].show = true;
        ModChain.display_widget(dialog.widgets['feature_value'+row.toString()], stat, modchain, spec, Math.max(level, 1), auto_spell, auto_spell_level, true);
        ModChain.display_label_widget(dialog.widgets['feature_label'+row.toString()], stat, auto_spell, true);
        row += 1;
    });
    while(row < dialog.data['widgets']['feature_label']['array'][1]) {
        dialog.widgets['feature_value'+row.toString()].show = dialog.widgets['feature_label'+row.toString()].show = false;
        row += 1;
    }
    init_damage_vs_icons(dialog, spec, auto_spell);
}

function cancel_manuf_item(builder, queue_slot, spec_name) {
    send_to_server.func(["CAST_SPELL", builder.id, "CANCEL_MAKE_DROIDS", queue_slot, spec_name]);

    // client-side predict what will happen
    var manuf_queue = builder.start_client_prediction('manuf_queue', builder.manuf_queue);
    var spec = gamedata['units'][spec_name];
    var level = player.tech[spec['level_determined_by_tech']] || 1;
    var entry = manuf_queue.splice(queue_slot,1)[0];
    var cost = ((entry && 'cost' in entry) ? entry['cost'] : mobile_cost_to_repair(spec, level, 0, 1, player, COST_MODE.MANUFACTURE_CANCEL, builder));
    for(var res in gamedata['resources']) {
        player.resource_state[res][1] += Math.floor(((entry && 'cost' in entry) ? gamedata['manufacture_cancel_refund'] : 1) * (cost[res] || 0));
    }
    player.quest_tracked_dirty = true;
}

/** Main per-frame update - takes care of grid buttons and status displays*/
/** @param {SPUI.Dialog} dialog */
function update_manufacture_dialog(dialog) {
    var builder = dialog.user_data['builder'];

    // use client-side manuf_queue if we are out of sync
    var manuf_queue = (builder ? builder.get_client_prediction('manuf_queue', builder.manuf_queue) : null);

    // count how many units of each kind the player has
    var unit_count = {};

    if(!('enable_defending_units' in gamedata) || gamedata['enable_defending_units']) {
        // in games with defending units, count units in session (i.e. base defenders)
        session.for_each_real_object(function(obj) {
            if(obj.is_mobile() && (obj.team === 'player')) {
                var name = obj.spec['name'];
                if(name in unit_count) {
                    unit_count[name] += 1;
                } else {
                    unit_count[name] = 1;
                }
            }
        });
    } else {
        // in games without defending units, count entire army
        goog.object.forEach(player.my_army, function(obj) {
            var name = obj['spec'];
            if(name in unit_count) {
                unit_count[name] += 1;
            } else {
                unit_count[name] = 1;
            }
        });
    }

    // count queued units
    var queue_count = {};
    session.for_each_real_object(function(obj) {
        if(obj.is_building() && obj.is_manufacturer() && (obj.team === 'player')) {
            var q = obj.get_client_prediction('manuf_queue', obj.manuf_queue);
            goog.array.forEach(q, function(data) {
                var name = data['spec_name'];
                if(name in queue_count) {
                    queue_count[name] += 1;
                } else {
                    queue_count[name] = 1;
                }
            });
        }
    });

    // fill in grid of unit types
    var grid_x = 0, grid_y = 0;
    for(var u = 0; u < (dialog.user_data['units_this_page'] ? dialog.user_data['units_this_page'].length : 0); u++) {
        var name = dialog.user_data['units_this_page'][u];
        var spec = gamedata['units'][name];

        var widget_name = grid_x.toString() + ',' + grid_y.toString();
        var widget = dialog.widgets['grid'+widget_name];

        dialog.widgets['grid'+widget_name].show =
            dialog.widgets['grid_qty'+widget_name].show =
            dialog.widgets['sunken_grid_bg'+widget_name].show =
            dialog.widgets['sunken_grid'+widget_name].show =
            dialog.widgets['sunken_grid_label'+widget_name].show = true;

        dialog.widgets['sunken_grid_bg'+widget_name].color = SPUI.make_colorv(dialog.data['widgets']['sunken_grid_bg'][(dialog.user_data['current_unit'] == name ? 'color_highlight' : 'color')]);

        var asset_is_3d;
        var voffset; // tweak vertical positioning of icon

        if('icon' in spec) { // this doesn't necessarily look better - stay optional
            // override auto-generated 3D asset icon
            asset_is_3d = false;
            widget.bg_image = get_leveled_quantity(spec['icon'], 1);
            widget.alpha = 1;
            voffset = 0;
        } else {
            asset_is_3d = true;
            widget.bg_image = get_leveled_quantity(spec['art_asset'], 1);
            widget.alpha = spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1;
            if(spec['flying']) {
                voffset = -1*spec['altitude'];
            } else {
                voffset = 0;
            }
        }

        widget.bg_image_offset = [dialog.data['widgets']['grid']['bg_image_offset'][0],
                                  dialog.data['widgets']['grid']['bg_image_offset'][1] + voffset];

        widget.onenter = (function(_name) { return function(w) { manufacture_dialog_select_unit(w.parent, _name); } })(name);

        // this is the function that handles the mouse click
        var closure = (function(spec_name, _widget_name) {
            return function(w) {
                var dialog = w.parent;
                var builder = dialog.user_data['builder'];
                var unlock_level = unit_unlock_level(spec_name);

                if(player.is_cheater) {
                    var props = {}; props[spec_name] = 1;
                    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_SPAWN_UNITS", props]);

                } else if(builder && unlock_level > 0) {

                    // this is the function that actually runs the build command
                    var send_command = (function (_dialog, _spec_name, __widget_name) { return function() {
                        var builder = _dialog.user_data['builder'];
                        send_to_server.func(["CAST_SPELL", builder.id, "MAKE_DROIDS", _spec_name]);
                        var manuf_queue = builder.start_client_prediction('manuf_queue', builder.manuf_queue);

                        // client-side predict what will happen
                        var spec = gamedata['units'][_spec_name];
                        var level = player.tech[spec['level_determined_by_tech']] || 1;
                        var cost = mobile_cost_to_repair(spec, level, 0, 1, player, COST_MODE.MANUFACTURE, builder);
                        var entry = {'spec_name':_spec_name,
                                     'level':level,
                                     'total_time':cost['time'],
                                     'cost': {}
                                    };
                        for(var res in gamedata['resources']) {
                            if(cost[res]) {
                                player.resource_state[res][1] -= cost[res];
                                entry['cost'][res] = cost[res];
                            }
                        }
                        manuf_queue.push(entry);

                        // play different effect when starting manufacturing vs. subsequent queue appends
                        var fx_name = (manuf_queue.length == 1 ? 'unit_manufacture_start' : 'unit_manufacture_add_to_queue');
                        var fx_data = gamedata['client']['vfx'][fx_name];
                        if(fx_data) {
                            session.get_real_world().fxworld.add_visual_effect_at_time([builder.x,builder.y], 0, [0,1,0], client_time, fx_data,
                                                           true,
                                                           { '%OBJECT_SPRITE': get_leveled_quantity(spec['art_asset'], level)});
                        }
                        player.quest_tracked_dirty = true;


                        if(player.get_any_abtest_value('manufacture_unit_glow', gamedata['client']['manufacture_unit_glow'] || false)) {
                            _dialog.widgets['grid_glow'+__widget_name].show = true;
                            _dialog.widgets['grid_glow'+__widget_name].reset_fx();
                        }

                    }; })(dialog, spec_name, _widget_name);

                    // check requirements
                    var spec = gamedata['units'][spec_name];
                    var cost_space = get_leveled_quantity(spec['consumes_space'], unlock_level);
                    var cost_res = mobile_cost_to_repair(spec, unlock_level, 0, 1, player, COST_MODE.MANUFACTURE, builder);
                    var not_enough_res = null; // name of one needy resource
                    var resources_needed = {};

                    for(var res in gamedata['resources']) {
                        if(player.resource_state[res][1] < cost_res[res]) {
                            not_enough_res = res;
                            resources_needed[res] = cost_res[res] - player.resource_state[res][1];
                        }
                    }

                    var space_usage = player.get_army_space_usage_by_squad();
                    var available_space = player.stattab['total_space'] - space_usage['ALL'];
                    if(!player.squads_enabled() || !gamedata['produce_to_reserves']) {
                        available_space = Math.min(available_space, player.stattab['main_squad_space'] - space_usage[SQUAD_IDS.BASE_DEFENDERS.toString()]);
                    }

                    // check count limit
                    var count_limit_problem = false;
                    if(spec['limit'] && !player.is_cheater) {
                        var counts = player.get_army_unit_count_by_specname();
                        var cur_count = counts[spec['name']] || 0;
                        if(cur_count + 1 > spec['limit']) {
                            count_limit_problem = true;
                        }
                    }

                    if(count_limit_problem) {
                        var helper = get_requirements_help('unit_count', spec['name']);
                        if(helper) {
                            helper();
                        } else {
                            var s = gamedata['errors']['UNIT_COUNT_LIMIT'];
                            invoke_child_message_dialog(s['ui_title'], s['ui_name'], {'dialog': 'message_dialog_big'});
                        }
                    } else if(available_space < cost_space && !player.is_cheater) {
                        var helper = get_requirements_help('unit_space', cost_space - available_space);
                        if(helper) {
                            helper();
                        } else {
                            var s = null;
                            if(player.squads_enabled()) {
                                var reason = classify_unit_space_shortage();
                                if(reason == 'base_defenders') {
                                    s = gamedata['strings']['requirements_help']['unit_space_base_defenders']['manage_base_defenders'];
                                } else if(reason == 'total_army') {
                                    s = gamedata['strings']['requirements_help']['unit_space_total_army']['upgrade'];
                                } else if(reason == 'recycle') {
                                    s = gamedata['strings']['requirements_help']['unit_space_total_army']['recycle'];
                                }
                            } else {
                                s = gamedata['strings']['requirements_help']['unit_space']['upgrade'];
                            }
                            if(s) {
                                invoke_child_message_dialog(s['ui_title'], s['ui_description'], {'dialog': 'message_dialog_big'});
                            }
                        }
                    } else if(builder.is_repairing()) {
                        // prompt player to speedup repair
                        invoke_child_speedup_dialog('production');
                    } else if(builder.is_damaged()) {
                        // prompt player to initiate repair
                        invoke_child_repair_dialog();
                    } else if(builder.is_upgrading() || builder.is_enhancing() || builder.is_removing()) {
                        // prompt player to speedup upgrade
                        invoke_child_speedup_dialog('production');
                    } else if(builder.level < get_leveled_quantity(gamedata['units'][spec_name]['requires_factory_level']||0, unlock_level)) {
                        var helper = get_requirements_help(read_predicate({'predicate':'BUILDING_LEVEL',
                                                                           'building_type': builder.spec['name'],
                                                                           'trigger_level': get_leveled_quantity(gamedata['units'][spec_name]['requires_factory_level']||0, unlock_level),
                                                                           'obj_id': builder.id}));
                        if(helper) {
                            helper();
                        } else {
                            var err = gamedata['errors']['FACTORY_LEVEL_TOO_LOW'];
                            var builder_name = builder.spec['ui_name'];
                            invoke_child_message_dialog(err['ui_title'].replace('%s', builder_name),
                                                        err['ui_help'].replace('%s', builder_name).replace('%d', get_leveled_quantity(gamedata['units'][spec_name]['requires_factory_level']||0, unlock_level).toString()),
                                                        {'dialog':'message_dialog_big'});
                        }
                    } else if(not_enough_res) {
                        var helper = get_requirements_help('resources', resources_needed, {continuation:send_command});
                        if(helper) {
                            helper();
                        }
                    } else {
                        send_command();
                        return false; // do not stop the dripper
                    }

                } else {
                    var helper = manufacture_dialog_unlock_helper(dialog.user_data['category'], spec_name, 'closure:builder'+(builder?'1':'0')+'unlock_level'+unlock_level.toString());
                    if(helper) { helper(); }
                }

                // all paths that do not end in send_command() should return true to stop the dripper, since it indicates some problem that must be solved.
                return true;
            };
        })(name, widget_name);
        widget.onclick = closure;

        if(!gamedata['client']['unit_manufacture_dripper']) {
            widget.dripper_cb = null; // disable dripper behavior
        }

        var qty_current = (name in unit_count ? unit_count[name] : 0);
        var qty_queued = (name in queue_count ? queue_count[name] : 0);

        widget.state = ((builder &&
                         unit_unlock_level(name) > 0 &&
                         builder.level >= get_leveled_quantity(gamedata['units'][name]['requires_factory_level']||0, unit_unlock_level(name))) ||
                        player.is_cheater) ? (asset_is_3d ? 'icon' : 'normal') : (asset_is_3d ? 'icon_disabled' : 'disabled_clickable');

        if((builder && unit_unlock_level(name) > 0) || qty_current + qty_queued > 0 || player.is_cheater) {
            var str = qty_current.toString();
            if(qty_queued > 0) {
                str += ' (+' + qty_queued.toString()+')';
            }
            dialog.widgets['grid_qty'+widget_name].str = str;
            dialog.widgets['sunken_grid_label'+widget_name].show = true;
        } else {
            dialog.widgets['grid_qty'+widget_name].str = dialog.data['widgets']['grid_qty']['ui_name_locked']; // '';
        }

        grid_x += 1;
        if(grid_x >= dialog.data['widgets']['grid']['array'][0]) {
            grid_x = 0; grid_y += 1;
        }
    }

    // empty out remaining grid cells
    while(grid_y < dialog.data['widgets']['grid']['array'][1]) {
        var widget_name = grid_x.toString()+','+grid_y.toString();
        dialog.widgets['grid'+widget_name].show =
            dialog.widgets['grid_qty'+widget_name].show =
            dialog.widgets['sunken_grid_bg'+widget_name].show =
            dialog.widgets['sunken_grid'+widget_name].show =
            dialog.widgets['sunken_grid_label'+widget_name].show = false;
        grid_x += 1;
        if(grid_x >= dialog.data['widgets']['grid']['array'][0]) {
            grid_x = 0; grid_y += 1;
        }
    }

    // fill in current production item
    dialog.widgets['in_production_icon'].show =
        dialog.widgets['in_production_time'].show =
        dialog.widgets['in_production_progress'].show =
        dialog.widgets['in_production_cancel'].show = (builder && manuf_queue.length > 0);
    dialog.widgets['in_production_level'].show = false;

    if(builder && manuf_queue.length > 0) {
        var item = manuf_queue[0];
        dialog.widgets['in_production_icon'].bg_image = get_leveled_quantity(gamedata['units'][item['spec_name']]['art_asset'], item['level']);
        dialog.widgets['in_production_icon'].alpha = (gamedata['units'][item['spec_name']]['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1);

        var time_left = item['total_time'] - builder.manuf_done_time;
        if(builder.manuf_start_time > 0) {
            time_left -= (server_time - builder.manuf_start_time);
        }
        if(session.enable_progress_timers) {
            dialog.widgets['in_production_time'].str = pretty_print_time(time_left);
        } else {
            // conceal the true time, for tutorial purposes
            dialog.widgets['in_production_time'].str = dialog.data['widgets']['in_production_time']['ui_name_working'];
        }

        var progress = 1 - time_left/item['total_time'];

        dialog.widgets['in_production_progress'].progress = progress;
        dialog.widgets['in_production_cancel'].onclick = (function(b,x,n) { return function() {
            cancel_manuf_item(b,x,n); }; })(builder, 0, item['spec_name']);
        dialog.widgets['in_production_cancel'].state = 'normal';

        if('level' in item &&
           ('update_unit_levels_on_tech_upgrade' in gamedata) &&
           !gamedata['update_unit_levels_on_tech_upgrade']) {
            dialog.widgets['in_production_level'].show = true;
            dialog.widgets['in_production_level'].str = dialog.data['widgets']['in_production_level']['ui_name'].replace('%d', pretty_print_number(item['level']));
        }
    }

    // fill in production queue display
    for(var box = 0; box < 4; box++) {
        dialog.widgets['queue'+box.toString()].show =
            dialog.widgets['queue_counter_bg'+box.toString()].show =
            dialog.widgets['queue_counter'+box.toString()].show =
            dialog.widgets['queue_level'+box.toString()].show =
            dialog.widgets['queue_cancel'+box.toString()].show = false;
    }

    var box = -1;
    var kind = null;
    var last_level = -1;
    var counters = [0,0,0,0];
    if(builder) {
        for(var i = 1; i < manuf_queue.length; i++) {
            var item = manuf_queue[i];
            if(item['spec_name'] != kind || (item['level']||-1) != last_level) {
                // start a new box
                box += 1;
                if(box >= 4) {
                    // ran out of boxes
                    break;
                }
                kind = item['spec_name'];
                last_level = item['level'] || -1;
                dialog.widgets['queue'+box.toString()].show = true;
                dialog.widgets['queue'+box.toString()].bg_image = get_leveled_quantity(gamedata['units'][kind]['art_asset'], item['level']);
                dialog.widgets['queue'+box.toString()].alpha = (gamedata['units'][kind]['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1);
                dialog.widgets['queue_counter_bg'+box.toString()].show = true;
                dialog.widgets['queue_counter'+box.toString()].show = true;
                dialog.widgets['queue_cancel'+box.toString()].show = true;
                dialog.widgets['queue_cancel'+box.toString()].state = 'normal';
                dialog.widgets['queue_cancel'+box.toString()].onclick = (function(b,x,n) { return function() { cancel_manuf_item(b,x,n); }; })(builder, i, kind);


                if('level' in item &&
                   ('update_unit_levels_on_tech_upgrade' in gamedata) &&
                   !gamedata['update_unit_levels_on_tech_upgrade']) {
                    dialog.widgets['queue_level'+box.toString()].show = true;
                    dialog.widgets['queue_level'+box.toString()].str = dialog.data['widgets']['queue_level']['ui_name'].replace('%d', pretty_print_number(item['level']));
                }

                counters[box] = 1;
            } else {
                counters[box] += 1;
            }
        }
    }

    for(var b = 0; b < 4; b++) {
        dialog.widgets['queue_counter'+b.toString()].str = counters[b].toString();
    }

    // fill in price display and "finish" button callback
    var closure;
    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].tooltip.str = '';
    dialog.widgets['price_spinner'].show = (builder && !builder.is_in_sync());

    if(!player.unit_speedups_enabled()) {
        dialog.widgets['finish_button'].show = dialog.widgets['price_display'].show = false;
    } else {
        if(builder && !builder.is_in_sync()) {
            dialog.widgets['price_display'].str = '';
            closure = null;
            dialog.widgets['price_display'].onclick = null;
            dialog.widgets['finish_button'].state = 'disabled';
            dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name_pending'];
            dialog.widgets['price_display'].tooltip.str = dialog.widgets['finish_button'].tooltip.str = '';
        } else if(!builder || manuf_queue.length < 1 || !session.enable_dialog_completion_buttons) {
            dialog.widgets['price_display'].str = '';
            closure = null;
            dialog.widgets['price_display'].onclick = null;
            dialog.widgets['finish_button'].state = 'disabled';
            dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'];
            dialog.widgets['price_display'].tooltip.str = dialog.widgets['finish_button'].tooltip.str = '';
        } else {
            // note: SPEEDUP_FOR_MONEY will repair the factory rather than speed up production if factory is damaged
            dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'+(builder.is_damaged() ? '_repair' : '')];
            dialog.widgets['finish_button'].state = 'normal';

            var price = Store.get_user_currency_price(builder.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null);
            if(session.enable_progress_timers) {
                dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
                dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);
            } else {
                // conceal for tutorial purposes
                dialog.widgets['price_display'].str = dialog.widgets['price_display'].tooltip.str = '';
            }

            if(price == 0) {
                closure = (function(_builder) { return function() {
                    //if(selection.ui.widgets['coverup_queue'].show) { return; } // ???
                    send_to_server.func(["CAST_SPELL", _builder.id, "SPEEDUP_FOR_FREE"]);
                    invoke_ui_locker(_builder.request_sync(), function() { change_selection(null); });
                }; })(builder);
            } else if(price > 0) {
                closure = (function(_builder) { return function() {
                    var dialog = selection.ui;
                    //if(dialog.widgets['coverup_queue'].show) { return; }
                    var cleanup_cb = (function (_dialog) { return function() {
                    }; })(dialog);

                    if(Store.place_user_currency_order(_builder.id, "SPEEDUP_FOR_MONEY", null, cleanup_cb)) {
                        invoke_ui_locker(_builder.request_sync(), function() { change_selection(null); });
                    }
                };})(builder);
            } else {
                // invalid order?
                if(builder.is_damaged() && !builder.is_repairing()) {
                    closure = (function (obj) { return function() {
                        change_selection(obj); invoke_repair_dialog();
                    }; })(builder);
                } else {
                    closure = null;
                    dialog.widgets['finish_button'].state = 'disabled';
                }
            }
        }

        dialog.widgets['price_display'].onclick =
            dialog.widgets['finish_button'].onclick = closure;
    } // END unit speedups available

    // fill in capacity display
    var space_usage = player.get_army_space_usage_by_squad();
    var total_capacity = player.stattab['total_space'];

    var used_capacity = space_usage['ALL'];
    var available_space = total_capacity - used_capacity;
    if(!player.squads_enabled() || !gamedata['produce_to_reserves']) {
        available_space = Math.min(available_space, player.stattab['main_squad_space'] - space_usage[SQUAD_IDS.BASE_DEFENDERS.toString()]);
    }
    dialog.widgets['capacity_bar'].progress = used_capacity/Math.max(1, total_capacity);
    dialog.widgets['capacity_label'].str = dialog.widgets['capacity_label'].data['ui_name'].replace('%s',used_capacity.toString() + '/' + total_capacity.toString());

    var overflow = false;
    var squads_enabled = player.squads_enabled();
    var queue_usage = 0;
    if(squads_enabled && gamedata['produce_to_reserves'] && manuf_queue) {
        // check if we're in an overflow situation
        for(var i = 0; i < manuf_queue.length; i++) {
            var item = manuf_queue[i];
            queue_usage += get_leveled_quantity(gamedata['units'][item['spec_name']]['consumes_space'], item['level']||1);
        }
        //if(dialog.user_data['current_unit']) { queue_usage += get_leveled_quantity(gamedata['units'][dialog.user_data['current_unit']]['consumes_space'], unit_unlock_level(dialog.user_data['current_unit'])||1); }
        if(space_usage[SQUAD_IDS.BASE_DEFENDERS.toString()] + queue_usage > player.stattab['main_squad_space']) {
            overflow = true;
        }
    }
    dialog.widgets['robot_in_production'].show = dialog.widgets['production_queue'].show = !squads_enabled || (queue_usage == 0);
    dialog.widgets['producing_to_base_defenders'].show = squads_enabled && queue_usage > 0 && !overflow;
    dialog.widgets['overflow_to_reserves'].show = squads_enabled && queue_usage > 0 && overflow;

    dialog.widgets['robot_in_production'].str = gamedata['spells']['MAKE_DROIDS']['ui_unit_in_progress'];
    dialog.widgets['producing_to_base_defenders'].str = gamedata['spells']['MAKE_DROIDS']['ui_to_base_defenders'];
    dialog.widgets['overflow_to_reserves'].str = gamedata['spells']['MAKE_DROIDS']['ui_to_reserves'];

    if(dialog.widgets['production_queue'].show) {
        var togo = (builder && !builder.is_damaged() && builder.is_manufacturing() ? builder.time_until_finish() : -1);
        if(togo > 0) {
            dialog.widgets['production_queue'].str =  dialog.data['widgets']['production_queue']['ui_name_togo'].replace('%s', pretty_print_time_brief(togo));
        } else {
            dialog.widgets['production_queue'].str = gamedata['spells']['MAKE_DROIDS']['ui_queue'];
        }
    }
    // update build requirements text
    if(dialog.user_data['current_unit']) {
        var spec = gamedata['units'][dialog.user_data['current_unit']];
        var level = unit_unlock_level(dialog.user_data['current_unit']);
        if(level < 1) { level = 1; }

        var cost = mobile_cost_to_repair(spec, level, 0, 1, player, COST_MODE.MANUFACTURE, builder);
        for(var res in gamedata['resources']) {
            if('requirements_'+res+'_value' in dialog.widgets) {
                if(cost[res] > 0) {
                    dialog.widgets['requirements_'+res+'_value'].show =
                        dialog.widgets['requirements_'+res+'_icon'].show = true;
                    dialog.widgets['requirements_'+res+'_value'].str = pretty_print_number(cost[res]);
                    dialog.widgets['requirements_'+res+'_value'].tooltip.str = dialog.data['widgets']['requirements_'+res+'_value']['ui_tooltip'].replace('%RES', gamedata['resources'][res]['ui_name']).replace('%VERB', gamedata['spells']['MAKE_DROIDS']['ui_name'].toLowerCase());
                    dialog.widgets['requirements_'+res+'_value'].text_color = (player.resource_state[res][1] >= cost[res] ? SPUI.good_text_color : SPUI.error_text_color);
                    // don't show button for topup, since the main "Use Resources" button will take care of it
                    if(!gamedata['resources'][res]['allow_topup'] && player.resource_state[res][1] < cost[res]) {
                        var helper = get_requirements_help(res, cost[res] - player.resource_state[res][1]);
                        dialog.widgets['resource_'+res+'_button'].show = !!helper;
                        dialog.widgets['resource_'+res+'_button'].onclick = helper;
                    } else {
                        dialog.widgets['resource_'+res+'_button'].show = false;
                    }
                } else {
                    dialog.widgets['requirements_'+res+'_value'].show =
                        dialog.widgets['requirements_'+res+'_icon'].show =
                        dialog.widgets['resource_'+res+'_button'].show = false;
                }
            }
        }

        var cost_space = get_leveled_quantity(spec['consumes_space'], level);
        dialog.widgets['requirements_space_value'].show =
            dialog.widgets['requirements_space_icon'].show = (cost_space > 0);
        if(cost_space > 0) {
            dialog.widgets['requirements_space_value'].str = pretty_print_number(cost_space);
            dialog.widgets['requirements_space_value'].tooltip.str = dialog.data['widgets']['requirements_space_value']['ui_tooltip'].replace('%TOTAL_SPACE_BUILDING', gamedata['buildings'][total_space_building()]['ui_name']);
            dialog.widgets['requirements_space_value'].text_color = (available_space >= cost_space ? SPUI.good_text_color : SPUI.error_text_color);
            if(available_space < cost_space) {
                var helper = get_requirements_help('unit_space', cost_space - available_space);
                dialog.widgets['resource_space_button'].show = !!helper;
                dialog.widgets['resource_space_button'].onclick = helper;
            } else {
                dialog.widgets['resource_space_button'].show = false;
            }
        } else {
            dialog.widgets['resource_space_button'].show = false;
        }

        var cost_time = cost['time'];

        dialog.widgets['requirements_time_value'].str = pretty_print_time(cost_time);
        dialog.widgets['requirements_time_value'].tooltip.str = dialog.data['widgets']['requirements_time_value']['ui_tooltip'].replace('%VERB', gamedata['spells']['MAKE_DROIDS']['ui_name'].toLowerCase());
    }
}

// (inefficiently) find a particular object by its type and return a reference to it
// (or null if not found)
function find_object_by_type(specname) {
    return session.for_each_real_object(function(obj) {
        if(obj.spec['name'] === specname) {
            return obj;
        }
    });
}

function find_all_objects_by_type(specname) {
    var ret = [];
    session.for_each_real_object(function(obj) {
        if(obj.spec['name'] === specname) {
            ret.push(obj);
        }
    });
    return ret;
}

function find_highest_level_object_by_type(specname) {
    var obj = null;
    session.for_each_real_object(function(o) {
        if(o.spec['name'] === specname) {
            if(!obj || o.level > obj.level) {
                obj = o;
            }
        }
    });
    return obj;
}
function count_objects_by_type(specname) {
    var count = 0;
    session.for_each_real_object(function(obj) {
        if(obj.spec['name'] === specname) {
            count += 1;
        }
    });
    return count;
}
function find_object_with_spell(spellname) {
    return session.for_each_real_object(function(obj) {
        if(obj.spec['spells']) {
            for(var i = 0; i < obj.spec['spells'].length; i++) {
                if(obj.spec['spells'][i] === spellname) {
                    return obj;
                }
            }
        }
    });
}

/** @param {string} category */
function invoke_crafting_table_of_contents_dialog(category) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['crafting_table_of_contents_dialog']);
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'crafting_table_of_contents_dialog';
    dialog.user_data['category'] = category;
    dialog.widgets['close_button'].onclick = function() { change_selection(null); };

    init_army_dialog_buttons(dialog.widgets['army_dialog_buttons_crafting'], (category in ARMY_DIALOG_BUTTONS ? category : 'crafting'), 'crafting_table_of_contents_dialog');

    var builder_type = get_workshop_for(category);
    var builder = find_object_by_type(builder_type);

    dialog.widgets['title'].str = gamedata['buildings'][builder_type]['ui_name'];
    var catspec = gamedata['crafting']['categories'][category];

    dialog.widgets['category_name'].str = catspec['ui_name'];
    // clicking the breadcrumb should function as an "escape hatch" back to the master crafting_dialog for this building
    dialog.widgets['category_name'].onclick = (function (_builder) { return function(w) {
        var builder_cats = _builder.spec['crafting_categories'];
            goog.array.forEach(_builder.spec['crafting_categories'], function(cat) {
                if(cat && Array.isArray(cat)){
                    builder_cats = _builder.get_leveled_quantity(_builder.spec['crafting_categories']);
                }
            }, _builder);
        if(_builder && _builder.spec['crafting_categories'] && builder_cats) {
            var cat = builder_cats[0];
            var catspec = gamedata['crafting']['categories'][cat];
            change_selection_ui(null);
            if(catspec['table_of_contents']) {
                invoke_crafting_table_of_contents_dialog(cat);
            } else {
                invoke_crafting_dialog(cat);
            }
        }
    }; })(builder);

    dialog.user_data['rowdata'] = []; // for now, "crafting subcategories" are just the names of item sets
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;

    dialog.widgets['coverup_all'].show =
        dialog.widgets['coverup_text'].show =
        dialog.widgets['coverup_icon'].show =
        dialog.widgets['coverup_button'].show = (!builder && !player.is_cheater);

    if(!builder && !player.is_cheater) {
        // workshop not present
        dialog.widgets['coverup_text'].str = dialog.data['widgets']['coverup_text']['ui_name'].replace('%s1', catspec['ui_name']).replace('%verb', catspec['ui_verb']).replace('%s2', gamedata['buildings'][builder_type]['ui_name_indefinite']);
        dialog.widgets['coverup_icon'].asset = get_leveled_quantity(gamedata['buildings'][builder_type]['art_asset'], 1);
        // special-case because some buildings are really tall
        dialog.widgets['coverup_icon'].xy = vec_add(dialog.data['widgets']['coverup_icon']['xy'], (gamedata['buildings'][builder_type]['hero_icon_pos'] || [0,0]));
        var helper = get_requirements_help(read_predicate({'predicate':'BUILDING_QUANTITY', 'building_type':builder_type, 'trigger_qty':1}), null, {short_circuit:true});
        dialog.widgets['coverup_button'].onclick = (helper ? helper : function() { invoke_build_dialog('production'); });
    } else {
        // construct recipe list
        for(var name in gamedata['crafting']['recipes']) {
            var spec = gamedata['crafting']['recipes'][name];
            if(spec['crafting_category'] != category) { continue; }
            if(!('associated_item_set' in spec)) { continue; }
            if(spec['developer_only'] && (spin_secure_mode || !player.is_developer())) { continue; }
            if('show_if' in spec && !read_predicate(spec['show_if']).is_satisfied(player, null)) { continue; }
            if('activation' in spec && !read_predicate(spec['activation']).is_satisfied(player, null)) { continue; }
            if(goog.array.contains(dialog.user_data['rowdata'], spec['associated_item_set'])) { continue; }
            dialog.user_data['rowdata'].push(spec['associated_item_set']);
        }
    }
    dialog.user_data['rowfunc'] = crafting_subcategory_setup_row;
    dialog.user_data['roworder'] = 'left_right_top_bottom';
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['subcategory']['array'][1];
    dialog.user_data['cols_per_page'] = dialog.data['widgets']['subcategory']['array'][0];
    scrollable_dialog_change_page(dialog, 0);
}

/** @param {SPUI.Dialog} dialog
    @param {number} row_col
    @param {string} rowdata */
function crafting_subcategory_setup_row(dialog, row_col, rowdata) {
    var wname = SPUI.get_array_widget_name('subcategory', dialog.data['widgets']['subcategory']['array'], row_col);
    dialog.widgets[wname].show = !!rowdata;
    if(!rowdata) { return; }
    var set_spec = gamedata['item_sets'][rowdata];
    dialog.widgets[wname].widgets['icon'].asset = set_spec['icon'];
    dialog.widgets[wname].widgets['name'].str = set_spec['ui_name'];
    dialog.widgets[wname].widgets['description'].set_text_with_linebreaking(set_spec['ui_description']);
    dialog.widgets[wname].widgets['frame'].onclick = (function (_setname) { return function(w) {
        invoke_crafting_dialog(dialog.user_data['category'], _setname);
    }; })(rowdata);
}

/** @param {string} newcategory
    @param {string|null=} newsubcategory
    @param {number=} newpage */
function invoke_crafting_dialog(newcategory, newsubcategory, newpage) {
    if ((newcategory in gamedata['crafting']['categories']) && ('dialog' in gamedata['crafting']['categories'][newcategory])){
        // there should be no UI path for any crafting category that has its own custom crafting interface to reach this code
        // in the event of undetected UI pathin, this checks if the category passed has its own custom crafting interface
        // (defined in crafting.json under categories/dialog) and exits the function if it does
        return;
    }
    var dialog = new SPUI.Dialog(gamedata['dialogs']['crafting_dialog']);
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'crafting_dialog';
    dialog.user_data['category'] = newcategory;
    dialog.user_data['subcategory'] = newsubcategory || null;
    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    dialog.widgets['dev_title'].show = player.is_cheater;

    init_army_dialog_buttons(dialog.widgets['army_dialog_buttons_crafting'], (newcategory in ARMY_DIALOG_BUTTONS ? newcategory : 'crafting'), 'crafting_dialog');

    var catspec = gamedata['crafting']['categories'][newcategory];
    dialog.user_data['categories'] = [];

    if(catspec['table_of_contents']) {
        // for table-of-contents categories, don't show category buttons, just show a backlink to the table of contents
        if(!newsubcategory) {
            throw Error('crafting category '+newcategory+' has a table_of_contents and so requires a subcategory parameter');
        }
        var subcategory_spec = gamedata['item_sets'][newsubcategory];
        dialog.widgets['subcategory_name'].set_text_bbcode('[color=#'+SPUI.disabled_text_color.hex()+']'+catspec['ui_name'] + '  >[/color]  ' + subcategory_spec['ui_name']);
        dialog.widgets['subcategory_name'].onclick = (function (_catspec) { return function(w) {
            change_selection_ui(null);
            invoke_crafting_table_of_contents_dialog(_catspec['name']); // XXX this should preselect (scroll to) newsubcategory
        }; })(catspec);
    } else {
        // set up category buttons
        goog.object.forEach(gamedata['crafting']['categories'], function(entry, name) {
            if('dialog' in entry && entry['dialog'] != 'crafting_dialog') { return; } // do not display
            if('category_group' in entry && !goog.array.contains(entry['category_group'], newcategory)) { return; } // do not display
            if('show_if' in entry && !read_predicate(entry['show_if']).is_satisfied(player, null)) { return; } // hidden

            dialog.user_data['categories'].push(entry);
            if(dialog.user_data['categories'].length >= dialog.data['widgets']['category_button']['array'][0]) { throw Error('not enough category_button array entries!'); }
        });
    }

    dialog.widgets['scroll_left'].widgets['scroll_left'].onclick = function(w) { var dialog = w.parent.parent; dialog.user_data['scrolled'] = true; crafting_dialog_scroll(dialog, dialog.user_data['page']-1); };
    dialog.widgets['scroll_right'].widgets['scroll_right'].onclick = function(w) { var dialog = w.parent.parent; dialog.user_data['scrolled'] = true; crafting_dialog_scroll(dialog, dialog.user_data['page']+1); };

    dialog.ondraw = update_crafting_dialog;
    dialog.on_mousewheel_function = crafting_dialog_mousewheel;

    // listen for inventory updates, because they affect the crafting recipe list
    dialog.user_data['inventory_update_receiver'] = (function (_dialog) { return function() {
        // run change_category() to update the recipe list, but try to return to the same page
        var old_rec = _dialog.user_data['selected_recipe'];
        crafting_dialog_change_category(_dialog, _dialog.user_data['category'], _dialog.user_data['page']);
        if(old_rec) {
            var new_rec = goog.array.find(_dialog.user_data['recipes'], function(rec) {
                return rec['spec'] === old_rec['spec']; // note: match regardless of level
            });
            if(new_rec) {
                crafting_dialog_select_recipe(_dialog.widgets['recipe'], new_rec);
            }
        }
    }; })(dialog);
    inventory_update_receivers.push(dialog.user_data['inventory_update_receiver']);
    dialog.on_destroy = function(dialog) { goog.array.remove(inventory_update_receivers, dialog.user_data['inventory_update_receiver']); };

    crafting_dialog_change_category(dialog, newcategory, newpage || 0);
    return dialog;
}

/** @param {SPUI.Dialog} dialog
    @param {string} category
    @param {number=} page */
function crafting_dialog_change_category(dialog, category, page) {
    if ((category in gamedata['crafting']['categories']) && ('dialog' in gamedata['crafting']['categories'][category])){
        // there should be no UI path for any crafting category that has its own custom crafting interface to reach this code
        // in the event of undetected UI pathin, this checks if the category passed has its own custom crafting interface
        // (defined in crafting.json under categories/dialog) and exits the function if it does
        return;
    }
    dialog.user_data['category'] = category;
    dialog.user_data['recipes'] = null;
    dialog.user_data['selected_recipe'] = null;
    dialog.user_data['on_use_recipe'] = null;
    dialog.user_data['scrolled'] = false;
    dialog.user_data['open_time'] = client_time;
    // special case for mines and ambushes, there is only one column of recipes
    dialog.user_data['recipe_columns'] = ((category == 'mines' || category == 'ambushes') ? 1 : dialog.data['widgets']['recipe_icon']['array'][0]);

    // center scroll arrows relative to recipe icons
    goog.array.forEach(['scroll_left', 'scroll_right'], function(wname) {
        dialog.widgets[wname].xy[0] = Math.floor(dialog.data['widgets'][wname]['xy'][0] + (dialog.user_data['recipe_columns'] - 1)/2 * dialog.data['widgets']['recipe_icon']['array_offset'][0]);
    });

    var category_ui_name = gamedata['crafting']['categories'][category]['ui_name'];
    var category_ui_verb = gamedata['crafting']['categories'][category]['ui_verb'];

    var cats = dialog.user_data['categories'];
    for(var i = 0; i < dialog.data['widgets']['category_button']['array'][0]; i++) {
        dialog.widgets['category_button'+i.toString()].show = (i < cats.length);
        if(i < cats.length) {
            var entry = cats[i];
            // manually compute X coordinate to center all the visible buttons
            var x = Math.floor(dialog.wh[0]/2 + (i - cats.length/2) * dialog.data['widgets']['category_button']['array_offset'][0] + dialog.data['widgets']['category_button']['xy'][0]);
            dialog.widgets['category_button'+i.toString()].xy = [x, dialog.data['widgets']['category_button']['xy'][1]];
            dialog.widgets['category_button'+i.toString()].str = entry['ui_name'];
            dialog.widgets['category_button'+i.toString()].text_color = (category === entry['name'] ? SPUI.default_text_color : SPUI.disabled_text_color);
            dialog.widgets['category_button'+i.toString()].state = (category === entry['name'] ? 'active' : 'normal');
            if(entry['table_of_contents']) {
                dialog.widgets['category_button'+i.toString()].onclick = (function (_entry) { return function(w) {
                    change_selection_ui(null);
                    invoke_crafting_table_of_contents_dialog(_entry['name']);
                }; })(entry);
            } else {
                dialog.widgets['category_button'+i.toString()].onclick = (function (_entry) { return function(w) {
                    crafting_dialog_change_category(w.parent, _entry['name']);
                }; })(entry);
            }
        }
    }

    var builder_type = get_workshop_for(category);

    dialog.widgets['title'].str = gamedata['buildings'][builder_type]['ui_name'];

    // check for presence of appropriate workshop
    var builder = find_object_by_type(builder_type);
    dialog.user_data['builder'] = builder;

    dialog.widgets['coverup_all'].show =
        dialog.widgets['coverup_text'].show =
        dialog.widgets['coverup_icon'].show =
        dialog.widgets['coverup_button'].show = (!builder && !player.is_cheater);

    var preselect = null;

    if(!builder && !player.is_cheater) {
        // workshop not present
        dialog.widgets['btmbar'].show =
            dialog.widgets['price_display'].show =
            dialog.widgets['finish_button'].show = false;
        dialog.widgets['coverup_text'].str = dialog.data['widgets']['coverup_text']['ui_name'].replace('%s1', category_ui_name).replace('%verb', category_ui_verb).replace('%s2', gamedata['buildings'][builder_type]['ui_name_indefinite']);
        dialog.widgets['coverup_icon'].asset = get_leveled_quantity(gamedata['buildings'][builder_type]['art_asset'], 1);
        // special-case because some buildings are really tall
        dialog.widgets['coverup_icon'].xy = vec_add(dialog.data['widgets']['coverup_icon']['xy'], (gamedata['buildings'][builder_type]['hero_icon_pos'] || [0,0]));
        var helper = get_requirements_help(read_predicate({'predicate':'BUILDING_QUANTITY', 'building_type':builder_type, 'trigger_qty':1}), null, {short_circuit:true});
        dialog.widgets['coverup_button'].onclick = (helper ? helper : function() { invoke_build_dialog('production'); });

    } else {
        refresh_crafting_dialog_recipes(dialog);
        if(dialog.user_data['recipes'].length > 0) {
            preselect = dialog.user_data['recipes'][0];
        }
    }

    goog.array.forEach(['recipe','status'], function(wname) {
        if(wname in dialog.widgets) {
            dialog.remove(dialog.widgets[wname]);
            delete dialog.widgets[wname];
        }
        var dialog_name = 'crafting_dialog_'+wname+'_';
        if(category == 'mines' || category == 'ambushes') {
            dialog_name = dialog_name + 'grid_weapons';
        } else {
            dialog_name = dialog_name + category;
        }
        if(!(dialog_name in gamedata['dialogs'])) {
            throw Error('missing dialog: '+dialog_name);
        }
        var w = new SPUI.Dialog(gamedata['dialogs'][dialog_name]);
        dialog.add(w);
        w.xy = w.data['xy'];
        dialog.widgets[wname] = w;
    });

    if(category == 'mines' || category == 'ambushes') {
        crafting_dialog_init_status_grid_weapons(dialog.widgets['status']);
    } else if(category == 'leaders' || category == 'equips') {
        crafting_dialog_init_status_merge_items(dialog.widgets['status']);
    } else if(category == 'missiles') {
        crafting_dialog_init_status_missiles(dialog.widgets['status']);
    } else {
        throw Error('unhandled category '+category);
    }

    if(player.upgrade_bar_enabled()) {
        UpgradeBar.invoke(dialog, 'building', (builder ? builder.spec['name'] : null), (builder ? builder.level+1 : -1), (builder ? builder.id : null));
    }

    crafting_dialog_scroll(dialog, page || 0);

    if(dialog.user_data['page'] == 0) {
        // select first buildable recipe
        crafting_dialog_select_recipe(dialog.widgets['recipe'], preselect);
    }
}

/** @param {SPUI.Element} dialog */
function refresh_crafting_dialog_recipes(dialog) {
    var category, preselect;
    category = dialog.user_data['category'];
    preselect = dialog.user_data['selected_recipe'];
    dialog.user_data['recipes'] = [];
    for(var name in gamedata['crafting']['recipes']) {
        var spec = gamedata['crafting']['recipes'][name];
        if(spec['crafting_category'] != category) { continue; }

        // subcategory/associated_item_set mismatch
        if(dialog.user_data['subcategory'] && (dialog.user_data['subcategory'] != spec['associated_item_set'])) { continue; }
        if(spec['developer_only'] && (spin_secure_mode || !player.is_developer())) { continue; }
        if('show_if' in spec && !read_predicate(spec['show_if']).is_satisfied(player, null)) { continue; }
        if('activation' in spec && !read_predicate(spec['activation']).is_satisfied(player, null)) { continue; }

        if((spec['max_level'] || 1) > 1) {
            if (spec['associated_tech'] && player.tech[spec['associated_tech']]) {
                    var rec = {'spec': name, 'level': player.tech[spec['associated_tech']]};
                    dialog.user_data['recipes'].push(rec);
                    if(!preselect) { preselect = rec; }
            } else if(spec['associated_item']) {
                // this recipe upgrades an existing item. Show only if the item is available in inventory.
                var seen_levels = {};
                player.stored_item_iter(function (entry) {
                    if(entry['spec'] === spec['associated_item']) {
                        var existing_level = entry['level'] || 1;
                        if(existing_level < spec['max_level'] &&
                           get_leveled_quantity(spec['cost'], existing_level + 1) !== null &&
                           !(existing_level.toString() in seen_levels)) {
                            // item not already maxed, we can upgrade it
                            seen_levels[existing_level.toString()] = 1; // mark seen
                            var rec_this_level = {'spec': name, 'level': existing_level + 1}
                            dialog.user_data['recipes'].push(rec_this_level);
                            if(!preselect) { preselect = rec_this_level; }
                        }
                    }
                });
            } else {
                throw Error('leveled crafting recipe without associated_item');
            }
        } else {
            var rec = {'spec': name};
            dialog.user_data['recipes'].push(rec);
            if(!preselect) { preselect = rec; }
        }
    }
    if(dialog.user_data['page'] == 0 && preselect) {
        // select first buildable recipe
        crafting_dialog_select_recipe(dialog.widgets['recipe'], preselect);
    }
}

/** @param {string} grid_type */
// this gets the maximum count for buildings that use the "grid" crafting system, minefields and ambush points
// it returns an integer used to determine how many row labels are needed by the crafting UI.
function get_max_grid_weapons(grid_type) {
    var building_name_map = {'mines':'minefield', 'ambushes':'ambush_point'};
    if(!(grid_type in building_name_map)) { return 0; }
    var building_name = building_name_map[grid_type];
    if(!(building_name in gamedata['buildings'])) { return 0; }
    var spec = gamedata['buildings'][building_name];
    return spec['limit_requires'].length;
}

/** @param {string} grid_type */
// this gets the current count for buildings that use the "grid" crafting system, minefields and ambush points
// it returns an integer used to determine how many rows are needed by the crafting UI.
function get_current_grid_weapons(grid_type) {
    var building_name_map = {'mines':'minefield', 'ambushes':'ambush_point'};
    if(!(grid_type in building_name_map)) { return 0; }
    var building_name = building_name_map[grid_type];
    if(!(building_name in gamedata['buildings'])) { return 0; }
    var count = 0;
    session.for_each_real_object(function(obj) {
        if(obj.is_building()){
            if(obj.is_minefield() && obj.team === 'player' && grid_type == 'mines') {
                count += 1;
            } else if (obj.is_ambush() && obj.team === 'player' && grid_type == 'ambushes') {
                count += 1;
            }
        }
    });
    return count;
}

/** @param {SPUI.Dialog} dialog */
function crafting_dialog_init_status_grid_weapons(dialog) {
    dialog.user_data['category'] = dialog.parent.user_data['category'];
    dialog.user_data['page'] = 0;
    var max_grid_weapons = (dialog.parent.user_data['builder'] ? get_max_grid_weapons(dialog.user_data['category']) : 0);
    var dims = dialog.data['widgets']['grid_slot']['array'];
    for(var row = 0; row < dims[1]; row++) {
        dialog.widgets['row_labels' + row.toString()].str = (1 + row).toString();
        dialog.widgets['row_labels' + row.toString()].show = (row * dims[0]) < max_grid_weapons;
    }
    for(var col = 0; col < dims[0]; col++) {
        dialog.widgets['col_labels' + col.toString()].show = (max_grid_weapons > col);
        dialog.widgets['col_labels' + col.toString()].str = String.fromCharCode('A'.charCodeAt(0) + col);
    }
    dialog.on_mousewheel_function = scroll_crafting_dialog_status_grid_weapons;
}

/** @param {SPUI.Dialog} dialog
    @param {(!Array<number>)} row_col */
function crafting_dialog_status_grid_weapons_cell_setup(dialog, row_col) {
    var wname = SPUI.get_array_widget_name('', dialog.data['widgets']['grid_slot']['array'], row_col);
    var tag = dialog.widgets['col_labels' + row_col[0].toString()].str + dialog.widgets['row_labels' + row_col[1].toString()].str;
    var builder = dialog.parent.user_data['builder'];
    var category = dialog.parent.user_data['category'];
    var catspec = gamedata['crafting']['categories'][category];
    var selected_rec = dialog.parent.user_data['selected_recipe'];
    var selected_recipe = (selected_rec ? dialog.parent.user_data['selected_recipe']['spec'] : null);
    var selected_recipe_spec = (selected_recipe ? gamedata['crafting']['recipes'][selected_recipe] : null);
    var selected_grid_item = (selected_recipe_spec ? ItemDisplay.get_crafting_recipe_product_spec(selected_recipe_spec)['name'] : null);
    var selected_grid_spec = (selected_grid_item ? ItemDisplay.get_inventory_item_spec(selected_grid_item) : null);
    var selected_grid_item_level = (selected_grid_item ? player.tech[selected_grid_spec['associated_tech']] || 1 : null);
    var craft_queue = (builder ? builder.get_crafting_queue() : []);
    var rows_per_page = dialog.data['widgets']['grid_slot']['array'][1]
    var max_grid_weapons = (dialog.parent.user_data['builder'] ? get_max_grid_weapons(category) : 0);
    dialog.parent.user_data['on_use_recipe'] = null; // default action when clicking the recipe on the left
    var delivery_slot_type = catspec['delivery_slot_type'];
    var delivery_slot_index = 0;
    var multiple_delivery_slots;
    var pending = false;
    var grid_frame_tooltip = '';


    // set up default display, where minefield or ambush point does not exist
    dialog.widgets['grid_icon'+wname].show =
        dialog.widgets['grid_skull'+wname].show =
        dialog.widgets['grid_timer'+wname].show =
        dialog.widgets['grid_frame'+wname].show =
        dialog.widgets['grid_cancel'+wname].show =
        dialog.widgets['grid_pending'+wname].show = false;
    dialog.widgets['grid_slot'+wname].state = 'locked';

    // help to do what you need to do to unlock another slot
    var help_pred = null;
    var slot_building = gamedata['crafting']['categories'][category]['delivery_building_for_ui'];
    var slot_building_spec = gamedata['buildings'][slot_building];
    help_pred = {'predicate':'BUILDING_QUANTITY', 'building_type':slot_building, 'trigger_qty': count_objects_by_type(slot_building)+1};

    var helper = null;
    if(help_pred && dialog.widgets['grid_slot'+wname].show) {
        helper = function (use_short_circuit) { return function() {
            var h = get_requirements_help(read_predicate(/** @type {!Object} */ (help_pred)), null, {short_circuit:use_short_circuit});
            if(h) { h(); }
        }; };
    }
    dialog.widgets['grid_slot'+wname].onclick = (helper ? helper(true) : null);
    if(!dialog.parent.user_data['on_use_recipe']) {
        dialog.parent.user_data['on_use_recipe'] = (helper ? helper(false) : null);
    }

    var tag_map, obj, cur_item, cur_config, cur_config_level = null;
    if(category == 'mines') {
        tag_map = session.minefield_tags_by_tag;
    } else if (category == 'ambushes') {
        tag_map = session.ambush_point_tags_by_tag;
    } else {
        throw Error('Unhandled category in grid weapons: ' + category);
    }
    if((tag in tag_map) && (session.get_real_world().objects.has_object(tag_map[tag]))) {
        obj = session.get_real_world().objects.get_object(tag_map[tag]);
        cur_item = (obj.equipment && (delivery_slot_type in obj.equipment) && obj.equipment[delivery_slot_type].length > 0 && obj.equipment[delivery_slot_type][0] ? player.decode_equipped_item(obj.equipment[delivery_slot_type][0]) : null);
        cur_config = (obj.config && (delivery_slot_type in obj.config) && obj.config[delivery_slot_type] && (player.decode_equipped_item(obj.config[delivery_slot_type])['spec'] in gamedata['items']) ? player.decode_equipped_item(obj.config[delivery_slot_type])['spec'] : null);
        cur_config_level = ((obj.config && (delivery_slot_type in obj.config) && obj.config[delivery_slot_type] && (player.decode_equipped_item(obj.config[delivery_slot_type])['spec'] in gamedata['items']) ? player.decode_equipped_item(obj.config[delivery_slot_type])['level'] : null) || 1);
    }
    if(obj) {
        pending = !obj.is_in_sync();
        dialog.widgets['grid_slot'+wname].state = 'normal';
        var in_progress_recipe = null, in_progress_level = null, in_progress_bus = null, in_progress_togo = -1;
        for(var i = 0; i < craft_queue.length; i++) {
            var entry = craft_queue[i];
            if(entry['craft']['delivery'] && entry['craft']['delivery']['obj_id'] == obj.id &&
               (!('slot_type' in entry['craft']['delivery']) || entry['craft']['delivery']['slot_type'] == delivery_slot_type) &&
               ((entry['craft']['delivery']['slot_index'] || 0) == 0)) {
                in_progress_recipe = entry['craft']['recipe'];
                in_progress_level = (entry['craft']['level'] || 1);
                in_progress_bus = entry;
                in_progress_togo = entry['total_time'] - entry['done_time'];
                if(entry['start_time'] > 0) {
                    in_progress_togo -= Math.max(0, server_time - entry['start_time']);
                }
                break;
            }
        }
        dialog.widgets['grid_icon'+wname].show =
        dialog.widgets['grid_frame'+wname].show =
        dialog.widgets['grid_cancel'+wname].show = true;
        dialog.widgets['grid_icon'+wname].state = 'normal';
        dialog.widgets['grid_skull'+wname].show =
        dialog.widgets['grid_timer'+wname].show = false;
        dialog.widgets['grid_slot'+wname].show = false;

        var build_grid_item = cur_config || selected_grid_item || null;
        var build_recipe = null;
        if(build_grid_item) {
            if(build_grid_item == selected_grid_item) {
                build_recipe = selected_recipe;
            } else {
                // look up the recipe for a DIFFERENT grid item
                for(var n in gamedata['crafting']['recipes']) {
                    var rec = gamedata['crafting']['recipes'][n];
                    if(rec['crafting_category'] == category && ItemDisplay.get_crafting_recipe_product_spec(rec)['name'] == build_grid_item) {
                        build_recipe = n; break;
                    }
                }
            }
        }
        var build_recipe_spec = (build_recipe ? gamedata['crafting']['recipes'][build_recipe] : null);

        var build_cb = null;
        var build_error_ui_text = null;

        if(build_recipe_spec) {
            var build_recipe_max_level = (build_recipe_spec['max_level'] || 1);
            var build_recipe_associated_tech = (build_recipe_spec['associated_tech'] || false);
            var build_recipe_level = 1;
            if((build_recipe_max_level || 1) > 1 && build_recipe_associated_tech && player.tech[build_recipe_associated_tech]) {
                build_recipe_level = player.tech[build_recipe_associated_tech];
            }
            var can_cast = can_cast_spell_detailed(builder.id, 'CRAFT_FOR_FREE', [{'recipe': build_recipe_spec['name'], // XXX level
                                                                                   'delivery': {'obj_id':obj.id, 'slot_type':delivery_slot_type, 'slot_index': delivery_slot_index}}]);
            if (!!!can_cast[0]) {
                if('requires' in build_recipe_spec) {
                    grid_frame_tooltip = read_predicate(get_leveled_quantity(build_recipe_spec['requires'], build_recipe_level)).ui_describe(player);
                } else if (can_cast[1]) {
                    grid_frame_tooltip = can_cast[1];
                }
            }

            if(can_cast[0]) {
                // the real build function
                build_cb = (function (_builder, _build_recipe_spec, _obj, _delivery_slot_index, _build_recipe_level) { return function() {
                    var extra_params = {'delivery': {'obj_id':_obj.id, 'slot_type':delivery_slot_type, 'slot_index': _delivery_slot_index}, 'level': _build_recipe_level };
                    start_crafting(_builder, _build_recipe_spec, extra_params);
                    // play sound effect
                    GameArt.play_canned_sound('action_button_134px');
                    return true;
                }; })(builder, build_recipe_spec, obj, delivery_slot_index, build_recipe_level);
            } else {
                build_error_ui_text = can_cast[1];
                // get helper function
                if(can_cast[2]) {
                    helper = get_requirements_help(can_cast[2][0], can_cast[2][1], can_cast[2][2]);
                    build_cb = (helper ? (function (_helper) { return function() { _helper(); return false; }; })(helper) : null);
                }
            }
        }

        var unconfig_cb = (function (_obj, _delivery_slot_type, _delivery_slot_index, _multiple) { return function(w) {
            var new_config = (_obj.config ? goog.object.clone(_obj.config) : {});
            if(_multiple) {
                if(!new_config[_delivery_slot_type]) {
                    new_config[_delivery_slot_type] = [];
                }
                while(new_config[_delivery_slot_type].length < _delivery_slot_index) {
                    new_config[_delivery_slot_type].push(null);
                }
                new_config[_delivery_slot_type][_delivery_slot_index] = null;
            } else {
                if(_delivery_slot_type in new_config) { delete new_config[_delivery_slot_type]; }
                if(goog.object.getCount(new_config) <= 0) { new_config = null; }
            }
            send_to_server.func(["CAST_SPELL", _obj.id, "CONFIG_SET", new_config]);
            // client-side predict
            _obj.config = new_config;
            _obj.request_sync();
        }; })(obj, delivery_slot_type, delivery_slot_index, multiple_delivery_slots);

        if(cur_item) {
            var cur_grid_item_spec = ItemDisplay.get_inventory_item_spec(cur_item['spec']);
            var current_grid_item_recipe = ItemDisplay.get_inventory_item_crafting_recipe(cur_item['spec']);
            var cur_grid_item_level = cur_item['level'] || 1;
            dialog.widgets['grid_icon'+wname].alpha = 1;
            dialog.widgets['grid_icon'+wname].asset = get_leveled_quantity(cur_grid_item_spec['icon'], cur_grid_item_level);
            dialog.widgets['grid_frame'+wname].onclick = (function (_rec, _lvl) { return function(w) {
                crafting_dialog_select_recipe(w.parent.parent.widgets['recipe'], {'spec': _rec['name'], 'level': _lvl});
            }; })(current_grid_item_recipe, cur_grid_item_level);
            grid_frame_tooltip = dialog.data['widgets']['grid_frame']['ui_tooltip_armed'].replace('%s', cur_grid_item_spec['ui_name']);
            dialog.widgets['grid_cancel'+wname].show = !(('can_unequip' in cur_grid_item_spec) && !cur_grid_item_spec['can_unequip']);
            dialog.widgets['grid_cancel'+wname].tooltip.str = dialog.data['widgets']['grid_cancel']['ui_tooltip_discard'].replace('%s', cur_grid_item_spec['ui_name']);
            var scrolling_current_page = dialog.user_data['page'];
            dialog.widgets['grid_cancel'+wname].onclick = (function (_obj, _cur_item, _delivery_slot_type, _delivery_slot_index, _unconfig_cb, _scrolling_current_page) { return function(w) {
                send_to_server.func(["EQUIP_BUILDING", _obj.id, [_delivery_slot_type,_delivery_slot_index], -1, null, _cur_item, -1]);
                // maybe put a confirmation dialog here?
                var current_page = _scrolling_current_page;
                var restore_scrolling = (function (_current_page) { return function(w) {
                    var scroll_dialog = find_dialog('crafting_dialog').widgets['status'];
                    scroll_dialog.user_data['page'] = scrolling_current_page;
                }; })(current_page);
                invoke_ui_locker(null,restore_scrolling);
                _unconfig_cb();
            }; })(obj, cur_item, delivery_slot_type, delivery_slot_index, unconfig_cb, scrolling_current_page);
        } else if(in_progress_recipe) {
            dialog.widgets['grid_icon'+wname].asset = get_leveled_quantity(get_crafting_recipe_icon(gamedata['crafting']['recipes'][in_progress_recipe]), in_progress_level);
            dialog.widgets['grid_icon'+wname].alpha = 1;
            dialog.widgets['grid_frame'+wname].onclick = null;
            grid_frame_tooltip = dialog.data['widgets']['grid_frame']['ui_tooltip_inprogress'].replace('%s', ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_crafting_recipe_product_spec(gamedata['crafting']['recipes'][in_progress_recipe])));
            dialog.widgets['grid_cancel'+wname].tooltip.str = dialog.data['widgets']['grid_cancel']['ui_tooltip_cancel'];
            dialog.widgets['grid_cancel'+wname].onclick = (function (_builder, _in_progress_bus, _unconfig_cb) { return function(w) {
                do_cancel_crafting(_builder, _in_progress_bus);
                _unconfig_cb();
            }; })(builder, in_progress_bus, unconfig_cb);
            dialog.widgets['grid_timer'+wname].show = true;
            dialog.widgets['grid_timer'+wname].str = pretty_print_time_brief(in_progress_togo);
        } else if(cur_config) {
            var cur_config_spec = gamedata['items'][cur_config];
            dialog.widgets['grid_icon'+wname].asset = get_leveled_quantity(cur_config_spec['icon'], cur_config_level);
            dialog.widgets['grid_icon'+wname].state = 'icon_disabled';
            dialog.widgets['grid_icon'+wname].alpha = 0.33;
            dialog.widgets['grid_skull'+wname].show = true;
            dialog.widgets['grid_frame'+wname].onclick = build_cb;
            grid_frame_tooltip = dialog.data['widgets']['grid_frame']['ui_tooltip_produce'].replace('%s', cur_config_spec['ui_name']);
            dialog.widgets['grid_cancel'+wname].onclick = unconfig_cb;

            if(!dialog.parent.user_data['on_use_recipe'] && selected_grid_spec == cur_config_spec) {
                dialog.parent.user_data['on_use_recipe'] = build_cb;
            }

        } else if(selected_grid_spec) {
            dialog.widgets['grid_icon'+wname].alpha = 0.33;
            dialog.widgets['grid_icon'+wname].asset = get_leveled_quantity(selected_grid_spec['icon'], selected_grid_item_level);
            dialog.widgets['grid_icon'+wname].show = (dialog.widgets['grid_frame'+wname].mouse_enter_time > 0) && (dialog.widgets['grid_cancel'+wname].mouse_enter_time < 0);
            if(grid_frame_tooltip == '') { grid_frame_tooltip = dialog.data['widgets']['grid_frame']['ui_tooltip_produce'].replace('%s', selected_grid_spec['ui_name']); }

            var build_and_config_cb;
            if(('persist_config' in catspec) && !catspec['persist_config']) {
                build_and_config_cb = build_cb; // no persistence
            } else {
                build_and_config_cb = (function (_obj, _selected_grid_spec, _delivery_slot_type, _delivery_slot_index, _multiple, _build_cb) { return function(w) {
                if(_build_cb && _build_cb()) {
                    var new_config = _obj.config || {};
                    if(_multiple) {
                        if(!new_config[_delivery_slot_type]) { new_config[_delivery_slot_type] = []; }
                        while(new_config[_delivery_slot_type].length < _delivery_slot_index) {
                            new_config[_delivery_slot_type].push(null);
                        }
                        new_config[_delivery_slot_type][_delivery_slot_index] = _selected_grid_spec['name'];
                    } else {
                        new_config[_delivery_slot_type] = _selected_grid_spec['name'];
                    }
                    send_to_server.func(["CAST_SPELL", _obj.id, "CONFIG_SET", new_config]);
                    // client-side predict config
                    _obj.config = new_config;
                    _obj.request_sync();
                }
                }; })(obj, selected_grid_spec, delivery_slot_type, delivery_slot_index, multiple_delivery_slots, build_cb);
            }
            dialog.widgets['grid_frame'+wname].onclick = build_and_config_cb;
            dialog.widgets['grid_cancel'+wname].show = false;

            if(!dialog.parent.user_data['on_use_recipe']) {
                dialog.parent.user_data['on_use_recipe'] = build_and_config_cb;
            }
        } else {
            dialog.widgets['grid_icon'+wname].show =
                dialog.widgets['grid_frame'+wname].show =
                dialog.widgets['grid_cancel'+wname].show = false;
        }

        dialog.widgets['grid_pending'+wname].show = pending;
        if(pending) {
            dialog.widgets['grid_frame'+wname].onclick = null;
        }
        dialog.widgets['grid_frame'+wname].tooltip.str = grid_frame_tooltip;
    } else {
        dialog.widgets['grid_slot'+wname].show = true;
        dialog.widgets['grid_slot'+wname].tooltip.str = grid_frame_tooltip = dialog.data['widgets']['grid_slot']['ui_tooltip_build_more'].replace('%s', slot_building_spec['ui_name']);
    }
}

/** @param {SPUI.Dialog} dialog */
function crafting_dialog_init_status_missiles(dialog) {
    var dims = dialog.data['widgets']['missile_slot']['array'];
    dialog.user_data['wname_to_tag'] = {};
    for(var y = 0; y < dims[1]; y++) {
        for(var x = 0; x < dims[0]; x++) {
            var wname = x.toString()+','+y.toString();
            var tag = wname;
            dialog.user_data['wname_to_tag'][wname] = tag; // not sure we need this for missile slots
            dialog.widgets['missile_slot'+wname].show = true; // update_status_missiles() takes care of hiding slots beyond the max available number
        }
    }
}

/** @param {SPUI.Dialog} dialog */
function crafting_dialog_init_status_merge_items(dialog) {
    // nothing to do here
}

/** @param {SPUI.Dialog} dialog
    @param {number} page */
function crafting_dialog_mousewheel(dialog, page) {
    var destination_page = (page > 0 ? dialog.user_data['page'] + 1 : dialog.user_data['page'] - 1);
    crafting_dialog_scroll(dialog, destination_page)
}

/** @param {SPUI.Dialog} dialog
    @param {number} page */
function crafting_dialog_scroll(dialog, page) {
    dialog.user_data['recipes_by_widget'] = null;
    var chapter_recipes = (dialog.user_data['recipes'] ? dialog.user_data['recipes'].length : 0);
    var recipes_per_page = dialog.user_data['recipe_columns']*dialog.data['widgets']['recipe_icon']['array'][1];
    var chapter_pages = dialog.user_data['chapter_pages'] = Math.floor((chapter_recipes+recipes_per_page-1)/recipes_per_page);
    dialog.user_data['page'] = page = (chapter_recipes === 0 ? 0 : clamp(page, 0, chapter_pages-1));
    dialog.widgets['scroll_left'].show = dialog.widgets['scroll_right'].show = (chapter_recipes > 0);
    player.quest_tracked_dirty = true;
}

/** @param {SPUI.Dialog} dialog
    @param {!Object|null} rec  */
function crafting_dialog_select_recipe(dialog, rec) {

    dialog.parent.user_data['selected_recipe'] = rec;
    dialog.parent.user_data['on_use_recipe'] = null; // will be set by an ondraw update

    // show instructions for empty recipe list
    dialog.parent.widgets['no_recipes'].show = (!!dialog.parent.user_data['builder'] && (!dialog.parent.user_data['recipes'] || dialog.parent.user_data['recipes'].length < 1));
    if(dialog.parent.widgets['no_recipes'].show) {
        dialog.parent.widgets['no_recipes'].str = gamedata['crafting']['categories'][dialog.parent.user_data['category']]['ui_no_recipes'];
    }

    if(!rec) { dialog.show = false; return; }
    var specname = rec['spec'];

    if(!specname || !(specname in gamedata['crafting']['recipes'])) {
        throw Error('crafting recipe not found for rec: '+JSON.stringify(rec));
    }

    var recipe = gamedata['crafting']['recipes'][specname];
    var recipe_level = rec['level'] || 1;
    dialog.show = true;
    dialog.user_data['recipe'] = recipe;
    if(recipe['crafting_category'] == 'mines' || recipe['crafting_category'] == 'ambushes') {
        crafting_dialog_select_recipe_grid_weapons(dialog, specname, recipe, recipe_level, recipe['crafting_category']);
    } else if(recipe['crafting_category'] == 'missiles') {
        crafting_dialog_select_recipe_missiles(dialog, specname, recipe);
    } else if(recipe['crafting_category'] == 'leaders' || recipe['crafting_category'] == 'equips') {
        crafting_dialog_select_recipe_merge_items(dialog, specname, rec); // full dictionary, not recipe
    }
}

/** @param {SPUI.Dialog} dialog
    @param {string} specname
    @param {!Object} recipe
    @param {number} recipe_level
    @param {string} category */
function crafting_dialog_select_recipe_grid_weapons(dialog, specname, recipe, recipe_level, category) {
    dialog.widgets['name'].str = get_crafting_recipe_ui_name(recipe, recipe_level);
    dialog.widgets['icon'].asset = get_crafting_recipe_icon(recipe, recipe_level);
    dialog.widgets['frame'].onclick = function(w) {
        if(w.parent.parent) {
            var func = w.parent.parent.user_data['on_use_recipe'];
            if(func) { func(); }
        }
    };

    var grid_spec = ItemDisplay.get_crafting_recipe_product_spec(recipe, recipe_level);
    if('ui_description' in grid_spec) {
        dialog.widgets['icon'].tooltip.str = grid_spec['ui_description'];
    }
    var grid_spell = ItemDisplay.get_inventory_item_weapon_spell(grid_spec);
    init_damage_vs_icons(dialog, {'kind':'building', 'ui_damage_vs':{}}, // fake building spec to fool init_damage_vs_icons()
                         grid_spell);
    var stat_spec = grid_spec;

    var stat_level = ('level' in grid_spec ? grid_spec['level'] : recipe_level);
    // The level that will apply to the created landmine item.
    // Normally equal to recipe_level, but legacy landmines that have a specific "level",
    // as opposed to newer multi-level landmine items, can override it.

    var stat_spell = grid_spell;

    var stat_spell_level = recipe_level;
    // The level that the landmine's SHOOT spell will use.
    // For legacy landmines, recipe_level will always be 1, so this will select the individual LAMDINE_Lxxx_SHOOT spell, which only has one level.
    // For newer multi-level landmines, it will select the level of the unified LANDMINE_SHOOT spell appropriate for the item we're about to create.
    if(('equip' in grid_spec) && ('effects' in grid_spec['equip'])) {
        var effect_list = grid_spec['equip']['effects'];
        goog.array.forEach(effect_list, function(effect) {
            if(effect['code'] == 'modstat' && (effect['stat'] == 'weapon_level') && effect['method'] == 'replace') {
                stat_spell_level = get_leveled_quantity(effect['strength'], recipe_level);
            }
        });
    }

    // grab a random minefield or ambush point building to catch any modstats that apply to mines
    var grid_weapon;
    if(category == 'mines') {
        grid_weapon = find_any_player_minefield();
    } else if (category == 'ambushes') {
        grid_weapon = find_any_player_ambush_point();
    }

    // set up stats display for this kind of recipe
    var statlist = gamedata['crafting']['categories'][recipe['crafting_category']]['display_stats'] || [];
    goog.array.forEach(['descriptionL0', 'descriptionR0', 'descriptionL1', 'descriptionR1'], function(wname, i) {
        if(i < statlist.length) {
            dialog.widgets[wname].show = true;
            var stat = statlist[i];
            var modchain = (grid_weapon && (stat in grid_weapon.modstats) ? grid_weapon.modstats[stat] : null);
            // hack - get the .str for the label, then reset the widget to be the stat value display, get the .str, and combine them
            ModChain.display_label_widget(dialog.widgets[wname], stat, stat_spell, true);
            var label_str = dialog.widgets[wname].str;
            ModChain.display_widget(dialog.widgets[wname], stat, modchain, stat_spec, stat_level, stat_spell, stat_spell_level, true);
            var value_str = dialog.widgets[wname].str;
            dialog.widgets[wname].str = label_str + ': ' + value_str;
        } else {
            dialog.widgets[wname].show = false;
        }
    });
}

/** @param {SPUI.Dialog} dialog
    @param {string} specname
    @param {!Object} recipe */
function crafting_dialog_select_recipe_missiles(dialog, specname, recipe) { // XXX does not handle recipe_level
    var product_spec = ItemDisplay.get_crafting_recipe_product_spec(recipe);
    dialog.widgets['name'].str = ItemDisplay.get_inventory_item_ui_name_long(product_spec);
    dialog.widgets['description'].set_text_with_linebreaking(product_spec['ui_description']); // XXX overflow?
    ItemDisplay.display_item(dialog.widgets['item'], {'spec':product_spec['name']}, {context_parent: dialog.parent});
    ItemDisplay.attach_inventory_item_tooltip(dialog.widgets['item'].widgets['frame'], {'spec':product_spec['name']}, dialog.parent);
    dialog.widgets['item'].widgets['frame'].onclick = function(w) {
        if(w.parent.parent.parent) {
            var func = w.parent.parent.parent.user_data['on_use_recipe'];
            if(func) { func(); }
        }
    };

    // set up stats display for this kind of recipe
    var statlist = gamedata['crafting']['categories'][recipe['crafting_category']]['display_stats'] || [];

    var product_spell = gamedata['spells'][product_spec['use']['spellname']];
    if(gamedata['crafting']['categories'][recipe['crafting_category']]['display_damage_vs']) {
        init_damage_vs_icons(dialog, {'kind':'building', 'ui_damage_vs':{}}, // fake building spec to fool init_damage_vs_icons()
                             product_spell);
    } else {
        init_damage_vs_icons(dialog, null, null);
    }

    var stat_spec = product_spec;
    var stat_level = product_spec['level'] || 1;
    var stat_spell = product_spell;
    var stat_spell_level = 1;

    for(var y = 0; y < dialog.data['widgets']['features']['array'][1]; y++) {
        for(var x = 0; x < dialog.data['widgets']['features']['array'][0]; x++) {
            var i = y * dialog.data['widgets']['features']['array'][0] + x;
            var wname = SPUI.get_array_widget_name('features', dialog.data['widgets']['features']['array'], [x,y]);
            if(i < statlist.length) {
                dialog.widgets[wname].show = true;
                var stat = statlist[i];
                var modchain = null;
                // hack - get the .str for the label, then reset the widget to be the stat value display, get the .str, and combine them
                ModChain.display_label_widget(dialog.widgets[wname], stat, stat_spell, true);
                var label_str = dialog.widgets[wname].str;
                ModChain.display_widget(dialog.widgets[wname], stat, modchain, stat_spec, stat_level, stat_spell, stat_spell_level, true);
                var value_str = dialog.widgets[wname].str;
                dialog.widgets[wname].str = label_str + ': ' + value_str;
            } else {
                dialog.widgets[wname].show = false;
            }
        }
    }
}

/** @param {SPUI.Dialog} dialog
    @param {string} specname
    @param {!Object} rec */
function crafting_dialog_select_recipe_merge_items(dialog, specname, rec) {
    var recipe = gamedata['crafting']['recipes'][rec['spec']];
    var level = rec['level'] || 1;

    var recipe_ui_name = get_leveled_quantity(recipe['ui_name'] || null, level);
    var recipe_ui_subtitle = get_leveled_quantity(recipe['ui_subtitle'] || null, level);
    var recipe_ui_description = get_leveled_quantity(recipe['ui_description'] || null, level);

    var leader_spec = ItemDisplay.get_crafting_recipe_product_spec(recipe, level);
    var ui_level = leader_spec['level'] || rec['level'] || 1;

    // set topinfo text
    var topinfo_bbcode;

    if(recipe_ui_subtitle) { // allow recipe to override topinfo
        topinfo_bbcode = '[b]'+recipe_ui_subtitle+'[/b]';
    } else if(leader_spec['item_set']) {
        var set_spec = gamedata['item_sets'][leader_spec['item_set']];
        var ui_item_set = set_spec['ui_name'];
        var ui_index = set_spec['members'].indexOf(leader_spec['name']) + 1;
        var ui_members = set_spec['members'].length;
        topinfo_bbcode = dialog.data['widgets']['topinfo']['ui_name_set'].replace('%ITEM_SET', ui_item_set).replace('%INDEX', ui_index.toString()).replace('%MEMBERS', ui_members.toString()).replace('%SUBTITLE', ItemDisplay.get_inventory_item_ui_subtitle(leader_spec)).replace('%LEVEL', ui_level.toString());
    } else {
        topinfo_bbcode = dialog.data['widgets']['topinfo']['ui_name'].replace('%SUBTITLE', ItemDisplay.get_inventory_item_ui_subtitle(leader_spec)).replace('%LEVEL', ui_level.toString());
    }
    dialog.widgets['topinfo'].set_text_bbcode(topinfo_bbcode);

    var virtual_item = {'spec':leader_spec['name'], 'level': rec['level'] || 1};
    ItemDisplay.display_item(dialog.widgets['item'], virtual_item, {context_parent: dialog.parent});

    /* old code to hide standard inventory tooltip when recipe ui_description is unique
    ItemDisplay.remove_inventory_item_tooltip(dialog.widgets['item'].widgets['frame']);

    if(recipe_ui_description) { // manual override
        //dialog.widgets['item'].widgets['frame'].tooltip.str = recipe_ui_description; // no way to attach a tooltip inside the item_display widget :(
    } else {
        ItemDisplay.attach_inventory_item_tooltip(dialog.widgets['item'].widgets['frame'], virtual_item, dialog.parent);
    }
    */

    dialog.widgets['name'].str = recipe_ui_name || ItemDisplay.get_inventory_item_ui_name_long(leader_spec);
    dialog.widgets['name'].text_color = ItemDisplay.get_inventory_item_color(leader_spec);

    dialog.widgets['item'].widgets['frame'].onclick = function(w) {
        if(w.parent.parent.parent) {
            var func = w.parent.parent.parent.user_data['on_use_recipe'];
            if(func) { func(); }
        }
    };

    // work on line breaking
    var bbtext = recipe_ui_description || ItemDisplay.get_inventory_item_ui_description(virtual_item, {hide_item_set:true, hide_level:true});
    dialog.widgets['description'].set_text_bbcode(bbtext);
    dialog.widgets['description'].tooltip.str = null;
    ItemDisplay.remove_inventory_item_tooltip(dialog.widgets['description']);
    if(dialog.widgets['description'].clip_to_max_lines(dialog.data['widgets']['description']['max_lines'], dialog.data['widgets']['description']['ui_name_seemore'])) {
        // there was an overflow, add tooltip
        if(recipe_ui_description) { // manual override
            dialog.widgets['description'].tooltip.str = SPText.bbcode_strip(recipe_ui_description);
        } else {
            ItemDisplay.attach_inventory_item_tooltip(dialog.widgets['description'], virtual_item, dialog.parent);
        }
    }
}

/** @param {SPUI.Dialog|SPUI.Element} dialog */
function update_crafting_dialog_recipe_common(dialog) {
    var specname = dialog.parent.user_data['selected_recipe']['spec'];
    var recipe_level = dialog.parent.user_data['selected_recipe']['level'] || 1;
    var recipe = gamedata['crafting']['recipes'][specname];
    var builder = dialog.parent.user_data['builder'];
    dialog.show = true;
    var grid = [0,0], dims = dialog.data['widgets']['requirements_icon']['array'];

    goog.object.forEach(gamedata['resources'], function(resdata, resname) {
        var wname = grid[0].toString()+','+grid[1].toString();
        var cost = get_leveled_quantity(get_leveled_quantity(recipe['cost'], recipe_level)[resname] || 0, recipe_level) || 0;
        dialog.widgets['requirements_icon'+wname].show =
            dialog.widgets['requirements_value'+wname].show = (cost > 0);
        if(cost > 0) {
            dialog.widgets['requirements_icon'+wname].asset = resdata['icon_small'];
            dialog.widgets['requirements_value'+wname].str = pretty_print_qty_brief(cost);
            dialog.widgets['requirements_value'+wname].tooltip.str = dialog.data['widgets']['requirements_value']['ui_tooltip'].replace('%res', resdata['ui_name']).replace('%qty', pretty_print_number(cost));

            dialog.widgets['requirements_value'+wname].text_color = (cost > player.resource_state[resname][1] ? SPUI.error_text_color : SPUI.good_text_color);
        }
        grid[1] += 1;
        if(grid[1] >= dims[1]) {
            grid[1] = 0;
            grid[0] += 1;
        }
    });

    while(grid[0] < dims[0]) {
        while(grid[1] < dims[1]) {
            var wname = grid[0].toString()+','+grid[1].toString();
            dialog.widgets['requirements_icon'+wname].show =
                dialog.widgets['requirements_value'+wname].show = false;
            grid[1] += 1;
        }
        grid[1] = 0;
        grid[0] += 1;
    }

    var cost_time = get_leveled_quantity(recipe['craft_time'], recipe_level);
    if(builder) {
        var speed = builder.get_stat('crafting_speed', builder.get_leveled_quantity(builder.spec['crafting_speed'] || 1.0));
        cost_time = Math.max(1, Math.floor(cost_time / speed));
    }

    dialog.widgets['requirements_time_value'].str = pretty_print_time_brief(cost_time);
}

/** @param {SPUI.Dialog} dialog */
function update_crafting_dialog_recipe_grid_weapons(dialog) {
    refresh_crafting_dialog_recipes(dialog.parent);
    update_crafting_dialog_recipe_common(dialog);
}

/** @param {SPUI.Dialog} dialog */
function update_crafting_dialog_recipe_missiles(dialog) {
    update_crafting_dialog_recipe_merge_items(dialog);
}

/** @param {SPUI.Dialog} dialog */
function update_crafting_dialog_recipe_merge_items(dialog) {
    update_crafting_dialog_recipe_common(dialog);
    var specname = dialog.parent.user_data['selected_recipe']['spec'];
    var recipe = gamedata['crafting']['recipes'][specname];
    var recipe_level = dialog.parent.user_data['selected_recipe']['level'] || 1;

    var can_craft = true;
    // note: like the main crafting_dialog recipe update, only gray out if a predicate is false, not if there is resource/ingredient trouble
    // can_craft = dialog.user_data['builder'] && can_cast_spell(dialog.user_data['builder'].id, 'CRAFT_FOR_FREE', [{'recipe': specname}]);
    can_craft = !(('requires' in recipe) && !player.is_cheater && !read_predicate(get_leveled_quantity(recipe['requires'], recipe_level)).is_satisfied(player, null));

    dialog.widgets['item'].widgets['frame'].state = (can_craft ? 'normal' : 'disabled_clickable');


    var ingr_list = get_crafting_recipe_ingredients_list(recipe, recipe_level);

    ItemDisplay.display_item_array(dialog, 'requirements_item', ingr_list, {context_parent: dialog.parent,
                                                                            hide_tooltip: true});
    var by_specname = {};
    for(var i = 0; i < dialog.data['widgets']['requirements_item']['array'][0]; i++) {
        if(i < ingr_list.length) {
            var ingr = ingr_list[i];
            var ingr_spec = gamedata['items'][ingr['spec']];
            var ingr_stack = ('stack' in ingr ? ingr['stack'] : 1);
            var ingr_level = ('level' in ingr ? ingr['level'] : null);
            var ui_ingr = ItemDisplay.get_inventory_item_stack_prefix(ingr_spec, ingr_stack) + ItemDisplay.get_inventory_item_ui_name_long(ingr_spec, ingr_level);
            dialog.widgets['requirements_item'+i.toString()].widgets['frame'].tooltip.str =
                dialog.data['widgets']['requirements_item']['ui_tooltip'].replace('%ITEM', ui_ingr);

            // group items by spec/level for the tooltip
            var key = ingr['spec'];
            if(ingr_level) { key += ':L'+ingr_level.toString(); }

            var has_it = player.inventory_item_quantity(ingr['spec'], ingr['level']) - (by_specname[key] || 0) >= ingr_stack;
            by_specname[key] = (by_specname[key]||0) + ingr_stack;
            dialog.widgets['requirements_item'+i.toString()].widgets['frame'].state = (has_it ? 'normal_nohighlight' : 'disabled');
            dialog.widgets['requirements_item_status'+i.toString()].show = true;
            dialog.widgets['requirements_item_status'+i.toString()].color = SPUI.make_colorv(dialog.data['widgets']['requirements_item_status'][(has_it ? 'color_present' : 'color_missing')]);
        } else {
            dialog.widgets['requirements_item_status'+i.toString()].show = false;
        }
    }
}

/** @param {SPUI.Dialog} dialog */
function update_crafting_dialog(dialog) {
    var flash_scroll = false;
    if(!dialog.user_data['scrolled'] &&
       ((client_time - dialog.user_data['open_time']) < gamedata['store']['store_scroll_flash_time'])) {
        if(dialog.widgets['scroll_right'].state != 'disabled') {
            flash_scroll = (((client_time/gamedata['store']['store_scroll_flash_period']) % 1) >= 0.5);
        }
    }

    var page = dialog.user_data['page'], chapter_pages = dialog.user_data['chapter_pages'];
    var chapter_recipes = (dialog.user_data['recipes'] ? dialog.user_data['recipes'].length : 0);
    var recipes_per_page = dialog.user_data['recipe_columns']*dialog.data['widgets']['recipe_icon']['array'][1];
    var grid = [0,0];

    if(chapter_pages > 0) {
        dialog.user_data['recipes_by_widget'] = {};
        var first_recipe_on_page = page * recipes_per_page;
        var last_recipe_on_page = Math.max(0, Math.min((page+1)*recipes_per_page-1, chapter_recipes-1));
        for(var i = first_recipe_on_page; i <= last_recipe_on_page; i++) {
            var rec = dialog.user_data['recipes'][i];
            var name = rec['spec'];
            var spec = gamedata['crafting']['recipes'][name];
            var wname = grid[0].toString() +',' + grid[1].toString();
            dialog.user_data['recipes_by_widget'][wname] = name;
            var tooltip_text = [], tooltip_text_color = SPUI.default_text_color;
            dialog.widgets['recipe_slot'+wname].show =
                dialog.widgets['recipe_icon'+wname].show =
                dialog.widgets['recipe_frame'+wname].show = true;
            var can_craft = true;

            tooltip_text.push(get_crafting_recipe_ui_name(spec, rec['level'] || 1));
            dialog.widgets['recipe_icon'+wname].asset = get_crafting_recipe_icon(spec, rec['level'] || 1);

            // get list of any unsatisfied requirements
            var pred = null, req = null;
            if(('requires' in spec) && !player.is_cheater) {
                pred = read_predicate(get_leveled_quantity(spec['requires'], dialog.user_data['recipe_level'] || 1))
                req = pred.ui_describe(player);
                if(req) {
                    tooltip_text.push('');
                    tooltip_text.push(dialog.data['widgets']['recipe_frame']['ui_tooltip_requires'].replace('%s', req));
                    can_craft = false;
                }
            }

            dialog.widgets['recipe_frame'+wname].onclick = (function (_rec) { return function(w) {
                if(w.parent.user_data['selected_recipe'] === _rec) {
                    if(w.parent.user_data['on_use_recipe']) {
                        // note: assumes on_use_recipe has been set up by an ondraw update
                        w.parent.user_data['on_use_recipe'](w.parent);
                    }
                } else {
                    crafting_dialog_select_recipe(w.parent.widgets['recipe'], _rec);
                }
            }; })(rec);

            dialog.widgets['recipe_gray_outer'+wname].show = !can_craft;
            dialog.widgets['recipe_frame'+wname].state = (rec === dialog.user_data['selected_recipe'] ? 'highlight' : 'normal');

            if(can_craft) {
            } else {
                if(pred) {
                    // still allow selecting the recipe so that players can see what its benefits and requirements are
                    tooltip_text_color = SPUI.error_text_color;
                } else {
                    dialog.widgets['recipe_frame'+wname].state = 'disabled';
                }
            }

            if(tooltip_text.length > 0) {
                dialog.widgets['recipe_frame'+wname].tooltip.str = tooltip_text.join('\n');
                dialog.widgets['recipe_frame'+wname].tooltip.text_color = tooltip_text_color;
            } else {
                dialog.widgets['recipe_frame'+wname].tooltip.str = null;
            }
            grid[0] += 1;
            if(grid[0] >= dialog.user_data['recipe_columns']) {
                // clear out unused columns to the right-hand side
                while(grid[0] < dialog.data['widgets']['recipe_icon']['array'][0]) {
                    var widget_name = grid[0].toString() + ',' + grid[1].toString();
                    dialog.widgets['recipe_slot'+widget_name].show =
                        dialog.widgets['recipe_icon'+widget_name].show =
                        dialog.widgets['recipe_gray_outer'+widget_name].show =
                        dialog.widgets['recipe_frame'+widget_name].show = false;
                    grid[0] += 1;
                }

                grid[0] = 0; grid[1] += 1;
            }
        }

        dialog.widgets['scroll_text'].show = true;
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_recipe_on_page+1).toString()).replace('%d2',(last_recipe_on_page+1).toString()).replace('%d3',chapter_recipes.toString());
    } else {
        dialog.widgets['scroll_text'].show = false;
    }

    // clear out empty widgets
    while(grid[1] < dialog.data['widgets']['recipe_icon']['array'][1]) {
        while(grid[0] < dialog.data['widgets']['recipe_icon']['array'][0]) {
            var widget_name = grid[0].toString() + ',' + grid[1].toString();
            dialog.widgets['recipe_slot'+widget_name].show =
                dialog.widgets['recipe_icon'+widget_name].show =
                dialog.widgets['recipe_gray_outer'+widget_name].show =
                dialog.widgets['recipe_frame'+widget_name].show = false;
            grid[0] += 1;
        }
        grid[0] = 0; grid[1] += 1;
    }

    dialog.widgets['scroll_left'].widgets['scroll_left'].state = (page != 0 ? 'normal' : 'disabled');
    dialog.widgets['scroll_left'].widgets['scroll_left_bg'].alpha = (page != 0 ? 0.86 : 0.25);
    dialog.widgets['scroll_left'].widgets['scroll_left_bg'].fade_unless_hover = (page != 0 ? 0.5 : 1);
    dialog.widgets['scroll_right'].widgets['scroll_right'].state = ((page < chapter_pages-1) ? 'normal' : 'disabled');
    dialog.widgets['scroll_right'].widgets['scroll_right_bg'].alpha = ((page < chapter_pages-1) ? (flash_scroll ? 1 : 0.86) : 0.25);
    dialog.widgets['scroll_right'].widgets['scroll_right_bg'].fade_unless_hover = ((page < chapter_pages-1) ? (flash_scroll ? 1 : 0.5) : 1);

    if(dialog.user_data['category'] == 'mines' || dialog.user_data['category'] == 'ambushes') {
        update_crafting_dialog_status_grid_weapons(dialog.widgets['status']);
    } else if(dialog.user_data['category'] == 'missiles') {
        update_crafting_dialog_status_missiles(dialog.widgets['status']);
    } else if(dialog.user_data['category'] == 'leaders' || dialog.user_data['category'] == 'equips') {
        update_crafting_dialog_status_merge_items(dialog.widgets['status']);
    } else {
        throw Error('unhandled category '+dialog.user_data['category']);
    }

    if(dialog.user_data['selected_recipe']) {
        if(dialog.user_data['category'] == 'mines' || dialog.user_data['category'] == 'ambushes') {
            update_crafting_dialog_recipe_grid_weapons(dialog.widgets['recipe']);
        } else if(dialog.user_data['category'] == 'missiles') {
            update_crafting_dialog_recipe_missiles(dialog.widgets['recipe']);
        } else if(dialog.user_data['category'] == 'leaders' || dialog.user_data['category'] == 'equips') {
            update_crafting_dialog_recipe_merge_items(dialog.widgets['recipe']);
        }
    }

    // fill in price display and "finish" button callback
    var builder = dialog.user_data['builder'];
    var craft_queue = (builder ? builder.get_crafting_queue() : []);
    var closure;
    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].tooltip.str = '';
    dialog.widgets['price_spinner'].show = (builder && !builder.is_in_sync());

    if(builder && builder.is_damaged()) {
        dialog.widgets['crafting_progress'].show =
            dialog.widgets['crafting_progress_text'].show = true;
        dialog.widgets['crafting_progress'].progress = (builder.is_crafting() ? builder.crafting_progress_one() : 0);
        dialog.widgets['crafting_progress_text'].str = dialog.data['widgets']['crafting_progress_text']['ui_name_damaged'];
        dialog.widgets['crafting_progress_text'].text_color = SPUI.error_text_color;
    } else if(builder && builder.is_crafting()) {
        dialog.widgets['crafting_progress'].show =
            dialog.widgets['crafting_progress_text'].show = true;
        dialog.widgets['crafting_progress'].progress = builder.crafting_progress_one();
        var ui_cat = 'unknown';
        for(var i = 0; i < craft_queue.length; i++) {
            var rspec = gamedata['crafting']['recipes'][craft_queue[i]['craft']['recipe']];
            if(rspec['crafting_category']) {
                ui_cat = gamedata['crafting']['categories'][rspec['crafting_category']]['ui_name_singular']; break;
            }
        }
        dialog.widgets['crafting_progress_text'].str = dialog.data['widgets']['crafting_progress_text']['ui_name_crafting'].replace('%togo',
                                                                                                                                    pretty_print_time(builder.crafting_time_left_all())).replace('%qty', craft_queue.length.toString()).replace('%cat',ui_cat);
        dialog.widgets['crafting_progress_text'].text_color = SPUI.make_colorv(dialog.data['widgets']['crafting_progress_text']['text_color']);
    } else {
        dialog.widgets['crafting_progress'].show = false;
        dialog.widgets['crafting_progress_text'].show = true;
        dialog.widgets['crafting_progress_text'].str = dialog.data['widgets']['crafting_progress_text']['ui_name_idle'];
        dialog.widgets['crafting_progress_text'].text_color = SPUI.make_colorv(dialog.data['widgets']['crafting_progress_text']['text_color']);
    }

    var can_speedup = player.crafting_speedups_enabled();
    if(can_speedup) {
        for(var i = 0; i < craft_queue.length; i++) {
            var rspec = gamedata['crafting']['recipes'][craft_queue[i]['craft']['recipe']];
            if(rspec['crafting_category']) {
                var cat = gamedata['crafting']['categories'][rspec['crafting_category']];
                if(('speedupable' in cat) && !cat['speedupable']) {
                    can_speedup = false;
                }
            }
        }
    }

    if(!can_speedup) {
        dialog.widgets['price_display'].show = dialog.widgets['finish_button'].show = false;
    } else {
        dialog.widgets['price_display'].show = dialog.widgets['finish_button'].show = true;

    // ! this block is left one indent to minimize diff
    if(builder && !builder.is_in_sync()) {
        dialog.widgets['price_display'].str = '';
        closure = null;
        dialog.widgets['price_display'].onclick = null;
        dialog.widgets['finish_button'].state = 'disabled';
        dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name_pending'];
        dialog.widgets['price_display'].tooltip.str = dialog.widgets['finish_button'].tooltip.str = '';
    } else if(!builder || craft_queue.length < 1) {
        dialog.widgets['price_display'].str = '';
        closure = null;
        dialog.widgets['price_display'].onclick = null;
        dialog.widgets['finish_button'].state = 'disabled';
        dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'];
        dialog.widgets['price_display'].tooltip.str = dialog.widgets['finish_button'].tooltip.str = '';
    } else {
        // note: SPEEDUP_FOR_MONEY will repair the factory rather than speed up production if factory is damaged
        dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'+(builder.is_damaged() ? '_repair' : '')];
        dialog.widgets['finish_button'].state = 'normal';

        var price = Store.get_user_currency_price(builder.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null);
        dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
        dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);

        if(price == 0) {
            closure = (function(_builder) { return function(w) {
                var dialog = w.parent;
                if(dialog.widgets['coverup_all'].show) { return; }
                send_to_server.func(["CAST_SPELL", _builder.id, "SPEEDUP_FOR_FREE"]);
                invoke_ui_locker(_builder.request_sync(), function() { change_selection(null); });
            }; })(builder);
        } else if(price > 0) {
            closure = (function(_builder) { return function(w) {
                var dialog = w.parent;
                if(dialog.widgets['coverup_all'].show) { return; }

                var cleanup_cb = (function (_dialog) { return function() {
//                  change_selection(null);
                }; })(dialog);

                if(Store.place_user_currency_order(_builder.id, "SPEEDUP_FOR_MONEY", null, cleanup_cb)) {
                    invoke_ui_locker(_builder.request_sync(), function() {
                        //change_selection(null);
                    });
                }
            };})(builder);
        } else {
            // invalid order?
            if(builder.is_damaged() && !builder.is_repairing()) {
                closure = (function (obj) { return function() {
                    change_selection(obj); invoke_repair_dialog();
                }; })(builder);
            } else {
                closure = null;
                dialog.widgets['finish_button'].state = 'disabled';
            }
        }
    }

    dialog.widgets['price_display'].onclick =
        dialog.widgets['finish_button'].onclick = closure;
    } // END crafting speedups are available

}

function make_unique_id() { return server_time.toFixed(0)+'-'+(10000*Math.random()).toFixed(0); }

function start_crafting(_builder, _build_recipe_spec, extra_params) {
    // come up with a unique tag for this bus
    var ui_tag = make_unique_id();
    var level = (extra_params && ('level' in extra_params) ? extra_params['level'] : 1);

    var params = {'recipe':_build_recipe_spec['name'], 'ui_tag': ui_tag};
    if(extra_params) {
        goog.array.forEach(['delivery','ui_index','level'], function(n) {
            if(n in extra_params) { params[n] = extra_params[n]; }
        });
    }

    send_to_server.func(["CAST_SPELL", _builder.id, "CRAFT_FOR_FREE", params]);
    var _craft_queue = _builder.start_client_prediction('crafting.queue', _builder.crafting ? _builder.crafting['queue'] : []);

    // client-side predict what will happen
    var cost_time = Math.max(1, Math.floor(get_leveled_quantity(_build_recipe_spec['craft_time'], level) / _builder.get_stat('crafting_speed', _builder.get_leveled_quantity(_builder.spec['crafting_speed'] || 1.0))));

    var delay = 0;
    for(var i = 0; i < _craft_queue.length; i++) {
        var entry = _craft_queue[i];
        var d = entry['total_time'] - entry['done_time'];
        if(entry['start_time'] > 0) {
            d -= Math.min(Math.max(server_time - entry['start_time'],0), entry['total_time']);
        }
        delay += d;
    }
    var start_time = server_time + Math.max(0, delay);
    _craft_queue.push({'craft':{'recipe':_build_recipe_spec['name'], 'level': level, 'ui_tag': ui_tag, 'cost': goog.object.clone(_build_recipe_spec['cost'])},
                       'start_time': start_time, 'done_time': 0, 'total_time': cost_time});
    goog.object.forEach(gamedata['resources'], function(res, resname) {
        var cost = _build_recipe_spec['cost'][resname] || 0;
        player.resource_state[resname][1] -= cost;
    });

    if('start_effect' in _build_recipe_spec) {
        session.get_real_world().fxworld.add_visual_effect_at_time(_builder.raw_pos(), 0, [0,1,0], client_time, _build_recipe_spec['start_effect'], true, null);
    }
    return ui_tag;
}

// cancel crafting job "p_bus"
// note that p_bus may not be the exact same object that's in the queue (due to client-side prediction) - match by ui_tag / attempt_id if possible
function do_cancel_crafting(builder, p_bus) {
    var craft_queue = builder.get_crafting_queue();
    var index;
    var bus = null;
    var match_kind = null, match_val = null;
    for(index = 0; index < craft_queue.length; index++) {
        var b = craft_queue[index];
        if('ui_tag' in p_bus['craft']) {
            if(b['craft']['ui_tag'] == p_bus['craft']['ui_tag']) {
                match_kind = 'ui_tag';
                match_val = p_bus['craft']['ui_tag'];
                bus = b;
                break;
            }
        } else if('attempt_id' in p_bus['craft']) {
            if(b['craft']['attempt_id'] == p_bus['craft']['attempt_id']) {
                match_kind = 'attempt_id';
                match_val = p_bus['craft']['attempt_id'];
                bus = b;
                break;
            }
        } else {
            if(b['craft']['recipe'] == p_bus['craft']['recipe']) {
                match_kind = 'index';
                match_val = index;
                bus = b;
                break;
            }
        }
    }
    if(!bus) { // no match
        console.log('do_cancel_crafting(): cannot find '+JSON.stringify(p_bus));
        return;
    }

    var spellarg = {'recipe':bus['craft']['recipe']};
    spellarg[match_kind] = match_val;
    send_to_server.func(["CAST_SPELL", builder.id, "CANCEL_CRAFT", spellarg]);

    // client-side predict what will happen
    craft_queue = builder.start_client_prediction('crafting.queue', builder.crafting ? builder.crafting['queue'] : []);
    craft_queue.splice(index,1);
    if(builder.repair_finish_time < 0 && !builder.is_damaged()) {
        _update_crafting(craft_queue, -1);
    }
    goog.object.forEach(gamedata['resources'], function(res, resname) {
        var cost = Math.floor(gamedata['manufacture_cancel_refund']*(bus['craft']['cost'][resname]||0));
        player.resource_state[resname][1] += cost;
    });
}

function cancel_unfinished_crafting(builder) {
    while(builder.is_crafting()) {
        var queue = builder.get_crafting_queue();
        var did_cancel = false;
        for(var i = 0; i < queue.length; i++) {
            var bus = queue[i];
            var prog = (bus['done_time'] + (bus['start_time'] > 0 ? (server_time - bus['start_time']) : 0))/bus['total_time'];
            if(prog >= 1) { continue; } // skip finished jobs
            did_cancel = true;
            do_cancel_crafting(builder, bus);
            break;
        }
        if(!did_cancel) { // we're done
            break;
        }
    }
}

/** @param {SPUI.Dialog} dialog */
function update_crafting_dialog_status_grid_weapons(dialog) {
    var page = dialog.user_data['page'];
    var dims = dialog.data['widgets']['grid_slot']['array'];
    var category = dialog.user_data['category'];
    for(var row = 0; row < dims[1]; row++) {
        dialog.widgets['row_labels' + row.toString()].str = (page + 1 + row).toString();
        for(var col = 0; col < dims[0]; col++) {
            crafting_dialog_status_grid_weapons_cell_setup(dialog, [col,row]);
        }
    }
    var tag_map;
    if(category == 'mines') {
        tag_map = session.minefield_tags_by_tag;
    } else if (category == 'ambushes') {
        tag_map = session.ambush_point_tags_by_tag;
    } else {
        throw Error('Unhandled category in grid weapons: ' + category);
    }
    // ensures rowdata has enough entries to fill the default grid, enough entries for each mine or ambush point,
    // and enough entries to be divisible by the number of columns
    var total_rows = (goog.object.getCount(tag_map) > dims[0] * dims[1] ? Math.ceil(goog.object.getCount(tag_map) / dims[0]) : dims[1]);
    var last_page = Math.max(total_rows - dims[1], 0);
    dialog.user_data['last_page'] = last_page;
    dialog.widgets['scroll_up'].show = dialog.widgets['scroll_down'].show = (last_page > 0);
    dialog.widgets['scroll_up'].state = (page === 0 ? 'disabled' : 'normal');
    dialog.widgets['scroll_down'].state = (page === last_page ? 'disabled' : 'normal');
    dialog.widgets['scroll_up'].onclick = function(w) {
        var _dialog = w.parent;
        scroll_crafting_dialog_status_grid_weapons(_dialog, - 1);
    };
    dialog.widgets['scroll_down'].onclick = function(w) {
        var _dialog = w.parent;
        scroll_crafting_dialog_status_grid_weapons(_dialog, + 1);
    };
}

/** @param {SPUI.Dialog} dialog
    @param {number} delta */
function scroll_crafting_dialog_status_grid_weapons(dialog, delta) {
    var page = dialog.user_data['page'];
    var last_page = dialog.user_data['last_page'];
    if(delta < 0 && page > 0) {
        dialog.user_data['page'] = page - 1;
    }
    if (delta > 0 && page < last_page) {
        dialog.user_data['page'] = page + 1;
    }
}

/** @param {SPUI.Dialog} dialog */
function update_crafting_dialog_status_missiles(dialog) {
    var dims = dialog.data['widgets']['missile_slot']['array'];
    var builder = dialog.parent.user_data['builder'];
    var category = dialog.parent.user_data['category'];
    var catspec = gamedata['crafting']['categories'][category];
    var selected_rec = dialog.parent.user_data['selected_recipe'];
    var selected_recipe = (selected_rec ? dialog.parent.user_data['selected_recipe']['spec'] : null);
    var selected_recipe_spec = (selected_recipe ? gamedata['crafting']['recipes'][selected_recipe] : null);
    var selected_mine = (selected_recipe_spec ? ItemDisplay.get_crafting_recipe_product_spec(selected_recipe_spec)['name'] : null);
    var selected_mine_spec = (selected_mine ? ItemDisplay.get_inventory_item_spec(selected_mine) : null);
    var selected_mine_level = (selected_mine ? player.tech[selected_mine_spec['associated_tech']] || 1 : null);

    var craft_queue = (builder ? builder.get_crafting_queue() : []);
    var num_slots = 0; // number of slots we currently have
    var max_slots = 0; // max number of slots we could have if FULLY upgraded
    var num_ready = 0; // number of slots that have an item completed and equipped

    dialog.parent.user_data['on_use_recipe'] = null; // default action when clicking the recipe on the left

    for(var y = 0; y < dims[1]; y++) {
        for(var x = 0; x < dims[0]; x++) {
            var wname = x.toString()+','+y.toString();
            var obj = null; // object for this delivery slot
            var delivery_slot_type = catspec['delivery_slot_type'];
            var delivery_slot_index;
            var multiple_delivery_slots;
            var pending = false;
            var cur_mine_item = null;
            var cur_config = null;
            var cur_config_level = null;

            if(builder) {
                if(category == 'missiles') {
                    obj = find_object_by_type(catspec['delivery_building_for_ui']);
                    multiple_delivery_slots = true;
                    delivery_slot_index = y*dims[0] + x; // XXX assumes you only have one delivery building
                    var delivery_building_spec = gamedata['buildings'][catspec['delivery_building_for_ui']];
                    max_slots = get_leveled_quantity(delivery_building_spec['equip_slots'][delivery_slot_type], get_max_level(delivery_building_spec));
                    if(obj) {
                        cur_mine_item = (obj.equipment && (delivery_slot_type in obj.equipment) && obj.equipment[delivery_slot_type].length > delivery_slot_index ? player.decode_equipped_item(obj.equipment[delivery_slot_type][delivery_slot_index]) : null);
                        cur_config = (obj.config && (delivery_slot_type in obj.config) && obj.config[delivery_slot_type].length > delivery_slot_index && (obj.config[delivery_slot_type][delivery_slot_index] in gamedata['items']) ? obj.config[delivery_slot_type][delivery_slot_index] : null);
                    }
                } else {
                    throw Error('unhandled category '+category);
                }
            }
            if(obj && (!multiple_delivery_slots || (delivery_slot_index <= max_slots-1))) {
                // slot exists (now, or if fully upgraded)
                num_slots += 1;

                pending = !obj.is_in_sync(); // || !builder.is_in_sync();
                dialog.widgets['missile_slot'+wname].state = 'normal';

                var in_progress_recipe = null, in_progress_level = null, in_progress_bus = null, in_progress_togo = -1;
                for(var i = 0; i < craft_queue.length; i++) {
                    var entry = craft_queue[i];
                    if(entry['craft']['delivery'] && entry['craft']['delivery']['obj_id'] == obj.id &&
                       (!('slot_type' in entry['craft']['delivery']) || entry['craft']['delivery']['slot_type'] == delivery_slot_type) &&
                       ((entry['craft']['delivery']['slot_index']||0) == delivery_slot_index)) {
                        in_progress_recipe = entry['craft']['recipe'];
                        in_progress_level = (entry['craft']['level'] || 1);
                        in_progress_bus = entry;
                        in_progress_togo = entry['total_time'] - entry['done_time'];
                        if(entry['start_time'] > 0) {
                            in_progress_togo -= Math.max(0, server_time - entry['start_time']);
                        }
                        break;
                    }
                }

                dialog.widgets['missile_icon'+wname].show =
                    dialog.widgets['missile_frame'+wname].show =
                    dialog.widgets['missile_cancel'+wname].show = true;
                dialog.widgets['missile_icon'+wname].state = 'normal';
                dialog.widgets['missile_skull'+wname].show =
                    dialog.widgets['missile_timer'+wname].show = false;

                var build_mine = cur_config || selected_mine || null;
                var build_recipe = null;
                if(build_mine) {
                    if(build_mine == selected_mine) {
                        build_recipe = selected_recipe;
                    } else {
                        // look up the recipe for a DIFFERENT mine
                        for(var n in gamedata['crafting']['recipes']) {
                            var rec = gamedata['crafting']['recipes'][n];
                            if(rec['crafting_category'] == category && ItemDisplay.get_crafting_recipe_product_spec(rec)['name'] == build_mine) {
                                build_recipe = n; break;
                            }
                        }
                    }
                }
                var build_recipe_spec = (build_recipe ? gamedata['crafting']['recipes'][build_recipe] : null);

                var build_cb = null;
                var build_error_ui_text = null;

                if(build_recipe_spec) {
                    var build_recipe_max_level = (build_recipe_spec['max_level'] || 1);
                    var build_recipe_associated_tech = (build_recipe_spec['associated_tech'] || false);
                    var build_recipe_level = 1;
                    if((build_recipe_max_level || 1) > 1 && build_recipe_associated_tech && player.tech[build_recipe_associated_tech]) {
                        build_recipe_level = player.tech[build_recipe_associated_tech];
                    }
                    var can_cast = can_cast_spell_detailed(builder.id, 'CRAFT_FOR_FREE', [{'recipe': build_recipe_spec['name'], // XXX level
                                                                                           'delivery': {'obj_id':obj.id, 'slot_type':delivery_slot_type, 'slot_index': delivery_slot_index}}]);
                    if(can_cast[0]) {
                        // the real build function
                        build_cb = (function (_builder, _build_recipe_spec, _obj, _delivery_slot_index, _build_recipe_level) { return function() {
                            var extra_params = {'delivery': {'obj_id':_obj.id, 'slot_type':delivery_slot_type, 'slot_index': _delivery_slot_index}, 'level': _build_recipe_level };
                            start_crafting(_builder, _build_recipe_spec, extra_params);
                            // play sound effect
                            GameArt.play_canned_sound('action_button_134px');
                            return true;
                        }; })(builder, build_recipe_spec, obj, delivery_slot_index, build_recipe_level);
                    } else {
                        build_error_ui_text = can_cast[1];
                        // get helper function
                        if(can_cast[2]) {
                            var helper = get_requirements_help(can_cast[2][0], can_cast[2][1], can_cast[2][2]);
                            build_cb = (helper ? (function (_helper) { return function() { _helper(); return false; }; })(helper) : null);
                        }
                    }
                }

                var unconfig_cb = (function (_obj, _delivery_slot_type, _delivery_slot_index, _multiple) { return function(w) {
                    var new_config = (_obj.config ? goog.object.clone(_obj.config) : {});
                    if(_multiple) {
                        if(!new_config[_delivery_slot_type]) {
                            new_config[_delivery_slot_type] = [];
                        }
                        while(new_config[_delivery_slot_type].length < _delivery_slot_index) {
                            new_config[_delivery_slot_type].push(null);
                        }
                        new_config[_delivery_slot_type][_delivery_slot_index] = null;
                    } else {
                        if(_delivery_slot_type in new_config) { delete new_config[_delivery_slot_type]; }
                        if(goog.object.getCount(new_config) <= 0) { new_config = null; }
                    }
                    send_to_server.func(["CAST_SPELL", _obj.id, "CONFIG_SET", new_config]);
                    // client-side predict
                    _obj.config = new_config;
                    _obj.request_sync();
                }; })(obj, delivery_slot_type, delivery_slot_index, multiple_delivery_slots);

                if(cur_mine_item) {
                    var cur_mine_spec = ItemDisplay.get_inventory_item_spec(cur_mine_item['spec']);
                    var cur_mine_level = cur_mine_item['level'] || 1;
                    num_ready += 1;
                    dialog.widgets['missile_icon'+wname].alpha = 1;
                    dialog.widgets['missile_icon'+wname].asset = get_leveled_quantity(cur_mine_spec['icon'], cur_mine_level);
                    dialog.widgets['missile_frame'+wname].onclick = null;
                    dialog.widgets['missile_frame'+wname].tooltip.str = dialog.data['widgets']['missile_frame']['ui_tooltip_armed'].replace('%s', cur_mine_spec['ui_name']);
                    dialog.widgets['missile_cancel'+wname].show = !(('can_unequip' in cur_mine_spec) && !cur_mine_spec['can_unequip']);
                    dialog.widgets['missile_cancel'+wname].tooltip.str = dialog.data['widgets']['missile_cancel']['ui_tooltip_discard'].replace('%s', cur_mine_spec['ui_name']);
                    dialog.widgets['missile_cancel'+wname].onclick = (function (_obj, _cur_mine_item, _delivery_slot_type, _delivery_slot_index, _unconfig_cb) { return function(w) {
                        send_to_server.func(["EQUIP_BUILDING", _obj.id, [_delivery_slot_type,_delivery_slot_index], -1, null, _cur_mine_item, -1]);
                        // maybe put a confirmation dialog here?
                        invoke_ui_locker();
                        _unconfig_cb();
                    }; })(obj, cur_mine_item, delivery_slot_type, delivery_slot_index, unconfig_cb);
                } else if(in_progress_recipe) {
                    dialog.widgets['missile_icon'+wname].asset = get_leveled_quantity(get_crafting_recipe_icon(gamedata['crafting']['recipes'][in_progress_recipe]), in_progress_level);
                    dialog.widgets['missile_icon'+wname].alpha = 1;
                    dialog.widgets['missile_frame'+wname].onclick = null;
                    dialog.widgets['missile_frame'+wname].tooltip.str = dialog.data['widgets']['missile_frame']['ui_tooltip_inprogress'].replace('%s', ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_crafting_recipe_product_spec(gamedata['crafting']['recipes'][in_progress_recipe])));
                    dialog.widgets['missile_cancel'+wname].tooltip.str = dialog.data['widgets']['missile_cancel']['ui_tooltip_cancel'];
                    dialog.widgets['missile_cancel'+wname].onclick = (function (_builder, _in_progress_bus, _unconfig_cb) { return function(w) {
                        do_cancel_crafting(_builder, _in_progress_bus);
                        _unconfig_cb();
                    }; })(builder, in_progress_bus, unconfig_cb);
                    dialog.widgets['missile_timer'+wname].show = true;
                    dialog.widgets['missile_timer'+wname].str = pretty_print_time_brief(in_progress_togo);
                } else if(cur_config) {
                    var cur_config_spec = gamedata['items'][cur_config];
                    dialog.widgets['missile_icon'+wname].asset = get_leveled_quantity(cur_config_spec['icon'], cur_config_level);
                    dialog.widgets['missile_icon'+wname].state = 'icon_disabled';
                    dialog.widgets['missile_icon'+wname].alpha = 0.33;
                    dialog.widgets['missile_skull'+wname].show = true;
                    dialog.widgets['missile_frame'+wname].onclick = build_cb;
                    dialog.widgets['missile_frame'+wname].tooltip.str = dialog.data['widgets']['missile_frame']['ui_tooltip_produce'].replace('%s', cur_config_spec['ui_name']);
                    dialog.widgets['missile_cancel'+wname].onclick = unconfig_cb;

                    if(!dialog.parent.user_data['on_use_recipe'] && selected_mine_spec == cur_config_spec) {
                        dialog.parent.user_data['on_use_recipe'] = build_cb;
                    }

                } else if(selected_mine_spec) {
                    dialog.widgets['missile_icon'+wname].alpha = 0.33;
                    dialog.widgets['missile_icon'+wname].asset = get_leveled_quantity(selected_mine_spec['icon'], selected_mine_level);
                    dialog.widgets['missile_icon'+wname].show = (dialog.widgets['missile_frame'+wname].mouse_enter_time > 0) && (dialog.widgets['missile_cancel'+wname].mouse_enter_time < 0);
                    dialog.widgets['missile_frame'+wname].tooltip.str = dialog.data['widgets']['missile_frame']['ui_tooltip_produce'].replace('%s', selected_mine_spec['ui_name']);
                    var build_and_config_cb;
                    if(('persist_config' in catspec) && !catspec['persist_config']) {
                        build_and_config_cb = build_cb; // no persistence
                    } else {
                        build_and_config_cb = (function (_obj, _selected_mine_spec, _delivery_slot_type, _delivery_slot_index, _multiple, _build_cb) { return function(w) {
                        if(_build_cb && _build_cb()) {
                            var new_config = _obj.config || {};
                            if(_multiple) {
                                if(!new_config[_delivery_slot_type]) { new_config[_delivery_slot_type] = []; }
                                while(new_config[_delivery_slot_type].length < _delivery_slot_index) {
                                    new_config[_delivery_slot_type].push(null);
                                }
                                new_config[_delivery_slot_type][_delivery_slot_index] = _selected_mine_spec['name'];
                            } else {
                                new_config[_delivery_slot_type] = _selected_mine_spec['name'];
                            }
                            send_to_server.func(["CAST_SPELL", _obj.id, "CONFIG_SET", new_config]);
                            // client-side predict config
                            _obj.config = new_config;
                            _obj.request_sync();
                        }
                        }; })(obj, selected_mine_spec, delivery_slot_type, delivery_slot_index, multiple_delivery_slots, build_cb);
                    }
                    dialog.widgets['missile_frame'+wname].onclick = build_and_config_cb;
                    dialog.widgets['missile_cancel'+wname].show = false;

                    if(!dialog.parent.user_data['on_use_recipe']) {
                        dialog.parent.user_data['on_use_recipe'] = build_and_config_cb;
                    }
                } else {
                    dialog.widgets['missile_icon'+wname].show =
                        dialog.widgets['missile_frame'+wname].show =
                        dialog.widgets['missile_cancel'+wname].show = false;
                }

                dialog.widgets['missile_pending'+wname].show = pending;
                if(pending) {
                    dialog.widgets['missile_frame'+wname].onclick = null;
                }
            } else if(delivery_slot_index < max_slots) {
                // minefield does not exist
                dialog.widgets['missile_icon'+wname].show =
                    dialog.widgets['missile_skull'+wname].show =
                    dialog.widgets['missile_timer'+wname].show =
                    dialog.widgets['missile_frame'+wname].show =
                    dialog.widgets['missile_cancel'+wname].show =
                    dialog.widgets['missile_pending'+wname].show = false;
                dialog.widgets['missile_slot'+wname].state = 'locked';

                // Valentina help to do what you need to do to unlock another slot
                // XXXXXX port this to a get_requirements_help('equip_slot', delivery_slot_type) call?
                var help_pred = null;
                var slot_building = gamedata['crafting']['categories'][category]['delivery_building_for_ui'];
                var slot_building_spec = gamedata['buildings'][slot_building];
                if('limit_requires' in slot_building_spec) {
                    // minefield-style buildings where you build more to open slots
                    help_pred = {'predicate':'BUILDING_QUANTITY', 'building_type':slot_building, 'trigger_qty': count_objects_by_type(slot_building)+1};
                    dialog.widgets['missile_slot'+wname].tooltip.str = dialog.data['widgets']['missile_slot']['ui_tooltip_build_more'].replace('%s', slot_building_spec['ui_name']);
                } else {
                    // missile-style buildings where you upgrade a building to open slots
                    var b = find_object_by_type(slot_building);
                    if(!b) { throw Error('not slot_building '+slot_building); }
                    help_pred = {'predicate':'BUILDING_LEVEL', 'building_type':slot_building, 'trigger_level': b.level + 1};
                    dialog.widgets['missile_slot'+wname].tooltip.str = dialog.data['widgets']['missile_slot']['ui_tooltip_upgrade'].replace('%s', slot_building_spec['ui_name']);
                }

                var helper = null;
                if(help_pred && dialog.widgets['missile_slot'+wname].show) {
                    helper = function (use_short_circuit) { return function() {
                        var h = get_requirements_help(read_predicate(/** @type {!Object} */ (help_pred)), null, {short_circuit:use_short_circuit});
                        if(h) { h(); }
                    }; };
                }
                dialog.widgets['missile_slot'+wname].onclick = (helper ? helper(true) : null);
                if(!dialog.parent.user_data['on_use_recipe']) {
                    dialog.parent.user_data['on_use_recipe'] = (helper ? helper(false) : null);
                }
            } else {
                // cannot ever exist
                dialog.widgets['missile_icon'+wname].show =
                    dialog.widgets['missile_skull'+wname].show =
                    dialog.widgets['missile_timer'+wname].show =
                    dialog.widgets['missile_frame'+wname].show =
                    dialog.widgets['missile_cancel'+wname].show =
                    dialog.widgets['missile_slot'+wname].show =
                    dialog.widgets['missile_pending'+wname].show = false;
            }
        }
    }

    // hide arrows below the final visible slot row
    if('arrow0' in dialog.widgets) {
        for(var i = 0; i < dialog.data['widgets']['arrow']['array'][1]; i++) {
            var wname = 'arrow'+i.toString();
            dialog.widgets[wname].show = (max_slots >= i*dialog.data['widgets']['missile_slot']['array'][0] + 1);
        }
    }

    if('num_ready' in dialog.widgets) {
        dialog.widgets['num_ready'].show = !!builder;
        dialog.widgets['num_ready'].str = dialog.data['widgets']['num_ready']['ui_name'].replace('%max', num_slots.toString()).replace('%cur', num_ready.toString()).replace('%s', catspec['ui_name']);
    }
}

/** @param {SPUI.Dialog} dialog */
function update_crafting_dialog_status_merge_items(dialog) {
    var builder = dialog.parent.user_data['builder'];
    var pending = (builder && !builder.is_in_sync());
    var craft_queue = (builder ? builder.get_crafting_queue() : []);

    dialog.parent.user_data['on_use_recipe'] = null; // default action when clicking the recipe on the left

    var in_progress_recipe = null, in_progress_recipe_level = null, in_progress_bus = null, in_progress_togo = -1;
    goog.array.forEach(craft_queue, function(entry) {
        if(gamedata['crafting']['recipes'][entry['craft']['recipe']]['crafting_category'] == 'leaders' || gamedata['crafting']['recipes'][entry['craft']['recipe']]['crafting_category'] == 'ambushes' || gamedata['crafting']['recipes'][entry['craft']['recipe']]['crafting_category'] == 'equips') {
            // since there is no queueing, there should only be one of these
            in_progress_recipe = entry['craft']['recipe'];
            in_progress_bus = entry;
            in_progress_recipe_level = entry['craft']['level'] || 1;
            in_progress_togo = entry['total_time'] - entry['done_time'];
            if(entry['start_time'] > 0) {
                in_progress_togo -= Math.max(0, server_time - entry['start_time']);
            }
        }
    });

    var selected_rec = dialog.parent.user_data['selected_recipe'];
    var selected_recipe = (selected_rec ? selected_rec['spec'] : null);
    var selected_recipe_spec = (selected_recipe ? gamedata['crafting']['recipes'][selected_recipe] : null);
    var selected_recipe_level = (selected_rec ? selected_rec['level'] : null);

    dialog.widgets['leader_icon'].state = 'normal';
    dialog.widgets['leader_timer'].show = false;

    dialog.widgets['arrow'].show =
        dialog.widgets['leader_prompt'].show = (!!builder && dialog.parent.user_data['recipes'] && dialog.parent.user_data['recipes'].length > 0);

    dialog.widgets['leader_slot'].show =
        dialog.widgets['leader_icon'].show =
        dialog.widgets['leader_frame'].show =(!!builder && ((dialog.parent.user_data['recipes'] && dialog.parent.user_data['recipes'].length > 0) || in_progress_recipe));

    var build_cb = null;
    var build_error_ui_text = null;

    if(builder && selected_recipe) {
        var can_cast = can_cast_spell_detailed(builder.id, 'CRAFT_FOR_FREE', [{'recipe': selected_rec['spec'],
                                                                               'level': selected_rec['level'] || 1}]);
        if(can_cast[0]) {
            // the real build function
            build_cb = (function (_builder, _selected_recipe_spec, _selected_rec_level) { return function() {
                start_crafting(_builder, _selected_recipe_spec, {'level': _selected_rec_level});
                // play sound effect
                GameArt.play_canned_sound('action_button_134px');
                return true;
            }; })(builder, selected_recipe_spec, selected_rec['level'] || 1);
        } else {
            build_error_ui_text = can_cast[1];
            // get helper function
            if(can_cast[2]) {
                var helper = get_requirements_help(can_cast[2][0], can_cast[2][1], can_cast[2][2]);
                build_cb = (helper ? (function (_helper) { return function() { _helper(); return false; }; })(helper) : null);
            }
        }
    }

    // note that this may be unknown_crafting_product for randomized recipes
    var selected_leader_spec = (selected_recipe_spec ? ItemDisplay.get_crafting_recipe_product_spec(selected_recipe_spec, selected_recipe_level) : null);

    if(in_progress_recipe) {
        dialog.widgets['leader_icon'].asset = get_crafting_recipe_icon(gamedata['crafting']['recipes'][in_progress_recipe], in_progress_recipe_level);
        dialog.widgets['leader_icon'].alpha = 1;
        dialog.widgets['leader_frame'].onclick = null;
        dialog.widgets['leader_frame'].tooltip.str = dialog.data['widgets']['leader_frame']['ui_tooltip_inprogress'].replace('%s', ItemDisplay.get_inventory_item_ui_name_long(ItemDisplay.get_crafting_recipe_product_spec(gamedata['crafting']['recipes'][in_progress_recipe], in_progress_recipe_level)));
        dialog.widgets['leader_frame'].tooltip.text_color = SPUI.default_text_color;
        dialog.widgets['leader_cancel'].show = true;
        dialog.widgets['leader_cancel'].tooltip.str = dialog.data['widgets']['leader_cancel']['ui_tooltip_cancel'];
        dialog.widgets['leader_cancel'].onclick = (function (_builder, _in_progress_bus) { return function(w) {
            do_cancel_crafting(_builder, _in_progress_bus);
        }; })(builder, in_progress_bus);
        dialog.widgets['leader_timer'].show = true;
        dialog.widgets['leader_timer'].str = pretty_print_time_brief(in_progress_togo);
    } else if(selected_leader_spec) {
        dialog.widgets['leader_icon'].alpha = 0.33;
        dialog.widgets['leader_icon'].asset = selected_leader_spec['icon'];
        dialog.widgets['leader_icon'].show = (dialog.widgets['leader_icon'].mouse_enter_time > 0) && (dialog.widgets['leader_cancel'].mouse_enter_time < 0);
        dialog.widgets['leader_frame'].tooltip.str = build_error_ui_text || dialog.data['widgets']['leader_frame']['ui_tooltip_produce'].replace('%s', ItemDisplay.get_inventory_item_ui_name_long(selected_leader_spec));
        dialog.widgets['leader_frame'].tooltip.text_color = (build_error_ui_text ? SPUI.error_text_color : SPUI.default_text_color);
        dialog.widgets['leader_frame'].onclick = build_cb;
        dialog.widgets['leader_cancel'].show = false;
        if(!dialog.parent.user_data['on_use_recipe']) {
            dialog.parent.user_data['on_use_recipe'] = build_cb;
        }
    } else {
        dialog.widgets['leader_cancel'].show = false;
    }

    // if out of sync, show spinner and disable clicks
    dialog.widgets['leader_pending'].show = pending;
    if(pending) {
        dialog.widgets['leader_frame'].onclick = dialog.widgets['leader_cancel'].onclick = null;
    }
}

function invoke_fishing_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['fishing_dialog']);
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.user_data['dialog'] = 'fishing_dialog';
    dialog.user_data['builder'] = find_object_by_type(get_workshop_for('fishing'));
    dialog.user_data['open_metric_sent'] = false;

    // standard scrollable dialog stuff
    dialog.user_data['rowfunc'] = update_fishing_dialog_row;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['row']['array'][1];
    dialog.user_data['page'] = -1;

    // format of rowdata and collections:
    // {recipe: (pointer to recipe data), bus: (crafting queue entry, may be null),
    //  ui_priority: (display order), time: (collections only - time collected), state: (complete/inprogress/idle)}
    dialog.user_data['rowdata'] = [];
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;

    dialog.user_data['collections'] = []; // list of jobs that were just collected and are displaying animation (see CRAFT_COMPLETE handler)
    dialog.user_data['ui_priority_overrides'] = {}; // mapping of bus['craft']['ui_tag'] -> ui_priority to keep rows in place across state transitions

    dialog.user_data['ui_priority_base_counter'] = 0;
    dialog.user_data['ui_priority_bases'] = {}; // mapping of recipe name to base value of ui_priority - used because sometimes these are randomized per player

    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name'].replace('%BUILDING', gamedata['buildings'][get_workshop_for('fishing')]['ui_name']);
    dialog.widgets['help_button'].onclick = function(w) {
        invoke_child_message_dialog(w.data['ui_tooltip'], w.data['ui_message'], {'dialog':'message_dialog_big'});
    };
    dialog.widgets['notify_choice'].show = (spin_frame_platform == 'fb');

    dialog.ondraw = update_fishing_dialog;
    update_fishing_dialog(dialog);
    scrollable_dialog_change_page(dialog, 0);
}

function fishing_dialog_get_ui_priority(dialog, recipe) {
    var bases = dialog.user_data['ui_priority_bases'];
    if(!(recipe['name'] in bases)) {
        var p = eval_cond_or_literal(recipe['ui_priority'], player, null);
        if(p < 0) { // randomize, but do it stably (because the recipe order is shuffled stably in update_fishing_dialog)
            p = dialog.user_data['ui_priority_base_counter'];
            dialog.user_data['ui_priority_base_counter'] += 1;
        }
        bases[recipe['name']] = p;
    }
    return bases[recipe['name']];
}

function update_notification_choice_button(w, pref_key, config_name) {
    var notifications_enabled = get_preference_setting(player.preferences, pref_key);
    w.state = (notifications_enabled ? 'active' : 'normal');
    if(!get_preference_setting(player.preferences, 'enable_fb_notifications')) {
        // warn that the global switch disables it
        w.text_color = SPUI.make_colorv(w.data['text_color_hidden']);
        w.tooltip.str = w.data['ui_tooltip_hidden'];
        w.onclick = (function (_pref_key) { return function(w) {
            player.quest_tracked_dirty = true;
            var s = gamedata['errors']['NOTIFICATIONS_DISABLED'];
            invoke_child_message_dialog(s['ui_title'], s['ui_name'], {'dialog': s['dialog'],
                                                                      'on_ok': (function (__pref_key) { return function() {
                                                                          player.preferences['enable_fb_notifications'] = 1;
                                                                          player.preferences[__pref_key] = 1;
                                                                          send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
                                                                          send_to_server.func(["RESET_NOTIFICATION", 'ALL']);
                                                                      }; })(_pref_key),
                                                                      'ok_button_ui_name': s['ui_button'],
                                                                      'cancel_button': true});
        }; })(pref_key);
    } else {
        w.text_color = SPUI.make_colorv(w.data['text_color']);
        w.tooltip.str = null;
        w.onclick = (function (_pref_key, _config_name) { return function(w) {
            player.quest_tracked_dirty = true;
            player.preferences[_pref_key] = (w.state == 'active' ? 0 : 1);
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
            if(player.preferences[_pref_key] &&
               gamedata['fb_notifications']['notifications'][_config_name]) {
                send_to_server.func(["RESET_NOTIFICATION", gamedata['fb_notifications']['notifications'][_config_name]['ref']]);
            }
            invoke_ui_locker();
        }; })(pref_key, config_name);
    }
}

/** @param {SPUI.Dialog} dialog */
function update_fishing_dialog(dialog) {
    update_notification_choice_button(dialog.widgets['notify_choice'], 'enable_fishing_notifications', 'fishing_complete');

    var builder = dialog.user_data['builder'];
    dialog.user_data['rowdata'] = [];

    if(!player.cooldown_active('fish_slate_assigned')) {
        if(!player.cooldown_active('fish_slate_assign_pending')) {
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "FISH_SLATE_ASSIGN"]);
            player.cooldown_client_trigger('fish_slate_assign_pending', 999);
        }
        dialog.widgets['topbar_text'].str = dialog.data['widgets']['topbar_text']['ui_name_pending'];
        dialog.widgets['loading_rect'].show = dialog.widgets['loading_text'].show = dialog.widgets['loading_spinner'].show = true;
        dialog.widgets['no_recipes'].show = false;
    } else {
        if(!dialog.user_data['open_metric_sent'] && gamedata['crafting']['categories']['fishing']['log_ui_events']) {
            dialog.user_data['open_metric_sent'] = true;
            var time_left = (builder.is_crafting() ? Math.floor(builder.crafting_time_left_one()) : 0);
            var slate_id = player.cooldowns['fish_slate_assigned']['data']['slate'];
            metric_event('5154_fish_open_dialog', {'sum': player.get_denormalized_summary_props('brief'), 'slate_id':slate_id, 'time_left': time_left});
        }

        var assign_time_togo = player.cooldown_togo('fish_slate_assigned');
        dialog.widgets['topbar_text'].str = dialog.data['widgets']['topbar_text']['ui_name'].replace('%REFRESH', pretty_print_time_brief(assign_time_togo));
        dialog.widgets['loading_rect'].show = dialog.widgets['loading_text'].show = dialog.widgets['loading_spinner'].show = false;

        // find current in-progress recipe and completed recipes
        if(builder.is_crafting()) {
            var craft_queue = builder.get_crafting_queue();
            for(var i = 0; i < craft_queue.length; i++) {
                var bus = craft_queue[i];
                var rec = gamedata['crafting']['recipes'][bus['craft']['recipe']];
                var cat = gamedata['crafting']['categories'][rec['crafting_category']];
                var prog = bus['done_time'] + (bus['start_time'] > 0 && bus['start_time'] < server_time ? (server_time - bus['start_time']) : 0);
                var state;
                if(('auto_collect' in cat) && !cat['auto_collect'] && prog >= bus['total_time']) {
                    state = 'complete';
                } else {
                    state = 'inprogress';
                }

                var ui_priority;

                if(/* state == 'inprogress' && */ bus['craft']['ui_tag'] in dialog.user_data['ui_priority_overrides']) {
                    // keep recipes in place after state transitions while dialog was open
                    ui_priority = dialog.user_data['ui_priority_overrides'][bus['craft']['ui_tag']];
                } else {
                    // list completed/queued recipes at end, in reverse queue order
                    ui_priority = 1000 - i;
                }
                dialog.user_data['rowdata'].push({'recipe':rec, 'bus':bus, 'ui_priority': ui_priority, 'state': state})
            }
        }

        var all_recipes = goog.object.getValues(gamedata['crafting']['recipes']);
        goog.array.shuffle(all_recipes); // permute order so that fishing_dialog_get_ui_priority assigns randomized priorities (stably per dialog open)
        goog.array.forEach(all_recipes, function(recipe) {
            if(recipe['crafting_category'] == 'fishing') {
                if(read_predicate(recipe['show_if']).is_satisfied(player, null)) {
                    dialog.user_data['rowdata'].push({'recipe':recipe, 'bus': null, 'ui_priority': fishing_dialog_get_ui_priority(dialog, recipe), 'state': 'idle'});
                }
            }
        });

        // add collected recipes
        var to_remove = [];
        goog.array.forEach(dialog.user_data['collections'], function(data) {
            if(client_time - data['time'] >= dialog.data['collection_time']) { to_remove.push(data); return; }
            dialog.user_data['rowdata'].push({'recipe': data['recipe'], 'bus': data['bus'], 'loot':data['loot'], 'ui_priority':data['ui_priority'], 'state':'collecting'});
        });
        goog.array.forEach(to_remove, function(x) { goog.array.remove(dialog.user_data['collections'], x); });

        // sort by ui_priority
        dialog.user_data['rowdata'].sort(function(x,y) {
            var px = x['ui_priority'];
            var py = y['ui_priority'];
            if(px < py) {
                return -1;
            } else if(px > py) {
                return 1;
            }
            return 0;
        });

        dialog.widgets['no_recipes'].show = (dialog.user_data['rowdata'].length == 0);
        if(dialog.widgets['no_recipes'].show) {
            dialog.widgets['no_recipes'].str = dialog.data['widgets']['no_recipes']['ui_name'].replace('%REFRESH', pretty_print_time_brief(assign_time_togo));
        }
    }

    scrollable_dialog_change_page(dialog, dialog.user_data['page']);
}

function update_fishing_dialog_row(parent_dialog, row, rowdata) {
    var dialog = parent_dialog.widgets['row'+row.toString()];
    dialog.show = (rowdata !== null);
    if(!rowdata) { return; }

    var builder = dialog.parent.user_data['builder'];
    var recipe = rowdata['recipe'];
    var recipe_level = 1;
    var cat = gamedata['crafting']['categories'][recipe['crafting_category']];
    var bus = rowdata['bus'] || null;

    var state = rowdata['state'];
    var helper = null;
    var help_tip = null;

    var can_speedup = player.crafting_speedups_enabled();
    if(can_speedup) {
        if(('speedupable' in cat) && !cat['speedupable']) {
            can_speedup = false;
        }
    }

    // special-case idle recipes
    if(state == 'idle') {
        if(builder.is_crafting() && builder.crafting_time_left_one() >= 0) {
            // another operation is already in progress
            state = 'disabled';
            help_tip = 'inprogress';
            if(can_speedup) {
                helper = function() { invoke_child_speedup_dialog('crafting'); };
            }
        } else if(builder.is_crafting() && builder.get_crafting_queue().length >= builder.get_leveled_quantity(builder.spec['crafting_queue_space'])) {
            // no operation in progress, but there is no queue space
            state = 'disabled';
            help_tip = 'must_collect';
            helper = function() { invoke_child_message_dialog(dialog.data['widgets']['start_button']['ui_tooltip_must_collect'],
                                                              dialog.data['widgets']['start_button']['ui_must_collect_descr'].replace('%d', builder.get_leveled_quantity(builder.spec['crafting_queue_space']).toString()), {'dialog': 'message_dialog_big'});
                                };

        } else {
            state = 'idle';
        }
    }

    dialog.widgets['bg'].color = SPUI.make_colorv(dialog.data['widgets']['bg'][('color_'+state in dialog.data['widgets']['bg'] ? 'color_'+state : 'color')]);
    dialog.widgets['bg'].outline_color = SPUI.make_colorv(dialog.data['widgets']['bg'][('outline_color_'+state in dialog.data['widgets']['bg'] ? 'outline_color_'+state : 'outline_color')]);
    dialog.widgets['name'].str = dialog.data['widgets']['name']['ui_name_'+state].replace('%RECIPE', recipe['ui_name']);

    // parse recipe products. If awaiting collection and item is melting, display "decayed" duration
    var products = goog.array.map(recipe['product'], function(item) {
        var ret = {'spec': item['spec']};
        if('stack' in item) { ret['stack'] = item['stack']; }
        if('item_duration' in item) {
            var dur = item['item_duration'];
            if(bus && ('creation_time' in bus) && (state == 'complete' || state == 'collecting')) {
                // XXX this doesn't account for stoppage due to building damage - see note in server.py: do_collect_craft_one()
                var end_time = bus['creation_time'] + bus['total_time'];
                dur = dur - (server_time - end_time);
            }
            ret['item_duration'] = dur;
        }
        return ret;
    });

    // display reward names
    var reward_str = goog.array.map(products, function(item) {
        var stack = ('stack' in item ? item['stack'] : 1);
        var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
        var ret;
        // special case: use full-precision stack count for fungible items instead of stack_prefix
        if(spec['fungible'] && stack != 1) {
            ret = pretty_print_number(stack)+' '+ItemDisplay.get_inventory_item_ui_name(spec);
        } else {
            ret = ItemDisplay.get_inventory_item_stack_prefix(spec, stack) + ItemDisplay.get_inventory_item_ui_name(spec);
        }
        if('item_duration' in item) {
            if(item['item_duration'] >= 0) {
                ret += ' '+dialog.data['widgets']['descr']['ui_name_expires'].replace('%s', pretty_print_time(item['item_duration']));
            } else {
                ret += ' '+dialog.data['widgets']['descr']['ui_name_expired'];
            }
        }
        return ret;
    }).join(' + ');
    dialog.widgets['descr'].str = reward_str;

    goog.array.forEach(['name','descr','reward_label'], function(n) {
        var key = 'text_color_'+state;
        dialog.widgets[n].text_color = SPUI.make_colorv(dialog.data['widgets'][n][(key in dialog.data['widgets'][n] ? key : 'text_color')]);
    });

    for(var i = 0; i < dialog.data['widgets']['reward_item']['array'][0]; i++) { dialog.widgets['reward_item'+i.toString()].widgets['frame'].onclick = null; }
    // display reward items
    ItemDisplay.display_item_array(dialog, 'reward_item', products, {context_parent: dialog.parent});
    for(var i = 0; i < dialog.data['widgets']['reward_item']['array'][0]; i++) {
        dialog.widgets['reward_expires'+i.toString()].show = (i < products.length && ('item_duration' in products[i]));
        if(dialog.widgets['reward_item'+i.toString()].show) {
            dialog.widgets['reward_item'+i.toString()].widgets['frame'].state = (state == 'collecting' ? 'disabled' : 'normal_nohighlight');
        }
        dialog.widgets['reward_spinner'+i.toString()].show = (dialog.widgets['reward_item'+i.toString()].show && state == 'collecting');
    }

    dialog.widgets['timer'].show = (state == 'inprogress');
    if(dialog.widgets['timer'].show) {
        dialog.widgets['timer'].str = pretty_print_time(builder.crafting_time_left_one());
    }
    dialog.widgets['progress_bar'].show = (state == 'inprogress' || state == 'complete' || state == 'collecting');
    if(dialog.widgets['progress_bar'].show) {
        var prog = ((state == 'complete' || state == 'collecting') ? 1 : 1 - builder.crafting_time_left_one()/get_leveled_quantity(recipe['craft_time'], recipe_level));
        dialog.widgets['progress_bar'].progress = 0.2 + 0.8 * prog; // artificially boost by 20% at start
    }

    dialog.widgets['reward_label'].show = !dialog.widgets['timer'].show;

    dialog.widgets['expire_timer'].show = false; // (state == 'idle' || state == 'disabled');
    if(dialog.widgets['expire_timer'].show) {
        dialog.widgets['expire_timer'].str = dialog.data['widgets']['expire_timer']['ui_name'].replace('%s', pretty_print_time(player.cooldown_togo('fish_slate_assigned')));
    }

    // buttons
    if(state == 'inprogress') {
        dialog.widgets['finish_button'].show = dialog.widgets['price_display'].show = true;
        dialog.widgets['start_button'].show = dialog.widgets['collect_button'].show = false;

        if(!can_speedup) {
            dialog.widgets['price_display'].show = dialog.widgets['finish_button'].show = false;
            if(!(('cancelable' in cat) && !cat['cancelable'])) {
                dialog.widgets['cancel_button'].show = true;
                dialog.widgets['cancel_button'].onclick = (function (_builder, _cat, _bus) { return function (w) {
                    invoke_confirm_cancel_message(_cat['confirm_cancel_kind'] || 'crafting', (function (__builder, __bus) {
                        return function() {
                            do_cancel_crafting(__builder, __bus);
                        }; })(_builder, _bus));
                }; })(builder, cat, bus);
            } else {
                dialog.widgets['cancel_button'].show = false;
            }
        } else {
            dialog.widgets['price_display'].show = dialog.widgets['finish_button'].show = true;
            dialog.widgets['cancel_button'].show = false;

            var closure;

            if(builder && !builder.is_in_sync()) {
                closure = null;
                dialog.widgets['finish_button'].state = 'disabled';
                dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name_pending'];
                dialog.widgets['finish_button'].text_offset = dialog.data['widgets']['finish_button']['text_offset_pending'];
                dialog.widgets['finish_button'].tooltip.str = '';
                dialog.widgets['price_display'].str = '';
            } else {
                // note: SPEEDUP_FOR_MONEY will repair the factory rather than speed up production if factory is damaged
                dialog.widgets['finish_button'].state = 'normal';
                dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'+(builder.is_damaged() ? '_repair' : '')];
                dialog.widgets['finish_button'].text_offset = dialog.data['widgets']['finish_button']['text_offset'];

                var price = Store.get_user_currency_price(builder.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null);
                dialog.widgets['price_display'].str = Store.display_user_currency_price(price) + ' ' + Store.gamebucks_ui_name(); // PRICE
                dialog.widgets['finish_button'].tooltip.str = Store.display_user_currency_price_tooltip(price);

                if(price == 0) {
                    closure = (function(_builder) { return function(w) {
                        var dialog = w.parent;
                        send_to_server.func(["CAST_SPELL", _builder.id, "SPEEDUP_FOR_FREE"]);
                        invoke_ui_locker(_builder.request_sync(), function() { /* change_selection(null); */ });
                    }; })(builder);
                } else if(price > 0) {
                    closure = (function(_builder) { return function(w) {
                        var dialog = w.parent;
                        var cleanup_cb = (function (_dialog) { return function() {
                            // change_selection(null);
                        }; })(dialog);

                        if(Store.place_user_currency_order(_builder.id, "SPEEDUP_FOR_MONEY", null, cleanup_cb)) {
                            invoke_ui_locker(_builder.request_sync(), function() {
                                //change_selection(null);
                            });
                        }
                    };})(builder)
                } else {
                    // invalid order?
                    if(builder.is_damaged() && !builder.is_repairing()) {
                        closure = (function (obj) { return function() {
                            change_selection(obj); invoke_repair_dialog();
                        }; })(builder);
                    } else {
                        closure = null;
                        dialog.widgets['finish_button'].state = 'disabled';
                    }
                }
            }
            dialog.widgets['price_display'].onclick =
                dialog.widgets['finish_button'].onclick = closure;
        }
    } else if(state == 'complete') {
        dialog.widgets['finish_button'].show = dialog.widgets['price_display'].show = dialog.widgets['start_button'].show = dialog.widgets['cancel_button'].show = false;
        dialog.widgets['collect_button'].show = true;

        // check storage space limit
        var res = null, excess = null;
        goog.array.forEach(recipe['product'], function(item) {
            if('spec' in item) {
                var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
                if(spec['fungible'] && spec['resource'] in gamedata['resources']) {
                    var stack = ('stack' in item ? item['stack'] : 1);
                    if(player.resource_state[spec['resource']][1] + stack > player.resource_state[spec['resource']][0]) {
                        res = spec['resource'];
                        excess = player.resource_state[res][1] + stack - player.resource_state[res][0];
                    }
                }
            }
        });

        if(excess) {
            dialog.widgets['collect_button'].state = 'green_disabled';
            dialog.widgets['collect_button'].str = dialog.data['widgets']['collect_button']['ui_name'];
            dialog.widgets['collect_button'].tooltip.str = gamedata['errors']['STORAGE_LIMIT']['ui_name']; // dialog.data['widgets']['collect_button']['ui_tooltip_storage_limit'];
            dialog.widgets['collect_button'].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['collect_button'].onclick = (function (_res, _excess) { return function(w) {
                var helper = get_requirements_help('need_more_storage', _res);
                if(helper) { helper(); }
            }; })(res, excess);
        } else {
            dialog.widgets['collect_button'].state = 'green';
            dialog.widgets['collect_button'].str = dialog.data['widgets']['collect_button']['ui_name'];
            dialog.widgets['collect_button'].tooltip.str = null;
            dialog.widgets['collect_button'].onclick = (function (_builder, _bus, _rowdata) { return function(w) {
                var dialog = w.parent;
                GameArt.play_canned_sound('xp_gain_sound');

                send_to_server.func(["CAST_SPELL", _builder.id, "COLLECT_CRAFT", [_bus['craft']['attempt_id']]]);
                var queue = _builder.start_client_prediction('crafting.queue', _builder.crafting ? _builder.crafting['queue'] : []);
                // client-side predict what will happen
                for(var i = 0; i < queue.length; i++) {
                    var b = queue[i];
                    if(b['craft']['attempt_id'] == _bus['craft']['attempt_id']) {
                        // simulate loot based on predictable items
                        var recipe = gamedata['crafting']['recipes'][b['craft']['recipe']];
                        var loot = goog.array.filter(recipe['product'], function(entry) { return 'spec' in entry; } );
                        var data = {'time': client_time, 'recipe': gamedata['crafting']['recipes'][b['craft']['recipe']], 'bus': b, 'ui_priority': _rowdata['ui_priority'], 'loot':loot};
                        dialog.parent.user_data['collections'].push(data);
                        queue.splice(i,1);
                        break;
                    }
                }
                //invoke_ui_locker(_builder.request_sync()); // not necessary with client-side prediction
            }; })(builder, bus, rowdata);
        }
    } else if(state == 'collecting') {
        dialog.widgets['finish_button'].show = dialog.widgets['price_display'].show = dialog.widgets['start_button'].show = dialog.widgets['cancel_button'].show = false;
        dialog.widgets['collect_button'].show = true;
        dialog.widgets['collect_button'].state = 'green_disabled';
        dialog.widgets['collect_button'].str = dialog.data['widgets']['collect_button']['ui_name_collecting'];
        dialog.widgets['collect_button'].onclick = null;
        if(!dialog.user_data['collect_text']) {
            dialog.user_data['collect_text'] = true;
            var is_fungible = false;
            goog.array.forEach(rowdata['loot'], function(item) {
                var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
                if(spec['fungible']) {
                    is_fungible = true;
                }
            });
            if(is_fungible) {
                var str = gamedata['strings']['combat_messages']['adding_to_storage'];
                ItemDisplay.add_inventory_item_effect(session.get_draw_world().fxworld, dialog.widgets['reward_item0'].widgets['frame'], str, [1,1,1,1]);
            }
        }
    } else {
        dialog.widgets['finish_button'].show = dialog.widgets['price_display'].show = dialog.widgets['collect_button'].show = dialog.widgets['cancel_button'].show = false;
        dialog.widgets['start_button'].show = true;
        if(help_tip) {
            dialog.widgets['start_button'].tooltip.str = dialog.data['widgets']['start_button']['ui_tooltip_'+help_tip];
            dialog.widgets['start_button'].tooltip.text_color = SPUI.error_text_color;
        } else {
            dialog.widgets['start_button'].tooltip.str = null;
        }
        dialog.widgets['start_button'].str = dialog.data['widgets']['start_button']['ui_name'].replace('%TIME', pretty_print_time_brief(get_leveled_quantity(recipe['craft_time'], recipe_level)));
        if(state == 'idle') {
            dialog.widgets['start_button'].state = 'normal';
            dialog.widgets['start_button'].onclick = (function (_builder, _recipe) { return function(w) {
                var dialog = w.parent;
                var ui_priority = fishing_dialog_get_ui_priority(dialog.parent, _recipe); // go back to the original recipe here (for metrics)
                var ui_tag = start_crafting(_builder, _recipe, {'ui_index': ui_priority});
                // client-side prediction for the per-SKU cooldown
                if('on_start' in recipe && recipe['on_start']['consequent'] == 'COOLDOWN_TRIGGER' && recipe['on_start']['duration_from_cooldown']) {
                    player.cooldown_client_trigger(recipe['on_start']['name'], player.cooldown_togo(recipe['on_start']['duration_from_cooldown']));
                }
                dialog.parent.user_data['ui_priority_overrides'][ui_tag] = ui_priority;
                invoke_ui_locker(_builder.request_sync());
                GameArt.play_canned_sound('action_button_134px');
            }; })(builder, recipe);
        } else {
            dialog.widgets['start_button'].state = (helper ? 'disabled_clickable' : 'disabled');
            dialog.widgets['start_button'].onclick = helper;
        }
    }

    dialog.widgets['collect_spinner'].show = (state == 'collecting');
}

var last_research_dialog_category = null;

/** @param {(string|null)=} parent_category
    @param {string=} newcategory
    @param {number=} newpage */
function invoke_research_dialog(parent_category, newcategory, newpage) {
    // note: assumes the research lab is already selected

    if(last_research_dialog_category === null) {
        last_research_dialog_category = gamedata['strings']['research_categories']['army'][0]['name'];
    }

    // if parent category is not provided, find it
    if(!parent_category) {
        if(!newcategory) { throw Error('neither parent_category or newcategory was provided'); }
        for(var p in gamedata['strings']['research_categories']) {
            var entry = goog.array.find(gamedata['strings']['research_categories'][p], function(entry) {
                return (entry['name'] == newcategory);
            });
            if(entry) {
                parent_category = p;
                break;
            }
        }
    }
    if(!newcategory) { // pick a reasonable default
        if(last_research_dialog_category && goog.array.find(gamedata['strings']['research_categories'][parent_category],
                                                            function(entry) { return entry['name'] == last_research_dialog_category; })) {
            newcategory = last_research_dialog_category;
        } else {
            newcategory = gamedata['strings']['research_categories'][parent_category][0]['name'];
        }
    }

    var dialog_data = gamedata['dialogs']['research_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'research_dialog';
    dialog.user_data['parent_category'] = parent_category;
    dialog.user_data['category'] = newcategory;
    dialog.widgets['close_button'].onclick = function() { change_selection(null); };

    dialog.widgets['dev_title'].show = player.is_cheater;

    if('ui_name_'+parent_category in dialog.data['widgets']['title']) {
        dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name_'+parent_category];
    } // otherwise, this is set in change_category

    dialog.widgets['army_dialog_buttons_army'].show = (parent_category == 'army');
    dialog.widgets['army_dialog_buttons_crafting'].show = (parent_category == 'crafting');
    dialog.widgets['army_dialog_buttons_leaders'].show = (parent_category == 'leaders');
    if(parent_category) {
        init_army_dialog_buttons(dialog.widgets['army_dialog_buttons_'+parent_category], parent_category, 'research_dialog');
    }

    // set up category buttons
    var i = 0;
    var cat_list = goog.array.filter(gamedata['strings']['research_categories'][parent_category], function(entry) {
        if('show_if' in entry && !read_predicate(entry['show_if']).is_satisfied(player, null)) { return false; }
        return !!get_lab_for(entry['name']);
    });
    var used = cat_list.length;
    goog.array.forEach(cat_list, function(entry) {
        // manually compute X coordinate to center all the visible buttons
        var x = Math.floor(dialog.wh[0]/2 + (i - used/2) * dialog.data['widgets']['category_button']['array_offset'][0] + dialog.data['widgets']['category_button']['xy'][0]);
        dialog.widgets['category_button'+i.toString()].xy = [x, dialog.data['widgets']['category_button']['xy'][1]];

        dialog.widgets['category_button'+i.toString()].str = entry['ui_name'];
        dialog.widgets['category_button'+i.toString()].onclick = function(w) { research_dialog_change_category(w.parent, entry['name']); };
        i++;
        if(i >= dialog.data['widgets']['category_button']['array'][0]) { throw Error('not enough category_button array entries!'); }
    });
    while(i < dialog.data['widgets']['category_button']['array'][0]) {
        dialog.widgets['category_button'+i.toString()].show = false;
        i++;
    }
    dialog.user_data['category_list'] = cat_list;

    dialog.widgets['scroll_left'].onclick = function(w) { dialog.user_data['scrolled'] = true; research_dialog_scroll(w.parent, w.parent.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function(w) { dialog.user_data['scrolled'] = true; research_dialog_scroll(w.parent, w.parent.user_data['page']+1); };

    dialog.ondraw = update_research_dialog;
    research_dialog_change_category(dialog, newcategory, newpage || 0);
}

/** @param {SPUI.Dialog} dialog
    @param {string} category
    @param {number=} num page to scroll to */
function research_dialog_change_category(dialog, category, num)
{
    dialog.user_data['category'] = category;
    last_research_dialog_category = dialog.user_data['category'];
    init_army_dialog_buttons(dialog.widgets['army_dialog_buttons_'+dialog.user_data['parent_category']], dialog.user_data['parent_category'], 'research_dialog', category);

    var page_ui_name = null;
    goog.array.forEach(gamedata['strings']['research_categories'][dialog.user_data['parent_category']], function(entry) {
        if(entry['name'] == category) {
            page_ui_name = entry['ui_name'];
        }
    });

    dialog.user_data['techs'] = null;
    dialog.user_data['scrolled'] = false;
    dialog.user_data['open_time'] = client_time;

    goog.array.forEach(dialog.user_data['category_list'], function(entry, i) {
        var w = dialog.widgets['category_button'+i.toString()];
        w.text_color = (category === entry['name'] ? SPUI.default_text_color : SPUI.disabled_text_color);
        w.state = (category === entry['name'] ? 'active' : 'normal');
    });

    var builder_type = get_lab_for(category);

    if(!('ui_name_'+dialog.user_data['parent_category'] in dialog.data['widgets']['title'])) {
        dialog.widgets['title'].str = gamedata['buildings'][builder_type]['ui_name'];
    }

    // check for presence of research lab
    var builder = find_object_by_type(builder_type);
    dialog.user_data['builder'] = builder;

    dialog.widgets['coverup_all'].show =
        dialog.widgets['coverup_text'].show =
        dialog.widgets['coverup_icon'].show =
        dialog.widgets['coverup_button'].show = (!builder && !player.is_cheater);

    if(!builder && !player.is_cheater) {
        // research lab not present - show instructions for building research lab
        dialog.widgets['coverup_text'].str = dialog.data['widgets']['coverup_text']['ui_name'].replace('%verb', gamedata['spells']['RESEARCH_FOR_FREE']['ui_dialog_name']).replace('%s1', page_ui_name).replace('%s2', gamedata['buildings'][builder_type]['ui_name_indefinite']);
        dialog.widgets['coverup_icon'].asset = get_leveled_quantity(gamedata['buildings'][builder_type]['art_asset'], 1);
        // special-case because some buildings are really tall
        dialog.widgets['coverup_icon'].xy = vec_add(dialog.data['widgets']['coverup_icon']['xy'], (gamedata['buildings'][builder_type]['hero_icon_pos'] || [0,0]));
        var helper = get_requirements_help(read_predicate({'predicate':'BUILDING_QUANTITY', 'building_type':builder_type, 'trigger_qty':1}), null, {short_circuit:true});
        dialog.widgets['coverup_button'].onclick = (helper ? helper : function() { invoke_build_dialog('production'); });

    } else {
        // fill in grid of technologies
        dialog.user_data['techs'] = [];
        // only sort if at least one item has ui_priority (otherwise leave in JSON order)
        var use_priority_sort = false;

        for(var name in gamedata['tech']) {
            var spec = gamedata['tech'][name];
            if(spec['research_category'] != category) {
                continue;
            }
            if((spec['developer_only'] || spec['ui_priority'] === -1) && (spin_secure_mode || !player.is_cheater)) { continue; }

            if('show_if' in spec && !read_predicate(spec['show_if']).is_satisfied(player, null)) { continue; }
            if('activation' in spec && !read_predicate(spec['activation']).is_satisfied(player, null)) { continue; }

            // only show techs associated with unit production when in army mode
            if(!('associated_unit' in spec) && dialog.user_data['parent_category'] == 'army') { continue; }

            dialog.user_data['techs'].push(name);
            if('ui_priority' in spec) { use_priority_sort = true; }
        }

        if(use_priority_sort) {
            dialog.user_data['techs'].sort(function(a, b) {
                // first sort by ui_priority high to low
                var ui_priority_a = gamedata['tech'][a]['ui_priority'] || 0;
                var ui_priority_b = gamedata['tech'][b]['ui_priority'] || 0;
                if(ui_priority_a < ui_priority_b) {
                    return 1;
                } else if(ui_priority_a > ui_priority_b) {
                    return -1;
                }
                return 0;
            });
        }
    }

    if(player.upgrade_bar_enabled()) {
        UpgradeBar.invoke(dialog, 'building', (builder ? builder.spec['name'] : null), (builder ? builder.level+1 : -1), (builder ? builder.id : null));
    }

    research_dialog_scroll(dialog, num || 0);
}

function research_dialog_scroll(dialog, page) {
    var grid_x = 0, grid_y = 0;
    dialog.user_data['techs_by_widget'] = null;
    var builder = dialog.user_data['builder'];

    var chapter_techs = (dialog.user_data['techs'] ? dialog.user_data['techs'].length : 0);
    var techs_per_page = dialog.data['widgets']['grid']['array'][0]*dialog.data['widgets']['grid']['array'][1];
    var chapter_pages = Math.floor((chapter_techs+techs_per_page-1)/techs_per_page);
    dialog.user_data['page'] = page = (chapter_techs === 0 ? 0 : clamp(page, 0, chapter_pages-1));

    if(chapter_pages > 0) {
        dialog.user_data['techs_by_widget'] = {};
        var first_tech_on_page = page * techs_per_page;
        var last_tech_on_page = Math.max(0, Math.min((page+1)*techs_per_page-1, chapter_techs-1));
        for(var i = first_tech_on_page; i <= last_tech_on_page; i++) {
            var name = dialog.user_data['techs'][i];
            var spec = gamedata['tech'][name];
            //  current research level and limit
            var current = (name in player.tech ? player.tech[name] : 0);
            var limit = get_max_ui_level(spec);

            var widget_name = grid_x.toString() +',' + grid_y.toString();
            var widget = dialog.widgets['grid'+widget_name];
            dialog.user_data['techs_by_widget'][widget_name] = name;

            if(spec['associated_unit']) {
                var unit_spec = gamedata['units'][spec['associated_unit']];
                if('splash_image' in unit_spec) {
                    widget.bg_image = get_leveled_quantity(unit_spec['splash_image'], Math.min(current+1, limit));
                    widget.transform = dialog.data['widgets']['grid']['transform_splash_image'];
                } else {
                    widget.bg_image = get_leveled_quantity(unit_spec['art_asset'], Math.min(current+1, limit));
                    widget.transform = null;
                }
                widget.alpha = unit_spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1;
            } else if('icon' in spec) {
                widget.bg_image = get_leveled_quantity(spec['icon'], Math.min(current+1, limit));
                widget.transform = null;
            }

            widget.show = true;
            dialog.widgets['grid_glow'+widget_name].show = true;
            dialog.widgets['grid_label'+widget_name].str = spec['ui_name'];
            dialog.widgets['grid_label'+widget_name].show = true;
            dialog.widgets['grid_status'+widget_name].show = true;

            var tooltip_text = [];
            var able_to_research = true;
            var unlocked = true;



            // limit on tech level
            if(current >= limit) {
                able_to_research = false;
                tooltip_text.push(gamedata['errors']['MAX_LEVEL_REACHED']['ui_name']);
            } else if(builder && builder.is_damaged()) {
                able_to_research = false;
                tooltip_text.push(gamedata['errors']['LAB_DAMAGED']['ui_name']);
            } else {
                // research time
                var research_time = Math.floor(get_leveled_quantity(spec['research_time'], current+1) / (dialog.user_data['builder'] ? dialog.user_data['builder'].get_stat('research_speed',1) : 1));
                tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_unlocks_in'].replace('%s',pretty_print_time(research_time)));

                // minimum resoure amounts
                for(var res in gamedata['resources']) {
                    var resdata = gamedata['resources'][res];
                    var min_quant = get_leveled_quantity(spec['cost_'+res] || 0, current+1);
                    var player_quant = player.resource_state[res][1];
                    if(player_quant < min_quant) {
                        able_to_research = false;
                    }
                    tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_requires_res'].replace('%d',pretty_print_number(min_quant)).replace('%res',resdata['ui_name']));
                }

                // get list of any unsatisfied requirements
                var req = null;
                if(('requires' in spec) && !player.is_cheater) {
                    var pred = read_predicate(get_leveled_quantity(spec['requires'], current+1));
                    req = pred.ui_describe(player);
                }
                if(req) {
                    tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_requires'].replace('%s', req));
                    able_to_research = false;
                    if(current === 0) {
                        unlocked = false;
                    }
                }
            }

            // bring up the tech upgrade dialog
            widget.onclick = (function(bname) {
                return function(w) {
                    var dialog = w.parent;
                    // play sound effect
                    if(1) {
                        var state = /** @type {!GameArt.Sprite} */ (GameArt.assets['action_button_134px'].states['normal']);
                        if(state.audio) { state.audio.play(client_time); }
                    }
                    change_selection_unit(null); // clear unit selection, since we may have selected something unrelated to the tech
                    invoke_upgrade_tech_dialog(bname, (function (_cat,_page) { return function() {
                        invoke_research_dialog(null,_cat,_page);
                    }; })(dialog.user_data['category'],dialog.user_data['page']));
                };
            })(name);

            widget.tooltip.str = null;
            widget.tooltip.text_color = SPUI.default_text_color;

            grid_x += 1;
            if(grid_x >= dialog.data['widgets']['grid']['array'][0]) {
                grid_x = 0; grid_y += 1;
            }
        }
        dialog.widgets['scroll_text'].show = true;
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_tech_on_page+1).toString()).replace('%d2',(last_tech_on_page+1).toString()).replace('%d3',chapter_techs.toString());
    } else {
        dialog.widgets['scroll_text'].show = false;
    }

    // clear out empty widgets
    while(grid_y < dialog.data['widgets']['grid']['array'][1]) {
        while(grid_x < dialog.data['widgets']['grid']['array'][0]) {
            var widget_name = grid_x.toString() + ',' + grid_y.toString();
            dialog.widgets['grid_price'+widget_name].show = false;
            dialog.widgets['grid'+widget_name].bg_image = null;
            dialog.widgets['grid'+widget_name].show = false;
            dialog.widgets['grid_glow'+widget_name].show = false;
            dialog.widgets['grid_label'+widget_name].show = false;
            dialog.widgets['grid_status'+widget_name].show = false;
            grid_x += 1;
        }
        grid_x = 0;
        grid_y += 1;
    }

    dialog.widgets['scroll_left'].state = (page != 0 ? 'normal' : 'disabled');
    dialog.widgets['scroll_right'].state = ((page < chapter_pages-1) ? 'normal' : 'disabled');
    player.quest_tracked_dirty = true;
}

// responsible for updating "grid_status", "grid_price" "grid_finish_button" only
/** @param {SPUI.Dialog} dialog */
function update_research_dialog(dialog) {
    if(!dialog.user_data['techs_by_widget']) { return; }

    if(!dialog.user_data['scrolled'] &&
       ((client_time - dialog.user_data['open_time']) < gamedata['store']['store_scroll_flash_time']) &&
       player.get_any_abtest_value('enable_store_scroll_flash', gamedata['store']['enable_store_scroll_flash'])) {
        if(dialog.widgets['scroll_right'].state != 'disabled') {
            dialog.widgets['scroll_right'].state = ((((client_time/gamedata['store']['store_scroll_flash_period']) % 1) >= 0.5) ? 'highlight' : 'normal');
        }
    }

    // mapping of techs -> labs working on it
    var under_research = {};
    session.for_each_real_object(function(obj) {
        if(obj.is_building() && obj.is_researcher() && obj.team == 'player' && obj.is_researching()) {
            under_research[obj.research_item] = obj;
        }
    });

    var grid_x = 0, grid_y = 0;

    while(grid_y < dialog.data['widgets']['grid']['array'][1]) {
        while(grid_x < dialog.data['widgets']['grid']['array'][0]) {
            var widget_name = grid_x.toString() +',' + grid_y.toString();

            dialog.widgets['grid_price'+widget_name].bg_image = player.get_any_abtest_value('price_display_short_asset', gamedata['store']['price_display_short_asset']);
            dialog.widgets['grid_price'+widget_name].state = Store.get_user_currency();

            if(dialog.user_data['techs_by_widget'] && widget_name in dialog.user_data['techs_by_widget'] && dialog.user_data['techs_by_widget'][widget_name] in under_research) {
                // tech is currently under research
                var tech_name = dialog.user_data['techs_by_widget'][widget_name];
                var tech = gamedata['tech'][tech_name];
                var lab = under_research[tech_name];
                var current = player.tech[tech_name] || 0;

                dialog.widgets['grid'+widget_name].state = 'normal';
                dialog.widgets['grid'+widget_name].rotating = (!lab.is_damaged());
                var height = (tech['associated_unit'] && gamedata['units'][tech['associated_unit']]['flying'] ? -2*gamedata['units'][tech['associated_unit']]['altitude'] : 0);
                dialog.widgets['grid'+widget_name].bg_image_offset[1] = dialog.data['widgets']['grid']['bg_image_offset_'+(tech['associated_unit'] ? 'unit':'icon')][1] + height + dialog.data['widgets']['grid']['finish_shift'][1];

                dialog.widgets['grid_label'+widget_name].text_color = SPUI.default_text_color;

                dialog.widgets['grid_progress'+widget_name].show = false;
                dialog.widgets['grid_price'+widget_name].show =
                    dialog.widgets['grid_finish_button'+widget_name].show = true;

                dialog.widgets['grid_finish_button'+widget_name].str = dialog.data['widgets']['grid_finish_button']['ui_name'+(lab.is_damaged() ? '_repair' : '')];

                var cb, display_price, display_tooltip = '';
                if(lab.is_damaged()) {
                    dialog.widgets['grid_status'+widget_name].str = dialog.data['widgets']['grid_status']['ui_name_repair'];
                    display_price = dialog.data['widgets']['grid_price']['ui_name_start'];
                    cb = (function(_lab) { return function() {
                        change_selection_unit(_lab);
                        if(_lab.is_damaged() && !_lab.is_repairing()) {
                            invoke_repair_dialog();
                        } else {
                            invoke_child_speedup_dialog('research');
                        }
                    }; })(lab);
                } else {
                    dialog.widgets['grid_status'+widget_name].str = dialog.data['widgets']['grid_status']['ui_name_inprogress'].replace('%d',(current+1).toString()).replace('%s',pretty_print_time_brief(lab.research_time_left()));
                    var price = Store.get_user_currency_price(lab.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null);
                    if(price == 0) {
                        cb = (function(_lab) { return function() {
                            change_selection_unit(_lab);
                            send_to_server.func(["CAST_SPELL", _lab.id, "SPEEDUP_FOR_FREE"]);
                            invoke_ui_locker(_lab.request_sync());
                        }; })(lab);
                    } else if(price > 0) {
                        cb = (function(_lab) { return function(widget) {
                            change_selection_unit(_lab);
                            if(Store.place_user_currency_order(_lab.id, "SPEEDUP_FOR_MONEY", null, function() { change_selection(null); })) {
                                widget.state = 'disabled';
                                var _dialog = widget.parent;
                                widget.str = _dialog.data['widgets']['grid_finish_button']['ui_name_pending'];
                                invoke_ui_locker(_lab.request_sync());
                            }
                        } })(lab);
                    } else {
                        cb = null;
                    }
                    display_price = Store.display_user_currency_price(price, 'compact'); // PRICE
                    display_tooltip = Store.display_user_currency_price_tooltip(price);
                }

                dialog.widgets['grid_price'+widget_name].str = display_price;
                dialog.widgets['grid_price'+widget_name].tooltip.str = display_tooltip;
                dialog.widgets['grid_price'+widget_name].onclick =
                    dialog.widgets['grid_finish_button'+widget_name].onclick = cb;

                dialog.widgets['grid_status'+widget_name].text_color = (lab.is_damaged() ? SPUI.error_text_color : SPUI.default_text_color);
            } else {
                var unlocked = true;
                if(dialog.user_data['techs_by_widget'] && widget_name in dialog.user_data['techs_by_widget']) {
                    // present but not under research
                    var tech_name = dialog.user_data['techs_by_widget'][widget_name];
                    var tech = gamedata['tech'][tech_name];
                    var current = player.tech[tech_name] || 0;
                    var limit = get_max_ui_level(tech);
                    var req = null;

                    if('requires' in tech && !read_predicate(get_leveled_quantity(tech['requires'], 1)).is_satisfied(player, null) && !player.is_cheater) {
                        unlocked = false; req = true;
                    } else if(current < limit) {
                        req = !read_predicate(get_leveled_quantity(tech['requires'], current+1)).is_satisfied(player, null);
                    } else {
                        req = true;
                    }

                    var height = (tech['associated_unit'] && gamedata['units'][tech['associated_unit']]['flying'] ? -2*gamedata['units'][tech['associated_unit']]['altitude'] : 0);
                    dialog.widgets['grid'+widget_name].bg_image_offset[1] = dialog.data['widgets']['grid']['bg_image_offset_'+(tech['associated_unit'] ? 'unit':'icon')][1] + height;

                    var tsize = dialog.widgets['grid_status'+widget_name].data['text_size'];
                    if(current == 0) {
                        dialog.widgets['grid_status'+widget_name].str = dialog.data['widgets']['grid_status']['ui_name_click_to_unlock'];
                        dialog.widgets['grid_status'+widget_name].font = SPUI.make_font(tsize, tsize+3, 'normal');
                    } else {
                        dialog.widgets['grid_status'+widget_name].str = dialog.data['widgets']['grid_status']['ui_name_level'].replace('%cur',current.toString()).replace('%max',limit.toString());
                        dialog.widgets['grid_status'+widget_name].font = SPUI.make_font(tsize, tsize+3, 'normal');
                    }

                    dialog.widgets['grid_status'+widget_name].text_color = (current >= limit) ? SPUI.disabled_text_color : (current==0 && req ? SPUI.disabled_text_color : (current ==0 && !req ? SPUI.make_colorv([1,1,0,1]) : SPUI.default_text_color));
                    dialog.widgets['grid_label'+widget_name].text_color = ((current >= limit) ? SPUI.disabled_text_color : SPUI.default_text_color);

                    dialog.widgets['grid_progress'+widget_name].show = (current > 0) && (current < limit);
                    if(dialog.widgets['grid_progress'+widget_name].show) {
                        dialog.widgets['grid_progress'+widget_name].progress = current/limit;
                        dialog.widgets['grid_progress'+widget_name].full_color = SPUI.make_colorv(dialog.data['widgets']['grid_progress']['full_color'+(current>=limit?'_done':'')]);
                    }
                } else {
                    // not present
                    dialog.widgets['grid_status'+widget_name].str = '';
                    dialog.widgets['grid_progress'+widget_name].show = false;
                }

                if(dialog.widgets['grid'+widget_name].bg_image) {
                    // check for support for the new normal_disabled sprite state
                    var asset = GameArt.assets[dialog.widgets['grid'+widget_name].bg_image];
                    var disabled_state = ('normal_disabled' in asset.states ? 'normal_disabled' : ('icon_disabled' in asset.states ? 'icon_disabled' : null));
                    dialog.widgets['grid'+widget_name].state = (!unlocked && disabled_state) ? disabled_state : 'normal';
                    dialog.widgets['grid'+widget_name].rotating = false;
                    dialog.widgets['grid'+widget_name].xy[1] = dialog.data['widgets']['grid']['xy'][1] + grid_y*dialog.data['widgets']['grid']['array_offset'][1];
                }

                dialog.widgets['grid_price'+widget_name].show = false;
                dialog.widgets['grid_finish_button'+widget_name].show = false;
            }
            grid_x += 1;
        }
        grid_x = 0;
        grid_y += 1;
    }
};

/** @param {boolean=} do_animation
    @param {Object=} preselect_quest */
function invoke_missions_dialog(do_animation, preselect_quest) {
    change_selection(null);

    player.update_quest_cache(true);

    var dialog_data = gamedata['dialogs']['missions_dialog'];

    // instantiate the dialog
    var dialog = new SPUI.Dialog(dialog_data);

    // make the dialog modal and add it to the "desktop"
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'missions_dialog';
    dialog.user_data['anim_start_time'] = (do_animation ? client_time : -1);
    dialog.user_data['quest_list'] = [];
    dialog.user_data['fb_likes_time'] = -1; // time the Facebook likes_cache was last invalidated
    dialog.user_data['selected_row'] = -1; // index of selected row in UI
    dialog.user_data['just_completed_row'] = -1; // index of row for previous completed quest in UI
    dialog.user_data['visible_rows'] = dialog.data['widgets']['row']['array'][1]; // # visible rows in UI
    dialog.user_data['first_row'] = 0; // index of top row that appears in UI
    dialog.user_data['context'] = null; // reward inventory item tooltip
    dialog.widgets['close_button'].onclick = function() { change_selection(null); player.invalidate_quest_cache(); };
    dialog.widgets['scroll_left'].onclick = function(w) { var dialog = w.parent; missions_dialog_scroll(dialog, dialog.user_data['first_row']-dialog.user_data['visible_rows']); };
    dialog.widgets['scroll_right'].onclick = function(w) { var dialog = w.parent; missions_dialog_scroll(dialog, dialog.user_data['first_row']+dialog.user_data['visible_rows']); };

    dialog.widgets['missions_button'].onclick = null;
    dialog.widgets['messages_button'].onclick = function() { invoke_mail_dialog(false); };
    dialog.widgets['missions_button'].show =
        dialog.widgets['messages_button'].show = player.get_any_abtest_value('enable_inventory', gamedata['enable_inventory']);

    // quest re-evaluation is not done on redraw to save CPU
    update_missions_dialog(dialog);

    // but animation is
    dialog.ondraw = animate_valentina_dialog;

    if(player.tutorial_state === 'open_missions_dialog') {
        advance_tutorial();
        // start arrow
        player.quest_tracked = gamedata['quests']['reclaim_base'];
        player.quest_tracked_dirty = true;
    }

    if(preselect_quest) {
        var idx = goog.array.indexOf(dialog.user_data['quest_list'], preselect_quest);
        if(idx >= 0) {
            missions_dialog_scroll(dialog, idx);
            missions_dialog_select_mission(dialog, idx);
        }
    }
    return dialog;
}

// animate Missions dialog zooming out of Valentina
/** @param {SPUI.Dialog} dialog */
function animate_valentina_dialog(dialog) {
    // handle invalidation of FB likes cache
    if(dialog.user_data['selected_row'] >= 0 && dialog.user_data['selected_row'] < dialog.user_data['quest_list'].length) {
        var quest = dialog.user_data['quest_list'][dialog.user_data['selected_row']];
        // if currently selected quest is incomplete, and calls for FB like refreshes
        if(('ui_refresh_likes' in quest) && !player.can_complete_quest(quest) && (client_time - dialog.user_data['fb_likes_time'] >= quest['ui_refresh_likes'])) {
            dialog.user_data['fb_likes_time'] = client_time;
            //console.log("REFRESH LIKES");
            if(spin_facebook_enabled) {
                SPFB.invalidate_likes_cache((function (_dialog, _row, _quest) { return function() {
                    // after the update comes back, force quest cache update, and attempt to update the Missions dialog state
                    player.update_quest_cache(true);
                    if(selection.ui === _dialog) {
                        if(_dialog.user_data['selected_row'] === _row) {
                            update_missions_dialog(_dialog);
                            for(var i = 0; i < dialog.user_data['quest_list'].length; i++) {
                                if(dialog.user_data['quest_list'][i] === _quest) {
                                    missions_dialog_select_mission(dialog, i);
                                    break;
                                }
                            }
                        }
                    }
                }; })(dialog, dialog.user_data['selected_row'], quest));
            }
            // trigger a re-evaluation of the predicate
            player.refresh_quest_cache_entry(quest);
        }
    }

    // handle flashing scroll buttons
    if(dialog.user_data['scroll_left_flash'] && dialog.widgets['scroll_left'].state === 'normal') {
        var flash = (client_time % 1.0) > 0.5;
        dialog.widgets['scroll_left'].text_color = SPUI.make_colorv(dialog.data['widgets']['scroll_left']['text_color_normal'+(flash?'_flash':'')]);
    }

    // zoom out of quest bar, or valentina
    if('quest_bar' in desktop_dialogs && dialog.user_data['selected_row'] >= 0 && dialog.user_data['selected_row'] < player.active_quests.length) {
        // note: coupled to ordering of QuestBar widgets matching player.active_quests
        var wname = SPUI.get_array_widget_name('icon', desktop_dialogs['quest_bar'].data['widgets']['icon']['array'], [0,dialog.user_data['selected_row']]);
        if(wname in desktop_dialogs['quest_bar'].widgets) {
            animate_dialog_zoom_effect(dialog, desktop_dialogs['quest_bar'].widgets[wname]);
            return;
        }
    }
    var bottom = desktop_dialogs['desktop_bottom'];
    var valentina = (bottom ? bottom.widgets['missions_button'] : null);
    animate_dialog_zoom_effect(dialog, valentina);
}

function animate_dialog_zoom_effect(dialog, src_widget) {
    if(SPFX.detail < 2) { return; } // do not do this in low-detail mode
    if(!src_widget) { dialog.transform = null; return; }

    var ANIM_TIME = player.get_any_abtest_value('valentina_dialog_anim_time', gamedata['client']['valentina_dialog_anim_time']);
    if(ANIM_TIME < 0 || !('anim_start_time' in dialog.user_data) || dialog.user_data['anim_start_time'] < 0) { return; }

    var progress = clamp((client_time - dialog.user_data['anim_start_time'])/ANIM_TIME, 0, 1);
    dialog.modal = progress;
    if(progress >= 1) {
        dialog.transform = null;
    } else {
        progress = Math.pow(progress,2.0);
        var scale = progress;
        // centerpoint of scale effect
        var pivot = vec_add(dialog.xy, vec_scale(0.5, dialog.wh));
        // where centerpoint is at start of animation
        var startpos = vec_add(src_widget.get_absolute_xy(), vec_scale(0.5, src_widget.wh));
        // where centerpoint is at end of animation
        var endpos = pivot;
        //startpos = [0,0]; endpos = [0,0];
        var origin = vec_add(startpos, vec_scale(progress, vec_sub(endpos, startpos)));

        dialog.transform = [scale, 0,
                            0, scale,
                            origin[0] + scale*(-origin[0]), origin[1] + scale*(-origin[1])];
    }
}

// refresh missions dialog with a new quest list
// completely resets selection and scrolling
/** @param {SPUI.Dialog} dialog */
function update_missions_dialog(dialog) {

    if(dialog.widgets['messages_button'].show) {
        dialog.widgets['pending_missions_icon'].show =
            dialog.widgets['pending_missions_icon_glow'].show = (player.claimable_quests > 0);
        dialog.widgets['pending_messages_icon'].show =
            dialog.widgets['pending_messages_icon_glow'].show = player.has_unread_mail();
    }

    // re-show close button (though it may get hidden again immediately from the player.quest_tracked click-here tips)
    dialog.widgets['close_button'].show = true;

    var skip_tutorial = 'skip_tutorial' in player.preferences && player.preferences['skip_tutorial'];

    if(read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null) && player.get_any_abtest_value('skip_tutorial_button', gamedata['client']['skip_tutorial_button'])) {
        dialog.widgets['popup_button'].show = true;
        if(skip_tutorial) {
            // currently skipping
            dialog.widgets['popup_button'].state = 'normal';
            dialog.widgets['popup_button'].onclick = function(w) {
                var dialog = w.parent;
                tutorial_opt_in(player.quest_tracked);
                update_missions_dialog(dialog);
            };
        } else {
            // currently NOT skipping
            dialog.widgets['popup_button'].state = 'active';
            dialog.widgets['popup_button'].onclick = function(w) {
                var dialog = w.parent;
                tutorial_opt_out();
                update_missions_dialog(dialog);
            };
        }
    } else {
        dialog.widgets['popup_button'].show = false;
    }

    var enable_messages = read_predicate({'predicate': 'LIBRARY', 'name': 'enable_messages'});
    if(enable_messages.is_satisfied(player, null) || skip_tutorial) {
        dialog.widgets['messages_button'].state = 'normal';
        dialog.widgets['messages_button'].tooltip.str = null;
    } else {
        dialog.widgets['messages_button'].state = 'disabled';
        dialog.widgets['messages_button'].tooltip.str = dialog.data['widgets']['messages_button']['ui_tooltip_requires'].replace('%s', enable_messages.ui_describe(player));
    }

    // fill in list of missions

    // store a reference to all listed Quests inside the dialog so that we can
    // trace mouse clicks to the corresponding quest
    var pre_select = -1;
    dialog.user_data['quest_list'] = [];
    for(var i = 0; i < player.active_quests.length; i++) {
        var quest = player.active_quests[i];
        dialog.user_data['quest_list'].push(quest);

        // select tracked mission
        if(pre_select === -1 &&
           (quest === player.quest_tracked ||
            i === dialog.user_data['just_completed_row'])) { // same row as previously-claimed quest
            pre_select = i;
        }
    }

    var first_row = 0;
    if(pre_select != -1) {
        // adjust scroll position up or down to make sure the pre-selected quest is visible
        if(pre_select < first_row) { first_row = pre_select; }
        else if(pre_select >= first_row + dialog.user_data['visible_rows']) { first_row = pre_select; }
    } else {
        // no pre-selection yet - just use row 0
        pre_select = first_row;
    }
    dialog.user_data['selected_row'] = pre_select;
    dialog.user_data['first_row'] = first_row;
    missions_dialog_scroll(dialog, dialog.user_data['first_row']);
};

// set scroll position, shifting selection to keep it visible
function missions_dialog_scroll(dialog, first_row) {
    // constrain first_row to valid range
    first_row = Math.max(Math.min(first_row, dialog.user_data['quest_list'].length - 1), 0);
    // quantize first_row to pages
    first_row = Math.floor(first_row/dialog.user_data['visible_rows'])*dialog.user_data['visible_rows'];
    dialog.user_data['first_row'] = first_row;

    // fill in UI quest list at left-hand side of dialog
    var ui_row = 0;
    for(var i = first_row; i < dialog.user_data['quest_list'].length; i++) {
        var quest = dialog.user_data['quest_list'][i];
        if(!quest) {
            throw Error('first_row '+first_row.toString()+' active_quests ' + player.active_quests.length.toString() + ' quest_list '+dialog.user_data['quest_list'].length.toString());
        }
        var rowname = 'row'+ui_row.toString();
        dialog.widgets[rowname].show = true;
        dialog.widgets[rowname].str = quest['ui_name'];

        if(player.is_cheater) { // in DEV Edit mode, show quest priority numbers
            dialog.widgets[rowname].str += ' (' + (quest['ui_priority']||0).toString() + ')';
        }

        dialog.widgets[rowname].onclick =
            dialog.widgets['row_icon'+ui_row.toString()].onclick =
            (function (rownum) { return function (w) {
                missions_dialog_select_mission(w.parent, rownum); }; })(i);
        dialog.widgets['row_icon'+ui_row.toString()].show = player.can_complete_quest(quest);

        ui_row += 1;
        if(ui_row >= dialog.user_data['visible_rows']) {
            break;
        }
    }

    // hide remaining rows
    var last_row_str = player.get_any_abtest_value('missions_dialog_last_row_ui_name', gamedata['strings']['missions_dialog_last_row_ui_name']);
    while(ui_row < dialog.user_data['visible_rows']) {
        if(ui_row + first_row == dialog.user_data['quest_list'].length) {
            dialog.widgets['row'+ui_row.toString()].show = true;
            dialog.widgets['row'+ui_row.toString()].str = last_row_str;
        } else {
            dialog.widgets['row'+ui_row.toString()].show = false;
        }
        dialog.widgets['row_icon'+ui_row.toString()].show = false;
        ui_row += 1;
    }

    // set scroll widget clickability
    dialog.widgets['scroll_left'].state = (first_row > 0 ? 'normal':'disabled');
    dialog.widgets['scroll_right'].state = (dialog.user_data['quest_list'].length > first_row+dialog.user_data['visible_rows'] ? 'normal':'disabled');

    dialog.user_data['scroll_left_flash'] = (first_row > 0 && read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null));

    dialog.widgets['scroll_left'].text_color = SPUI.make_colorv(dialog.data['widgets']['scroll_left']['text_color_'+dialog.widgets['scroll_left'].state]);
    dialog.widgets['scroll_right'].text_color = SPUI.make_colorv(dialog.data['widgets']['scroll_right']['text_color_'+dialog.widgets['scroll_right'].state]);

    dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1', dialog.user_data['quest_list'].length > 0 ? first_row+1 : 0).replace('%d2', Math.min(first_row+dialog.user_data['visible_rows'], dialog.user_data['quest_list'].length)).replace('%d3', dialog.user_data['quest_list'].length);

    // select the pre-selection, or any row that's visible
    missions_dialog_select_mission(dialog, dialog.user_data['selected_row']);
}

function missions_dialog_select_mission(dialog, row) {
    dialog.user_data['selected_row'] = row;
    dialog.user_data['selected_row'] = Math.min(Math.max(dialog.user_data['selected_row'], dialog.user_data['first_row']), Math.min(dialog.user_data['first_row']+dialog.user_data['visible_rows']-1, dialog.user_data['quest_list'].length-1));

    if(dialog.user_data['selected_row'] < 0) { // no quests
        dialog.widgets['your_reward'].show =
        dialog.widgets['reward_gamebucks_icon'].show =
        dialog.widgets['reward_gamebucks_amount'].show =
        dialog.widgets['claim_button'].show =
        dialog.widgets['tips_label'].show =
        dialog.widgets['mission_icon'].show =
        dialog.widgets['mission_icon_frame'].show =
        dialog.widgets['mission_accomplished_bar'].show =
        dialog.widgets['mission_accomplished'].show =
        dialog.widgets['mission_incomplete_bar'].show =
        dialog.widgets['mission_incomplete'].show =
        dialog.widgets['sunken_right3'].show =
        dialog.widgets['selected_row'].show = false;
        for(var res in gamedata['resources']) {
            if('reward_'+res+'_icon' in dialog.widgets) {
                dialog.widgets['reward_'+res+'_icon'].show = dialog.widgets['reward_'+res+'_amount'].show = false;
            }
        }
        dialog.widgets['noquests'].show = true;
        dialog.widgets['valentina'].show = true;
        return;
    }

    var quest = dialog.user_data['quest_list'][dialog.user_data['selected_row']];
    // check whether quest goal has been satisfied
    var pred = read_predicate(quest['goal']);
    var pending = player.can_complete_quest(quest);

    // update highlight on left-hand display
    var white = new SPUI.Color(1,1,1,1);
    var highlight_color = new SPUI.Color(0.75,0.75,0.75,1), important_highlight_color = new SPUI.Color(1,1,0.7,1);
    var important_color = new SPUI.Color(1,1,0.4,1);

    for(var i = 0; i < dialog.user_data['visible_rows']; i++) {
        var rowname = 'row'+i.toString();
        var index = i+dialog.user_data['first_row'];
        var rq = (index < dialog.user_data['quest_list'].length ? dialog.user_data['quest_list'][index] : null);
        var select_this = (index == dialog.user_data['selected_row']);
        var important = rq && rq['ui_important'];

        dialog.widgets[rowname].font = SPUI.make_font(dialog.widgets[rowname].data['text_size'], dialog.widgets[rowname].data['text_size']+3,
                                                      (important ? 'normal' : 'normal'));

        if(rq) {
            dialog.widgets[rowname].text_color = (select_this ? (important ? important_highlight_color : white) : (important ? important_color : SPUI.disabled_text_color));
            dialog.widgets[rowname].highlight_text_color = (select_this ? (important ? important_highlight_color : white) : (important ? important_highlight_color : highlight_color));
            dialog.widgets[rowname].state = 'normal';
            if(!select_this && pending && quest['force_claim'] && !player.preferences['skip_tutorial']) {
                // remove ability to select other quests
                dialog.widgets[rowname].state = 'disabled';
            }
        } else {
            dialog.widgets[rowname].highlight_text_color = dialog.widgets[rowname].text_color = new SPUI.Color(0.25,0.25,0.25,1);
            dialog.widgets[rowname].state = 'disabled';
        }

        if(select_this) {
            var spacing = dialog.data['widgets']['row']['array_offset'][1];
            dialog.widgets['selected_row'].xy[1] = dialog.data['widgets']['row']['xy'][1]+i*spacing-2;
        }
    }

    // update info at right
    if('icon' in quest) {
        dialog.widgets['mission_icon'].show = true;
        dialog.widgets['mission_icon'].asset = quest['icon'];
    } else {
        dialog.widgets['mission_icon'].show = false;
    }
    dialog.widgets['mission_icon_frame'].show = dialog.widgets['mission_icon'].show;
    dialog.widgets['valentina'].show = !dialog.widgets['mission_icon'].show;

    dialog.widgets['flavor_title'].text_color = (quest['ui_important'] ? important_color : SPUI.default_text_color);
    dialog.widgets['flavor_title'].str = (quest['ui_flavor_name'] ? quest['ui_flavor_name'] : quest['ui_name']);
    dialog.widgets['subtitle'].str = (quest['ui_flavor_name'] ? quest['ui_name'] : '');

    if(quest['ui_instructions']) {
        dialog.widgets['tips_label'].show = true;
        dialog.widgets['tips'].set_text_with_linebreaking(quest['ui_instructions']);
    } else {
        dialog.widgets['tips_label'].show = false;
        dialog.widgets['tips'].str = '';
    }

    dialog.widgets['description'].set_text_with_linebreaking(eval_cond_or_literal(quest['ui_description'], player, null));
    dialog.widgets['description'].xy = dialog.widgets['description'].data['xy'+(quest['ui_flavor_name'] ? '':'_nosubtitle')];

    var reward_res = {};
    var max_res = player.get_max_storage();
    var ratio_ratio; // factor that applies ONLY to reward_x_ratio amounts
    if('repeat_interval' in quest) {
        ratio_ratio = player.get_any_abtest_value('daily_quest_reward_ratio', gamedata['daily_quest_reward_ratio']);
    } else {
        ratio_ratio = 1.0;
    }
    for(var res in gamedata['resources']) {
        reward_res[res] = quest['reward_'+res]||0;
        if('reward_'+res+'_ratio' in quest) {
            reward_res[res] += Math.floor(ratio_ratio * quest['reward_'+res+'_ratio']*max_res[res]);
        }
        if('reward_'+res+'_amount' in dialog.widgets) {
            dialog.widgets['reward_'+res+'_amount'].str = pretty_print_number(reward_res[res]);
            dialog.widgets['reward_'+res+'_amount'].tooltip.str = dialog.widgets['reward_'+res+'_icon'].tooltip.str = gamedata['resources'][res]['ui_description'];
            dialog.widgets['reward_'+res+'_amount'].show = dialog.widgets['reward_'+res+'_icon'].show = (reward_res[res] > 0);
        }
    }

    var reward_other = [];
    dialog.widgets['reward_unit_icon'].show = dialog.widgets['reward_unit_icon_stack'].show = false;
    dialog.widgets['reward_unit_icon'].onenter = dialog.widgets['reward_unit_icon'].onleave_cb = null;
    dialog.widgets['reward_unit_icon'].xy = dialog.data['widgets']['reward_unit_icon']['xy'];
    dialog.widgets['reward_unit_icon'].wh = dialog.data['widgets']['reward_unit_icon']['dimensions'];

    if('reward_heal_all_units' in quest && quest['reward_heal_all_units']) {
        reward_other.push(dialog.data['widgets']['reward_other_text']['ui_name_heal_all_units']);
        if(!dialog.widgets['reward_unit_icon'].show) {
            dialog.widgets['reward_unit_icon'].show = true;
            dialog.widgets['reward_unit_icon'].asset = 'inventory_repair_item_green';
            dialog.widgets['reward_unit_icon'].xy = dialog.data['widgets']['reward_unit_icon']['alloy_xy'];
        }
    }

    var reward_units = null;
    var reward_consequent = quest['reward_consequent'] || null;

    // hack
    if(reward_consequent && reward_consequent['consequent'] == 'AND') {
        reward_consequent = reward_consequent['subconsequents'][0];
    }

    if(quest['reward_icon']) {
        // this quest uses a manually-specified reward icon. Ignore all other logic below.
        if(!dialog.widgets['reward_unit_icon'].show) {
            dialog.widgets['reward_unit_icon'].show = true;
            dialog.widgets['reward_unit_icon'].asset = quest['reward_icon'];
            dialog.widgets['reward_unit_icon'].xy = dialog.data['widgets']['reward_unit_icon']['alloy_xy'];
        }
        // also check for manually-specified text
        if(quest['ui_reward_text']) {
            reward_other.push(quest['ui_reward_text']);
        }
    } else if('reward_give_units' in quest) {
        reward_units = quest['reward_give_units'];
    } else if (reward_consequent && (reward_consequent['consequent'] == 'GIVE_UNITS')) {
        reward_units = reward_consequent['units'];
    } else if (('reward_consequent' in quest) && (reward_consequent['consequent'] == 'GIVE_LOOT') &&
               (reward_consequent['loot'].length > 0)) {

        // XXX this is a special-case hack - we don't have a general-purpose way to display arbitrary loot tables
        // instead, abuse reward_unit_icon to display a loot item

        if(('spec' in reward_consequent['loot'][0]) &&
           (reward_consequent['loot'][0]['spec'].indexOf('packaged_') == 0) &&
           (reward_consequent['loot'][0]['spec'].slice(9) in gamedata['units'])) {
            reward_units = {};
            reward_units[reward_consequent['loot'][0]['spec'].slice(9)] = reward_consequent['loot'][0]['stack'] || 1;
        } else if(('multi' in reward_consequent['loot'][0]) && (reward_consequent['loot'][0]['multi'][0]['table'] == 'sexy_unlocked_unit')) {
            reward_units = {};
            var stack = (reward_consequent['loot'][0]['multi_stack'] || 1);

            // manually check the loot table to see what we're going to get
            var cond = gamedata['loot_tables_client']['sexy_unlocked_unit']['loot'][0]['cond'];
            for(var i = 0; i < cond.length; i++) {
                if(read_predicate(cond[i][0]).is_satisfied(player, null)) {
                    var unit_name = cond[i][1]['spec'].slice(9);
                    if(!(unit_name in gamedata['units'])) {
                        throw Error('cannot parse sexy_unlocked_unit '+cond[i][1]['spec']);
                    }
                    reward_units[unit_name] = stack;
                    break;
                }
            }
        } else if('spec' in reward_consequent['loot'][0]) {
            // display an arbitrary item
            dialog.widgets['reward_unit_icon'].show = dialog.widgets['reward_unit_icon_stack'].show = true;
            var item = reward_consequent['loot'][0]; // fake item for tooltip
            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            ItemDisplay.set_inventory_item_asset(dialog.widgets['reward_unit_icon'], spec);
            ItemDisplay.set_inventory_item_stack(dialog.widgets['reward_unit_icon_stack'], spec, item);

            // reposition icon for item display
            dialog.widgets['reward_unit_icon'].xy = dialog.data['widgets']['reward_unit_icon']['item_xy'];
            dialog.widgets['reward_unit_icon'].wh = dialog.data['widgets']['reward_unit_icon']['item_dimensions'];

            dialog.widgets['reward_unit_icon'].onenter = (function (_item) { return function(w) {
                var dialog = w.parent;
                if(dialog.user_data['context']) { return; }
                invoke_inventory_context(dialog, w, 0, _item, false);
                // set transparent so that onleave is always called reliably
                if(dialog.user_data['context']) { dialog.user_data['context'].transparent_to_mouse = true; }
            }; })(item);
            dialog.widgets['reward_unit_icon'].onleave_cb = function(w) {
                var dialog = w.parent;
                if(dialog.user_data['context']) { invoke_inventory_context(dialog, w, -1, null, false); }
            };
        }
    }

    if(reward_units) {
        var data = reward_units;
        for(var name in data) {
            var qty = data[name];
            if(!(name in gamedata['units'])) {
                continue;
            }
            var spec = gamedata['units'][name];
            if(qty > 0) {
                var str = qty.toString() + 'x ' + spec['ui_name'];
                reward_other.push(str);
                dialog.widgets['reward_unit_icon'].show = true;
                dialog.widgets['reward_unit_icon'].asset = get_leveled_quantity(spec['art_asset'], 1);
                var voffset;
                if(spec['flying']) {
                    voffset = -4*spec['altitude'];
                } else {
                    voffset = 0;
                }
                dialog.widgets['reward_unit_icon'].bg_image_offset = [dialog.data['widgets']['reward_unit_icon']['bg_image_offset'][0],
                                                                      dialog.data['widgets']['reward_unit_icon']['bg_image_offset'][1] + voffset];
            }
        }
    }
    dialog.widgets['reward_other_text'].str = reward_other.join('\n');

    var reward_xp = 0;

    if('quest_reward_resources' in gamedata['player_xp']) {
        var total_res = 0;
        for(var res in gamedata['resources']) {
            total_res += quest['reward_'+res] || 0;
        }
        reward_xp = Math.floor(gamedata['player_xp']['quest_reward_resources'] * total_res);
    } else {
        reward_xp = ('reward_xp' in quest ? Math.max(Math.floor(quest['reward_xp']*gamedata['player_xp']['quests']), gamedata['player_xp']['quests_min']) : 0);
    }

    // gamebucks and xp take up the same space, so only show one of them at a time
    if(('reward_gamebucks' in quest) && quest['reward_gamebucks'] > 0 && player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks') {
        dialog.widgets['reward_gamebucks_amount'].show =
            dialog.widgets['reward_gamebucks_icon'].show = true;
        dialog.widgets['reward_gamebucks_amount'].str = Store.display_user_currency_amount(quest['reward_gamebucks'], 'compact');
        dialog.widgets['reward_gamebucks_icon'].asset = player.get_any_abtest_value('gamebucks_resource_icon', gamedata['store']['gamebucks_resource_icon']);
        reward_other.push(Store.display_user_currency_amount(quest['reward_gamebucks'], 'full'));
        dialog.widgets['reward_gamebucks_amount'].tooltip.str =
            dialog.widgets['reward_gamebucks_icon'].tooltip.str = dialog.data['widgets']['reward_gamebucks_icon']['ui_tooltip'].replace('%s', player.get_any_abtest_value('gamebucks_ui_name', gamedata['store']['gamebucks_ui_name']));

        dialog.widgets['reward_xp_amount'].show =
            dialog.widgets['reward_xp_icon'].show = false;
    } else {
        dialog.widgets['reward_gamebucks_amount'].show =
            dialog.widgets['reward_gamebucks_icon'].show = false;

        dialog.widgets['reward_xp_amount'].show =
            dialog.widgets['reward_xp_icon'].show = (reward_xp > 0);
        if(reward_xp > 0) {
            dialog.widgets['reward_xp_amount'].str = pretty_print_number(reward_xp);
        }
    }

    dialog.widgets['claim_button'].state = (pending ? 'bigaction' : 'normal');
    dialog.widgets['claim_button'].bg_image = (pending ? 'action_button_134px' : 'menu_button_134px');
    if(pending) {
        dialog.widgets['claim_button'].str = dialog.data['widgets']['claim_button']['ui_name'];
        dialog.widgets['claim_button'].onclick = (function (q) { return function(w) {
            var dialog = w.parent;
            if(1) {
                dialog.widgets['glow'].show = true;
                dialog.widgets['glow'].reset_fx();
            }
            send_to_server.func(["COMPLETE_QUEST", q['name']]);
            dialog.widgets['claim_button'].str = dialog.data['widgets']['claim_button']['ui_name_claiming'];
            dialog.widgets['claim_button'].state = 'disabled';
        }; })(quest);
    } else {

        // see if we have a helper function for the goal predicate
        var helper = null;

        if(quest['ui_accept_consequent']) { // manual override is top priority
            helper = (function (_cons) { return function() { _cons.execute(); }; })(read_consequent(quest['ui_accept_consequent']));
        } else if(!quest['tips'] &&
                  player.get_any_abtest_value('missions_dialog_predicate_help', gamedata['client']['missions_dialog_predicate_help'])) {
            // try to generate a helper automatically, for non-blue-arrow-tips quests
            helper = get_requirements_help(pred, null, {even_if_tutorial_incomplete:true, short_circuit:true});
        }

        // note: helper may still be null here

        dialog.widgets['claim_button'].str = dialog.data['widgets']['claim_button']['ui_name'+ (helper ? '_show_me' : '_accept')];
        dialog.widgets['claim_button'].onclick = (function (q, _helper) { return function() {
            if('ui_accept_url' in q) {
                // override default behavior with a URL open
                url_open_in_new_tab(q['ui_accept_url']);
                return;
            }

            change_selection(null);

            // "accept" button works like "close" if in skip_tutorial mode
            if('skip_tutorial' in player.preferences && player.preferences['skip_tutorial']) {
                // NOTE! do NOT track the quest, since the player does not want tips
                player.quest_tracked = null;
                player.quest_tracked_dirty = true;
            } else {
                tutorial_opt_in(q);
            }

            if(_helper) {
                _helper();
            }

        }; })(quest, helper);
    }

    dialog.widgets['mission_accomplished'].show =
        dialog.widgets['mission_accomplished_bar'].show = pending;
    dialog.widgets['mission_incomplete'].show =
        dialog.widgets['mission_incomplete_bar'].show = !pending;

    if(!pending) {
        // get mission progress text, if available
        var text = null;
        if(pred.ui_progress) {
            text = pred.ui_progress(player, null);
        }

        if(text) {
            dialog.widgets['mission_incomplete'].str = text;
        } else {
            dialog.widgets['mission_incomplete'].str = dialog.data['widgets']['mission_incomplete']['ui_name'];
        }
    }

    player.quest_tracked_dirty = true;
}

function invoke_map_dialog(force_page) {
    change_selection(null);

    var dialog_data = gamedata['dialogs']['map_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'map_dialog';
    dialog.user_data['chapter'] = null;
    dialog.user_data['page'] = 0;
    dialog.user_data['quarries'] = null;
    dialog.user_data['friends_on_page'] = [];
    dialog.user_data['quarries_on_page'] = [];
    dialog.user_data['rivals_fetched'] = 0;
    dialog.user_data['quarries_fetched'] = 0;
    dialog.user_data['hitlist_scanned'] = 0;

    dialog.widgets['close_button'].onclick = function() {
        if(player.tutorial_state != "COMPLETE") { return; }
        change_selection(null);
    };

    dialog.widgets['refresh_button'].onclick = function(w) {
        var dialog = w.parent;

        if(dialog.user_data['chapter'] === 'rivals') {
            var cb = (function(_dialog) { return function() {
                dialog.user_data['rivals_fetched'] += 1;

                // reset rivals list and page number
                if(_dialog.user_data['chapter'] === 'rivals') {
                    var oldpage = _dialog.user_data['page']; // 0
                    _dialog.user_data['page'] = -1;
                    map_dialog_change_page(_dialog, _dialog.user_data['chapter'], oldpage);
                }
            }; })(dialog);

            // send a query for battled rivals the first time, then set flag to false on subsequent refreshes
            query_rivals(cb, (dialog.user_data['rivals_fetched'] == 0));
        } else if(dialog.user_data['chapter'] === 'quarries') {
            var cb = (function(_dialog) { return function(db_time, result) {
                dialog.user_data['quarries'] = [];
                dialog.user_data['quarries_fetched'] += 1;

                for(var i = 0; i < result.length; i++) {
                    var quarry = result[i];
                    if(quarry['base_type'] == 'quarry') {
                        dialog.user_data['quarries'].push(quarry);
                    }
                }

                // reset rivals list and page number
                if(_dialog.user_data['chapter'] === 'quarries') {
                    var oldpage = _dialog.user_data['page']; // 0
                    _dialog.user_data['page'] = -1;
                    map_dialog_change_page(_dialog, _dialog.user_data['chapter'], oldpage);
                }
            }; })(dialog);
            query_quarries(cb, -1);
        }
    };

    dialog.ondraw = update_map_dialog;
    update_map_dialog_header_buttons(dialog.widgets['header_buttons']); // to set up onclick handlers for the below

    dialog.widgets['dev_title'].show = !!player.is_cheater;

    // very, very awkward, but this dialog is a mess
    var page = map_dialog_get_default_page();
    if(page != 'computers' && force_page) {
        page = 'computers';
    } else if(!page) {
        page = 'computers';
    }

    var click_it = function(name) {
        var index = dialog.widgets['header_buttons'].user_data['buttons'].indexOf(name);
        if(index < 0) { throw Error('button not found for '+(name ? name.toString() : 'null/undefined')); }
        var w = dialog.widgets['header_buttons'].widgets['button'+index.toString()];
        if(w.onclick) { w.onclick(w); }
    }
    click_it(page);
    if(force_page && dialog.user_data['chapter'] !== force_page &&
       goog.array.contains(dialog.widgets['header_buttons'].user_data['buttons'], force_page)) {
        click_it(force_page);
    }

    if(player.tutorial_state === 'open_map_dialog') { advance_tutorial(); }
}

// store choice once, then allow player to override
var map_dialog_default_page = null;
function map_dialog_get_default_page() {
    if(!map_dialog_default_page) {
        var page = 'computers';

        if(player.tutorial_state != "COMPLETE" || !read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null)) {
            page = 'computers';
        } else if(player.get_any_abtest_value('map_dialog_default_page', null)) {
            page = player.get_any_abtest_value('map_dialog_default_page', null);
        } else {
            page = eval_cond_or_literal(gamedata['map_dialog_default_page'], player, null);
        }
        map_dialog_default_page = page;
    }

    // check for tab accessibility
    if(!player.is_ladder_player() && (!player.is_pvp_player() || !player.is_legacy_pvp_player()) && map_dialog_default_page == 'rivals') { map_dialog_default_page = 'computers'; }
    if(!session.region.map_enabled() && map_dialog_default_page == 'quarries') { map_dialog_default_page = 'computers'; }

    return map_dialog_default_page;
}

/** @param {SPUI.Dialog} dialog */
function update_map_dialog(dialog) {
    update_map_dialog_header_buttons(dialog.widgets['header_buttons']);

    var show_loading = false;
    if(dialog.user_data['chapter'] === 'hitlist') {
        if(!player.cooldown_active('hitlist_assigned')) {
            if(!player.cooldown_active('hitlist_assign_pending')) {
                send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "HITLIST_ASSIGN"]);
                player.cooldown_client_trigger('hitlist_assign_pending', 999);
            }
            show_loading = true;
        } else if(!dialog.user_data['hitlist_scanned']) {
            dialog.user_data['hitlist_scanned'] = 1;
            map_dialog_change_page(dialog, dialog.user_data['chapter'], -1); // rescan list after the assignment comes in (use page = -1 to force rescan)
        }
    } else {
        var last_query_time = (dialog.user_data['chapter'] === 'quarries' ? last_quarry_query_time : last_rivals_query_time);
        var fetched = dialog.user_data[(dialog.user_data['chapter'] === 'quarries' ? 'quarries_fetched' : 'rivals_fetched')];

        var ok_to_send_query = (last_query_time == -1 ||
                                (last_query_time > 0 && client_time > (last_query_time+gamedata['rival_query_cooldown'])));

        dialog.widgets['refresh_button'].state = ok_to_send_query ? 'normal' : 'disabled';

        if(last_query_time == -1 || (dialog.user_data['chapter'] === 'quarries' && dialog.user_data['quarries'] === null)) {
            // start initial refresh
            if(dialog.user_data['chapter'] === 'rivals' || dialog.user_data['chapter'] === 'quarries') {
            dialog.widgets['refresh_button'].onclick(dialog.widgets['refresh_button']);
            }
        }
        // show "Loading..." only during true query latency on first try,
        // but then keep it up until cooldown expires on subsequent tries

        show_loading = ((dialog.user_data['chapter'] == 'rivals' || dialog.user_data['chapter'] == 'quarries') &&
                        (last_query_time == 0 ||
                         (fetched && !ok_to_send_query)));
    }

    dialog.widgets['loading_rect'].show = dialog.widgets['loading_text'].show = dialog.widgets['loading_spinner'].show = show_loading;

    // update timers
    var row = 0;
    if(dialog.user_data['chapter'] === 'quarries') {
        for(; row < dialog.user_data['quarries_on_page'].length; row++) {
            var quarry = dialog.user_data['quarries_on_page'][row];

            // travel timer
            dialog.widgets['row_travel0'+row].show = true;
            var travel_time = player.travel_time_to(quarry['base_map_loc']);
            var to_go = player.travel_state['end_time'] - server_time; // may not be relevant if travel_satisfied() is true
            dialog.widgets['row_travel0'+row].str = pretty_print_time_brief(travel_time);
            dialog.widgets['row_travel1'+row].show = true;
            if(quarry['base_landlord_id'] === session.user_id) {
                dialog.widgets['row_travel1'+row].str = dialog.data['widgets']['row_travel1']['ui_name_owned'];
                if(player.travel_state['dest_loc'] && vec_equals(player.travel_state['dest_loc'], quarry['base_map_loc'])) {
                    if(player.travel_satisfied(quarry['base_map_loc'])) {
                        dialog.widgets['row_travel1'+row].str = dialog.data['widgets']['row_travel1']['ui_name_ready_to_reinforce'];
                    } else {
                        dialog.widgets['row_travel1'+row].str = dialog.data['widgets']['row_travel1']['ui_name_reinforce_in'].replace('%s', pretty_print_time_brief(to_go));
                    }
                }
                dialog.widgets['row_travel1'+row].text_color = new SPUI.Color(0,1,0,1);
            } else if(player.travel_state['dest_loc'] && vec_equals(player.travel_state['dest_loc'], quarry['base_map_loc'])) {
                if(player.travel_satisfied(quarry['base_map_loc'])) {
                    dialog.widgets['row_travel1'+row].str = dialog.data['widgets']['row_travel1']['ui_name_ready_for_battle'];
                    dialog.widgets['row_travel1'+row].text_color = SPUI.default_text_color;
                } else {
                    dialog.widgets['row_travel1'+row].str = dialog.data['widgets']['row_travel1']['ui_name_arriving_in'].replace('%s',pretty_print_time_brief(to_go));
                    dialog.widgets['row_travel1'+row].text_color = new SPUI.Color(0.5,0.5,0.5,1);
                }
            } else {
                dialog.widgets['row_travel1'+row].str = '';
            }

            // Spy button
            var visit_func = (function (_quarry) { return function() {
                do_visit_base(-1, {base_id:_quarry['base_id']});
            }; })(quarry);
            var travel_func = (function (_quarry) { return function() {
                send_to_server.func(["TRAVEL_BEGIN", _quarry['base_map_loc'], player.travel_time_to(_quarry['base_map_loc'])]);
            }; })(quarry);

            dialog.widgets['row_button'+row].show = true;

            if((quarry['base_landlord_id'] === session.user_id || player.travel_satisfied(quarry['base_map_loc']))) {
                // can visit immediately
                dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name'];
                dialog.widgets['row_button'+row].tooltip.str = '';
                dialog.widgets['row_button'+row].state = 'normal';
                dialog.widgets['row_button'+row].onclick = visit_func;

                // attack status overrides other possibilities
                var lock_state = quarry['LOCK_STATE'] || 0;
                var lock_owner = quarry['LOCK_OWNER'] || -1;
                if(lock_state != 0 && (lock_owner != session.user_id)) {
                    dialog.widgets['row_button'+row].state = 'disabled';
                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_under_attack'];
                    dialog.widgets['row_button'+row].tooltip.str = dialog.data['widgets']['row_button']['ui_tooltip_under_attack'];
                }

            } else {
                // must travel first
                dialog.widgets['row_button'+row].tooltip.str = '';

                if(!player.travel_state['dest_loc']) {
                    // no destination selected, show Travel button
                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_travel'];
                    dialog.widgets['row_button'+row].state = 'normal';
                    dialog.widgets['row_button'+row].onclick = travel_func;
                } else if(vec_equals(player.travel_state['dest_loc'], quarry['base_map_loc'])) {
                    // on way to this destination, show Cancel Travel button
                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_cancel_travel'];
                    dialog.widgets['row_button'+row].state = 'normal';
                    dialog.widgets['row_button'+row].onclick = function() { send_to_server.func(["TRAVEL_BEGIN", null, 0]); };
                } else if(player.travel_state['end_time'] >= server_time) {
                    // on way to another destination
                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_travel'];
                    //dialog.widgets['row_button'+row].state = 'disabled';
                    dialog.widgets['row_button'+row].onclick = travel_func;
                    dialog.widgets['row_button'+row].tooltip.str = dialog.data['widgets']['row_button']['ui_tooltip_travel'];
                } else {
                    // arrived at another destination
                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_travel'];
                    dialog.widgets['row_button'+row].state = 'normal';
                    dialog.widgets['row_button'+row].onclick = travel_func;
                }
            }
            dialog.widgets['row_ai_info'+row].show = false;
            dialog.widgets['row_button'+row].drop_shadow = (dialog.widgets['row_button'+row].state == 'attack');
        }
    } else {
        for(; row < dialog.user_data['friends_on_page'].length; row++) {
            var friend = dialog.user_data['friends_on_page'][row];
            dialog.widgets['row_attackability'+row].show =
                dialog.widgets['row_hider'+row].show =
                dialog.widgets['row_ai_info'+row].show =
                dialog.widgets['row_hider_button'+row].show = false;

            // Spy button
            dialog.widgets['row_button'+row].show = true;

            var callback = (function (uid) { return function() {
                visit_base(uid);
                if(player.tutorial_state === 'spy_on_ai') {
                    advance_tutorial();
                }
            }; })(friend.user_id);

            dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name'];
            dialog.widgets['row_button'+row].tooltip.str = '';
            dialog.widgets['row_button'+row].state = (dialog.user_data['chapter'] == 'hitlist' ? 'attack' : 'normal');
            dialog.widgets['row_button'+row].onclick = callback;

            if(friend.is_ai() && !dialog.widgets['row_info_button'+row].show) {
                // for AIs without "?" buttons, make the portrait/name do the spy action when clicked
                dialog.widgets['row_portrait'+row].onclick = dialog.widgets['row_name'+row].onclick = callback;
            }

            var attackability_str = null, attackability_col = dialog.data['widgets']['row_attackability']['text_color'];

            if(friend.is_ai()) {
                var base = gamedata['ai_bases_client']['bases'][friend.user_id.toString()];

                if('ui_spy_button' in base) {
                    dialog.widgets['row_button'+row].str = base['ui_spy_button'];
                    if(dialog.user_data['chapter'] != 'hitlist') {
                        dialog.widgets['row_button'+row].state = 'passive';
                    }
                } else if(base['kind'] == 'ai_attack') {
                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_ai_attack'];
                }

                if(base['kind'] == 'ai_attack') {
                    // replace the regular Spy command with start_ai_attack()
                    dialog.widgets['row_portrait'+row].onclick = dialog.widgets['row_name'+row].onclick = dialog.widgets['row_button'+row].onclick = (function (uid) { return function() {
                        start_ai_attack(uid);
                    }; })(friend.user_id);
                }

                var pred = read_predicate(base['activation']);
                if(!pred.is_satisfied(player, null) && !player.is_cheater) {
                    //attackability_str = dialog.data['widgets']['row_attackability']['ui_ name_locked'];
                    dialog.widgets['row_hider'+row].show =
                        dialog.widgets['row_hider_button'+row].show = true;
                    dialog.widgets['row_hider_button'+row].onclick = get_requirements_help(pred, null);
                    var ui_pred = pred.ui_describe(player);
                    dialog.widgets['row_hider_button'+row].tooltip.str = (ui_pred ? dialog.data['widgets']['row_hider_button']['ui_tooltip'].replace('%s', ui_pred) : null);
                    if('ui_info' in base) {

                        dialog.widgets['row_hider_button'+row].tooltip.str += '\n\n' + base['ui_info'];
                    }
                    dialog.widgets['row_hider_button'+row].tooltip.text_color = SPUI.error_text_color;

                    // if the AI base uses an instance cooldown, AND the cooldown is running,
                    // show cooldown info
                    if('ui_resets' in base) {
                        attackability_str = base['ui_resets'];
                        attackability_col = dialog.data['widgets']['row_attackability']['text_color_resets'];
                    }
                    if('ui_instance_cooldown' in base) {
                        var togo = player.cooldown_togo(base['ui_instance_cooldown']);
                        if(togo > 0) {
                            var stacks = player.cooldown_active(base['ui_instance_cooldown']);
                            attackability_str = (base['ui_instance_cooldown_template'] || dialog.data['widgets']['row_attackability']['ui_name_instance_cooldown']).replace('%s', pretty_print_time(togo)).replace('%count', stacks.toString());
                            attackability_col = dialog.data['widgets']['row_attackability']['text_color_resets_inprogress'];

                            // detect dummy bases that exist only to hold a place while waiting for the cooldown to expire,
                            // and show plain ui_info instead of the failed predicate text
                            if(base['activation']['predicate'] == 'ALWAYS_FALSE' && ('ui_info' in base)) {
                                dialog.widgets['row_hider_button'+row].tooltip.str = base['ui_info'];
                                dialog.widgets['row_hider_button'+row].tooltip.text_color = SPUI.default_text_color;
                            }
                        } else if('ui_resets' in base) {
                            attackability_str = base['ui_resets'];
                            attackability_col = dialog.data['widgets']['row_attackability']['text_color_resets'];
                        }
                    }

                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_locked'];
                    dialog.widgets['row_button'+row].state = 'disabled';
                } else {
                    if('ui_resets' in base) {
                        attackability_str = base['ui_resets'];
                        attackability_col = dialog.data['widgets']['row_attackability']['text_color_resets'];
                    }
                    if('ui_instance_cooldown' in base) {
                        var togo = player.cooldown_togo(base['ui_instance_cooldown']);
                        if(togo > 0) {
                            var stacks = player.cooldown_active(base['ui_instance_cooldown']);
                            attackability_str = (base['ui_instance_cooldown_template'] || dialog.data['widgets']['row_attackability']['ui_name_instance_cooldown']).replace('%s', pretty_print_time(togo)).replace('%count', stacks.toString());
                            attackability_col = dialog.data['widgets']['row_attackability']['text_color_resets_inprogress'];
                        }
                    }
                    dialog.widgets['row_ai_info'+row].show = true;
                    dialog.widgets['row_ai_info'+row].onclick = null;
                    dialog.widgets['row_ai_info'+row].tooltip.str = base['ui_info'] || null;
                }
            }

            if(attackability_str) {
                dialog.widgets['row_attackability'+row].show = true;
                dialog.widgets['row_attackability'+row].str = attackability_str;
                dialog.widgets['row_attackability'+row].text_color = new SPUI.Color(attackability_col[0],
                                                                                    attackability_col[1],
                                                                                    attackability_col[2],1);
            }
            dialog.widgets['row_button'+row].drop_shadow = (dialog.widgets['row_button'+row].state == 'attack');
        }
    }

    while(row < dialog.data['widgets']['row_attackability']['array'][1]) {
        dialog.widgets['row_button'+row].show =
            dialog.widgets['row_attackability'+row].show =
            dialog.widgets['row_ai_info'+row].show =
            dialog.widgets['row_hider'+row].show =
            dialog.widgets['row_hider_button'+row].show = false;
        row += 1;
    }

    dialog.widgets['hitlist_empty'].show = (dialog.user_data['chapter'] == 'hitlist' && dialog.user_data['friends_on_page'].length == 0 &&
                                            player.cooldown_active('hitlist_assigned'));
    if(dialog.widgets['hitlist_empty'].show) {
        dialog.widgets['hitlist_empty'].str = dialog.data['widgets']['hitlist_empty']['ui_name'].replace('%s', pretty_print_time(player.cooldown_togo('hitlist_assigned')));
    }
}

// global flag - show rival warning only once per session
var map_dialog_rivals_warned = false;

// "chapter" means "computers", "rivals", "friends", or "quarries"
// "page" refers to the left/right scrolling position

function map_dialog_change_page(dialog, chapter, page) {

    player.quest_tracked_dirty = true;

    // see whether rivals page would be empty
    var any_rivals = true;

    /*
    for(var i = 0; i < player.friends.length; i++) {
        var friend = player.friends[i];
        if(!friend.is_ai() && !friend.is_real_friend) {
            any_rivals = true;
            break;
        }
    }
    */

    // hide rivals until tutorial is complete
    if(player.tutorial_state != "COMPLETE") {
        any_rivals = false;
    }

    // if rivals page would be empty, divert to computers page
    if(!any_rivals && chapter === 'rivals') {
        chapter = 'computers';
    }
    if(!player.is_legacy_pvp_player() && chapter === 'rivals') {
        chapter = 'computers';
    }

    if(dialog.user_data['chapter'] === chapter && dialog.user_data['page'] === page) { return; }
    dialog.user_data['chapter'] = chapter;
    dialog.user_data['page'] = page;
    map_dialog_default_page = chapter;

    dialog.widgets['refresh_button'].show = (chapter === 'rivals' || chapter === 'quarries');
    dialog.widgets['refresh_button'].tooltip.str = dialog.data['widgets']['refresh_button'][(chapter === 'quarries' ? 'ui_tooltip_quarries' : 'ui_tooltip')];

    dialog.widgets['column_header_travel'].show = (chapter === 'quarries');

    dialog.widgets['column_header_battle_stars'].show = (chapter !== 'quarries' && !!gamedata['client']['map_dialog_battle_stars_column']);
    dialog.widgets['column_header_level'].show = (chapter !== 'quarries' && !dialog.widgets['column_header_battle_stars'].show);

    // show rival warning dialog
    if(dialog.user_data['chapter'] != 'computers' &&
       player.resource_state['protection_end_time'] > server_time &&
       player.get_any_abtest_value('map_dialog_warn_rivals', gamedata['client']['map_dialog_warn_rivals']) &&
       player.quest_root.children.length == 0 &&
       ((player.history['attacks_launched_vs_human'] || 0) == 0) &&
       !map_dialog_rivals_warned) {
        map_dialog_rivals_warned = true;
        invoke_ingame_tip('human_rivals_tip', {frequency: GameTipFrequency.ALWAYS_UNLESS_IGNORED});
    } else if(dialog.user_data['chapter'] === 'quarries') {
        invoke_ingame_tip('map_quarries_tip', {frequency: GameTipFrequency.ALWAYS_UNLESS_IGNORED});
    }


    var item_list = [];

    if(chapter === 'quarries') {
        if(dialog.user_data['quarries'] !== null) {

            for(var i = 0; i < dialog.user_data['quarries'].length; i++) {
                var quarry = dialog.user_data['quarries'][i];
                if(quarry['base_expire_time'] &&
                   quarry['base_expire_time'] > 0 &&
                   server_time >= quarry['base_expire_time']) {
                    continue;
                }
                item_list.push(quarry);
            }

            var compare_by_base_id = function (a,b) {
                if(a['base_id'] < b['base_id']) {
                    return -1;
                } else if(a['base_id'] > b['base_id']) {
                    return 1;
                } else {
                    return 0;
                }
            };

            var compare_by_ownership_and_travel_time = function (a,b) {
                var time_a = player.travel_time_to(a['base_map_loc']);
                var time_b = player.travel_time_to(b['base_map_loc']);
                var owns_a = a['base_landlord_id'] === session.user_id;
                var owns_b = b['base_landlord_id'] === session.user_id;
                if(owns_a && !owns_b) {
                    return -1;
                } else if(owns_b && !owns_a) {
                    return 1;
                } else if(time_a < time_b) {
                    return -1;
                } else if(time_a > time_b) {
                    return 1;
                } else {
                    return 0;
                }
            };

            item_list.sort(compare_by_ownership_and_travel_time);
        }
    } else {
        if(chapter == 'hitlist') {
            goog.object.forEach(gamedata['ai_bases_client']['bases'], function(ai_base, sid) {
                if((ai_base['ui_category']||'computers') != chapter) { return; }
                if(('show_if' in ai_base) && !read_predicate(ai_base['show_if']).is_satisfied(player, null)) { return; }
                // create a fake Friend entry for the AI
                var info = {'social_id': 'ai', 'ui_name': ai_base['ui_name'], 'player_level': ai_base['resources']['player_level']};
                item_list.push(new Friend(parseInt(sid,10), false, info, null));
            });
        } else {
            // first filter the list of friends down to those who should appear on this page
            for(var i = 0; i < player.friends.length; i++) {
                var friend = player.friends[i];
                var ai_base = (friend.is_ai() ? gamedata['ai_bases_client']['bases'][friend.user_id.toString()] || null : null);

                if(chapter === 'computers') {
                    if(friend.is_ai()) {
                        if(player.tutorial_state != "COMPLETE") {
                            // special case for tutorial - only show Lion Stone
                            if(friend.user_id != LION_STONE_ID) { continue; }
                        }
                        if(ai_base && (ai_base['ui_category']||'computers') != 'computers') { continue; }
                        item_list.push(friend);
                    }
                } else if(chapter === 'friends') {
                    if(!friend.is_ai() && friend.is_real_friend) {
                        item_list.push(friend);
                    }
                } else if(chapter === 'rivals') {
                    if(!friend.is_ai() && !friend.is_real_friend) {
                        item_list.push(friend);
                    }
                } else if(chapter === 'hitlist') {
                    if(ai_base) {
                        if((ai_base['ui_category']||'computers') != 'hitlist') { continue; }
                        item_list.push(friend);
                    }
                }
            }
        }

        // sort list
        var compare_by_ai_level = function (a,b) {
            var base_a = gamedata['ai_bases_client']['bases'][a.user_id.toString()];
            var base_b = gamedata['ai_bases_client']['bases'][b.user_id.toString()];

            // first sort by ui_priority high to low
            var ui_priority_a = eval_cond_or_literal(base_a['ui_priority'] || 0, player, null);
            var ui_priority_b = eval_cond_or_literal(base_b['ui_priority'] || 0, player, null);
            if(ui_priority_a < ui_priority_b) {
                return 1;
            } else if(ui_priority_a > ui_priority_b) {
                return -1;
            }

            // then "freshness" of a time-limited base
            var range_a = ('show_if' in base_a ? read_predicate(base_a['show_if']).ui_time_range(player) : ('activation' in base_a ? read_predicate(base_a['activation']).ui_time_range(player) : [-1,-1]));
            var range_b = ('show_if' in base_b ? read_predicate(base_b['show_if']).ui_time_range(player) : ('activation' in base_b ? read_predicate(base_b['activation']).ui_time_range(player) : [-1,-1]));
            if(range_a[0] < range_b[0]) {
                return 1;
            } else if(range_a[0] > range_b[0]) {
                return -1;
            }

            // then ui_difficulty_index low to high
            var ui_diff_a = base_a['ui_difficulty_index'] || 0;
            var ui_diff_b = base_b['ui_difficulty_index'] || 0;
            if(ui_diff_a < ui_diff_b) {
                return -1;
            } else if(ui_diff_a > ui_diff_b) {
                return 1;
            }

            // then level low to high
            if(a.get_player_level() < b.get_player_level()) {
                return -1;
            } else if(a.get_player_level() > b.get_player_level()) {
                return 1;
            }

            // use user_id as final sort key to ensure stable order for AIs
            if(a.user_id < b.user_id) {
                return 1;
            } else if(a.user_id > b.user_id) {
                return -1;
            }
            return 0;
        };
        item_list.sort(goog.array.contains(['computers','hitlist'], chapter) ?
                       compare_by_ai_level : Friend.compare_by_player_level);
    }


    // now fill in the dialog widgets
    var row = 0;

    var rows_per_page = 5; // how many rows show up on each page

    var chapter_friends = item_list.length; // total number of entries in this chapter

    // how many pages are in this chapter
    var chapter_pages = Math.floor((chapter_friends+rows_per_page-1)/rows_per_page);

    // reset the page index if it's out of bounds
    dialog.user_data['page'] = page = (chapter_pages === 0 ? 0 : clamp(page, 0, chapter_pages-1));

    dialog.user_data['quarries_on_page'] = [];
    dialog.user_data['friends_on_page'] = [];

    if(chapter_pages > 0) {
        // if any friends are to be shown

        // indices of the first and last friends able to be shown in the page
        var first_friend_on_page = page * rows_per_page;
        var last_friend_on_page = (page+1)*rows_per_page - 1;
        last_friend_on_page = Math.max(0, Math.min(last_friend_on_page, chapter_friends-1));

        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_friend_on_page+1).toString()).replace('%d2',(last_friend_on_page+1).toString()).replace('%d3',chapter_friends.toString());

        for(var i = first_friend_on_page; i <= last_friend_on_page; i++) {
            dialog.widgets['row_bg'+row].show = true;
            dialog.widgets['row_bg'+row].color = SPUI.make_colorv(dialog.data['widgets']['row_bg'][('color_'+chapter in dialog.data['widgets']['row_bg'] ? 'color_'+chapter : 'color')]);
            dialog.widgets['row_portrait_outline'+row].show = true;
            dialog.widgets['row_portrait_outline'+row].outline_color = SPUI.make_colorv(dialog.data['widgets']['row_portrait_outline'][('outline_color_'+chapter in dialog.data['widgets']['row_portrait_outline'] ? 'outline_color_'+chapter : 'outline_color')]);
            dialog.widgets['row_challenge_icon_bg'+row].show =
                dialog.widgets['row_challenge_icon'+row].show =
                dialog.widgets['row_challenge_button'+row].show = false;

            for(var h = 0; h < dialog.data['widgets']['row_star_holes']['array'][0]; h++) {
                dialog.widgets[SPUI.get_array_widget_name('row_stars', dialog.data['widgets']['row_stars']['array'], [h,row])].show = false;
                dialog.widgets[SPUI.get_array_widget_name('row_star_holes', dialog.data['widgets']['row_star_holes']['array'], [h,row])].show = false;
            }

            if(chapter === 'quarries') {
                var quarry = item_list[i];
                dialog.user_data['quarries_on_page'].push(quarry);
                var landlord = PlayerCache.query_sync(quarry['base_landlord_id']);

                dialog.widgets['row_portrait'+row].show = true;
                dialog.widgets['row_portrait'+row].set_user(quarry['base_landlord_id'] || null);

                var info_func = (function(_landlord) { return function() {
                    if(_landlord && !is_ai_user_id_range(_landlord['user_id'])) {
                        PlayerInfoDialog.invoke(_landlord['user_id']);
                    }
                }; })(landlord);

                dialog.widgets['row_portrait'+row].onclick =
                    dialog.widgets['row_attackability'+row].onclick =
                    dialog.widgets['row_name'+row].onclick = info_func;

                dialog.widgets['row_name'+row].show = true;
                dialog.widgets['row_name'+row].str = quarry['base_ui_name'];
                dialog.widgets['row_level'+row].show = false;



                dialog.widgets['row_qicon'+row].show = true;
                dialog.widgets['row_qicon'+row].bg_image = 'resource_icon_'+quarry['base_icon'];

                var TIMELEFT = [[1, 'low'], [3600, 'medium'], [43200, 'full']];
                var fullness_state;
                if(quarry['base_expire_time'] < 0) {
                    fullness_state = 'full';
                } else {
                    fullness_state = 'empty';
                    for(var r = 0; r < TIMELEFT.length; r++) {
                        if((quarry['base_expire_time'] - server_time) >= TIMELEFT[r][0]) {
                            fullness_state = TIMELEFT[r][1];
                        } else { break; }
                    }
                }

                var rich_str = quarry_richness_ui_str(quarry['base_richness']);

                dialog.widgets['row_qstat'+row].show = true;
                dialog.widgets['row_qstat'+row].state = fullness_state;

                var qtip;
                if(1) {
                    var data = dialog.data['widgets']['row_qstat'];
                    var ui_long_rich_str = (rich_str in data['ui_tooltip_sizes'] ? data['ui_tooltip_sizes'][rich_str] : rich_str);
                    qtip = data['ui_tooltip_'+fullness_state].replace('%SIZE', ui_long_rich_str).replace('%RESOURCE', gamedata['resources'][quarry['base_icon']]['ui_name']);
                }

                dialog.widgets['row_qsize'+row].show = true;
                dialog.widgets['row_qsize'+row].str = rich_str;

                dialog.widgets['row_qstat'+row].tooltip.str =
                    dialog.widgets['row_qicon'+row].tooltip.str =
                    dialog.widgets['row_qsize'+row].tooltip.str = qtip;

                dialog.widgets['row_qstat'+row].onclick =
                dialog.widgets['row_qicon'+row].onclick =
                    dialog.widgets['row_qsize'+row].onclick = function() { invoke_ingame_tip('map_quarries_tip', {frequency: GameTipFrequency.ALWAYS}); };

                dialog.widgets['row_progress'+row].show = false;
                dialog.widgets['row_progress_str'+row].show = false;

                // abuse old protection/cooldown fields for Quarry info
                dialog.widgets['row_attackability'+row].text_color = SPUI.default_text_color;
                dialog.widgets['row_attackability'+row].show = true;
                if(landlord) {
                    dialog.widgets['row_attackability'+row].str = dialog.data['widgets']['row_attackability']['ui_name_owner'].replace('%s', PlayerCache.get_ui_name(landlord));
                } else {
                    dialog.widgets['row_attackability'+row].str = dialog.data['widgets']['row_attackability']['ui_name_no_owner'];
                }
                // Spy button and travel timers are updated per-frame in update_map_dialog()

            } else { // NOT quarries
                var friend = item_list[i];
                dialog.user_data['friends_on_page'].push(friend);

                // portrait
                dialog.widgets['row_portrait'+row].show = true;
                var display_name = friend.get_ui_name();
                dialog.widgets['row_portrait'+row].set_user(friend.user_id, true); // override portrait with map_portrait, if applicable

                var base = null;
                if(friend.is_ai()) {
                    // AI

                    // will be overridden in update_map_dialog()
                    dialog.widgets['row_portrait'+row].onclick =
                        dialog.widgets['row_name'+row].onclick = null;

                    base = gamedata['ai_bases_client']['bases'][friend.user_id.toString()];
                    if(base && 'ui_map_name' in base) {
                        display_name = base['ui_map_name']; // override normal display name
                    }
                } else {
                    dialog.widgets['row_portrait'+row].onclick =
                        dialog.widgets['row_name'+row].onclick = (function (_uid) {
                            return function() { PlayerInfoDialog.invoke(_uid); };
                        })(friend.user_id);
                }

                // name/level/battles
                dialog.widgets['row_name'+row].show = true;
                dialog.widgets['row_name'+row].str = display_name;

                dialog.widgets['row_info_button'+row].show = false;
                var show_battle_stars = (base && gamedata['client']['map_dialog_battle_stars_column'] && ('ui_battle_stars_key' in base));
                if(show_battle_stars) {
                    dialog.widgets['row_ai_difficulty'+row].show =
                        dialog.widgets['row_level'+row].show = false;
                    for(var h = 0; h < dialog.data['widgets']['row_star_holes']['array'][0]; h++) {
                        var star_count = player.history[base['ui_battle_stars_key']] || 0;
                        dialog.widgets[SPUI.get_array_widget_name('row_stars', dialog.data['widgets']['row_stars']['array'], [h,row])].show = (h < star_count);
                        dialog.widgets[SPUI.get_array_widget_name('row_star_holes', dialog.data['widgets']['row_star_holes']['array'], [h,row])].show = true;
                    }
                    // add the level number to the display name, since we're hiding the normal level display
                    dialog.widgets['row_name'+row].str += ' (L'+friend.get_player_level().toString()+')';

                } else {
                    dialog.widgets['row_level'+row].show = true;
                    dialog.widgets['row_level'+row].str = dialog.data['widgets']['row_level']['ui_name'].replace('%s', friend.get_player_level().toString());

                    var level_color = SPUI.default_text_color, show_difficulty = false;
                    if(friend.is_ai() && player.get_any_abtest_value('map_dialog_ai_difficulty', gamedata['client']['map_dialog_ai_difficulty'])) {
                        var difficulty = friend.classify_ai_difficulty();
                        if(difficulty) {
                            show_difficulty = true;
                            dialog.widgets['row_ai_difficulty'+row].str = dialog.data['widgets']['row_ai_difficulty']['ui_name_'+difficulty];
                            dialog.widgets['row_ai_difficulty'+row].tooltip.str = null;
                            level_color = SPUI.make_colorv(dialog.data['widgets']['row_ai_difficulty']['text_color_'+difficulty]);
                            dialog.widgets['row_ai_difficulty'+row].text_color = level_color;
                        }
                        if(base && ('ui_difficulty_comment' in base)) { // this can override the default string
                            var comment = eval_cond_or_literal(base['ui_difficulty_comment'], player, null);
                            if(comment !== null) {
                                var max_len = dialog.data['widgets']['row_ai_difficulty']['max_len'];
                                if(comment.length > max_len) {
                                    dialog.widgets['row_ai_difficulty'+row].str = comment.slice(0,max_len) + '...';
                                    dialog.widgets['row_ai_difficulty'+row].tooltip.str = comment;
                                } else {
                                    dialog.widgets['row_ai_difficulty'+row].str = comment;
                                    dialog.widgets['row_ai_difficulty'+row].tooltip.str = null;
                                }
                            }
                        }
                    }
                    dialog.widgets['row_ai_difficulty'+row].show = show_difficulty;
                    dialog.widgets['row_level'+row].text_color = level_color;
                }

                dialog.widgets['row_qsize'+row].show = false;
                dialog.widgets['row_qicon'+row].show = false;
                dialog.widgets['row_qstat'+row].show = false;

                dialog.widgets['row_progress'+row].show = false;
                dialog.widgets['row_progress_str'+row].show = false;
                if(friend.is_ai()) {
                    if(base && ('ui_progress' in base)) {
                        // hide level/difficulty display, unless base asks for it
                        if(!base['ui_progress']['show_level']) {
                            dialog.widgets['row_level'+row].show = false;
                            dialog.widgets['row_ai_difficulty'+row].show = false;
                        }

                        if('cur' in base['ui_progress']) {
                            // show progress bar
                            dialog.widgets['row_progress'+row].show = true;
                            dialog.widgets['row_progress_str'+row].show = true;
                            dialog.widgets['row_progress'+row].progress = base['ui_progress']['cur']/base['ui_progress']['max'];
                            if(base['ui_progress']['cur'] >= base['ui_progress']['max']) {
                                dialog.widgets['row_progress'+row].full_color = SPUI.make_colorv(dialog.data['widgets']['row_progress']['full_color_complete']);
                                dialog.widgets['row_progress_str'+row].str = dialog.data['widgets']['row_progress_str']['ui_name_complete'];
                            } else {
                                dialog.widgets['row_progress'+row].full_color = SPUI.make_colorv(dialog.data['widgets']['row_progress']['full_color']);
                                dialog.widgets['row_progress_str'+row].str = dialog.data['widgets']['row_progress_str']['ui_name'].replace('%cur', base['ui_progress']['cur'].toString()).replace('%max', base['ui_progress']['max'].toString());
                            }
                        } else {
                            // do not show progress bar
                            dialog.widgets['row_progress'+row].show = false;
                            dialog.widgets['row_progress_str'+row].show = false;
                        }
                    }

                    if(base && ('ui_info_url' in base)) {
                        var info_url = eval_cond_or_literal(base['ui_info_url'], player, null);
                        if(info_url) {
                            var opener = (function (_info_url) { return function() {
                                url_open_in_new_tab(_info_url);
                            }; })(info_url);

                            // "?" Info button and level display are mutually exclusive
                            dialog.widgets['row_info_button'+row].show = true;
                            dialog.widgets['row_level'+row].show = false;
                            dialog.widgets['row_ai_difficulty'+row].show = false;
                            dialog.widgets['row_info_button'+row].onclick = opener;

                            // also link portrait and name to the URL
                            dialog.widgets['row_portrait'+row].onclick =
                                dialog.widgets['row_name'+row].onclick = opener;
                        }
                    }

                    if(base && (base['challenge_icon'] || base['challenge_item'])) {
                        goog.array.forEach(['row_challenge_icon','row_challenge_icon_bg'], function(wname) {
                            dialog.widgets[wname+row].xy = vec_add(dialog.data['widgets'][wname][show_battle_stars ? 'xy_stars' : 'xy'], vec_scale(row, dialog.data['widgets'][wname]['array_offset']));
                        });
                        if(base['challenge_item']) {
                            var item = eval_cond_or_literal(base['challenge_item'], player, null);
                            if(item) {
                                dialog.widgets['row_challenge_icon'+row].show = true;
                                dialog.widgets['row_challenge_icon_bg'+row].show = true;
                                var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
                                ItemDisplay.set_inventory_item_asset(dialog.widgets['row_challenge_icon'+row], spec);
                                ItemDisplay.attach_inventory_item_tooltip(dialog.widgets['row_challenge_icon'+row], item, dialog);
                            }
                        } else if(base['challenge_icon']) {
                            var icon = eval_cond_or_literal(base['challenge_icon'], player, null);
                            if(icon) {
                                dialog.widgets['row_challenge_icon'+row].show = true;
                                dialog.widgets['row_challenge_icon_bg'+row].show = false;
                                ItemDisplay.remove_inventory_item_tooltip(dialog.widgets['row_challenge_icon'+row]);
                                dialog.widgets['row_challenge_icon'+row].asset = icon;
                            }
                        }
                    }
                    if(base && base['ui_challenge_button_consequent']) {
                        dialog.widgets['row_challenge_button'+row].show = true;
                        dialog.widgets['row_challenge_button'+row].str = base['ui_challenge_button_name'];
                        dialog.widgets['row_challenge_button'+row].tooltip.str = base['ui_challenge_button_tooltip'] || null;
                        dialog.widgets['row_challenge_button'+row].onclick = (function (_cons) { return function(w) {
                            read_consequent(_cons).execute(player, null);
                        }; })(base['ui_challenge_button_consequent']);
                    }
                }

                dialog.widgets['row_travel0'+row].show = false;
                dialog.widgets['row_travel1'+row].show = false;

                // if player is still in the tutorial, disable irrelevant buttons
                if(player.tutorial_state != 'COMPLETE') {
                    if(chapter != 'computers' || row != 0) {
                        dialog.widgets['row_button'+row].state = 'disabled';
                    }
                }
            } // END not quarries

            row += 1;
        }
    } else {
        // no friends in the list
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(0).toString()).replace('%d2',(0).toString()).replace('%d3',(0).toString());
    }

    // clear out empty rows
    while(row < rows_per_page) {
        dialog.widgets['row_bg'+row].show =
            dialog.widgets['row_portrait'+row].show =
            dialog.widgets['row_portrait_outline'+row].show =
            dialog.widgets['row_name'+row].show =
            dialog.widgets['row_level'+row].show =
            dialog.widgets['row_challenge_icon_bg'+row].show =
            dialog.widgets['row_challenge_icon'+row].show =
            dialog.widgets['row_challenge_button'+row].show =
            dialog.widgets['row_ai_difficulty'+row].show =
            dialog.widgets['row_info_button'+row].show =
            dialog.widgets['row_qsize'+row].show =
            dialog.widgets['row_qicon'+row].show =
            dialog.widgets['row_qstat'+row].show =
            dialog.widgets['row_travel0'+row].show =
            dialog.widgets['row_travel1'+row].show =
            dialog.widgets['row_progress'+row].show =
            dialog.widgets['row_progress_str'+row].show =
            dialog.widgets['row_button'+row].show = false;
        for(var h = 0; h < dialog.data['widgets']['row_star_holes']['array'][0]; h++) {
            dialog.widgets[SPUI.get_array_widget_name('row_stars', dialog.data['widgets']['row_stars']['array'], [h,row])].show = false;
            dialog.widgets[SPUI.get_array_widget_name('row_star_holes', dialog.data['widgets']['row_star_holes']['array'], [h,row])].show = false;
        }
        row += 1;
    }

    // set clickability of scroll arrows
    if(page != 0) {
        dialog.widgets['scroll_left'].state = 'normal';
    } else {
        dialog.widgets['scroll_left'].state = 'disabled';
    }

    if(page < (chapter_pages-1)) {
        dialog.widgets['scroll_right'].state = 'normal';
    } else {
        dialog.widgets['scroll_right'].state = 'disabled';
    }

    dialog.widgets['scroll_left'].onclick = function(w) { map_dialog_change_page(w.parent, w.parent.user_data['chapter'], w.parent.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function(w) { map_dialog_change_page(w.parent, w.parent.user_data['chapter'], w.parent.user_data['page']+1); };

    // disable irrelevant buttons during tutorial
    if(player.tutorial_state != "COMPLETE") {
        dialog.widgets['scroll_left'].state =
            dialog.widgets['scroll_right'].state = 'disabled';
    }
}

function invoke_fullscreen_instructions() {
    player.record_feature_use('fullscreen_dialog');
    change_selection(null);
    var dialog = new SPUI.Dialog(gamedata['dialogs']['fullscreen_instructions']);
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['flavor'].str = gamedata['strings']['fullscreen_instructions_flavor_text'];
    dialog.widgets['ok_button'].onclick =
        dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };
    if(spin_demographics['browser_OS'] === "Mac") {
        dialog.widgets['os'].str = dialog.data['widgets']['os']['ui_name'].replace('%s', 'Mac');
        // note: Safari seems to ignore the keyboard shortcut now?
        dialog.widgets['key'].str = (spin_demographics['browser_name'] === 'Safari' ? 'View Menu ->\nEnter Full Screen' : '\u2318-Shift-F'); // Unicode for Mac command key
    } else if(spin_demographics['browser_OS'] === "Windows") {
        dialog.widgets['os'].str = dialog.data['widgets']['os']['ui_name'].replace('%s', 'Windows');
        dialog.widgets['key'].str = 'F11';
    } else {
        change_selection_ui(null);
    }
    return dialog;
}

function invoke_fullscreen_prompt() {
    // doesn't make sense to call this unless true fullscreen is available
    if(!has_true_fullscreen()) { throw Error('browser does not support true fullscreen'); }

    // full screen already?
    if(canvas_is_fullscreen) { return null; }

    if(player.record_feature_use('fullscreen_prompt')) {
        metric_event('6500_fullscreen_prompt', add_demographics({}));
    }

    change_selection(null);
    var dialog = new SPUI.Dialog(gamedata['dialogs']['fullscreen_prompt']);
    dialog.user_data['dialog'] = 'fullscreen_prompt';
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['ok_button'].onclick = function(w) {
        close_parent_dialog(w);
        toggle_true_fullscreen();
    };

    // arrow pointing to ok_button
    read_consequent({'consequent':'TUTORIAL_ARROW', 'child': 1,
                     'arrow_type':'button',
                     'direction':'down',
                     'dialog_name':'fullscreen_prompt',
                     'widget_name':'ok_button'}).execute();

    // optional "Don't show again" button
    if((player.history['logged_in_times'] || 0 >= 5)) {
        dialog.widgets['ignore_button'].show = true;
        dialog.widgets['ignore_button'].onclick = function(w) {
            w.state = (w.state == 'active' ? 'normal' : 'active');
            player.preferences['ignore_fullscreen_prompt'] = (w.state == 'active' ? 1 : 0);
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
        };
    }

    return dialog;
}

function invoke_daily_tip_pages(tiplist) {
    if(tiplist.length < 1) { return null; }
    var dialog = new SPUI.Dialog(gamedata['dialogs']['daily_tip_pageable']);
    dialog.user_data['dialog'] = 'daily_tip_pageable';
    dialog.user_data['tiplist'] = tiplist;
    dialog.user_data['idx'] = -1;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['next_button'].onclick = function(w) {
        var _dialog = w.parent;
        if(_dialog.user_data['idx']+1 >= _dialog.user_data['tiplist'].length) {
            close_parent_dialog(w);
        } else {
            daily_tip_pageable_show_tip(_dialog, _dialog.user_data['idx']+1);
        }
    };
    dialog.widgets['prev_button'].onclick = function(w) {
        var _dialog = w.parent;
        daily_tip_pageable_show_tip(_dialog, _dialog.user_data['idx']-1);
    };

    // show oldest non-understood tip
    var i;
    for(i = 0; i < tiplist.length; i++) {
        if(!tiplist[i]['understood']) { break; }
    }
    i = Math.min(i, tiplist.length-1);
    dialog.ondraw = update_daily_tip_pageable;
    daily_tip_pageable_show_tip(dialog, i);
    return dialog;
}

function daily_tip_pageable_show_tip(dialog, idx) {
    dialog.user_data['idx'] = idx;
    var tip = dialog.user_data['tiplist'][idx];
    if(!tip['understood']) {
        tip['understood'] = 1;
        send_to_server.func(["DAILY_TIP_UNDERSTOOD", tip['name'], true]);
    }

    dialog.widgets['description'].clear_text();
    if('ui_description' in tip) {
        dialog.widgets['description'].append_text(SPText.cstring_to_ablocks_bbcode(tip['ui_description'], null, system_chat_bbcode_click_handlers));
    }

    var image_name = ('image' in tip ? tip['image'] : gamedata['game_id']+'_pageable_generic.jpg');
    var image_url = GameArt.art_url('art/daily_tips/'+image_name, false);
    var img = new Image();
    img.crossOrigin = 'Anonymous';
    img.src = image_url;
    dialog.widgets['picture'].raw_image = img;

    var tiplist = dialog.user_data['tiplist'];
    dialog.widgets['next_button'].state = ((idx < tiplist.length-1) ? (!tiplist[idx+1]['understood'] ? 'active' : 'normal') : 'disabled');
    //dialog.widgets['next_button'].str = dialog.data['widgets']['next_button']['ui_name'+((idx >= tiplist.length-1) ? '_close' : '')];
    dialog.widgets['prev_button'].state = (idx > 0 ? 'normal' : 'disabled');
    dialog.default_button = (dialog.widgets['next_button'].state == 'active' ? dialog.widgets['next_button'] : dialog.widgets['close_button']);
}

// this mainly just handles the link button
/** @param {SPUI.Dialog} dialog */
function update_daily_tip_pageable(dialog) {
    var idx = dialog.user_data['idx'];
    if(idx < 0 || dialog.user_data['tiplist'].length < 1) { return; }
    var tip = dialog.user_data['tiplist'][idx];

    dialog.widgets['link_button'].show = false;

    if(('link_button_url' in tip) || ('link_button_consequent' in tip) &&
       (!('link_button_show_if' in tip) || read_predicate(tip['link_button_show_if']).is_satisfied(player,null))) {
        var url = eval_cond_or_literal(tip['link_button_url'] || null, player, null);
        if(url) { url = url_put_info(url, session.user_id, player.history['money_spent']||0); }

        var cons = null, helper = null, helper_tooltip = null;
        if(tip['link_button_consequent']) {
            if('link_button_activation' in tip) {
                var pred = read_predicate(tip['link_button_activation']);
                if(pred.is_satisfied(player,null)) {
                    cons = tip['link_button_consequent'];
                } else {
                    helper_tooltip = pred.ui_describe(player);
                    helper = get_requirements_help(pred);
                    // show the tooltip even if we can't provide help
                    if(helper_tooltip && !helper) { helper = function() {}; }
                }
            } else {
                cons = tip['link_button_consequent'];
            }
        }

        if(url || cons || helper) {
            dialog.widgets['link_button'].show =
                dialog.widgets['picture_click_catcher'].show = true;
            if('link_button_bg_image' in tip) {
                dialog.widgets['link_button'].bg_image = tip['link_button_bg_image'];
            } else {
                dialog.widgets['link_button'].bg_image = dialog.data['widgets']['link_button']['bg_image'];
            }
            if('link_button_ui_name' in tip) {
                dialog.widgets['link_button'].str = tip['link_button_ui_name'];
            } else {
                dialog.widgets['link_button'].str = dialog.data['widgets']['link_button']['ui_name'];
            }
            dialog.widgets['link_button'].state = (cons || url) ? 'normal' : 'disabled_clickable';
            dialog.widgets['link_button'].tooltip.str = helper_tooltip;
            dialog.widgets['picture_click_catcher'].onclick =
                dialog.widgets['link_button'].onclick = (function (_url, _cons, _helper) { return function() {
                    if(_url) {
                        url_open_in_new_tab(_url);
                    }
                    if(_cons) { change_selection_ui(null); read_consequent(_cons).execute(); }
                    if(_helper) { _helper(); }
                }; })(url, cons, helper);
        }
    }
}

/** @param {string} tipname
    @param {boolean=} skip_notification_queue
    @param {?Object=} notification_params
*/
function invoke_daily_tip(tipname, skip_notification_queue, notification_params) {
    var tip = null;
    for(var i = 0; i < gamedata['daily_tips'].length; i++) {
        var t = gamedata['daily_tips'][i];
        if(t['name'] == tipname) {
            tip = t;
            break;
        }
    }
    if(!tip) { console.log('daily tip '+tipname+' not found!'); return; }
    if(tip['kind'] == 'pageable') { return invoke_daily_tip_pages([tip]); } // for testing only
    if('consequent' in tip) {
        // new-style pure consequent
        read_consequent(tip['consequent']).execute({'daily_tip': tip['name']});
        return;
    }

    // load img asynchronously and display when ready
    var img = new Image();

    var complete_cb = (function (_tip, _img) { return function() {
        var dialog = new SPUI.Dialog(gamedata['dialogs']['daily_tip']);
        dialog.user_data['dialog'] = 'daily_tip';
        install_child_dialog(dialog);
        dialog.auto_center();
        dialog.modal = true;
        dialog.widgets['picture'].raw_image = _img;
        var go_away = function (_name, _ack, _url, _cons) { return function(widget) {
            send_to_server.func(["DAILY_TIP_UNDERSTOOD", _name, _ack]);
            close_parent_dialog(widget);
            if(_url) {
                url_open_in_new_tab(_url);
            }
            if(_cons) {
                read_consequent(_cons).execute();
            }
        }; };
        dialog.widgets['close_button'].onclick = go_away(_tip['name'], false, null, null);
        dialog.widgets['ok_button'].onclick = go_away(_tip['name'], true,
                                                      ('understood_button_url' in _tip ?
                                                       url_put_info(_tip['understood_button_url'], session.user_id, player.history['money_spent'] || 0) : null),
                                                      tip['understood_button_consequent'] || null);

        if('sound' in _tip) {
            GameArt.play_canned_sound(_tip['sound']);
        }
        if('alloy_bonus_hack' in _tip) {
            var data = _tip['alloy_bonus_hack'];
            dialog.widgets['alloy_bonus'].show = data['enable'];
            dialog.widgets['alloy_bonus'].str = dialog.data['widgets']['alloy_bonus']['ui_name'].replace('%d', Store.display_user_currency_amount(player.get_any_abtest_value('free_gamebucks_veteran',
                                                                                                                                                                              gamedata['starting_conditions']['veteran_gamebucks']), 'full'));
        }
        if(('link_button_url' in _tip) || ('link_button_consequent' in _tip)) {

            var url = eval_cond_or_literal(_tip['link_button_url'] || null, player, null);
            if(url) { url = url_put_info(url, session.user_id, player.history['money_spent']||0) }
            var cons = (_tip['link_button_consequent'] || null);
            if(url || cons) {
                dialog.widgets['link_button'].show = true;
                dialog.widgets['link_button'].xy = _tip['link_button_xy'];
                if('link_button_bg_image' in _tip) { dialog.widgets['link_button'].bg_image = _tip['link_button_bg_image']; }
                if('link_button_ui_name' in _tip) {
                    dialog.widgets['link_button'].str = _tip['link_button_ui_name'];
                }
                dialog.widgets['link_button'].onclick = (function (_url, _cons) { return function() {
                    if(_url) {
                        url_open_in_new_tab(_url);
                    }
                    if(_cons) { change_selection_ui(null); read_consequent(_cons).execute(); }
                }; })(url, cons);
            }
        }
        apply_dialog_hacks(dialog, _tip);
    }; })(tip, img);

    img.onload = (function (cb, _skip_notification_queue, _notification_params) {
        return function() {
            if (!_skip_notification_queue) {
                notification_queue.push(cb, _notification_params);
            } else {
                cb();
            }
        };
    })(complete_cb, skip_notification_queue || false, notification_params || null);
    img.crossOrigin = 'Anonymous';
    img.src = GameArt.art_url('art/daily_tips/'+tip['image'], false);
}

// common function used by daily tips and AI base completion Consequents (DISPLAY_MESSAGE)
// to apply widget hacks to the dialog
/** @param {SPUI.Dialog} dialog
    @param {Object} _tip
    @param {Object=} consequent_context */
function apply_dialog_hacks(dialog, _tip, consequent_context) {
    dialog.user_data['consequent_context'] = consequent_context || null;
    if('sunken_asset' in _tip) {
        dialog.widgets['sunken'].asset = _tip['sunken_asset'];
    }
    if('picture_asset' in _tip) {
        dialog.widgets['picture'].asset = _tip['picture_asset'];
    }
    if('inset_picture' in _tip) {
        dialog.widgets['inset_picture'].show = true;
        dialog.widgets['inset_picture'].asset = _tip['inset_picture'];
        if('inset_picture_xy' in _tip) { dialog.widgets['inset_picture'].xy = _tip['inset_picture_xy']; }
        if('inset_picture_dimensions' in _tip) { dialog.widgets['inset_picture'].wh = _tip['inset_picture_dimensions']; }
    }
    if('unit_icon' in _tip) {
        var spec = gamedata['units'][_tip['unit_icon']] || gamedata['buildings'][_tip['unit_icon']] || null;
        if(spec) {
            dialog.widgets['unit_icon'].show = true;
            dialog.widgets['unit_icon'].asset = get_leveled_quantity(spec['art_asset'], 1);
        }
        if('unit_icon_xy' in _tip) { dialog.widgets['unit_icon'].xy = _tip['unit_icon_xy']; }
    }

    if('understood_button_xy' in _tip) {
        dialog.widgets['ok_button'].xy = _tip['understood_button_xy'];
    }
    if('understood_button_dimensions' in _tip) {
        dialog.widgets['ok_button'].wh = vec_copy(_tip['understood_button_dimensions']);
    }
    if('understood_button_ui_name' in _tip) {
        dialog.widgets['ok_button'].str = _tip['understood_button_ui_name'];
    }
    if('understood_button_bg_image' in _tip) {
        dialog.widgets['ok_button'].bg_image = _tip['understood_button_bg_image'];
    }

    if('understood_button_onclick' in _tip) {
        var old_cb = dialog.widgets['ok_button'].onclick;
        var new_cb = null;
        if(_tip['understood_button_onclick'] == 'invoke_curiosity_research') {
            new_cb = function(w) {
                invoke_upgrade_tech_dialog('curiosity_production', null);
            };
        } else if(_tip['understood_button_onclick'] == 'invoke_store_specials') {
            new_cb = function(w) {
                invoke_store('specials');
            };
        }
        if(new_cb) {
            dialog.widgets['ok_button'].onclick = (function (_new, _old) { return function(w) {
                _old(w);
                _new(w);
            }; })(new_cb, old_cb);
        }
    }
    if('event_video_hack' in _tip && _tip['event_video_hack']['enable']) {
        var hack = _tip['event_video_hack'];
        if(!hack['show_if'] || read_predicate(hack['show_if']).is_satisfied(player, null)) {
            var old_cb = dialog.widgets['ok_button'].onclick;
            var new_cb = (function (_old_cb, _hack) { return function(w) {
                _old_cb(w);
                // create a fake dialog underneath the video widget just for the modal background-darkening effect
                var dialog = new SPUI.Dialog(gamedata['dialogs']['null_dialog']);
                dialog.transparent_to_mouse = true;
                dialog.auto_center();
                dialog.modal = true;
                change_selection_ui(dialog);
                var close_cb = (function (_dialog) { return function() { change_selection_ui(null); }; })(dialog);
                SPVideoWidget.init_youtube(SPVideoWidget.make_youtube_url(_hack['youtube_id']), close_cb);
            }; })(old_cb, hack);
            var wname = hack['widget'] || 'ok_button';
            dialog.widgets[wname].onclick = new_cb;
        }
    }
    if('ui_description' in _tip) {
        dialog.widgets['description'].show = true;
        if('description_xy' in _tip) { dialog.widgets['description'].xy = _tip['description_xy']; }
        if('description_dimensions' in _tip) { dialog.widgets['description'].wh = _tip['description_dimensions']; }
        dialog.widgets['description'].set_text_with_linebreaking(_tip['ui_description']);
    }
    if('event_countdown_hack' in _tip && _tip['event_countdown_hack']['enable']) {
        var hack = _tip['event_countdown_hack'];
        dialog.widgets['event_countdown'].show = 1;
        if('text_hjustify' in hack) { dialog.widgets['event_countdown'].text_hjustify = hack['text_hjustify']; }
        if('ui_title' in hack) { dialog.widgets['event_countdown_title'].str = hack['ui_title']; }
        if('ui_value' in hack) {
            dialog.widgets['event_countdown'].str = hack['ui_value'];
        } else {
            var update_cb = (function (_hack) { return function(w) {
                var time_to_print;
                if(_hack['reset_origin_time']) {
                    // count down to end of current repetition interval
                    var now = player.get_absolute_time();
                    var this_period_end = ((Math.floor( (now - _hack['reset_origin_time']) / _hack['reset_interval'] ) + 1) * _hack['reset_interval']) + _hack['reset_origin_time'];
                    time_to_print = (this_period_end - now);
                } else if(_hack['aura_name']) {
                    // count down remaining aura duration
                    var aura = goog.array.find(player.player_auras, function(a) { return a['spec'] === _hack['aura_name']; });
                    if(aura) {
                        time_to_print = aura['end_time'] - server_time;
                    } else {
                        time_to_print = 0;
                    }
                } else {
                    // count down to start or end of event
                    time_to_print = -player.get_event_time(_hack['event_kind'] || 'current_event', _hack['event_name'] || null, _hack['method'], true);
                }
                var ui_name = _hack['ui_name'] || w.data['ui_name'];
                var precision = ('time_precision' in _hack ? _hack['time_precision'] : 2);
                var spell_out = ('spell_time_units' in _hack ? _hack['spell_time_units'] : true);
                w.str = ui_name.replace('%s', do_pretty_print_time(time_to_print, precision, spell_out));
            }; })(hack);
            if(hack['realtime']) {
                // update every frame
                dialog.widgets['event_countdown'].ondraw = update_cb;
            } else {
                // update once only
                update_cb(dialog.widgets['event_countdown']);
            }
        }
        if('xy' in hack) { dialog.widgets['event_countdown'].xy = hack['xy']; }
        if('dimensions' in hack) { dialog.widgets['event_countdown'].wh = hack['dimensions']; }
        if('text_size' in hack) { dialog.widgets['event_countdown'].font = SPUI.make_font(hack['text_size'], hack['text_size']+3, hack['text_style'] || 'bold'); }
        if('text_color' in hack) { var col = hack['text_color']; dialog.widgets['event_countdown'].text_color = new SPUI.Color(col[0], col[1], col[2], col[3]); }
        if('text_hjustify' in hack) { dialog.widgets['event_countdown'].text_hjustify = hack['text_hjustify']; }
    }
    if('event_victories_hack' in _tip && _tip['event_victories_hack']['enable']) {
        var hack = _tip['event_victories_hack'];
        dialog.widgets['event_victories'].show =
            dialog.widgets['event_victories_bar'].show = 1;
        var cur = player.history[hack['history_key']] || 0;
        dialog.widgets['event_victories'].str = dialog.data['widgets']['event_victories']['ui_name'].replace('%d1', pretty_print_number(cur)).replace('%d2', pretty_print_number(hack['max']));
        dialog.widgets['event_victories_bar'].progress = cur/hack['max'];
    }
    if('logged_in_times_hack' in _tip && _tip['logged_in_times_hack']['enable']) {
        var hack = _tip['logged_in_times_hack'];
        dialog.widgets['logged_in_times'].show = true;
        var cur;
        if('number' in hack) {
            cur = hack['number'];
        } else {
            cur = player.history['logged_in_times'] || 0;
        }
        dialog.widgets['logged_in_times'].str = dialog.data['widgets']['logged_in_times']['ui_name_'+(cur==1?'one':'many')].replace('%d', cur.toString());
    }
    if('showcase_hack' in _tip) {
        Showcase.apply_showcase_hacks(dialog, _tip['showcase_hack']);
    }
}

/** @enum {number} */
var GameTipFrequency = {
    ONCE_ONLY: 1, // only show one time, ever
    ALWAYS: 2, // always show
    ALWAYS_UNLESS_IGNORED: 3 // always show, unless player has set ignore: preference
};

/** These are not daily tips, but small one-time GUI messages that pop up for certain actions.
    @param {string} name
    @param {({frequency: (GameTipFrequency|undefined),
              dialog_options: (Object|undefined),
              ignore_button_ui_name: (string|null|undefined),
              replacements: (Object.<string,string>|undefined)}|null)=} options
    @return {SPUI.Dialog|null} */
function invoke_ingame_tip(name, options) {
    if(!options) { options = {frequency:undefined, dialog_options:undefined, ignore_button_ui_name:undefined, replacements:undefined}; }

    /** @type {!GameTipFrequency} */
    var frequency = options.frequency || GameTipFrequency.ONCE_ONLY;

    if(frequency == GameTipFrequency.ONCE_ONLY && player.check_feature_use(name)) {
        return null;
    }
    /** @type {string|null} */
    var ignore_key = null;
    if(frequency == GameTipFrequency.ALWAYS_UNLESS_IGNORED) {
        ignore_key = 'ignore_tip:'+name;
        if(player.preferences[ignore_key]) {
            return null;
        }
    }

    player.record_feature_use(name);
    var tip = gamedata['strings'][name];

    var dialog_options = options.dialog_options || {};
    dialog_options['dialog'] = options.dialog || 'message_dialog_big';
    var descr = tip['ui_description'];
    if(options.replacements) {
        for(var k in options.replacements) {
            descr = descr.replace(k, options.replacements[k]);
        }
    }
    var dialog = invoke_child_message_dialog(tip['ui_title'], descr, dialog_options);

    if(ignore_key) {
        if('ignore_button' in dialog.widgets) {
            dialog.widgets['ignore_button'].show = true;
            if(options.ignore_button_ui_name) {
                dialog.widgets['ignore_button'].str = options.ignore_button_ui_name;
            }
            dialog.widgets['ignore_button'].onclick = (function (_ignore_key) { return function(w) {
                w.state = (w.state == 'active' ? 'normal' : 'active');
                player.preferences[_ignore_key] = (w.state == 'active' ? 1 : 0);
                send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
            }; })(ignore_key);
        } else {
            throw Error('no ignore_button in '+dialog_options['dialog']);
        }
    }

    if(tip['unit_icon']) {
        var spec = gamedata['units'][tip['unit_icon']] || gamedata['buildings'][tip['unit_icon']] || null;
        if(spec) {
            dialog.widgets['unit_icon'].show = true;
            dialog.widgets['unit_icon'].asset = get_leveled_quantity(spec['art_asset'], 1);
        }
    }
    return dialog;
}

/** @param {string} tipname
    @param {string} name - specname of unit to talk about
    @param {number} threshold - from gamedata, HP ratio below which the debuff applies */
function invoke_weak_unit_tip(tipname, name, threshold) {
    if(session.weak_unit_warned[tipname]) { return; }
    session.weak_unit_warned[tipname] = 1;
    var dialog = invoke_ingame_tip(tipname, {frequency: GameTipFrequency.ALWAYS_UNLESS_IGNORED,
                                             dialog:'message_dialog_weak_unit',
                                             dialog_options: {parentless:true}
                                            });
    if(!dialog) { return; } // suppressed
    SPUI.root.add(dialog);
    dialog.auto_center();
    var unit_ui_name = gamedata['units'][name]['ui_name'];
    dialog.widgets['title'].set_text_with_linebreaking(gamedata['strings'][tipname]['ui_title'].replace('%s', unit_ui_name));
    dialog.widgets['description'].set_text_with_linebreaking(gamedata['strings'][tipname]['ui_description'].replace('%s', unit_ui_name).replace('%one_minus_threshold', (100.0*(1.0-threshold)).toFixed(0)));
    dialog.widgets['ok_button'].onclick = close_parent_dialog;
    dialog.widgets['unit_icon'].show = dialog.widgets['unit_wrench_icon'].show = true;
    dialog.widgets['unit_icon'].asset = get_leveled_quantity(gamedata['units'][name]['art_asset'], 1);
}

player.get_absolute_time = function() {
    var cur_time;
    var time_override = get_query_string('event_time_override');
    if(time_override) {
        cur_time = parseInt(time_override,10);
    } else {
        cur_time = server_time;
    }
    return cur_time;
};

// these are caches derived from immutable (after A/B test patching) gamedata
// for speeding up searches for events

/** @type {?Array.<Object>} */
player.event_list_cache = null;

/** Speed up lookups of events by name
    @type {?Object.<string, Array.<Object>>} */
player.event_list_cache_index = null;

/** Return the event_schedule entry for an event in progress
    @param {string} event_kind
    @param {string|null} event_name
    @param {number} ref_time
    @param {boolean} ignore_activation */
player.get_event_schedule = function(event_kind, event_name, ref_time, ignore_activation) {
    if(!goog.array.contains(['current_event','current_event_store','current_event_no_store','facebook_sale','bargain_sale',
                             'current_stat_tournament','backend_time_event',
                             'current_trophy_pve_challenge','current_trophy_pvp_challenge'], event_kind)) {
        throw Error('unhandled event_kind '+event_kind);
    }
    if(player.isolate_pvp && (event_kind.indexOf('trophy') != -1)) { return null; }

    if(player.event_list_cache === null) {
        player.event_list_cache = gamedata['event_schedule'].concat(player.get_any_abtest_value('event_schedule', []));
        player.event_list_cache_index = {};
        goog.array.forEach(player.event_list_cache, function(entry) {
            var name = entry['name'];
            if(!(name in player.event_list_cache_index)) {
                player.event_list_cache_index[name] = [];
            }
            player.event_list_cache_index[name].push(entry);
        });
    }

    var event_list;
    if(event_name) { // restrict lookups to events with matching name
        event_list = player.event_list_cache_index[event_name] || [];
    } else {
        event_list = player.event_list_cache;
    }
    if(!event_list) { throw Error('bad event_list'); }

    for(var i = 0; i < event_list.length; i++) {
        var entry = event_list[i];
        var data = gamedata['events'][entry['name']] || null;
        if(!data) { continue; }
        if(!('kind' in data) || (data['kind'] != event_kind)) { continue; }

        // first run of event starts at start_time and ends at end_time
        // if repeat_interval is specified, event re-runs at start_time + repeat_interval
        if(entry['start_time'] > ref_time) { continue; }
        if('repeat_interval' in entry) {
            var delta = (ref_time - entry['start_time']) % entry['repeat_interval'];
            if(delta >= (entry['end_time'] - entry['start_time'])) { continue; }
        } else {
            if(entry['end_time'] <= ref_time) { continue; }
        }

        if(event_name && (entry['name'] != event_name)) { continue; }
        if(!ignore_activation) {
            if(('activation' in entry) && !read_predicate(entry['activation']).is_satisfied(player, null)) { continue; }
            if(('activation' in data) && !read_predicate(data['activation']).is_satisfied(player, null)) { continue; }
        }
        return entry;
    }

    return null;
};

/** Returns the event_schedule entry for an event in progress
    @param {string} event_kind
    @param {string|null=} event_name
    @param {number|null=} ref_time
    @param {boolean=} ignore_activation */
player.get_event_data = function(event_kind, event_name, ref_time, ignore_activation) {
    if(typeof ref_time === 'undefined' || ref_time === null) { ref_time = player.get_absolute_time(); }
    if(!event_name) { event_name = null; }
    var sched = player.get_event_schedule(event_kind, event_name, ref_time, !!ignore_activation);
    if(sched) {
        return gamedata['events'][sched['name']];
    }
    return null;
};

/** @param {string} event_kind
    @param {string|null} event_name
    @param {string} method
    @param {boolean=} ignore_activation
    @param {number=} t_offset */
player.get_event_time = function(event_kind, event_name, method, ignore_activation, t_offset) {
    if(typeof t_offset == 'undefined') { t_offset = 0; }
    var ref_time = player.get_absolute_time() + t_offset;
    var entry = player.get_event_schedule(event_kind, event_name, ref_time, !!ignore_activation);
    if(!entry) { return null; }

    if(method === 'start') { // time since start of current run
        if('repeat_interval' in entry) {
            return (ref_time - entry['start_time']) % entry['repeat_interval'];
        } else {
            return ref_time - entry['start_time'];
        }
    } else if(method === 'end') { // negative time until end of current run
        if('repeat_interval' in entry) {
            var delta = (ref_time - entry['start_time']) % entry['repeat_interval'];
            return delta - (entry['end_time'] - entry['start_time']);
        } else {
            return ref_time - entry['end_time'];
        }
    } else if(method === 'inprogress') { // true if event is in progress, false if not
        if('repeat_interval' in entry) {
            if(ref_time < entry['start_time']) { return false; }
            var delta = (ref_time - entry['start_time']) % entry['repeat_interval'];
            return (delta < (entry['end_time'] - entry['start_time']));
        } else {
            return (ref_time >= entry['start_time'] && ref_time < entry['end_time']);
        }
    } else if(method === 'enabled') {
        return true;
    } else {
        throw Error('unknown method '+method);
    }
};

// returns the events entry
player.current_stat_tournament_event = function() {
    return player.get_event_data('current_stat_tournament');
};

// returns absolute end time of current cycle of this stat tournament
player.current_stat_tournament_end_time = function() {
    var cur_time_minus_end_time = player.get_event_time('current_stat_tournament', null, 'end');
    return player.get_absolute_time() - cur_time_minus_end_time;
};

// returns the events entry
player.current_alliance_stat_tournament_event = function() {
    // do not return the event if its "alliance" setting is false
    var event = player.current_stat_tournament_event();
    if(event &&
       (!('alliance' in event) || event['alliance'])) {
        return event;
    }
    return null;
};

player.current_alliance_stat_tournament_end_time = function() {
    if(player.current_alliance_stat_tournament_event()) {
        return player.current_stat_tournament_end_time();
    }
    return null;
};

function display_trophy_count(raw, trophy_type) {
    var offset;
    if(trophy_type in gamedata['trophy_display_offset']) {
        offset = gamedata['trophy_display_offset'][trophy_type];
    } else {
        console.log('unknown trophy_type '+trophy_type.toString());
        offset = 0;
    }
    return raw+offset;
}

player.get_current_trophy_challenge_name = function(kind) {
    var entry = player.get_event_data(kind);
    if(entry) { return entry['name']; }
    return null;
};
player.current_trophy_pve_challenge_name = function() { return player.get_current_trophy_challenge_name('current_trophy_pve_challenge'); };
player.current_trophy_pvp_challenge_name = function() { return player.get_current_trophy_challenge_name('current_trophy_pvp_challenge'); };
player.current_trophy_challenge_name = function() {
    var ret = player.current_trophy_pvp_challenge_name();
    if(ret) { return ret; }
    return player.current_trophy_pve_challenge_name();
};

player.get_current_trophy_challenge_togo = function(kind) {
    var event_name = player.get_current_trophy_challenge_name(kind);
    if(event_name && player.get_event_time(kind, event_name, 'inprogress')) {
        var togo = -player.get_event_time(kind, event_name, 'end');
        return togo;
    }
    return -1;
};

player.current_trophy_pve_challenge_togo = function() { return player.get_current_trophy_challenge_togo('current_trophy_pve_challenge'); };
player.current_trophy_pvp_challenge_togo = function() { return player.get_current_trophy_challenge_togo('current_trophy_pvp_challenge'); };
player.current_trophy_challenge_togo = function() {
    var ret = player.current_trophy_pvp_challenge_togo();
    if(ret >= 0) { return ret; }
    return player.current_trophy_pve_challenge_togo();
};

player.use_trophies = function() {
    return (player.get_any_abtest_value('enable_trophy_ui', gamedata['client']['enable_trophy_ui']) &&
            (player.current_trophy_challenge_togo() >= 0));
};

player.current_trophy_type = function() {
    if(player.current_trophy_pvp_challenge_togo() >= 0) {
        return 'pvp';
    } else if(player.current_trophy_pve_challenge_togo() >= 0) {
        return 'pve';
    }
    return null;
};

/** @return {number} */
var get_achievement_points = function(player_achievements) {
    var total = 0;
    goog.object.forEach(player_achievements, function(props, name) {
        var data = gamedata['achievements'][name];
        if(!data) { return; }
        var points = ('achievement_points' in data ? data['achievement_points'] : 0);
        if(points > 0) {
            total += points;
        }
    });
    return total;
};

function invoke_sprobe_dialog() {
    player.record_feature_use('sprobe_dialog');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['sprobe_dialog']);
    dialog.user_data['dialog'] = 'sprobe_dialog';
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.user_data['sprobes'] = []
    for(var i = 0; i < dialog.data['widgets']['result']['array'][0]; i++) {
        var on_finish = (function (_dialog, next_i) { return function() {
            if(_dialog.is_visible() && next_i < _dialog.user_data['sprobes'].length) {
                _dialog.user_data['sprobes'][next_i].go();
            }
        }; })(dialog, i+1);
        dialog.widgets['trial_label'+i.toString()].str = dialog.data['widgets']['trial_label']['ui_name'].replace('%d', (i+1).toString());
        dialog.user_data['sprobes'].push(sprobe_init(on_finish));
    }
    dialog.widgets['close_button'].onclick = dialog.widgets['dismiss_button'].onclick = close_parent_dialog;
    // note: obfuscate the string a bit
    dialog.widgets['your_gameapi_url'].str = dialog.data['widgets']['your_gameapi_url']['ui_name'].replace('%s', gameapi_url().replace('.com','').replace('http','').replace('GAMEAPI','').replace('//','').replace('/','')).replace('%method', gameapi_connection_method());
    if(longpoll_error_count >= 4) {
        dialog.widgets['longpoll_error'].show = 1;
    }
    dialog.widgets['warning_label'].append_text(SPText.cstring_to_ablocks_bbcode(dialog.data['widgets']['warning_label']['ui_name_bbcode']));

    var probe = dialog.user_data['sprobes'][0];
    goog.array.forEach(dialog.data['widgets']['description']['tests'], function(test, n) {
        dialog.widgets['description'+n.toString()].str = test['ui_name'];
    });
    probe.go();
    dialog.ondraw = update_sprobe_dialog;
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_sprobe_dialog(dialog) {
    dialog.widgets['your_framerate'].str = dialog.data['widgets']['your_framerate']['ui_name'].replace('%s', fps_counter.cur_fps.toFixed(1));

    for(var col = 0; col < dialog.data['widgets']['result']['array'][0]; col++) {
        var probe = dialog.user_data['sprobes'][col];
        for(var n = 0; n < dialog.data['widgets']['description']['tests'].length; n++) {
            var test = dialog.data['widgets']['description']['tests'][n];
            var w = dialog.widgets['result'+col.toString()+','+n.toString()];
            var kind = 'unsup', s = '';
            if(test['name'] in probe.tests) {
                var x = probe.tests[test['name']];
                if(x.state == SProbe.TestState.INIT) {
                    kind = 'init';
                } else if(x.state == SProbe.TestState.PENDING) {
                    kind = 'pending';
                } else if(x.state == SProbe.TestState.DONE) {
                    if(x.result['result'] == 'ok') {
                        kind = 'ok'; s = '';
                        if('ping' in x.result) {
                            if(x.result['ping'] >= dialog.data['widgets']['result']['ping_warn_threshold']) {
                                kind = 'warn';
                            }
                            s = (1000.0*x.result['ping']).toFixed(0) + 'ms';
                        }
                    } else {
                        if(x.result['error'] == 'timeout') {
                            kind = 'timeout';
                        } else {
                            kind = 'error'; s = x.result['error'];
                        }
                    }
                }
            }
            w.str = dialog.data['widgets']['result']['ui_name_'+kind].replace('%s', s);
            w.text_color = SPUI.make_colorv(dialog.data['widgets']['result']['text_color_'+kind]);
        }
    }
}

function invoke_settings_dialog() {
    player.record_feature_use('settings_dialog');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['settings_dialog']);
    dialog.user_data['dialog'] = 'settings_dialog';
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.user_data['scroll_by_row'] = true;
    dialog.user_data['preferences'] = {};
    for(var key in player.preferences) {
        dialog.user_data['preferences'][key] = player.preferences[key];
    }
    dialog.user_data['requires_reload'] = false;
    dialog.widgets['sprobe_button'].onclick = function() { invoke_sprobe_dialog(); };
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['apply_button'].onclick = function(w) {
        var dialog = w.parent;
        if(!dialog) { return; }
        dialog.widgets['apply_button'].state = 'disabled';
        dialog.widgets['apply_button'].str = dialog.data['widgets']['apply_button']['ui_name_applying'];
        send_to_server.func(["UPDATE_PREFERENCES", dialog.user_data['preferences']]);
        // special case to re-enable unacked notifications
        if(dialog.user_data['preferences']['enable_fb_notifications']) {
            send_to_server.func(["RESET_NOTIFICATION", 'ALL']);
        }
        if(dialog.user_data['requires_reload']) {
            flush_message_queue(true);
            window.setTimeout(function() { reload_game(); }, 1000);
        } else {
            var requires_recensor = false;
            if(global_chat_frame &&
               (get_preference_setting(dialog.user_data['preferences'], 'chat_filter') !=
                get_preference_setting(player.preferences, 'chat_filter'))) {
                requires_recensor = true
            }
            var requires_switch_camera_shake = false;
            if(get_preference_setting(dialog.user_data['preferences'], 'enable_camera_shake') !=
               get_preference_setting(player.preferences, 'enable_camera_shake')) {
                   requires_switch_camera_shake = true;
            }
            player.preferences = dialog.user_data['preferences'];
            change_selection(null);
            if(requires_recensor) {
                recensor_chat_frame(global_chat_frame);
            }
            if(requires_switch_camera_shake) {
                SPFX.enable_camera_shake = !('enable_camera_shake' in player.preferences && !player.preferences['enable_camera_shake']);
            }
        }
    };
    dialog.widgets['apply_button'].state = 'disabled';
    var settings = gamedata['strings']['settings'];
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['separator']['array'][1];
    dialog.user_data['rowdata'] = [];
    for(var name in settings) {
        var data = settings[name];
        if('show_if' in data && !read_predicate(data['show_if']).is_satisfied(player, null)) {
            continue;
        }
        if('name' in data) {
            dialog.user_data['rowdata'].push(data);
        }
    }
    dialog.user_data['rowfunc'] = settings_dialog_setup_row;
    dialog.ondraw = refresh_settings_dialog;
    dialog.on_mousewheel_function = scrollable_dialog_mousewheel;
    return dialog;
}

/** @param {Object} prefs     The dictionary of current preferences (usually player.preferences)
    @param {string} pref_name Name of an entry in gamedata['strings']['settings']
                              order of precedence:
                              manual setting >> A/B test >> default value from gamedata_main.json
*/
function get_preference_setting(prefs, pref_name) {
    var data = gamedata['strings']['settings'][pref_name];
    if(!data) { return null; } // not active
    if(data['preference_key'] in prefs) {
        return prefs[data['preference_key']];
    }
    if('abtest_key' in data) {
        var UNSET = -999;
        var val = player.get_any_abtest_value(data['abtest_key'], UNSET);
        if(val !== UNSET) { return val; }
    }

    // use default value
    return eval_cond_or_literal(data['default_val'], player, null);
}

/** @param {SPUI.Dialog} dialog */
function refresh_settings_dialog(dialog) {
    var rows_per_page = dialog.user_data['rows_per_page'];
    var total_rows = dialog.user_data['rowdata'].length;
    if(total_rows <= rows_per_page) {
        dialog.widgets['scroll_up'].show = false;
        dialog.widgets['scroll_down'].show = false;
    }
    scrollable_dialog_change_page(dialog, (dialog.user_data['page'] >= 0 ? dialog.user_data['page'] : 0));
    return dialog;
}

/** @param {SPUI.Dialog} dialog
    @param {number} row
    @param {Object} rowdata */
function settings_dialog_setup_row(dialog, row, rowdata) {
    dialog.widgets['separator'+row].show =
        dialog.widgets['description'+row].show =
        dialog.widgets['coverup'+row].show =
        dialog.widgets['choice0,'+row].show =
        dialog.widgets['choice1,'+row].show = (rowdata !== null);

    if(rowdata !== null) {
        dialog.widgets['description'+row].str = rowdata['ui_description'];
        var row_enabled = ('enable_if' in rowdata ? read_predicate(rowdata['enable_if']).is_satisfied(player, null) : true);
        dialog.widgets['coverup'+row].show = !row_enabled;
        var cur_value = get_preference_setting(dialog.user_data['preferences'], rowdata['name']);
        for(var c = 0; c < 2; c++) {
            var choice = rowdata['choices'][c];
            dialog.widgets['choice'+c+','+row].str = choice['ui_name'];
            dialog.widgets['choice'+c+','+row].tooltip.str = choice['ui_tooltip'];
            dialog.widgets['choice'+c+','+row].onclick = (function (_dialog, _rowdata, _choice, _row) { return function() {
                _dialog.user_data['preferences'][_rowdata['preference_key']] = _choice['preference_val'];
                dialog.widgets['apply_button'].state = 'normal';
                var requires_reload = _rowdata['requires_reload'];
                if(requires_reload) { dialog.user_data['requires_reload'] = 1; }
                scrollable_dialog_change_page(dialog, dialog.user_data['page']);
            }; })(dialog, rowdata, choice, row);
            var choice_selected = (cur_value == choice['preference_val']);
            dialog.widgets['choice'+c+','+row].state = (choice_selected ? 'active' : 'normal');
        }
        if('help_url' in rowdata) {
            dialog.widgets['help'+row].show = true;
            dialog.widgets['help'+row].onclick = (function (_rowdata) { return function(w) {
                url_open_in_new_tab(_rowdata['help_url']);
            }; })(rowdata);
        } else {
            dialog.widgets['help'+row].show = false;
        }
    }
}

function invoke_keyboard_shortcuts() {
    player.record_feature_use('keyboard_shortcuts_list');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['keyboard_shortcuts']);
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.user_data['page'] = 0;
    // array of bbcode text to display (one string per page)
    dialog.user_data['text'] = dialog.data['widgets']['shortcut_text'][player.unit_micro_enabled() ? 'bbcode_pages' : 'bbcode_pages_nomicro'];

    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    if(gamedata['strings']['keyboard_shortcuts_help_url']) {
        dialog.widgets['link_button'].onclick = (function (_url) { return function() {
            url_open_in_new_tab(_url);
        }; })(gamedata['strings']['keyboard_shortcuts_help_url']);
    } else {
        dialog.widgets['link_button'].show = false;
    }

    dialog.widgets['prev_button'].show = dialog.widgets['next_button'].show = (dialog.user_data['text'].length > 1);
    dialog.widgets['prev_button'].onclick = function (w) {
        var dialog = w.parent; if(!dialog) { return; }
        keyboard_shortcuts_change_page(dialog, dialog.user_data['page']-1);
    };
    dialog.widgets['next_button'].onclick = function (w) {
        var dialog = w.parent; if(!dialog) { return; }
        keyboard_shortcuts_change_page(dialog, dialog.user_data['page']+1);
    };

    keyboard_shortcuts_change_page(dialog, 0);
    dialog.ondraw = keyboard_shortcuts_update;
    return dialog;
}

/** @param {SPUI.Dialog} dialog
    @param {number} page */
function keyboard_shortcuts_change_page(dialog, page) {
    dialog.user_data['page'] = Math.min(Math.max(page, 0), dialog.user_data['text'].length-1);
    dialog.widgets['shortcut_text'].clear_text();
    dialog.widgets['shortcut_text'].append_text(SPText.cstring_to_ablocks_bbcode(dialog.user_data['text'][dialog.user_data['page']]));
}

/** @param {SPUI.Dialog} dialog */
function keyboard_shortcuts_update(dialog) {
    dialog.widgets['prev_button'].state = (dialog.user_data['page'] > 0 ? 'normal' : 'disabled');
    dialog.widgets['next_button'].state = (dialog.user_data['page'] < 1 ? 'normal' : 'disabled');
}

function invoke_region_map_help() {
    player.record_feature_use('region_map_help');

    // optionally override the standard help dialog
    if('region_map_help_consequent' in gamedata['territory']) {
        var cons = eval_cond_or_literal(gamedata['territory']['region_map_help_consequent'], player, null);
        if(cons) {
            read_consequent(cons).execute();
            return;
        }
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['region_map_help']);
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    var s = dialog.data['widgets']['description']['ui_name_bbcode'];
    for(var res in gamedata['resources']) {
        s = s.replace('%'+res.toUpperCase(), gamedata['resources'][res]['ui_name']);
    }
    dialog.widgets['description'].append_text(SPText.cstring_to_ablocks_bbcode(s));
    return dialog;
}

function invoke_army_dialog_help() {
    player.record_feature_use('army_dialog_help');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['army_dialog_help']);
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['description'].append_text(SPText.cstring_to_ablocks_bbcode(dialog.data['widgets']['description']['ui_name_bbcode']));
    return dialog;
}

function invoke_cc_upgrade_info() { return do_invoke_cc_upgrade_dialog('info'); }
function invoke_cc_upgrade_congrats() { return do_invoke_cc_upgrade_dialog('congrats'); }
function do_invoke_cc_upgrade_dialog(mode) {
    var cc = find_object_by_type(gamedata['townhall']);
    if(!cc) { return null; }
    var level;
    if(mode == 'congrats') {
        level = cc.level;
    } else {
        if(cc.level >= cc.get_max_level()) { return null; }
        level = cc.level + 1;
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['cc_upgrade_congrats_dialog']);
    dialog.user_data['dialog'] = 'cc_upgrade_congrats_dialog';

    if(mode == 'congrats') {
        change_selection_ui(dialog);

        // show a "click me" arrow on the close button for initial appearance
        if(level <= 2) {
            read_consequent({'consequent':'TUTORIAL_ARROW', 'child': 1,
                             'arrow_type':'button',
                             'direction':'up',
                             'dialog_name':'cc_upgrade_congrats_dialog',
                             'widget_name':'close_button'}).execute();
        }
    } else {
        install_child_dialog(dialog);
    }
    dialog.auto_center();
    dialog.modal = true;
    goog.array.forEach(['title','you_completed','details_header'], function(wname) {
        dialog.widgets[wname].str = dialog.data['widgets'][wname]['ui_name_'+mode];
    });
    dialog.widgets['icon'].asset = get_leveled_quantity(gamedata['buildings'][gamedata['townhall']]['art_asset'], level);
    dialog.widgets['level_text'].str = dialog.data['widgets']['level_text']['ui_name'].replace('%TOWNHALL',gamedata['buildings'][gamedata['townhall']]['ui_name']).replace('%d', level.toString());
    dialog.widgets['close_button'].onclick = dialog.widgets['ok_button'].onclick = close_parent_dialog;

    if(mode == 'congrats') {
        var viral_name = null, viral_props = null;
        if('ui_congrats_viral' in cc.spec) {
            viral_name = get_leveled_quantity(cc.spec['ui_congrats_viral'], cc.level);
            if(viral_name) {
                viral_props = {};
            }
        }
        var viral = get_facebook_viral(viral_name);
        if(viral) {
            dialog.widgets['ok_button'].show = false;
            dialog.widgets['viral_button'].show = true;
            dialog.default_button = dialog.widgets['viral_button'];
            dialog.widgets['viral_button'].str = viral['ui_button_text'];
            dialog.widgets['viral_button'].onclick = (function (_vname, _vprops) { return function() {
                invoke_facebook_viral(_vname, _vprops);
            }; })(viral_name, viral_props);
        }
    }

    dialog.widgets['details'].scroll_up_button = dialog.widgets['scroll_up'];
    dialog.widgets['details'].scroll_down_button = dialog.widgets['scroll_down'];
    dialog.widgets['scroll_up'].onclick = function(w) { w.parent.widgets['details'].scroll_up(); };
    dialog.widgets['scroll_down'].onclick = function(w) { w.parent.widgets['details'].scroll_down(); };

    var parsed = Congrats.cc_upgrade(cc, level);
    dialog.widgets['details'].max_lines = parsed.length+10;
    dialog.user_data['parsed'] = parsed;
    dialog.user_data['line'] = 0;

    if(mode == 'congrats') {
        dialog.widgets['glow'].show = true;
        play_level_up_sound(null);

        dialog.user_data['typewriter'] = (function (d) { return function() {
            if(!d.parent) { return; }
            var parsed = d.user_data['parsed'];
            if(d.user_data['line'] >= parsed.length) {
                return;
            } else {
                if(d.user_data['line'] % 2 == 0) {
                    GameArt.play_canned_sound('xp_gain_sound');
                }
                d.widgets['details'].append_text(parsed[d.user_data['line']]);
                d.user_data['line'] += 1;
                window.setTimeout(d.user_data['typewriter'], 350);
            }
        }; })(dialog);
        dialog.user_data['typewriter']();
    } else {
        goog.array.forEach(parsed, function(line) { dialog.widgets['details'].append_text(line); });
        dialog.widgets['details'].scroll_to_top();
    }
    return dialog;
}

function invoke_generic_upgrade_congrats(small_asset, alt_bg, sound_name, title, level, text, asset, cloaked, viral_name, viral_props) {
    change_selection(null);
    var dialog = new SPUI.Dialog(gamedata['dialogs']['unit_upgrade_congrats_dialog']);
    dialog.user_data['dialog'] = 'unit_upgrade_congrats_dialog';
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    if(alt_bg) {
        dialog.widgets['sunken'].asset = dialog.data['widgets']['sunken']['asset'] + '_alt';
    }

    dialog.widgets['small_icon'].show = !!small_asset;
    dialog.widgets['small_icon'].asset = small_asset;

    dialog.widgets['big_icon'].asset = asset;
    if(dialog.widgets['big_icon'].asset) {
        dialog.widgets['big_icon'].state = (GameArt.assets[asset].has_state('hero') ? 'hero' : 'normal');
    }

    dialog.widgets['big_icon'].alpha = dialog.widgets['small_icon'].alpha = cloaked ? gamedata['client']['cloaked_opacity'] : 1;
    dialog.widgets['level_text'].set_text_with_linebreaking(dialog.data['widgets']['level_text']['ui_name'].replace('%s', title).replace('%d', level.toString()));
    dialog.widgets['description'].set_text_with_linebreaking(text);
    dialog.widgets['close_button'].onclick = function() { change_selection(null); };

    dialog.widgets['flash'].show = true;
    dialog.widgets['glow'].show = true;

    var viral = get_facebook_viral(viral_name);
    if(viral) {
        dialog.widgets['ok_button'].str = viral['ui_button_text'];
        dialog.widgets['ok_button'].onclick = (function (_vname, _vprops) { return function() {
            change_selection(null);
            invoke_facebook_viral(_vname, _vprops);
        }; })(viral_name, viral_props);
    } else {
        dialog.widgets['ok_button'].onclick = dialog.widgets['close_button'].onclick;
    }

    return dialog;
}

function invoke_building_upgrade_congrats(spec_name, level) {
    if(spec_name == gamedata['townhall']) { return invoke_cc_upgrade_congrats(); }

    var spec = gamedata['buildings'][spec_name];
    if(!('ui_congrats' in spec)) { return null; }
    var text = get_leveled_quantity(spec['ui_congrats'], level);
    if(!text) { return; }

    var viral_name = null, viral_props = null;
    if('ui_congrats_viral' in spec) {
        viral_name = get_leveled_quantity(spec['ui_congrats_viral'], level);
        if(viral_name) {
            viral_props = {};
        }
    }

    // new: sound is handled by the VFX or dialog widgets for new flashy case
    var sound_name = null;

    var dialog = invoke_generic_upgrade_congrats(null, false, sound_name, spec['ui_name'], level, text, get_leveled_quantity(spec['art_asset'], level),
                                                 get_leveled_quantity(spec['cloaked'] || 0, level),
                                                 viral_name, viral_props);
    if(level == 1) {
        // replace "You Upgraded:" with "You Constructed:"
        dialog.widgets['you_completed'].str = dialog.data['widgets']['you_completed']['ui_name_constructed'];
    }
    return dialog;
}

function invoke_enhancement_congrats(obj_id, enh_name, level) {
    var spec = gamedata['enhancements'][enh_name];
    if(!('ui_congrats' in spec)) { return null; }
    var text = get_leveled_quantity(spec['ui_congrats'], level);
    if(!text) { return; }

    if(!session.get_real_world().objects.has_object(obj_id)) { return; }

    var host = session.get_real_world().objects.get_object(obj_id);

    var asset = null, cloaked = 0;
    if('splash_image' in spec) {
        asset = get_leveled_quantity(spec['splash_image'], level);
    } else {
        asset = get_leveled_quantity(host.spec['art_asset'], level);
        cloaked = get_leveled_quantity(host.spec['cloaked'] || 0, host.level)
    }
    var dialog = invoke_generic_upgrade_congrats(null, false, null, spec['ui_name'], level, text,
                                                 asset, cloaked, null, null);
    return dialog;
}

function invoke_tech_upgrade_congrats(spec_name) {
    var tech_spec = gamedata['tech'][spec_name];
    if(!('ui_congrats' in tech_spec)) { return; }

    var level = player.tech[spec_name];

    var text = get_leveled_quantity(tech_spec['ui_congrats'], level);
    if(!text) { return; }

    var unit_spec, ui_tech_name;

    if('associated_unit' in tech_spec) {
        // tech for unlocking a unit
        unit_spec = gamedata['units'][tech_spec['associated_unit']];
        ui_tech_name = unit_spec['ui_name'];
    } else if('affects_unit' in tech_spec) {
        // tech that buffs a unit
        unit_spec = gamedata['units'][tech_spec['affects_unit']];
        ui_tech_name = tech_spec['ui_name'];
    } else if('affects_manufacture_category' in tech_spec) {
        // tech that buffs a category of units
        for(var name in gamedata['units']) {
            if(gamedata['units'][name]['manufacture_category'] == tech_spec['affects_manufacture_category']) {
                // show "coolest" unit of this manufacture category that the player has
                if(!unit_spec || gamedata['units'][name]['level_determined_by_tech'] in player.tech) {
                    unit_spec = gamedata['units'][name];
                }
            }
        }
        ui_tech_name = tech_spec['ui_name'];
    } else {
        return;
    }

    // show different background for mod upgrades
    var alt_bg = ('affects_unit' in tech_spec);

    // new: sound is handled by the VFX or dialog widgets for new flashy case
    var sound_name = null;

    var dialog = invoke_generic_upgrade_congrats(get_leveled_quantity(unit_spec['art_asset'], level), alt_bg, sound_name,
                                                 ui_tech_name, level, text, get_leveled_quantity(tech_spec['splash_image'] || unit_spec['splash_image'] || unit_spec['art_asset'], level),
                                                 get_leveled_quantity(unit_spec['cloaked'] || 0, level),
                                                 null, null);

    if(level == 1) {
        // replace "You Upgraded:" with "You Unlocked:"
        dialog.widgets['you_completed'].str = dialog.data['widgets']['you_completed']['ui_name_unlocked'];
    }

    // show "Produce" button if player is beyond extended tutorial
    if(read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null)) {
        dialog.widgets['ok_button'].str = gamedata['spells']['MAKE_DROIDS']['ui_name'];
        dialog.widgets['ok_button'].onclick = (function (sp) { return function() {
            change_selection(find_object_by_type(get_factory_for(sp['manufacture_category'])));
            invoke_manufacture_dialog('tech_upgrade_congrats', sp['manufacture_category'], sp['name']);
        }; })(unit_spec);
    }

    if('ui_congrats_viral' in tech_spec && player.get_any_abtest_value('unit_tech_virals_replace_produce', gamedata['virals']['unit_tech_virals_replace_produce'])) {
        var viral_name = get_leveled_quantity(tech_spec['ui_congrats_viral'], level);
        if(viral_name) {
            var viral = get_facebook_viral(viral_name);
            if(viral) {
                var viral_props = {'%UNIT': tech_spec['ui_name']};
                dialog.widgets['ok_button'].str = viral['ui_button_text'];
                dialog.widgets['ok_button'].onclick = (function (_vname, _vprops) { return function() {
                    invoke_facebook_viral(_vname, _vprops);
                }; })(viral_name, viral_props);
                }
        }
    }

    return dialog;
}

function invoke_blueprint_congrats(item_spec_name, tech_spec_name) {
    var item_spec = ItemDisplay.get_inventory_item_spec(item_spec_name);
    var tech_spec = gamedata['tech'][tech_spec_name];
    var unit_spec = null;
    if('associated_unit' in tech_spec) {
        // tech for unlocking/upgrading a unit
        unit_spec = gamedata['units'][tech_spec['associated_unit']];
    } else if('associated_item' in tech_spec) {
        // tech for unlocking/upgrading an item (via crafting recipe)
    } else if('associated_tech' in tech_spec) {
        // possibly a mod tech
        var associated_tech_spec = gamedata['tech'][tech_spec['associated_tech']];
        if('associated_unit' in associated_tech_spec) {
            unit_spec = gamedata['units'][associated_tech_spec['associated_unit']];
        }
    } else {
        return;
    }

    change_selection(null);
    var dialog = new SPUI.Dialog(gamedata['dialogs']['blueprint_congrats']);
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var icon_alpha = 1;
    if(unit_spec) {
        var is_cloaked = ('cloaked' in unit_spec ? unit_spec['cloaked'] : 0);
        if(get_leveled_quantity(is_cloaked, 1)) {
            icon_alpha = gamedata['client']['cloaked_opacity'];
        }
    }

    if(unit_spec) {
        dialog.widgets['small_icon'].asset = get_leveled_quantity(unit_spec['art_asset'],1);
        dialog.widgets['small_icon'].alpha = icon_alpha;
        dialog.widgets['big_icon'].alpha = icon_alpha;
    }

    if('splash_image' in tech_spec) {
        dialog.widgets['splash_icon'].asset = get_leveled_quantity(tech_spec['splash_image'],1);
        dialog.widgets['splash_icon'].state = GameArt.assets[dialog.widgets['splash_icon'].asset].has_state('hero') ? 'hero' : 'normal';

        dialog.widgets['splash_icon_bg'].show = true;
    } else {
        dialog.widgets['big_icon'].asset = dialog.widgets['small_icon'].asset; // might be null
    }

    dialog.widgets['level_text'].set_text_with_linebreaking(dialog.data['widgets']['level_text']['ui_name'].replace('%s',ItemDisplay.get_inventory_item_ui_name(item_spec)));
    dialog.widgets['description'].set_text_with_linebreaking(dialog.data['widgets']['description']['ui_name'].replace('%lab', gamedata['buildings'][get_lab_for(tech_spec['research_category'])]['ui_name']));

    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    dialog.widgets['ok_button'].onclick = (function (_tech_spec_name) { return function() {
        change_selection_ui(null);
        invoke_upgrade_tech_dialog(_tech_spec_name, null);
    }; })(tech_spec_name);

    return dialog;
}

player.gift_orders_enabled = function() {
    var default_value = eval_cond_or_literal(gamedata['store']['enable_gift_orders'], player, null);
    return player.get_any_abtest_value('enable_gift_orders', default_value);
};

/** wrapper around metric_event for adding purchase UI properties
    @param {string} event_name
    @param {Object=} extra_props */
function purchase_ui_event(event_name, extra_props) {
    // filter down to important events
    if(!goog.array.contains(['4410_buy_gamebucks_dialog_open',
                             '4440_buy_gamebucks_init_payment'], event_name)) { return; }

    var props = {'purchase_ui_event': true, 'api':SPay.api, 'client_time': Math.floor(client_time)};

    // look for an active flash sale
    var aura = goog.array.find(player.player_auras, function(a) {
        return goog.array.contains(['null_sale', 'flash_sale', 'item_bundles'], a['spec']) &&
            a['end_time'] > server_time &&
            (!('start_time' in a) || a['start_time'] < server_time);
    });
    if(aura && ('data' in aura)) {
        goog.array.forEach(['kind','duration','tag'], function(field) {
            if(field in aura['data']) {
                props['flash_sale_'+field] = aura['data'][field];
            }
        });
    }

    if(extra_props) {
        goog.object.extend(props, extra_props);
    }
    metric_event(event_name, props);
}

/** @param {string} reason
    @param {number} amount
    @param {Object|null} order - to chain to auto-complete an attempted gamebucks order
    @param {Object|null=} options */
function invoke_buy_gamebucks_dialog(reason, amount, order, options) {
    if(!player.is_cheater) {
        var pred = gamedata['store']['buy_gamebucks_dialog_enable_if'] || null;
        if(pred) {
            var p = read_predicate(pred);
            if(!p.is_satisfied(player)) {
                var helper = get_requirements_help(p);
                if(helper) { helper(); }
                return;
            }
        }
    }

    var ver = eval_cond_or_literal(player.get_any_abtest_value('buy_gamebucks_dialog_version', gamedata['store']['buy_gamebucks_dialog_version'] || 1), player, null);

    // this option controls whether the game will automatically
    // re-attempt the gamebucks purchase that caused this dialog to
    // appear after the player buys the gamebucks. Default to off
    // because it often causes support tickets like "I bought 1000
    // Gold but only recevied 490!" (because 510 was spent on
    // auto-completing the original order).
    if(!eval_cond_or_literal(player.get_any_abtest_value('reattempt_order_after_buy_gamebucks', gamedata['store']['reattempt_order_after_buy_gamebucks']||false), player, null)) {
        order = null;
    }

    if(ver == 1) {
        return invoke_buy_gamebucks_dialog1(reason, amount, order, options);
    } else {
        return invoke_buy_gamebucks_dialog23(ver, reason, amount, order, options);
    }
}

/** @param {string} reason
    @param {number} amount
    @param {Object|null} order - to chain to auto-complete an attempted gamebucks order
    @param {Object|null=} options */
function invoke_buy_gamebucks_dialog1(reason, amount, order, options) {
    if(!options) { options = {}; }
    if(options['highlight_only']) { throw Error('highlight_only not supported'); }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['buy_gamebucks_dialog']);
    dialog.user_data['dialog'] = 'buy_gamebucks_dialog';
    dialog.user_data['order'] = (order || null);
    dialog.user_data['enable_gift_orders'] = player.gift_orders_enabled() && (player.resource_state['gamebucks'] >= 0);
    dialog.user_data['chapter'] = 'yourself';
    dialog.user_data['gift_order'] = null;
    dialog.user_data['gift_order_candidates'] = null;

    dialog.widgets['title'].str = dialog.widgets['title'].data['ui_name'].replace('%s', Store.gamebucks_ui_name());

    // short-term hack - transition messages for users who haven't seen either gamebucks or the new fbpayments API yet
    // note: gamebucks transition message takes precedence over fbpayments
    if('transition_msg' in dialog.widgets) {
        var transition_msg;
        if(player.get_any_abtest_value('buy_gamebucks_transition_msg_gamebucks', gamedata['store']['buy_gamebucks_transition_msg_gamebucks'])) {
            transition_msg = 'gamebucks';
        } else if(player.get_any_abtest_value('buy_gamebucks_transition_msg_fbpayments', gamedata['store']['buy_gamebucks_transition_msg_fbpayments'])) {
            transition_msg = 'fbpayments';
        }

        if(transition_msg) {
            dialog.widgets['info_button'].show = dialog.widgets['transition_msg_header'].show = dialog.widgets['transition_msg'].show = true;
            dialog.widgets['transition_msg'].set_text_with_linebreaking(dialog.data['widgets']['transition_msg']['ui_name_'+transition_msg]);
            dialog.widgets['info_button'].onclick = (function (_transition_msg) { return function(w) {
                url_open_in_new_tab(w.data['url_'+_transition_msg]);
            }; })(transition_msg);
        }
    }

    dialog.widgets['mf_logo'].show = true;

    var spell_list = [];

    // optional top-up SKU that buys only enough gamebucks for whatever the player was attempting to do
    var topup_bucks = -1;
    if(order && order['price'] > 0 && order['price'] > player.resource_state['gamebucks'] &&
       (player.get_any_abtest_value('gamebucks_per_fbcredit_topup', gamedata['store']['gamebucks_per_fbcredit_topup']) > 0)) {
        topup_bucks = order['price'] - player.resource_state['gamebucks'];

    }
    dialog.user_data['topup_bucks'] = topup_bucks;

    // construct slate of SKUs from fixed-price bundles
    for(var spellname in gamedata['spells']) {
        if(spellname.indexOf("BUY_GAMEBUCKS_") != -1 && spellname !== "BUY_GAMEBUCKS_TOPUP") {
            var spell = gamedata['spells'][spellname];
            if('requires' in spell && !read_predicate(spell['requires']).is_satisfied(player, null)) {
                continue;
            }
            if(topup_bucks > 0) {
                // don't show SKUs smaller than the topup
                if(spell['quantity'] < topup_bucks) { continue; }
            }
            spell_list.push(spellname);
        }
    }

    spell_list.sort(function (a,b) {
        var sa = gamedata['spells'][a], sb = gamedata['spells'][b];
        var va = sa['quantity'], vb = sb['quantity'];
        if(va > vb) { return 1; } else if(va < vb) { return -1; } else { return 0; }
    });

    if(topup_bucks > 0) {
        var old_list = spell_list;
        // if the slate has a full 6 SKUs, omit the first one to make room for the topup
        if(old_list.length == 6) {
            old_list = old_list.slice(1);
        }
        // prepend the topup SKU at the beginning
        spell_list = ["BUY_GAMEBUCKS_TOPUP"];
        spell_list = spell_list.concat(old_list);
    }

    if(spell_list.length < 1 || spell_list.length > 6) {
        log_exception(null, 'weird number of gamebucks SKUs ('+spell_list.length.toString()+')! region '+player.price_region+' country '+player.country+' SKUs: ['+spell_list.join(',')+'] in invoke_buy_gamebucks_dialog');
    }

    if(spell_list.length > dialog.data['widgets']['radio']['array'][1]) {
        console.log('too many spells for list UI!');
    }

    dialog.user_data['spell_list'] = spell_list;
    dialog.user_data['selection'] = 0;
    dialog.user_data['pending'] = false;

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var go_away = function(w) {
        purchase_ui_event('4420_buy_gamebucks_dialog_close');
        close_parent_dialog(w);
    };

    dialog.widgets['close_button'].onclick = go_away;

    var default_selection = (topup_bucks > 0 ? 0 : player.get_any_abtest_value('default_gamebucks_offer_index', gamedata['store']['default_gamebucks_offer_index']));

    buy_gamebucks_dialog_select(dialog, default_selection);

    player.record_client_history('purchase_ui_opens', 1);
    if((player.history['money_spent'] || 0) <= 0) {
        player.record_client_history('purchase_ui_opens_preftd', 1);
    }
    var default_spellname = spell_list[default_selection];
    purchase_ui_event('4410_buy_gamebucks_dialog_open', {'sku': default_spellname,
                                                         'gamebucks': gamedata['spells'][default_spellname]['quantity'],
                                                         'currency': gamedata['spells'][default_spellname]['currency'],
                                                         'currency_price': gamedata['spells'][default_spellname]['price'],
                                                         'method': reason});
    SPFB.AppEvents.logEvent('SP_PURCHASE_DIALOG_OPEN');

    dialog.widgets['gift_order_cancel_button'].onclick = function(w) { w.parent.user_data['gift_order'] = null; };
    dialog.widgets['gift_order_choose_button'].onclick = dialog.widgets['gift_order_friend_icon'].onclick = function(w) {
        invoke_choose_gift_order_dialog(w.parent, w.parent.user_data['gift_order_candidates']);
    };
    dialog.widgets['gifts_button'].onclick = function(w) { buy_gamebucks_dialog_change_chapter(w.parent, 'gifts'); }
    dialog.widgets['yourself_button'].onclick = function(w) {buy_gamebucks_dialog_change_chapter(w.parent, 'yourself'); };

    if(spin_frame_platform == 'fb' && player.get_any_abtest_value('enable_fb_gift_cards', eval_cond_or_literal(gamedata['store']['enable_fb_gift_cards'], player, null))) {
        dialog.widgets['redeem_gift_card_button'].show = true;
        dialog.widgets['redeem_gift_card_button'].tooltip.str = dialog.data['widgets']['redeem_gift_card_button']['ui_tooltip'].replace('%s', gamedata['store']['gamebucks_ui_name']);
        dialog.widgets['redeem_gift_card_button'].onclick = function(w) { Store.redeem_fb_gift_card( function() { change_selection(null); }, null); };
    }

    dialog.ondraw = update_buy_gamebucks_dialog;
    return dialog;
}

function buy_gamebucks_dialog_change_chapter(dialog, chapter) {
    dialog.user_data['chapter'] = chapter;
    buy_gamebucks_dialog_select(dialog, dialog.user_data['selection']); // recalculate SKUs
}

/** @param {SPUI.Dialog} dialog */
function update_buy_gamebucks_dialog(dialog) {
    dialog.widgets['loading_rect'].show =
        dialog.widgets['loading_text'].show =
        dialog.widgets['loading_spinner'].show = dialog.user_data['pending'];

    if(dialog.user_data['enable_gift_orders'] && dialog.user_data['gift_order_candidates'] === null) {
        dialog.user_data['gift_order_candidates'] = player.get_gift_order_candidates();
    }
    var anyone_to_gift = dialog.user_data['enable_gift_orders'] && dialog.user_data['gift_order_candidates'] && (dialog.user_data['gift_order_candidates'].length>=1);

    if(!anyone_to_gift) {
        dialog.user_data['chapter'] = 'yourself';
        dialog.widgets['gifts_button'].show =
        dialog.widgets['gift_order_title'].show =
        dialog.widgets['yourself_button'].show = false;
    } else {
        dialog.widgets['gifts_button'].show =
        dialog.widgets['gift_order_title'].show =
        dialog.widgets['yourself_button'].show = true;
        dialog.widgets['gifts_button'].state = (dialog.user_data['chapter'] == 'gifts' ? 'active' : 'normal');
        dialog.widgets['yourself_button'].state = (dialog.user_data['chapter'] == 'yourself' ? 'active' : 'normal');
    }

    goog.array.forEach(['select_your_package','buy_button'], function(name) {
        dialog.widgets[name].str = dialog.data['widgets'][name]['ui_name'+(dialog.user_data['chapter']=='gifts'?'_gifts':'')];
    });

    if(dialog.user_data['chapter'] == 'gifts') {
        //dialog.widgets['mf_logo'].show = false;
        dialog.widgets['buy_button'].state = (dialog.user_data['gift_order'] ? 'normal' : 'disabled');
        dialog.widgets['gift_order_choose_button'].show =
            dialog.widgets['gift_order_friend_icon'].show = true;

        if(dialog.user_data['gift_order']) {
            var entry = dialog.user_data['gift_order']['gifts'][0];
            dialog.widgets['gift_order_cancel_button'].show = false;
            dialog.widgets['gift_order_friend_icon'].set_user(entry['recipient_user_id']);
        } else {
            dialog.widgets['gift_order_cancel_button'].show = false;
            dialog.widgets['gift_order_friend_icon'].set_user(null);
        }
    } else {
        dialog.widgets['buy_button'].state = 'normal';
        //dialog.widgets['mf_logo'].show = true;
        dialog.widgets['gift_order_choose_button'].show =
            dialog.widgets['gift_order_cancel_button'].show =
            dialog.widgets['gift_order_friend_icon'].show = false;

    }
};

// return [qty (number), tooltip (array of strings, one per line)] describing bonus units given along with a gamebucks purchase
function get_gamebucks_sku_bonus_units(spell) {
    var cc_level = player.get_townhall_level();
    var tip = [];
    var total_qty = 0;
    for(var spec_name in spell['give_units']) {
        if(!(spec_name in gamedata['units'])) { continue; }
        var spec = gamedata['units'][spec_name];
        var qty = spell['give_units'][spec_name];
        var level = player.tech[spec['level_determined_by_tech']] || 1;
        if('level_by_cc' in spell['give_units']) {
            var table = gamedata['reward_unit_level_by_cc_level'];
            var index = clamp(cc_level-1, 0, table.length-1);
            level = Math.max(level, table[index]);
            if(player.get_any_abtest_value('reward_units_by_mail', gamedata['reward_units_by_mail'])) {
                // round generously
                if(level > 4) {
                    level = 8;
                } else if(level > 1) {
                    level = 4;
                } else {
                    level = 1;
                }
            }
        }
        var text = qty.toString()+'x '+spec['ui_name'];
        //text += ' (L'+level.toString()+')';
        tip.push(text);
        total_qty += qty;
    }
    return [total_qty, tip];
};

function buy_gamebucks_dialog_select(dialog, num) {
    var spell_list = dialog.user_data['spell_list'];
    var topup_bucks = dialog.user_data['topup_bucks'];
    num = Math.min(Math.max(num, 0), spell_list.length-1);
    dialog.user_data['selection'] = num;

    var display_currency = null;
    if(SPay.api == 'fbpayments' || SPay.api == 'microsoft') {
        // display_currency will be set on a per-spell basis
    } else if(SPay.api == 'kgcredits') {
        display_currency = 'Kongregate Kreds';
    } else if(player.get_any_abtest_value('use_local_currency', gamedata['store']['use_local_currency']) && player.facebook_currency) {
        display_currency = player.facebook_currency['user_currency'];
    } else {
        display_currency = 'Facebook Credits';
    }

    // XXX note: xsolla not supported here

    var i;
    for(i = 0; i < spell_list.length; i++) {
        var spellname = spell_list[i];
        var spell = gamedata['spells'][spellname];
        var alloy_qty = (spell['price_formula'] == 'gamebucks_topup' ? topup_bucks : spell['quantity']);

        var payment_currency = ('currency' in spell ? spell['currency'] : 'fbcredits');

        if(SPay.api == 'fbpayments' || SPay.api == 'xsolla' || SPay.api == 'microsoft') {
            if(payment_currency.indexOf(SPay.api+':') != 0) { throw Error('bad payment_currency '+payment_currency); }
            display_currency = payment_currency.split(':')[1];
        }

        var payment_price = Store.get_price(payment_currency, GameObject.VIRTUAL_ID, spell, (spell['price_formula'] == 'gamebucks_topup' ? topup_bucks : null), false);

        dialog.widgets['radio'+i].state = (i === num ? 'active' : 'normal');
        dialog.widgets['radio'+i].onclick =
            dialog.widgets['icon'+i].onclick =
            dialog.widgets['bucks'+i].onclick =
//          dialog.widgets['label'+i].onclick =
            dialog.widgets['credits'+i].onclick =
            dialog.widgets['comment'+i].onclick =
            dialog.widgets['bonus'+i].onclick =
            dialog.widgets['bonus_slot'+i].onclick =
            (function (_i, _alloy_qty, _payment_currency, _payment_price) { return function(w) {
                var dialog = w.parent;
                var _spellname = dialog.user_data['spell_list'][_i];
                purchase_ui_event('4430_buy_gamebucks_select_qty', {'sku': _spellname,
                                                                    'gamebucks': _alloy_qty,
                                                                    'currency': _payment_currency,
                                                                    'currency_price': _payment_price});

                buy_gamebucks_dialog_select(dialog, _i);
            }; })(i, alloy_qty, payment_currency, payment_price);
        dialog.widgets['bucks'+i].str = dialog.data['widgets']['bucks']['ui_name'].replace('%d', Store.display_user_currency_amount(alloy_qty, 'full'));

        dialog.widgets['credits'+i].str = Store.display_real_currency_amount(display_currency, payment_price, payment_currency, false);
        // manually add " Credits" suffix to Facebook Credits amounts in the list
        if(display_currency == 'Facebook Credits' && payment_currency == 'fbcredits') {
            dialog.widgets['credits'+i].str += ' Credits';
        } else if(display_currency == 'Kongregate Kreds' && payment_currency == 'kgcredits') {
            dialog.widgets['credits'+i].str += ' Kreds';
        }

        dialog.widgets['icon'+i].bg_image = player.get_any_abtest_value('gamebucks_resource_icon', gamedata['store']['gamebucks_resource_icon']);

        dialog.widgets['comment'+i].str = ('ui_comment' in spell ? spell['ui_comment'] : '');
        dialog.widgets['bonus'+i].str = ('ui_bonus' in spell ? eval_cond_or_literal(spell['ui_bonus'], player, null) : '');

        var give_units = ('give_units' in spell && (dialog.user_data['chapter'] != 'gifts')); // no bonus units in gifts

        dialog.widgets['bonus'+i].font = SPUI.make_font(dialog.data['widgets']['bonus']['text_size'],
                                                        dialog.data['widgets']['bonus']['text_size']+4,
                                                        (i === num && give_units ? 'bold' : 'normal'));
        dialog.widgets['bonus'+i].text_hjustify = (give_units ? 'center' : 'left');
        dialog.widgets['bonus'+i].show = dialog.widgets['bonus_slot'+i].show = !!give_units;

        if(give_units) {
            var temp = get_gamebucks_sku_bonus_units(spell);
            var total_qty = temp[0], tip = temp[1];
            dialog.widgets['bonus_slot'+i].tooltip.str = tip.join('\n');
            dialog.widgets['bonus'+i].xy[0] = dialog.data['widgets']['bonus']['xy'][0] + dialog.data['widgets']['bonus']['slot_shove'];
            var state = 'normal';
            if(total_qty >= 11) {
                state = 'gunship';
            } else if(total_qty >= 7) {
                state = 'transport';
            } else {
                state = 'rover';
            }
            dialog.widgets['bonus_slot'+i].state = state;
        } else {
            dialog.widgets['bonus_slot'+i].tooltip.str = '';
        }

        dialog.widgets['radio'+i].show =
            dialog.widgets['icon'+i].show =
            dialog.widgets['bucks'+i].show =
//          dialog.widgets['label'+i].show =
            dialog.widgets['comment'+i].show =
            dialog.widgets['credits'+i].show = true;
    }

    while(i < dialog.data['widgets']['radio']['array'][1]) {
        dialog.widgets['radio'+i].show =
            dialog.widgets['icon'+i].show =
            dialog.widgets['bucks'+i].show =
//          dialog.widgets['label'+i].show =
            dialog.widgets['comment'+i].show =
            dialog.widgets['bonus_slot'+i].show =
            dialog.widgets['bonus'+i].show =
            dialog.widgets['credits'+i].show = false;
        i++;
    }

    // selected spell
    var spellname = spell_list[num];
    var spell = gamedata['spells'][spellname];
    var payment_currency = ('currency' in spell ? spell['currency'] : 'fbcredits');
    if(SPay.api == 'fbpayments' || SPay.api == 'microsoft') { display_currency = payment_currency.split(':')[1]; }
    var alloy_qty = (spell['price_formula'] == 'gamebucks_topup' ? topup_bucks : spell['quantity']);
    var spellarg = (spell['price_formula'] == 'gamebucks_topup' ? topup_bucks : null);
    var payment_price = Store.get_price(payment_currency, GameObject.VIRTUAL_ID, spell, spellarg, false);

    // PRICE
    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].str = Store.display_real_currency_amount(display_currency, payment_price, payment_currency, true);
    if(payment_currency == 'kgcredits') {
        dialog.widgets['price_display'].state = 'kgcredits';
    } else {
        dialog.widgets['price_display'].state = ((display_currency == 'Facebook Credits' && payment_currency == 'fbcredits') || player.get_any_abtest_value('always_show_fbcredits_logo', gamedata['store']['always_show_fbcredits_logo']) ? 'fbcredits' : 'neutral');
    }
    dialog.widgets['price_display'].text_offset = (dialog.widgets['price_display'].state == 'fbcredits' ? [5,1] : [0,1] );
    dialog.widgets['price_display'].tooltip.str =
        (player.get_any_abtest_value('price_display_tooltip', gamedata['store']['price_display_tooltip']) ?
         dialog.data['widgets']['price_display']['ui_tooltip_buy'].replace('%bucks', dialog.widgets['bucks'+num].str).replace('%credits',dialog.widgets['credits'+num].str) : '');

    dialog.widgets['price_display'].onclick =
        dialog.widgets['buy_button'].onclick = (function (spname, _spellarg, _order, _alloy_qty, _payment_price, _payment_currency) { return function(widget) {
            var dialog = widget.parent;
            if(dialog.user_data['pending']) { return; }

            if(_order && (player.resource_state['gamebucks'] + _alloy_qty) < _order['price']) {
                // don't attempt continuation order if alloy amount would be insufficient
                _order = null;
            }

            purchase_ui_event('4440_buy_gamebucks_init_payment', {'sku': spname,
                                                                  'gamebucks': _alloy_qty,
                                                                  'currency': _payment_currency,
                                                                  'currency_price': _payment_price});
            var credits_props = {'no_clear': true};
            var gift_order = dialog.user_data['chapter'] == 'gifts' && dialog.user_data['gift_order'];
            if(gift_order) {
                // fill in amount here
                gift_order['gifts'][0]['gamebucks'] = _alloy_qty;
                credits_props['gift_order'] = gift_order;
            }

            var credits_cb = (function (_widget, __order) { return function() {
                var dialog = _widget.parent;
                if(dialog) {
                    dialog.user_data['pending'] = false;
                    close_parent_dialog(_widget); // get rid of Get More Alloy dialog
                }

                if(__order && player.resource_state['gamebucks'] >= __order['price']) {
                    // re-attempt the original order
                    if(Store.place_gamebucks_order(__order['price'], __order['unit_id'], __order['spellname'], __order['spellarg'], __order['cb'] || null)) {
                        invoke_ui_locker();
                    }
                }
            }; })(widget, _order);


            var placer = (function (_dialog, __payment_currency, _spname, _spellarg, _credits_cb, _credits_props) { return function() {
                if(SPay.api != 'fbcredits' && player.get_any_abtest_value('lock_buy_gamebucks_dialog_during_payment', gamedata['store']['lock_buy_gamebucks_dialog_during_payment'])) {
                    // lock dialog
                    _dialog.user_data['pending'] = true;
                    _credits_props['fail_cb'] = (function (__dialog) { return function() {
                        // unlock dialog on fail as well as success
                        __dialog.user_data['pending'] = false;
                    }; })(_dialog);
                }
                Store.place_order(__payment_currency, GameObject.VIRTUAL_ID, _spname, _spellarg, _credits_cb, _credits_props);
            }; })(dialog, _payment_currency, spname, spellarg, credits_cb, credits_props);

            if(gift_order) {
                invoke_confirm_gift_order_dialog(gift_order, placer);
            } else {
                placer();
            }
        }; })(spellname, spellarg, dialog.user_data['order'], alloy_qty, payment_price, payment_currency);
};

function invoke_you_got_bonus_units() {
    var dialog_data = gamedata['dialogs']['you_got_bonus_units'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'you_got_bonus_units';
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['ok_button'].onclick =
        dialog.widgets['close_button'].onclick = close_parent_dialog;
    GameArt.play_canned_sound('success_playful_22');;
    return dialog;
}

/** @param {!SPUI.Dialog} dialog - this dialog
    @param {!SPUI.Dialog} parent of this dialog
    @param {string} spellname
    @param {Object|null} spellarg
    @param {number} ui_index
    @param {Array<!Object>|null} expect_loot */
function init_buy_gamebucks_sku23(dialog, parent, spellname, spellarg, ui_index, expect_loot) {
    var spell = gamedata['spells'][spellname];
    dialog.user_data['spellname'] = spellname;
    dialog.user_data['spellarg'] = spellarg;
    dialog.user_data['spell'] = spell;
    dialog.user_data['ui_index'] = ui_index;
    dialog.user_data['expect_loot'] = expect_loot; // was originally loot-bearing at set-up time
    dialog.user_data['context_parent'] = parent; // dialog that will be the parent of any spawned inventory context menus
    dialog.user_data['pending'] = false;
    dialog.user_data['base_xy'] = vec_copy(dialog.xy);

    dialog.widgets['name'].set_text_with_linebreaking(spell['ui_new_store_name'] || spell['ui_name']);
    //dialog.widgets['icon'].asset = spell['new_store_icon'] || spell['icon'];
    dialog.widgets['jewel'].user_data['count'] = 0;
    dialog.widgets['jewel'].ondraw = update_notification_jewel;
    dialog.ondraw = update_buy_gamebucks_sku23;
}

function invoke_gamebucks_sku_highlight_dialog(spellname, spellarg, expect_loot) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['gamebucks_sku_highlight_dialog']);
    dialog.user_data['dialog'] = 'gamebucks_sku_highlight_dialog';
    install_child_dialog(dialog);
    dialog.modal = true;
    dialog.auto_center();
    dialog.user_data['ver'] = 2; // hard-coded for now
    dialog.user_data['look'] = eval_cond_or_literal(player.get_any_abtest_value('buy_gamebucks_dialog_look', gamedata['store']['buy_gamebucks_dialog_look'] || null), player, null);
    dialog.user_data['pending'] = false;
    dialog.user_data['any_sku_has_bonus'] = 1; // force "bonus text" mode
    dialog.user_data['expire_time'] = -1; // XXX does this need a per-sku override?
    init_buy_gamebucks_sku23(dialog.widgets['sku'], dialog, spellname, spellarg, 0, expect_loot);

    dialog.widgets['close_button'].onclick = close_parent_dialog;

    dialog.ondraw = update_gamebucks_sku_highlight_dialog;
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_gamebucks_sku_highlight_dialog(dialog) {
    dialog.widgets['close_button'].state = (dialog.user_data['pending'] ? 'disabled' : 'normal');
    if(!dialog.widgets['sku'].show) {
        // the SKU went away, maybe it was a one-time deal that was purchased.
        // we're done!
        // (this will be one frame late since the child update runs after this, but whatever...)

        // reparent "item discovered"
        var d = dialog.children[dialog.children.length-1];
        if(d.user_data && d.user_data['dialog'] /* XXX awkward - check if this is a dialog */) {
            dialog.unparent(d);
        } else {
            d = null;
        }
        close_dialog(dialog);
        if(d) {
            install_child_dialog(d);
            d.auto_center();
        }
        return;
    }

    update_buy_gamebucks_dialog23_warning_text(dialog);
}

/** @param {string} reason
    @param {number} amount
    @param {Object|null} order - to chain to auto-complete an attempted gamebucks order
    @param {Object|null=} options */
function invoke_buy_gamebucks_dialog23(ver, reason, amount, order, options) {
    if(!options) { options = {}; }

    var highlight_only = !!options['highlight_only'];
    if(highlight_only) {
        if(ver != 2) {
            throw Error('highlight_only not supported');
        }
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['buy_gamebucks_dialog'+ver.toString()]);
    dialog.user_data['ver'] = ver;
    dialog.user_data['look'] = eval_cond_or_literal(player.get_any_abtest_value('buy_gamebucks_dialog_look', gamedata['store']['buy_gamebucks_dialog_look'] || null), player, null);
    dialog.user_data['dialog'] = 'buy_gamebucks_dialog'+ver.toString();
    dialog.user_data['order'] = (order || null);
    dialog.user_data['pending'] = false;
    dialog.user_data['enable_gift_orders'] = player.gift_orders_enabled() && (player.resource_state['gamebucks'] >= 0);
    dialog.user_data['chapter'] = 'yourself';
    dialog.user_data['gift_order'] = null;
    dialog.user_data['gift_order_candidates'] = null;

    dialog.widgets['title_bold'].str = dialog.data['widgets']['title_bold']['ui_name'].replace('%s', Store.gamebucks_ui_name());

    // optional top-up SKU that buys only enough gamebucks for whatever the player was attempting to do
    var topup_bucks = -1;
    if(order && order['price'] > 0 && order['price'] > player.resource_state['gamebucks'] &&
       (player.get_any_abtest_value('gamebucks_per_fbcredit_topup', gamedata['store']['gamebucks_per_fbcredit_topup']) > 0)) {
        topup_bucks = order['price'] - player.resource_state['gamebucks'];
    }
    dialog.user_data['topup_bucks'] = topup_bucks;
    dialog.user_data['any_sku_has_bonus'] = 0;
    dialog.user_data['max_displayed_quantity'] = 0;
    dialog.user_data['context'] = null; // inventory_context

    // construct slate of SKUs from fixed-price bundles
    var spell_list = [];
    for(var spellname in gamedata['spells']) {
        if(spellname.indexOf("BUY_GAMEBUCKS_") != -1 && spellname !== "BUY_GAMEBUCKS_TOPUP") {
            var spell = gamedata['spells'][spellname];

            if(!spell['currency'] || spell['currency'].split(':')[0] !== SPay.api) { continue; } // skip spells with different API

            if('requires' in spell && !read_predicate(spell['requires']).is_satisfied(player, null)) {
                continue;
            }
            if(topup_bucks > 0) {
                // don't show SKUs smaller than the topup
                if(spell['quantity'] < topup_bucks) { continue; }
            }

            dialog.user_data['max_displayed_quantity'] = Math.max(dialog.user_data['max_displayed_quantity'], spell['quantity']);
            var bonus_lines = 0;
            if(spell['ui_bonus']) {
                var b = eval_cond_or_literal(spell['ui_bonus'], player, null);
                bonus_lines += b.split('\n').length;
                // special-case hack for backwards compatibility with old SKUs ("Unit Bonus" -> "BONUS:\nUnits")
                if(b.indexOf('Unit Bonus') !== -1) { bonus_lines += 1; }
            }
            if((('nominal_quantity' in spell) && spell['nominal_quantity'] < spell['quantity'])) {
                bonus_lines += gamedata['dialogs'][dialog.data['widgets']['sku']['dialog']]['widgets']['name2']['ui_name_bonus_quantity'].split('\n').length;
            }

            dialog.user_data['any_sku_has_bonus'] = Math.max(dialog.user_data['any_sku_has_bonus'], bonus_lines);

            // get expected loot
            var item_list = null;
            if('loot_table' in spell) {
                item_list = session.get_loot_items(player, gamedata['loot_tables_client'][spell['loot_table']]['loot']).item_list;
                if(item_list.length <= 0) { item_list = null; }
            }

            spell_list.push({'spellname': spellname, 'spellarg': null, 'expect_loot': item_list});

            // always add a NON-bundled version of any loot-table-bearing SKU
            if(item_list && item_list.length > 0) {
                spell_list.push({'spellname': spellname, 'spellarg': {'want_loot':false}, 'expect_loot': null});
            }
        }
    }

    spell_list.sort(function (a,b) {
        var sa = gamedata['spells'][a['spellname']], sb = gamedata['spells'][b['spellname']];

        // put loot-bearing SKUs first
        var la = !!a['expect_loot'], lb = !!b['expect_loot'];
        if(la && !lb) { return -1; } else if(!la && lb) { return 1; }

        // put bannered SKUs first
        var ba = eval_cond_or_literal(sa['ui_banner'] || null, player, null),
            bb = eval_cond_or_literal(sb['ui_banner'] || null, player, null);
        if(ba && !bb) { return -1; } else if(!ba && bb) { return 1; }

        var va = sa['quantity'], vb = sb['quantity'];
        if(va > vb) { return 1; } else if(va < vb) { return -1; } else { return 0; }
    });

    if(topup_bucks > 0) {
        spell_list = [{'spellname': 'BUY_GAMEBUCKS_TOPUP', 'spellarg': topup_bucks}].concat(spell_list);
    }

    if(spell_list.length < 1) {
        log_exception(null, 'no gamebucks SKUs ('+spell_list.length.toString()+')! region '+player.price_region+' country '+player.country + ' in invoke_buy_gamebucks_dialog2');
    }

    dialog.user_data['spell_list'] = spell_list;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    // SKU setup
    var i = 0;
    for(; i < spell_list.length; i++) {
        var d = new SPUI.Dialog(gamedata['dialogs'][dialog.data['widgets']['sku']['dialog']]);
        init_buy_gamebucks_sku23(d, dialog, spell_list[i]['spellname'], spell_list[i]['spellarg'] || null, i, spell_list[i]['expect_loot'] || null);
        dialog.add(d); dialog.widgets['sku'+i.toString()] = d;
        d.clip_to = [dialog.widgets['sunken'].xy[0], dialog.widgets['sunken'].xy[1],
                     dialog.widgets['sunken'].wh[0], dialog.widgets['sunken'].wh[1]];
    }

    // scrolling setup
    dialog.user_data['scroll_pos'] = 0;
    dialog.user_data['scroll_goal'] = 0;
    dialog.user_data['scroll_limits'] = [0, spell_list.length * dialog.data['widgets']['sku']['array_offset'][0] - dialog.widgets['sunken'].wh[0] + dialog.data['widgets']['sku']['xy'][0] - 20];
    dialog.user_data['open_time'] = client_time;
    dialog.user_data['scrolled'] = false;

    var scroller = function(incr) { return function(w) {
        var dialog = w.parent;
        dialog.user_data['scroll_goal'] = clamp(dialog.user_data['scroll_goal']+dialog.data['widgets']['sku']['array_offset'][0]*dialog.data['scroll_incr']*incr,
                                                dialog.user_data['scroll_limits'][0], dialog.user_data['scroll_limits'][1]);
        dialog.widgets['scroll_left'].state = (dialog.user_data['scroll_goal'] <= dialog.user_data['scroll_limits'][0] ? 'disabled' : 'normal');
        dialog.widgets['scroll_right'].state = (dialog.user_data['scroll_goal'] >= dialog.user_data['scroll_limits'][1] ? 'disabled' : 'normal');
        if(incr !== 0 && !dialog.user_data['scrolled']) {
            dialog.user_data['scrolled'] = true;
            purchase_ui_event('4431_buy_gamebucks_dialog_scroll', {'gui_version': dialog.user_data['ver'],
                                                                   'gui_look': dialog.user_data['look']});
        }
    }; };

    dialog.widgets['scroll_left'].onclick = scroller(-1);
    dialog.widgets['scroll_right'].onclick = scroller(1);
    dialog.widgets['scroll_left_jewel'].ondraw =
        dialog.widgets['scroll_right_jewel'].ondraw = update_notification_jewel;
    dialog.widgets['scroll_left_jewel'].user_data['count'] =
        dialog.widgets['scroll_right_jewel'].user_data['count'] = 0;

    dialog.widgets['scroll_left'].show = dialog.widgets['scroll_right'].show =
        dialog.data['widgets']['scroll_left']['show'] &&
        (spell_list.length * dialog.data['widgets']['sku']['array_offset'][0] >= dialog.widgets['sunken'].wh[0]);

    dialog.widgets['scroll_left_jewel'].show = dialog.widgets['scroll_right_jewel'].show =
        dialog.widgets['scroll_left'].show && false;

    // set initial scroll state
    if(dialog.widgets['scroll_left'].show) {
        scroller(0)(dialog.widgets['scroll_left']);
        dialog.user_data['scroll_pos'] = dialog.user_data['scroll_goal'];
    }

    // redeem gift card setup
    if(spin_frame_platform == 'fb' && player.get_any_abtest_value('enable_fb_gift_cards', eval_cond_or_literal(gamedata['store']['enable_fb_gift_cards'], player, null))) {
        dialog.widgets['redeem_gift_card_warning'].show = dialog.widgets['redeem_gift_card_button'].show = dialog.widgets['redeem_gift_card_icon'].show = true;
        dialog.widgets['redeem_gift_card_warning'].str = dialog.data['widgets']['redeem_gift_card_warning']['ui_name'].replace('%s', gamedata['store']['gamebucks_ui_name']);
        dialog.widgets['redeem_gift_card_button'].tooltip.str = dialog.data['widgets']['redeem_gift_card_button']['ui_tooltip'].replace('%s', gamedata['store']['gamebucks_ui_name']);
        dialog.widgets['redeem_gift_card_button'].onclick = function(w) {
            var s = gamedata['strings']['fb_gift_card_confirm'];
            var descr = s['ui_description'];
            while(descr.indexOf('%GAMEBUCKS') >= 0) {
                descr = descr.replace('%GAMEBUCKS', Store.gamebucks_ui_name());
            }
            invoke_child_message_dialog(s['ui_title'], descr,
                                        {'cancel_button': true,
                                         'dialog': 'message_dialog_big',
                                         'ok_button_ui_name': s['ui_button'],
                                         'on_ok': function() {
                                             Store.redeem_fb_gift_card( function() { change_selection(null); }, null);
                                         }});
        };
    }

    if(Store.trialpay_available() && player.get_any_abtest_value('enable_trialpay', eval_cond_or_literal(gamedata['store']['enable_trialpay']||false, player, null))) {
        dialog.widgets['trialpay_button'].show = true;
        dialog.widgets['trialpay_button'].str = dialog.data['widgets']['trialpay_button']['ui_name'].replace('%s', gamedata['store']['gamebucks_ui_name']);
        dialog.widgets['trialpay_button'].onclick = function(w) { Store.trialpay_invoke(); };
    }

    // highlight priority
    // 3. leftmost loot-bearing offer with a ui_warning (since that usually means it's attractive)
    // 2. leftmost loot-bearing offer for >= 1000 Gamebucks
    // 1. leftmost loot-bearing offer
    var highlight_priority = function(s) {
        if(s['expect_loot']) {
            if(buy_gamebucks_sku2_ui_warning(gamedata['spells'][s['spellname']], s['spellarg'])) {
                return 3;
            } else if(gamedata['spells'][s['spellname']]['quantity'] >= 1000) {
                return 2;
            } else {
                return 1;
            }
        } else {
            return 0;
        }
    };
    var highlight_list = goog.array.clone(spell_list);
    highlight_list.sort(function(a, b) {
        var a_prio = highlight_priority(a), b_prio = highlight_priority(b);
        if(a_prio > b_prio) {
            return -1;
        } else if(a_prio < b_prio) {
            return 1;
        } else if(spell_list.indexOf(a) < spell_list.indexOf(b)) {
            return -1;
        } else {
            return 1;
        }
    });
    var to_highlight = (highlight_list.length > 0 && highlight_priority(highlight_list[0]) > 0) ? highlight_list[0] : null;

    if(to_highlight && (highlight_only || !session.buy_gamebucks_sku_highlight_shown)) {
        session.buy_gamebucks_sku_highlight_shown = true; // only show once
        if(highlight_only) {
            close_dialog(dialog);
        }
        var highlight_dialog = invoke_gamebucks_sku_highlight_dialog(to_highlight['spellname'], to_highlight['spellarg'], to_highlight['expect_loot']);
        if(highlight_only) {
            //highlight_dialog.widgets['close_button'].onclick = function(w) { change_selection_ui(null); }
            return;
        }
    } else if(highlight_only) {
        //throw Error('no SKU to highlight');
        var msg = 'no SKU to highlight!\nserver_time: '+server_time.toString()+'\nplayer_auras: '+JSON.stringify(player.player_auras)+'\nhighlight_list: '+JSON.stringify(highlight_list);
        metric_event('0970_client_exception', add_demographics({'method':msg, 'location':'invoke_buy_gamebucks_dialog23',
                                                                'since_connect': (session.connected() ? client_time - session.connect_time : session.connect_time),
                                                                'since_pageload': client_time - spin_pageload_begin,
                                                                'server_message_history': debug_server_message_history.join(','),
                                                                'gameclient_build_date':(typeof gameclient_build_date === 'undefined' ? 'unknown' : gameclient_build_date),
                                                                'gamedata_build_info':gamedata['gamedata_build_info']}));

        close_dialog(dialog);
        return;
    }

    var go_away = function(w) {
        purchase_ui_event('4420_buy_gamebucks_dialog_close', {'gui_version': w.parent.user_data['ver'],
                                                              'gui_look': w.parent.user_data['look']});
        close_parent_dialog(w);
    };

    dialog.widgets['close_button'].onclick = go_away;
    dialog.ondraw = update_buy_gamebucks_dialog23;

    player.record_feature_use('buy_gamebucks_dialog2');
    player.record_client_history('purchase_ui_opens', 1);
    if((player.history['money_spent'] || 0) <= 0) {
        player.record_client_history('purchase_ui_opens_preftd', 1);
    }
    purchase_ui_event('4410_buy_gamebucks_dialog_open', {'gui_version': dialog.user_data['ver'],
                                                         'gui_look': dialog.user_data['look'],
                                                         'method': reason});
    SPFB.AppEvents.logEvent('SP_PURCHASE_DIALOG_OPEN');
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_buy_gamebucks_dialog23(dialog) {
    dialog.widgets['close_button'].state = (dialog.user_data['pending'] ? 'disabled' : 'normal');

    var spell_list = dialog.user_data['spell_list'];

    if(dialog.user_data['scroll_pos'] != dialog.user_data['scroll_goal']) {
        var delta = dialog.user_data['scroll_goal'] - dialog.user_data['scroll_pos'];
        var sign = (delta > 0 ? 1 : -1);
        dialog.user_data['scroll_pos'] += sign * Math.floor(dialog.data['scroll_speed'] * Math.abs(delta) + 0.5);
    }

    var left_jewels = 0, right_jewels = 0; // count number of jeweled SKUs to the left and right of the window

    for(var i = 0; i < spell_list.length; i++) {
        var w = dialog.widgets['sku'+i.toString()];

        var offset, base;
        if(dialog.user_data['ver'] == 3) { // fixed-size version
            var n_up = dialog.user_data['spell_list'].length;
            if(!('array_offset_'+n_up.toString()+'up' in dialog.data['widgets']['sku'])) {
                throw Error('unhandled number of skus: '+n_up.toString()+' ('+JSON.stringify(spell_list)+')');
            }
            offset = dialog.data['widgets']['sku']['array_offset_'+n_up.toString()+'up'];
            base = dialog.data['widgets']['sku'][('xy_'+n_up.toString()+'up' in dialog.data['widgets']['sku'] ? 'xy_'+n_up.toString()+'up' : 'xy')];
        } else {
            offset = dialog.data['widgets']['sku']['array_offset'];
            base = dialog.data['widgets']['sku']['xy'];
        }

        w.user_data['base_xy']= [i*offset[0] - dialog.user_data['scroll_pos'] + base[0], base[1]];
    }

    dialog.widgets['scroll_left_jewel'].user_data['count'] = left_jewels;
    dialog.widgets['scroll_right_jewel'].user_data['count'] = right_jewels;

    update_buy_gamebucks_dialog23_warning_text(dialog);
}

/** @param {SPUI.Dialog} dialog */
function update_buy_gamebucks_dialog23_warning_text(dialog) {
    // set dialog "warning" text and expire_time
    // note: this uses the ui_buy_gamebucks_warning cond chain, which is separate from per-SKU expire_times

    // hidden per-dialog
    if(('show' in dialog.data['widgets']['warning_text']) && !dialog.data['widgets']['warning_text']['show']) { return; }

    var ui_warning = null, expire_time = -1;
    for(var i = 0; i < gamedata['store']['ui_buy_gamebucks_warning'].length; i++) {
        var pred = read_predicate(gamedata['store']['ui_buy_gamebucks_warning'][i][0]);
        var ui_text = gamedata['store']['ui_buy_gamebucks_warning'][i][1];
        if(pred.is_satisfied(player, null)) {
            ui_warning = ui_text;
            expire_time = pred.ui_expire_time(player);
            break;
        }
    }

    if(ui_warning) {
        if(ui_warning.indexOf('%togo') >= 0) {
            if(expire_time > 0) {
                ui_warning = ui_warning.replace('%togo', pretty_print_time(expire_time - server_time));
            } else {
                throw Error('ui_warning with %togo but no expire_time: '+ui_warning);
            }
        }
        dialog.widgets['warning_text'].show = true;
        dialog.widgets['warning_text'].set_text_bbcode(ui_warning);
    } else {
        dialog.widgets['warning_text'].show = false;
    }
}

/** Get the UI-visible expire time for an active BUY_GAMEBUCKS sku spell
    @param {!Object} spell
    @return {number} */
function gamebucks_spell_ui_expire_time(spell, spellarg) {
    var expire_time = -1;
    goog.array.forEach(['show_if', 'requires'], function(pred_name) {
        if(pred_name in spell) {
            var t = read_predicate(spell[pred_name]).ui_expire_time(player);
            if(t > 0) {
                expire_time = (expire_time > 0 ? Math.min(expire_time, t) : t);
            }
        }
    });

    // get expire time of loot attachments
    if('loot_table' in spell && (!spellarg || spellarg['want_loot'])) {
        var loot = session.get_loot_items(player, gamedata['loot_tables_client'][spell['loot_table']]['loot']);
        if(loot.predicate) {
            var t = read_predicate(loot.predicate).ui_expire_time(player);
            if(t > 0) {
                expire_time = (expire_time > 0 ? Math.min(expire_time, t) : t);
            }
        }
    }
    return expire_time;
}

/** @param {SPUI.Dialog} dialog */
function update_buy_gamebucks_sku23(dialog) {
    // info needed from the parent/context
    // note: callbacks also look at parent's user_data['pending']
    var pending = (dialog.parent && ('pending' in dialog.parent.user_data) ? dialog.parent.user_data['pending'] : false);
    var any_sku_has_bonus = (dialog.parent && ('any_sku_has_bonus' in dialog.parent.user_data) ? dialog.parent.user_data['any_sku_has_bonus'] : 0);
    var max_displayed_quantity = (dialog.parent && ('max_displayed_quantity' in dialog.parent.user_data) ? dialog.parent.user_data['max_displayed_quantity'] : 0);
    var topup_bucks = (dialog.parent && ('topup_bucks' in dialog.parent.user_data) ? dialog.parent.user_data['topup_bucks'] : -1);
    var order = (dialog.parent && ('order' in dialog.parent.user_data) ? dialog.parent.user_data['order'] : null);
    dialog.user_data['ver'] = (dialog.parent && ('ver' in dialog.parent.user_data) ? dialog.parent.user_data['ver'] : -1);
    dialog.user_data['look'] = (dialog.parent && ('look' in dialog.parent.user_data) ? dialog.parent.user_data['look'] :
                                eval_cond_or_literal(player.get_any_abtest_value('buy_gamebucks_dialog_look', gamedata['store']['buy_gamebucks_dialog_look'] || null), player, null));

    var spellname = dialog.user_data['spellname'];
    var spell = dialog.user_data['spell'];
    var spellarg = dialog.user_data['spellarg'];
    var expect_loot = dialog.user_data['expect_loot'];

    if('requires' in spell && !read_predicate(spell['requires']).is_satisfied(player, null)) {
        // spell disappeared (e.g. due to sale running out)
        dialog.show = false;
        return;
    }

    dialog.widgets['loading_spinner'].show = dialog.widgets['hider'].show = pending;
    var hi = (dialog.mouse_enter_time > 0) && (!dialog.widgets['hider'].show) && !pending;
    dialog.xy = [dialog.user_data['base_xy'][0],
                 dialog.user_data['base_xy'][1] - (hi && !dialog.widgets['bg'].pushed ? 1 : 0)];
    dialog.widgets['bg_shine'].alpha = (hi ? (dialog.widgets['bg'].pushed ? 1 : 0.66 ) : 0.5);

    if('buy_text' in dialog.widgets) {
        dialog.widgets['buy_text'].text_color = SPUI.make_colorv(dialog.data['widgets']['buy_text']['text_color'+(hi? '_highlight':'')]);
    }

    var pile_size = ('ui_pile_size' in spell ? spell['ui_pile_size'] : dialog.user_data['ui_index']);
    dialog.widgets['gamebucks_pile'].asset = player.get_any_abtest_value('gamebucks_pile_asset', gamedata['store']['gamebucks_pile_asset']);
    dialog.widgets['gamebucks_pile'].state = 'size'+pile_size.toString();

    // spell ui_banner takes priority, but always show a default "SALE" banner when there are attached items
    var banner_text = ('ui_banner' in spell ? eval_cond_or_literal(spell['ui_banner'], player, null) :
                       (buy_gamebucks_sku2_item_list(spell, spellarg).length > 0 ? dialog.data['widgets']['sale_label']['ui_name'] : null));
    dialog.widgets['sale_bg'].show = dialog.widgets['sale_label'].show = (!!banner_text && (banner_text.length > 0));
    dialog.widgets['sale_label'].str = banner_text;
    if(banner_text in dialog.data['widgets']['sale_label']['xy_shift']) {
        dialog.widgets['sale_label'].xy = vec_add(dialog.data['widgets']['sale_label']['xy'], dialog.data['widgets']['sale_label']['xy_shift'][banner_text]);
    }

    var display_currency = null;
    if(SPay.api == 'fbpayments' || SPay.api == 'xsolla' || SPay.api == 'microsoft') {
        // display_currency will be set on a per-spell basis
    } else if(SPay.api == 'kgcredits') {
        display_currency = 'Kongregate Kreds';
    } else if(player.get_any_abtest_value('use_local_currency', gamedata['store']['use_local_currency']) && player.facebook_currency) {
        display_currency = player.facebook_currency['user_currency'];
    } else {
        display_currency = 'Facebook Credits';
    }

    var alloy_qty = (spell['price_formula'] == 'gamebucks_topup' ? topup_bucks : spell['quantity']);

    var payment_currency = ('currency' in spell ? spell['currency'] : 'fbcredits');
    if(SPay.api == 'fbpayments' || SPay.api == 'xsolla' || SPay.api == 'microsoft') {
        if(payment_currency.indexOf(SPay.api+':') != 0) { throw Error('bad payment_currency '+payment_currency); }
        display_currency = payment_currency.split(':')[1];
    }
    var payment_price = Store.get_price(payment_currency, GameObject.VIRTUAL_ID, spell, spellarg, false);

    goog.array.forEach(['name','name2'], function(wname) {
        if(wname in dialog.widgets) {
            var ui_key = (any_sku_has_bonus ? '_withbonus' : '_nobonus');

            var s = dialog.data['widgets'][wname]['ui_name'+ui_key].replace('%qty', pretty_print_number(spell['nominal_quantity'] || alloy_qty)).replace('%gamebucks', Store.gamebucks_ui_name());

            if(s.indexOf('%bonus') != -1) {
                var bonus_list = [];
                if('nominal_quantity' in spell && spell['nominal_quantity'] < spell['quantity'] && 'ui_name_bonus_quantity' in dialog.data['widgets'][wname]) {
                    bonus_list.push(dialog.data['widgets'][wname]['ui_name_bonus_quantity'].replace('%qty', pretty_print_number(spell['quantity'] - spell['nominal_quantity'])).replace('%GAMEBUCKS_NAME', Store.gamebucks_ui_name()));
                }
                if(spell['ui_bonus']) {
                    var b = eval_cond_or_literal(spell['ui_bonus'], player, null);
                    // special-case hack for backwards compatibility with old SKUs ("Unit Bonus" -> "BONUS:\nUnits")
                    if(b.indexOf('Unit Bonus') != -1) {
                        b = b.replace('Unit Bonus', 'BONUS:\nUnits');
                    }

                    bonus_list.push(b);
                }

                if(bonus_list.length > 0) {
                    s = s.replace('%bonus', bonus_list.join('\n'));
                } else {
                    // blank it out
                    s = '';
                }
            }
            dialog.widgets[wname].str = s;

            if('text_offset'+ui_key in dialog.data['widgets'][wname]) {
                dialog.widgets[wname].text_offset = dialog.data['widgets'][wname]['text_offset'+ui_key];
            }

            var size_ui_key = 'text_size'+ ui_key + (wname == 'name' && alloy_qty >= 10000 && ('text_size'+ui_key+'_big' in dialog.data['widgets'][wname]) ? '_big': '');
            var size;
            if(size_ui_key in dialog.data['widgets'][wname]) {
                size = dialog.data['widgets'][wname][size_ui_key];
            } else {
                size = dialog.data['widgets'][wname]['text_size'];
            }
            dialog.widgets[wname].font = SPUI.make_font(size, dialog.data['widgets'][wname]['text_leading']|| (size+3),
                                                        dialog.data['widgets'][wname]['text_style']);
        }
    });

    if(('name2' in dialog.widgets) && !dialog.widgets['name2'].str && !any_sku_has_bonus) {
        dialog.widgets['name'].text_vjustify = 'center';
    } else {
        dialog.widgets['name'].text_vjustify = 'top';
        // note: if any_sku_has_bonus, then use max of number of bonus lines among all SKUs
        var bonus_lines = (any_sku_has_bonus && ('name2' in dialog.widgets) ? Math.max(any_sku_has_bonus, dialog.widgets['name2'].str.split('\n').length) : 0);
        if(bonus_lines == 1) {
            dialog.widgets['name2'].text_vjustify = 'bottom';
            dialog.widgets['name'].text_offset = dialog.data['widgets']['name']['text_offset_oneline'];
            dialog.widgets['name2'].text_offset = dialog.data['widgets']['name2']['text_offset_oneline'];
        } else if(bonus_lines == 3) {
            dialog.widgets['name2'].text_vjustify = 'bottom';
            dialog.widgets['name'].text_offset = dialog.data['widgets']['name']['text_offset_threelines'];
            dialog.widgets['name2'].text_offset = dialog.data['widgets']['name2']['text_offset_threelines'];
        }
    }

    // build tooltip
    var tooltip_list = [];
    if('name2' in dialog.widgets) {
        // clarify nominal/total quantity
        if(('nominal_quantity' in spell) && spell['nominal_quantity'] < spell['quantity']) {
            var s = dialog.data['widgets']['name2']['ui_tooltip_bonus_quantity'];
            s = s.replace('%qty', pretty_print_number(spell['quantity'] - spell['nominal_quantity']));
            s = s.replace('%nominal_qty', pretty_print_number(spell['nominal_quantity']));
            while(s.indexOf('%GAMEBUCKS_NAME') != -1) {
                s = s.replace('%GAMEBUCKS_NAME', Store.gamebucks_ui_name());
            }
            tooltip_list.push(s);
        }
        // list bonus units
        if('give_units' in spell) {
            var temp = get_gamebucks_sku_bonus_units(spell);
            var tip = temp[1].join('\n');
            tooltip_list.push(dialog.data['widgets']['name2']['ui_tooltip_bonus_units'].replace('%units', tip));
        }
    }

    if(tooltip_list.length > 0) {
        dialog.widgets['name2'].tooltip.str = tooltip_list.join('\n\n');
    } else {
        dialog.widgets['name2'].tooltip.str = null;
    }

    // display expire time and bundle values, if applicable
    var expire_time = (dialog.data['widgets']['expire_time']['show'] ? gamebucks_spell_ui_expire_time(spell, spellarg) : -1);
    /** @type {string|null} */
    var bundle_value = null;
    if('bundle_value' in dialog.widgets &&
       'buy_gamebucks_dialog_looks' in gamedata['store'] &&
       gamedata['store']['buy_gamebucks_dialog_looks'][dialog.user_data['look'] || 'default'] &&
       gamedata['store']['buy_gamebucks_dialog_looks'][dialog.user_data['look'] || 'default']['enable_bundle_value']) {
        var look_data = gamedata['store']['buy_gamebucks_dialog_looks'][dialog.user_data['look'] || 'default'];
        var currency = look_data['bundle_value_currency'] || 'gamebucks';
        var scale = eval_cond_or_literal(look_data['bundle_value_scale'] || 1, player, null);
        bundle_value = buy_gamebucks_sku2_ui_bundle_value(spell, spellarg, scale, (currency === 'local'));
    }

    if(bundle_value) {
        dialog.widgets['bundle_value'].str = dialog.data['widgets']['bundle_value']['ui_name'].replace('%d', bundle_value);
    }
    if(expire_time > 0) {
        dialog.widgets['expire_time'].str = dialog.data['widgets']['expire_time']['ui_name'].replace('%togo', pretty_print_time(expire_time - server_time));
    }

    // if neither bundle_value or expire_time is present, show the SKU comment
    if(!bundle_value && expire_time <= 0) {
        dialog.widgets['comment'].show = true;
        dialog.widgets['expire_time'].show = false;
        if('bundle_value' in dialog.widgets) { dialog.widgets['bundle_value'].show = false; }

        // do not display a comment unless at least one SKU has a bonus
        if(any_sku_has_bonus) {
            if('ui_comment' in spell) {
                dialog.widgets['comment'].str = spell['ui_comment'];
            } else if(('nominal_quantity' in spell) && (spell['nominal_quantity'] < spell['quantity']) && (spell['quantity'] >= max_displayed_quantity)) {
                dialog.widgets['comment'].str = dialog.data['widgets']['comment']['ui_name_best_value'];
            } else {
                dialog.widgets['comment'].str = null;
            }
        }
    } else if(bundle_value && expire_time <= 0) { // ONLY show bundle_value
        dialog.widgets['comment'].show = false;
        dialog.widgets['expire_time'].show = false;
        dialog.widgets['bundle_value'].show = true;
    } else if(!bundle_value && expire_time > 0) { // ONLY show expire_time
        dialog.widgets['comment'].show = false;
        dialog.widgets['expire_time'].show = true;
        if('bundle_value' in dialog.widgets) { dialog.widgets['bundle_value'].show = false; }
    } else { // show BOTH bundle_value and expire_time, alternating
        dialog.widgets['comment'].show = false;
        dialog.widgets['expire_time'].show = true;
        dialog.widgets['bundle_value'].show = true;
        // animate fading between the two
        var period = 7, full = 0.3;
        var t = (client_time % period)/period;
        var u;
        if(t < full) {
            u = 0;
        } else if(t < 0.5) {
            u = (t-full)/(0.5-full);
        } else if(t < 0.5+full) {
            u = 1;
        } else {
            u = 1 - (t-(0.5+full))/(1-(0.5+full));
        }
        dialog.widgets['expire_time'].alpha = u;
        dialog.widgets['bundle_value'].alpha = 1-u;
    }

    if('warning_text' in dialog.widgets) {
        dialog.widgets['warning_text'].str = buy_gamebucks_sku2_ui_warning(spell, spellarg);
        goog.array.forEach(['buy_text','price_display'], function(wname) {
            dialog.widgets[wname].xy = dialog.data['widgets'][wname][(dialog.widgets['warning_text'].str ? 'xy_warning' : 'xy')];
        });
    }

    //dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    //if(payment_currency == 'kgcredits') {
    //dialog.widgets['price_display'].state = 'kgcredits';
    //} else {
    //dialog.widgets['price_display'].state = ((display_currency == 'Facebook Credits' && payment_currency == 'fbcredits') || player.get_any_abtest_value('always_show_fbcredits_logo', gamedata['store']['always_show_fbcredits_logo']) ? 'fbcredits' : 'neutral');
    //}

    if(payment_price >= 0) {
        dialog.widgets['price_display'].str = Store.display_real_currency_amount(display_currency, payment_price, payment_currency, false);
        // manually add " Credits" suffix to Facebook Credits amounts in the list
        if(display_currency == 'Facebook Credits' && payment_currency == 'fbcredits') {
            dialog.widgets['price_display'].str += ' Credits';
        } else if(display_currency == 'Kongregate Kreds' && payment_currency == 'kgcredits') {
            dialog.widgets['price_display'].str += ' Kreds';
        }
    } else {
        dialog.widgets['price_display'].str = null;
    }

    if(payment_price >= 0 && !pending) {
        dialog.widgets['bg'].state = 'normal';
        dialog.widgets['bg'].onclick = (function (spname, _spellarg, _order, _alloy_qty, _payment_price, _payment_currency) { return function(widget) {
            var dialog = widget.parent;
            if(dialog.parent && dialog.parent.user_data['pending']) { return; }

            if(_order && (player.resource_state['gamebucks'] + _alloy_qty) < _order['price']) {
                // don't attempt continuation order if alloy amount would be insufficient
                _order = null;
            }

            // should match Store.get_description() results
            var descr = spname;
            var extra_descr = buy_gamebucks_sku2_metrics_description(spell, _spellarg);
            if(extra_descr) {
                descr += ','+extra_descr;
            }
            purchase_ui_event('4440_buy_gamebucks_init_payment', {'gui_version': dialog.user_data['ver'],
                                                                  'gui_look': dialog.user_data['look'],
                                                                  'method': dialog.parent.user_data['dialog'],
                                                                  'sku': descr,
                                                                  'gamebucks': _alloy_qty,
                                                                  'currency': _payment_currency,
                                                                  'currency_price': _payment_price});
            var credits_props = {'no_clear': true};
            var gift_order = (dialog.parent.user_data['chapter'] == 'gifts' && dialog.parent.user_data['gift_order']);
            if(gift_order) {
                // fill in amount here
                gift_order['gifts'][0]['gamebucks'] = _alloy_qty;
                credits_props['gift_order'] = gift_order;
            }

            var credits_cb = (function (_widget, __order) { return function() {
                var dialog = _widget.parent;
                if(dialog) {
                    if(dialog.parent) {
                        dialog.parent.user_data['pending'] = false;

                        // get rid of buy gamebucks dialog
                        // XXX hack - UNLESS the only child is item_discovered
                        if(dialog.parent.children[dialog.parent.children.length-1].user_data &&
                           dialog.parent.children[dialog.parent.children.length-1].user_data['dialog'] === 'item_discovered') {
                        } else {
                            close_dialog(dialog.parent);
                        }
                    }
                }

                if(__order && player.resource_state['gamebucks'] >= __order['price']) {
                    // re-attempt the original order
                    if(Store.place_gamebucks_order(__order['price'], __order['unit_id'], __order['spellname'], __order['spellarg'], __order['cb'] || null)) {
                        invoke_ui_locker();
                    }
                }
            }; })(widget, _order);

            var placer = (function (_dialog, __payment_currency, _spname, _spellarg, _credits_cb, _credits_props) { return function() {
                _dialog.widgets['glowfx'].show = true;
                _dialog.widgets['glowfx'].reset_fx();

                if(SPay.api != 'fbcredits' && player.get_any_abtest_value('lock_buy_gamebucks_dialog_during_payment', gamedata['store']['lock_buy_gamebucks_dialog_during_payment'])) {
                    // lock dialog
                    if(_dialog.parent) { _dialog.parent.user_data['pending'] = true; }
                    _credits_props['fail_cb'] = (function (__dialog) { return function() {
                        // unlock dialog on fail as well as success
                        if(__dialog.parent) { __dialog.parent.user_data['pending'] = false; }
                    }; })(_dialog);
                }
                Store.place_order(__payment_currency, GameObject.VIRTUAL_ID, _spname, _spellarg, _credits_cb, _credits_props);
            }; })(dialog, _payment_currency, spname, spellarg, credits_cb, credits_props);

            if(gift_order) {
                invoke_confirm_gift_order_dialog(gift_order, placer);
            } else {
                placer();
            }
        }; })(spellname, spellarg, order, alloy_qty, payment_price, payment_currency);
    } else {
        dialog.widgets['bg'].state = 'disabled';
        dialog.widgets['bg'].onclick = null;
    }

    // apply look
    var enable_attachment_pulsing = false;
    if('buy_gamebucks_dialog_looks' in gamedata['store']) {
        var look = dialog.user_data['look'] || 'default';
        var look_data = gamedata['store']['buy_gamebucks_dialog_looks'][look] || {'widgets':{}};
        if(look_data['enable_attachment_pulsing']) {
            enable_attachment_pulsing = true;
        }
        for(var wname in look_data['widgets']) {
            if(wname in dialog.widgets) {
                var w = dialog.widgets[wname];
                var props = look_data['widgets'][wname];
                if('ui_name' in props) {
                    w.str = props['ui_name'];
                }
                if('text_style' in props) {
                    w.font = SPUI.make_font(w.font.size, w.font.leading, props['text_style']);
                }
                if('text_color' in props) {
                    w.text_color = SPUI.make_colorv(props['text_color']);
                }
                if('color' in props) {
                    w.color = SPUI.make_colorv(props['color']);
                }
                if('gradient_color' in props) {
                    w.gradient_color = SPUI.make_colorv(props['gradient_color']);
                }
            }
        }
    }

    var has_attachments = update_buy_gamebucks_sku2_attachments(dialog, spell, spellarg, enable_attachment_pulsing);

    if(expect_loot && (!has_attachments || (has_attachments.length == 1 && has_attachments[0]['spec'] == 'gamebucks'))) {
        // we were showing an item bundle originally, but now we're not anymore (e.g. because it was a one-time bundle
        // and the player bought it), so hide this since it will duplicate the non-bundled version of the same SKU.
        dialog.show = false;
    }
}

// return list of attachments, not including bonus gamebucks that come from nominal vs. actual quantity
function buy_gamebucks_sku2_item_list(spell, spellarg) {
    if('loot_table' in spell && (!spellarg || spellarg['want_loot'])) {
        return session.get_loot_items(player, gamedata['loot_tables_client'][spell['loot_table']]['loot']).item_list;
    }
    return [];
}

/** Look into the loot table for an active BUY_GAMEBUCKS sku spell to pull out a parameter
    @param {!Object} spell
    @param {?} spellarg
    @param {string} param_name
    @return {T|null}
    @template T */
function buy_gamebucks_sku2_get_loot_table_parameter(spell, spellarg, param_name) {
    if('loot_table' in spell && (!spellarg || spellarg['want_loot'])) {
        // note: this has some opinions about the loot table structure.
        var master_table = gamedata['loot_tables_client'][spell['loot_table']];

        // case 1 - parameter is on the master loot table
        if(param_name in master_table) {
            return eval_cond_or_literal(master_table[param_name], player, null);
        }

        // case 2 - master loot table indirects exactly once to another table
        if(master_table['loot'].length < 1) { return null; } // empty
        if(!('cond' in master_table['loot'][0])) { throw Error('unexpected master loot table structure: '+JSON.stringify(master_table['loot'])); }
        var table_ref = eval_cond_or_literal(master_table['loot'][0]['cond'], player, null);
        if(table_ref) {
            if(!('table' in table_ref)) { throw Error('unexpected subordinate loot table structure: '+JSON.stringify(table_ref)); }
            var sub_table = gamedata['loot_tables_client'][table_ref['table']];
            if(param_name in sub_table) {
                return eval_cond_or_literal(sub_table[param_name], player, null);
            }
        }
    }
    return null;
};


/** Get the metrics_description for an active BUY_GAMEBUCKS sku spell
    @param {!Object} spell
    @param {?} spellarg
    @return {string|null} */
function buy_gamebucks_sku2_metrics_description(spell, spellarg) {
    return buy_gamebucks_sku2_get_loot_table_parameter(spell, spellarg, 'metrics_description');
}

/** Get ui_warning attached to this SKU
    @param {!Object} spell
    @param {?} spellarg
    @return {string|null} */
function buy_gamebucks_sku2_ui_warning(spell, spellarg) {
    var ret = buy_gamebucks_sku2_get_loot_table_parameter(spell, spellarg, 'ui_warning');
    if(!ret && 'ui_bonus' in spell) {
        ret = eval_cond_or_literal(spell['ui_bonus'], player, null);
    }
    return ret;
}

/** Get the UI-visible item bundle gamebucks value for an active BUY_GAMEBUCKS sku spell
    @param {!Object} spell
    @param {?} spellarg
    @param {number} scale_factor
    @param {boolean} use_local_currency
    @return {string|null} */
function buy_gamebucks_sku2_ui_bundle_value(spell, spellarg, scale_factor, use_local_currency) {
    var num_gamebucks = buy_gamebucks_sku2_get_loot_table_parameter(spell, spellarg, 'ui_gamebucks_value') || 0;
    if(num_gamebucks <= 0) { return null; }
    num_gamebucks *= scale_factor;

    // the local currency conversion is messy and only works for fbpayments and xsolla APIs.
    // XXX fix up later if the A/B test is successful.
    if(use_local_currency && 'currency' in spell &&
       (spell['currency'].indexOf('fbpayments:') === 0 || spell['currency'].indexOf('xsolla:') === 0)) {
        var real_currency = spell['currency'].split(':')[1];
        var tbl = gamedata['store']['gamebucks_open_graph_prices'];
        for(var i = 0; i < tbl.length; i++) {
            var cur_name = tbl[i][0], cur_rate = tbl[i][1];
            if(cur_name === real_currency) {
                var real_amount = parseFloat(cur_rate) * num_gamebucks;
                return Store.display_real_currency_amount(real_currency, real_amount, spell['currency'], true);
            }
        }
    }
    return Store.display_user_currency_amount(num_gamebucks, 'full');
};

// merge identical successive entries in an item list, even if this would violate the max stack size
function collapse_item_list(ls) {
    var is_simple_item = function(item) { // true if the item has no keys other than 'spec' and 'stack'
        return !goog.object.some(item, function(v,k) { return !goog.array.contains(['spec','stack'], k); });
    };
    var ret = [];
    for(var i = 0; i < ls.length; i++) {
        var item = ls[i];
        if(ret.length > 0 &&
           ret[ret.length-1]['spec'] === item['spec'] &&
           is_simple_item(ret[ret.length-1]) &&
           is_simple_item(item)) {
            // merge
            var last = ret[ret.length-1];
            last['stack'] = ('stack' in last ? last['stack'] : 1) + ('stack' in item ? item['stack'] : 1);
            continue;
        }
        ret.push(item);
    }
    return ret
};

/** @param {!SPUI.Dialog} dialog
    @param {!Object} spell
    @param {?} spellarg
    @param {boolean} enable_attachment_pulsing
    @return {!Array<!Object>} attachments */
function update_buy_gamebucks_sku2_attachments(dialog, spell, spellarg, enable_attachment_pulsing) {
    if(!('attachments0' in dialog.widgets)) { return []; } // inapplicable
    var item_list = [];

    // special case for bonus gamebucks - add a virtual "gamebucks" item
    if('nominal_quantity' in spell && spell['nominal_quantity'] < spell['quantity']) {
        item_list.push({'spec':'gamebucks', 'stack': spell['quantity'] - spell['nominal_quantity']});
    };
    item_list = collapse_item_list(item_list.concat(buy_gamebucks_sku2_item_list(spell, spellarg)));

    if(item_list.length >= 1 && item_list[0]['spec'] == 'gamebucks') {
        // add UI text for the "bonus" gamebucks
        var item = item_list[0];
        var stack = ('stack' in item ? item['stack'] : 1);
        var bonus_pct = 100.0*stack/spell['nominal_quantity'];
        var bonus_pct_str = Math.max(Math.floor(bonus_pct), 1).toFixed(0);
        item['ui_name'] = dialog.widgets['attachments0'].data['widgets']['name']['ui_name_bonus_quantity'].replace('%qty', pretty_print_number(stack)).replace('%pct', bonus_pct_str).replace('%GAMEBUCKS_NAME', Store.gamebucks_ui_name());
    }
    update_buy_gamebucks_or_store_sku_attachments(dialog, item_list, enable_attachment_pulsing);
    return item_list;
};

/** @param {!SPUI.Dialog} dialog
    @param {!Array<!Object>} item_list
    @param {boolean} enable_attachment_pulsing */
function update_buy_gamebucks_or_store_sku_attachments(dialog, item_list, enable_attachment_pulsing) {
    if(!('attachment_phases' in dialog.user_data) || dialog.user_data['attachment_phases'].length < item_list.length) {
        dialog.user_data['attachment_phases'] = Array(item_list.length);
        for(var i = 0; i < item_list.length; i++) {
            dialog.user_data['attachment_phases'][i] = Math.random();
        }
    }

    var visible_rows = dialog.data['widgets']['attachments']['array'][0] * dialog.data['widgets']['attachments']['array'][1];
    var pages = Math.floor((item_list.length + visible_rows - 1) / visible_rows);
    var cur_page = (pages > 1 ? Math.floor(client_time % pages) : 0);
    for(var row = 0; row < visible_rows; row += 1) {
        var index = cur_page * visible_rows + row;
        if(index < item_list.length) {
            var item = item_list[index];
            var item_spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            var item_level = ('level' in item ? item['level'] : 1);
            var rarity = (item['spec'] === 'gamebucks' ? 4 : ('rarity' in item_spec ? item_spec['rarity'] : 1));

            var attach = dialog.widgets['attachments'+row.toString()];
            attach.show = true;
            dialog.widgets['dividers'+row.toString()].show = (row != visible_rows - 1); // hide under last row
            ItemDisplay.set_inventory_item_asset(attach.widgets['icon'], item_spec);
            var outline_color = SPUI.make_colorv(gamedata['client']['loot_rarity_colors'][Math.min(Math.max(rarity+1, 0), gamedata['client']['loot_rarity_colors'].length-1)]);
            // reduce garishness
            if(enable_attachment_pulsing) {
                outline_color.a = 0.5;
            }
            attach.widgets['icon_frame'].outline_color = outline_color;
            var stack = ('stack' in item ? item['stack'] : 1);
            var ui_quantity;
            if(item['spec'] === 'gamebucks') {
                ui_quantity = pretty_print_number(stack);
            } else {
                if(stack == 1) {
                    ui_quantity = ''; // '1x';
                } else {
                    ui_quantity = goog.string.trim(ItemDisplay.get_inventory_item_stack_prefix(item_spec, stack));
                }
            }
            attach.widgets['quantity'].str = ui_quantity;
            attach.widgets['name'].str = ('ui_name' in item ? item['ui_name'] : ItemDisplay.get_inventory_item_ui_name(item_spec, (item_level > 1 ? item_level : null), stack));
            attach.widgets['name'].clip_to = attach.widgets['name'].data[(ui_quantity ? 'clip_to' : 'clip_to_no_qty')];

            // pass through clicks to purchase the SKU
            attach.widgets['tooltip_maker'].onclick = function(w) {
                var sku_dialog = w.parent.parent;
                if(sku_dialog.widgets['bg'].state !== 'disabled') {
                    sku_dialog.widgets['bg'].onclick(sku_dialog.widgets['bg']);
                }
            };

            // unique address for this attachment to this SKU
            var slot = dialog.user_data['ui_index'].toString()+':'+row.toString();
            attach.widgets['tooltip_maker'].onenter = (function (_slot, _item) { return function(w) {
 var dialog = w.parent;
                var context_parent = w.parent.parent.user_data['context_parent'];
                if(context_parent.user_data['context'] && context_parent.user_data['context'].user_data['slot'] === _slot) { return; }

                // XXXXXX hack to prevent tooltip show-through into child dialog
                var enable_tooltip = true;
                var p = context_parent;
                while(p.parent) {
                    if(p.children[p.children.length-1] !== context_parent && p.children[p.children.length-1].modal) {
                        return; // no tooltip
                    }
                    p = p.parent;
                }

                invoke_inventory_context(context_parent, w, _slot, _item, false, {'parent_dialog': context_parent});

                // set transparent so that onleave is always called reliably
                if(context_parent.user_data['context']) { context_parent.user_data['context'].transparent_to_mouse = true; }
            }; })(slot, item);
            attach.widgets['tooltip_maker'].onleave_cb = (function (_slot, _item) { return function(w) {
                var context_parent = w.parent.parent.user_data['context_parent'];
                if(context_parent.user_data['context'] && context_parent.user_data['context'].user_data['slot'] === _slot) {
                    invoke_inventory_context(context_parent, w, -1, null, false);
                }
            }; })(slot, item);

            // set up pulsing rarity halo
            if(enable_attachment_pulsing && 'asset_rarity'+rarity.toString() in attach.data['widgets']['rarity']) {
                attach.widgets['rarity'].show = true;
                attach.widgets['rarity'].asset = attach.data['widgets']['rarity']['asset_rarity'+rarity.toString()];
                var amp = attach.data['widgets']['rarity']['pulse_amplitude'];
                var period = attach.data['widgets']['rarity']['pulse_period'];
                var phase = dialog.user_data['attachment_phases'][index];
                var alpha = (1-amp) + amp * Math.sin((client_time/period + phase)*2*Math.PI);
                attach.widgets['rarity'].alpha = alpha;
            } else {
                attach.widgets['rarity'].show = false;
            }

        } else {
            dialog.widgets['attachments'+row.toString()].show =
                dialog.widgets['dividers'+row.toString()].show = false;
        }
    }
}

// utility to completely lock up the UI until server catches up, with optional cb to call after we close

/** @type {SPUI.Dialog|null} */
var g_ui_locker = null; // global instance

/** @param {number|null=} sync_marker
    @param {function()|null=} cb */
function invoke_ui_locker(sync_marker, cb) {
    if(!sync_marker && (sync_marker !== 0)) { sync_marker = synchronizer.request_sync(); }
    //console.log('ui_locker UP '+sync_marker.toString());
    if(g_ui_locker) {
        g_ui_locker.user_data['sync_marker'] = Math.max(g_ui_locker.user_data['sync_marker'], sync_marker);
        return g_ui_locker;
    }
    var dialog_data = gamedata['dialogs']['ui_locker'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'ui_locker';
    dialog.user_data['sync_marker'] = sync_marker;
    dialog.user_data['cb'] = cb || null;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = dialog_data['modal'];
    dialog.ondraw = update_ui_locker;
    dialog.on_destroy = function(dialog) {
        //console.log('ui_locker DESTROY '+dialog.user_data['sync_marker'].toString());
        if(g_ui_locker === dialog) { g_ui_locker = null; }
    };
    g_ui_locker = dialog;
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_ui_locker(dialog) {
    if(synchronizer.is_in_sync(dialog.user_data['sync_marker'])) {
        //console.log('ui_locker DOWN '+dialog.user_data['sync_marker'].toString());
        var cb = dialog.user_data['cb'];
        close_parent_dialog(dialog.widgets['loading_rect']);
        if(cb) { cb(); }
    }
}

// this locker will stay up until you manually close it
function invoke_ui_locker_until_closed() {
    var dialog = invoke_ui_locker(-1);
    dialog.ondraw = null;
    return dialog;
}

/** @param {!Array.<Object>} items
    @param {number} duration
    @param {string} where
*/
function invoke_items_discovered(items, duration, where) {
    if(!goog.array.contains(['inventory','messages','loot_buffer'], where)) { throw Error('unhandled "where" value '+where); }

    // skip if using fast modal looting
    if(where === 'loot_buffer' && loot_dialog_fast_anim) {
        invoke_loot_dialog(gamedata['strings']['combat_messages']['item_discovered']);
        return null;
    }

    return do_invoke_items_discovered(items, duration, where, null);
}

/** @param {!Array.<Object>} items
    @param {number} duration
    @param {string} where
    @param {SPUI.Dialog|null=} lottery_dialog
    @return {!SPUI.Dialog} */
function do_invoke_items_discovered(items, duration, where, lottery_dialog) {
    items = collapse_item_list(items);

    var dialog_data = gamedata['dialogs']['item_discovered'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'item_discovered';
    dialog.user_data['items'] = items;
    dialog.user_data['duration'] = duration;
    dialog.user_data['where'] = where;
    dialog.user_data['anim_start_time'] = -1;
    dialog.user_data['context'] = null;
    install_child_dialog(dialog);
    dialog.modal = true;
    dialog.auto_center();

    var exp_days = duration / (24*60*60);
    if(exp_days < 0) {
        dialog.widgets['expiry'].show = false;
    } else {
        dialog.widgets['expiry'].str = dialog.data['widgets']['expiry']['ui_name'].replace('%d', exp_days.toFixed(0));
    }

    var all_fungible = true;
    goog.array.forEach(items, function(item, i) {
        var spec = gamedata['items'][item['spec']];
        if(!spec['fungible']) { all_fungible = false; }

        var sku_glow = SPUI.instantiate_widget(dialog.data['widgets']['sku_glow']);
        dialog.add(sku_glow);
        dialog.widgets['sku_glow'+i.toString()] = sku_glow;

        var sku = new SPUI.Dialog(gamedata['dialogs'][dialog.data['widgets']['sku']['dialog']]);
        dialog.add(sku);
        dialog.widgets['sku'+i.toString()] = sku;

        sku.widgets['name'].set_text_with_linebreaking(ItemDisplay.get_inventory_item_ui_name(spec));
        ItemDisplay.set_inventory_item_asset(sku.widgets['icon'], spec);
        ItemDisplay.set_inventory_item_stack(sku.widgets['icon_stack'], spec, item);
        sku.widgets['price_icon'].show = false;
        sku.widgets['price_display'].text_offset = [0,0];
        var rarity = (spec['rarity'] || 0);
        sku.widgets['price_display'].str = gamedata['strings']['rarities'][rarity+1].toUpperCase();
        var col = gamedata['client']['loot_rarity_colors'][rarity+1];
        sku.widgets['price_display'].text_color = new SPUI.Color(col[0], col[1], col[2], 1);
        sku.widgets['glowfx'].show = true;
        sku.widgets['glowfx'].reset_fx();
        sku.widgets['slot0,0'].show = true;
        sku.widgets['jewel'].show = false;

        if(where !== 'loot_buffer') { // set up tooltip, unless in loot buffer
            sku.widgets['icon_frame'].onenter = (function (_item, _slot) { return function(w) {
                var dialog = w.parent.parent;
                if(dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === _slot) { return; }
                invoke_inventory_context(dialog, w, _slot, _item, false, {'parent_dialog': dialog});
                // set transparent so that onleave is always called reliably
                if(dialog.user_data['context']) { dialog.user_data['context'].transparent_to_mouse = true; }
            }; })(item, i);
            sku.widgets['icon_frame'].onleave_cb = (function (_item, _slot) { return function(w) {
                var dialog = w.parent.parent;
                if(dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === _slot) {
                    invoke_inventory_context(dialog, w, -1, null, false);
                }
            }; })(item, i);
        }
    });

    dialog.widgets['title'].str = dialog.data['widgets']['title'][(items.length === 1 ? 'ui_name' : 'ui_name_plural')];

    if(where === 'loot_buffer') {
        // modal looting - turn off extra stuff, and no onhover tip
        dialog.widgets['subtitle'].show = dialog.widgets['expiry'].show = dialog.widgets['store_soon'].show = false;
    } else {
        dialog.widgets['subtitle'].show = true;
        dialog.widgets['subtitle'].str = dialog.data['widgets']['subtitle']['ui_name_'+where];

        if(where === 'messages') {
            dialog.widgets['store_soon'].show = true;
            dialog.widgets['close_button'].str = dialog.data['widgets']['close_button']['ui_name_messages'];
        } else if(where == 'inventory') {
            dialog.widgets['close_button'].str = dialog.data['widgets']['close_button'][(all_fungible ? 'ui_name_inventory_fungible':'ui_name_inventory')].replace('%inventory_building', gamedata['buildings'][gamedata['inventory_building']]['ui_name']);
        }
    }

    var enable_animation = (where === 'messages');

    if(enable_animation) {
        dialog.widgets['close_button'].onclick = close_item_discovered;
    } else {
        dialog.widgets['close_button'].onclick = function(w) {
            close_parent_dialog(w);
            invoke_loot_dialog(); // immediate
        };
    }

    if(lottery_dialog) {
        dialog.user_data['lottery_dialog'] = lottery_dialog;
        dialog.widgets['lottery_price_display'].show =
            dialog.widgets['lottery_button'].show = true;
     }

    dialog.ondraw = animate_item_discovered;
    dialog.ondraw(dialog); // set initial sku positions
    return dialog;
}

function close_item_discovered(widget) {
    var dialog = widget.parent;
    if(dialog.user_data['anim_start_time'] < 0) {
        dialog.user_data['anim_start_time'] = client_time;
    }
}

/** @param {SPUI.Dialog} dialog */
function animate_item_discovered(dialog) {
    var items = dialog.user_data['items'];

    goog.array.forEach(items, function(item, i) {
        var sku = dialog.widgets['sku'+i.toString()];
        var sku_glow = dialog.widgets['sku_glow'+i.toString()];

        // center the SKUs and glows
        var offset = vec_copy(dialog.data['widgets']['sku']['array_offset']);
        var total_width = offset[0] * (items.length-1) + sku.wh[0];

        var start_xy = [Math.floor((dialog.wh[0] - total_width)/2), dialog.data['widgets']['sku']['xy'][1]];
        // collapse together if need to scrunch horizontally
        var opacity = 1;
        if(dialog.get_absolute_xy()[0] + start_xy[0] < 0) {
            var pad = dialog.data['widgets']['sku']['xy_collapsed'][0];
            start_xy[0] = -dialog.get_absolute_xy()[0] + pad;
            offset = [Math.floor((canvas_width-2*pad-sku.wh[0]) / (items.length-1)), dialog.data['widgets']['sku']['array_offset_collapsed'][1]];
            start_xy[1] -= Math.floor(((items.length-1) * dialog.data['widgets']['sku']['array_offset_collapsed'][1])/2);
            // fade to transparent with more overlap
            opacity = Math.min(Math.max(offset[0] / dialog.data['widgets']['sku']['array_offset'][0], 0.5), 1);
        }

        sku.xy = vec_add(start_xy, vec_scale(i, offset));
        sku_glow.xy = vec_add(sku.xy, vec_sub(dialog.data['widgets']['sku_glow']['xy'], dialog.data['widgets']['sku']['xy']));
        goog.array.forEach(['bg', 'bg_shine', 'name_bg', 'price_bg'], function(wname) {
            sku.widgets[wname].alpha = opacity * sku.widgets[wname].data['alpha'];
        });
        sku_glow.alpha = opacity * sku_glow.data['alpha'];
    });

    if(dialog.user_data['lottery_dialog']) {
        update_lottery_dialog_buttons(dialog, dialog.user_data['lottery_dialog']);
    }

    if(dialog.user_data['where'] !== 'messages') { return; } // no animation
    if(dialog.user_data['anim_start_time'] < 0) { return; }

    var ANIM_TIME = player.get_any_abtest_value('valentina_dialog_anim_time', gamedata['client']['valentina_dialog_anim_time']);

    var progress = clamp((client_time - dialog.user_data['anim_start_time'])/ANIM_TIME, 0, 1);
    if(ANIM_TIME < 0 || dialog.user_data['anim_start_time'] < 0) { progress = 1; }

    var bottom = desktop_dialogs['desktop_bottom'];
    var valentina = bottom.widgets['missions_button'];
    if(!valentina) { progress = 1; }

    dialog.modal = 1-progress;

    if(progress >= 1) {
        close_parent_dialog(dialog.widgets['close_button']);
    } else if(progress > 0) {
        dialog.widgets['bg_blanker'].show = false;
        // zoom into valentina
        progress = 1 - progress;
        progress = Math.pow(progress,2.0);
        var scale = progress;
        // centerpoint of scale effect
        var pivot = vec_add(dialog.xy, vec_scale(0.5, dialog.wh));
        // where centerpoint is at start of animation
        var startpos = vec_add(vec_add(bottom.xy, valentina.xy), vec_scale(0.5, valentina.wh));
        // where centerpoint is at end of animation
        var endpos = pivot;
        //startpos = [0,0]; endpos = [0,0];
        var origin = vec_add(startpos, vec_scale(progress, vec_sub(endpos, startpos)));

        dialog.transform = [scale, 0,
                            0, scale,
                            origin[0] + scale*(-origin[0]), origin[1] + scale*(-origin[1])];
    }
}

function invoke_new_store_dialog() {
    var dialog_data = gamedata['dialogs']['new_store_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'new_store_dialog';
    install_child_dialog(dialog);
    dialog.modal = true;
    dialog.auto_center();
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.user_data['categories'] = [];

    for(var i = 0; i < gamedata['store']['catalog'].length; i++) {
        var cat = gamedata['store']['catalog'][i];
        if('activation' in cat && !read_predicate(cat['activation']).is_satisfied(player,null)) { continue; }
        if('show_if' in cat && !read_predicate(cat['show_if']).is_satisfied(player,null)) { continue; }
        dialog.user_data['categories'].push(cat);
    }

    var i = 0, grid_x = 0, grid_y = 0;
    for(; i < Math.min(dialog.data['widgets']['cat']['array'][0]*dialog.data['widgets']['cat']['array'][1], dialog.user_data['categories'].length); i++) {
        var cat = dialog.user_data['categories'][i];
        var d = dialog.widgets['cat'+grid_x.toString()+','+grid_y.toString()];
        d.show = true;
        d.user_data['category'] = cat;
        d.widgets['icon'].asset = cat['icon'];
        d.widgets['label'].str =  cat['ui_name'];
        d.widgets['bg'].onclick = (function (_cat) { return function(w) {
            var d = w.parent;
            close_parent_dialog(w.parent);
            if('link' in _cat && _cat['link'] === 'buy_gamebucks_dialog') {
                invoke_buy_gamebucks_dialog('new_store_category', -1, null);
            } else {
                invoke_new_store_category(d.user_data['category']);
            }
        }; })(cat);
        d.widgets['jewel'].user_data['count'] = 0;
        d.widgets['jewel'].ondraw = update_notification_jewel;
        d.ondraw = update_new_store_category_label;
        grid_x += 1;
        if(grid_x >= dialog.data['widgets']['cat']['array'][0]) {
            grid_x = 0;
            grid_y += 1;
        }
    }
    while(grid_y < dialog.data['widgets']['cat']['array'][1]) {
        while(grid_x < dialog.data['widgets']['cat']['array'][0]) {
            dialog.widgets['cat'+grid_x.toString()+','+grid_y.toString()].show = false;
            grid_x += 1;
        }
        grid_x = 0;
        grid_y += 1;
    }

    dialog.ondraw = update_new_store;
    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_new_store(dialog) {
    // how big can we be?
    var new_width = canvas_width - 2*dialog.data['margin'][0];
    new_width = clamp(new_width, dialog.data['dimensions'][0], dialog.data['max_dimensions'][0]);
    dialog.wh = [new_width, dialog.data['dimensions'][1]];
    dialog.on_resize(); // reset centering
    dialog.apply_layout(); // adjust miscellaneous widgets

    // lay out category labels
    var slen = dialog.user_data['categories'].length.toString();
    if(!(slen in dialog.data['positions'])) {
        throw Error('unhandled number of store categories: '+slen);
    }
    var POSITIONS = dialog.data['positions'][slen];
    var i = 0, grid_x = 0, grid_y = 0;

    for(; i < Math.min(dialog.data['widgets']['cat']['array'][0]*dialog.data['widgets']['cat']['array'][1], dialog.user_data['categories'].length); i++) {
        var cat = dialog.user_data['categories'][i];
        var d = dialog.widgets['cat'+grid_x.toString()+','+grid_y.toString()];
        // set position, correcting for resizing
        d.xy = vec_add(POSITIONS[i], vec_floor(vec_scale(0.5, vec_sub(dialog.widgets['sunken'].wh, dialog.data['widgets']['sunken']['dimensions']))));
        d.user_data['base_xy'] = [d.xy[0], d.xy[1]];
        grid_x += 1;
        if(grid_x >= dialog.data['widgets']['cat']['array'][0]) {
            grid_x = 0;
            grid_y += 1;
        }
    }
}

function update_new_store_category_label(d) {
    var hi = (d.mouse_enter_time > 0);
    d.xy[1] = d.user_data['base_xy'][1] - (hi && !d.widgets['bg'].pushed ? 1 : 0);

    d.widgets['icon_glow'].xy = vec_copy(d.data['widgets']['icon_glow']['xy'+ (d.widgets['bg'].pushed ? '_pushed' : '')]);
    d.widgets['icon_glow'].wh = vec_copy(d.data['widgets']['icon_glow']['dimensions'+ (d.widgets['bg'].pushed ? '_pushed' : '')]);
    d.widgets['icon_glow'].alpha = (hi ? (d.widgets['bg'].pushed ? 0.66 : 0.2) : 0);
    d.widgets['icon_glow'].asset = d.data['widgets']['icon_glow']['asset'+(d.widgets['bg'].pushed ? '_pushed': '')];
    d.widgets['bg_shine'].alpha = (hi ? (d.widgets['bg'].pushed ? 1 : 0.66 ) : 0.5);
    d.widgets['label_bg_shine'].alpha = 0.8 * d.widgets['bg_shine'].alpha;

    var count = 0;

    if(player.get_any_abtest_value('enable_store_jewel', gamedata['store']['enable_store_jewel'])) {
        if('jewel' in d.user_data['category'] && read_predicate(d.user_data['category']['jewel']).is_satisfied(player, null)) { // jewel on category itself - unusual
            count += 1;
        }
        for(var isku = 0; isku < d.user_data['category']['skus'].length; isku++) {
            var skudata = d.user_data['category']['skus'][isku];
            if(new_store_allow_sku(skudata)) {
                if('jewel' in skudata) {
                    if(read_predicate(skudata['jewel']).is_satisfied(player, null)) {
                        count += 1;
                    }
                }
            }
        }
    }
    d.widgets['jewel'].user_data['count'] = count;
    d.widgets['jewel_new'].show = (count > 0);
}

function new_store_allow_sku(skudata) {
    if('show_if' in skudata && !read_predicate(skudata['show_if']).is_satisfied(player, null)) {
        return false;
    }
    if('spell' in skudata) {
        var spell = gamedata['spells'][skudata['spell']];
        if('new_store_requires' in spell && !read_predicate(spell['new_store_requires']).is_satisfied(player, null)) {
            return false;
        }
    } else if('item' in skudata) {
        var spec = gamedata['items'][skudata['item']];
        if('store_requires' in spec && !read_predicate(spec['store_requires']).is_satisfied(player, null)) {
            return false;
        }
    } else if('loot_table' in skudata) {
        // drop the SKU if its table yields no loot
        if(session.get_loot_items(player, gamedata['loot_tables_client'][skudata['loot_table']]['loot']).item_list.length < 1) {
            return false;
        }
    }
    if(('start_time' in skudata) && (player.get_absolute_time() < skudata['start_time'])) { return false; }
    if(('expire_time' in skudata) && (player.get_absolute_time() >= skudata['expire_time'])) { return false; }

    return true;
}

/** @param {Object} catdata
    @param {(Array.<{cat:Object, sku_name:(string|null|undefined), pos:(number|null|undefined)}>|null)=} parent_catdata
        this is a list of the catdatas on the hierarchical path to this category
        PLUS either a sku name or literal scroll position to scroll to when stepping back up the hierarchy
    @param {string|null=} scroll_to_sku_name - "name" string of a spell, item, or subcategory to scroll to upon opening the category. null to ignore.
    @param {number|null=} scroll_to_pos - explicit initial scroll position. Overrides scroll_to_sku_name. null to ignore.
*/
function invoke_new_store_category(catdata, parent_catdata, scroll_to_sku_name, scroll_to_pos) {
    scroll_to_sku_name = scroll_to_sku_name || null;
    scroll_to_pos = (typeof scroll_to_pos == 'undefined' ? null : scroll_to_pos);

    var dialog_data = gamedata['dialogs']['new_store_category'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'new_store_category';
    dialog.user_data['catdata'] = catdata;
    if(parent_catdata && parent_catdata.length < 1) { parent_catdata = null; } // code below expects parent_catdata to be null instead of []
    dialog.user_data['parent_catdata'] = parent_catdata || null;

    var skulist = [];

    if('record_feature_use' in catdata) {
        player.record_feature_use(catdata['record_feature_use'].replace('%WEEK', current_pvp_week().toFixed(0)));
    }

    // Since game state cannot change during this function, cache predicate results.
    predicate_cache_on();

    for(var i = 0; i < catdata['skus'].length; i++) {
        var skudata = catdata['skus'][i];
        if(!new_store_allow_sku(skudata)) { continue; }
        skulist.push(skudata);
    }

    // add extra special item SKUs from A/B tests
    if(catdata['name'] == 'specials') {
        for(var test_name in player.abtests) {
            var group = player.abtests[test_name];
            if(test_name in gamedata['abtests'] && gamedata['abtests'][test_name]['active'] && (group in gamedata['abtests'][test_name]['groups'])) {
                var data = gamedata['abtests'][test_name]['groups'][group];
                if('extra_store_specials' in data) {
                    var extras = data['extra_store_specials'];
                    for(var i = 0; i < extras.length; i++) {
                        if(new_store_allow_sku(extras[i])) {
                            skulist.push(extras[i]);
                        }
                    }
                }
            }
        }
    }

    dialog.user_data['skulist'] = skulist;
    install_child_dialog(dialog);
    dialog.modal = true;
    dialog.auto_center();

    var ui_name = '';
    if(parent_catdata) {
        goog.array.forEach(parent_catdata, function(data, idx) {
            if(data.cat['ui_name']) { // toplevel catalog does not have a ui_name
                ui_name = ui_name + (idx != 0 ? ' :: ' : '') + data.cat['ui_name'];
            }
        });
    }
    ui_name += (ui_name.length != 0 ? ' :: ' : '') + catdata['ui_name'];

    dialog.widgets['title_bold'].str = dialog.data['widgets']['title_bold']['ui_name'].replace('%s', ui_name);
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['back_button'].onclick = function(w) {
        var parent_catdata = w.parent.user_data['parent_catdata'];
        close_parent_dialog(w);
        if(parent_catdata && parent_catdata.length > 0 && parent_catdata[0].cat['ui_name']) { // note: toplevel catalog does not have a ui_name
            // invoke parent category
            invoke_new_store_category(parent_catdata[parent_catdata.length-1].cat, (parent_catdata.length > 1 ? parent_catdata.slice(0, parent_catdata.length-1) : null),
                                      parent_catdata[parent_catdata.length-1].sku_name || null, parent_catdata[parent_catdata.length-1].pos || null);
        } else {
            // go back to top level
            invoke_new_store_dialog();
        }
    };

    if(('activation' in catdata) && !read_predicate(catdata['activation']).is_satisfied(player,null)) {
        // illegal category - punt
        dialog.widgets['back_button'].onclick(dialog.widgets['back_button']);
        predicate_cache_off();
        return null;
    }

    dialog.widgets['resource_bar_fbcredits_button'].onclick = Store.get_balance_plus_cb();

    dialog.user_data['open_time'] = client_time;

    // the index of a SKU to show in the center as soon as the dialog opens
    // null for no scrolling (0 means "center first SKU")
    dialog.user_data['initial_scroll'] = null;
    dialog.user_data['initial_scroll_exact'] = false;
    if(scroll_to_pos !== null) {
        // convert from pixels to SKU index units
        dialog.user_data['initial_scroll'] = scroll_to_pos / dialog.data['widgets']['sku']['array_offset'][0];
        dialog.user_data['initial_scroll_exact'] = true;
    } else if(scroll_to_sku_name) {
        dialog.user_data['initial_scroll'] = goog.array.findIndex(skulist, function(entry) {
            return ((('name' in entry) && entry['name'] === scroll_to_sku_name) ||
                    (('item' in entry) && entry['item'] === scroll_to_sku_name) ||
                    (('spell' in entry) && entry['spell'] === scroll_to_sku_name));
        });
        if(dialog.user_data['initial_scroll'] < 0) {
            dialog.user_data['initial_scroll'] = null;
            console.log("invoke_new_store_category(): did not find scroll_to_sku_name: "+scroll_to_sku_name);
        }
    }
    dialog.user_data['scroll_pos'] = dialog.user_data['scroll_goal'] = 0;
    dialog.user_data['scrolled'] = false;

    dialog.widgets['scroll_left'].onclick = function (w) { new_store_category_scroll(w.parent, -1); };
    dialog.widgets['scroll_right'].onclick = function (w) { new_store_category_scroll(w.parent, 1); };
    dialog.widgets['scroll_left_jewel'].ondraw =
        dialog.widgets['scroll_right_jewel'].ondraw = update_notification_jewel;
    dialog.widgets['scroll_left_jewel'].user_data['count'] =
        dialog.widgets['scroll_right_jewel'].user_data['count'] = 0;

    var default_sku_index = -1;
    var default_sku_priority = -1;

    var i = 0;
    for(; i < skulist.length; i++) {
        var skudata = skulist[i];

        if(('ui_new_store_enterkey_priority' in skudata) && (skudata['ui_new_store_enterkey_priority'] > default_sku_priority)) {
            default_sku_priority = skudata['ui_new_store_enterkey_priority'];
            default_sku_index = i;
        }

        var d = new SPUI.Dialog(gamedata['dialogs'][dialog.data['widgets']['sku']['dialog']]);
        dialog.add(d);
        dialog.widgets['sku'+i.toString()] = d;

        d.user_data['skudata'] = skudata;
        d.user_data['ui_index'] = i;
        d.user_data['context_parent'] = dialog;

        d.user_data['catpath'] = [];
        if(parent_catdata) {
            goog.array.forEach(parent_catdata, function(data) {
                d.user_data['catpath'].push(data.cat['name']);
            });
        }
        d.user_data['catpath'].push(catdata['name']);

        d.user_data['base_xy'] = [d.xy[0], d.xy[1]];
        d.user_data['pending'] = -1;
        d.user_data['context'] = null;
        d.user_data['anim_start'] = client_time + d.data['widgets']['info']['blink_offset'] * i;
        d.user_data['sound_start'] = -1;

        // these fields are for use by the purchase confirmation dialog. They are updated dynamically by the update function.
        d.user_data['ui_price_str'] = '?';
        d.user_data['should_confirm_purchase'] = false; // controls whether the purchase confirmation is enabled (false if the player doesn't have sufficient resources to buy the thing)

        var banner_text = ('ui_banner' in skudata ? eval_cond_or_literal(skudata['ui_banner'], player, null) : null);
        d.widgets['sale_bg'].show = d.widgets['sale_label'].show = (!!banner_text && (banner_text.length > 0));
        d.widgets['sale_label'].str = banner_text;
        if(banner_text in d.data['widgets']['sale_label']['tweaks']) {
            var tweak = d.data['widgets']['sale_label']['tweaks'][banner_text];
            d.widgets['sale_label'].xy = vec_add(d.data['widgets']['sale_label']['xy'], tweak['xy_shift']);
            var text_size = tweak['text_size'] || d.data['widgets']['sale_label']['text_size'];
            d.widgets['sale_label'].font = SPUI.make_font(text_size, text_size+3, d.data['widgets']['sale_label']['text_style']);
        }

        d.widgets['icon_frame'].onclick = null;
        d.widgets['icon_frame'].transparent_to_mouse = true;
        d.widgets['slot0,0'].show = true;

        var tip_item = null;

        if('spell' in skudata) {
            var spell = gamedata['spells'][skudata['spell']];
            d.widgets['name'].set_text_with_linebreaking_and_shrink_font_to_fit(skudata['ui_name'] || spell['ui_new_store_name'] || spell['ui_name']);
            d.widgets['icon'].asset = spell['new_store_icon'] || spell['icon'];

            if('new_store_tip_item' in spell) {
                // create a "virtual" fake item for showing on the tooltip
                tip_item = {'spec':spell['new_store_tip_item'] };
            }
        } else if('item' in skudata) {
            var spec = gamedata['items'][skudata['item']];
            var stack = ('stack' in skudata ? skudata['stack'] : 1);
            tip_item = {'spec': skudata['item'], 'stack': stack};
            if('melt_duration' in skudata) {
                tip_item['melt_duration'] = skudata['melt_duration'];
            }
            if('melt_time' in skudata) {
                tip_item['expire_time'] = skudata['melt_time'];
            }

            var fallback_name = ItemDisplay.get_inventory_item_stack_prefix(spec, stack) + ItemDisplay.get_inventory_item_ui_name(spec);

            d.widgets['name'].set_text_with_linebreaking_and_shrink_font_to_fit(('ui_name' in skudata ? skudata['ui_name'] : fallback_name));
            ItemDisplay.set_inventory_item_asset(d.widgets['icon'], spec);
            ItemDisplay.set_inventory_item_stack(d.widgets['icon_stack'], spec, tip_item);
        } else if('loot_table' in skudata) {
            // loot table - override the single item icon
            d.widgets['name'].set_text_with_linebreaking_and_shrink_font_to_fit(skudata['ui_name'] || '?');
            goog.array.forEach(['slot0,0','icon_bg','icon_glow','icon','icon_stack','icon_frame'], function(wname) {
                d.widgets[wname].show = false;
            });
        } else if('name' in skudata) {
            // hierarchical child category

            // change a few widget settings to look better as a category
            d.widgets['folder_icon'].show = true;
            d.widgets['icon_frame'].state = 'normal_nohighlight'; // disable onhover highlight on the icon
            d.widgets['name'].text_hjustify = d.widgets['name'].text_vjustify = 'center';
            d.widgets['name'].text_color = SPUI.make_colorv(d.data['widgets']['name']['text_color_category']);
            d.widgets['name'].font = SPUI.make_font(d.data['widgets']['name']['text_size_category'], d.data['widgets']['name']['text_size_category']+3, d.data['widgets']['name']['text_style']);
            d.widgets['name'].set_text_with_linebreaking_and_shrink_font_to_fit(skudata['ui_name']);
            d.user_data['icon_assets'] = [];
            if('icon' in skudata) {
                d.user_data['icon_assets'].push(skudata['icon']);
            } else {
                // get icons from child items

                // first pass - uncollected items
                var stack = [skudata];
                while(stack.length > 0) {
                    var sku = stack.pop();
                    if('icon' in sku) {
                        d.user_data['icon_assets'].push(sku['icon']);
                    } else if('skus' in sku) {
                        stack = stack.concat(sku['skus']);
                    } else if('item' in sku && ('icon' in gamedata['items'][sku['item']])) {
                        if('collected' in sku && read_predicate(sku['collected']).is_satisfied(player, null)) { continue; }
                        d.user_data['icon_assets'].push(gamedata['items'][sku['item']]['icon']);
                    }
                }

                // second pass - all items
                if(d.user_data['icon_assets'].length < 1) {
                    stack = [skudata];
                    while(stack.length > 0) {
                        var sku = stack.pop();
                        if('icon' in sku) {
                            d.user_data['icon_assets'].push(sku['icon']);
                        } else if('skus' in sku) {
                            stack = stack.concat(sku['skus']);
                        } else if('item' in sku && ('icon' in gamedata['items'][sku['item']])) {
                            d.user_data['icon_assets'].push(gamedata['items'][sku['item']]['icon']);
                        }
                    }
                    if(d.user_data['icon_assets'].length < 1) {
                        d.user_data['icon_assets'].push('inventory_unknown');
                    }
                }
            }

            d.widgets['price_icon'].show =
                d.widgets['price_display'].show = false;
            goog.array.forEach(['info','name','name_bg','bg_shine','price_bg','price_bg_shine'], function(wname) {
                d.widgets[wname].xy = vec_copy(d.data['widgets'][wname]['xy_category']);
                d.widgets[wname].wh = vec_copy(d.data['widgets'][wname]['dimensions_category']);
                if('gradient_color_category' in d.data['widgets'][wname]) {
                    d.widgets[wname].gradient_color = SPUI.make_colorv(d.data['widgets'][wname]['gradient_color_category']);
                }
            });
        }

        if(tip_item) {
            d.widgets['icon_frame'].onenter = (function (_item, _skudata) { return function(w) {
                var dialog = w.parent;
                if(dialog.user_data['context']) { return; }

                if(dialog.user_data['sound_start'] < client_time - 1) {
                    dialog.user_data['sound_start'] = client_time;
                    if('mouseover_effect' in _skudata) {
                        session.get_draw_world().fxworld.add_visual_effect_at_time([0,0], 0, [0,1,0], client_time, _skudata['mouseover_effect'], true, null);
                    } else {
                        var assetname = ('mouseover_sound' in _skudata ? _skudata['mouseover_sound'] : 'mouseover_button_sound');
                        GameArt.play_canned_sound(assetname);
                    }
                }

                //w.state = 'active';

                // note: parent the context tooltip to the
                // new_store_category dialog, not the SKU, so that it
                // appears in the top of the Z order

                invoke_inventory_context(dialog, w, 0, _item, false, {'parent_dialog': dialog.parent});

                // set transparent so that onleave is always called reliably
                if(dialog.user_data['context']) { dialog.user_data['context'].transparent_to_mouse = true; }
            }; })(tip_item, skudata);
            d.widgets['icon_frame'].onleave_cb = (function (_item) { return function(w) {
                var dialog = w.parent;
                //w.state = 'normal';
                if(dialog.user_data['context']) {
                    invoke_inventory_context(dialog, w, -1, null, false);
                }
            }; })(tip_item);
        }

        d.widgets['jewel'].user_data['count'] = 0;
        d.widgets['jewel'].ondraw = update_notification_jewel;

        // note: don't set d.ondraw, instead we are going to call this
        // manually from update_new_store_category(), because we want
        // to enable the predicate cache across all child SKU updates.
        update_new_store_sku(d);
    }

    if(default_sku_index >= 0) {
        // on Enter keypress, send click to default sku
        dialog.widgets['default_button'].onclick = (function (_index) { return function(w) {
            var d = w.parent.widgets['sku'+_index.toString()];
            if(d.widgets['bg'].state != 'disabled') {
                d.widgets['bg'].onclick(d.widgets['bg']);
            }
        }; })(default_sku_index);
    } else {
        dialog.widgets['default_button'].onclick = null;
    }

    dialog.ondraw = update_new_store_category;
    predicate_cache_off();
    return dialog;
}

// recalculate scroll limits and goal. incr +/- 1 to go left and right, 0 to just recalculate in place.
function new_store_category_scroll(dialog, incr) {
    var skulist = dialog.user_data['skulist'];

    // how much horizontal space do we need for ALL SKUs?
    var extent = skulist.length * dialog.data['widgets']['sku']['array_offset'][0] + dialog.data['widgets']['sku']['xy'][0] + 3;

    if(extent > dialog.widgets['sunken'].wh[0]) {
        // we have more SKUs than space
        dialog.user_data['scroll_limits'] = [0, Math.max(0, extent - dialog.widgets['sunken'].wh[0])];

        // correct the initial_scroll index to put that SKU in the center, not at the left edge
        if(dialog.user_data['initial_scroll'] !== null && !dialog.user_data['initial_scroll_exact']) {
            // add/subtract as necessary to center this SKU
            dialog.user_data['initial_scroll'] = dialog.user_data['initial_scroll'] - Math.floor((dialog.widgets['sunken'].wh[0]/dialog.data['widgets']['sku']['array_offset'][0])/2 - 0.5);
        }
    } else {
        // we have more space than SKUs - just center everything
        var left_edge = Math.floor((dialog.widgets['sunken'].wh[0] - extent)/2);
        dialog.user_data['scroll_limits'] = [-left_edge, -left_edge];
        dialog.user_data['initial_scroll'] = null; // no need to scroll anywhere
    }

    // note: this part only runs on the very first call after the dialog opens
    if(dialog.user_data['initial_scroll'] !== null) {
        var initial_scroll = dialog.user_data['initial_scroll'];
        dialog.user_data['initial_scroll'] = null;
        dialog.user_data['scrolled'] = true;
        // immediately snap scroll position
        dialog.user_data['scroll_pos'] = dialog.user_data['scroll_goal'] = clamp(initial_scroll * dialog.data['widgets']['sku']['array_offset'][0],
                                                                                 dialog.user_data['scroll_limits'][0], dialog.user_data['scroll_limits'][1]);
    }

    if(incr != 0) { // move left or right
        dialog.user_data['scroll_goal'] = dialog.user_data['scroll_goal']+dialog.data['widgets']['sku']['array_offset'][0]*incr;
        dialog.user_data['scrolled'] = true;
    }

    // ensure goal is in bounds
    dialog.user_data['scroll_goal'] = clamp(dialog.user_data['scroll_goal'], dialog.user_data['scroll_limits'][0], dialog.user_data['scroll_limits'][1]);

    // set button clickability
    dialog.widgets['scroll_left'].state = (dialog.user_data['scroll_goal'] <= dialog.user_data['scroll_limits'][0] ? 'disabled' : 'normal');
    dialog.widgets['scroll_right'].state = (dialog.user_data['scroll_goal'] >= dialog.user_data['scroll_limits'][1] ? 'disabled' : 'normal');
};

/** @param {SPUI.Dialog} dialog */
function update_new_store_category(dialog) {
    update_resource_bars(dialog, false, false, true);
    var skulist = dialog.user_data['skulist'];

    // first resize the dialog itself, then worry about scrolling calculations

    // how big can we be?
    var new_width = canvas_width - 2*dialog.data['margin'][0];
    new_width = clamp(new_width, dialog.data['dimensions'][0], dialog.data['max_dimensions'][0]);
    dialog.wh = [new_width, dialog.data['dimensions'][1]];
    dialog.on_resize(); // reset centering
    dialog.apply_layout(); // adjust miscellaneous widgets

    // perform scroll limit/goal calculations without moving left or right
    new_store_category_scroll(dialog, 0);

    if(!dialog.user_data['scrolled'] &&
       ((client_time - dialog.user_data['open_time']) < gamedata['store']['store_scroll_flash_time']) &&
       player.get_any_abtest_value('enable_store_scroll_flash', gamedata['store']['enable_store_scroll_flash'])) {
        if(dialog.widgets['scroll_right'].state != 'disabled') {
            dialog.widgets['scroll_right'].state = ((((client_time/gamedata['store']['store_scroll_flash_period']) % 1) >= 0.5) ? 'highlight' : 'normal');
        }
    }

    // adjust smooth scrolling position
    if(dialog.user_data['scroll_limits'][0] == dialog.user_data['scroll_limits'][1]) {
        // if window is wider than needed to show all SKUs, just snap to the centered position
        dialog.user_data['scroll_pos'] = dialog.user_data['scroll_limits'][0];
    } else if(dialog.user_data['scroll_pos'] != dialog.user_data['scroll_goal']) {
        // exponential movement
        var delta = dialog.user_data['scroll_goal'] - dialog.user_data['scroll_pos'];
        var sign = (delta > 0 ? 1 : -1);
        dialog.user_data['scroll_pos'] += sign * Math.floor(0.20 * Math.abs(delta) + 0.5);
    }

    dialog.widgets['scroll_left'].show = dialog.widgets['scroll_right'].show =
        (skulist.length * dialog.data['widgets']['sku']['array_offset'][0] >= dialog.widgets['sunken'].wh[0]);

    dialog.widgets['scroll_left_jewel'].show = dialog.widgets['scroll_right_jewel'].show =
        dialog.widgets['scroll_left'].show && player.get_any_abtest_value('enable_store_jewel', gamedata['store']['enable_store_jewel']);

    var left_jewels = 0, right_jewels = 0; // count number of jeweled SKUs to the left and right of the window

    // adjust child SKU dialogs

    predicate_cache_on();

    for(var i = 0; i < skulist.length; i++) {
        var w = dialog.widgets['sku'+i.toString()];
        var skudata = w.user_data['skudata'];

        if(!new_store_allow_sku(skudata)) { // a predicate changed, or something else made it want to disappear
            w.show = false;
            continue;
        }

        // left/right scrolling
        w.user_data['base_xy'][0] = i*dialog.data['widgets']['sku']['array_offset'][0] - dialog.user_data['scroll_pos'] + dialog.data['widgets']['sku']['xy'][0];
        w.user_data['base_xy'][1] = dialog.data['widgets']['sku']['xy'][1];

        // set clipping
        w.clip_to = [dialog.widgets['sunken'].xy[0], dialog.widgets['sunken'].xy[1],
                     dialog.widgets['sunken'].wh[0], dialog.widgets['sunken'].wh[1]];

        if(('jewel' in skudata) && read_predicate(skudata['jewel']).is_satisfied(player, null)) {
            if(w.user_data['base_xy'][0] + 0.66*w.wh[0] < 0) { left_jewels += 1; }
            if(w.user_data['base_xy'][0] + 0.33*w.wh[0] >= dialog.widgets['sunken'].xy[0] + dialog.widgets['sunken'].wh[0]) { right_jewels += 1; }
        }

        update_new_store_sku(w);
    }

    predicate_cache_off();

    dialog.widgets['scroll_left_jewel'].user_data['count'] = left_jewels;
    dialog.widgets['scroll_right_jewel'].user_data['count'] = right_jewels;
}

function update_new_store_sku(d) {
    var pending = (d.user_data['pending'] > client_time);
    var skudata = d.user_data['skudata'];
    var alpha = ('alpha' in d.user_data ? d.user_data['alpha'] : 1);
    var price = -1, shown_price = -1, sale_currency = Store.get_user_currency(), buyable = true; // buyable means "show hider if 'requires' predicate is false"
    var set_completed = false;
    var info_str = null, info_col = 'ok', info_small = false, info_high = false;
    var helper = null, child_catdata = null;
    var expire_time = -1;

    // initialize cooldown to hidden
    d.widgets['cooldown_label'].show = d.widgets['cooldown_time'].show = false;

    // reposition cooldown to avoid overlap with loot table attachment list
    d.widgets['cooldown_label'].xy = d.widgets['cooldown_label'].data['loot_table' in skudata ? 'xy_with_attachments' : 'xy'];
    d.widgets['cooldown_time'].xy = d.widgets['cooldown_time'].data['loot_table' in skudata ? 'xy_with_attachments' : 'xy'];
    d.widgets['cooldown_time'].wh = d.widgets['cooldown_time'].data['loot_table' in skudata ? 'dimensions_with_attachments' : 'dimensions'];
    d.widgets['cooldown_time'].text_hjustify = d.widgets['cooldown_time'].data['loot_table' in skudata ? 'text_hjustify_with_attachments' : 'text_hjustify'];

    var count = 0;
    if(player.get_any_abtest_value('enable_store_jewel', gamedata['store']['enable_store_jewel'])) {
        if(('jewel' in skudata) && read_predicate(skudata['jewel']).is_satisfied(player, null)) {
            count += 1;
        }
    }
    d.widgets['jewel'].user_data['count'] = count;

    // compute expiration time for all SKUs except for hierarchical categories
    if(!('name' in skudata)) {
        if('expire_time' in skudata) {
            expire_time = skudata['expire_time'];
        } else if('activation' in skudata && read_predicate(skudata['activation']).ui_expire_time(player) > 0) {
            expire_time = read_predicate(skudata['activation']).ui_expire_time(player);
        } else if('show_if' in skudata && read_predicate(skudata['show_if']).ui_expire_time(player) > 0) {
            expire_time = read_predicate(skudata['show_if']).ui_expire_time(player);
        } else {
            // look to parents for inherited expiration time
            var cat = null;
            var catlist = gamedata['store']['catalog'];
            var catpath = d.user_data['catpath'];
            for(var i = 0; i < catpath.length; i++) {
                cat = goog.array.find(catlist, function (entry) {
                    return (entry['name'] && entry['name'] === catpath[i] &&
                            (!('activation' in entry) || read_predicate(entry['activation']).is_satisfied(player,null)) &&
                            (!('start_time' in entry) || entry['start_time'] < player.get_absolute_time()) &&
                            (!('expire_time' in entry) || entry['expire_time'] >= player.get_absolute_time()));
                });
                if(cat) {
                    // figure out parent's expiration time
                    var etime = -1;
                    if('expire_time' in cat) {
                        etime = cat['expire_time'];
                    } else if('activation' in cat) {
                        etime = read_predicate(cat['activation']).ui_expire_time(player);
                    } else if('show_if' in cat) {
                        etime = read_predicate(cat['show_if']).ui_expire_time(player);
                    }
                    if(etime > 0) {
                        expire_time = (expire_time > 0 ? Math.min(expire_time, etime) : etime);
                    }
                } else {
                    break;
                }
                catlist = cat['skus'] || [];
            }
        }
    }

    if('spell' in skudata) {
        var spell = gamedata['spells'][skudata['spell']];
        var pred = (('requires' in spell) ? read_predicate(spell['requires']) : null);
        var tip_item = ('new_store_tip_item' in spell ? {'spec':spell['new_store_tip_item']} : null);
        var tip_item_spec = (tip_item ? ItemDisplay.get_inventory_item_spec(tip_item['spec']) : null);
        if('currency' in spell) { sale_currency = spell['currency']; }

        // note: adding the subtitles here causes too much clutter
        /*
        if(tip_item_spec) {
            var subtitle = ItemDisplay.get_inventory_item_ui_subtitle(tip_item_spec);
            if(subtitle) {
                info_str = subtitle;
                info_high = true; info_small = true;
            }
        }
        */

        price = Store.get_price(sale_currency, GameObject.VIRTUAL_ID, spell, null);
        if(price < 0) {
            // try to display a price even though spell is unavailable
            shown_price = Store.get_price(sale_currency, GameObject.VIRTUAL_ID, spell, null, true);
        } else {
            shown_price = price;
        }

        var formula = spell['price_formula'];
        // ability to purchase is a combination of new-style "requires" predicates
        // plus some ugly legacy code that checks specific price formulas

        if(pred && (price < 0) && !pred.is_satisfied(player, null)) {
            // show reason for unfulfilled predicate
            var req_text = pred.ui_describe(player);
            if(req_text) {
                info_col = 'error';
                info_str = req_text; // d.data['widgets']['info']['ui_name_unmet'].replace('%s', req_text);
                helper = get_requirements_help(pred, null);
            }
            info_high = info_small = false;
            if(formula.indexOf('resource_boost') == 0) {
                shown_price = -1; // do not show "FREE" for unpurchaseable resource boosts
            }
        } else if(formula === 'resource_boost' || formula === 'resource_boost_gamebucks' || formula === 'resource_boost_constant') {
            var resource = spell['resource'];
            var amount;
            if('give_amount' in spell) {
                amount = spell['give_amount'];
            } else if(spell['boost_amount'] < 1) {
                amount = Math.floor(spell['boost_amount'] * player.resource_state[resource][0]);
            } else {
                // full 100% boost
                amount = player.resource_state[resource][0] - player.resource_state[resource][1];
            }
            amount = Math.max(amount, 0);

            if(price >= 0) {
                info_col = 'ok';
                info_str = pretty_print_number(amount) + ' ' + (gamedata['resources'][resource]['ui_name']);
                info_high = info_small = false;
            } else {
                info_col = 'error';
                info_str = d.data['widgets']['info']['ui_name_not_enough_room'];
                if(amount <= 0) {
                    shown_price = -1; // don't show "FREE" for a full boost when resources are already full
                }
                info_high = info_small = false;
                var increment = {};
                increment[resource] = Math.max(1,amount);
                helper = get_requirements_help('resources', increment);
            }

        } else if(formula.indexOf('grow_base_perimeter') === 0) {
            info_col = (price >= 0 ? 'ok' : 'error');
            var to_level = parseInt(formula[formula.length-1],10);
            if(session.viewing_base.base_size >= to_level) {
                info_str = d.data['widgets']['info']['ui_name_already_upgraded'];
                info_high = info_small = false;
            } else {
                info_high = info_small = (price >= 0);
            }
        } else if(formula.indexOf('barrier_upgrade') === 0) {
            info_col = (price >= 0 ? 'ok' : 'error');
            if(price < 0) {
                info_str = d.data['widgets']['info']['ui_name_already_upgraded'];
            }
            info_high = info_small = false;
        }

        if(('cooldown_name' in spell) && (!info_str || info_high)) {
            expire_time = -1; // override computed expiration time with the cooldown display
            var cd_name = spell['cooldown_name'];
            var togo = player.cooldown_togo(cd_name);

            d.widgets['cooldown_label'].show = d.widgets['cooldown_time'].show = true;
            d.widgets['cooldown_label'].str = d.data['widgets']['cooldown_label']['ui_name_'+(togo>0 ? (spell['price'] === 0 ? 'available' : 'rebuy') : 'cd')];

            if(togo > 0) {
                d.widgets['cooldown_time'].str = pretty_print_time(togo);
            } else if('cooldown_origin' in spell) {
                d.widgets['cooldown_label'].str = d.data['widgets']['cooldown_label']['ui_name_expires'];
                d.widgets['cooldown_time'].str = pretty_print_time(spell['cooldown_interval'] - (server_time - spell['cooldown_origin']) % spell['cooldown_interval']);
            } else {
                d.widgets['cooldown_time'].str = pretty_print_time(spell['cooldown']);
                d.widgets['cooldown_time'].text_color = new SPUI.Color(1,0.7,1,1);
            }
            var col = d.data['widgets']['cooldown_time']['text_color_'+(togo > 0 ? 'rebuy':'cd')];
            d.widgets['cooldown_time'].text_color = new SPUI.Color(col[0], col[1], col[2], col[3]);
        }

    } else if('item' in skudata || 'loot_table' in skudata) {
        var pred = (('requires' in skudata) ? read_predicate(skudata['requires']) : null);
        var stack = ('item' in skudata && 'stack' in skudata ? skudata['stack'] : 1);
        var arg = {'catpath': d.user_data['catpath'], 'ui_index': d.user_data['ui_index'], 'skudata':skudata};
        if('price_currency' in skudata) { sale_currency = skudata['price_currency']; }

        if('price' in skudata) {
            price = Store.get_price(sale_currency, GameObject.VIRTUAL_ID, gamedata['spells']["BUY_ITEM"], arg);
            if(price < 0) {
                // try to display a price even though item is unavailable
                shown_price = Store.get_price(sale_currency, GameObject.VIRTUAL_ID, gamedata['spells']["BUY_ITEM"], arg, true);
            } else {
                shown_price = price;
            }
        } else if('ui_availability' in skudata) {
            buyable = false;
            d.widgets['availability'].show = true;
            d.widgets['price_icon'].show = false;
            d.widgets['availability'].set_text_with_linebreaking(skudata['ui_availability']);
        }

        if(pred && (price < 0) && !pred.is_satisfied(player, null)) {
            var req_descr = pred.ui_describe_detail(player);
            if(req_descr) {
                buyable = true; // DO show hider
                info_small = true;
                info_col = 'error';
                info_str = (('ui_name' in skudata['requires'] || ('ui_name_literal' in skudata['requires']) || req_descr.already_obtained || ('ui_cooldown_name' in skudata['requires'])) ? req_descr.descr : d.data['widgets']['info']['ui_name_unmet'].replace('%s', req_descr.descr));
                helper = get_requirements_help(pred, null);
            }
        }

        if(!info_str) {
            var ls = [];
            var subtitle = null;
            if('ui_subtitle' in skudata) {
                subtitle = skudata['ui_subtitle'];
            } else if('item' in skudata) {
                subtitle = ItemDisplay.get_inventory_item_ui_subtitle(ItemDisplay.get_inventory_item_spec(skudata['item']))
            }
            if(subtitle) { ls.push([subtitle,'ok']); }

            // blink with item set membership
            if('item' in skudata) {
                var spec = ItemDisplay.get_inventory_item_spec(skudata['item']);
                if(spec['item_set']) {
                    var set_spec = gamedata['item_sets'][spec['item_set']];
                    var s = d.data['widgets']['info']['ui_name_item_set'].replace('%s', set_spec['ui_name']).replace('%n', (1+set_spec['members'].indexOf(spec['name'])).toString()).replace('%total', set_spec['members'].length.toString());
                    ls.push([s,'item_set']);
                }
            }

            if(ls.length > 0) {
                var period = d.data['widgets']['info']['blink_period'];
                var index = (Math.floor(((client_time - d.user_data['anim_start'] + period/2)/period) % ls.length) + ls.length) % ls.length;
                info_str = ls[index][0];
                info_col = ls[index][1];
                info_high = true;
                info_small = true;
            }
        }

        // show loot table contents and expiration time
        if('loot_table' in skudata) {
            var item_result = session.get_loot_items(player, gamedata['loot_tables_client'][skudata['loot_table']]['loot']);
            if(item_result.predicate) {
                var etime = read_predicate(item_result.predicate).ui_expire_time(player);
                if(etime > 0) {
                    expire_time = (expire_time > 0 ? Math.min(expire_time, etime) : etime);
                }
            }
            // additional restriction on expiration time from SKU's show_if predicate - should be checked for item SKUs too,
            // but needs testing to make sure it doesn't break anything in special event catalogs
            if('show_if' in skudata) {
                var etime = read_predicate(skudata['show_if']).ui_expire_time(player);
                if(etime > 0) {
                    expire_time = (expire_time > 0 ? Math.min(expire_time, etime) : etime);
                }
            }
            var collapsed_item_list = collapse_item_list(item_result.item_list);
            update_buy_gamebucks_or_store_sku_attachments(d, collapsed_item_list, true);
        }

    } else if('name' in skudata) {
        // hierarchical category
        child_catdata = skudata;
        price = shown_price = 0;
        if('ui_info' in skudata) {
            info_col = 'category';
            info_small = true;
            info_str = skudata['ui_info'];
        }

        // blink icon graphic
        var ls = d.user_data['icon_assets'];
        var period = d.data['widgets']['icon']['blink_period'];
        var index = (Math.floor(((client_time - d.user_data['anim_start'] + period/2)/period) % ls.length) + ls.length) % ls.length;
        d.widgets['icon'].asset = ls[index];

        // compute number collected out of all children underneath here
        var set_n = 0, set_total = 0;
        var stack = [skudata];
        while(stack.length > 0) {
            var sku = stack.pop();
            if(new_store_allow_sku(sku)) { // skip SKUs that are not currently shown in store
                if('skus' in sku) { // folder
                    stack = stack.concat(sku['skus']);
                } else if('collected' in sku) { // single SKU
                    set_total += 1;
                    if(read_predicate(sku['collected']).is_satisfied(player, null)) { set_n += 1; }
                }
            }
        }

        if(set_total > 0) {
            d.widgets['category_completion'].show = true;
            d.widgets['category_completion'].str = d.data['widgets']['category_completion']['ui_name'].replace('%n', set_n.toString()).replace('%total', set_total.toString());
            set_completed = (set_n >= set_total);
        }

    } else {
        throw Error('unhandled skudata '+JSON.stringify(skudata));
    }

    if(expire_time > 0 && !('ui_availability' in skudata)) {
        if(info_str) { info_high = true; }
        d.widgets['cooldown_label'].show = d.widgets['cooldown_time'].show = true;
        // note: the ui_availability case here is probably unused - it causes GUI overlap with the timer
        d.widgets['cooldown_label'].str = d.data['widgets']['cooldown_label'][('ui_availability' in skudata ? 'ui_name_availability_ends' : 'ui_name_expires')];
        d.widgets['cooldown_time'].str = pretty_print_time(expire_time - player.get_absolute_time());
        var col = d.data['widgets']['cooldown_time']['text_color_expires'];
        d.widgets['cooldown_time'].text_color = new SPUI.Color(col[0], col[1], col[2], col[3]);
    }

    d.widgets['info'].show = !!info_str;
    if(info_str) {
        var sz = d.data['widgets']['info']['text_size'], st = d.data['widgets']['info']['text_style'];
        if(info_small) {
            sz = d.data['widgets']['info']['text_size_small'];
            st = d.data['widgets']['info']['text_style_small'];
        }
        d.widgets['info'].font = SPUI.make_font(sz, sz+3, st);
        d.widgets['info'].xy = d.data['widgets']['info']['xy' + (info_high ? '_high' : (child_catdata ? '_category' : ''))];
        d.widgets['info'].wh = d.data['widgets']['info']['dimensions' + (info_high ? '_high' : (child_catdata ? '_category' : ''))];
        d.widgets['info'].set_text_with_linebreaking(info_str);
    }
    if(info_col) {
        var col = d.data['widgets']['info']['text_color_'+info_col];
            d.widgets['info'].text_color = new SPUI.Color(col[0], col[1], col[2], col[3]);
    }

    d.widgets['hider'].show = (price < 0 && buyable) || pending;

    d.widgets['loading_spinner'].show = pending;
    var hi = (d.mouse_enter_time > 0) && (!d.widgets['hider'].show) && !pending;
    d.xy[0] = d.user_data['base_xy'][0];
    d.xy[1] = d.user_data['base_xy'][1] - (hi && !d.widgets['bg'].pushed ? 1 : 0);
    d.widgets['icon_glow'].xy = vec_copy(d.data['widgets']['icon_glow']['xy'+ (d.widgets['bg'].pushed ? '_pushed' : '')]);
    d.widgets['icon_glow'].wh = vec_copy(d.data['widgets']['icon_glow']['dimensions'+ (d.widgets['bg'].pushed ? '_pushed' : '')]);
    d.widgets['icon_glow'].alpha = (hi ? (d.widgets['bg'].pushed ? 0.66 : 0.2) : 0);
    d.widgets['icon_glow'].asset = d.data['widgets']['icon_glow']['asset'+(d.widgets['bg'].pushed ? '_pushed': '')];
    d.widgets['bg'].alpha = alpha * d.data['widgets']['bg']['alpha'];
    d.widgets['bg_shine'].alpha = alpha * (hi ? (d.widgets['bg'].pushed ? 1 : 0.66 ) : 0.5) * (set_completed ? 0.5 : 1);
    d.widgets['price_bg_shine'].alpha = 0.8*  (hi ? (d.widgets['bg'].pushed ? 1 : 0.66 ) : 0.5);

    // PRICE
    if(child_catdata || ('ui_availability' in skudata)) {
        d.widgets['price_icon'].show = d.widgets['price_display'].show = false;
    } else {
        if(sale_currency == 'gamebucks') {
            d.widgets['price_icon'].asset = player.get_any_abtest_value('gamebucks_resource_icon', gamedata['store']['gamebucks_resource_icon']);
        } else if(sale_currency == 'fbcredits') {
            d.widgets['price_icon'].asset = 'resource_icon_fbcredits';
        } else if(sale_currency.indexOf('item:') === 0) {
            d.widgets['price_icon'].asset = ItemDisplay.get_inventory_item_spec(sale_currency.split(':')[1])['store_icon'];
        } else if(sale_currency == 'score:trophies_pvp') {
            d.widgets['price_icon'].asset = 'trophy_21x21';
            d.widgets['price_icon'].state = 'pvp';
        } else if(sale_currency in gamedata['resources']) {
            d.widgets['price_icon'].asset = gamedata['resources'][sale_currency]['icon_small'];
        } else {
            throw Error('unknown sale_currency '+sale_currency);
        }

        if(sale_currency == 'gamebucks' || sale_currency == 'fbcredits') {
            d.widgets['price_display'].str = Store.display_user_currency_price(shown_price);
            d.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(shown_price);
            d.user_data['ui_price_str'] = Store.display_user_currency_amount(shown_price, 'full');
            d.user_data['should_confirm_purchase'] = (price >= 0) && (sale_currency == 'fbcredits' || (player.resource_state['gamebucks'] >= shown_price));
        } else if(sale_currency.indexOf('item:') === 0) {
            d.widgets['price_display'].str = (shown_price > 0 ? pretty_print_number(shown_price) : '-');
            var currency_item_spec = ItemDisplay.get_inventory_item_spec(sale_currency.split(':')[1]);
            d.widgets['price_display'].tooltip.str = (shown_price > 0 ? gamedata['strings']['store']['buy_for'].replace('%s',
                                                                                                                        ItemDisplay.get_inventory_item_stack_prefix(currency_item_spec, shown_price)+ItemDisplay.get_inventory_item_ui_name(currency_item_spec)) : null);
            d.user_data['ui_price_str'] = (shown_price > 0 ? ItemDisplay.get_inventory_item_stack_prefix(currency_item_spec, shown_price)+ItemDisplay.get_inventory_item_ui_name(currency_item_spec) : '-');
            d.user_data['should_confirm_purchase'] = (price >= 0) && (player.inventory_item_quantity(currency_item_spec['name']) >= price);

        } else if(sale_currency == 'score:trophies_pvp') {
            var stat_name = sale_currency.split(':')[1];
            var has_qty = 0;
            var player_data = PlayerCache.query_sync(session.user_id);
            if(player_data && (stat_name in player_data)) {
                has_qty = player_data[stat_name];
            }
            var ui_name = gamedata['strings']['leaderboard']['categories'][stat_name]['title'];
            d.widgets['price_display'].str = (shown_price > 0 ? pretty_print_number(shown_price) : '-');
            d.widgets['price_display'].tooltip.str = (shown_price > 0 ? gamedata['strings']['store']['buy_for'].replace('%s', pretty_print_number(shown_price) + ' ' + ui_name) : null);
            d.user_data['ui_price_str'] = (shown_price > 0 ? pretty_print_number(shown_price) + ' ' + ui_name : '-');
            d.user_data['should_confirm_purchase'] = (price >= 0) && (has_qty >= price);
        } else if(sale_currency in gamedata['resources']) {
            d.widgets['price_display'].str = (shown_price > 0 ? pretty_print_number(shown_price) : '-');
            d.widgets['price_display'].tooltip.str = (shown_price > 0 ? gamedata['strings']['store']['buy_for'].replace('%s', pretty_print_number(shown_price) + ' ' +gamedata['resources'][sale_currency]['ui_name']) : null);
            d.user_data['ui_price_str'] = (shown_price > 0 ? pretty_print_number(shown_price) + ' ' +gamedata['resources'][sale_currency]['ui_name'] : '-');
            d.user_data['should_confirm_purchase'] = (price >= 0) && (player.resource_state[sale_currency][1] >= price);
        }
    }

    if(child_catdata) {
        d.widgets['bg'].state = 'normal';
        d.widgets['bg'].onclick = function(w) {
            var d = w.parent;
            var child_catdata = d.user_data['skudata'];
            // this saves the scroll_goal so that hitting the "Back" button brings you to the exact spot you were before you clicked this
            var new_parent_catdata = (d.parent.user_data['parent_catdata'] || []).concat([{cat:d.parent.user_data['catdata'], pos:d.parent.user_data['scroll_goal']}]);
            close_parent_dialog(w.parent);
            // don't specify anything to scroll toward, just leave it at the default
            invoke_new_store_category(child_catdata, new_parent_catdata);
        };
    } else if(price >= 0 && !pending) {
        d.widgets['bg'].state = 'normal';
        d.widgets['bg'].onclick = function(w) {
            var d = w.parent;
            var skudata = d.user_data['skudata'];
            var cleanup_cb = (function (_d, _w) { return function() {
                _d.user_data['pending'] = client_time + 1.5;
                var skudata = _d.user_data['skudata'];
                var spell = ('spell' in skudata ? gamedata['spells'][skudata['spell']] : null);

                if(spell && spell['close_store_on_purchase']) {
                    change_selection_ui(null);
                    return;
                }

                _d.widgets['glowfx'].show = true;
                _d.widgets['glowfx'].reset_fx();

                if(!player.get_any_abtest_value('modal_looting', gamedata['modal_looting'])) {
                    var floating_msg = (spell ? ('ui_new_store_activated' in spell ? spell['ui_new_store_activated'] : gamedata['strings']['combat_messages']['purchased']) : gamedata['strings']['combat_messages']['sent_to_messages']);
                    if(floating_msg.length > 0) {
                        ItemDisplay.add_inventory_item_effect(session.get_draw_world().fxworld, _d.widgets['icon'], floating_msg, [1,1,0.3]);
                    }
                }
            }; })(d, w);

            var order_spell = ('spell' in skudata ? skudata['spell'] : "BUY_ITEM");
            var order_spellarg = ('spell' in skudata ? null : {'catpath': d.user_data['catpath'], 'ui_index': d.user_data['ui_index'], 'skudata':skudata});
            // note: there is no 0-credit order path for FB Credits or tokens, so make a gamebucks order for free items
            var order_currency = (price == 0 ? 'gamebucks' : sale_currency);

            // function to place the order, with a parameter for a spellarg that might come from further pre-order GUI
            var order_cb = (function (_d, _order_currency, _order_spell, _order_spellarg, _cleanup_cb) { return function(override_spellarg) {
                var placed = Store.place_order(_order_currency, GameObject.VIRTUAL_ID, _order_spell,
                                               (override_spellarg ? override_spellarg : _order_spellarg),
                                               _cleanup_cb, {'no_clear':true});
                if(placed) {
                    invoke_ui_locker();
                    _d.user_data['pending'] = client_time + 6000;
                    var spell = gamedata['spells'][_order_spell];
                    if(('cooldown_name' in spell) && ((!('activation' in spell)) || spell['activation'] == 'instant')) {
                        // preemptively trigger the cooldown on client side to prevent duplicate orders
                        // the actual real cooldown info comes from the COOLDOWNS_UPDATE that the server will send when it receives the order
                        // but we trigger it here on client-side to make sure the UI is blocked while the order is in-flight
                        player.cooldown_client_trigger(spell['cooldown_name'], spell['cooldown']);
                    }
                }
                return placed;

            }; })(d, order_currency, order_spell, order_spellarg, cleanup_cb);


            // fire order immediately, or need further GUI?
            var spell = gamedata['spells'][order_spell];
            if(((!('activation' in spell)) || spell['activation'] == 'instant')) {
                if(d.user_data['should_confirm_purchase']) {
                    var ui_name = d.widgets['name'].str.replace(/\n/g, ' ');
                    confirm_purchase(goog.partial(order_cb, null), ui_name, d.user_data['ui_price_str'],
                                     eval_cond_or_literal(skudata['ui_purchase_confirm'] || spell['ui_purchase_confirm'] || null, player, null));
                } else {
                    order_cb(null);
                }
                return;
            }

            if(order_spell == "CHANGE_REGION" || order_spell.indexOf("CHANGE_REGION_INSTANTLY")==0) {
                change_selection_ui(null); // don't want to do this, but the tooltips are unbearable
                invoke_change_region_dialog(order_cb, order_spell);
            } else if(order_spell == "CHANGE_ALIAS") {
                invoke_change_alias_dialog(order_cb, order_spell);
            } else {
                throw Error('unhandled order_spell '+order_spell.toString());
            }

        };
    } else if(helper) {
        d.widgets['bg'].state = 'disabled_clickable';
        d.widgets['bg'].onclick = helper;
    } else {
        d.widgets['bg'].state = 'disabled';
    }
}

/** @param {function()} action_cb
    @param {string} ui_item_name
    @param {string} ui_price
    @param {string|null=} ui_text_override */
function confirm_purchase(action_cb, ui_item_name, ui_price, ui_text_override) {
    if(!player.get_any_abtest_value('store_purchase_confirm', eval_cond_or_literal(gamedata['store']['purchase_confirm'] || false, player, null))) {
        action_cb();
        return;
    }
    invoke_purchase_confirm_dialog(action_cb, ui_item_name, ui_price, ui_text_override);
}

/** @param {function()} action_cb
    @param {string} ui_item_name
    @param {string} ui_price
    @param {string|null=} ui_text_override */
function invoke_purchase_confirm_dialog(action_cb, ui_item_name, ui_price, ui_text_override) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['purchase_confirm_dialog']);
    dialog.user_data['dialog'] = 'purchase_confirm_dialog';
    dialog.user_data['action_cb'] = action_cb;

    dialog.modal = true;
    install_child_dialog(dialog);
    dialog.auto_center();

    dialog.widgets['cancel_button'].onclick = close_parent_dialog;

    var ui_descr = ui_text_override || dialog.data['widgets']['description']['ui_name'];
    dialog.widgets['description'].set_text_with_linebreaking(ui_descr.replace('%thing',ui_item_name).replace('%price', ui_price));

//    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
//    dialog.widgets['price_display'].state = Store.get_user_currency();
//    dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
//    dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);
//    dialog.widgets['price_display'].onclick =
    dialog.widgets['ok_button'].onclick = function(w) {
        var cb = w.parent.user_data['action_cb'];
        close_parent_dialog(w);
        cb();
    };

    return dialog;
}

/** @param {string=} purpose
    @param {string=} path */
function invoke_store(purpose, path) {
    // purpose: null, or (a resource name like 'iron'), 'special_items', 'barriers', 'defenses', 'exact_path'
    // path (required when purpose='exact_path', otherwise null): a string specifying the SKU or category to scroll to, in the form of a /-delimited hierarchical path
    // examples:
    // "event_prizes/blueprints/t90_blueprint" (opens BLUEPRINTS category and scrolls to highlight t90_blueprint)
    // "event_prizes/blueprints" (opens EVENT PRIZES category and scrolls to highlight blueprints folder)
    // "event_prizes/blueprints/" (opens BLUEPRINTS category)

    var store = null;

    var catalog = gamedata['store']['catalog'];
    if(purpose in gamedata['resources']) {
        var i;
        for(i = 0; i < catalog.length; i++) { if(catalog[i]['name'] == 'resources') { break; } }
        var catdata = catalog[i];
        store = invoke_new_store_category(catdata);
        var skulist = store.user_data['skulist'];
        for(i = 0; i < skulist.length; i++) {
            var skudata = skulist[i];
            if('spell' in skudata) {
                var spell = gamedata['spells'][skudata['spell']];
                if('resource' in spell && spell['resource'] == purpose) {
                    break;
                }
            }
        }
        if(i < skulist.length) {
            store.user_data['initial_scroll'] = i;
        }
    } else if(purpose == 'barriers' || purpose == 'special_items' || purpose == 'specials' || purpose == 'defenses') {
        var i;
        if(purpose == 'barriers' || purpose == 'special_items') { purpose = 'defenses'; }
        for(i = 0; i < catalog.length; i++) { if(catalog[i]['name'] == purpose) { break; } }
        if(i < catalog.length) {
            var catdata = catalog[i];
            store = invoke_new_store_category(catdata);
        } else {
            console.log("invoke_store(): unhandled purpose "+purpose);
            store = invoke_new_store_dialog();
        }
    } else if(purpose == 'exact_path') {
        var split_path = (path.length > 1 ? path.split('/') : []);
        var parent_catdata = []; // build list of parent nodes as we drill down
        var catdata = {'skus': catalog}; // begin at toplevel
        for(var i = 0; i < split_path.length; i++) {
            var cur = split_path[i];
            if(i >= split_path.length-1) { // final SKU or category
                store = invoke_new_store_category(catdata, parent_catdata.slice(1,parent_catdata.length), cur);
                break;
            } else {
                // drill down
                if(!('skus' in catdata)) { break; }
                parent_catdata.push({cat:catdata, sku_name:cur});
                catdata = goog.array.find(catdata['skus'], function(entry) {
                    return entry['name'] == cur;
                });
                if(!catdata) { break; }
            }
        }
        if(!store) {
            throw Error('bad SKU path: "'+path+'"');
        }
    } else {
        store = invoke_new_store_dialog();
    }

    return store;
}

var last_build_dialog_category = 'resources';

/** @param {string=} newcategory */
function invoke_build_dialog(newcategory) {
    //metric_event('4020_open_menu', {'menu_name':'build_dialog'});

    change_selection(player.virtual_units["BUILDMENU"]);

    var dialog_data = gamedata['dialogs']['build_dialog'];

    // instantiate the dialog
    var dialog = new SPUI.Dialog(dialog_data);

    // make the dialog modal and add it to the "desktop"
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'build_dialog';

    dialog.widgets['close_button'].onclick = function() {
        if(player.tutorial_state != "COMPLETE") { return; }
        change_selection(null);
    };
    dialog.widgets['inert_button'].show = !!player.is_cheater;
    dialog.widgets['dev_title'].show = player.is_cheater;

    goog.array.forEach(['inert', 'resources', 'production', 'defense'], function(cat) {
        dialog.widgets[cat+'_button'].onclick = (function (_cat) { return function(w) { build_dialog_change_category(w.parent, _cat); }; })(cat);
        dialog.widgets[cat+'_button_jewel'].ondraw = update_notification_jewel;
    });

    var category;
    if(player.tutorial_state === 'choose_defensive_cannon') {
        category = 'defense';
    } else if(newcategory) {
        category = newcategory;
    } else {
        var preselect = null;
        if('default_build_dialog_category' in gamedata['client']) {
            preselect = eval_cond_or_literal(gamedata['client']['default_build_dialog_category'], player, null);
        }
        category = preselect || last_build_dialog_category;
    }
    build_dialog_change_category(dialog, category);

    dialog.widgets['scroll_left'].onclick = function(w) { dialog.user_data['scrolled'] = true; build_dialog_scroll(w.parent, w.parent.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function(w) { dialog.user_data['scrolled'] = true; build_dialog_scroll(w.parent, w.parent.user_data['page']+1); };
    dialog.widgets['scroll_left_jewel'].ondraw =
        dialog.widgets['scroll_right_jewel'].ondraw = update_notification_jewel;

    if(player.tutorial_state === 'open_buildings_dialog') {
        advance_tutorial();
        dialog.widgets['close_button'].onclick = null; // don't let player close the dialog!
    }
    return dialog;
}

// return a dictionary of "able to build additional buildings of this type" jewels by build_category and specname
// e.g. {"defense": {"turret": 3, // can build 3 more turrets
//                   "barrier": 1, // and one more barrier
//                   "ALL": 4, "ALL_unique": 2}, // for convenience
//       "ALL": 4, "ALL_unique": 2
//      }
function get_building_jewels() {
    var ret = {'ALL':0, 'ALL_unique':0};
    if(!read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null)) { return ret; } // tutorial not complete
    if(!player.get_any_abtest_value('build_dialog_jewels', gamedata['client']['build_dialog_jewels'])) { return ret; } // disabled by A/B test

    for(var name in gamedata['buildings']) {
        var spec = gamedata['buildings'][name];
        var category = spec['build_category'];
        if(spec['developer_only'] || spec['ui_priority'] < 0) { continue; }
        if(spec['quarry_only'] && session.viewing_base.base_type != 'quarry') { continue; }
        if(session.viewing_base.base_type == 'quarry' && !spec['quarry_buildable']) { continue; }

        var pred_ok = true;
        goog.array.forEach(['show_if', 'activation', 'requires'], function(pred) {
            if((pred in spec) && !read_predicate(get_leveled_quantity(spec[pred],1)).is_satisfied(player, null)) {
                pred_ok = false;
            }
        });
        if(!pred_ok) { continue; }

        var current = count_objects_by_type(spec['name']);
        var cc_level = player.get_townhall_level();
        if(!('limit' in spec)) { continue; }
        var limit = get_leveled_quantity(spec['limit'], Math.max(1, cc_level));
        if(current >= limit) { continue; }

        if('limit_requires' in spec) {
            limit = Math.min(limit, spec['limit_requires'].length);
            var req_limit = current;
            for(; req_limit < spec['limit_requires'].length; req_limit++) {
                if(!read_predicate(spec['limit_requires'][req_limit]).is_satisfied(player, null)) { break; }
            }
            limit = Math.min(limit, req_limit);
        }
        if(limit - current > 0) {
            if(!(category in ret)) {
                ret[category] = {'ALL': 0};
            }
            ret[category][spec['name']] = limit - current;
            ret[category]['ALL'] += limit - current;
            ret[category]['ALL_unique'] += 1;
            ret['ALL'] += limit - current;
            ret['ALL_unique'] += 1;
        }
    }
    return ret;
}

function build_dialog_change_category(dialog, category) {
    dialog.user_data['category'] = category;
    dialog.user_data['scrolled'] = false;
    dialog.user_data['open_time'] = client_time;
    dialog.user_data['speclist'] = [];

    if(category === 'defense' && player.tutorial_state === 'go_to_defense_tab') {
        advance_tutorial();
    }

    last_build_dialog_category = category;

    var building_jewels = get_building_jewels();
    goog.array.forEach(['inert', 'resources', 'production', 'defense'], function(cat) {
        dialog.widgets[cat+'_button'].state = (category === cat ? 'active' : 'normal');
        dialog.widgets[cat+'_button_jewel'].user_data['count'] = ((cat in building_jewels) ? building_jewels[cat]['ALL'] : 0);
    });


    if(player.tutorial_state === 'choose_defensive_cannon') {
        dialog.widgets['resources_button'].state =
            dialog.widgets['production_button'].state = 'disabled';
    }

    // only sort if at least one item has ui_priority (otherwise leave in JSON order)
    var use_priority_sort = false;

    if(category === 'inert') {
        for(var name in gamedata['inert']) {
            var spec = gamedata['inert'][name];
            if(('base_climates' in spec) && session.viewing_base.base_climate &&
               (!goog.array.contains(spec['base_climates'], session.viewing_base.base_climate))) {
                // inappropriate climate
                continue;
            }
            dialog.user_data['speclist'].push(name);
            if('ui_priority' in spec) { use_priority_sort = true; }
        }
    } else {
        for(var name in gamedata['buildings']) {
            var spec = gamedata['buildings'][name];
            if(spec['build_category'] != category) {
                continue;
            }
            if((spec['developer_only'] || spec['ui_priority'] < 0) && (spin_secure_mode || !player.is_cheater)) {
                continue;
            }
            if(spec['quarry_only'] && session.viewing_base.base_type != 'quarry') { continue; }
            if(session.viewing_base.base_type == 'quarry' && !spec['quarry_buildable']) { continue; }

            if('show_if' in spec && !read_predicate(spec['show_if']).is_satisfied(player, null)) { continue; }
            if('activation' in spec && !read_predicate(spec['activation']).is_satisfied(player, null)) { continue; }
            dialog.user_data['speclist'].push(name);
            if('ui_priority' in spec) { use_priority_sort = true; }
        }
    }
    if(use_priority_sort) {
        dialog.user_data['speclist'].sort(function(a, b) {
            // first sort by ui_priority high to low
            var ui_priority_a = gamedata[(a in gamedata['buildings'] ? 'buildings' : 'inert')][a]['ui_priority'] || 0;
            var ui_priority_b = gamedata[(b in gamedata['buildings'] ? 'buildings' : 'inert')][b]['ui_priority'] || 0;
            if(ui_priority_a < ui_priority_b) {
                return 1;
            } else if(ui_priority_a > ui_priority_b) {
                return -1;
            }
            return 0;
        });
    }
    build_dialog_scroll(dialog, 0);
}

function build_dialog_scroll(dialog, page) {
    // fill in grid of building types
    var grid_x = 0, grid_y = 0;
    // list of widget [specname,x,y] coords - for usage by TUTORIAL_ARROW consequents and get_requirements_help
    dialog.user_data['slots_this_page'] = [];

    var building_jewels = get_building_jewels();

    var chapter_specs = (dialog.user_data['speclist'] ? dialog.user_data['speclist'].length : 0);
    var specs_per_page = dialog.data['widgets']['grid']['array'][0]*dialog.data['widgets']['grid']['array'][1];
    var chapter_pages = Math.floor((chapter_specs+specs_per_page-1)/specs_per_page);
    dialog.user_data['page'] = page = (chapter_specs === 0 ? 0 : clamp(page, 0, chapter_pages-1));

    // this is the function that actually starts the build command
    var build_closure = function(kind, bname) {
        return function() {
            var spec = gamedata[kind][bname];
            var build_time = get_leveled_quantity(spec['build_time'], 1);
            // if foreman is busy, prompt player to add foreman or speed up current operation
            if(player.foreman_is_busy() && (build_time > 0 || !gamedata['foreman_ignore_zero_time_building'])) {
                if(gamedata['enable_multiple_foremen'] && player.tutorial_state == "COMPLETE") {
                    var helper = get_requirements_help('foreman', null);
                    if(helper) {
                        helper();
                        return;
                    }
                }
                var obj = player.foreman_get_tasks()[0];
                change_selection(obj);
                invoke_speedup_dialog('busy');
                return;
            }

            // prime targeted "build" spell
            selection.spellname = "BUILD";
            selection.spellkind = bname;
            // add spell target graphics
            change_selection_ui_under(new BuildUICursor(null, spec));
            if(player.tutorial_state === 'choose_defensive_cannon' && bname === gamedata['tutorial'][player.tutorial_state]['target']) {
                advance_tutorial();
            }

            // try to pre-locate the building
            if(player.tutorial_state == 'place_defensive_cannon') {
                // this should probably be run no matter what
                //var loc = gamedata['tutorial'][player.tutorial_state]['location'];
                var loc = screen_to_ortho([mouse_state.last_raw_x, mouse_state.last_raw_y]);
                var xy = ortho_to_screen(loc);
                mouse_state.last_x = xy[0]; mouse_state.last_y = xy[1];

            } else if(player.tutorial_state == "COMPLETE" && (!player.quest_tracked || !player.quest_tracked['tips'])) {
                var loc = find_valid_building_location(session.viewing_base.midcell(), bname);
                if(loc) {
                    // scroll instantly over there
                    view_pos = ortho_to_playfield_vector(vec_sub(loc, vec_scale(0.5,session.viewing_base.ncells())));
                    // fake a mouse position update right on the build location
                    var xy = ortho_to_screen(loc);
                    mouse_state.last_x = xy[0]; mouse_state.last_y = xy[1];
                }
            }
        };
    };

    if(chapter_pages > 0) {
        var first_spec_on_page = page * specs_per_page;
        var last_spec_on_page = Math.max(0, Math.min((page+1)*specs_per_page-1, chapter_specs-1));
        for(var i = first_spec_on_page; i <= last_spec_on_page; i++) {
            var name = dialog.user_data['speclist'][i];
            var widget_name = grid_x.toString() + ',' + grid_y.toString();

            dialog.user_data['slots_this_page'].push([name,grid_x,grid_y]);

            if(name in gamedata['inert']) {
                var spec = gamedata['inert'][name];
                dialog.widgets['grid_label'+widget_name].show = true;
                dialog.widgets['grid_label'+widget_name].str = name;
                dialog.widgets['grid_status'+widget_name].show = false;
                dialog.widgets['grid_jewel'+widget_name].show = false;
                dialog.widgets['grid'+widget_name].show = true;
                dialog.widgets['grid'+widget_name].bg_image = spec['art_asset'];
                dialog.widgets['grid'+widget_name].state = 'normal';
                // shrink large sprites
                dialog.widgets['grid'+widget_name].transform = (spec['gridsize'][0] > 8 ?  [0.2,0,0,0.2,dialog.data['widgets']['grid']['dimensions'][0]/2,dialog.data['widgets']['grid']['dimensions'][1]/2] : null);
                dialog.widgets['grid'+widget_name].onclick = build_closure('inert', name);
                dialog.widgets['grid'+widget_name].tooltip.str = null;
            } else {
                var spec = gamedata['buildings'][name];
                var widget = dialog.widgets['grid'+widget_name];
                widget.bg_image = get_leveled_quantity(spec['art_asset'], 1);
                widget.state = 'icon';
                widget.transform = null;
                widget.show = true;
                dialog.widgets['grid_label'+widget_name].str = spec['ui_name'];
                dialog.widgets['grid_label'+widget_name].show = true;
                dialog.widgets['grid_status'+widget_name].show = true;
                dialog.widgets['grid_jewel'+widget_name].show = true;
                dialog.widgets['grid_jewel'+widget_name].ondraw = update_notification_jewel;
                dialog.widgets['grid_jewel'+widget_name].user_data['count'] = (dialog.user_data['category'] in building_jewels ? (building_jewels[dialog.user_data['category']][name] || 0) : 0);

                var tooltip_text = [];
                var able_to_build = true;
                var max_built = false, can_build_more_if_cc_higher = false, can_build_more_if_cc_one_higher = false, can_build_more_if_pred = null;
                var unlocked = true;
                var helper = null;

                tooltip_text.push(SPUI.break_lines(spec['ui_description'],SPUI.desktop_font, [300,0])[0]);
                tooltip_text.push('');

                // hack for tutorial
                if(player.tutorial_state != 'COMPLETE') {
                    if(name != gamedata['tutorial']['choose_defensive_cannon']['target']) {
                        able_to_build = false; unlocked = false;
                    }
                }

                // display current number of this kind of building, and quantity limit
                var current = count_objects_by_type(spec['name']);
                var limit;
                var cc_obj = player.get_townhall();
                var cc_level = (cc_obj ? cc_obj.level : 0);
                var max_cc_level = (cc_obj ? cc_obj.get_max_ui_level() : 0);
                if('limit' in spec) {
                    limit = get_leveled_quantity(spec['limit'], Math.max(1, cc_level));
                    if('limit_requires' in spec) {
                        limit = Math.min(limit, spec['limit_requires'].length);
                        var req_limit = current;
                        for(; req_limit < spec['limit_requires'].length; req_limit++) {
                            if(!read_predicate(spec['limit_requires'][req_limit]).is_satisfied(player, null)) { break; }
                        }
                        limit = Math.min(limit, req_limit);
                    }
                } else {
                    limit = '-';
                }

                // limit on number of buildings
                if(('limit_requires' in spec) && !player.is_cheater) {
                    if(current >= spec['limit_requires'].length) {
                        // already built all that you can
                        able_to_build = false;
                        max_built = true;
                        tooltip_text.push(gamedata['errors']['BUILDING_LIMIT_EXCEEDED']['ui_name']);
                    } else {
                        var pred = read_predicate(spec['limit_requires'][current]);
                        if(!pred.is_satisfied(player, null)) {
                            able_to_build = false;
                            max_built = true;
                            can_build_more_if_pred = pred;
                            if(!helper) { helper = get_requirements_help(pred, null); }
                        }
                    }
                } else if(((typeof limit) == 'number') && current >= limit && !player.is_cheater) {
                    able_to_build = false;
                    max_built = true;
                    var msg = gamedata['errors']['BUILDING_LIMIT_EXCEEDED']['ui_name'];

                    if((cc_level < max_cc_level) &&
                       current < get_leveled_quantity(spec['limit'], max_cc_level)) {
                        can_build_more_if_cc_higher = true;
                        can_build_more_if_cc_one_higher = (current < get_leveled_quantity(spec['limit'], cc_level+1));

                        var cc_ui_name = gamedata['buildings'][gamedata['townhall']]['ui_name'];
                        msg = gamedata['errors']['BUILDING_LIMIT_EXCEEDED']['ui_name_detailed'].replace('%townhall1',cc_ui_name).replace('%townhall2',cc_ui_name).replace('%lev', cc_level.toString());

                        if(!helper) { helper = get_requirements_help('cc_limit', spec); }
                    }
                    tooltip_text.push(msg);
                }

                if(!max_built || can_build_more_if_cc_higher || can_build_more_if_pred) {

                    // build time
                    var build_time = get_leveled_quantity(spec['build_time'], 1);
                    if(build_time > 0) {
                        build_time = Math.floor(build_time / get_player_stat(player.stattab, 'foreman_speed'));
                        //tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_builds_in'].replace('%s',pretty_print_time(build_time)));
                    } else {
                        tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_builds_instantly']);
                    }

                    // get list of any unsatisfied requirements
                    if('requires' in spec && !player.is_cheater) {
                        var pred = read_predicate(get_leveled_quantity(spec['requires'], 1));
                        var req = pred.ui_describe(player);
                        if(req) {
                            tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_unmet'].replace('%s',req));
                            able_to_build = false;
                            unlocked = false;
                            // this should take priority over any previous helper
                            if(true || !helper) { helper = get_requirements_help(pred, null); }
                        }
                    }

                    if(can_build_more_if_pred) {
                        tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_unmet'].replace('%s',can_build_more_if_pred.ui_describe(player)));
                    }

                    // minimum resource amounts
                    var min_quant;
                    var res_needed = {};
                    for(var res in gamedata['resources']) {
                        var resdata = gamedata['resources'][res];
                        min_quant = get_leveled_quantity(spec['build_cost_'+res] || 0, 1);
                        var player_quant = player.resource_state[res][1];
                        if(player_quant < min_quant && !player.is_cheater) {
                            able_to_build = false;
                            res_needed[res] = min_quant - player_quant;
                        }
                        if(min_quant > 0) {
                            tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_requires_res'].replace('%d',pretty_print_number(min_quant)).replace('%res',resdata['ui_name']));
                        }
                    }
                    if(goog.object.getCount(res_needed) > 0) {
                        if(!helper) {
                            helper = get_requirements_help('resources', res_needed, {continuation:(function (_build_closure, _name) { return function() {
                                _build_closure('buildings',_name)();
                            }; })(build_closure, name)});
                        }
                    }

                    // power requirements
                    if('consumes_power' in spec) {
                        var consumes_power = get_leveled_quantity(spec['consumes_power'], 1);
                        var extra_power_needed = (session.viewing_base.power_state[1] + consumes_power) - session.viewing_base.power_state[0];
                        if(consumes_power > 0 && extra_power_needed > 0) {
                            able_to_build = false;
                            tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_requires_power'].replace('%d',pretty_print_number(extra_power_needed)).replace('%POWERPLANTS', gamedata['buildings'][gamedata['strings']['modstats']['stats']['limit:energy']['check_spec']]['ui_name_plural']));
                            if(!helper) { helper = get_requirements_help('power', null); }
                        }
                    }

                } /// END can still build more

                dialog.widgets['grid_glow'+widget_name].show = true;

                var str = '', color = SPUI.default_text_color;
                if(unlocked) {
                    widget.state = 'icon';

                    if(max_built) {
                        if(can_build_more_if_cc_higher) {
                            color = SPUI.warning_text_color;
                            str += dialog.data['widgets']['grid_status']['ui_name_x_of_y'].replace('%cur',current.toString()).replace('%max',limit.toString());

                            // All friendly_build_dialog does is add the text
                            // "Upgrade CC for more" when upgrading the CC by
                            // one level would allow you to build more of this
                            // building.
                            if(player.get_any_abtest_value('friendly_build_dialog', gamedata['client']['friendly_build_dialog']) &&
                               can_build_more_if_cc_one_higher &&
                               (cc_level >= 2 || read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null))) {
                                str += '\n'+dialog.data['widgets']['grid_status']['ui_name_upgrade_cc'].replace('%TOWNHALL', gamedata['buildings'][gamedata['townhall']]['ui_name_abbreviation'] || gamedata['buildings'][gamedata['townhall']]['ui_name']);
                            }
                        } else if(can_build_more_if_pred) {
                            color = SPUI.warning_text_color;
                            str += dialog.data['widgets']['grid_status']['ui_name_x_of_y'].replace('%cur',current.toString()).replace('%max',limit.toString());
                        } else {
                            color = SPUI.error_text_color;
                            str += dialog.data['widgets']['grid_status']['ui_name_max_built'].replace('%cur', current.toString()).replace('%max',limit.toString());
                        }
                    } else {
                        str += dialog.data['widgets']['grid_status']['ui_name_x_of_y'].replace('%cur',current.toString()).replace('%max',limit.toString());
                    }
                } else {
                    widget.state = 'icon_disabled';
                    str = dialog.data['widgets']['grid_status']['ui_name_locked'];
                    color = SPUI.error_text_color;
                }
                if(spec['developer_only']) { str = '(DEV ONLY) '+str; }

                dialog.widgets['grid_status'+widget_name].str = str;
                dialog.widgets['grid_status'+widget_name].text_color = color;

                if(able_to_build) {
                    widget.onclick = build_closure('buildings', name);
                    widget.tooltip.text_color = SPUI.default_text_color;
                } else {
                    if(helper) {
                        // hack - need to update helper on a per-frame basis - this closes the build dialog as a work-around
                        widget.onclick = (function (_helper) { return function(w) {
                            close_parent_dialog(w);
                            _helper();
                        }; })(helper);
                    } else {
                        widget.onclick = null;
                    }
                    widget.tooltip.text_color = SPUI.error_text_color;
                }

                widget.tooltip.str = tooltip_text.join('\n');
            } // END building

            grid_x += 1;
            if(grid_x >= dialog.data['widgets']['grid']['array'][0]) {
                grid_x = 0; grid_y += 1;
            }
        }
        dialog.widgets['scroll_text'].show = true;
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_spec_on_page+1).toString()).replace('%d2',(last_spec_on_page+1).toString()).replace('%d3',chapter_specs.toString());
    } else {
        dialog.widgets['scroll_text'].show = false;
    }

    // clear out empty widgets
    while(grid_y < dialog.data['widgets']['grid']['array'][1]) {
        while(grid_x < dialog.data['widgets']['grid']['array'][0]) {
            var widget_name = grid_x.toString() + ',' + grid_y.toString();
            dialog.widgets['grid'+widget_name].bg_image = null;
            dialog.widgets['grid'+widget_name].show =
                dialog.widgets['grid_glow'+widget_name].show =
                dialog.widgets['grid_label'+widget_name].show =
                dialog.widgets['grid_status'+widget_name].show =
                dialog.widgets['grid_jewel'+widget_name].show = false;
            grid_x += 1;
        }
        grid_x = 0;
        grid_y += 1;
    }

    dialog.widgets['scroll_left'].state = (page != 0 ? 'normal' : 'disabled');
    dialog.widgets['scroll_right'].state = ((page < chapter_pages-1) ? 'normal' : 'disabled');

    goog.array.forEach([['scroll_left', [0, first_spec_on_page]],
                        ['scroll_right', [last_spec_on_page+1, dialog.user_data['speclist'].length]]],
                       function(data) {
                           var wname = data[0], range = data[1];
                           var count = 0;
                           if(dialog.widgets[wname].state != 'disabled') {
                               for(var i = range[0]; i < range[1] && i < dialog.user_data['speclist'].length; i++) {
                                   var name = dialog.user_data['speclist'][i];
                                   count += (dialog.user_data['category'] in building_jewels ? (building_jewels[dialog.user_data['category']][name] || 0) : 0);
                               }
                           }
                           dialog.widgets[wname+'_jewel'].user_data['count'] = count;
                       });

    player.quest_tracked_dirty = true;
}

// determine whether a shortage of unit space is because of base defenders or total army being full
function classify_unit_space_shortage() {
    var space_usage = player.get_army_space_usage_by_squad();
    var available_total_army = player.stattab['total_space'] - space_usage['ALL'];
    var available_base_defenders = player.stattab['main_squad_space'] - space_usage[SQUAD_IDS.BASE_DEFENDERS.toString()];
    if(available_base_defenders < available_total_army && (!player.squads_enabled() || !gamedata['produce_to_reserves'])) {
        return 'base_defenders';
    } else {
        // can squad bay be built, or upgraded further?
        var target = find_object_by_type(gamedata['squad_building']);
        if(!target || target.level < target.get_max_ui_level()) {
            return 'total_army';
        } else {
            // maxed out - only thing you can do is recycle
            return 'recycle';
        }
    }
}

/** Try to help the player overcome a lack of resources or unfulfilled predicate
    @returns {function()|null} a function that will cause the helper UI to appear (null if we can't help)
    @param {string|Predicate} kind
    @param {?=} arg
    @param {Object=} options */
function get_requirements_help(kind, arg, options) {
    if(!options) { options = {}; }
    var force_short_circuit = false; // this overrides options.short_circuit if true
    var force_even_if_tutorial_incomplete = false; // overrides options.even_if_tutorial_incomplete if true

    if(!player.get_any_abtest_value('plus_buttons', gamedata['client']['plus_buttons'])) { return null; }
    if(player.tutorial_state != "COMPLETE") { return null; }

    var noun = null, verb = null, target = null;
    var ui_arg_s = null, ui_arg_d = null, ui_override_title = null, ui_override_description = null, unit_icon = null;

    // convert legacy resource requests into combo ones
    if(kind in gamedata['resources']) {
        var amount = arg;
        arg = {}; arg[kind] = amount;
        kind = 'resources';
    }

    // when the player doesn't have enough resource storage to hold the extra amount needed,
    // convert the "more res needed" help into a prompt to add/upgrade storage buildings
    if(kind == 'resources') {
        for(var res in arg) {
            if((player.resource_state[res][1] + arg[res]) > player.resource_state[res][0]) {
                kind = 'need_more_storage';
                arg = res;
                break;
            }
        }
    }

    if(kind == 'resources') {
        noun = kind;
        var can_topup = true;
        var need_more = false;

        // legacy path: one at a time
        for(var res in arg) {
            if(arg[res] > 0) {
                need_more = true;
                if(!gamedata['resources'][res]['allow_topup']) {
                    can_topup = false;
                    verb = res; ui_arg_s = pretty_print_number(arg[res]);
                    break;
                }
            }
        }
        if(need_more && can_topup) {
            // optional continuation callback
            var continuation = options.continuation || null;
            return (function (_arg, _continuation) { return function() { invoke_buy_resources_dialog(_arg, _continuation); }; })(arg, continuation);
        }

        // otherwise fall through to standard helper

    } else if(kind == 'insufficient_resources_to_repair_units' || kind == 'insufficient_resources_to_repair_squad') {
        noun = kind;
        if(!arg) { return null; }
        var can_topup = true;
        var missing_res = {};

        // don't need to worry about the case where resource storage is insufficient to hold the amount,
        // because the player would not have been able to build those units in the first place (I think...)

        for(var res in gamedata['resources']) {
            if((res in arg) && (arg[res] > player.resource_state[res][1])) {
                missing_res[res] = arg[res] - player.resource_state[res][1];
                verb = res; // for the fallback non-topup path
                if(!gamedata['resources'][res]['allow_topup']) {
                    can_topup = false;
                    break;
                }
            }
        }
        if(goog.object.getCount(missing_res) > 0 && can_topup) {
            // optional continuation callback
            var continuation = options.continuation || null;
            return (function (_missing_res, _continuation) { return function() { invoke_buy_resources_dialog(_missing_res, _continuation); }; })(missing_res, continuation);
        }

        if(!verb) { return null; }
        ui_arg_s = pretty_print_number(arg[verb] - player.resource_state[verb][1]);
        if('squad_id' in arg) { // awkward - passed in from invoke_insufficient_resources_for_repair_message()
            ui_arg_d = player.squads[arg['squad_id'].toString()]['ui_name'];
        }
    } else if(kind == 'storages_full' ||
              kind == 'storages_full_attack' ||
              kind == 'storages_almost_full_attack' ||
              kind == 'need_more_storage') {
        noun = kind;
        var rsrc = arg;
        var specname = gamedata['resources'][rsrc]['storage_building'];
        // see if we have already built enough storages
        var cc = player.get_townhall();
        var cc_level = player.get_townhall_level();
        var under_construction_obj = null;
        var num_built = 0;
        var min_level = 999, need_to_upgrade_obj = null;
        session.for_each_real_object(function(obj) {
            if(obj.spec['name'] === specname && obj.team === 'player') {
                if(obj.is_under_construction()) {
                    under_construction_obj = obj;
                    return;
                }
                num_built += 1;
                if(obj.level < min_level && obj.level < obj.get_max_ui_level()) {
                    min_level = obj.level;
                    need_to_upgrade_obj = obj;
                }
            }
        });
        ui_arg_s = gamedata['buildings'][specname]['ui_name'];
        ui_arg_d = gamedata['resources'][rsrc]['ui_name_lower'];
        unit_icon = get_leveled_quantity(gamedata['buildings'][specname]['art_asset'], 1);
        if(num_built < 1) {
            // player has not built any storages yet
            if(under_construction_obj) {
                verb = 'finish_construction'; target = under_construction_obj;
            } else {
                verb = 'build_first'; target = specname;
            }
        } else if(num_built < get_leveled_quantity(gamedata['buildings'][specname]['limit'], cc_level)) {
            // player has not built the full number of storages yet
            verb = 'build_more'; target = specname;
        } else if(need_to_upgrade_obj) {
            // player has an under-leveled storage
            verb = 'upgrade'; target = need_to_upgrade_obj;
        } else if(cc && cc.level < cc.get_max_ui_level()) {
            // player must upgrade CC
            verb = 'upgrade_cc'; target = cc;
        } else {
            console.log('unable to help with '+kind+' problem!');  return null;
        }

    } else if(kind == 'power') {
        // see if we have already built enough power plants
        var cc_level = player.get_townhall_level();
        var num_built = 0;
        var min_level = 999, need_to_upgrade_obj = null, powerplant_specname = null;
        session.for_each_real_object(function(obj) {
            if(('provides_power' in obj.spec) && obj.team === 'player') {
                powerplant_specname = obj.spec['name'];
                num_built += 1;
                if(obj.level < min_level && obj.level < obj.get_max_ui_level()) {
                    min_level = obj.level;
                    need_to_upgrade_obj = obj;
                }
            }
        });
        if(powerplant_specname && (num_built < get_leveled_quantity(gamedata['buildings'][powerplant_specname]['limit'], cc_level))) {
            // player has not built the full number of energy plants yet
            noun = 'power'; verb = 'build_more'; target = powerplant_specname;
        } else if(need_to_upgrade_obj) {
            // player has an under-leveled power plant
            noun = 'power'; verb = 'upgrade'; target = need_to_upgrade_obj;
        } else {
            console.log('unable to help with power problem!');  return null;
        }
    } else if(kind == 'score') {
        noun = kind;

        for(var stat_name in arg) {
            if(arg[stat_name] > 0) {
                verb = stat_name; ui_arg_s = pretty_print_number(arg[stat_name]);
                break;
            }
        }
    } else if(kind == 'unit_count') {
        noun = kind; verb = 'default';
        ui_arg_s = gamedata['units'][arg]['ui_name_plural'];
    } else if(kind == 'unit_space') {
        if(player.squads_enabled()) {
            // squads case
            var reason = classify_unit_space_shortage();
            if(reason == 'recycle') {
                noun = 'unit_space_total_army'; verb = 'recycle';
            } else if(reason == 'base_defenders') {
                noun = 'unit_space_base_defenders'; verb = 'manage_base_defenders';
            } else if(reason == 'total_army') {
                noun = 'unit_space_total_army';
                target = find_object_by_type(gamedata['squad_building']);
                if(!target) {
                    verb = 'build_first';
                    target = gamedata['squad_building'];
                } else if(target.level < target.get_max_ui_level()) {
                    verb = 'upgrade';
                } else {
                    verb = 'recycle'; // nothing else to do
                }
            }
        } else {
            // non-squads case
            var specname = attack_space_building();
            if(specname == gamedata['townhall']) {
                // TR-like case where the townhall just needs to be upgraded
                target = player.get_townhall();
                if(!target || (target.level >= target.get_max_ui_level())) { return null; }
                noun = 'unit_space'; verb = 'upgrade';
            } else {
                // SG-like case where a separate building provides army space
                var cc_level = player.get_townhall_level();
                var num_built = 0;
                var min_level = 999, need_to_upgrade_obj = null;
                session.for_each_real_object(function(obj) {
                    if(obj.spec['name'] === specname && obj.team === 'player') {
                        num_built += 1;
                        if(obj.level < min_level && obj.level < obj.get_max_ui_level()) {
                            min_level = obj.level;
                            need_to_upgrade_obj = obj;
                        }
                    }
                });
                if(num_built < get_leveled_quantity(gamedata['buildings'][specname]['limit'], cc_level)) {
                    // player has not built the full number yet
                    noun = 'unit_space'; verb = (num_built < 1 ? 'build_first' : 'build_more'); target = specname;
                } else if(need_to_upgrade_obj) {
                    // player has an under-leveled building
                    noun = 'unit_space'; verb = 'upgrade'; target = need_to_upgrade_obj;
                } else {
                    console.log('unable to help with unit_space problem!');  return null;
                }
            }
        }
    } else if(typeof(kind) === 'string' && kind.indexOf('inventory_space') != -1) {
        noun = kind;
        var warehouse = find_object_by_type(gamedata['inventory_building']);
        if(warehouse) {
            if(warehouse.level < warehouse.get_max_ui_level()) {
                verb = (kind === 'inventory_space_need' ? 'upgrade_or_discard_items' : 'upgrade');
                target = warehouse; ui_arg_s = warehouse.spec['ui_name'];
            } else {
                verb = 'discard_items'; target = warehouse; ui_arg_s = warehouse.spec['ui_name'];
            }
        } else {
            verb = 'build_first'; target = gamedata['inventory_building'];
            ui_arg_s = gamedata['buildings'][gamedata['inventory_building']]['ui_name_indefinite'];
        }
    } else if(kind == 'cc_limit') {
        noun = 'cc_limit'; verb = 'upgrade'; target = player.get_townhall();
        ui_arg_s = target.spec['ui_name']; ui_arg_d = arg['ui_name'];
    } else if(kind == 'limited_equipped') {
        noun = kind;
        var item_spec = ItemDisplay.get_inventory_item_spec(arg)
        target = player.get_townhall(); // assumes townhall is the building that provides_limited_equipped
        ui_arg_s = target.spec['ui_name']; ui_arg_d = ItemDisplay.get_inventory_item_ui_name_long(item_spec);

        var provides = target.spec['provides_limited_equipped'] && (item_spec['limited_equipped'] in target.spec['provides_limited_equipped']) ? target.spec['provides_limited_equipped'][item_spec['limited_equipped']] : -1;
        var cur = get_leveled_quantity(provides, target.level);
        var max_ever = get_leveled_quantity(provides, target.get_max_ui_level());
        if(max_ever > cur) {
            verb = 'upgrade';
        } else {
            verb = 'max';
        }
    } else if(kind == 'player_aura_limit') {
        noun = kind; verb = 'any';
    } else if(kind == 'invalid_building_location') {
        noun = kind; verb = arg;
    } else if(kind == 'tech_for_repair') {
        var unit_spec = gamedata['units'][arg];
        noun = kind; verb = 'research'; target = unit_spec['level_determined_by_tech']; ui_arg_s = unit_spec['ui_name'];
    } else if(kind == 'foreman') {
        // find an extra_foreman for the player to upgrade
        var min_level = 999, need_to_upgrade_obj = null;
        var num_built = 0;

        session.for_each_real_object(function(obj) {
            if(('provides_foremen' in obj.spec) && obj.team === 'player') {
                num_built += 1;
                if(obj.level < min_level && obj.level < obj.get_max_ui_level()) {
                    min_level = obj.level;
                    need_to_upgrade_obj = obj;
                }
            }
        });

        // find what type of building provides foremen
        var builder_spec = null;
        goog.object.forEach(gamedata['buildings'], function(spec) { if('provides_foremen' in spec) { builder_spec = spec; } });

        if(builder_spec && (num_built < get_leveled_quantity(builder_spec['limit'], player.get_townhall_level()))) {
            // player can build more foremen buildings
            noun = 'foreman'; verb = (num_built < 1 ? 'build_first' : 'build_more'); target = builder_spec['name'];
            ui_arg_s = builder_spec[(num_built < 1 ? 'ui_name_indefinite' : 'ui_name')];
        } else if(need_to_upgrade_obj) {
            // player has an under-leveled extra_foreman (and we're assuming that they can be upgraded while other foremen are busy)
            noun = 'foreman'; verb = 'upgrade'; target = need_to_upgrade_obj;
            ui_arg_s = need_to_upgrade_obj.spec['ui_name'];
        } else {
            // fallback to a speedup dialog on one of the current busy buildings
            var tasks = player.foreman_get_tasks();
            if(tasks.length > 0) {
                return (function(_busy_obj) { return function() {
                    change_selection(_busy_obj);
                    invoke_speedup_dialog('speedup');
                }; })(tasks[0]);
            } else {
                console.log('cannot help with foreman problem!');
                return null;
            }
        }
    } else if(kind == 'friends') {
        if(arg.indexOf('invite') == 0) {
            noun = kind; verb = arg;
        } else {
            console.log('cannot help with friend problem: ' + (arg || 'unknown'));
            return null;
        }
    } else if(kind == 'crafting_ingredients') {
        noun = 'crafting';
        verb = 'obtain_ingredients';
        var item_list = [];
        goog.array.forEach(arg, function(item) {
            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            item_list.push(ItemDisplay.get_inventory_item_stack_prefix(spec, item['stack']||1) + ItemDisplay.get_inventory_item_ui_name_long(spec, item['level']));
            if(spec['helper'] == 'invite_friends') {
                // send player to invite friends
                noun = 'friends';
                verb = 'invite_for_ingredients';
            } else if('obtain_ingredients:'+item['spec'] in gamedata['strings']['requirements_help']['crafting']) {
                // ingredient-specific message
                verb = 'obtain_ingredients:'+item['spec'];
            }
        });
        ui_arg_s = item_list.join(', ');
    } else if(kind == 'speedup' || kind == 'repair') {
        noun = 'building';
        verb = kind;
        target = arg; // the object you want to speedup or repair
        ui_arg_s = arg.spec['ui_name'];
    } else if(kind.ui_help) {
        // it's a Predicate instance
        var ret = kind.ui_help(player);
        if(ret) {
            noun = ret['noun']; verb = ret['verb']; target = ret['target'] || null;
            ui_arg_s = ret['ui_arg_s'] || null; ui_arg_d = ret['ui_arg_d'] || null;
            ui_override_title = ret['ui_title'] || null; ui_override_description = ret['ui_name'] || null;
        }
    } else {
        console.log('unknown requirements help type! '+kind.toString());
    }

    //console.log(noun + ' '+verb+' '+target+' '+ui_arg_s+' '+ui_arg_d);

    if(!noun || !verb) { return null; }
    var tip = gamedata['strings']['requirements_help'][noun][verb];
    if(!tip) { return null; }

    var title = ui_override_title || tip['ui_title'].replace('%s', ui_arg_s ? ui_arg_s : '').replace('%d', ui_arg_d ? ui_arg_d.toString() : '');
    var descr = ui_override_description || tip['ui_description'].replace('%s', ui_arg_s ? ui_arg_s : '').replace('%d', ui_arg_d ? ui_arg_d.toString() : '');
    var button = tip['ui_button'] ? tip['ui_button'] : null;
    var cancel_button = tip['ui_cancel_button'] ? tip['ui_cancel_button'] : null;
    var help_function = null;
    var open_function = null;

    if(verb in gamedata['resources']) {
        if((('allow_instant' in gamedata['resources'][verb]) && !gamedata['resources'][verb]['allow_instant']) ) {
            // cannot be bought
        } else {
            if(gamedata['client']['log_insufficient_resources']) {
                open_function = function() {
                    metric_event('5200_insufficient_resources_dialog', {});
                };
            }
            help_function = (function (_verb) { return function() {
                if(gamedata['client']['log_insufficient_resources']) {
                    metric_event('5201_insufficient_resources_go_to_store', {});
                }

                invoke_store(_verb);
            }; })(verb);
        }
    } else if(verb == 'build_more' || verb == 'build_first') {
        unit_icon = get_leveled_quantity(gamedata['buildings'][target]['art_asset'], 1);
        // note: hack to pass parameter via ui_ name
        help_function = (function (_specname) { return function() {
            var dialog = invoke_build_dialog(gamedata['buildings'][_specname]['build_category']);
            if(dialog) {
                // find page containing the building
                var index = dialog.user_data['speclist'].indexOf(_specname);
                if(index < 0) { return; }
                build_dialog_scroll(dialog, Math.floor(index / (dialog.data['widgets']['grid']['array'][0]*dialog.data['widgets']['grid']['array'][1])));

                // find widget representing the building the player needs to build
                var widget_name = null;
                var widget = null;
                var slots = dialog.user_data['slots_this_page'];
                for(var i = 0; i < slots.length; i++) {
                    var name_x_y = slots[i];
                    if(name_x_y[0] == _specname) {
                        widget_name = 'grid'+name_x_y[1].toString()+','+name_x_y[2].toString();
                        widget = dialog.widgets[widget_name];
                        break;
                    }
                }

                // wire up the ENTER key to build it
                dialog.default_button = widget;

                // create a tutorial arrow pointing to the building
                var dir = 'down';
                var arrow = make_ui_arrow(dir);
                player.quest_root.add(arrow);
                arrow.ondraw = update_tutorial_arrow_for_button(arrow, dialog.user_data['dialog'], widget_name, dir);

                // hack - invoke_build_dialog() dirties the quest tracker state, we need to "reset" it here so
                // that the arrow we make doesn't immediately get cleared
                player.quest_tracked_dirty = false;
                selection.ui_change_time = -1;

            }
        }; })(target);
    } else if(verb == 'upgrade' || verb == 'upgrade_cc') {
        help_function = (function(_target) { return function() {
            change_selection_unit(_target);
            invoke_upgrade_building_dialog();
        }; })(target);
    } else if(verb == 'research') {
        help_function = (function (_target) { return function() {
            invoke_upgrade_tech_dialog(_target, null);
        }; })(target);
    } else if(verb == 'repair') {
        help_function = (function (_target) { return function() {
            change_selection_unit(_target);
            if(_target.is_repairing()) {
                invoke_speedup_dialog('speedup');
            } else {
                invoke_repair_dialog();
            }
        }; })(target);
    } else if(verb == 'speedup' && noun == 'player_aura') {
        force_short_circuit = true; // no use showing the info dialog separately
        help_function = (function (_aura_name) { return function() {
            invoke_player_aura_speedup_dialog(_aura_name);
        }; })(target);
    } else if(verb == 'speedup' || verb == 'finish_construction') {
        help_function = (function (_target) { return function() {
            change_selection_unit(_target);
            if(_target.time_until_finish() > 0) {
                invoke_speedup_dialog('speedup');
            } else if(_target.is_damaged() && !_target.is_repairing()) {
                invoke_repair_dialog();
            }
        }; })(target);
    } else if(verb == 'discard_items' || verb == 'upgrade_or_discard_items') {
        help_function = (function (_target) { return function() {
            if(!player.warehouse_is_busy()) {
                invoke_inventory_dialog();
            } else {
                change_selection_unit(target);
                if(target.is_damaged() && !target.is_repairing()) {
                    invoke_repair_dialog();
                } else {
                    invoke_speedup_dialog('speedup');
                }
            }
        }; })(target);
    } else if(verb == 'recycle') {
        help_function = function() { invoke_repair_control(); }
    } else if(verb == 'manage_base_defenders') {
        help_function = function() { SquadManageDialog.invoke_squad_manage(SQUAD_IDS.BASE_DEFENDERS); }
    } else if(verb.indexOf('invite') == 0) {
        if(friend_invites_enabled()) {
            help_function = function() { invoke_invite_friends_dialog('get_requirements_help'); };
        }
    } else if(verb == 'set' && noun == 'alias') {
        help_function = function() {
            change_selection_ui(null);
            PlayerInfoDialog.invoke(session.user_id, function(dialog) {
                /* XXX this doesn't work :(.
                // If "child":0, then the quest_root is being cleared by something before it appears.
                // If "child":1, it doesn't detect the profile tab dialog on first appearance.
                if(0) {
                    read_consequent({'consequent':'TUTORIAL_ARROW', 'child': 1,
                                     'arrow_type':'button',
                                     'direction':'down',
                                     'dialog_name':'player_info_profile_tab',
                                     'widget_name':'set_alias_button'}).execute();
                }
                */
            });
        };
    } else if(noun == 'trust_level') {
        force_even_if_tutorial_incomplete = true;
        help_function = (function (_verb) { return function() {
            if(spin_frame_platform !== 'bh') {
                throw Error('trust_level help not available on platform '+spin_frame_platform);
            }

            var msg = null, feature_name = null;
            if(_verb === 'verify') {
                msg = 'bh_popup_account_verify';
                feature_name = 'bh_verify_prompt';
            } else if(_verb === 'associate') {
                msg = 'bh_popup_account_associate';
                feature_name = 'bh_associate_prompt';
            }

            if(msg) {
                change_selection_ui(null);
                player.record_feature_use(feature_name);

                // flush immediately, because we might redirect right here
                flush_message_queue(true);

                // send this command to the outer iframe
                window.top.postMessage(msg, '*');
            }
        }; })(verb);
    }

    // don't offer requirements help before extended_tutorial_complete, to avoid breaking tutorial GUI
    if(!force_even_if_tutorial_incomplete &&
       !(options && options.even_if_tutorial_incomplete) &&
       !read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null) &&
       player.quest_tracked) {
        return null;
    }

    if(options.short_circuit || force_short_circuit) {
        return help_function;
    }

    return (function (_title, _descr, _button, _cancel_button, _help, _unit_icon, _options, _open_function) { return function() {
        var dialog = new SPUI.Dialog(gamedata['dialogs']['requirements_help_dialog']);
        dialog.user_data['dialog'] = 'requirements_help_dialog';
        install_child_dialog(dialog);
        dialog.modal = true;
        dialog.auto_center();
        dialog.widgets['close_button'].onclick = (function (_cancel) { return function(w) {
            close_parent_dialog(w);
            if(_cancel) { _cancel(); }
        }; })(_options.cancel_function);

        if(_cancel_button) {
            dialog.widgets['close_button'].str = _cancel_button;

            // swap around activity/passivity of buttons
            dialog.widgets['close_button'].state = 'active';
            dialog.widgets['ok_button'].state = 'passive';
            dialog.default_button = dialog.widgets['close_button'];
        }
        dialog.widgets['title'].str = _title;
        dialog.widgets['description'].set_text_with_linebreaking(_descr);
        if(_help) {
            dialog.widgets['ok_button'].show = true;
            if(_button) { dialog.widgets['ok_button'].str = _button; }
            dialog.widgets['ok_button'].onclick = (function (_help_func) { return function(w) {
                close_parent_dialog(w); _help_func();
            }; })(_help);
        }

        if(_unit_icon) {
            dialog.widgets['unit_icon'].show = true;
            dialog.widgets['unit_icon'].asset = _unit_icon;
        }

        if(_open_function) {
            _open_function();
        }

        return dialog;
    }; })(title, descr, button, cancel_button, help_function, unit_icon, options, open_function);
}

/** Get all player-visible modtechs that are associated with a given named tech
    and have a first "effect" of modifying some stat. Returned as a mapping from stat_name -> modtech.
    @param {string} tech_name
    @return {!Object<string,!Object>} */
function get_mod_techs_for_tech_by_stat_name(tech_name) {
    var ret = {};
    for(var other_name in gamedata['tech']) {
        var other_tech = gamedata['tech'][other_name];
        if(other_tech['associated_tech'] == tech_name &&
           other_tech['effects'] && other_tech['effects'][0]['stat'] &&
           (!other_tech['show_if'] || read_predicate(other_tech['show_if']).is_satisfied(player,null))) {
            ret[other_tech['effects'][0]['stat']] = other_tech;
        }
    }
    return ret;
}

/** Similar to above, but return all enhancements that affect enhancement_categories
    @param {!Array<string>} enhancement_categories
    @return {!Object<string,!Object>} */
function get_enhancements_for_categories_by_stat_name(enhancement_categories) {
    var ret = {};
    for(var other_name in gamedata['enhancements']) {
        var other_tech = gamedata['enhancements'][other_name];
        if(goog.array.contains(enhancement_categories, other_tech['enhancement_category']) &&
           other_tech['effects'] && other_tech['effects'][0]['stat'] &&
           (!other_tech['show_if'] || read_predicate(other_tech['show_if']).is_satisfied(player,null))) {
            ret[other_tech['effects'][0]['stat']] = other_tech;
        }
    }
    return ret;
}

// upgrade a specific building (if preselect_building is null, use selection.unit)
/** @param {(GameObject|null)=} preselect_building */
function invoke_upgrade_building_dialog(preselect_building) { return invoke_upgrade_dialog_generic('BUILDING', null, preselect_building || null); }

// upgrade a technology
/** @param {string} techname
    @param {SPUI.Dialog|null=} prev_dialog */
function invoke_upgrade_tech_dialog(techname, prev_dialog) { return invoke_upgrade_dialog_generic(techname, prev_dialog || null, null); }

// upgrade an enhancement
/** @param {!GameObject} obj
    @param {string} enhname
    @param {SPUI.Dialog|null=} prev_dialog */
function invoke_upgrade_enhancement_dialog(obj, enhname, prev_dialog) { return invoke_upgrade_dialog_generic(enhname, prev_dialog || null, obj); }

/** @param {string} techname
    @param {SPUI.Dialog|null} prev_dialog
    @param {GameObject|null} preselect */
function invoke_upgrade_dialog_generic(techname, prev_dialog, preselect) {

    if(techname == 'BUILDING') {
        // if building is busy, divert to speedup dialog
        var bldg = preselect || selection.unit;
        if(bldg.time_until_finish() > 0 && !gamedata['always_allow_show_building_stats']) {
            change_selection_unit(bldg);
            return invoke_child_speedup_dialog('speedup');
        }
    }

    // instantiate the dialog
    var dialog = new SPUI.Dialog(gamedata['dialogs']['upgrade_dialog']);

    // make the dialog modal and add it to the "desktop" (replacing any existing selection.ui)
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.user_data['dialog'] = 'upgrade_dialog';
    dialog.user_data['unit'] = (preselect || selection.unit); // buildings only
    dialog.user_data['techname'] = techname;
    dialog.user_data['tech'] = (techname === 'BUILDING' ? null :
                                (techname in gamedata['tech'] ? gamedata['tech'][techname] :
                                 (techname in gamedata['enhancements'] ? gamedata['enhancements'][techname] : null)));
    dialog.user_data['equip_slots_by_type'] = {};
    dialog.user_data['prev_dialog'] = prev_dialog;
    dialog.user_data['context'] = null;
    dialog.user_data['feature_scroll'] = 0;
    dialog.user_data['equip_chooser'] = null;
    dialog.ondraw = update_upgrade_dialog;
    dialog.ondraw(dialog);
    return dialog;
}

/** Get list of features to show for a weapon on a unit or building
    @param {Object} spec
    @param {Object} spell
    @return {Array.<string>} */
function get_weapon_spell_features2(spec, spell) {
    var ret = [];
    var ui_show_weapon_features = true;
    if('ui_show_weapon_features' in spell && !spell['ui_show_weapon_features']) {
        ui_show_weapon_features = false;
    }
    if(ui_show_weapon_features) {
        ret.push('weapon_damage');
    }
    if('effective_range' in spell) {
        ret.push('effective_weapon_range');
    }
    if(!is_melee_spell(spell) && ('range' in spell)) {
        ret.push('weapon_range');
    }
    if('min_range' in spell && ui_show_weapon_features) {
        ret.push('min_range');
    }
    if('splash_range' in spell && ui_show_weapon_features) {
        ret.push('splash_range');
    }
    if('accuracy' in spell && ui_show_weapon_features) {
        ret.push('accuracy');
    }
    if('ui_priority_vs' in spell || 'ui_priority_vs' in spec) {
        ret.push('ui_priority_vs');
    }
    if('impact_auras' in spell){
        goog.array.forEach(spell['impact_auras'], function(aura) {
            var name = aura['spec'];
            var spec = gamedata['auras'][name];
            var effects = spec['effects'];
            var is_dot = false;
            goog.array.forEach(effects, function(effect) { if('code' in effect && effect['code'] == 'on_fire') { is_dot = true; } });
            if(is_dot) { return; }
            ret.push('impact_auras:' + name);
        });
    }
    return ret;
};

/** @param {SPUI.Dialog} dialog  */
function update_upgrade_dialog(dialog) {
    var techname = dialog.user_data['techname'];
    var unit = dialog.user_data['unit'];
    var tech = dialog.user_data['tech'];

    // XXXXXX hack to prevent tooltip show-through into child dialog
    var enable_tooltip = true;
    var p = dialog;
    while(p.parent) {
        if(p.children[p.children.length-1] !== dialog && p.children[p.children.length-1].modal) {
            enable_tooltip = false;
            break;
        }
        p = p.parent;
    }

    // offset dialog position so that mod techs don't appear exactly on top of the parent regular tech
    if(tech && tech['affects_unit']) {
        dialog.wh = vec_sub(dialog.data['dimensions'], dialog.data['mod_tech_offset']);
    } else {
        dialog.wh = dialog.data['dimensions'];
    }
    dialog.auto_center();

    var old_level, max_level;

    if(techname === 'BUILDING') {
        old_level = unit.level;
        max_level = unit.get_max_ui_level();
    } else if(techname in gamedata['tech']) {
        old_level = (techname in player.tech ? player.tech[techname] : 0);
        max_level = get_max_ui_level(tech);
    } else if(techname in gamedata['enhancements']) {
        old_level = (unit.enhancements ? unit.enhancements[techname] || 0 : 0);
        max_level = get_max_ui_level(tech);
    } else {
        throw Error('unhandled case');
    }

    var new_level = old_level + 1;

    // flag that we can't do any upgrades, and this is just for showing stats
    var stats_only = (techname === 'BUILDING' && !session.home_base && !unit.spec['quarry_upgradable']);

    // whether it is possible to perform the upgrade using resources (vs. instant purchase)
    var use_resources_offered = true;

    // whether the player has fulfilled all requirements to perform
    // the upgrade/research, aside from having enough fungible resources
    var use_resources_requirements_ok = true, instant_requirements_ok = true;

    // requirements text for tooltip - add insufficient resource amounts for "Use Resources" tooltip
    var tooltip_req_instant = [], tooltip_req_use_resources = [];

    // whether the player has enough fungible resources
    var resources_ok = true;
    var resources_needed = {}; // dictionary of resource amounts needed
    var ui_resources_needed = []; // list of ui_strings describing resources we need, for tooltip

    // text describing any unsatisfied requirements
    var req = [];

    // already researched to maximum level?
    if(new_level > max_level) {
        use_resources_requirements_ok = instant_requirements_ok = false;
    }

    // is the appropriate building busy?
    var builder;
    if(tech && ('research_category' in tech)) {
        var builder_type = get_lab_for(tech['research_category']);
        builder = find_object_by_type(builder_type);
        if(!builder && !player.is_cheater) {
            console.log('opened upgrade dialog but research lab was not present: '+techname+' '+tech['research_category']);
            invoke_research_dialog(null, tech['research_category']);
            return;
        }
        //change_selection_unit(builder);
    } else {
        builder = unit;
    }
    dialog.user_data['builder'] = builder;

    // check if viewing a building and if always viewing stats is enabled
    var stats_when_busy = false;
    if (builder && builder.is_building() && builder.time_until_finish() > 0 && gamedata['always_allow_show_building_stats']) {
        stats_when_busy = true;
    };

    // building is missing, damaged or busy with something, cannot
    // perform upgrade/research

    if(!builder && !player.is_cheater) {
        use_resources_requirements_ok = instant_requirements_ok = false;
    } else if(builder && builder.is_damaged()) {
        req.push(dialog.data['widgets']['requirements_text']['ui_name_needs_repair'].replace('%s',builder.spec['ui_name']));
        use_resources_requirements_ok = false;
        if(tech) {
            // you CAN do an instant tech research even if the lab is daamged
        } else {
            instant_requirements_ok = false;
        }
    } else if(builder && builder.time_until_finish() > 0 && !stats_when_busy) {
        req.push(dialog.data['widgets']['requirements_text']['ui_name_busy'].replace('%s',builder.spec['ui_name']));
        use_resources_requirements_ok = false;
        if(tech) {
            // you CAN do an instant tech research even if the lab is busy
        } else {
            instant_requirements_ok = false;
        }
    }

    // now fill in some of the text fields inside of the dialog
    // by resetting the 'str' variable for a few widgets

    // dialog title
    // we are looking this up by the widget name, as specified in gamedata.json
    var widget = dialog.widgets['title'];

    if(tech) {
        if(old_level === 0) {
            dialog.widgets['title_bold'].str = dialog.data['widgets']['title_bold']['ui_name_unlock'];
            widget.str = widget.data['ui_name_unlock'].replace('%s',tech['ui_name']).replace('%d', new_level.toString());
            widget.xy = widget.data['ui_name_unlock_xy'];
        } else if(new_level > max_level) {
            dialog.widgets['title_bold'].str = dialog.data['widgets']['title_bold']['ui_name_stats'];
            widget.str = widget.data['ui_name_stats'].replace('%s',tech['ui_name']).replace('%d',max_level.toString());
            widget.xy = widget.data['ui_name_stats_xy'];
            if(widget.str.length > widget.data['ui_name_stats_max_length']) {
                widget.str = widget.data['ui_name_stats_short'].replace('%s', tech['ui_name']).replace('%d', new_level.toString());
            }
        } else {
            if(('update_unit_levels_on_tech_upgrade' in gamedata) &&
               !gamedata['update_unit_levels_on_tech_upgrade']) {
                // call this "Research" instead of "Upgrade" when the new level isn't applied to existing units
                dialog.widgets['title_bold'].str = dialog.data['widgets']['title_bold']['ui_name_research'];
                widget.xy = widget.data['ui_name_research_xy'];
            } else {
                dialog.widgets['title_bold'].str = dialog.data['widgets']['title_bold']['ui_name'];
                widget.xy = widget.data['ui_name_xy'];
            }
            widget.str = widget.data['ui_name'].replace('%s', tech['ui_name']).replace('%d', new_level.toString());
            if(widget.str.length > widget.data['ui_name_max_length']) {
                widget.str = widget.data['ui_name_short'].replace('%s', tech['ui_name']).replace('%d', new_level.toString());
            }
        }
    } else {
        if(new_level > max_level || stats_only || stats_when_busy) {
            dialog.widgets['title_bold'].str = dialog.data['widgets']['title_bold']['ui_name_stats'];
            widget.str = widget.data['ui_name_stats'].replace('%s',unit.spec['ui_name']).replace('%d',old_level.toString());
            if(widget.str.length > widget.data['ui_name_stats_max_length']) {
                widget.str = widget.data['ui_name_stats_short'].replace('%s', unit.spec['ui_name']).replace('%d', new_level.toString());
            }
        } else {
            widget.str = widget.data['ui_name'].replace('%s', unit.spec['ui_name']).replace('%d', new_level.toString());
            if(widget.str.length > widget.data['ui_name_max_length']) {
                widget.str = widget.data['ui_name_short'].replace('%s', unit.spec['ui_name']).replace('%d', new_level.toString());
            }
        }
    }

    // big hero icon
    if(tech) {
        var asset, state = 'hero', pos_state = 'xy';;
        if('associated_unit' in tech && !('splash_image' in gamedata['units'][tech['associated_unit']])) { // UNIT without splash image
            var unit_spec = gamedata['units'][tech['associated_unit']];
            asset = get_leveled_quantity(unit_spec['art_asset'], (new_level > max_level ? max_level : new_level));

            var voffset;
            if(unit_spec['flying']) {
                voffset = -3*unit_spec['altitude'];
            } else {
                voffset = 0;
            }
            dialog.widgets['icon'].bg_image_offset = [dialog.data['widgets']['icon']['bg_image_offset'][0],
                                                      dialog.data['widgets']['icon']['bg_image_offset'][1] + voffset];
            dialog.widgets['icon'].alpha = unit_spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1;
        } else {
            if('associated_unit' in tech && ('splash_image' in gamedata['units'][tech['associated_unit']])) { // UNIT with splash iamge
                asset = get_leveled_quantity(gamedata['units'][tech['associated_unit']]['splash_image'], (new_level > max_level ? max_level : new_level));
                pos_state = 'xy_unit_splash';
                if(old_level <= 1) {
                    state = 'normal_disabled';
                }
            } else if('splash_image' in tech) { // TECH with splash image
                asset = get_leveled_quantity(tech['splash_image'], (new_level > max_level ? max_level : new_level));
                if(GameArt.assets[asset].has_state('hero')) {
                    // 3D asset splash image
                } else {
                    // painted 2D splash image
                    state = 'normal';
                    pos_state = 'xy_splash';
                }
            } else if('icon' in tech) { // TECH icon
                asset = get_leveled_quantity(tech['icon'], (new_level > max_level ? max_level : new_level));
            } else {
                throw Error('no icon/image for tech '+tech['name']);
            }

            if(!GameArt.assets[asset].has_state(state)) { // fallback for missing hero/normal_disabled
                state = 'normal';
            }
        }
        dialog.widgets['icon'].xy = dialog.data['widgets']['icon'][pos_state];
        dialog.widgets['icon'].asset = asset;
        dialog.widgets['icon'].state = state;
    } else {
        dialog.widgets['icon'].asset = get_leveled_quantity(unit.spec['art_asset'], (new_level > max_level ? max_level : new_level));
        // special-case because some buildings are really tall
        dialog.widgets['icon'].bg_image_offset = vec_add(dialog.data['widgets']['icon']['bg_image_offset'], unit.spec['hero_icon_pos'] || [0,0]);
    }

    dialog.widgets['cost_time'].show = (!stats_only && new_level <= max_level && !stats_when_busy);
    for(var res in gamedata['resources']) {
        var show_res = (!stats_when_busy && !stats_only && new_level <= max_level) && (tech ? ('cost_'+res in tech) : ('build_cost_'+res in unit.spec));
        if('resource_'+res+'_icon' in dialog.widgets) {
            dialog.widgets['resource_'+res+'_icon'].show = show_res;
            dialog.widgets['resource_'+res+'_icon'].asset = gamedata['resources'][res]['icon_small'];
        }
        if('cost_'+res in dialog.widgets) {
            dialog.widgets['cost_'+res].show = show_res;
        }
        if('resource_'+res+'_button' in dialog.widgets) {
            dialog.widgets['resource_'+res+'_button'].show = false;
        }
    }
    dialog.widgets['resource_power_button'].show = false;
    dialog.widgets['cost_power'].show =
        dialog.widgets['resource_power_icon'].show =
        (!tech && (unit.spec['kind'] === 'building') && (get_leveled_quantity(unit.spec['consumes_power']||0, max_level) > 0));

    // resource costs
    if(stats_only || new_level > max_level || stats_when_busy) {
        // don't show resource costs if already at max level
        if(dialog.widgets['cost_power'].show) {
            dialog.widgets['cost_power'].tooltip.str = (enable_tooltip ? dialog.data['widgets']['cost_power']['ui_tooltip_maxlevel'] : null);
            dialog.widgets['cost_power'].fixed_tooltip_offset = dialog.data['widgets']['cost_power']['fixed_tooltip_offset_maxlevel'];
            dialog.widgets['cost_power'].text_color = SPUI.default_text_color;
            dialog.widgets['cost_power'].str = pretty_print_number(get_leveled_quantity(unit.spec['consumes_power'], unit.level));
        }
        dialog.widgets['cost_time'].str = null;

    } else {
        var cost;

        for(var res in gamedata['resources']) {
            var resdata = gamedata['resources'][res];

            if(tech) {
                cost = get_leveled_quantity(tech['cost_'+res] || 0, new_level);
            } else {
                cost = get_leveled_quantity(unit.spec['build_cost_'+res] || 0, new_level);
            }

            if(!player.is_cheater && cost > 0 && !resource_allow_instant_upgrade(resdata,player)) {
                instant_requirements_ok = false;
                tooltip_req_instant.push(dialog.data['widgets']['instant_button']['ui_tooltip_rare_res'].replace('%s', resdata['ui_name']));
            }

            if(cost < 0) {
                use_resources_offered = false;
            } else if(player.resource_state[res][1] < cost) {
                resources_ok = false;
                resources_needed[res] = cost - player.resource_state[res][1];
                ui_resources_needed.push(dialog.data['widgets']['use_resources_button']['ui_tooltip_more_res'].replace('%d',pretty_print_number(cost - player.resource_state[res][1])).replace('%s',resdata['ui_name']));
            }

            if('cost_'+res in dialog.widgets) {
                widget = dialog.widgets['cost_'+res];
                widget.show = (cost > 0);
                if('resource_'+res+'_icon' in dialog.widgets) {
                    dialog.widgets['resource_'+res+'_icon'].show = (cost > 0);
                }
                widget.str = pretty_print_qty_brief(cost);
                widget.tooltip.str = (enable_tooltip ? widget.data['ui_tooltip'].replace('%RES', resdata['ui_name']).replace('%QTY', pretty_print_number(cost)) : null);
                if(cost > 0 && player.resource_state[res][1] < cost) {
                    widget.text_color = SPUI.error_text_color;
                    // don't show button for topup, since the main "Use Resources" button will take care of it
                    if(!gamedata['resources'][res]['allow_topup'] && 'resource_'+res+'_button' in dialog.widgets) {
                        var helper = get_requirements_help(res, cost - player.resource_state[res][1]);
                        dialog.widgets['resource_'+res+'_button'].show = !!helper;
                        dialog.widgets['resource_'+res+'_button'].onclick = helper;
                    }
                } else {
                    widget.text_color = SPUI.good_text_color;
                }
            }
        }

        if(dialog.widgets['cost_power'].show) {
            var old_cost = get_leveled_quantity(unit.spec['consumes_power'], unit.level);
            cost = get_leveled_quantity(unit.spec['consumes_power'], unit.level+1);

            dialog.widgets['cost_power'].tooltip.str = (enable_tooltip ? dialog.data['widgets']['cost_power']['ui_tooltip'].replace('%CUR', pretty_print_number(old_cost)).replace('%AFTER', pretty_print_number(cost)).replace('%DURING', pretty_print_number(get_leveled_quantity(unit.spec['consumes_power_while_building'], unit.level+1))) : null);
            dialog.widgets['cost_power'].fixed_tooltip_offset = dialog.data['widgets']['cost_power']['fixed_tooltip_offset'];

            var ui_delta;
            if(cost > old_cost) {
                ui_delta = '+' + pretty_print_number(cost-old_cost);
            } else if(cost < old_cost) {
                ui_delta = '-' + pretty_print_number(old_cost - cost);
            } else {
                ui_delta = '+0';
            }
            dialog.widgets['cost_power'].str = dialog.data['widgets']['cost_power']['ui_name'].replace('%AFTER', pretty_print_number(cost)).replace('%DELTA', ui_delta);

            // do not display energy text in red for central computer upgrades, because they allow more plants to be built
            if((unit.spec['name'] != gamedata['townhall']) &&
               (session.viewing_base.power_state[1] + cost - old_cost) > session.viewing_base.power_state[0]) {
                dialog.widgets['cost_power'].text_color = SPUI.error_text_color;
                var helper = get_requirements_help('power', null);
                dialog.widgets['resource_power_button'].show = !!helper;
                dialog.widgets['resource_power_button'].onclick = helper;
            } else {
                dialog.widgets['cost_power'].text_color = SPUI.good_text_color;
            }

        }

        var time_arr;
        var tech_speed = 1;
        if(tech) {
            if('research_time' in tech) {
                time_arr = tech['research_time'];
                if(builder) {
                    tech_speed = builder.get_stat('research_speed',1);
                }
            } else if('enhance_time' in tech) {
                time_arr = tech['enhance_time'];
                if(builder) {
                    tech_speed = builder.get_stat('enhance_speed',1);
                }
            } else {
                throw Error('time_arr not found for tech '+tech['name']);
            }
        } else {
            time_arr = unit.spec['build_time'];
        }

        var cost_time = get_leveled_quantity(time_arr, new_level);
        if(tech_speed != 1) {
            cost_time = Math.floor(cost_time / tech_speed);
        } else if(!tech && unit && cost_time > 0) {
            cost_time = Math.floor(cost_time / get_player_stat(player.stattab, 'foreman_speed'));
        }
        widget = dialog.widgets['cost_time'];
        widget.str = (cost_time > 0 ? pretty_print_time(cost_time) : '');

    } // END if not at max level

    dialog.widgets['cost_time_bar'].show = dialog.widgets['cost_time_clock'].show = !!dialog.widgets['cost_time'].str;

    if(tech) {
        dialog.widgets['cost_power'].show = false;
        dialog.widgets['resource_power_icon'].show = false;
    }

    // get equipment slots
    dialog.user_data['equip_slots_by_type'] = {};
    var equip_slots = null;

    if(player.get_any_abtest_value('enable_equipment', gamedata['client']['enable_equipment']) &&
       (!tech || player.get_any_abtest_value('enable_unit_equipment', gamedata['client']['enable_unit_equipment']))) {
        if(tech && ('associated_unit' in tech)) {
            // unit equipment
            var unit_spec = gamedata['units'][tech['associated_unit']];
            equip_slots = unit_spec['equip_slots'] || null;
        }
        if(!tech) {
            // building equipment
            equip_slots = unit.spec['equip_slots'] || null;
        }
    }

    // FEATURES

    var feature_list = [];

    if(tech) {
        // UNIT OR GENERIC TECH
        if('associated_unit' in tech) {
            var spec = gamedata['units'][tech['associated_unit']];
            feature_list.push('max_hp');
            if(gamedata['show_armor_in_ui']) { feature_list.push('armor'); }
            feature_list = feature_list.concat(get_weapon_spell_features2(spec, get_auto_spell_for_unit(player, spec)));
            feature_list.push('maxvel');
            if(get_leveled_quantity(spec['consumes_space']||0, 1) > 0) {
                feature_list.push('consumes_space');
            }
            if(get_leveled_quantity(spec['limit']||0, 1) > 0) {
                feature_list.push('limit');
            }
            if('on_damage' in spec) { feature_list.push('on_damage'); }
            if('on_destroy' in spec) { feature_list.push('on_destroy'); }
            if('on_approach' in spec) { feature_list.push('on_approach'); }

            if(player.raids_enabled()) { // raids - show cargo stats
                goog.object.forEach(gamedata['resources'], function(resdata, resname) {
                    if(('cargo_'+resname) in spec) { feature_list.push('cargo_'+resname); }
                });
            }

            if('damage_taken_from' in spec) {
                goog.object.forEach(spec['damage_taken_from'], function(amount, key) {
                    var stat = 'damage_taken_from:'+key;
                    if(stat in gamedata['strings']['modstats']['stats'] &&
                       gamedata['strings']['modstats']['stats'][stat]['display'] !== null) {
                        feature_list.push(stat);
                    }
                });
            }

            if('permanent_auras' in spec) {
                feature_list.push('permanent_auras');
            }
        } else if('associated_item' in tech) {
            var item_spec = ItemDisplay.get_inventory_item_spec(get_leveled_quantity(tech['associated_item'], Math.min(new_level, max_level)));
            var auto_spell = get_auto_spell_for_item(item_spec);
            if(auto_spell) {
                feature_list = feature_list.concat(get_weapon_spell_features2(item_spec, auto_spell));
            }
            if('equip' in item_spec && 'effects' in item_spec['equip']) {
                goog.array.forEach(item_spec['equip']['effects'], function(effect) {
                    if(!('code' in effect && effect['code'] === 'modstat')) { return; }

                    if(effect['stat'] === 'permanent_auras' && feature_list.indexOf('permanent_auras') === -1) {
                        feature_list.push('permanent_auras');
                    }
                });
            }
        } else if('associated_building' in tech) {
            feature_list.push('limit:'+tech['associated_building']);
        } else if('affects_unit' in tech && tech['effects']) { // mod techs
            if(tech['effects'].length != 1 || tech['effects'][0]['code'] !== 'modstat') {
                throw Error('do not know how to parse these effects: '+JSON.stringify(tech['effects']));
            }
            feature_list.push(tech['effects'][0]['stat']);
        } else if('enhancement_category' in tech && tech['effects']) { // enhancement
            if(tech['effects'].length != 1 || tech['effects'][0]['code'] !== 'modstat') {
                throw Error('do not know how to parse these effects: '+JSON.stringify(tech['effects']));
            }
            feature_list.push(tech['effects'][0]['stat']);
        }
    } else {
        // BUILDING
        if(unit.spec['show_hp_stat']) { feature_list.push('max_hp'); }

        goog.object.forEach(gamedata['resources'], function(resdata, resname) {
            if(('produces_'+resname) in unit.spec) { feature_list.push('produces_'+resname); }
            if(('storage_'+resname) in unit.spec && !('provides_space' in unit.spec) /* omit on CC */ ) { feature_list.push('storage_'+resname); }
            if(('vault_'+resname) in unit.spec) { feature_list.push('vault_'+resname); }
        });
        if('provides_power' in unit.spec) { feature_list.push('provides_power'); }
        if('power_shutdown_threshold' in unit.spec) { feature_list.push('power_shutdown_threshold'); }
        if('provides_foremen' in unit.spec) { feature_list.push('provides_foremen'); }

        // special stat for ambush points
        if('strike_team' in unit.spec) { feature_list.push('strike_team'); }

        // detect enhanceable stats
        if(unit.spec['enhancement_categories']) {
            for(var enh_name in gamedata['enhancements']) {
                var enh_tech = gamedata['enhancements'][enh_name];
                if(goog.array.contains(unit.spec['enhancement_categories'], enh_tech['enhancement_category'])) {
                    var stat = enh_tech['effects'][0]['stat'];
                    if(!goog.array.contains(feature_list, stat)) {
                        feature_list.push(stat);
                    }
                }
            }
        }

        if(unit.is_researcher()) { feature_list.push('research_level'); }
        if(unit.is_researcher()) { feature_list.push('research_speed'); }
        if(unit.is_crafter() && !unit.is_emplacement() && !unit.is_security_node() && !unit.is_trapped_barrier() && !unit.is_armed_building() && !unit.is_armed_townhall() && !('crafting_speed' in unit.spec)) { feature_list.push('crafting_level'); }
        if(unit.is_crafter() && ('crafting_queue_space' in unit.spec)) { feature_list.push('crafting_queue_space'); }

        if('provides_quarry_control' in unit.spec && session.region.map_enabled()) { feature_list.push('provides_quarry_control'); }
        if(player.squads_enabled()) {
            if('provides_total_space' in unit.spec) { feature_list.push('provides_total_space'); }
            if('provides_space' in unit.spec) { feature_list.push('provides_space'); }
            if('provides_squads' in unit.spec) { feature_list.push('provides_squads'); }
            if('provides_deployed_squads' in unit.spec) { feature_list.push('provides_deployed_squads'); }
            if(player.raids_enabled()) {
                if('provides_deployed_raids' in unit.spec) { feature_list.push('provides_deployed_raids'); }
                if('raid_range_pve' in unit.spec) { feature_list.push('raid_range_pve'); }
                if('raid_range_pvp' in unit.spec) { feature_list.push('raid_range_pvp'); }
            }
            if('provides_squad_space' in unit.spec) { feature_list.push('provides_squad_space'); }
        } else {
            if('provides_space' in unit.spec) { feature_list.push('provides_space'); }
        }

        // attack space
        if(('provides_space' in unit.spec) && (gamedata['deployable_unit_space'] < 1)) { feature_list.push('deployable_unit_space'); }

        if('provides_donated_space' in unit.spec && player.unit_donation_enabled()) { feature_list.push('provides_donated_space'); }
        if('max_individual_donation_space' in unit.spec && player.unit_donation_enabled()) { feature_list.push('max_individual_donation_space'); }
        if('alliance_help_daily_limit' in unit.spec && player.alliance_help_enabled()) { feature_list.push('alliance_help_daily_limit'); }
        if('provides_inventory' in unit.spec) { feature_list.push('provides_inventory'); }

        if(unit.spec['name'] === gamedata['townhall']) {
            // not enough space in dialog for "limit:barriers" :(
            goog.array.forEach(['limit:storages','limit:harvesters','limit:turrets','limit:emplacements'], function(statname) {
                var statdata = gamedata['strings']['modstats']['stats'][statname];
                if(statdata) {
                    var check_spec = gamedata['buildings'][statdata['check_spec']];
                    if(!(check_spec['show_if']) || read_predicate(check_spec['show_if']).is_satisfied(player, null)) {
                        feature_list.push(statname);
                    }
                }
            });
            if(gamedata['enable_power']) {
                feature_list.push('limit:energy');
            }
        }

        if('provides_limited_equipped' in unit.spec) {
            goog.object.forEach(unit.spec['provides_limited_equipped'], function(num_array, kind) {
                var statname = 'provides_limited_equipped:'+kind;
                var statdata = gamedata['strings']['modstats']['stats'][statname];
                if(statdata) {
                    var check_spec = gamedata['buildings'][statdata['check_spec']];
                    if(!(check_spec['show_if']) || read_predicate(check_spec['show_if']).is_satisfied(player, null)) {
                        feature_list.push(statname);
                    }
                }
            });
        }

        if(unit.is_manufacturer()) {
            feature_list.push('manufacture_speed');
            feature_list.push('unit_repair_speed');
        }

        if(unit.is_crafter() && ('crafting_speed' in unit.spec)) {
            feature_list.push('crafting_speed');
        }

        var auto_spell = get_auto_spell_raw(unit.spec); // not unit.get_auto_spell(), since that includes equipped item mods
        if(auto_spell) {
            feature_list = feature_list.concat(get_weapon_spell_features2(unit.spec, auto_spell));
        }

        if('on_damage' in unit.spec) { feature_list.push('on_damage'); }
        if('on_destroy' in unit.spec) { feature_list.push('on_destroy'); }
        if('on_approach' in unit.spec) { feature_list.push('on_approach'); }

        if(unit.spec['permanent_auras']) {
            feature_list.push('permanent_auras');
        }
        if(unit.spec['permanent_modstats']) {
            var pm_list = unit.spec['permanent_modstats'];
            if(pm_list.length >= 1 && (Array.isArray(pm_list[0]) || pm_list[0] === null)) {
                pm_list = unit.get_leveled_quantity(pm_list);
            }
            goog.array.forEach(pm_list, function(pm) {
                var stat = pm['stat'];
                if(stat in gamedata['strings']['modstats']['stats'] &&
                   gamedata['strings']['modstats']['stats'][stat]['display'] !== null &&
                   !goog.array.contains(feature_list, stat)) {
                    feature_list.push(stat);
                }
            });
        }

        if('damage_taken_from' in unit.spec) {
            goog.object.forEach(unit.spec['damage_taken_from'], function(amount, key) {
                var stat = 'damage_taken_from:'+key;
                if(stat in gamedata['strings']['modstats']['stats'] &&
                   gamedata['strings']['modstats']['stats'][stat]['display'] !== null) {
                    feature_list.push(stat);
                }
            });
        }

        if(unit.spec['quarry_control_auras']) {
            var au_list = unit.spec['quarry_control_auras'];
            goog.array.forEach(au_list, function(au) {
                var aura_specname = au['spec'];
                var stat = 'quarry_control_aura:'+aura_specname;
                if(stat in gamedata['strings']['modstats']['stats'] &&
                   gamedata['strings']['modstats']['stats'][stat]['display'] !== null &&
                   !goog.array.contains(feature_list, stat)) {
                    feature_list.push(stat);
                }
            });
        }

    } // END is a building

    // gather misc. new-style modstats
    var modstats = null;
    if(!tech) {
        modstats = unit.modstats;
    } else if('associated_unit' in tech) {
        modstats = player.stattab['units'][tech['associated_unit']] || {};
    }
    if(modstats !== null) {
        goog.object.forEach(modstats,
                            function(modchain, stat) {
                                if(stat in gamedata['strings']['modstats']['stats'] && !goog.array.contains(feature_list, stat) &&
                                   gamedata['strings']['modstats']['stats'][stat]['display'] !== null &&
                                   /* weapon* stats, except for weapon_damage_vs, should be handled above since they need to look up auto_spell */
                                   (stat.indexOf('weapon_')!=0 ||
                                    stat.indexOf('weapon_damage_vs:')==0 ||
                                    (stat === 'weapon_range_pvp' && goog.array.contains(feature_list, 'weapon_range'))) &&
                                   (stat != 'weapon' || !(unit && unit.is_emplacement()) || !(unit && unit.is_security_node()) || !(unit && unit.is_trapped_barrier()) || !(unit && unit.is_armed_building()) || !(unit && unit.is_armed_townhall())) && /* don't show "weapon" stat on mounted weapon buildings */
                                   (modchain['mods'].length>1 && modchain['val'] != modchain['mods'][0]['val'])) {
                                    feature_list.push(stat);
                                }
                            });
    }

    // gather stats affected by mod techs or enhancements that don't already appear in the list
    if(tech) {
        var moddable_stats = goog.object.getKeys(get_mod_techs_for_tech_by_stat_name(tech['name']));
        feature_list = feature_list.concat(moddable_stats);
    } else if(unit && unit.is_building() && unit.spec['enhancement_categories']) {
        var enhable_stats = goog.object.getKeys(get_enhancements_for_categories_by_stat_name(unit.spec['enhancement_categories']));
        feature_list = feature_list.concat(enhable_stats);
    }


    // XP AMOUNT
    var xp_amount = 0;
    if(new_level <= max_level) {
        if(tech) {
            var override = get_leveled_quantity(('upgrade_xp' in tech ? tech['upgrade_xp'] : -1), new_level);
            if(override >= 0) {
                xp_amount = override;
            } else {
                var res_amount = 0;
                for(var res in gamedata['resources']) {
                    res_amount += get_leveled_quantity(tech['cost_'+res] || 0, new_level);
                }
                xp_amount = Math.floor(gamedata['player_xp']['research'] * res_amount);
            }
        } else {
            if(unit && (unit.spec['name'] in gamedata['player_xp']['buildings'])) {
                var override = get_leveled_quantity(('upgrade_xp' in unit.spec ? unit.spec['upgrade_xp'] : -1), new_level);
                if(override >= 0) {
                    xp_amount = override;
                } else {
                    var res_amount = 0;
                    for(var res in gamedata['resources']) {
                        res_amount += get_leveled_quantity(unit.spec['build_cost_'+res] || 0, new_level);
                    }
                    var coeff;
                    if(new_level == 1 && ('level_1' in gamedata['player_xp']['buildings'])) {
                        coeff = gamedata['player_xp']['buildings']['level_1'];
                    } else {
                        coeff = gamedata['player_xp']['buildings'][unit.spec['name']];
                    }
                    xp_amount += Math.floor(coeff * res_amount);
                }
            }
        }
        if(xp_amount > 0) {
            feature_list.push('xp');
        }
    }

    // remove duplicates
    goog.array.removeDuplicates(feature_list);

    var item_host_building = null;
    if(tech && tech['associated_item']) {
        // is it a building equip item (e.g. minefield or turret head)?
        // if so, grab modchains from a relevant building so we show the applicable modstats
        var item_name = get_leveled_quantity(tech['associated_item'], Math.min(new_level, max_level));
        var item_spec = ItemDisplay.get_inventory_item_spec(item_name);
        if('equip' in item_spec) {
            item_host_building = find_any_compatible_building(item_spec);
        }
    }

    // mod techs and enhancements need to show stats for "Level 0" unresearched state
    var show_level_0 = (tech && (tech['affects_unit'] || tech['enhancement_category']));

    var grid_y = 0;
    var delta_color = SPUI.make_colorv(dialog.data['widgets']['col0,']['delta_color']);

    function feature_widget(dialog, y, x) { return dialog.widgets['col'+x.toString()+','+y.toString()]; }

    var max_rows = dialog.data['widgets']['col0,']['array'][1] + (equip_slots ? -1 : 0); // equip_slots cover last line

    dialog.widgets['feature_scroll_up'].show = dialog.widgets['feature_scroll_down'].show = (feature_list.length > max_rows);
    if(dialog.widgets['feature_scroll_up'].show) {
        dialog.user_data['feature_scroll'] = Math.max(Math.min(dialog.user_data['feature_scroll'], feature_list.length - max_rows), 0);
        dialog.widgets['feature_scroll_up'].state = (dialog.user_data['feature_scroll'] > 0 ? 'normal' : 'disabled');
        dialog.widgets['feature_scroll_down'].state = (dialog.user_data['feature_scroll'] < (feature_list.length-max_rows) ? 'normal' : 'disabled');
        dialog.widgets['feature_scroll_up'].onclick = function(w) { w.parent.user_data['feature_scroll'] -= 1; };
        dialog.widgets['feature_scroll_down'].onclick = function(w) { w.parent.user_data['feature_scroll'] += 1; };
    } else {
        dialog.user_data['feature_scroll'] = 0;
    }

    for(var i = dialog.user_data['feature_scroll']; i < feature_list.length; i++) {

        if(grid_y >= max_rows) {
            //console.log("ran out of space to list features! need " + feature_list.length.toString());
            break;
        }
        var stat_name = feature_list[i];

        if(stat_name == 'xp') {
            // special case for XP gain
            feature_widget(dialog, grid_y, 0).show = true;
            if (stats_when_busy) {
                feature_widget(dialog, grid_y, 0).show = false;
            }
            feature_widget(dialog, grid_y, 0).str = gamedata['strings']['modstats']['stats']['xp']['ui_name'];
            feature_widget(dialog, grid_y, 0).tooltip.str = (enable_tooltip ? gamedata['strings']['modstats']['stats']['xp']['ui_tooltip'] : null);
            var xp_col = (new_level == 1 ? 1 : 2);
            feature_widget(dialog, grid_y, (xp_col == 1 ? 2 : 1)).show = false;
            feature_widget(dialog, grid_y, xp_col).show = true;
            if (stats_when_busy) {
                feature_widget(dialog, grid_y, xp_col).show = false;
            }
            feature_widget(dialog, grid_y, xp_col).str = '+'+pretty_print_number(xp_amount)+' XP';
            feature_widget(dialog, grid_y, xp_col).text_color = delta_color;
            feature_widget(dialog, grid_y, xp_col).tooltip.str = (enable_tooltip ? gamedata['strings']['modstats']['stats']['xp']['ui_tooltip'] : null);
        } else {

        var spec = null;
        var old_chain_level = old_level, new_chain_level = new_level; // levels for the (spec's) stats at the base of the modchain

        // levels keying the auto_spell stats we are displaying
        // will be the same in most cases, except when weapon_level is set by a modstat (i.e. turret heads)

        // XXX - I'm not sure this is correct anymore; in the case where 'tech' is a turret head level-enabling tech,
        // we want the spell levels to correspond to old/new_level, not the unit's modded weapon_level!

        var old_spell_level, new_spell_level;
        if(unit && unit.is_building() && unit.modstats['weapon_level']) {
            old_spell_level = ModChain.get_stat(unit.modstats['weapon_level'], unit.level);
            // are we looking at a tech that affects weapon_level, or something else?
            if(tech && tech['associated_item'] &&
               get_auto_spell_for_item(ItemDisplay.get_inventory_item_spec(get_leveled_quantity(tech['associated_item'], Math.min(new_level, max_level))))) {
                // this tech (presumably) affects the weapon level, so show increases
                new_spell_level = Math.min(new_level, max_level);
            } else {
                // something else - do not show improvement in spell level
                new_spell_level = old_spell_level;
            }
        } else {
            old_spell_level = old_level;
            new_spell_level = new_level;
        }

        if(!tech) {
            spec = unit.spec;
        } else if('associated_unit' in tech) {
            spec = gamedata['units'][tech['associated_unit']];
        } else if('affects_unit' in tech) {
            spec = gamedata['units'][tech['affects_unit']];
            // modchain base stats should be derived from the unit's level, not the mod tech's level
            old_chain_level = new_chain_level = old_spell_level = new_spell_level = Math.max(player.tech[spec['level_determined_by_tech']] || 0, 1);
        } else if('associated_item' in tech) {
            spec = ItemDisplay.get_inventory_item_spec(get_leveled_quantity(tech['associated_item'], Math.min(new_level, max_level))); // note! doesn't handle item type changing!
        } else if('associated_building' in tech) {
            spec = gamedata['buildings'][tech['associated_building']];
        } else if('enhance_time' in tech) {
            spec = unit.spec;
            // modchain base stats should be derived from the host building's level, not the mod tech's level
            old_chain_level = new_chain_level = unit.level;
        } else {
            throw Error('cannot display feature '+stat_name+' for upgrade that has no building or associated unit or item');
        }

        var modchain = null;
        if(!tech) {
            modchain = unit.modstats[stat_name] || null;
        } else if('associated_unit' in tech) {
            modchain = (player.stattab['units'][tech['associated_unit']] || {})[stat_name] || null;
        } else if('affects_unit' in tech) {
            modchain = (player.stattab['units'][tech['affects_unit']] || {})[stat_name] || null;
        } else if('associated_item' in tech) {
            // is it a building equip item (e.g. minefield or turret head)?
            // if so, grab modchains from a relevant building so we show the applicable modstats
            if(item_host_building && item_host_building.modstats[stat_name]) {
                modchain = item_host_building.modstats[stat_name];
            }
        } else if('enhance_time' in tech) {
            modchain = unit.modstats[stat_name] || null;
        }

        var old_chain = null, new_chain = null;
        if(old_level > 0 || show_level_0) {
            old_chain = modchain;
        }

        if(new_level <= max_level) {
            // make a version of the chain that shows improvements at next level
            var new_base_value = ModChain.get_base_value(stat_name, spec, new_chain_level);
            new_chain = (modchain ? ModChain.recompute_with_new_base_val(modchain, new_base_value, new_chain_level) : ModChain.make_chain(new_base_value, {'level':new_chain_level}));
        }

        // some special cases that rebase mod chains
        var rebase_old = null, rebase_new = null;

        // special case to conceal absolute harvester rates
        if(stat_name.indexOf('produces_') === 0 && (gamedata['strings']['modstats']['stats'][stat_name]['display_value'] || 'relative') == 'relative') {
            var one = get_leveled_quantity(spec[stat_name], 1);
            if(old_level > 0) { rebase_old = get_leveled_quantity(spec[stat_name], old_level) / one; }
            if(new_level <= max_level) { rebase_new = get_leveled_quantity(spec[stat_name], new_level) / one; }
        // special case to rebase deployable unit space
        } else if(stat_name == 'deployable_unit_space') {
            if(old_level > 0) { rebase_old = Math.floor(gamedata['deployable_unit_space']*get_leveled_quantity(spec['provides_space'], old_level)); }
            if(new_level <= max_level) { rebase_new = Math.floor(gamedata['deployable_unit_space']*get_leveled_quantity(spec['provides_space'], new_level)); }
        // special case to rebase maxvel, which is a scaling factor from the point of view of mods
        } else if(stat_name == 'maxvel') {
            if(old_level > 0) { rebase_old = get_leveled_quantity(spec[stat_name], old_level); }
            if(new_level <= max_level) { rebase_new = get_leveled_quantity(spec[stat_name], new_level); }
        }

        if(rebase_old !== null) { old_chain = (old_chain ? ModChain.recompute_with_new_base_val(old_chain, rebase_old, old_chain_level) : ModChain.make_chain(rebase_old, {'level':old_chain_level})); }
        if(rebase_new !== null) { new_chain = (new_chain ? ModChain.recompute_with_new_base_val(new_chain, rebase_new, new_chain_level) : ModChain.make_chain(rebase_new, {'level':new_chain_level})); }

        // incorporate effects of permanent modstats
        // actually, just project what will happen at new_chain_level, since
        // current modstat chain should already include the current-level effects
        if(spec['permanent_modstats']) {
            var pm_list = spec['permanent_modstats'];

            if(new_level <= max_level) {
                if(pm_list.length >= 1 && (Array.isArray(pm_list[0]) || pm_list[0] === null)) {
                    pm_list = get_leveled_quantity(pm_list, new_level);
                }
                goog.array.forEach(pm_list, function(pm) {
                    if(pm['stat'] === stat_name) {
                        var method = pm['method'];
                        var kind = spec['kind'] || null;
                        var source = spec['name'];
                        // update new_chain (old_chain should already reflect the right values)
                        if(!new_chain) {
                            new_chain = ModChain.make_chain(ModChain.get_base_value(stat_name, spec, new_chain_level), {'level':new_chain_level});
                        }
                        new_chain = ModChain.add_or_replace_mod(new_chain, method, get_leveled_quantity(pm['strength'], new_level), kind, source, {'level':new_level});
                    }
                });
            }
        }

        // incorporate effects of mod techs and enhancements
        if(tech && (tech['affects_unit'] || tech['enhancement_category'])) {
            var effect = tech['effects'][0];
            var method = effect['method'];
            var kind = (tech['enhancement_category'] ? 'enhancement' : 'tech');
            var source = tech['name'];
            if(old_level > 0) {
                if(!old_chain) {
                    old_chain = ModChain.make_chain(ModChain.get_base_value(stat_name, spec, old_chain_level), {'level':old_chain_level});
                }
                old_chain = ModChain.add_or_replace_mod(old_chain, method, get_leveled_quantity(effect['strength'], old_level), kind, source, {'level':old_level});
            }
            if(new_level <= max_level) {
                if(!new_chain) {
                    new_chain = ModChain.make_chain(ModChain.get_base_value(stat_name, spec, new_chain_level), {'level':new_chain_level});
                }
                new_chain = ModChain.add_or_replace_mod(new_chain, method, get_leveled_quantity(effect['strength'], new_level), kind, source, {'level':new_level});
            }
        }

        var new_column = -1;
        var old_auto_spell, new_auto_spell;
        if(tech) {
            if('associated_unit' in tech || 'affects_unit' in tech) {
                old_auto_spell = new_auto_spell = get_auto_spell_for_unit(player, spec);
            } else if('associated_item' in tech) {
                old_auto_spell = get_auto_spell_for_item(ItemDisplay.get_inventory_item_spec(get_leveled_quantity(tech['associated_item'], Math.max(1,old_level))));
                new_auto_spell = get_auto_spell_for_item(ItemDisplay.get_inventory_item_spec(get_leveled_quantity(tech['associated_item'], Math.min(new_level,max_level))));
            } else if('associated_building' in tech || 'enhance_time' in tech) {
                old_auto_spell = new_auto_spell = null;
            } else {
                throw Error('cannot determine auto_spell for tech '+tech['name']);
            }
        } else {
            if(unit.is_building() && unit.modstats['weapon_level']) {
                // when showing stats that affect a mounted weapon,
                // show the _modifier version on the base object
                old_auto_spell = new_auto_spell = null;
            } else {
                old_auto_spell = new_auto_spell = unit.get_auto_spell();
            }
        }

        feature_widget(dialog, grid_y, 0).show = true;
        ModChain.display_label_widget(feature_widget(dialog, grid_y, 0), stat_name, old_auto_spell, enable_tooltip);

        if(old_level <= 0 && !show_level_0) {
            feature_widget(dialog, grid_y, 1).show = true;
            feature_widget(dialog, grid_y, 2).show = false;
            ModChain.display_widget(feature_widget(dialog, grid_y, 1), stat_name, new_chain, spec, new_chain_level, new_auto_spell, new_spell_level, enable_tooltip);
        } else if(stats_only || new_level > max_level || stats_when_busy) {
            feature_widget(dialog, grid_y, 1).show = true;
            feature_widget(dialog, grid_y, 2).show = false;
            ModChain.display_widget(feature_widget(dialog, grid_y, 1), stat_name, old_chain, spec, old_chain_level, old_auto_spell, old_spell_level, enable_tooltip);
        } else {
            feature_widget(dialog, grid_y, 1).show = true;
            feature_widget(dialog, grid_y, 2).show = true;
            ModChain.display_widget(feature_widget(dialog, grid_y, 1), stat_name, old_chain, spec, old_chain_level, old_auto_spell, old_spell_level, enable_tooltip);
            ModChain.display_widget(feature_widget(dialog, grid_y, 2), stat_name, new_chain, spec, new_chain_level, new_auto_spell, new_spell_level, enable_tooltip); // sets text color
            if(feature_widget(dialog, grid_y, 2).str != feature_widget(dialog, grid_y, 1).str) {
                feature_widget(dialog, grid_y, 2).text_color = delta_color;
            }
        }
        }

        // status bar/buttons for mod techs and enhancements
        var mod_tech = null;
        var enh_tech = null;

        if(tech) {
            mod_tech = get_mod_techs_for_tech_by_stat_name(tech['name'])[stat_name] || null;
        } else if(unit && unit.is_building() && unit.spec['enhancement_categories']) {
            enh_tech = get_enhancements_for_categories_by_stat_name(unit.spec['enhancement_categories'])[stat_name] || null;
        }

        dialog.widgets['mod_bar'+grid_y.toString()].show =
            dialog.widgets['mod_text'+grid_y.toString()].show = !!(mod_tech || enh_tech);
        dialog.widgets['mod_button'+grid_y.toString()].show = (!stats_only && dialog.widgets['mod_bar'+grid_y.toString()].show);
        dialog.widgets['secteam_behavior_button'+grid_y.toString()].show = (unit && unit.is_building() && (stat_name === 'on_destroy' || stat_name === 'on_approach' || stat_name === 'on_damage'));
        if (dialog.widgets['secteam_behavior_button'+grid_y.toString()].show && dialog.widgets['mod_button'+grid_y.toString()].show) {
            dialog.widgets['secteam_behavior_button'+grid_y.toString()].xy[0] = dialog.data['widgets']['secteam_behavior_button']['mod_showing_xy'][0];
        } else {
            dialog.widgets['secteam_behavior_button'+grid_y.toString()].xy[0] = dialog.data['widgets']['secteam_behavior_button']['xy'][0];
        }
        if(dialog.widgets['secteam_behavior_button'+grid_y.toString()].show) {
            var cur_config = (unit.config ? goog.object.clone(unit.config) : {});
            var cur_behavior, cur_behavior_ui_name = null;
            var config_key = stat_name + '_behavior';
            if(!cur_config[config_key]){
                cur_config[config_key] = {'name':'secteam_default'};
            }
            cur_behavior = cur_config[config_key]['name'];
            dialog.widgets['secteam_behavior_button'+grid_y.toString()].bg_image = dialog.data['widgets']['secteam_behavior_button'][cur_behavior + '_image'];
            if('secteam_behaviors' in gamedata['strings']['modstats']) {
                cur_behavior_ui_name = gamedata['strings']['modstats']['secteam_behaviors'][cur_behavior];
            } else {
                cur_behavior_ui_name = {'secteam_default':'Default','secteam_hold':'Hold','secteam_aggressive':'Relentless'}[cur_behavior];
            }
            dialog.widgets['secteam_behavior_button'+grid_y.toString()].tooltip.str = dialog.data['widgets']['secteam_behavior_button']['ui_tooltip'].replace('%cur', cur_behavior_ui_name);
            var next_behavior = {'secteam_default':'secteam_hold','secteam_hold':'secteam_aggressive','secteam_aggressive':'secteam_default'}[cur_behavior];
            var next_ai_state = {'secteam_default':4,'secteam_hold':2,'secteam_aggressive':null}[cur_behavior];
            var next_ai_aggressive = {'secteam_default':0,'secteam_hold':1,'secteam_aggressive':null}[cur_behavior];
            dialog.widgets['secteam_behavior_button'+grid_y.toString()].onclick = (function (_unit, _cur_config, _config_key, _next_behavior, _next_ai_state, _next_ai_aggressive) { return function(w) {
                var new_config = goog.object.clone(_cur_config);
                new_config[_config_key] = {'name': _next_behavior,'ai_state':_next_ai_state, 'ai_aggressive':_next_ai_aggressive};
                send_to_server.func(["CAST_SPELL", _unit.id, "CONFIG_SET", new_config]);
                // client-side predict
                _unit.config = new_config;
                _unit.request_sync();
            }; })(unit, cur_config, config_key, next_behavior, next_ai_state, next_ai_aggressive);
        }

        if(mod_tech || enh_tech) {
            // handler for click on "Modify" button
            var mod_onclick = (function (_unit, _mod_tech, _enh_tech) { return function(w) {
                if(_mod_tech) {
                    invoke_upgrade_tech_dialog(_mod_tech['name']);
                } else if(_enh_tech) {
                    invoke_upgrade_enhancement_dialog(_unit, _enh_tech['name']);
                }
            }; })(unit, mod_tech, enh_tech);

            var mod_text_mode = 'ui_name';
            var mod_text_color = 'text_color';

            var cur_mod_level, max_mod_level;
            if(mod_tech) {
                cur_mod_level = player.tech[mod_tech['name']]||0;
                max_mod_level = get_max_ui_level(mod_tech);
            } else if(enh_tech) {
                cur_mod_level = unit.enhancements ? unit.enhancements[enh_tech['name']]||0 : 0;
                max_mod_level = get_max_ui_level(enh_tech);
            }

            if(cur_mod_level >= max_mod_level) {
                mod_text_mode = 'ui_name_maxed';
                mod_text_color = 'text_color_maxed';
            } else if(builder && (builder.is_damaged() || builder.time_until_finish() > 0)) {
                if(mod_tech && builder.research_item === mod_tech['name']) {
                    mod_text_mode = 'ui_name_busy';
                    mod_text_color = 'text_color_busy';
                    mod_onclick = (function (_builder) { return function(w) {
                        change_selection_unit(_builder);
                        invoke_child_speedup_dialog('research');
                    }; })(builder);
                } else if(enh_tech && unit && unit.is_enhancing() && unit.enhancing['enhance']['spec'] === enh_tech['name']) {
                    mod_text_mode = 'ui_name_busy';
                    mod_text_color = 'text_color_busy';
                    mod_onclick = (function (_builder) { return function(w) {
                        change_selection_unit(_builder);
                        invoke_child_speedup_dialog('enhance');
                    }; })(builder);
                } else {
                    mod_text_mode = 'ui_name_other_busy';
                    mod_text_color = 'text_color_other_busy';
                }
            }

            dialog.widgets['mod_button'+grid_y.toString()].onclick =
                dialog.widgets['mod_text'+grid_y.toString()].onclick = mod_onclick;
            dialog.widgets['mod_text'+grid_y.toString()].str = dialog.data['widgets']['mod_text'][mod_text_mode].replace('%cur', cur_mod_level.toString()).replace('%max', max_mod_level.toString());
            dialog.widgets['mod_text'+grid_y.toString()].text_color = SPUI.make_colorv(dialog.data['widgets']['mod_text'][mod_text_color]);
            dialog.widgets['mod_bar'+grid_y.toString()].progress = cur_mod_level / max_mod_level;
            dialog.widgets['mod_button'+grid_y.toString()].tooltip.str = (enable_tooltip ? dialog.data['widgets']['mod_button']['ui_tooltip'] : null);
        }

        grid_y += 1;
    }
    while(grid_y < max_rows) {
        feature_widget(dialog, grid_y, 0).show =
            feature_widget(dialog, grid_y, 1).show =
            feature_widget(dialog, grid_y, 2).show = false;
        dialog.widgets['mod_bar'+grid_y.toString()].show =
            dialog.widgets['mod_text'+grid_y.toString()].show =
            dialog.widgets['mod_button'+grid_y.toString()].show = false;
        grid_y += 1;
    }

    if(feature_list.length < 1) {
        dialog.widgets['header0'].show =
            dialog.widgets['header1'].show = false;
    } else if(old_level <= 0 && !show_level_0) {
        dialog.widgets['header0'].str = dialog.widgets['header0'].data[(tech && tech['affects_unit']) ? 'ui_name_mod' : 'ui_name'].replace('%d', new_level);
        dialog.widgets['header1'].show = false;
    } else if(stats_only || new_level > max_level || stats_when_busy) {
        dialog.widgets['header0'].str = dialog.widgets['header0'].data[(old_level <= 0 ? 'ui_name_unmodified' : (tech && tech['affects_unit']) ? 'ui_name_mod' : 'ui_name')].replace('%d', old_level);
        dialog.widgets['header1'].show = false;
    } else {
        dialog.widgets['header0'].str = dialog.widgets['header0'].data[(old_level <= 0 ? 'ui_name_unmodified' : (tech && tech['affects_unit']) ? 'ui_name_mod' : 'ui_name')].replace('%d', old_level);
        dialog.widgets['header1'].str = dialog.widgets['header1'].data[(tech && tech['affects_unit']) ? 'ui_name_mod' : 'ui_name'].replace('%d', new_level);
        if(unit && unit.spec['name'] == gamedata['townhall']) {
            dialog.widgets['upgrade_info_button'].show = true;
            dialog.widgets['upgrade_info_button'].onclick = function(w) { invoke_cc_upgrade_info(); };
        }
    }

    // optional webstats link
    dialog.widgets['webstats_button'].show = false;
    if(!dialog.widgets['upgrade_info_button'].show) {
        var webstats_template = eval_cond_or_literal(gamedata['strings']['webstats_url'] || null, player, null);
        if(webstats_template) {
            var webstats_url = null;
            if(!tech && unit && unit.is_building()) {
                // building upgrade
                webstats_url = webstats_template.replace('%kind', 'buildings').replace('%spec', unit.spec['name']);
            } else if(tech && tech['associated_unit']) {
                webstats_url = webstats_template.replace('%kind', 'units').replace('%spec', tech['associated_unit']);
            } else if(tech && (techname in gamedata['tech'])) {
                webstats_url = webstats_template.replace('%kind', 'tech').replace('%spec', tech['name']);
            } else if(tech && (techname in gamedata['enhancements'])) {
                webstats_url = webstats_template.replace('%kind', 'enhancements').replace('%spec', tech['name']);
            }
            if(webstats_url) {
                dialog.widgets['webstats_button'].show = true;
                dialog.widgets['webstats_button'].onclick = (function(_url) { return function(w) {
                    url_open_in_new_tab(_url);
                }; })(webstats_url);
            }
        }
    }

    // set up equipment widgets
    if(equip_slots) {
            equip_slots = get_leveled_quantity(equip_slots, Math.max(old_level, 1));
            var last_label = null, slot_i = 0;

            for(var type_name in equip_slots) {
                if(!player.is_cheater &&
                   ((('show' in gamedata['strings']['equip_slots'][type_name]) &&
                     !gamedata['strings']['equip_slots'][type_name]['show']) ||
                    (('show_if' in gamedata['strings']['equip_slots'][type_name]) &&
                    !read_predicate(gamedata['strings']['equip_slots'][type_name]['show_if']).is_satisfied(player,null)))) {
                    continue;
                }
                var n_slots = get_leveled_quantity(equip_slots[type_name], Math.max(old_level, 1));
                var max_slots = get_leveled_quantity(equip_slots[type_name], max_level);
                var n = 0;
                for(; n < n_slots; n++) {
                    if(slot_i >= dialog.data['widgets']['equip_slot']['array'][0]) { break; }

                    if(type_name != last_label) {
                        dialog.user_data['equip_slots_by_type'][type_name] = slot_i;
                        dialog.widgets['equip_type'+slot_i].show = true;
                        dialog.widgets['equip_type'+slot_i].str = gamedata['strings']['equip_slots'][type_name]['ui_name']+':';
                        last_label = type_name;
                    }

                    dialog.widgets['equip_slot'+slot_i].show =
                        dialog.widgets['equip_frame'+slot_i].show = true;

                    dialog.widgets['equip_slot'+slot_i].state = (stats_only ? 'disabled' : 'normal');
                    dialog.widgets['equip_slot'+slot_i].tooltip.str = null;

                    dialog.widgets['equip_frame'+slot_i].onclick = (function (_tech, _unit, _type_name, _n, _slot_i) { return function(w) {
                        // check for in-flight requests
                        if(tech) {
                            if(player.unit_equipment[tech['associated_unit']] &&
                               player.unit_equipment[tech['associated_unit']]['equip_pending']) { return; }
                        } else {
                            if(_unit.equip_pending) { return; }
                        }

                        // kill item tooltip
                        invoke_inventory_context(w.parent, w, -1, null, false);
                        var error = null;
                        if(player.warehouse_is_busy()) {
                            error = gamedata['errors']["WAREHOUSE_IS_BUSY"];
                        } else if(!tech &&
                                  (_unit.is_damaged() ||
                                   _unit.is_busy())) {
                            error = gamedata['errors']["CANNOT_EQUIP_BUILDING_WHILE_BUSY"];
                        }
                        if(error) {
                            invoke_child_message_dialog(error['ui_title'], error['ui_name'], {'dialog': 'message_dialog_big'});
                        } else {
                            invoke_equip_chooser_dialog(w.parent, w, _tech, _unit, _type_name, _n, _slot_i);
                        }
                    }; })(tech, unit, type_name, n, slot_i);

                    slot_i++;
                }
                for(; n < max_slots; n++) {
                    if(slot_i >= dialog.data['widgets']['equip_slot']['array'][0]) { break; }

                    if(type_name != last_label) {
                        dialog.user_data['equip_slots_by_type'][type_name] = slot_i;
                        dialog.widgets['equip_type'+slot_i].show = true;
                        dialog.widgets['equip_type'+slot_i].str = gamedata['strings']['equip_slots'][type_name]['ui_name']+':';
                        last_label = type_name;
                    }

                    var unlocks_at = old_level;
                    for(var l = old_level; l <= max_level; l++) {
                        if(get_leveled_quantity(equip_slots[type_name], l) >= n+1) {
                            unlocks_at = l;
                            break;
                        }
                    }
                    dialog.widgets['equip_frame'+slot_i].show =
                        dialog.widgets['equip_item'+slot_i].show = false;
                    dialog.widgets['equip_slot'+slot_i].state = 'locked';
                    dialog.widgets['equip_slot'+slot_i].show = true;
                    dialog.widgets['equip_slot'+slot_i].onclick = null;
                    dialog.widgets['equip_slot'+slot_i].tooltip.str = (enable_tooltip ? dialog.data['widgets']['equip_slot']['ui_tooltip_unlocks_at'].replace('%d', unlocks_at.toString()) : null);
                    slot_i++;
                }
            }
    }

    // set up damage_vs icons
    if(!tech) {
        // note: not unit.get_auto_spell(), since that includes equipped item mods
        var spell = get_auto_spell_raw(unit.spec);
        init_damage_vs_icons(dialog, unit.spec, spell);
    } else if(tech['associated_unit']) {
        init_damage_vs_icons(dialog, gamedata['units'][tech['associated_unit']], get_auto_spell_for_unit(player, gamedata['units'][tech['associated_unit']]));
    } else if(tech['associated_item']) {
        var spell = get_auto_spell_for_item(ItemDisplay.get_inventory_item_spec(get_leveled_quantity(tech['associated_item'],Math.min(new_level, max_level))));
        init_damage_vs_icons(dialog, {'name': tech['name'], 'kind':'building', 'ui_damage_vs':{}}, // fake building spec to fool init_damage_vs_icons()
                             spell); // spell's ui_damage_vs will take precedence
    } else {
        init_damage_vs_icons(dialog, null, null);
    }

    // shift damage_vs icons over to make room for mod display
    if(tech && player.get_any_abtest_value('enable_mod_techs', gamedata['enable_mod_techs'])) {
        for(var i = 0; i < dialog.data['widgets']['damage_vs']['array'][0]; i++) {
            var w = dialog.widgets['damage_vs'+i.toString()];
            w.xy[0] = dialog.data['widgets']['damage_vs']['xy'][0] + i*dialog.data['widgets']['damage_vs']['array_offset'][0] + dialog.data['widgets']['icon']['mod_shift'][0];
        }
        dialog.widgets['damage_vs_label'].xy = vec_add(dialog.data['widgets']['damage_vs_label']['xy'], dialog.data['widgets']['icon']['mod_shift']);
    }

    // get tech requirements
    var req_spec = {'predicate': 'ALWAYS_TRUE'};
    if(tech) {
        if('requires' in tech) {
            req_spec = tech['requires'];
        }
    } else {
        if('requires' in unit.spec) {
            req_spec = unit.spec['requires'];
        }
    }

    dialog.widgets['predicate_help_button'].show = false;

    var show_complete_reqs = true;
    var builder_blocks_upgrade = false;

    if(stats_only) {
        // do nothing
        show_complete_reqs = false;
    }
    if(show_complete_reqs && new_level > max_level) {
        req.push(gamedata['errors']['MAX_LEVEL_REACHED']['ui_name']);
        show_complete_reqs = false;
    }
    if(show_complete_reqs && stats_when_busy) {
        req.push(gamedata['errors']['STATS_WHILE_UPGRADING']['ui_name']);
        show_complete_reqs = false;
    }
    if(!builder_blocks_upgrade && show_complete_reqs && builder && builder.is_damaged()) {
        builder_blocks_upgrade = true;
        // builder needs repair
        dialog.widgets['predicate_help_button'].show = true;
        dialog.widgets['predicate_help_button'].onclick = function(w) {
            var dialog = w.parent;
            change_selection_unit(dialog.user_data['builder']);
            if(selection.unit.is_repairing()) {
                invoke_child_speedup_dialog('speedup');
            } else {
                invoke_child_repair_dialog();
            }
        };
    }
    if(!builder_blocks_upgrade && show_complete_reqs && builder && (builder.time_until_finish() > 0)) {
        builder_blocks_upgrade = true;
        // builder is busy
        dialog.widgets['predicate_help_button'].show = true;
        dialog.widgets['predicate_help_button'].onclick = function(w) {
            var dialog = w.parent;
            change_selection_unit(dialog.user_data['builder']);
            invoke_child_speedup_dialog('speedup');
        };
    }
    if(show_complete_reqs && req_spec && !player.is_cheater) {
        var pred_raw = get_leveled_quantity(req_spec, new_level);

        // add requirement for enhancement host building level
        if(tech && unit && 'min_host_level' in tech) {
            var req_host_level = get_leveled_quantity(tech['min_host_level'], new_level);
            if(unit.level < req_host_level) {
                pred_raw = {'predicate': 'AND', 'subpredicates': [
                    pred_raw,
                    {'predicate': 'BUILDING_LEVEL', 'building_type': unit.spec['name'], 'trigger_level': req_host_level,
                     'obj_id': unit.id}]};
            }
        }

        var pred = read_predicate(pred_raw);
        var text = pred.ui_describe(player);  // XXX make ui_describe return a list
        if(text) {
            req.push(text);
            use_resources_requirements_ok = instant_requirements_ok = false;
            if (!builder_blocks_upgrade){
                var helper = get_requirements_help(pred, null);
                dialog.widgets['predicate_help_button'].show = !!helper;
                dialog.widgets['predicate_help_button'].onclick = helper;
            }
        }
    }

    // check for ingredients
    var ingr_list = [];
    if(!stats_only && new_level <= max_level) {
        if(tech && ('enhance_time' in tech)) {
            ingr_list = get_enhancement_ingredients_list(tech, new_level);
        } else if(tech) {
            ingr_list = get_tech_ingredients_list(tech, new_level);
        } else {
            ingr_list = get_building_ingredients_list(unit.spec, new_level);
        }
    }
    ItemDisplay.display_item_array(dialog, 'requirements_item', ingr_list, {hide_tooltip: true});
    var ingr_by_specname = {};
    for(var i = 0; i < dialog.data['widgets']['requirements_item']['array'][0]; i++) {
        if(i < ingr_list.length) {
            var ingr = ingr_list[i];
            var ingr_spec = gamedata['items'][ingr['spec']];
            var ingr_stack = ('stack' in ingr ? ingr['stack'] : 1);
            var ingr_level = ('level' in ingr ? ingr['level'] : null);
            var ui_ingr = ItemDisplay.get_inventory_item_stack_prefix(ingr_spec, ingr_stack) + ItemDisplay.get_inventory_item_ui_name_long(ingr_spec, ingr_level);
            dialog.widgets['requirements_item'+i.toString()].widgets['frame'].tooltip.str =
                dialog.data['widgets']['requirements_item']['ui_tooltip'].replace('%ITEM', ui_ingr);

            // group items by spec/level for the tooltip
            var key = ingr['spec'];
            if(ingr_level) { key += ':L'+ingr_level.toString(); }

            var has_it = player.inventory_item_quantity(ingr['spec'], ingr['level']) - (ingr_by_specname[key] || 0) >= ingr_stack;
            ingr_by_specname[key] = (ingr_by_specname[key]||0) + ingr_stack;
            dialog.widgets['requirements_item'+i.toString()].widgets['frame'].state = (has_it ? 'normal_nohighlight' : 'disabled');
            dialog.widgets['requirements_item_status'+i.toString()].show = true;
            dialog.widgets['requirements_item_status'+i.toString()].color = SPUI.make_colorv(dialog.data['widgets']['requirements_item_status'][(has_it ? 'color_present' : 'color_missing')]);

            if(!has_it) {
                req.push(dialog.data['widgets']['requirements_item']['ui_tooltip'].replace('%ITEM', ui_ingr));
                use_resources_requirements_ok = instant_requirements_ok = false;

                if(!dialog.widgets['predicate_help_button'].show) {
                    var helper = (function(_spec, _qty) { return function() {
                        var s = gamedata['errors']['INSUFFICIENT_ITEMS'];
                        invoke_child_message_dialog(s['ui_title'], s['ui_name'].replace('%s',_spec['ui_name_plural'] || _spec['ui_name']).replace('%d',pretty_print_number(_qty)), {'dialog': 'message_dialog_big'});
                    }; })(ingr_spec, ingr_stack);
                    dialog.widgets['predicate_help_button'].show = true;
                    dialog.widgets['predicate_help_button'].onclick = helper;
                }
            }
        } else {
            dialog.widgets['requirements_item_status'+i.toString()].show = false;
        }
    }

    dialog.widgets['requirements_text'].set_text_with_linebreaking(req.join(', '));

    for(var i = 0; i < req.length; i++) {
        tooltip_req_instant.push(req[i]);
        tooltip_req_use_resources.push(req[i]);
    }
    for(var i = 0; i < ui_resources_needed.length; i++) {
        tooltip_req_use_resources.push(ui_resources_needed[i]);
    }
    if(tooltip_req_instant.length > 0) { tooltip_req_instant.splice(0, 0, dialog.data['widgets']['use_resources_button']['ui_tooltip_unmet']); }
    if(tooltip_req_use_resources.length > 0) { tooltip_req_use_resources.splice(0, 0, dialog.data['widgets']['use_resources_button']['ui_tooltip_unmet']); }


    var flavor_text;
    if(tech) {
        if(tech['ui_description']) {
            flavor_text = tech['ui_description'];
        } else if(tech['associated_unit']) {
            flavor_text = gamedata['units'][tech['associated_unit']]['ui_description'] || '';
        } else {
            flavor_text = '';
        }
    } else {
        flavor_text = unit.spec['ui_description'] || '';
    }
    dialog.widgets['flavor_text'].set_text_with_linebreaking(get_leveled_quantity(flavor_text, Math.min(new_level, max_level)));

    // connect button widget onclick() handlers

    if(stats_only || new_level > max_level) {
        // hide all buttons
        dialog.widgets['instant_button'].show = dialog.widgets['instant_credits'].show = dialog.widgets['use_resources_button'].show = false;
        // note: timer bar already hidden above
    } else if (stats_when_busy) {
        // hide resources, but show instant buy button
        dialog.widgets['use_resources_button'].show = false;
        dialog.widgets['instant_button'].show = dialog.widgets['instant_credits'].show = true;
        dialog.widgets['instant_button']['ui_name'] = gamedata['spells']['SPEEDUP_FOR_MONEY']['ui_name'];
        dialog.widgets['instant_button'].spellname = 'SPEEDUP_FOR_MONEY';
        dialog.widgets['instant_button'].onclick = (function (_builder) { return function() {change_selection_unit(_builder); invoke_speedup_dialog('speedup');}; })(builder)
        var instant_price = Store.get_user_currency_price(builder.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null)
        dialog.widgets['instant_credits'].str = Store.display_user_currency_price(instant_price);
        dialog.widgets['instant_credits'].tooltip.str = Store.display_user_currency_price_tooltip(instant_price);
    } else {
        dialog.widgets['instant_button'].show = dialog.widgets['instant_credits'].show = dialog.widgets['use_resources_button'].show = true;

    // ! block below is deliberately one indent left to minimize diff

    // "Use Resources" button
    dialog.widgets['use_resources_button'].show = use_resources_offered;
    dialog.widgets['use_resources_button'].tooltip.str = null;

    var upgrade_func; // function to actually perform the (non-paid) upgrade
    if(tech) {
        upgrade_func = (function (_dialog) { return function() {
            // tell the server to research this tech
            var builder = _dialog.user_data['builder'] || null;
            if(builder) {
                var tech = _dialog.user_data['tech'];
                if('enhance_time' in tech) {
                    var cur_level = builder.enhancements ? builder.enhancements[tech['name']] || 0 : 0;
                    var ingr_list = get_enhancement_ingredients_list(tech, cur_level+1);
                    var do_it = (function (__dialog, _builder, _name, _level) { return function() {
                        send_to_server.func(["CAST_SPELL", _builder.id, "ENHANCE_FOR_FREE", _name, _level]);
                        invoke_ui_locker(_builder.request_sync(), (function (__dialog) { return function() { close_dialog(__dialog); }; })(_dialog));

                    }; })(_dialog, builder, tech['name'], cur_level+1);

                    if(ingr_list && ingr_list.length > 0 && !tech['refund_ingredients']) {
                        var s = gamedata['strings']['enhance_confirm_ingredient_loss'];
                        invoke_child_message_dialog(s['ui_title'], s['ui_description'],
                                                    {'cancel_button': true,
                                                     'ok_button_ui_name': s['ui_button'],
                                                     'on_ok': do_it});
                    } else {
                        do_it();
                    }
                } else {
                    send_to_server.func(["CAST_SPELL", builder.id, "RESEARCH_FOR_FREE", tech['name']]);
                    invoke_ui_locker(builder.request_sync(), (function (__dialog) { return function() { close_dialog(__dialog); }; })(_dialog));
                }
            } else {
                close_dialog(_dialog);
            }
        }; })(dialog);
    } else {
        upgrade_func = (function (_dialog) { return function() {
            var unit = _dialog.user_data['unit'];

            var do_upgrade_func = (function (__unit, __dialog) { return function() {
                // tell the server we want to upgrade this building
                send_to_server.func(["CAST_SPELL", __unit.id, "UPGRADE_FOR_FREE"]);

                // trigger effect
                var fx_data = ('upgrade_start_effect' in __unit.spec ?
                               __unit.spec['upgrade_start_effect'] :
                               gamedata['client']['vfx']['building_upgrade_start']);
                if(fx_data) {
                    session.get_real_world().fxworld.add_visual_effect_at_time([__unit.x,__unit.y], 0, [0,1,0], client_time, fx_data,
                                                   true, // !spec['worth_less_xp'], // no sound for barrier upgrades?
                                                   { '%OBJECT_SPRITE': __unit.get_leveled_quantity(__unit.spec['art_asset'])});
                }

                invoke_ui_locker(__unit.request_sync(), (function (___dialog) { return function() { close_dialog(___dialog); }; })(__dialog));
            }; })(unit, _dialog);

            var confirm = unit.spec['name']+'_confirm_upgrade';
            if(confirm in gamedata['strings'] &&
               (unit.spec['name'] == gamedata['region_map_building'] && !player.get_any_abtest_value('region_map_available_during_transmitter_upgrade',gamedata['territory']['region_map_available_during_transmitter_upgrade'])) ||
               (unit.spec['name'] == gamedata['inventory_building'] && !player.get_any_abtest_value('inventory_available_during_warehouse_upgrade', gamedata['inventory_available_during_warehouse_upgrade']))) {
                // confirmation dialog
                var s = gamedata['strings'][confirm];
                invoke_child_message_dialog(s['ui_title'], s['ui_description'],
                                            {'cancel_button': true,
                                             'ok_button_ui_name': s['ui_button'],
                                             'on_ok': do_upgrade_func});
            } else {
                do_upgrade_func();
            }
        }; })(dialog);
    }

    if(builder && !builder.is_in_sync()) {
        dialog.widgets['use_resources_button'].state = 'disabled';
    } else if(use_resources_requirements_ok && resources_ok) {
        dialog.widgets['use_resources_button'].state = 'normal';
        dialog.widgets['use_resources_button'].onclick = upgrade_func;
    } else {
        dialog.widgets['use_resources_button'].state = 'disabled';
        if(tooltip_req_use_resources.length > 0) {
            dialog.widgets['use_resources_button'].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['use_resources_button'].tooltip.str = (enable_tooltip ? tooltip_req_use_resources.join('\n') : null);
        }

        // search for appropriate "+" button to get help
        if(player.get_any_abtest_value('upgrade_dialog_clickhelp', gamedata['client']['upgrade_dialog_clickhelp'])) {
            var help_func = null;

            var HELPERS = ['predicate_help_button', 'resource_power_button'];
            for(var res in gamedata['resources']) {
                if('resource_'+res+'_button' in dialog.widgets) {
                    HELPERS.push('resource_'+res+'_button');
                }
            }
            for(var i = 0; i < HELPERS.length; i++) {
                var h = HELPERS[i];
                if(dialog.widgets[h].show) {
                    help_func = dialog.widgets[h].onclick;
                    break;
                }
            }

            var button_is_normal = false;

            if(!help_func && !resources_ok) {
                // try a resource basket
                // special case that leads to the "buy resources" dialog
                help_func = get_requirements_help('resources', resources_needed, {continuation:upgrade_func});

                // don't gray out the button if all resources can be topped-up
                var can_topup = true;
                for(var res in resources_needed) {
                    if(!gamedata['resources'][res]['allow_topup']) {
                        can_topup = false; break;
                    }
                }
                if(can_topup) { button_is_normal = true; }
            }

            if(help_func) {
                dialog.widgets['use_resources_button'].state = (button_is_normal ? 'normal' : 'disabled_clickable');
                dialog.widgets['use_resources_button'].onclick = help_func;
            }
        }
    }

    // "Instant" button
    var credit_check = -1; // only check if cost is <0
    if(tech && 'research_credit_cost' in tech) {
        credit_check = tech['research_credit_cost'];
    } else if(tech && 'research_gamebucks_cost' in tech) {
        credit_check = tech['research_gamebucks_cost'];
    } else if(tech && 'enhance_credit_cost' in tech) {
        credit_check = tech['enhance_credit_cost'];
    } else if(tech && 'enhance_gamebucks_cost' in tech) {
        credit_check = tech['enhance_gamebucks_cost'];
    } else if(unit && 'upgrade_credit_cost' in unit.spec) {
        credit_check = unit.spec['upgrade_credit_cost'];
    } else if(unit && 'upgrade_gamebucks_cost' in unit.spec) {
        credit_check = unit.spec['upgrade_gamebucks_cost'];
    }

    if(get_leveled_quantity(credit_check, new_level) < 0) {
        // instant upgrade not offered
        dialog.widgets['instant_button'].show = dialog.widgets['instant_credits'].show = false;
        dialog.default_button = dialog.widgets['use_resources_button'];

        if(dialog.widgets['use_resources_button'].state == 'normal') {
            // make use_resources_button yellow and default
            dialog.widgets['use_resources_button'].state = 'active';
        }
        // else if(dialog.widgets['use_resources_button'].state == 'disabled_clickable') {
        // dialog.widgets['use_resources_button'].state = 'normal'; ?
        // }
    } else {
        dialog.default_button = dialog.widgets['instant_button'];

    // ! block below is deliberately one indent left to minimize diff
    var price;
    if(tech) {
        if(builder || player.is_cheater) {
            var spell = gamedata['spells'][('enhance_time' in tech ? 'ENHANCE_FOR_MONEY' : 'RESEARCH_FOR_MONEY')];
            var spellarg = ('enhance_time' in tech ? [techname, new_level] : techname);
            price = Store.get_user_currency_price(builder ? builder.id : GameObject.VIRTUAL_ID, spell, spellarg);
        } else {
            price = -1;
        }
    } else {
        price = Store.get_user_currency_price(unit.id, gamedata['spells']['UPGRADE_FOR_MONEY'], null);
    }

    // just for diagnostics - price should always be -1 if requirements are not met
    if(!instant_requirements_ok && price >= 0 && !player.is_cheater) {
        console.log('requirements/price mismatch!');
    }

    widget = dialog.widgets['instant_credits'];
    widget.bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    widget.state = Store.get_user_currency();
    widget.str = Store.display_user_currency_price(price); // PRICE
    widget.tooltip.str = (enable_tooltip ? Store.display_user_currency_price_tooltip(price) : null);

    if(price < 0) {
        // cannot make a purchase because tech requirements are not fulfilled
        dialog.widgets['instant_credits'].onclick = null;
        dialog.widgets['instant_button'].state = 'disabled';
        if(tooltip_req_instant.length > 0) {
            dialog.widgets['instant_button'].tooltip.str = (enable_tooltip ? tooltip_req_instant.join('\n') : null);
            dialog.widgets['instant_button'].tooltip.text_color = SPUI.error_text_color;
        }

        if(player.get_any_abtest_value('upgrade_dialog_clickhelp', gamedata['client']['upgrade_dialog_clickhelp']) &&
           dialog.widgets['predicate_help_button'].show) {
            dialog.widgets['instant_button'].state = 'disabled_clickable';
            dialog.widgets['instant_credits'].onclick = dialog.widgets['instant_button'].onclick = dialog.widgets['predicate_help_button'].onclick;
        }

    } else if(price == 0) {
        dialog.widgets['instant_button'].state = 'normal';
        if(tech) {
            // if research is free, just do an RESEARCH_FOR_FREE followed by a SPEEDUP_FOR_FREE
            dialog.widgets['instant_credits'].onclick =
                dialog.widgets['instant_button'].onclick = function(w) {
                    var dialog = w.parent; if(!dialog) { return; }
                    var builder = dialog.user_data['builder'], techname = dialog.user_data['techname'], tech = dialog.user_data['tech'];
                    if(builder) {
                        if('enhance_time' in tech) {
                            send_to_server.func(["CAST_SPELL", builder.id, "ENHANCE_FOR_FREE", techname,
                                                 (builder.enhancements ? builder.enhancements[techname]||0 : 0) + 1]);
                        } else {
                            send_to_server.func(["CAST_SPELL", builder.id, "RESEARCH_FOR_FREE", techname]);
                        }
                        send_to_server.func(["CAST_SPELL", builder.id, "SPEEDUP_FOR_FREE"]);
                        builder.request_sync();
                    }
                    close_parent_dialog(w);
                };
        } else {
            // if upgrade is free, just do an UPGRADE_FOR_FREE followed by a SPEEDUP_FOR_FREE
            dialog.widgets['instant_credits'].onclick =
                dialog.widgets['instant_button'].onclick = function(w) {
                    var dialog = w.parent; if(!dialog) { return; }
                    var unit = dialog.user_data['unit'];
                    send_to_server.func(["CAST_SPELL", unit.id, "UPGRADE_FOR_FREE"]);
                    send_to_server.func(["CAST_SPELL", unit.id, "SPEEDUP_FOR_FREE"]);
                    unit.request_sync();
                    close_parent_dialog(w);
            };
        }
    } else {
        if(builder && !builder.is_in_sync()) {
            // waiting for server response
            dialog.widgets['instant_button'].state = 'disabled';
            dialog.widgets['instant_button'].str = dialog.data['widgets']['instant_button']['ui_name_pending'];
            dialog.widgets['instant_credits'].onclick = dialog.widgets['instant_button'].onclick = null;
        } else {
            dialog.widgets['instant_button'].state = 'normal';
            dialog.widgets['instant_button'].str = dialog.data['widgets']['instant_button']['ui_name'];

            var cleanup_cb = (function (_widget) { return function() {
                close_parent_dialog(_widget);
            }; })(widget);

            if(tech) {
                dialog.widgets['instant_credits'].onclick =
                    dialog.widgets['instant_button'].onclick = function(widget) {
                        var dialog = widget.parent; if(!dialog) { return; }
                        var builder = dialog.user_data['builder'], techname = dialog.user_data['techname'], tech = dialog.user_data['tech'];

                        if(builder || player.is_cheater) {
                            var status;
                            if('enhance_time' in tech) {
                                status = Store.place_user_currency_order(builder.id, "ENHANCE_FOR_MONEY",
                                                                         [techname, (builder.enhancements ? builder.enhancements[techname]||0 : 0) + 1], cleanup_cb);
                            } else {
                                status = Store.place_user_currency_order(builder ? builder.id : GameObject.VIRTUAL_ID, "RESEARCH_FOR_MONEY", techname, cleanup_cb);
                            }
                            if(status) {
                                invoke_ui_locker(builder ? builder.request_sync() : synchronizer.request_sync());
                            }
                        }
                    };
            } else {
                dialog.widgets['instant_credits'].onclick =
                    dialog.widgets['instant_button'].onclick = function(widget) {
                        var dialog = widget.parent; if(!dialog) { return; }
                        var unit = dialog.user_data['unit'];

                        if(Store.place_user_currency_order(unit.id, "UPGRADE_FOR_MONEY", null, cleanup_cb)) {
                            invoke_ui_locker(unit.request_sync());
                        }
                    };
            }
        }
    }

    } // END instant upgrade is offered

    } // END not at max level

    dialog.widgets['close_button'].onclick = function(w) {
        var _dialog = w.parent;
        var prev_dialog = _dialog.user_data['prev_dialog'];
        close_parent_dialog(w);
        if(prev_dialog) { prev_dialog(); }
    };

    update_upgrade_dialog_equipment(dialog);

    if(!stats_only && player.upgrade_bar_enabled()) {
        UpgradeBar.invoke(dialog, (tech ? ('enhance_time' in tech ? 'enhancement' : 'tech') : 'building'),
                          (tech ? techname : (unit ? unit.spec['name'] : null)),
                          new_level, (unit ? unit.id : null));
    }

    // update tutorial UI
    player.quest_tracked_dirty = true;

    return dialog;
}

/** @param {SPUI.Dialog} dialog */
function update_upgrade_dialog_equipment(dialog) {
    var tech = dialog.user_data['tech'];
    var unit = dialog.user_data['unit'];

    // update equipment slots
    if((!tech && unit && unit.is_building() && ('equip_slots' in unit.spec) && player.get_any_abtest_value('enable_equipment', gamedata['client']['enable_equipment']) ||
        (tech && ('associated_unit' in tech) && player.get_any_abtest_value('enable_unit_equipment', gamedata['client']['enable_unit_equipment'])))) {

        var equip_pending = false;
        var equip_problem = player.warehouse_is_busy();
        var equip_slots = null, old_level = -1, max_level = -1;
        var equip = null;

        if(tech && ('associated_unit' in tech)) {
            // unit equipment
            var unit_spec = gamedata['units'][tech['associated_unit']];
            equip_slots = unit_spec['equip_slots'] || null;
            old_level = player.tech[tech['name']] || 0;
            max_level = get_max_ui_level(unit_spec);
            equip = player.unit_equipment[tech['associated_unit']] || {};
            equip_pending = !!(equip['equip_pending']);
        }

        if(!tech) {
            // building equipment
            equip_slots = unit.spec['equip_slots'] || null;
            old_level = unit.level;
            max_level = unit.get_max_ui_level();
            equip_pending = unit.equip_pending;
            equip_problem |= (unit.is_damaged() || unit.is_busy());
            equip = unit.equipment;
        }
        equip_problem |= equip_pending;

        if(equip_slots) {
            // horrible hack to deal with tooltip overlap:
            // hide inventory_context when there is a child dialog other than the upgrade_bar, or the inventory_context dialog itself
            var child_dialog = (dialog.children[dialog.children.length-1].user_data && dialog.children[dialog.children.length-1].user_data['dialog'] &&
                                dialog.children[dialog.children.length-1].user_data['dialog'] != 'upgrade_bar' &&
                                dialog.children[dialog.children.length-1].user_data['dialog'] != 'inventory_context'
                               );

            equip_slots = get_leveled_quantity(equip_slots, Math.max(old_level, 1));
            var slot_i = 0;
            for(var type_name in equip_slots) {
                if(!player.is_cheater &&
                   ((('show' in gamedata['strings']['equip_slots'][type_name]) && !gamedata['strings']['equip_slots'][type_name]['show']) ||
                    (('show_if' in gamedata['strings']['equip_slots'][type_name]) &&
                     !read_predicate(gamedata['strings']['equip_slots'][type_name]['show_if']).is_satisfied(player,null))
                   )) {
                    continue;
                }

                var n_slots = get_leveled_quantity(equip_slots[type_name], Math.max(old_level, 1));
                var max_slots = get_leveled_quantity(equip_slots[type_name], max_level);

                var n = 0;
                for(; n < n_slots; n++) {
                    if(slot_i >= dialog.data['widgets']['equip_slot']['array'][0]) { break; }

                    dialog.widgets['equip_loading_spinner'+slot_i].show = equip_pending;
                    dialog.widgets['equip_loading_rect'+slot_i].show = equip_problem;

                    // update the items shown in the equipment slots
                    if(equip && (type_name in equip) && (equip[type_name].length > n) && equip[type_name][n]) {
                        var eitem = player.decode_equipped_item(equip[type_name][n]);
                        var especname = eitem['spec'];
                        var espec = ItemDisplay.get_inventory_item_spec(especname);
                        ItemDisplay.set_inventory_item_asset(dialog.widgets['equip_item'+slot_i], espec);
                        dialog.widgets['equip_item'+slot_i].show = true;
                        dialog.widgets['equip_frame'+slot_i].state = 'normal';

                        if(!child_dialog) {
                            dialog.widgets['equip_frame'+slot_i].onenter = (function (_slot_i, _type_name, _n, _eitem) { return function(w) {
                                var dialog = w.parent;
                                if(dialog.user_data['context'] &&
                                   dialog.user_data['context'].user_data['slot'] === _slot_i) {
                                    return;
                                }
                                invoke_inventory_context(w.parent, w, _slot_i, _eitem, false, {'position':'top_or_bottom'});
                            }; })(slot_i, type_name, n, eitem);
                        } else {
                            // there's a child dialog in the way - get rid of inventory_context
                            invoke_inventory_context(dialog, dialog.widgets['equip_frame'+slot_i], -1, null, false);
                            dialog.widgets['equip_frame'+slot_i].onenter = null;
                        }
                        dialog.widgets['equip_frame'+slot_i].onleave_cb = (function (_slot_i, _type_name, _n) { return function(w) {
                            if(dialog.user_data['context'] &&
                               dialog.user_data['context'].user_data['slot'] === _slot_i) {
                                invoke_inventory_context(w.parent, w, -1, null, false);
                            }
                        }; })(slot_i, type_name, n);

                        dialog.widgets['equip_frame'+slot_i].tooltip.str = null;
                    } else { // slot is not filled
                        dialog.widgets['equip_item'+slot_i].show = false;
                        dialog.widgets['equip_frame'+slot_i].state = 'invisible';
                        dialog.widgets['equip_frame'+slot_i].onenter = null;
                        dialog.widgets['equip_frame'+slot_i].onleave_cb = null;
                        dialog.widgets['equip_frame'+slot_i].tooltip.str = (!child_dialog ? dialog.data['widgets']['equip_frame']['ui_tooltip_empty'] : null);
                    }
                    slot_i++;
                }
                for(;n < max_slots; n++) {
                    if(slot_i >= dialog.data['widgets']['equip_slot']['array'][0]) { break; }
                    slot_i++;
                }
            }
        }
    }
}

function init_damage_vs_icons(dialog, spec, weapon_spell) {
    var show = (weapon_spell && (('ui_damage_vs' in weapon_spell) || ('ui_damage_vs' in spec)));

    if((spec && 'ui_show_weapon_features' in spec && !spec['ui_show_weapon_features']) || (weapon_spell && 'ui_show_weapon_features' in weapon_spell && !weapon_spell['ui_show_weapon_features'])) {
        show = false;
    }

    if('damage_vs_label' in dialog.widgets) { dialog.widgets['damage_vs_label'].show = show; }

    var CATS = gamedata['strings']['damage_vs_categories'];
    var ui_damage_vs = (show ? ('ui_damage_vs' in weapon_spell ? weapon_spell['ui_damage_vs'] : spec['ui_damage_vs']) : null);

    for(var i = 0; i < CATS.length; i++) {
        var xy;
        if(dialog.data['widgets']['damage_vs']['array'][1] <= 1) {
            xy = [i,0]; // 2D array
        } else {
            xy = [i % dialog.data['widgets']['damage_vs']['array'][0], Math.floor(i / dialog.data['widgets']['damage_vs']['array'][0])];
        }
        var widget = dialog.widgets[SPUI.get_array_widget_name('damage_vs', dialog.data['widgets']['damage_vs']['array'], xy)];
        widget.show = show;
        if(show) {
            widget.show = (spec['kind'] !== 'building' || CATS[i][0] != 'building');

            if(spec['kind'] === 'building' && dialog.data['widgets']['damage_vs']['array'][1] <= 1) {
                // slide widgets to the right to re-center them with missing "vs building" icon
                widget.xy[0] = dialog.data['widgets']['damage_vs']['xy'][0] + i*dialog.data['widgets']['damage_vs']['array_offset'][0] + Math.ceil(dialog.data['widgets']['damage_vs']['array_offset'][0]/2);
            }

            if(!(CATS[i][0] in ui_damage_vs)) {
                throw Error('ui_damage_vs from '+('ui_damage_vs' in weapon_spell ? 'weapon_spell '+weapon_spell['name'] : 'spec '+spec['name'])+' missing entry '+CATS[i][0]);
            }

            var q = ui_damage_vs[CATS[i][0]];
            widget.asset = 'damage_vs_'+CATS[i][0];
            if(q in gamedata['strings']['damage_vs_qualities']) {
                widget.state = gamedata['strings']['damage_vs_qualities'][q];
            } else {
                throw Error('not found: damage_vs_qualities: '+q);
            }
            var ui_name;
            if(CATS[i][1] in gamedata['strings']['manufacture_categories']) {
                ui_name = gamedata['strings']['manufacture_categories'][CATS[i][1]]['plural'];
            } else if(CATS[i][1] in gamedata['strings']['object_kinds']) {
                ui_name = gamedata['strings']['object_kinds'][CATS[i][1]]['plural'];
            } else {
                throw Error('unknown manuf category or object kind '+CATS[i][1]);
            }
            widget.tooltip.str = gamedata['strings']['damage_vs_string']
                .replace('%quality', gamedata['strings']['damage_vs_ui_qualities'][q])
                .replace('%category', ui_name);
        }
    }

    // damage_type icons
    if('damage_types' in dialog.data['widgets'] && 'damage_types' in gamedata['strings']) {
        var TYPES = gamedata['strings']['damage_types'];
        var i = 0;
        var max_widgets = dialog.data['widgets']['damage_types']['array'][0] * dialog.data['widgets']['damage_types']['array'][1];

        if(show && weapon_spell && 'damage_vs' in weapon_spell) {
            for(var key in weapon_spell['damage_vs']) {
                if(key in TYPES) {
                    var xy;
                    if(dialog.data['widgets']['damage_types']['array'][1] <= 1) {
                        xy = [i,0]; // 2D array
                    } else {
                        xy = [i % dialog.data['widgets']['damage_types']['array'][0], Math.floor(i / dialog.data['widgets']['damage_types']['array'][0])];
                    }
                    var widget = dialog.widgets[SPUI.get_array_widget_name('damage_types', dialog.data['widgets']['damage_types']['array'], xy)];
                    widget.show = true;

                    var type_data = TYPES[key];
                    widget.asset = type_data['asset'];
                    widget.tooltip.str = SPUI.break_lines(widget.data['ui_tooltip'].replace('%name', type_data['ui_name']).replace('%description', type_data['ui_description']),
                                                          SPUI.desktop_font, widget.data['max_tooltip_dimensions'])[0];

                    i += 1;
                    if(i >= max_widgets) {
                        break; // ran out of space
                    }
                }
            }
        }
        if('damage_types_label' in dialog.widgets) {
            dialog.widgets['damage_types_label'].show = (i >= 1);
        }

        // space out widgets and hide any unused slots at the end
        dialog.update_array_widget_positions('damage_types', i);
    }

};

var Store = { order_cleanup_cb: null };

Store.get_free_speedup_time = function(player) { return eval_cond_or_literal(player.get_any_abtest_value('free_speedup_time', gamedata['store']['free_speedup_time']), player, null); };

// note: "user_currency" here refers to the in-game currency (either FB Credits or gamebucks a.k.a. alloys/gold), NOT the real payment currency
Store.get_user_currency = function() { return player.get_any_abtest_value('currency', gamedata['currency']); };
Store.gamebucks_ui_name = function() { return player.get_any_abtest_value('gamebucks_ui_name', gamedata['store']['gamebucks_ui_name']); };

// get the tooltip to display under the user's in-game currency balance
Store.get_balance_tooltip = function() {
    var currency = (player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks' ? 'gamebucks' : 'facebook_credits');
    var curr_qty = player.resource_state[currency] < 0 ? 'Unknown' : pretty_print_number(player.resource_state[currency]);
    var fb_qty = player.resource_state['facebook_credits'] < 0 ? 'Unknown' : pretty_print_number(player.resource_state['facebook_credits']);

    var tip;
    if(SPay.api == 'kgcredits') {
        tip = gamedata['dialogs']['desktop_top']['widgets']['resource_bar_fbcredits']['ui_tooltip_kgcredits'];
    } else {
        tip = gamedata['dialogs']['desktop_top']['widgets']['resource_bar_fbcredits']['ui_tooltip_'+currency+(player.resource_state['facebook_credits'] < 0 ? '_badapi' : '')];
    }
    tip = tip.replace('%d', curr_qty);
    tip = tip.replace('%s', (currency == 'gamebucks' ? Store.gamebucks_ui_name() : 'FB Credits'));
    while(tip.indexOf('%gamebucks') != -1) {
        tip = tip.replace('%gamebucks', Store.gamebucks_ui_name());
    }
    tip = tip.replace('%fbcredits', fb_qty);
    return tip;
};

// get the function to call when user clicks on the "+" button next to the in-game currency balance
Store.get_balance_plus_cb = function() {
    var credits_button_cb;
    if(player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks') {
        credits_button_cb = function(w) {
            if(w.parent) { w.parent.onleave(); } // get rid of tooltips
            invoke_buy_gamebucks_dialog('desktop_add_alloy_button', -1, null);
        };
    } else {
        credits_button_cb = Store.buy_more_fbcredits;
    }
    return credits_button_cb;
};

// display an amount of in-game currency
// format = 'compact' for raw number, 'normal' for 'N Alloy'/'N', or 'full' for 'N Alloy'/'N Facebook Credits'
/** @param {number} price
    @param {string=} format */
Store.display_user_currency_amount = function(price, format) {
    if(Store.get_user_currency() == 'gamebucks') {
        var divisor = player.get_any_abtest_value('gamebucks_display_divisor', gamedata['store']['gamebucks_display_divisor']);
        if(!format) { format = 'normal'; }
        var key = 'gamebucks_display_ui_'+format;
        var template = player.get_any_abtest_value(key, gamedata['store'][key]);
        var num;
        if(divisor == 1) {
            num = pretty_print_number(price);
        } else {
            // NOTE: only handles divisor=10
            num = pretty_print_number(Math.floor(price/divisor));
            var frac = price % divisor;
            if(frac > 0) {
                num += '.' + frac.toString();
            }
        }
        return template.replace('%s', num);
    } else { // fbcredits
        var ret = pretty_print_number(price);
        if(format && format == 'full') {
            ret += " Facebook Credit";
            if(price != 1) { ret += "s"; }
        }
        return ret;
    }
};

// display an in-game currency price. Same as display_user_currency_amount except returns "-" for things that are free
/** @param {number} price
    @param {string=} format */
Store.display_user_currency_price = function(price, format) {
    if(price < 0) {
        return "-"; // unfulfilled requirements or other error
    } else if(price == 0) {
        return gamedata['strings']['store']['FREE'];
    }
    return Store.display_user_currency_amount(price, format);
};

// display a real-world currency amount (also handles Facebook Credit prices)
// display_currency = the currency in which to display the final amount
// price_currency = must be either fbcredits (for the old FB Credits API) or fbpayments:display_currency (for the new FB Payments API) or xsolla:display_currency (for Xsolla)
Store.display_real_currency_amount = function (display_currency, price, price_currency, abbreviate) {
    var curr_prefix, curr_suffix, curr_decimals;
    if(display_currency in gamedata['currencies']) {
        var template = gamedata['currencies'][display_currency];

        curr_prefix = template['prefix'] || '';
        curr_suffix = template['suffix'] || '';

        if((SPay.api == 'fbpayments' || SPay.api == 'xsolla' || SPay.api == 'microsoft') && player.facebook_currency && player.facebook_currency['user_currency'] != display_currency && !abbreviate) {
            // when showing prices in a currency that is not the player's own currency, be very explicit about what we are showing
            // because it might be e.g. an Australian user seeing a US Dollar price
            if(curr_prefix.indexOf(display_currency) === -1 && curr_suffix.indexOf(display_currency) === -1) {
                // only prepend the currency abbreviation if local prefix/suffix does not already include it (e.g. "DKK 1234" already includes it)
                curr_prefix = display_currency + ' ' + curr_prefix;
            }
        }
        curr_decimals = ('decimals' in template ? template['decimals'] : 2);
    } else {
        // fallback for unknown currencies
        curr_prefix = '';
        curr_suffix = (abbreviate ? '' : ' '+display_currency);
        curr_decimals = 2;
    }

    var display_price;
    if(price_currency == display_currency || ((price_currency.indexOf('fbpayments:') == 0 || price_currency.indexOf('xsolla:') == 0 || price_currency.indexOf('microsoft:') == 0) && price_currency.split(':')[1] == display_currency) ||
       (price_currency == 'fbcredits' && display_currency == 'Facebook Credits') ||
       (price_currency == 'kgcredits' && display_currency == 'Kongregate Kreds')) {
        display_price = price;
    } else {
        if(price_currency != 'fbcredits') {
            throw Error('unhandled conversion: '+price_currency+' -> '+display_currency);
        }
        if(!player.facebook_currency || display_currency != player.facebook_currency['user_currency']) {
            throw Error('display_currency '+display_currency+' does not match Facebook-provided data of '+(player.facebook_currency ? player.facebook_currency['user_currency'] : 'NONE'));
        }
        // use the Facebook-provided user currency data for the conversion
        display_price = Math.round(price * player.facebook_currency['currency_exchange_inverse']*player.facebook_currency['currency_offset'])/player.facebook_currency['currency_offset'];
    }

    return curr_prefix + display_price.toFixed(curr_decimals) + curr_suffix;
};

// get the tooltip to display under an in-game currency price
Store.display_user_currency_price_tooltip = function(price) {
    if(!player.get_any_abtest_value('price_display_tooltip', gamedata['store']['price_display_tooltip'])) {
        return "";
    }
    if(price <= 0) {
        return ""; // unfulfilled requirements or other error, or free
    }
    return gamedata['strings']['store']['buy_for'].replace('%s', Store.display_user_currency_amount(price, 'full'));
};

// convert FB Credit price to another in-game currency - used only for tooltips on cost-capping auras
Store.convert_credit_price_to_currency = function(p, currency) {
    if(currency == 'fbcredits') {
        return p;
    } else if(currency == 'gamebucks') {
        return player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) * p;
    } else {
        throw Error('unknown currency');
    }
};
Store.convert_credit_price_to_user_currency = function(p) {
    return Store.convert_credit_price_to_currency(p, Store.get_user_currency());
};

// get price of a spell in user's in-game currency
Store.get_user_currency_price = function(unit_id, spell, spellarg) {
    return Store.get_price(Store.get_user_currency(), unit_id, spell, spellarg, false);
};

// main pricing entry point
// this MUST match Store.get_price in server.py, or else there will be trouble!!!
/** @param {string} sale_currency
    @param {GameObjectId} unit_id
    @param {Object} spell
    @param {?} spellarg
    @param {boolean=} ignore_error */
Store.get_price = function(sale_currency, unit_id, spell, spellarg, ignore_error) {
    var p_p_currency = Store.get_base_price(unit_id, spell, spellarg, ignore_error);
    var p = p_p_currency[0], p_currency = p_p_currency[1];

    if(p <= 0) { return p; }

    // only check for currency match when price > 0
    if(sale_currency.indexOf('item:') !== 0 && sale_currency.indexOf('score:') !== 0 && !(sale_currency in gamedata['resources'])) {
        var spell_currency = ('currency' in spell ? spell['currency'] : Store.get_user_currency());
        if(sale_currency != spell_currency) { return -1; }
    }

    // convert base price currency to what the buyer wants to pay with

    if(sale_currency === p_currency) {
        return p;
    } else if(sale_currency == 'fbcredits') {
        if(p_currency == 'gamebucks') {
            return Math.floor(p/player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']))+1;
        } else {
            return -1;
        }
    } else if(sale_currency == 'gamebucks') {
        if(p_currency == 'fbcredits') {
            return player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) * p;
        } else {
            return -1;
        }
    } else {
        throw Error('unknown currency conversion '+p_currency+' -> '+sale_currency);
    }
};

// return whether or not it is possible to cast this (server-side) spell
// the _detailed() version returns [can_cast, ui_reason, and a list of up to 3 args [x,y,z] that will be passed to get_requirements_help(x,y,z) to make a Valentina helper]
/** @param {GameObjectId} unit_id
    @param {string} spellname
    @param {*} spellarg */
function can_cast_spell_detailed(unit_id, spellname, spellarg) {
    var world = session.get_real_world();

    var spell = gamedata['spells'][spellname];

    // note: undecided if we should factor in the GCD here. Leaving it
    // off for now, item frames will have to deal with GCD on their
    // own.
    var to_go = -1; // player.cooldown_togo('GCD');

    if('cooldown_name' in spell) {
        var cd_name = spell['cooldown_name'];
        to_go = Math.max(to_go, player.cooldown_togo(cd_name));
    }

    if(to_go > 0) {
        return [false, 'On Cooldown: '+pretty_print_time(to_go), null];
    }

    if(spellname == "GIVE_UNITS_LIMIT_BREAK" || spellname == "CHANGE_ALIAS") {
        // always OK
    } else if(spellname == "SHOW_STORE" || spellname == "CLIENT_CONSEQUENT") {
        // always OK
    } else if(spellname.indexOf("BUY_RANDOM_") == 0 || spellname.indexOf("FREE_RANDOM_") == 0) {
        // always OK (when not on cooldown)
    } else if(spellname.indexOf("CHANGE_REGION_INSTANTLY") == 0) {
        var pred = read_predicate(player.get_any_abtest_value('change_region_requirement', gamedata['territory']['change_region_requirement']));
        if(!pred.is_satisfied(player, null)) {
            return [false, pred.ui_describe(player), [pred,null]];
        }
    } else if(spellname == "ALLIANCE_GIFT_LOOT") {
        if(!session.is_in_alliance()) {
            return [false, gamedata['strings']['requirements_help']['alliance']['join']['ui_description'], null];
        }
    } else if(spellname == "FRIEND_GIFT_LOOT") {
        // always OK - the friend_gift_dialog GUI handles the case where you have no friends
        /*
        if(goog.array.filter(player.friends, function(fr) { return fr.is_real_friend; }).length < 1) {
            return [false, gamedata['strings']['requirements_help']['friends']['invite']['ui_description'], ['friends','invite',{short_circuit:1}]];
        }
        */
    } else if(spellname == "GIVE_UNITS") {
        // add up the space required for the new units
        var total = 0;
        for(var name in spellarg) {
            if(!(name in gamedata['units'])) { continue; }
            var spec = gamedata['units'][name];

            var data = spellarg[name];
            var qty = 1;
            if(typeof(data) === "number") {
                qty = data;
            } else if('qty' in data) {
                qty = data['qty'];
            }

            var level = player.tech[spec['level_determined_by_tech']] || 1;
            var space = get_leveled_quantity(spec['consumes_space'] || 0, level);
            total += qty*space;

            if(spec['limit']) {
                var counts = player.get_army_unit_count_by_specname();
                var cur_count = counts[spec['name']] || 0;
                if(cur_count + 1 > spec['limit']) {
                    return [false, gamedata['errors']['UNIT_COUNT_LIMIT']['ui_name'], ['unit_count', spec['name']]];
                }
            }
        }
        var space_usage = player.get_army_space_usage_by_squad();
        var available_space = player.stattab['total_space'] - space_usage['ALL'];
        if(!player.squads_enabled() || !gamedata['produce_to_reserves']) {
            available_space = Math.min(available_space, player.stattab['main_squad_space'] - space_usage[SQUAD_IDS.BASE_DEFENDERS.toString()]);
        }
        if(total > available_space) {
            var tooltip = gamedata['errors']['UNIT_SPACE_LIMIT']['ui_name'];
            if(player.squads_enabled()) {
                var reason = classify_unit_space_shortage();
                if(reason == 'base_defenders') {
                    tooltip = gamedata['strings']['requirements_help']['unit_space_base_defenders']['manage_base_defenders']['ui_description'];
                } else if(reason == 'total_army') {
                    tooltip = gamedata['strings']['requirements_help']['unit_space_total_army']['upgrade']['ui_description'];
                } else if(reason == 'recycle') {
                    tooltip = gamedata['strings']['requirements_help']['unit_space_total_army']['recycle']['ui_description'];
                }
            }
            return [false, tooltip, ['unit_space',null]];
        }
    } else if(spellname.indexOf("BOOST_") == 0 && (spell['resource'] in gamedata['resources'])) {
        var resource = spell['resource'];
        var amount;
        if('boost_amount' in spell) { // percentage boost
            if(spell['boost_amount'] < 1) {
                amount = Math.floor(spell['boost_amount'] * player.resource_state[resource][0]);
            } else { // 100% boost
                amount = player.resource_state[resource][0] - player.resource_state[resource][1]; // note: can go negative if overfull
            }
        } else if('give_amount' in spell) { // flat amount
            amount = spell['give_amount'];
        } else {
            throw Error('do not know how to process boost spell '+spellname);
        }

        if(amount <= 0 || ((player.resource_state[resource][1] + amount) > player.resource_state[resource][0])) {
            return [false, gamedata['errors']['STORAGE_LIMIT']['ui_name'],
                    [resource, Math.max(1, ((player.resource_state[resource][1] + amount) - player.resource_state[resource][0])) ]];
        }
    } else if(spellname == "BUILD_INSTANTLY_FOR_FREE") {
        // this mirrors do_build in the server
        // checks everything EXCEPT resource levels
        if(!session.home_base) { return [false, gamedata['errors']["CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"]['ui_name'], null]; }
        var building_type = spellarg[0], j_i = spellarg[1];
        var spec = gamedata['buildings'][building_type];
        if(spec['developer_only'] && (spin_secure_mode || !player.is_developer())) { return [false, gamedata['errors']['DISALLOWED_IN_SECURE_MODE']['ui_name'], null]; }
        if(j_i && !player.is_building_location_valid(j_i, spec, null, {ignore_perimeter: !!spec['ignore_perimeter']})) {
            return [false, gamedata['errors']['INVALID_BUILDING_LOCATION']['ui_name'], ['invalid_building_location','any']];
        }
        if(spec['requires']) {
            var pred = read_predicate(get_leveled_quantity(spec['requires'],1));
            if(!pred.is_satisfied(player,null)) {
                return [false, gamedata['strings']['unmet_requirements'].replace('%s',pred.ui_describe(player)), [pred,null]];
            }
        }
        /*
        if(0 && spec['consumes_power'] &&
           (session.viewing_base.power_state[1] + get_leveled_quantity(spec['consumes_power'],1)) > session.viewing_base.power_state[0]) {
            return [false, gamedata['errors']['POWER_LIMIT']['ui_name'], ['power',null]];
        }
        */
        if(spec['limit']) {
            var current = 0;
            world.objects.for_each(function(obj) {
                if(obj.team === 'player' && obj.spec['name'] === spec['name']) { current += 1; }
            });
            var limit = get_leveled_quantity(spec['limit'], player.get_townhall_level());
            if(limit >= 0 && current >= limit && !player.is_cheater) {
                // can we build more at a higher CC level?
                var max_limit = ((typeof spec['limit']) === 'number' ? spec['limit'] : goog.array.reduce(spec['limit'], function(accum, cur) { accum = Math.max(accum,cur);}, 0));
                var helper_args = (max_limit > limit ? ['cc_limit',spec] : null);
                return [false, gamedata['errors']['BUILDING_LIMIT_EXCEEDED']['ui_name'], helper_args];
            }
        }
        return [true,null,null];
    } else if(spellname == "UPGRADE_UNIQUE_INSTANTLY_FOR_FREE") {
        if(!session.home_base) { return [false, gamedata['errors']["CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"]['ui_name'], null]; }
        var building_type = spellarg;
        var spec = gamedata['buildings'][building_type];
        var obj = find_object_by_type(building_type);
        if(!obj || !obj.is_building() || obj.team !== 'player') {
            return [false, gamedata['errors']['BUILDING_NOT_FOUND']['ui_name'], null];
        }
        if(obj.is_damaged() || obj.is_repairing()) {
            return [false, gamedata['errors']['CANNOT_UPGRADE_BUILDING_WHILE_DAMAGED']['ui_name'], null];
        }
        if(obj.is_busy() && !obj.is_upgrading()) {
            return [false, gamedata['errors']['CANNOT_UPGRADE_BUILDING_WHILE_BUSY']['ui_name'], null];
        }
        if(obj.level >= obj.get_max_level()) {
            return [false, gamedata['errors']['MAX_LEVEL_REACHED']['ui_name'], null];
        }

        return [true,null,null];
    } else if(spellname == "APPLY_AURA") {
        var target = spellarg[0], aura_name = spellarg[1], aura_strength = spellarg[2], aura_duration = spellarg[3];
        var spec = gamedata['auras'][aura_name];
        if(!(('limited' in spec) && !spec['limited'])) {
            var aura_count = 0;
            goog.array.forEach(player.player_auras, function(x) {
                var s = gamedata['auras'][x['spec']];
                // 'harm' auras are debuffs and don't count towards the player aura limit
                // 'limited':0 auras are special and don't count towards the player aura limit
                if(!s['harm'] && !(('limited' in s) && !s['limited'])) {
                    aura_count += 1;
                }
            });
            if(aura_count >= gamedata['player_aura_limit']) {
                // see if this will stack an existing aura
                var found = false;
                for(var i = 0; i < player.player_auras.length; i++) {
                    if(player.player_auras[i]['spec'] === aura_name) {
                        found = true;
                        break;
                    }
                }
                if(!found) {
                    return [false, gamedata['errors']['PLAYER_AURA_LIMIT']['ui_name'], ['player_aura_limit', null]];
                }
            }
        }
        return [true, null, null];
    } else if(spellname.indexOf("BUY_PROTECTION") == 0) {
        // always OK
    } else if(spellname.indexOf("UPGRADE_BARRIERS") == 0) {
        var min_level = 99;
        world.objects.for_each(function(obj) {
            if(obj.spec['name'] === 'barrier') {
                min_level = Math.min(min_level, obj.level);
            }
        });
        var formula = spell['price_formula'];
        var up_level = parseInt(formula[formula.length-1],10);
        if(min_level >= up_level) {
            return [false, null, null];
        } else {
            return [true, null, null];
        }
    } else if(spellname.indexOf("GROW_BASE_PERIMETER") == 0) {
        var formula = spell['price_formula'];
        var to_level = parseInt(formula[formula.length-1],10);
        if(session.viewing_base.base_size >= to_level) {
            return [false, null, null];
        }
        return [true, null, null];
    } else if(('code' in spell) && (spell['code'] == 'projectile_attack')) {
        if(session.has_deployed) {
            if(session.viewing_base.base_climate_data['exclude_missiles']) {
                return [false, gamedata['errors']['CANNOT_USE_ITEM_UNDERGROUND']['ui_name'], null];
            } else {
                return [true, null, null];
            }
        } else {
            return [false, gamedata['errors']['CANNOT_USE_ITEM_OUTSIDE_OF_COMBAT']['ui_name'], null];
        }
    } else if(('code' in spell) && (spell['code'] == 'instant_repair' || spell['code'] == 'instant_combat_repair')) {
        var found = world.objects.for_each(function(obj) {
            if(obj.team === 'player' && obj.is_damaged()) {
                return true;
            }
        });
        if(!found && (spell['code'] === 'instant_repair' || session.deployed_unit_space == 0)) {
            return [false, gamedata['errors']['NOTHING_TO_REPAIR']['ui_name'], null];
        }

        if(spell['code'] == 'instant_combat_repair') {
            if(session.home_base || !session.has_deployed) {
                return [false, gamedata['errors']['CANNOT_USE_ITEM_OUTSIDE_OF_COMBAT']['ui_name'], null];
            }
        } else {
            if(!session.home_base || session.has_deployed) {
                return [false, gamedata['errors']['CANNOT_CAST_SPELL_IN_COMBAT']['ui_name'], null];
            }
        }

        return [true, null, null];
    } else if(spellname == "CRAFT_FOR_FREE") {
        var builder = world.objects.get_object(unit_id);
        var recipe_name = spellarg[0]['recipe'];
        var recipe_level = spellarg[0]['level'] || 1;
        var recipe_spec = gamedata['crafting']['recipes'][recipe_name];

        var ret = null;
        if(!player.is_cheater) {
            // check predicate requirements
            goog.array.forEach(['show_if','requires'], function(predname) {
                if(ret) { return; } // already found a reason we cannot proceed
                if(predname in recipe_spec) {
                    var pred = read_predicate(get_leveled_quantity(recipe_spec[predname], recipe_level));
                    if(!pred.is_satisfied(player, null)) {
                        ret = [false, gamedata['errors']['REQUIREMENTS_NOT_SATISFIED']['ui_name'], [pred]];
                    }
                }
            });
            if(ret) { return ret; }

            // check delivery slot requirement
            if('delivery' in spellarg[0] &&
               spellarg[0]['delivery']['slot_type'] &&
               ('obj_id' in spellarg[0]['delivery'])) {
                var delivery_obj = session.get_real_world().objects.get_object(spellarg[0]['delivery']['obj_id']);
                var product_item = get_crafting_recipe_product_list(recipe_spec, recipe_level)[0];
                var product_level = ItemDisplay.get_inventory_item_level(product_item);
                var product_spec = ItemDisplay.get_inventory_item_spec(product_item['spec']);
                var compat_list;
                if('compatible' in product_spec['equip']) {
                    compat_list = product_spec['equip']['compatible'];
                } else {
                    compat_list = [product_spec['equip']];
                }
                goog.array.forEach(compat_list, function(compat) {
                    if(ret) { return; } // already found a reason we cannot proceed
                    if('min_level' in compat) {
                        var min_level = get_leveled_quantity(compat['min_level'], product_level);
                        if(delivery_obj.level < min_level) {
                            var pred = read_predicate({'predicate': 'BUILDING_LEVEL',
                                                       'building_type': delivery_obj.spec['name'],
                                                       'trigger_level': min_level,
                                                       'obj_id': delivery_obj.id});
                            ret = [false, gamedata['errors']['REQUIREMENTS_NOT_SATISFIED']['ui_name'], [pred]];
                        }
                    }
                });
                if(ret) { return ret; }
            }

            // check resource requirements
            var resources_needed = {};
            for(var res in gamedata['resources']) {
                var cost = get_leveled_quantity(recipe_spec['cost'], recipe_level)[res]||0;
                if(player.resource_state[res][1] < cost) {
                    resources_needed[res] = cost - player.resource_state[res][1];
                }
            }
            if(goog.object.getCount(resources_needed) > 0) {
                return [false, gamedata['errors']['INSUFFICIENT_RESOURCES']['ui_name'], ['resources', resources_needed]];
            }

            // check ingredient requirements
            if('ingredients' in recipe_spec) {
                // have to pre-sum by specname and level in case there are multiple matching entries
                var by_specname_and_level = {};
                var ingr_list = get_crafting_recipe_ingredients_list(recipe_spec, recipe_level);
                goog.array.forEach(ingr_list, function(ingr) {
                    var stack = ('stack' in ingr ? ingr['stack'] : 1);
                    var key = ingr['spec'];
                    if('level' in ingr) {
                        key += ':'+ingr['level'].toString();
                    }
                    by_specname_and_level[key] = (by_specname_and_level[key] || 0) + stack;
                });
                var missing_items = [];
                goog.object.forEach(by_specname_and_level, function(qty, key) {
                    var specname_level = key.split(':');
                    var specname = specname_level[0], level = (specname_level.length > 1 ? parseInt(specname_level[1],10) : null);
                    if(player.inventory_item_quantity(specname, level) < qty) {
                        missing_items.push({'spec':specname, 'level':level, 'stack': qty - player.inventory_item_quantity(specname, level)});
                    }
                });
                if(missing_items.length > 0) {
                    return [false, gamedata['errors']['CRAFT_INGREDIENT_MISSING']['ui_name'], ['crafting_ingredients', missing_items]];
                }
            }
        }

        var cat_spec = gamedata['crafting']['categories'][recipe_spec['crafting_category']];
        var queueable = !('queueable' in cat_spec && !cat_spec['queueable']);
        if((!queueable && builder.is_crafting()) ||
           (builder.is_repairing() || builder.is_upgrading() || builder.is_under_construction() || builder.is_enhancing() || builder.is_removing())) {
            return [false, gamedata['errors']['WORKSHOP_IS_BUSY']['ui_name'], ['speedup', builder]];
        } else if(builder.is_damaged()) {
            return [false, gamedata['errors']['WORKSHOP_IS_BUSY']['ui_name'], ['repair', builder]];
        }

        // OK!
    } else {
        throw Error('unhandled spell '+spellname);
    }
    return [true,null,null];
}

/** @param {GameObjectId} unit_id
    @param {string} spellname
    @param {*} spellarg */
function can_cast_spell(unit_id, spellname, spellarg) {
    var ret = can_cast_spell_detailed(unit_id, spellname, spellarg);
    return ret[0];
}

function sku_match(skudata, player, specname, tablename, level, stack, melt_time, melt_duration, tm, ignore_error) {
    if(specname) {
        if(!('item' in skudata) || skudata['item'] !== specname || ((skudata['level']||1) !== level)) { return false; }
    } else if(tablename) {
        if(!('loot_table' in skudata) || skudata['loot_table'] !== tablename) { return false; }
    }
    if(!('price' in skudata)) { return false; }
    if(melt_time > 0 && tm >= melt_time) { return false; }
    if(('start_time' in skudata) && (tm < skudata['start_time'])) { return false; }
    if(('expire_time' in skudata) && (tm >= skudata['expire_time'])) { return false; }
    var skustack = ('stack' in skudata ? skudata['stack'] : 1);
    if(skustack !== stack) { return false; }
    var skumelt = ('melt_time' in skudata ? skudata['melt_time'] : -1);
    if(skumelt !== melt_time) { return false; }
    var skudur = ('melt_duration' in skudata ? skudata['melt_duration'] : -1);
    if(skudur !== melt_duration) { return false; }
    if(('show_if' in skudata) && !read_predicate(skudata['show_if']).is_satisfied(player, null)) { return false; }
    if(!ignore_error && ('requires' in skudata) && !read_predicate(skudata['requires']).is_satisfied(player, null)) { return false; }
    return true;
}

// look through the store catalog for the SKU representing this BUY_ITEM spellarg
Store.buy_item_find_skudata = function(spellarg, player, ignore_error) {
    var catpath = spellarg['catpath'];
    var specname = spellarg['skudata']['item'] || null;
    var tablename = spellarg['skudata']['loot_table'] || null;
    if(!catpath || (!specname && !tablename)) { return null; }
    var stack = ('stack' in spellarg['skudata'] ? spellarg['skudata']['stack'] : 1);
    var level = ('level' in spellarg['skudata'] ? spellarg['skudata']['level'] : 1);
    var melt_time = ('melt_time' in spellarg['skudata'] ? spellarg['skudata']['melt_time'] : -1);
    var melt_dur = ('melt_duration' in spellarg['skudata'] ? spellarg['skudata']['melt_duration'] : -1);
    var tm = player.get_absolute_time();

    // drill down into the category containing this SKU
    var cat = null;
    var catlist = gamedata['store']['catalog'];
    for(var i = 0; i < catpath.length; i++) {
        cat = goog.array.find(catlist, function (entry) {
            return (entry['name'] && entry['name'] === catpath[i] &&
                    (!('activation' in entry) || read_predicate(entry['activation']).is_satisfied(player,null)) &&
                    (!('start_time' in entry) || entry['start_time'] < tm) &&
                    (!('expire_time' in entry) || entry['expire_time'] >= tm));
        });
        if(!cat) { return null; }
        catlist = cat['skus'] || [];
    }
    if(!cat) { return null; }

    var ret = null, pr = -1;
    goog.array.forEach(cat['skus'], function(skudata) {
        if(sku_match(skudata, player, specname, tablename, level, stack, melt_time, melt_dur, tm, ignore_error)) {
            if(pr < 0 || skudata['price'] < pr) {
                // use lowest price, in case there are multiple matches
                ret = skudata;
                pr = skudata['price'];
            }
        }
    });

    // also look in extra_store_specials
    if(catpath[0] === 'specials') {
        for(var test_name in player.abtests) {
            var group = player.abtests[test_name];
            if(test_name in gamedata['abtests'] && gamedata['abtests'][test_name]['active'] && (group in gamedata['abtests'][test_name]['groups'])) {
                var data = gamedata['abtests'][test_name]['groups'][group];
                if('extra_store_specials' in data) {
                    var extras = data['extra_store_specials'];
                    for(var i = 0; i < extras.length; i++) {
                        var skudata = extras[i];
                        if(sku_match(skudata, player, specname, tablename, level, stack, melt_time, melt_dur, tm, ignore_error)) {
                            if(pr < 0 || skudata['price'] < pr) {
                                // use lowest price, in case there are multiple matches
                                ret = skudata;
                                pr = skudata['price'];
                            }
                        }
                    }
                }
            }
        }
    }

    return ret;
};

// for historical reasons, the core time/cost computation is done in units of fbcredits
Store.get_speedup_price_fbcredits = function(player, kind, seconds) {
    var mins_per_credit = player.get_any_abtest_value('speedup_minutes_per_credit', gamedata['store']['speedup_minutes_per_credit']);
    if(typeof mins_per_credit == 'object') { // dictionary of per-kind values
        mins_per_credit = (kind in mins_per_credit ? mins_per_credit[kind] : mins_per_credit['default']);
    }
    return (seconds/60.0)/mins_per_credit;
};
Store.get_speedup_price = function(player, kind, seconds, currency) {
    var quantize = true;
    var fbcredits_price = Store.get_speedup_price_fbcredits(player, kind, seconds);
    var ret;
    if(currency == 'gamebucks') {
        ret = player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) * fbcredits_price;
    } else if(currency == 'fbcredits') {
        ret = fbcredits_price;
    } else {
        throw Error('unhandled currency '+currency);
    }
    if(quantize) { // snap to next-highest integer price
            return Math.floor(ret) + 1;
    }
    return ret;
};

// main pricing function - MUST match Store.get_base_price in server.py!
Store.get_base_price = function(unit_id, spell, spellarg, ignore_error) {
    var p_currency = 'fbcredits';

    if('requires' in spell && !ignore_error) {
        if(!read_predicate(spell['requires']).is_satisfied(player, null)) { return [-1, p_currency]; }
    }

    if('cooldown_name' in spell && !ignore_error) {
        if(player.cooldown_active(spell['cooldown_name'])) {
            return [-1, p_currency];
        }
    }

    var formula = spell['price_formula'];
    if(!formula) {
        throw Error('bad price_formula for spell '+spell['name']);
    }

    if(formula === 'constant') {
        if('currency' in spell) { p_currency = spell['currency']; }
        return [spell['price'], p_currency];
    } else if(formula === 'item') {
        // find this SKU
        var skudata = Store.buy_item_find_skudata(spellarg, player, ignore_error);
        if(!skudata || !('price' in skudata)) { return [-1, p_currency]; }

        if('item' in skudata) {
            var spec = gamedata['items'][skudata['item']];
            if(!spec) {
                return [-1, p_currency];
            }
            if(('store_requires' in spec) && !ignore_error && !read_predicate(spec['store_requires']).is_satisfied(player, null)) {
                return [-1, p_currency];
            }
        }
        if('price_currency' in skudata) { p_currency = skudata['price_currency']; }
        return [eval_cond_or_literal(skudata['price'], player, null), p_currency];

    } else if(formula === 'gamebucks_topup') {
        var bucks_per_credit = player.get_any_abtest_value('gamebucks_per_fbcredit_topup', gamedata['store']['gamebucks_per_fbcredit_topup']);
        if(bucks_per_credit < 0) { return [-1, p_currency]; }
        return [Math.max(1, Math.ceil(spellarg / (1.0*bucks_per_credit))), p_currency];
    } else if(formula.indexOf('barrier_upgrade') === 0) {
        var min_level = 99;
        session.for_each_real_object(function(obj) {
            if(obj.spec['name'] === 'barrier') {
                min_level = Math.min(min_level, obj.level);
            }
        });
        var up_level = parseInt(formula[formula.length-1],10);
        if(min_level >= up_level && !ignore_error) {
            return [-1, p_currency];
        } else {
            return [spell['price'], p_currency];
        }
    } else if(formula.indexOf('grow_base_perimeter') === 0) {
        var to_level = parseInt(formula[formula.length-1],10);
        if('currency' in spell) { p_currency = spell['currency']; }
        if(session.viewing_base.base_size >= to_level && !ignore_error) {
            return [-1, p_currency];
        }
        return [spell['price'], p_currency];
    } else if(formula === 'speedup' || formula === 'speedup_gamebucks') {
        var unit = session.get_real_world().objects.get_object(unit_id);

        if(unit.is_damaged() && !unit.is_repairing()) { return [-1, p_currency]; }

        var time_to_finish = unit.time_until_finish();

        var allow_free_speedup = true;
        var always_free_speedup = false;

        // check for blockage of free speedups
        if(unit.is_building() && !unit.is_repairing() && !unit.is_upgrading() && !unit.is_under_construction() && !unit.is_enhancing() && !unit.is_removing()) {
            if(unit.is_manufacturing()) {
                if(!player.unit_speedups_enabled()) {
                    return [-1, p_currency];
                }

                always_free_speedup = true;
                goog.array.forEach(unit.manuf_queue, function(item) {
                    var item_spec = gamedata['units'][item['spec_name']];
                    if('always_free_speedup' in item_spec && (get_leveled_quantity(item_spec['always_free_speedup'], item['level']))) {
                        return;
                    } else {
                        always_free_speedup = false;
                    }

                    if('no_free_speedup' in item_spec && (get_leveled_quantity(item_spec['no_free_speedup'], item['level']))) {
                        allow_free_speedup = false;
                    }
                });
            }
            if(unit.is_crafting()) {
                if(!player.crafting_speedups_enabled()) {
                    return [-1, p_currency];
                } else {
                    var queue = unit.get_crafting_queue();
                    if(goog.array.find(queue, function(bus) {
                        var cat = gamedata['crafting']['categories'][gamedata['crafting']['recipes'][bus['craft']['recipe']]['crafting_category']];
                        if(('speedupable' in cat) && !cat['speedupable']) {
                            return true;
                        }
                        return false;
                        })) {
                        return [-1, p_currency]; // no speedups
                    }
                }
            }
        }

        if(always_free_speedup || (allow_free_speedup && time_to_finish <= Store.get_free_speedup_time(player))) {
            return [0, p_currency];
        } else {
            if(allow_free_speedup && !player.get_any_abtest_value('count_free_speedup_time', gamedata['store']['count_free_speedup_time'])) {
                time_to_finish -= Store.get_free_speedup_time(player);
            }
            if(time_to_finish < 0) { time_to_finish = 0; }

            // apply upgrade_speedup_cost_factor
            if(unit.is_building() && !unit.is_repairing() && unit.is_upgrading()) {
                var factor = get_leveled_quantity(unit.spec['upgrade_speedup_cost_factor'] || 1, unit.level+1);
                time_to_finish *= factor;
            }


            if(formula === 'speedup_gamebucks') {
                p_currency = 'gamebucks';
            }
            var price = Store.get_speedup_price(player, unit.activity_speedup_kind(), time_to_finish, p_currency);

            return [price, p_currency];
        }
    } else if(formula === 'player_aura_speedup_gamebucks') {
        var aura_name = spellarg;
        p_currency = 'gamebucks';
        var aura_spec = gamedata['auras'][aura_name];
        if(!aura_spec || !aura_spec['speedupable']) {
            return [-1, p_currency];
        }

        var aura = goog.array.find(player.player_auras, function(a) {
            return (a['spec'] == aura_name) && ('end_time' in a);
        });
        if(!aura) {
            return [-1, p_currency];
        }
        var time_to_finish = Math.max(aura['end_time'] - server_time, 0)
        var price = Store.get_speedup_price(player, 'player_aura', time_to_finish, p_currency);
        return [price, p_currency];
    } else if(formula === 'squad_movement_speedup_gamebucks') {
        var squad_id = spellarg;
        p_currency = 'gamebucks';
        if(!player.squad_is_deployed(squad_id) || !player.squad_is_moving(squad_id)) {
            return [-1, p_currency];
        }
        var squad_data = player.squads[squad_id.toString()];
        var time_to_finish = Math.max(squad_data['map_path'][squad_data['map_path'].length-1]['eta'] - server_time, 1);
        var price = Store.get_speedup_price(player, 'squad_movement', time_to_finish, p_currency);
        return [price, p_currency];
    } else if(formula === 'unit_repair_speedup' || formula === 'unit_repair_speedup_gamebucks') {
        if(!player.unit_speedups_enabled()) {
            return [-1, p_currency];
        }

        if(player.unit_repair_queue.length < 1) { return [-1, p_currency]; }

        var time_to_finish = player.unit_repair_queue[player.unit_repair_queue.length-1]['finish_time'] - server_time;
        if(!player.get_any_abtest_value('count_free_speedup_time', gamedata['store']['count_free_speedup_time'])) {
            time_to_finish -= Store.get_free_speedup_time(player);
        }
        // NOTE! unit repair speedups do not have the "5 minute instant" option!
        if(time_to_finish <= 0) {
            time_to_finish = 0;
        }

        if(formula === 'unit_repair_speedup_gamebucks') {
            p_currency = 'gamebucks';
        }
        var price = Store.get_speedup_price(player, 'unit_repair', time_to_finish, p_currency);

        return [price, p_currency];
    } else if(formula === 'repair_all' || formula === 'repair_all_gamebucks') {
        // similar to a speedup, but charge for the SUM repair price of all damaged buildings
        var sum_price = 0;
        var sum_time = 0;
        if(formula === 'repair_all_gamebucks') { p_currency = 'gamebucks'; }

        session.for_each_real_object(function(obj) {
            if(obj.is_building() && obj.is_damaged()) {
                var repair_time;
                if(obj.is_repairing()) {
                    repair_time = obj.repair_finish_time - server_time;
                } else {
                    var health = (1.0*obj.hp) / obj.max_hp;
                    repair_time = Math.floor((1-health) * (obj.get_leveled_quantity(obj.spec['repair_time'])/obj.get_stat('repair_speed',1)));
                }
                if(repair_time < 0) { repair_time = 0; }
                sum_time += repair_time;
                var time_to_finish = repair_time - Store.get_free_speedup_time(player);
                if(time_to_finish <= 0) {
                } else {
                    sum_price += Store.get_speedup_price(player, 'building_repair', time_to_finish, p_currency);
                }
            }
        });

        if(player.get_any_abtest_value('building_repair_sum_times', gamedata['store']['building_repair_sum_times'])) {
            var time_to_finish = sum_time;
            if(time_to_finish <= Store.get_free_speedup_time(player)) {
                sum_price = 0;
            } else {
                sum_price = Store.get_speedup_price(player, 'building_repair', time_to_finish, p_currency);
            }
        }

        if(session.viewing_base.base_type != 'home') {
            // no free repairs away from home base - this is mainly
            // because the server doesn't implement it due to locking
            // complexity, not for design reasons
            if(sum_time > 0) { sum_price = Math.max(sum_price, 1); }
        }

        var do_units = session.home_base;

        if(!player.unit_speedups_enabled()) {
            do_units = false;
        }

        if(do_units) {
            // note: ignore repair queue, but sum unit times before applying formula
            var total_rep_time = 0;

            if(player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units'])) {
                goog.object.forEach(player.my_army, function(obj) {
                    var squad_id = obj['squad_id'] || 0;

                    // ignore army units not at home base
                    if(player.squad_is_deployed(squad_id)) { return; }

                    var spec = gamedata['units'][obj['spec']];
                    var level = obj['level'] || 1;
                    var curmax = army_unit_hp(obj);
                    if(curmax[0] < curmax[1]) {
                        if(/*(army_unit_repair_state(obj) == 0) && */ player.can_repair_unit_of_spec(spec, curmax[0])) {
                            var rep = mobile_cost_to_repair(spec, level, curmax[0], curmax[1], player);
                            total_rep_time += rep['time'];
                        }
                    }
                });

            } else { // OLD non-squads method
                session.for_each_real_object(function(obj) {
                    if(obj.is_mobile() && obj.is_damaged() && player.can_repair_unit(obj)) {
                        var rep = obj.cost_to_repair(player);
                        total_rep_time += rep['time'];
                    }
                });
            }

            if(total_rep_time > 0) {
                var time_to_finish = total_rep_time;
                if(!player.get_any_abtest_value('count_free_speedup_time', gamedata['store']['count_free_speedup_time'])) {
                    time_to_finish -= Store.get_free_speedup_time(player);
                }
                if(time_to_finish <= 0) {
                    time_to_finish = 0;
                }
                var unit_price = Store.get_speedup_price(player, 'unit_repair', time_to_finish, p_currency);
                sum_price += unit_price;
            }
        }
        return [sum_price, p_currency];

    } else if(formula === 'upgrade' || formula.indexOf('research') === 0 || formula.indexOf('enhance') === 0 || formula === 'craft_gamebucks') {
        var unit = null;
        if(unit_id == GameObject.VIRTUAL_ID && player.is_cheater && formula.indexOf('research') === 0) {

        } else {
            unit = session.get_real_world().objects.get_object(unit_id);
            if(!unit.is_building() || unit.is_damaged() ||
               (unit.is_busy() && !(((formula.indexOf('research') === 0) && unit.is_researching()) ||
                                    ((formula.indexOf('enhance') === 0) && unit.is_enhancing())))) {
                return [-1, p_currency];
            }
        }

        var price;

        if(formula === 'upgrade') {
            if(unit.level >= unit.get_max_ui_level()) {
                return [-1, p_currency];
            }
            if(('requires' in unit.spec) && !player.is_cheater) {
                var pred = read_predicate(get_leveled_quantity(unit.spec['requires'], unit.level+1));
                if(!pred.is_satisfied(player, null)) {
                    return [-1, p_currency];
                }
            }

            if(!player.is_cheater) {
                for(var res in gamedata['resources']) {
                    var resdata = gamedata['resources'][res];
                    if(!resource_allow_instant_upgrade(resdata,player)) {
                        if(get_leveled_quantity(unit.spec['build_cost_'+res] || 0, unit.level+1) > 0) {
                            return [-1, p_currency]; // requires rare resource
                        }
                    }
                }
                if(!ingredients_list_allows_instant(get_building_ingredients_list(unit.spec, unit.level+1))) {
                        return [-1, p_currency]; // requires rare item
                }
            }

            if('upgrade_gamebucks_cost' in unit.spec) {
                p_currency = 'gamebucks';
                price = get_leveled_quantity(unit.spec['upgrade_gamebucks_cost']||-1, unit.level+1);
            } else {
                price = get_leveled_quantity(unit.spec['upgrade_credit_cost']||-1, unit.level+1);
            }
            var factor = player.get_any_abtest_value('building_muffin_factor', gamedata['store']['building_muffin_factor']);
            if(factor != 1) {
                price = Math.round(factor*price);
            }
        } else if(formula === 'craft_gamebucks') {
            p_currency = 'gamebucks';
            var delivery = spellarg['delivery'] || null;
            var recipe = gamedata['crafting']['recipes'][spellarg['recipe']];
            var recipe_level = spellarg['level'] || 1;
            var category = gamedata['crafting']['categories'][recipe['crafting_category']];

            /* allow instant upgrades even if foreman is busy
            if(category['foreman'] && player.foreman_is_busy()) {
                return [-1, p_currency];
            }
            */

            if(!player.is_cheater) {
                for(var res in gamedata['resources']) {
                    var resdata = gamedata['resources'][res];
                    if(!resource_allow_instant_upgrade(resdata,player)) {
                        if((get_leveled_quantity(get_leveled_quantity(recipe['cost'], recipe_level)[res] || 0, recipe_level)) > 0) {
                            return [-1, p_currency]; // requires rare resource
                        }
                    }
                }
                var pred_fail = false;
                goog.array.forEach(['show_if','requires','activation'], function(predname) {
                    if(predname in recipe && !read_predicate(get_leveled_quantity(recipe[predname], recipe_level)).is_satisfied(player, null)) { pred_fail = true; };
                });
                if(pred_fail) { return [-1, p_currency]; }

                var limited_or_unique_equipped_fail = false;
                if(!ignore_error && delivery && delivery['obj_id']) {
                    var product_list = get_crafting_recipe_product_list(recipe, recipe_level);
                    goog.array.forEach(product_list, function(my_product) {
                        var delivery_address = new BuildingEquipSlotAddress(delivery['obj_id'], delivery['slot_type'], delivery['slot_index']);
                        if(my_product['spec']) {
                            if(player.would_violate_limited_equipped(ItemDisplay.get_inventory_item_spec(my_product['spec']), delivery_address) ||
                               player.would_violate_unique_equipped(ItemDisplay.get_inventory_item_spec(my_product['spec']), delivery_address)) {
                                limited_or_unique_equipped_fail = true;
                            }
                        }
                    });
                }
                if(limited_or_unique_equipped_fail) { return [-1, p_currency]; }
            }
            // check existing queue
            // we don't bother with the more detailed checks the server does, since only a client bug would cause mal-formed requests here
            var craft_queue = unit.get_crafting_queue();
            if('queueable' in category && !category['queueable']) {
                if(craft_queue.length > 0) { return [-1, p_currency]; } // note: doesn't handle uncollected finished jobs
            }

            // check destination slot (XXX redundant with can_cast_spell_detailed)
            if(delivery && delivery['obj_id']) {
                var other = session.get_real_world().objects.get_object(delivery['obj_id']);
                if(!delivery['replace']) {
                    if(other.equipment && delivery['slot_type'] in other.equipment && other.equipment[delivery['slot_type']][delivery['slot_index']||0]) {
                        return [-1, p_currency];
                    }
                }
                var product_item = get_crafting_recipe_product_list(recipe, recipe_level)[0];
                var product_level = ItemDisplay.get_inventory_item_level(product_item);
                var product_spec = ItemDisplay.get_inventory_item_spec(product_item['spec']);
                var compat_list;
                if('compatible' in product_spec['equip']) {
                    compat_list = product_spec['equip']['compatible'];
                } else {
                    compat_list = [product_spec['equip']];
                }
                var ret = null;
                goog.array.forEach(compat_list, function(compat) {
                    if(ret) { return; } // already found a reason we cannot proceed
                    if('min_level' in compat) {
                        var min_level = get_leveled_quantity(compat['min_level'], product_level);
                        if(other.level < min_level) {
                            ret = [-1, p_currency];
                        }
                    }
                });
                if(ret) { return ret; }
            }

            price = get_leveled_quantity(recipe['craft_gamebucks_cost']||-1, recipe_level);

        } else if(formula.indexOf('enhance') === 0) {
            var enh_name = spellarg[0];
            var new_level = spellarg[1];
            var spec = gamedata['enhancements'][enh_name];

            var cur_level = (unit.enhancements[enh_name] || 0);
            if(new_level != cur_level + 1) {
                return [-1, p_currency];
            }

            if(new_level > get_max_ui_level(spec)) {
                return [-1, p_currency];
            }
            if(spec['developer_only'] && (spin_secure_mode || !player.is_developer())) {
                return [-1, p_currency];
            }
            if(!goog.array.contains(unit.spec['enhancement_categories'] || [],
                                    spec['enhancement_category'])) {
                return [-1, p_currency];
            }
            if(unit.level < get_leveled_quantity(spec['min_host_level']||0, new_level)) {
                return [-1, p_currency];
            }
            if(('requires' in spec) && !player.is_cheater) {
                var pred = read_predicate(get_leveled_quantity(spec['requires'], new_level));
                if(!pred.is_satisfied(player, null)) {
                    return [-1, p_currency];
                }
            }

            if(!player.is_cheater) {
                for(var res in gamedata['resources']) {
                    var resdata = gamedata['resources'][res];
                    if(!resource_allow_instant_upgrade(resdata,player)) {
                        if(get_leveled_quantity(spec['cost_'+res] || 0, new_level) > 0) {
                            return [-1, p_currency]; // requires rare resource
                        }
                    }
                }
                if(!ingredients_list_allows_instant(get_enhancement_ingredients_list(spec, new_level))) {
                    return [-1, p_currency]; // requires rare item
                }
            }

            if(formula === 'enhance_gamebucks' && 'enhance_gamebucks_cost' in spec) {
                p_currency = 'gamebucks';
                price = get_leveled_quantity(spec['enhance_gamebucks_cost'], new_level);
            } else if(formula === 'enhance' && 'enhance_credit_cost' in spec) {
                price = get_leveled_quantity(spec['enhance_credit_cost'], new_level);
            } else {
                throw Error('unhandled formula/cost '+formula+' for '+enh_name);
            }

        } else {
            // tech research
            var spec = gamedata['tech'][spellarg];
            var new_level;
            if(spellarg in player.tech) {
                new_level = player.tech[spellarg] + 1;
            } else {
                new_level = 1;
            }
            if(new_level > get_max_ui_level(spec)) {
                return [-1, p_currency];
            }
            if(spec['developer_only'] && (spin_secure_mode || !player.is_developer())) {
                return [-1, p_currency];
            }
            if(!unit && !player.is_cheater) {
                return [-1, p_currency];
            }
            if(unit) {
                if(!unit.is_researcher()) {
                    return [-1, p_currency];
                }
                var found = false;
                var categories = unit.spec['research_categories'] || [];
                for(var i = 0; i < categories.length; i++) {
                    if(spec['research_category'] === categories[i]) {
                        found = true;
                        break;
                    }
                }
                if(!found) {
                    return [-1, p_currency];
                }
            }
            if(('requires' in spec) && !player.is_cheater) {
                var pred = read_predicate(get_leveled_quantity(spec['requires'], new_level));
                if(!pred.is_satisfied(player, null)) {
                    return [-1, p_currency];
                }
            }
            if(('activation' in spec) && !player.is_cheater) {
                if(!read_predicate(spec['activation']).is_satisfied(player, null)) {
                    return [-1, p_currency];
                }
            }

            if(!player.is_cheater) {
                for(var res in gamedata['resources']) {
                    var resdata = gamedata['resources'][res];
                    if(!resource_allow_instant_upgrade(resdata,player)) {
                        if(get_leveled_quantity(spec['cost_'+res] || 0, new_level) > 0) {
                            return [-1, p_currency]; // requires rare resource
                        }
                    }
                }
                if(!ingredients_list_allows_instant(get_tech_ingredients_list(spec, new_level))) {
                    return [-1, p_currency]; // requires rare item
                }
            }

            if(formula === 'research_gamebucks' && 'research_gamebucks_cost' in spec) {
                p_currency = 'gamebucks';
                price = get_leveled_quantity(spec['research_gamebucks_cost'], new_level);
            } else if(formula === 'research' && 'research_credit_cost' in spec) {
                price = get_leveled_quantity(spec['research_credit_cost'], new_level);
            } else {
                throw Error('unhandled formula/cost '+formula+' for '+spellarg);
            }

            var factor = player.get_any_abtest_value('tech_muffin_factor', gamedata['store']['tech_muffin_factor']);
            if(factor != 1) {
                price = Math.round(factor*price);
            }
        }

        return [price, p_currency];

    } else if(formula === 'resource_boost' || formula === 'resource_boost_gamebucks' || formula === 'resource_boost_constant') {
        if(formula === 'resource_boost_gamebucks') { p_currency = 'gamebucks'; }

        var resource = spell['resource'];
        var amount;
        if('give_amount' in spell) { // constant boosts
            amount = spell['give_amount'];
            if((player.resource_state[resource][1] + amount) > player.resource_state[resource][0] && !ignore_error) {
                return [-1, spell['currency']];
            }
        } else if(spell['boost_amount'] < 1) { // percentage boosts
            amount = Math.floor(spell['boost_amount'] * player.resource_state[resource][0]);
            // only allow purchase of sub-100% boosts if there is storage room
            if((player.resource_state[resource][1] + amount) > player.resource_state[resource][0] && !ignore_error) {
                return [-1, p_currency];
            }
        } else {
            // 100% boost
            if(player.resource_state[resource][1] >= player.resource_state[resource][0]) {
                if(!ignore_error) {
                    // completely full
                    return [-1, p_currency];
                } else {
                    // for the ignore_error case, we'll return zero price, but the caller needs to be careful not to display this as "free"
                    amount = 0;
                }
            } else {
                amount = player.resource_state[resource][0] - player.resource_state[resource][1];
            }
        }
        if(formula === 'resource_boost_constant') {
            return [spell['price'], spell['currency']];
        } else {
            return [Store.get_resource_price(resource, amount, p_currency), p_currency];
        }
    } else if(formula === 'resource_topup') {
        p_currency = 'gamebucks'; // only option for this
        var price = 0;
        for(var res in spellarg) {
            if(!gamedata['resources'][res]['allow_topup']) {
                return [-1, p_currency]; // not allowed
            }
            if(player.resource_state[res][1] + spellarg[res] > player.resource_state[res][0]) {
                return [-1, p_currency]; // not enough room in storage
            }
            price += Store.get_resource_price(res, spellarg[res], p_currency);
        }
        return [price, p_currency];
    } else {
        throw Error('Unknown price formula '+formula);
    }
};

/** Returns a parameter from store.json that might be overridden by an A/B test, and/or a per-resource dictionary
    @param {string} name
    @param {string} resname
    @returns {?} */
Store.get_resource_parameter = function(name, resname) {
    var ret = player.get_any_abtest_value(name, gamedata['store'][name]);
    if(typeof ret === 'object' && !(0 in ret)) { // detect dictionaries
        ret = ret[resname];
    }
    return ret;
};

/** Returns the price of an arbitrary amount of fungible resources
    @param {number} amount
    @param {string} currency
    @returns {number} */
Store.get_resource_price = function(resname, amount, currency) {
    if(amount <= 0) { return 0; }

    var price_formulas = {
        'legacy_exp_log': function(_resname, _amount, _currency) {
            var scale_factor = Store.get_resource_parameter('resource_price_formula_scale', _resname);
            var coeff = (_currency === 'gamebucks' ? player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) : 1);
            var price = scale_factor * coeff * 0.06 * Math.exp(0.75 * (log10(_amount) - 2.2 * Math.pow(log10(_amount), -1.25)));
            return (_amount > 2) ? price : 1;
        },
        'piecewise_linear': function(_resname, _amount, _currency) {
            var price_points = Store.get_resource_parameter('resource_price_formula_piecewise_linear_points', _resname);

            for(var i = 1; i < price_points.length; i++) {
                if(_amount < price_points[i][0] || i == price_points.length - 1) {
                    var scale_factor = Store.get_resource_parameter('resource_price_formula_scale', _resname);
                    // scale down for fbcredits since this formula is designed for gamebucks
                    var coeff = (_currency !== 'gamebucks' ? 1 / player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) : 1);
                    var slope = (price_points[i][1] - price_points[i - 1][1]) / (price_points[i][0] - price_points[i - 1][0]);
                    return scale_factor * coeff * price_points[i - 1][1] + slope * (_amount - price_points[i - 1][0]);
                }
            }

            throw Error("Unhandled case while calculating piecewise_linear prices. This should never happen.");
        },
        'by_townhall_level': function(_resname, _amount, _currency) {
            var scale_factor = Store.get_resource_parameter('resource_price_formula_scale', _resname);
            var price_points = Store.get_resource_parameter('resource_price_formula_by_townhall_level', _resname);

            var th_level = player.get_townhall_level();
            var res_per_gamebuck = price_points[th_level-1];
            var coeff = (_currency !== 'gamebucks' ? 1.0 / player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) : 1.0);
            return scale_factor * coeff * amount / res_per_gamebuck;
        }
    };
    var price_formula_name = Store.get_resource_parameter('resource_price_formula', resname);
    return Math.ceil(price_formulas[price_formula_name](resname, amount, currency));
}

Store.fbcredits_to_dollars = function(amt) { return 0.07 * amt; };
Store.kgcredits_to_dollars = function(amt) { return 0.07 * amt; };

// To work around browsers dropping the order completion callback due
// to cross-site scripting errors, manually fire several events to update
// the GUI on the first UI event to happen after the dialog goes up.
// THEORETICALLY, if the Facebook API works correctly and calls the callback
// we supply, this should not be necessary.

Store.force_order_cleanup = function() {
    if(Store.order_cleanup_cb) {
        var cb = Store.order_cleanup_cb;
        console.log('PERFORMING POST-ORDER CLEANUP');
        Store.order_cleanup_cb = null;
        session.for_each_real_object(function(obj) {
            send_to_server.func(["PING_OBJECT", obj.id, "post_order_cleanup"]);
        });
        send_to_server.func(["UNIT_REPAIR_TICK"]);
        send_to_server.func(["PING_CREDITS"]);
        send_to_server.func(["PING_TECH"]);
        send_to_server.func(["PING_PLAYER"]);
        metric_event('4067_order_prompt_callback_dropped', add_demographics({}));
        cb();
    }
};

// NOTE: cb is a UI cleanup callback that will be called ONLY for gamebucks purchases, not for FB credits purchases!
// FB credits purchases always have to kill the entire UI because the FB script callback is unreliable
// cb is called on success only with no parameter. To catch failures, pass another callback as props.on_fail.

/** @param {GameObjectId} unit_id
    @param {string} spellname
    @param {?} spellarg
    @param {function()|null=} cb
    @param {Object|null=} props */
Store.place_user_currency_order = function(unit_id, spellname, spellarg, cb, props) {
    return Store.place_order(Store.get_user_currency(), unit_id, spellname, spellarg, cb, props);
};

/** @param {string} currency
    @param {GameObjectId} unit_id
    @param {string} spellname
    @param {?} spellarg
    @param {function()|null=} cb
    @param {Object|null=} props */
Store.place_order = function(currency, unit_id, spellname, spellarg, cb, props) {
    var no_clear = props && props['no_clear'];

    var price = Store.get_price(currency, unit_id, gamedata['spells'][spellname], spellarg, false);

    if(price < 0 || (price == 0 && (currency == 'fbcredits' || currency.indexOf('fbpayments:') === 0 || currency.indexOf('xsolla:') === 0))) {
        change_selection(null);
        var msg = 'Error: invalid order, probably due to time delay, please try again.';
        user_log.msg(msg, new SPUI.Color(1,0,0,1));
        return false;
    }

    if(currency == 'fbcredits' || currency == 'kgcredits' ||
       currency.indexOf('fbpayments:') === 0 || currency.indexOf('xsolla:') === 0) {
        player.record_client_history('purchase_inits', 1);
        if((player.history['money_spent'] || 0) <= 0) {
            player.record_client_history('purchase_inits_preftd', 1);
        }
    }

    if(currency == 'fbcredits') {
        if(!no_clear) { change_selection(null); }
        Store.place_fbcredits_order(price, unit_id, spellname, spellarg, cb);
        return false;
    } else if(currency == 'kgcredits') {
        if(!no_clear) { change_selection(null); }
        Store.place_kgcredits_order(price, unit_id, spellname, spellarg, cb, (props ? (props['fail_cb'] || null) : null));
        return false;
    } else if(currency == 'microsoft') {
        if(!no_clear) { change_selection(null); }
        Store.place_microsoft_order(price, unit_id, spellname, spellarg, cb, (props ? (props['fail_cb'] || null) : null));
        return false;
    } else if(currency.indexOf('fbpayments:') === 0 || currency.indexOf('xsolla:') === 0 || currency.indexOf('microsoft:') === 0) {
        if(!no_clear) { change_selection(null); }
        if(SPay.api == 'xsolla') {
            Store.place_xsolla_order(spellname, spellarg, cb, props);
        } else if (SPay.api == 'microsoft') {
            Store.place_microsoft_order(price, unit_id, spellname, spellarg, cb, (props ? (props['fail_cb'] || null) : null));
        } else {
            Store.place_fbpayments_order(currency, price, unit_id, spellname, spellarg, cb, props);
        }
        return false;
    } else if(currency == 'gamebucks') {
        return Store.place_gamebucks_order(price, unit_id, spellname, spellarg, cb);
    } else if(currency.indexOf('item:') === 0) {
        return Store.place_item_order(currency.split(':')[1], price, unit_id, spellname, spellarg, cb);
    } else if(currency.indexOf('score:') === 0) {
        return Store.place_score_order(currency.split(':')[1], price, unit_id, spellname, spellarg, cb);
    } else if(currency in gamedata['resources']) {
        return Store.place_fungible_order(currency, price, unit_id, spellname, spellarg, cb);
    } else {
        throw Error('unknown currency '+currency);
    }
};

Store.order_serial = 6543;
Store.order_receiver = new goog.events.EventTarget();

/** @param {string} tag_prefix
    @param {function(boolean)|null} cb
    @return {string} tag to send with the order */
Store.listen_for_order_ack = function(tag_prefix, cb) {
    Store.order_serial += 1;
    var tag = tag_prefix+Store.order_serial.toString();
    if(cb) {
        // need this adaptor to pull the .success property out of the event object
        Store.order_receiver.listenOnce(tag, (function (_cb) { return function(event) { _cb(event.success); }; })(cb));
    }
    return tag;
};

Store.place_gamebucks_order = function(price, unit_id, spellname, spellarg, cb) {
    if(price > 0 && player.resource_state['gamebucks'] < price) {
        var descr = ''; // 'INSUFFICIENT:';
        try {
            // really don't want to get errors here, since it would kill the order
            var unit = session.get_real_world().objects._get_object(unit_id);
            descr += spellname+(unit ? ','+unit.spec['name']:'')+(spellarg?','+spellarg.toString():'');
        } catch (e) {
            descr += 'UNKNOWN';
        }

        invoke_insufficient_alloy_message(descr, price - player.resource_state['gamebucks'],
                                          {'price':price, 'unit_id':unit_id, 'spellname':spellname, 'spellarg':spellarg, 'cb': cb});
        return false;
    }

    var tag = Store.listen_for_order_ack('gbo', cb);
    send_to_server.func(["GAMEBUCKS_ORDER", tag, price, unit_id, spellname, spellarg, Math.floor(server_time)]);

    return true;
};

Store.place_item_order = function(specname, price, unit_id, spellname, spellarg, cb) {
    var has_qty = player.inventory_item_quantity(specname);
    if(has_qty < price) {
        var s = gamedata['errors']['INSUFFICIENT_ITEMS'];
        var spec = ItemDisplay.get_inventory_item_spec(specname);
        invoke_child_message_dialog(s['ui_title'], s['ui_name'].replace('%s',spec['ui_name_plural'] || spec['ui_name']).replace('%d',pretty_print_number(price-has_qty)), {'dialog': 'message_dialog_big'});
        return false;
    }

    var tag = Store.listen_for_order_ack('io', cb);
    send_to_server.func(["ITEM_ORDER", tag, specname, price, unit_id, spellname, spellarg, Math.floor(server_time)]);

    return true;
}

Store.place_fungible_order = function(resname, price, unit_id, spellname, spellarg, cb) {
    var has_qty = player.resource_state[resname][1];
    if(has_qty < price) {
        var resources_needed = {}; resources_needed[resname] = price - has_qty;
        var helper = get_requirements_help('resources', resources_needed, {even_if_tutorial_incomplete:true, continuation: null}); // maybe cb?
        if(helper) {
            helper();
        } else { // worst-case fallback
            var cost = {}; cost[resname] = price;
            invoke_insufficient_resources_message(cost, gamedata['errors']['INSUFFICIENT_RESOURCES']['ui_name']);
        }
        return false;
    }

    var tag = Store.listen_for_order_ack('fo', cb);
    send_to_server.func(["FUNGIBLE_ORDER", tag, resname, price, unit_id, spellname, spellarg, Math.floor(server_time)]);

    // client-side prediction
    player.resource_state[resname][1] -= price;

    return true;
}

Store.place_score_order = function(stat_name, price, unit_id, spellname, spellarg, cb) {
    if(!goog.array.contains(['trophies_pvp', 'trophies_pvv'], stat_name)) {
        throw Error('unknown stat to query '+stat_name);
    }
    var has_qty = 0;
    var player_data = PlayerCache.query_sync(session.user_id);
    if(player_data && (stat_name in player_data)) {
        has_qty = player_data[stat_name];
    }
    if(has_qty < price) {
        var resources_needed = {}; resources_needed[stat_name] = price - has_qty;
        var helper = get_requirements_help('score', resources_needed, {even_if_tutorial_incomplete:true, continuation: null}); // maybe cb?
        if(helper) {
            helper();
        } else { // worst-case fallback
            var s = gamedata['errors']['INSUFFICIENT_'+stat_name.toUpperCase()];
            invoke_child_message_dialog(s['ui_title'], s['ui_name'].replace('%d', pretty_print_number(price - has_qty)), {'dialog': 'message_dialog_big'});
        }
        return false;
    }

    var tag = Store.listen_for_order_ack('so', cb);
    send_to_server.func(["SCORE_ORDER", tag, stat_name, price, unit_id, spellname, spellarg, Math.floor(server_time)]);

    // client-side prediction
    if(price != 0) {
        player_data[stat_name] -= price;
    }

    return true;
}

Store.place_fbcredits_order = function(price, unit_id, spellname, spellarg, on_finish) {
    var descr = spellname;
    if(spellarg) {
        descr += ','+spellarg;
    }
    if(unit_id && unit_id != GameObject.VIRTUAL_ID) {
        var object = session.get_real_world().objects.get_object(unit_id);
        descr += ','+object.spec['name'];
    }

    var icon;
    if(spellname.indexOf('BUY_GAMEBUCKS') === 0) {
        icon = player.get_any_abtest_value('fb_order_dialog_gamebucks_icon', gamedata['store']['fb_order_dialog_gamebucks_icon']);
    } else {
        icon = player.get_any_abtest_value('fb_order_dialog_generic_icon', gamedata['store']['fb_order_dialog_generic_icon']);
    }

    var tag = Store.listen_for_order_ack('fbo', on_finish);

    // this is arbitrary custom data for our server
    var order_info = {
        'session_id': session.session_id,
        'unit_id': unit_id,
        'client_unit_type': (object ? object.spec['name'] : null),
        'server_time_according_to_client': Math.floor(server_time),
        'spellname': spellname,
        'spellarg': spellarg,
        'client_price': price,
        'tag': tag,
        // have to pull images from proxyserver (?)
        'image_url': spin_server_protocol+spin_server_host+':'+spin_server_port+'/'+icon,
        'product_url': spin_server_protocol+spin_server_host+':'+spin_server_port+'/'+icon
    };

    // order completion callback
    var order_complete = (function(uid, pr, desc) { return function(data) {

        Store.order_cleanup_cb = null; // cancel it

        var props = {'currency': 'fbcredits',
                     'Billing Amount': Store.fbcredits_to_dollars(pr),
                     'Billing Description': desc};

        if(data['status'] != 'settled') {
            var msg = 'unknown error';
            if('error_code' in data && 'error_message' in data) {
                msg = 'error: '+data['error_code']+' '+data['error_message'];
            } else if('status' in data) {
                msg = 'status: '+data['status'];
            }
            console.log('ORDER PROBLEM: '+msg);
            props['method'] = msg;
            var ename;
            if(data['error_code'] == 1383010) {
                ename = '4068_order_prompt_canceled';
            } else {
                ename = '4069_order_prompt_failure';
            }
            metric_event(ename, props);
        } else {
            var msg = '';
            if('order_id' in data) {
                msg = 'order_id: '+data['order_id'];
                props['order_id'] = data['order_id'];
            }
            metric_event('4070_order_prompt_success', props);

            console.log('ORDER SUCCESSFUL: '+msg);

            // give realtime feedback on Facebook credit balance display
            // this may not be accurate - but we'll get an accurate update from the server
            // when it polls the Facebook API after processing the order
            player.resource_state['facebook_credits'] -= pr;

            // check for updated object and player status
            if(uid) {
                send_to_server.func(["PING_OBJECT", uid, "order_success"]);
            }
            send_to_server.func(["PING_TECH"]);
            send_to_server.func(["PING_PLAYER"]);
        }
    }; })(unit_id, price, descr);

    var props = {'currency': 'fbcredits',
                 'Billing Amount': Store.fbcredits_to_dollars(price),
                 'Billing Description': descr};

    if(spin_facebook_enabled) {
        // use the real Facebook Credits API
        var use_local_currency = (player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks') && player.get_any_abtest_value('use_local_currency', gamedata['store']['use_local_currency']) && player.facebook_currency;

        try {
            if(get_query_string('simulate_cb_fail')) { order_complete = function() { console.log("SIMULATING FB.PAY CALLBACK FAILURE"); }; }

            SPay.place_order_fbcredits(order_info, order_complete, use_local_currency);
        } catch(e) {
            log_exception(e, 'place_order');
            metric_event('4061_order_prompt_api_error', props);
            return false;
        }

        // set the cleanup-pending flag AFTER giving enough time for Facebook's dialog to block the UI
        window.setTimeout(function() { Store.order_cleanup_cb = function() {}; }, 2000);

    } else {
        // pretend the purchase was made successfully
        send_to_server.func(["DEV_SIMULATE_ORDER", order_info, 'fbcredits']);
        order_complete({'status':'settled'});

        user_log.msg('Simulating payment of '+ price.toString() + ' Facebook Credit(s)', new SPUI.Color(1,1,0,1));
        //invoke_child_message_dialog("Developer Message", 'Simulating payment of '+ price + ' Facebook credit(s)');
    }

    metric_event('4060_order_prompt', props);
    return true;
};

Store.place_kgcredits_order = function(price, unit_id, spellname, spellarg, on_finish, on_fail) {
    var descr = spellname;
    if(spellarg) {
        descr += ','+spellarg;
    }
    if(unit_id && unit_id != GameObject.VIRTUAL_ID) {
        var object = session.get_real_world().objects.get_object(unit_id);
        descr += ','+object.spec['name'];
    }

    var icon = player.get_any_abtest_value('fb_order_dialog_gamebucks_icon', gamedata['store']['fb_order_dialog_gamebucks_icon']);

    var tag = Store.listen_for_order_ack('kgo', on_finish);

    // this is arbitrary custom data for our server
    var order_info = {
        'session_id': session.session_id,
        'unit_id': unit_id,
        'client_unit_type': (object ? object.spec['name'] : null),
        'server_time_according_to_client': Math.floor(server_time),
        'spellname': spellname,
        'spellarg': spellarg,
        'client_price': price,
        'tag': tag,
        // have to pull images from proxyserver (?)
        'image_url': spin_server_protocol+spin_server_host+':'+spin_server_port+'/'+icon
    };

    // order completion callback
    var order_complete = (function(uid, pr, desc, _on_fail) { return function(data) {

        Store.order_cleanup_cb = null; // cancel it

        var props = {'currency': 'kgcredits',
                     'Billing Amount': Store.kgcredits_to_dollars(pr),
                     'Billing Description': desc};

        if(!data['success']) {
            var msg = 'unknown error';
            console.log('ORDER PROBLEM: '+msg);
            props['method'] = msg;
            var ename = '4069_order_prompt_failure';
            metric_event(ename, props);
            if(_on_fail) { _on_fail(); }
        } else {
            var msg = '';
            if('item_order_id' in data) {
                msg = 'item_order_id: '+data['item_order_id'];
                props['item_order_id'] = data['item_order_id'];
            }
            metric_event('4070_order_prompt_success', props);

            console.log('ORDER SUCCESSFUL: '+msg);

            // check for updated object and player status
            if(uid) {
                send_to_server.func(["PING_OBJECT", uid, "order_success"]);
            }
            send_to_server.func(["PING_TECH"]);
            send_to_server.func(["PING_PLAYER"]);
        }
    }; })(unit_id, price, descr, on_fail);

    var props = {'currency': 'kgcredits',
                 'Billing Amount': Store.fbcredits_to_dollars(price),
                 'Billing Description': descr};
    var coded_order_info = 'SP'+SPHTTP.wrap_string(JSON.stringify(order_info));

    if(spin_kongregate_enabled) {
        // use the real API
        try {
            if(get_query_string('simulate_cb_fail')) { order_complete = function() { console.log("SIMULATING KONGREGATE.MTX.PURCHASEITEMsREMOTE CALLBACK FAILURE"); }; }
            SPay.place_order_kgcredits(coded_order_info, order_complete);
        } catch(e) {
            log_exception(e, 'place_order');
            metric_event('4061_order_prompt_api_error', props);
            return false;
        }
        // set the cleanup-pending flag AFTER giving enough time for Kongregate's dialog to block the UI
        window.setTimeout(function() { Store.order_cleanup_cb = function() {}; }, 2000);
    } else {
        // pretend the purchase was made successfully
        send_to_server.func(["DEV_SIMULATE_ORDER", coded_order_info, 'kgcredits']);
        order_complete({'success':true});

        user_log.msg('Simulating payment of '+ price.toString() + ' Kongregate Kred(s)', new SPUI.Color(1,1,0,1));
    }

    metric_event('4060_order_prompt', props);
    return true;
};

Store.place_microsoft_order = function(price, unit_id, spellname, spellarg, on_finish, on_fail) {
    var descr = spellname;
    if(spellarg) {
        descr += ','+spellarg;
    }
    if(unit_id && unit_id != GameObject.VIRTUAL_ID) {
        var object = session.get_real_world().objects.get_object(unit_id);
        descr += ','+object.spec['name'];
    }
    var tag = Store.listen_for_order_ack('mso', on_finish);
    // this is arbitrary custom data for our server
    var order_info = {
        'session_id': session.session_id,
        'unit_id': unit_id,
        'client_unit_type': (object ? object.spec['name'] : null),
        'server_time_according_to_client': Math.floor(server_time),
        'spellname': spellname,
        'sku': spellname,
        'spellarg': spellarg,
        'tag': tag,
        'client_price': price
    };
    // add a debug flag to the Microsoft payments API if debugging is enabled
    // this will show the Microsoft Store payments browser window and console for debugging
    if('enable_microsoft_payments_debug_if' in gamedata['store']) {
        if(read_predicate(gamedata['store']['enable_microsoft_payments_debug_if']).is_satisfied(player)) {
            order_info['debug'] = 1;
        }
    }
    var props = {'currency': 'microsoft_store',
                 'Billing Amount': price,
                 'Billing Description': descr};
    SPay.place_order_microsoft(order_info)
                .then(function(result) {
                    var receipt = result['result'];
                    console.log('Microsoft payments API result received') // debugging message, remove after testing
                    console.log(result) // debugging message, remove after testing
                    // send_to_server.func(["VERIFY_MICROSOFT_STORE_RECEIPT", receipt, "order_complete"]); // add back in when ready for server verification phase
                    send_to_server.func(["PING_TECH"]);
                    send_to_server.func(["PING_PLAYER"]);

                    var msg = 'receipt: '+ receipt;
                    props['receipt'] = receipt;
                    metric_event('4070_order_prompt_success', props);
                    console.log('ORDER SUCCESSFUL: '+msg);
                },
                      function(error) {
                          var msg = 'unknown error';
                          console.log('Microsoft payments API ORDER PROBLEM: '+msg); // debugging message, remove 'Microsoft payments API' after testing
                          props['method'] = msg;
                          log_exception(error, 'place_order');
                          metric_event('4061_order_prompt_api_error', props);
                          if(on_fail) { on_fail(); }
                });
    metric_event('4060_order_prompt', props);
    return true;
};

Store.place_fbpayments_order = function(fbpayments_currency, price, unit_id, spellname, spellarg, on_finish, options) {
    if(!options) { options = {}; }
    var on_fail = options['fail_cb'] || null;
    var gift_order = options['gift_order'] || null;

    if(fbpayments_currency.indexOf('fbpayments:') !== 0) {
        throw Error('place_fbpayments_order with bad currency '+fbpayments_currency);
    }

    var currency = fbpayments_currency.split(':')[1];
    var spell = gamedata['spells'][spellname];

    var descr = spellname;
    if(spellarg) {
        descr += ','+spellarg;
    }
    if(unit_id && unit_id != GameObject.VIRTUAL_ID) {
        var object = session.get_real_world().objects.get_object(unit_id);
        descr += ','+object.spec['name'];
    }

    var product_url_props = {'spellname':spellname, 'type':gamedata['game_id']+'_sku'};
    if('loot_table' in spell) { // if the spell has an item bundle, opt-in to the want_loot flag
        if(session.get_loot_items(player, gamedata['loot_tables_client'][spell['loot_table']]['loot']).item_list.length > 0) {
            product_url_props['want_loot']='1';
        }
    }
    var product_url = ogpapi_url(product_url_props);
    var quantity = 1;

    var tag = Store.listen_for_order_ack('fbp', on_finish);

    var request_id = gamedata['game_id']+'_'+session.user_id.toString()+'_'+spin_session_id+'_'+tag;

    var props = {'currency': currency,
                 'price': price,
                 'description': descr,
                 'product_url': product_url,
                 'request_id': request_id,
                 'quantity': 1};

    send_to_server.func(["FBPAYMENT_CREATE", tag, request_id, unit_id, spellname, spellarg, price, currency,
                         product_url, quantity, Math.floor(server_time), gift_order]);

    // order completion callback
    var order_complete = (function(_unit_id, _props, _on_fail) { return function(data) {

        Store.order_cleanup_cb = null; // cancel it

        if(!data || (data['status'] != 'completed')) {
            var msg = 'unknown error';
            if(data) {
                if('error_code' in data && 'error_message' in data) {
                    msg = 'error: '+data['error_code']+' '+data['error_message'];
                } else if('status' in data) {
                    msg = 'status: '+data['status'];
                }
            }
            console.log('ORDER PROBLEM: '+msg);
            _props['method'] = msg;
            var ename;
            if(data && data['error_code'] == 1383010) {
                ename = '4075_fbpayments_order_prompt_canceled';
            } else {
                ename = '4076_fbpayments_order_prompt_failure';
            }
            metric_event(ename, _props);
            send_to_server.func(["FBPAYMENT_IGNORE", _props['request_id']]);
            if(_on_fail) { _on_fail(); }
        } else {
            var msg = '';
            if('payment_id' in data) {
                msg = 'payment_id: '+data['payment_id'];
                _props['payment_id'] = data['payment_id'];
            }
            metric_event('4077_fbpayments_order_prompt_success', _props);

            console.log('ORDER SUCCESSFUL: '+msg);

            send_to_server.func(["FBPAYMENT_PING", _props['request_id'], data['signed_request'] || null]);
        }
    }; })(unit_id, props, on_fail);

    var test_currency = get_query_string('test_currency') || null;

    if(spin_facebook_enabled) {
        // use the real Facebook Credits API

        try {
            if(get_query_string('simulate_cb_fail')) { order_complete = function() { console.log("SIMULATING FB.PAY CALLBACK FAILURE"); }; }
            SPay.place_order_fbpayments(product_url, quantity, request_id, order_complete, test_currency);
        } catch(e) {
            log_exception(e, 'place_order');
            metric_event('4072_fbpayments_order_prompt_api_error', props);
            return false;
        }

        // set the cleanup-pending flag AFTER giving enough time for Facebook's dialog to block the UI
        // let's see if we can live without this for now...
        // window.setTimeout(function() { Store.order_cleanup_cb = function() {}; }, 2000);

    } else {
        // pretend the purchase was made successfully
        send_to_server.func(["FBPAYMENT_SIMULATE_PURCHASE", request_id]);
        order_complete({'status':'completed'});

        user_log.msg('Simulating payment of '+ price.toString() + ' ' + currency, new SPUI.Color(1,1,0,1));
    }
    metric_event('4071_fbpayments_order_prompt', props);
    return true;
};

/** @type {!Object.<string, string>} - map from spellname to Xsolla token */
Store.xsolla_token_cache = {};
Store.xsolla_token_receivers = {};
Store.xsolla_token_serial = 0;

/** @param {string} spellname
    @param {number|null=} spellarg - for spells that specify a quantity in the spellarg
    @return {string} */
Store.xsolla_token_cache_key = function(spellname, spellarg) {
    var ret = spellname;
    if(spellarg) { ret += ':' + spellarg.toString();}
    return ret;
};

/** Open the purchase GUI for a SKU - this needs an asynchronous round-trip to get the per-SKU "access token"
    @param {string} spellname
    @param {number|null} spellarg - for spells that specify a quantity in the spellarg
    @param {function()|null=} on_finish
    @param {Object|null=} options */
Store.place_xsolla_order = function(spellname, spellarg, on_finish, options) {
    var key = Store.xsolla_token_cache_key(spellname, spellarg);
    if(key in Store.xsolla_token_cache) {
        Store.do_place_xsolla_order(Store.xsolla_token_cache[key], on_finish, options);
        return;
    }

    metric_event('4079_xsolla_order_get_token', {'spellname': spellname, 'spellarg': spellarg, 'purchase_ui_event': true, 'client_time': client_time});

    var tag = 'xgt'+Store.xsolla_token_serial.toString();
    Store.xsolla_token_serial += 1;
    send_to_server.func(['XSOLLA_GET_TOKEN', tag, spellname, spellarg || null]);

    var ui_locker_arr = [null]; // need to pass the UI locker dialog to the callback AFTER query is launched, so stuff it inside an array

    Store.xsolla_token_receivers[tag] = (function (_key, _on_finish, _options, _ui_locker_arr) { return function(token) {
        close_dialog(_ui_locker_arr[0]);
        Store.xsolla_token_cache[_key] = token;
        Store.do_place_xsolla_order(token, on_finish, options);
    }; })(key, on_finish, options, ui_locker_arr);

    // block GUI
    ui_locker_arr[0] = invoke_ui_locker_until_closed();
};

// goog.object.extend operates in-place, we want a non-mutating extend
var my_extend = function(a, b) {
    var result = {};
    for (var x in a) if (a.hasOwnProperty(x)) result[x] = a[x];
    for (var x in b) if (b.hasOwnProperty(x)) result[x] = b[x];
    return result;
};

/** Open the purchase GUI, once we have a token
    @param {string} token
    @param {function()|null=} on_finish
    @param {Object|null=} options */
Store.do_place_xsolla_order = function(token, on_finish, options) {
    if(!SPay.xsolla_available()) { throw Error('Xsolla initialization failed'); }
    var on_fail = options['fail_cb'] || null;

    var state = {'fail': false, 'success': false, // track whether we have called each callback already
                 // metric event properties
                 'metric_props': {'purchase_ui_event': true, 'token': token}};

    metric_event('4057_xsolla_order_prompt_init', my_extend(state['metric_props'], {'client_time': client_time}));

    // turn off fullscreen to show overlay
    if(canvas_is_fullscreen) { toggle_true_fullscreen(); }

    XPayStationWidget['init']({'access_token': token, 'sandbox': !spin_secure_mode});

    XPayStationWidget['on']('close', (function (_state, _on_fail) { return function(event, data) {
        XPayStationWidget['off'](); // detach remaining event handlers
        if(!_state['success'] && !_state['fail']) {
            _state['fail'] = true;
            metric_event('4059_xsolla_order_prompt_fail', my_extend(_state['metric_props'], {'method': 'close', 'client_time': client_time}));
            if(_on_fail) { _on_fail(); }
        }
    }; })(state, on_fail));

    XPayStationWidget['on']('status-done', (function (_state, _on_finish) { return function(event, data) {
        metric_event('4058_xsolla_order_prompt_success', my_extend(_state['metric_props'], {'client_time': client_time}));
        _state['success'] = true;
        _on_finish();
    }; })(state, on_finish));

    XPayStationWidget['on']('status-troubled', (function (_state, _on_fail) { return function(event, data) {
        metric_event('4059_xsolla_order_prompt_fail', my_extend(_state['metric_props'], {'method': 'status-troubled: '+JSON.stringify(data), 'client_time': client_time}));
        _state['fail'] = true;
        if(_on_fail) { _on_fail(); }
    }; })(state, on_fail));

    goog.array.forEach(['open', 'load', 'status-invoice', 'status-delivering'],
                       function(cbtype) {
                           XPayStationWidget['on'](cbtype, (function (_state, _cbtype) { return function(event, data) {
                               // might be unnecessary
                               metric_event('4078_xsolla_order_prompt_update', my_extend(_state['metric_props'], {'method': _cbtype, 'client_time': client_time}));
                           }; })(state, cbtype));
                       });
    XPayStationWidget.open();
};

Store.buy_more_fbcredits = function() {

    var order_complete = function(data) {

        Store.order_cleanup_cb = false;

        var props = {'Billing Description': 'buy_more_credits'};

        // Facebook does NOT apparently provide any info on whether it succeeded or failed...

        console.log('buy_more_credits result:');
        console.log(data);
        metric_event('4211_buy_more_credits_result_unknown', props);

        if(!('order_id' in data)) {
            var msg = 'unknown error';
            if('error_code' in data && 'error_message' in data) {
                msg = 'error: '+data['error_code']+' '+data['error_message'];
            } else if('status' in data) {
                msg = 'status: '+data['status'];
            }
            props['method'] = msg;
            //console.log('MORE CREDITS PROBLEM: '+msg);
            //metric_event('4209_buy_more_credits_failure', props);
        } else {
            var msg = '';
            if('order_id' in data) {
                msg = 'order_id: '+data['order_id'];
                props['order_id'] = data['order_id'];
            }
            //console.log('MORE CREDITS SUCCESSFUL: '+data);
            //metric_event('4210_buy_more_credits_success', props);
        }

        // recheck credit balance
        send_to_server.func(["PING_CREDITS"]);
    };

    if(spin_facebook_enabled) {
        try {
            SPay.buy_more_credits(order_complete);
        } catch(e) {
            log_exception(e, 'buy_more_credits');
            metric_event('4201_buy_more_credits_api_error', {'method':'buy_more_credits'});
            return;
        }

        // set the cleanup-pending flag AFTER giving enough time for Facebook's dialog to block the UI
        window.setTimeout(function() { Store.order_cleanup_cb = function() {}; }, 2000);

    } else {
        console.log('Store.buy_more_fbcredits()');
    }

    metric_event('4200_buy_more_credits_prompt', {});
};

Store.redeem_fb_gift_card = function(success_cb, fail_cb) {

    var order_complete = (function (_success_cb, _fail_cb) { return function(data) {
        // the callback only handles metrics. The actual success/failure and fulfillment
        // of the order happens via the FBRTAPI path on the server.

        Store.order_cleanup_cb = false;
        var success = false;

        if(data && ('status' in data) && (data['status'] == 'completed') && (data['quantity']>0)) {
            metric_event('4321_redeem_fb_gift_card_success', {'payment_id': data['payment_id'],
                                                              'quantity': data['quantity']});
            send_to_server.func(["FB_GIFT_CARD_REDEEMED", data['payment_id'], data['quantity']]);
            success = true;
        } else {
            metric_event('4322_redeem_fb_gift_card_failure', {'result':data});
        }

        // recheck credit balance
        send_to_server.func(["PING_CREDITS"]);

        // call provided callback
        if(success && _success_cb) {
            _success_cb();
        } else if(_fail_cb) {
            _fail_cb();
        }
    }; })(success_cb, fail_cb);

    if(spin_facebook_enabled) {
        try {
            SPay.redeem_fb_gift_card(order_complete);
        } catch(e) {
            log_exception(e, 'redeem_fb_gift_card');
            metric_event('4323_redeem_fb_gift_card_api_error', {'method':'redeem_fb_gift_card'});
            return;
        }

        // set the cleanup-pending flag AFTER giving enough time for Facebook's dialog to block the UI
        window.setTimeout(function() { Store.order_cleanup_cb = function() {}; }, 2000);

    } else {
        console.log('Store.redeem_fb_gift_card()');
    }

    metric_event('4320_redeem_fb_gift_card_prompt', {});
};

Store.trialpay_available = function() {
    return (spin_frame_platform == 'fb') &&
        spin_trialpay_vendor_id &&
        player.facebook_third_party_id &&
        SPay.trialpay_available();
};

Store.trialpay_invoke = function() {
    metric_event('4510_trialpay_invoked', {'purchase_ui_event': true, 'client_time':client_time});
    if(spin_facebook_enabled) {
        var proxyserver = spin_server_host+(parseInt(spin_server_http_port,10)!=80 ? ':'+spin_server_http_port : '');
        SPay.trialpay_invoke(spin_app_id,
                             spin_trialpay_vendor_id,
                             // callback URL
                             'http://'+proxyserver+'/TRIALPAYAPI',
                             // currency URL
                             ogpapi_url({
                                 // note: MF requires a special case for legacy compatibility
                                 'type': (gamedata['game_id'] == 'mf' ? 'mf_alloy' : gamedata['game_id']+'_gamebucks')
                             }),
                             player.facebook_third_party_id,
                             session.user_id.toString(), // send user ID as order_info
                             Store.trialpay_callback);

        // set the cleanup-pending flag AFTER giving enough time for Facebook's dialog to block the UI
        window.setTimeout(function() { Store.order_cleanup_cb = function() {}; }, 2000);
    } else {
        console.log('Store.trialpay_invoke()');
    }
};

/** @param {string} result
    @param {Object=} data */
Store.trialpay_callback = function(result, data) {
    Store.order_cleanup_cb = false;

    if(result == 'open') {
        metric_event('4511_trialpay_opened', {'purchase_ui_event': true, 'client_time':client_time});
    } else if(result == 'close') {
        metric_event('4512_trialpay_closed', {'purchase_ui_event': true, 'client_time':client_time});
    } else if(result == 'complete') {
        metric_event('4513_trialpay_completed', {'purchase_ui_event': true, 'client_time':client_time,
                                                 'completions': data['completions'],
                                                 'gamebucks': data['vc_amount']});
        send_to_server.func(["PING_CREDITS"]); // may not be necessary, but just in case.
    }
};

// install a new dialog as a child of the current dialog (or at toplevel, if no UI is up)
/** @param {SPUI.Dialog} dialog */
function install_child_dialog(dialog) {
    // note: this should ideally be a check to make sure selection.ui inherits from SPUI.Container
    var parent = (selection.ui && selection.ui.add ? selection.ui : null);

    // never make major dialogs a child of a popup context menu, add them to the desktop instead
    if(parent && parent.user_data && parent.user_data['dialog'] &&
       (parent.user_data['dialog'] == 'context_menu' || parent.user_data['dialog'].indexOf('popout') != -1)) {
        parent = null;
    }

    if(parent) {
        /* XXXXXX descend hierarchy of child dialogs - this is actually more correct, try it sometime
        if(0) {
            // (otherwise the current code appends to the topmost selection.ui, even if it already has a child dialog!)
            while(parent.children.length >= 1 && parent.children[parent.children.length-1].user_data && parent.children[parent.children.length-1].user_data['dialog']) {
                parent = parent.children[parent.children.length-1];
            }
        }
        */

        if(parent.onleave) { parent.onleave(); }
        parent.add(dialog);
        SPUI.set_keyboard_focus(null);
    } else {
        change_selection_ui(dialog);
    }
    return dialog;
}

// Removes the parent. Works for both top-level and child dialogs.
/** @param {SPUI.Dialog|SPUI.Element} dialog */
function close_dialog(dialog) {
    if(selection.ui === dialog) {
        change_selection_ui(null);
    } else if(dialog.parent) {
        dialog.parent.remove(dialog);
    }
}

// Used as an onclick handler for "close" buttons. Closes the parent dialog containing widget "w".
function close_parent_dialog(w) {
    var dialog = w.parent;
    if(dialog) {
        close_dialog(dialog);
    }
}

function do_change_selection_ui(newui, under) {
    if(selection.ui) {
        SPUI.root.remove(selection.ui);
    }
    selection.ui = newui;
    if(selection.ui) {
        if(under) {
            SPUI.root.add_under(selection.ui);
        } else {
            SPUI.root.add(selection.ui);
        }
    }
    player.quest_tracked_dirty = true;
    selection.ui_change_time = client_time;
    SPUI.set_keyboard_focus(null);
}
function change_selection_ui(newui) {
    do_change_selection_ui(newui, false);
}
function change_selection_ui_under(newui) {
    do_change_selection_ui(newui, true);
}

function change_selection_unit(newunit) {
    selection.unit = newunit;
    selection.spellname = null;
    selection.spellkind = null;
    selection.slot = -1;
    selection.item = null;
    selection.multi = [];
    player.quest_tracked_dirty = true;
}

function change_selection(newsel) {
    change_selection_ui(null);
    change_selection_unit(newsel);
};

// add 'u' to selection, handling cases where it's already selected
function add_unit_to_selection(u) {
    if(u === selection.unit) { return; }
    for(var j = 0; j < selection.multi.length; j++) {
        if(selection.multi[j] === u) {
            return;
        }
    }
    selection.multi.push(u);
    if(!selection.unit) {
        selection.unit = u;
    }
};
// if 'u' was not selected, select it. Otherwise, deselect it.
function toggle_unit_selection(u) {
    if(u === selection.unit) {
        for(var j = 0; j < selection.multi.length; j++) {
            if(selection.multi[j] === u) {
                selection.multi.splice(j, 1);
                break;
            }
        }

        if(selection.multi.length > 0) {
            selection.unit = selection.multi[0];
        } else {
            change_selection_unit(null);
        }
        return;
    }
    for(var j = 0; j < selection.multi.length; j++) {
        if(selection.multi[j] === u) {
            selection.multi.splice(j, 1);
            return;
        }
    }
    // unit was definitely not selected
    if(!selection.unit) {
        selection.unit = u;
    } else {
        selection.multi.push(u);
    }
};

/** Inverse of the server's compress_and_wrap_string()
    @param {string} codec
    @param {string} z_result
    @return {string} */
function unwrap_and_uncompress_string(codec, z_result) {
    if(codec === 'raw') {
        return z_result;
    } else if(codec == 'lzjb') {
        return SPStringCoding.utf8_array_to_js_string(Iuppiter.decompress(goog.crypt.base64.decodeStringToByteArray(z_result)));
    } else if(codec == 'lz4') {
        var arr = goog.crypt.base64.decodeStringToByteArray(z_result);
        arr = /** @type {!Array} */ (arr); // since decodeStringToByteArray's return value is incorrectly annotated to be nullable
        return SPStringCoding.utf8_array_to_js_string(lz4.decompress(arr));
    } else if(codec == 'gzip') {
        // erase temporaries after use to help GC
        var temp1 = goog.crypt.base64.decodeStringToByteArray(z_result); z_result = '';
        var temp2 = SPGzip.gunzip(temp1); temp1 = null;
        return SPStringCoding.utf8_array_to_js_string(temp2);
    } else {
        throw Error('unknown codec '+codec);
    }
};

function on_ajax_goog(event) {
    if(!event.target.isSuccess()) {
        if(SPINPUNCHGAME.shutdown_in_progress || client_state === client_states.TIMED_OUT) { return; } // irrelevant (?)

        client_time = (new Date()).getTime()/1000;
        var code = event.target.getLastErrorCode();
        var msg = '';
        var conntime;
        if(!session.connected()) {
            conntime = session.connect_time;
            if(spin_game_direct_connect) {
                msg += 'FIRST(direct) ';
            } else {
                msg += 'FIRST(proxy) ';
            }
        } else {
            conntime = client_time - session.connect_time;
            msg += 'post-connect '+conntime.toFixed(2)+' sec, serial '+message_serial.toString();
        }
        msg += ', '+(client_time - spin_pageload_begin).toFixed(2)+' sec since pageload';
        msg += ', art progress '+GameArt.get_dl_progress_all().toFixed(3);

        try {
            // accessing some XHR object fields when request fails synchronously throws exceptions
            // just try to get as much info as we can
            msg += ', error code '+event.target.getLastErrorCode().toString();
            msg += ', status '+event.target.getStatus().toString();
            msg += ', statusText '+event.target.getStatusText();
        } catch (e) {}

        var props = add_demographics({'user_id':spin_user_id,
                                      'method':msg,
                                      'serial': last_ajax_serial,
                                      'len': last_ajax_xmit_len,
                                      'elapsed': client_time - last_ajax_xmit_time,
                                      'since_connect': conntime,
                                      'since_pageload': client_time - spin_pageload_begin,
                                      'connection': gameapi_connection_method()
                                     });

        if(!session.connected() && spin_game_direct_connect && session.client_hello_packet != null && ajax_config['enable_proxy']) {
            // fall back to proxied connection before giving up
            SPLWMetrics.send_event(spin_metrics_anon_id, '0631_direct_ajax_failure_falling_back_to_proxy', props);
            spin_game_direct_connect = false;
            spin_game_use_websocket = false; // if AJAX to nonstandard ports doesn't work, websockets probably won't either.

            // some browsers (Opera) call this synchronously from within send() in certain failure cases (overzealous CORS protection?)
            // perform the retry after an asynchronous wait in order to avoid messing up message_serial
            window.setTimeout(function() {
                message_serial = 0;
                message_queue = new AJAXMessageQueue();
                send_to_server.func(session.client_hello_packet);
                flush_message_queue(true, ajax_config['message_timeout_hello']);
            }, 10);
        } else {
            var coded_msg = null;

            if(code === goog.net.ErrorCode.HTTP_ERROR) {
                // we failed to send the request, or got a bad HTTP response code back
                if(SPINPUNCHGAME.shutdown_in_progress) {
                    // outstanding AJAX requests get aborted and return here when the browser window closes
                    // this is not to be considered a failure, so do not transmit the metric.
                } else {
                    coded_msg = '0630_client_died_from_ajax_xmit_failure';
                }
            } else if(code === goog.net.ErrorCode.TIMEOUT) {
                // request was sent but we didn't get an answer within the timeout period
                coded_msg = '0635_client_died_from_ajax_xmit_timeout';
            } else {
                console.log('unrecognized AJAX error!');
                coded_msg = '0639_client_died_from_ajax_unknown_failure';
            }
            if(coded_msg) {
                var template = gamedata['errors']['CLIENT_NETWORK_FAILURE'];
                invoke_timeout_message(coded_msg, props,
                                       {'ui_title': template['ui_title'],
                                        'ui_description': template['ui_description'].replace('%d', coded_msg.slice(0,4)),
                                        'dialog': template['dialog'],
                                        'ui_button': template['ui_button']
                                       });
            }
        }
    } else {
        return on_ajax(event.target.getResponseText(), gameapi_connection_method()+':sync');
    }
};

var ajax_recv_buffer = {};
var ajax_next_serial = 0;
var ajax_last_ack = 0; // last ack we sent back to the server

function on_ajax(response, kind) {
    var from_server = JSON.parse(response);
    if(!from_server || !('serial' in from_server) || !('msg' in from_server) || !('clock' in from_server)) {
        // connection probably got terminated
        invoke_timeout_message('0640_client_died_from_ajax_recv_failure', {}, {});
        return -1;
    }
    var serial = from_server['serial'];
    var clock = from_server['clock'];
    var messages = from_server['msg'];
    var do_flush = false;

    if('ack' in from_server) {
        retrans_buffer.trim(from_server['ack']);

        // if we haven't sent an ack to the server in a long time,
        // send something back to keep the server's retrans buffer size down
        if(message_queue.length() < 1 &&
           3*(ajax_next_serial - 1 - ajax_last_ack) >= gamedata['client']['ajax_message_buffer']) {
            send_to_server.func(["PING"]);
            // ensure that we transmit something, do not rely on window timer since it might be throttled by browser
            do_flush = true;
        }
    }

    var ret = recv_message_bundle(serial, clock, messages, kind);

    if(do_flush) {
        flush_message_queue(true);
    }

    return ret;
}

function recv_message_bundle(serial, clock, messages, kind) {
    if(clock > 0) {
        // reset server_time_offset
        server_time_offset = clock - (new Date()).getTime()/1000;
        update_client_and_server_time();
        SPUI.time = client_time;
        GameArt.sync_time(client_time);
    }

    if(serial < 0) {
        // protocol error message - something is really messed up. Process immediately because it's not part of the regular message stream
        handle_server_message_bundle(-1, {'messages':messages, 'kind':'error'});
        return -1;
    }
    if(serial in ajax_recv_buffer || serial < ajax_next_serial) {
        // discard retransmission of something we already saw
        return 0;
    }
    ajax_recv_buffer[serial] = {'messages':messages, 'kind':kind};
    process_recv_buffer();
    return 0;
}

function process_recv_buffer() {
    while(ajax_next_serial in ajax_recv_buffer) {
        var bundle = ajax_recv_buffer[ajax_next_serial];
        delete ajax_recv_buffer[ajax_next_serial];
        handle_server_message_bundle(ajax_next_serial, bundle);
        ajax_next_serial += 1;
    }

    if(goog.object.getCount(ajax_recv_buffer) >= gamedata['client']['ajax_message_buffer']) {
        return invoke_timeout_message('0625_client_recv_buffer_overflow', {'len': goog.object.getCount(ajax_recv_buffer)}, {});
    }
}

function handle_server_message_bundle(serial, bundle) {
    var messages = bundle['messages'];
    for(var msgnum = 0; msgnum < messages.length; msgnum++) {
        var msg = messages[msgnum];
        try {
            if(player.is_developer()) {
                console.log(['From Server ('+bundle['kind']+')', serial.toString()].concat(msg));
            }
            handle_server_message(msg);
        } catch(e) {
            log_exception(e, 'handle_server_message');
        }
    }
}

/** @type {!Array<string>} for debugging server->client traffic */
var debug_server_message_history = [];
/** @const */
var debug_server_message_history_limit = 7;

function handle_server_message(data) {
    var msg = data[0];

    debug_server_message_history.push(msg);
    if(debug_server_message_history.length > debug_server_message_history_limit) { // limit
        debug_server_message_history.splice(0, debug_server_message_history.length - debug_server_message_history_limit);
    }

    // presumably everything that happens in here affects the "real" world.
    var world = (session.has_world() ? session.get_real_world() : null);

    if(msg == "SERVER_HELLO") {
        var server_gamedata_version = data[1];
        if(session.user_id != data[2]) { throw Error('unexpected user_id: spin_user_id '+spin_user_id.toString()+' SERVER_HELLO '+data[2].toString()); }
        if(session.session_id != data[3]) { throw Error('unexpected session_id: spin_session_id '+spin_session_id.toString()+' SERVER_HELLO '+data[3].toString()); }

        var server_measured_time = data[4];

        console.log("Your SpinPunch user ID is "+session.user_id+". Server gamedata version is "+server_gamedata_version);
        console.log("Server time is " + server_measured_time + ", client time is "+ client_time +", offset is " + server_time_offset)

        player.facebook_name = data[5];
        player.tutorial_state = data[6];
        if(data[7] !== null) { player.preferences = data[7]; }

        var needs_daily_attack = data[8];
        if(needs_daily_attack) {
            player.daily_attack_time = client_time + gamedata['ai_attacks_client']['after_login_time'];
            console.log('queueing daily attack for '+player.daily_attack_time);
        }

        player.country = data[9];
        player.country_tier = data[10];
        player.price_region = data[11];
        player.logged_in_times = data[12];
        player.init_abtests(data[13]);
        player.developer = !!data[14];
        player.is_suspicious = data[15];
        player.isolate_pvp = data[16];
        player.acquisition_campaign = data[17];
        player.home_base_id = data[18];
        var money_spent = data[19];
        player.history['money_spent'] = money_spent; // set this so early PLAYER_HISTORY predicates will work
        player.creation_time = data[20];
        player.chat_seen = data[21];
        player.is_chat_mod = data[22];
        var daily_banner = data[23];
        var fb_likes_preload = data[24];
        player.vpn_status = (data.length >= 26 ? data[25] : null);

        ChatFilter.init(gamedata['client']['chat_filter']);

        session.region = new Region.Region(null); // note: start with "blank" region, updated later

        session.connect_time = client_time;
        session.client_hello_packet = null;

        metric_event('0106_client_connected_to_server', add_demographics({'user_id': session.user_id,
                                                                          'since_pageload': (new Date()).getTime()/1000 - spin_pageload_begin,
                                                                          'method': (spin_game_direct_connect ? 'direct':'proxy')}));

        // optionally switch on websockets (which may already be on from init() if gamedata.client.enable_websockets is true)
        // but note: don't do this if spin_game_direct_connect has been turned off by error 0631 happening from an earlier connection attempt
        if(!spin_game_use_websocket && spin_game_direct_connect && (parseInt(spin_game_server_ws_port,10) > 0 || parseInt(spin_game_server_wss_port,10) > 0)) {
            if(player.get_any_abtest_value('enable_websockets', false) && SPWebsocket.is_supported()) {
                spin_game_use_websocket = true;
            }
        }

        var force_lazy_sound = player.get_any_abtest_value('force_lazy_sound', gamedata['client']['force_lazy_sound'] || false);

        // order of precedence for graphics options is player preference << browser forcing (A/B testable) << URL query
        var use_low_gfx = false;
        if(read_predicate(gamedata['client']['force_low_gfx_if']).is_satisfied(player, null)) {
            use_low_gfx = true;
        } else if('low_gfx' in player.preferences) {
            use_low_gfx = !!player.preferences['low_gfx'];
        }

        if(document.URL.indexOf('low_gfx=1') != -1) { use_low_gfx = true; }
        if(document.URL.indexOf('low_gfx=0') != -1) { use_low_gfx = false; }

        if(!use_low_gfx && player.get_any_abtest_value('enable_canvas_oversample', gamedata['client']['enable_canvas_oversample'])) {
            canvas_oversample = window['devicePixelRatio'] || 1;
        } else {
            canvas_oversample = 1;
        }

        var enable_audio = (!blacklist_audio) && (get_query_string('enable_audio') !== '0') && buzz.isSupported() && (buzz.isMP3Supported() || buzz.isOGGSupported());
        var audio_driver = null;
        if(enable_audio) {
            var q = get_query_string('audio_driver');
            if(q) {
                audio_driver = q;
            } else {
                audio_driver = eval_cond(player.get_any_abtest_value('default_audio_driver', gamedata['client']['default_audio_driver'] || null), player, null);
            }
        }

        console.log('GameArt settings: low_gfx '+use_low_gfx+' audio_driver '+(audio_driver ? audio_driver.toString() : null));

        GameArt.init(client_time, canvas, ctx, gamedata['art'], gameart_onload, audio_driver, use_low_gfx, force_lazy_sound, player.get_any_abtest_value('enable_pixel_manipulation_in_low_gfx', gamedata['client']['enable_pixel_manipulation_in_low_gfx']));

        if(!ctx) { throw Error('ctx not initialized'); }
        SPFX.init(ctx, use_low_gfx, false);
        SPFX.enable_camera_shake = !('enable_camera_shake' in player.preferences && !player.preferences['enable_camera_shake']);

        // set html_text_input
        if(read_predicate(gamedata['client']['enable_html_text_input']).is_satisfied(player)) {
            SPUI.html_text_input = true;
        }

        if('sound_volume' in player.preferences) {
            GameArt.sound_volume = player.preferences['sound_volume'];
        } else {
            GameArt.sound_volume = 1;
        }
        if('music_volume' in player.preferences) {
            GameArt.music_volume = player.preferences['music_volume'];
        } else {
            GameArt.music_volume = 1;
        }

        PlayerCache.init(gamedata['client']['player_cache']);

        if(spin_frame_platform == 'fb' && spin_facebook_enabled) {
            SPFB.init_watchdog();
        }

        SPFB.preload_likes(fb_likes_preload);

        var need_reflow = false;

        // fill header
        var header = document.getElementById('spin_header');
        if(header) {
            var inner = player.get_any_abtest_value('spin_header_content', daily_banner);
            if(inner) {
                header.innerHTML = url_put_info(inner, session.user_id, money_spent);
                need_reflow = true;
            }
        }

        // fill the footer linkbar
        var bar = /** @type {HTMLElement} */ (document.getElementById('spin_footer_linkbar_content'));
        if(bar) {
            var inner = eval_cond_or_literal(player.get_any_abtest_value('footer_linkbar_content', gamedata['strings']['footer_linkbar_content'] || null), player, null);
            if(inner) {
                bar.innerHTML = url_put_info(inner, session.user_id, money_spent);
                // update "Like" button, if present
                if(inner.indexOf('class="fb-') >= 0) {
                    SPFB.XFBML_parse(bar);
                }
            }
        }

        linkbar_put_id(session.user_id);

        // set fixed canvas size on load based on browser dimensions
        update_armorgames_iframe_size([screen.availWidth, screen.availHeight]);

        // reflow in case the header height changed
        if(need_reflow || canvas_oversample !== 1) { on_resize_browser(null); }

        // fill footer ad area
        if(player.is_syfy_user()) {
            var container = document.getElementById('spin_footer_ad');
            if(container) {
                container.style.background = '#000000';
                var rnd = window['rnd'] || Math.floor(Math.random()*10e6);
                var pid151920 = window['pid151920'] || rnd;
                var plc151920 = window['plc151920'] || 0;
                var abkw = window['abkw'] || '';
                var absrc = 'http://ab161933.adbutler-exciton.com/adserve/;ID=161933;size=760x250;setID=151920;type=iframe;kw='+abkw+';pid='+pid151920+';place='+(plc151920++)+';rnd='+rnd+'';
                container.innerHTML = '<ifr'+'ame src="'+absrc+'?syfy_game_MF_bottombanner" width="760" height="250" marginwidth="0" marginheight="0" hspace="0" vspace="0" frameborder="0" scrolling="no"></ifr'+'ame>';
            }
        }

        // apply Perfect Audience cookie
        if(player.get_any_abtest_value('enable_perfect_audience', gamedata['client']['enable_perfect_audience'])) {
            (function() {
                var pa = document.createElement('script'); pa.type = 'text/javascript'; pa.async = true;
                pa.src = ('https:' == document.location.protocol ? 'https:' : 'http:') + "//tag.perfectaudience.com/serve/503fb4dc726ac60002000001.js";
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(pa, s);
            })();
        }

    } else if(msg == "SQUADS_UPDATE") {
        player.squads = data[1];
        for(var key in SquadControlDialog.update_receivers) {
            SquadControlDialog.update_receivers[key]();
        }
        player.quest_tracked_dirty = true;
    } else if(msg == "PLAYER_ARMY_UPDATE" || msg == "PLAYER_ARMY_UPDATE_FULL") {
        if(msg == "PLAYER_ARMY_UPDATE_FULL") {
            player.my_army = {};
        }
        goog.array.forEach(data[1], function(state) {
            player.my_army[state['obj_id']] = state;
        });
        player.quest_tracked_dirty = true;
        if(world) { world.lazy_update_citizens(); }
    } else if(msg == "PLAYER_ARMY_UPDATE_DESTROYED") {
        var obj_id = data[1];
        if(obj_id in player.my_army) { delete player.my_army[obj_id]; }
        world.lazy_update_citizens();
    } else if(msg == "REGION_CHANGE") {
        change_region_pending = null;
        var new_region_id = data[1];
        var during_login = data[3];
        session.region = new Region.Region(gamedata['regions'][new_region_id] || null);
        player.home_base_loc = data[2];
        if(session.home_base && session.viewing_base) { session.viewing_base.base_map_loc = player.home_base_loc; }
        session.region.ping_contest_rank();
        if(!during_login) {
            // kill any UI
            change_selection(null);
            notification_queue.push_with_priority(function() {
                if(!session.region.data) { return; }
                var msg = gamedata['strings']['change_region_finish'];
                invoke_child_message_dialog(msg['ui_title'].replace('%s', session.region.data['ui_name']),
                                            msg['ui_description'].replace('%s', session.region.data['ui_name']).replace('%loc', player.home_base_loc[0].toString()+','+player.home_base_loc[1].toString())+eval_cond_or_literal(session.region.data['ui_description_long'], player, null),
                                            {'dialog': 'message_dialog_big', 'use_bbcode': true});
                GameArt.play_canned_sound('success_playful_22');
            }, -2);
        }

        // XXX does not set gravity parameters as in SESSION_CHANGE
        session.viewing_base.set_climate(data[4]);

        if(global_chat_frame) { change_chat_tab(global_chat_frame, null); }

    } else if(msg == "MAP_BOOKMARKS_UPDATE") {
        player.map_bookmarks = data[1];
    } else if(msg == "FACEBOOK_NAME_UPDATE") {
        player.facebook_name = data[1];
    } else if(msg == "FACEBOOK_THIRD_PARTY_ID_UPDATE") {
        player.facebook_third_party_id = data[1];
    } else if(msg == "PLAYER_UI_NAME_UPDATE") {
        player.ui_name = data[1];
        var dlg = desktop_dialogs['player_portrait_dialog'];
        if(dlg && dlg.widgets['player_portrait']) {
            dlg.widgets['player_portrait'].invalidate();
        } // reset avatar image
    } else if(msg == "PLAYER_ALIAS_UPDATE") {
        player.alias = data[1];
    } else if(msg == "PLAYER_TITLES_UPDATE") {
        player.title = data[1];
        //player.unlocked_titles = data[2];
    } else if(msg == "PLAYER_PORTRAIT_UPDATE") {
        // invalidate displayed portrait URL of ourself
        SPUI.FriendPortrait.invalidate_user_id(session.user_id);
    } else if(msg == "PLAYER_CACHE_UPDATE") {
        PlayerCache.update_batch(data[1]);
    } else if(msg == "PLAYER_TRUST_LEVEL_UPDATE") {
        player.trust_level = data[1];
    } else if(msg == "PLAYER_PRIVACY_CONSENT_UPDATE") {
        player.privacy_consent = data[1];
    } else if(msg == "FACEBOOK_CURRENCY_UPDATE") {
        player.facebook_currency = data[1];
        if(player.facebook_currency && get_query_string('test_currency')) {
            player.facebook_currency['user_currency'] = get_query_string('test_currency');
        }
    } else if(msg == "ABTEST_UPDATE") {
        player.init_abtests(data[1]);
    } else if(msg == "CHAT_GAG_RESULT" || msg == "CHAT_UNGAG_RESULT") {
        var target_id = data[1], success = data[2];
        if(success) {
            PlayerCache.update(target_id, {'chat_gagged': (msg == "CHAT_GAG_RESULT" ? true : false)}, false);
            var s = gamedata['strings'][(msg == "CHAT_GAG_RESULT" ? 'chat_gag_success' : 'chat_ungag_success')];
            var info = PlayerCache.query_sync(target_id);
            var name = PlayerCache.get_ui_name(info);
            invoke_child_message_dialog(s['ui_title'],
                                        s['ui_description'].replace('%d', target_id.toString()).replace('%s',name));
        }
    } else if(msg == "ALLIANCE_JOIN_REQUESTS") {
        var idlist = data[1], pcache_data = data[2];

        // stick pcache_data into PlayerCache
        PlayerCache.update_batch(pcache_data);

        var disp_func = function (_id) { return function() {
            invoke_alliance_join_request(_id);
        }; };

        for(var i = 0; i < idlist.length; i++) {
            notification_queue.push_with_priority(disp_func(idlist[i]), -10);
        }

    } else if(msg == "ALLIANCE_CREATE_RESULT" || msg == "ALLIANCE_MODIFY_RESULT") {
        var props = data[1], new_id = data[2]; // success if new_id > 0
        AllianceCache.receive_create_or_modify_result(props['tag'], new_id);
    } else if(msg == "ALLIANCE_INVITE_RESULT" || msg == "ALLIANCE_KICK_RESULT" || msg == "ALLIANCE_PROMOTE_RESULT") {
        var alliance_id = data[1], affected_user = data[2], success = data[3], tag = data[4];
        if(success) {
            GameArt.play_canned_sound('success_playful_22');;
            var ui_msg = gamedata['strings']['alliance_'+{'ALLIANCE_INVITE_RESULT':'invite',
                                                          'ALLIANCE_KICK_RESULT':'kick',
                                                          'ALLIANCE_PROMOTE_RESULT':'promote'}[msg]+'_finish'];
            var player_props = PlayerCache.query_sync(affected_user);
            var name = PlayerCache.get_ui_name(player_props);
            invoke_child_message_dialog(ui_msg['ui_title'],
                                        ui_msg['ui_description'].replace('%s', name),
                                        {'dialog': 'message_dialog_big'});
        }
        AllianceCache.receive_invite_or_kick_result(tag, success);
    } else if(msg == "ALLIANCE_ACK_JOIN_REQUEST_RESULT") {
        var alliance_id = data[1], affected_user = data[2], success = data[3], tag = data[4];
        AllianceCache.receive_ack_join_request_result(tag, success);
    } else if(msg == "ALLIANCE_SEND_JOIN_REQUEST_RESULT") {
        var alliance_id = data[1], success = data[2], tag = data[3];
        AllianceCache.receive_send_join_request_result(tag, success);
    } else if(msg == "ALLIANCE_UPDATE") {
        var old_id = session.alliance_id;
        session.alliance_id = data[1];
        var init = data[2]; // true if this is happening on login or otherwise silently updating state (suppresses GUI notifications)
        var cache_entry = data[3];
        session.alliance_membership = data[4];
        var role_changed = data[5];

        if(session.alliance_id > 0) {
            AllianceCache.update(session.alliance_id, cache_entry);
        }

        // sync the player cache
        PlayerCache.update_alliance_membership(session.user_id, session.alliance_id);

        if(global_chat_frame) {
            // make sure Alliance tab has the right state
            change_chat_tab(global_chat_frame, null);

            if(init && global_chat_frame.is_visible()) {
                var do_maximize = read_predicate(gamedata['client']['maximize_chat_on_login_if']).is_satisfied(player,null);
                /* turned off for now
                if('chat_frame_minimized' in player.preferences) {
                    do_maximize = !player.preferences['chat_frame_minimized'];
                }
                */
                if(do_maximize) {
                    chat_frame_size(global_chat_frame, true, true);
                }
            }
        }

        if(role_changed) {
            var display_func = function() {
                if(!session.is_in_alliance()) { return; }
                var msg = gamedata['strings']['alliance_role_changed'];
                var info = AllianceCache.query_info_sync(session.alliance_id);
                invoke_child_message_dialog(msg['ui_title'],
                                            msg['ui_description'].replace('%alliance', alliance_display_name(info)).replace('%role', info['roles'][(session.alliance_membership['role']||0).toString()]['ui_name']),
                                            {'dialog': 'message_dialog_big'});
                GameArt.play_canned_sound('success_playful_22');;
            };
            notification_queue.push_with_priority(display_func, -3);

        } else if(!init) {
            if(session.alliance_id > 0) {
                AllianceCache.query_info(session.alliance_id, (function (_old_id) { return function(r) {
                    change_selection(null);
                    var display_func = (function (_r, action) { return function() {
                        var msg = gamedata['strings'][action+'_alliance_finish'];
                        invoke_child_message_dialog(msg['ui_title'].replace('%s', _r['ui_name']),
                                                    msg['ui_description'].replace('%s', _r['ui_name']),
                                                    {'dialog': 'message_dialog_big'});
                        GameArt.play_canned_sound('success_playful_22');;
                    }; })(r, (session.alliance_id == _old_id ? 'modify' : 'join'));
                    notification_queue.push_with_priority(display_func, -2);
                }; })(old_id));
            } else {
                var display_func = function() {
                    var msg = gamedata['strings']['leave_alliance_finish'];
                    invoke_child_message_dialog(msg['ui_title'],
                                                msg['ui_description'],
                                                {'dialog': 'message_dialog_big'});
                    GameArt.play_canned_sound('error_sound');
                };
                change_selection(null);
                notification_queue.push_with_priority(display_func, -2);
            }
            if(global_chat_frame) {
                // force-maximize alliance chat
                if(global_chat_frame.is_visible() && session.is_in_alliance()) {
                    chat_frame_size(global_chat_frame, true, true);
                }
            }
        }
        session.clear_building_idle_state_caches();

    } else if(msg == "BATTLE_ENDED") {
        var battle_outcome = data[1];
        var battle_summary = data[2];
        var base_data = data[3];
        var battle_base = new Base.Base(base_data['base_id'], base_data);
        var battle_ladder_state = data[4];
        var battle_loot = battle_summary['loot'] || {};
        var battle_replay_signature = data[5] || null;

        var battle_type = (battle_base.base_id === player.home_base_id ? 'home' :
                           (battle_ladder_state ? 'ladder' :
                            (battle_base.base_type === 'quarry' ? 'quarry' :
                             (battle_base.base_type === 'squad' ? 'squad' :
                              'away'))))
        var opprole = (battle_summary['attacker_id'] === session.user_id ? 'defender' : 'attacker');

        var battle_opponent_name = battle_summary[opprole+'_name'];
        var battle_opponent_user_id = battle_summary[opprole+'_id'];
        var battle_opponent_level = battle_summary[opprole+'_level'];

        for(var res in battle_loot) { if(battle_loot[res]) { player.flash_res_time[res] = client_time; } }

        var cb = null; // callback for post-battle GUI

        if(battle_type === 'home') {
            if(player.tutorial_state != "COMPLETE") {
                cb = goog.partial(invoke_ai_attack_finish_dialog, battle_loot);
            } else {
                cb = (function (_type, _base, _uid, _fbid, _level, _fr, _name, out, loot, dmg, ladder_state, replay_signature) { return function() {
                    invoke_defense_end_dialog(_type, _base, _uid, _fbid, _level, _fr, _name, out, loot, dmg, ladder_state, replay_signature);
                }; })(battle_type, battle_base,
                      null, // battle_opponent_user_id,
                      null, // battle_opponent_fbid,
                      -1, // battle_opponent_level,
                      null, // battle_opponent_friend,
                      battle_opponent_name,
                      battle_outcome, battle_loot, battle_summary, battle_ladder_state, battle_replay_signature);
            }
        } else if(battle_outcome != 'none') {
            cb = (function (_type, _base, _uid, _fbid, _level, _fr, _name, out, loot, dmg, ladder_state, replay_signature) { return function() {
                invoke_battle_end_dialog(_type, _base, _uid, _fbid, _level, _fr, _name, out, loot, dmg, ladder_state, replay_signature);
            }; })(battle_type, battle_base,
                  battle_opponent_user_id,
                  null, // battle_opponent_fbid,
                  battle_opponent_level,
                  null, // battle_opponent_friend,
                  battle_opponent_name,
                  battle_outcome, battle_loot, battle_summary, battle_ladder_state, battle_replay_signature);
        }

        if(cb) {
            notification_queue.push_with_priority(cb, player.tutorial_state != "COMPLETE" ? NotificationQueue.TUTORIAL_MIN_PRIO : 0);
        }
    } else if(msg == "SESSION_CHANGE_SKIPPED") {
        visit_base_pending = false;
        clear_loading_base_dialog();
    } else if(msg == "SESSION_CHANGE") {

        APMCounter.reset();

        // blow away the old session
        change_selection(null);

        offscreen_unit_arrow = null;
        visit_base_pending = false;

        // cancel "loading base" message if it hasn't fired yet
        cancel_loading_base_timer();

        session.change_time = client_time;

        session.viewing_user_id = data[1];
        var unused_viewing_fbid = data[2];
        session.viewing_ai = is_ai_user_id_range(session.viewing_user_id);
        session.viewing_friend = null;
        session.ui_name = data[3];
        session.home_base = data[4];
        session.has_attacked = false;
        session.has_deployed = false;
        session.deploy_time = -1;
        session.enable_combat_resource_bars = true;
        // session.enable_progress_timers is carried over between view changes
        session.enable_dialog_completion_buttons = true;
        session.surrender_pending = false;
        session.retreat_pending = -1;
        session.no_more_units = false;
        session.set_attack_finish_time(-1);
        session.incoming_attack_time = -1;
        session.incoming_attack_wave_time = -1;
        session.incoming_attack_units = [];
        session.incoming_attack_units_total = 0;
        session.incoming_attack_units_destroyed = 0;
        session.battle_outcome_sync_marker = Synchronizer.INIT;
        session.battle_outcome_dirty = false;

        // don't reset this, it needs to carry over between sessions: session.incoming_attacker_name = '';
        session.loot = {};
        session.last_loot = {};
        session.last_looted_uncapped = {};
        session.res_looter = null;
        session.pre_deploy_units = {};
        session.post_deploy_units = {};
        session.pvp_balance = data[11];
        session.viewing_lock_state = data[12];
        session.viewing_isolate_pvp = data[13];
        session.repeat_attack_cooldown_expire = data[14];

        session.set_viewing_base(new Base.Base(data[16], // viewing_base_id
                                               {'deployment_buffer': data[15],
                                                'base_landlord_id': data[17],
                                                'base_climate': data[18],
                                                'base_map_loc': data[19],
                                                'base_expire_time': data[20],
                                                'base_ui_name': data[21],
                                                'base_type': data[22],
                                                'base_ncells': data[23],
                                                'base_last_attack_time': data[27] || -1,
                                                'base_richness': data[40] || -1,
                                                'deployment_allowed': data[41]
                                               }),
                                 session.home_base && player.get_any_abtest_value('enable_citizens', gamedata['client']['enable_citizens']) // enable_citizens
                                );

        session.viewing_player_home_base_id = data[24];
        session.viewing_player_home_region = data[25];
        session.is_alt_account = data[26];
        session.deployable_squads = data[28];
        session.deployed_unit_space = 0;
        goog.object.clear(session.weak_unit_warned);
        if(gamedata['territory']['dirty_region_map_after_session_change']) { session.region.dirty = true; }
        var viewing_alliance_id = data[29], viewing_alliance_info = data[30];
        session.ladder_state = data[31];
        var viewing_trophy_data = data[32];
        session.home_warehouse_busy = data[33];
        session.defending_squads = data[34];
        enemy.is_pvp_player_cache = data[35];
        var pcache_data = data[36];
        PlayerCache.update_batch(pcache_data);
        session.home_equip_items = data[37] || [];

        // when spying on friendly squads in NoSQL land, assume lock is taken
        if(!session.home_base && session.region.data && session.region.data['storage'] == 'nosql' &&
           (session.viewing_base.base_landlord_id == session.user_id) && (goog.array.contains(['squad','quarry'], session.viewing_base.base_type))) {
            session.has_attacked = true;
            session.set_attack_finish_time(server_time + gamedata['reinforce_time']);
        }

        // send lock state update into the player cache
        if(!session.home_base && !session.viewing_ai && (session.viewing_base.base_id == session.viewing_player_home_base_id)) {
            PlayerCache.update_lock_state(session.viewing_user_id, session.viewing_lock_state);
        }

        // send alliance update into the caches
        if(viewing_alliance_id > 0) {
            PlayerCache.update_alliance_membership(session.viewing_user_id, viewing_alliance_id);
            if(viewing_alliance_info) {
                AllianceCache.update(viewing_alliance_id, viewing_alliance_info);
            }
        }

        // send trophy data to the cache
        if(viewing_trophy_data) {
            PlayerCache.update(session.viewing_user_id, viewing_trophy_data, false);
        }

        // see if the fbid is in our friend list
        for(var i = 0; i < player.friends.length; i++) {
            if(player.friends[i].user_id === session.viewing_user_id) {
                session.viewing_friend = player.friends[i];
                break;
            }
        }

        console.log("Session ("+session.ui_name+") ID is " + session.session_id);

        // set up game map
        var ncells = session.viewing_base.ncells();
        mouse_state.hovering_over = null;

        // read object state from server
        var object_state = data[5];
        for(var n = 0; n < object_state.length; n++) {
            var obj = create_object(object_state[n], false);
            session.get_real_world().objects.add_object(obj);
            if(obj.team === 'player' && obj.is_mobile()) {
                session.deployed_unit_space += obj.get_leveled_quantity(obj.spec['consumes_space'] || 0);
            }
        }

        if(!goog.array.contains(['repair_message', 'wait_for_battle_finish','build_cannon_message','open_buildings_dialog'], player.tutorial_state)) {
            // recenter view, unless part of the "seamless" session change after home-base attack
            view_pos = [0,0];
            force_scroll_state.key = null;
            if(!session.home_base && session.viewing_ai &&
               !read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null) &&
               // during tutorial, when spying on AI enemies, recenter southwest to make deployment area more visible
               player.tutorial_state === 'click_attack') {
                if('force_scroll_after_session_change' in gamedata['tutorial'][player.tutorial_state]) {
                    //force_scroll(null, gamedata['tutorial'][player.tutorial_state]['force_scroll_after_session_change'], player.tutorial_state);
                    view_pos = ortho_to_playfield_vector(vec_sub(gamedata['tutorial'][player.tutorial_state]['force_scroll_after_session_change'], vec_scale(0.5,ncells)));
                } else {
                    view_pos = [-335,233];
                }
            } else {
                // find the townhall and center the player's view on it
                var townhall = find_object_by_type(gamedata['townhall']);
                if (townhall) {
                    view_pos = ortho_to_playfield_vector(vec_sub([townhall.x, townhall.y], vec_scale(0.5,ncells)));
                } else {
                    // if the townhall isn't found, the default centered view works fine
                }
            }
        }

        update_resources(data[6], true);
        update_enemy_resources(data[7]);
        enemy.instance_expiration_time = data[8];
        enemy.stattab = {'player':{},'units':{},'buildings':{},'INIT':'enemy'};
        enemy.player_auras = [];

        init_desktop_dialogs();
        set_view_zoom(get_preference_setting(player.preferences, 'playfield_zoom'));
        set_view_limits();

        // recall persisted playfield speed setting for battles only
        update_player_combat_time_scale((session.home_base || !session.viewing_base.deployment_allowed) ? 0 : get_preference_setting(player.preferences, 'playfield_speed'));

        if(client_state != client_states.RUNNING) {
            // very first session initiated
            client_state = client_states.RUNNING;

            //console.log('RUNNING');
            on_resize_game();

            if(player.tutorial_state === "COMPLETE" && player.logged_in_times === 3 && player.country === "ph") {
                // maximize chat frame
                if(global_chat_frame && global_chat_frame.is_visible()) {
                    chat_frame_size(global_chat_frame, true, true);
                }
            }

            if(get_query_string('fb_ref') && get_query_string('fb_ref').indexOf('fishing_') == 0) {
                notification_queue.push_with_priority(function() { invoke_fishing_dialog(); }, -4);
            }
        }

        if(session.home_base && session.last_map_dialog_state) {
            var state = session.last_map_dialog_state;
            session.last_map_dialog_state = null;
            // ideally this should just call directly, as pop-ups should appear as children instead of clearing UI
            // but we need to check whether invoke_defense_end, invoke_ai_attack_finish, and invoke_battle_end_dialog are safe without clears
            notification_queue.push_with_priority((function(_state) { return function() {
                var dialog = invoke_region_map();
                if(dialog) { dialog.widgets['map'].set_state(_state); }
            }; })(state), -3);
        }

        if(player.tutorial_state != "COMPLETE") {
            tutorial_step(false);
        }

        change_backdrop_music(/** @type {!GameArt.Sprite} */ (GameArt.assets['background_music'].states[(session.home_base ? 'normal' : 'recon')]).audio);

        if(player.can_level_up()) {
            notification_queue.push_with_priority(invoke_level_up_dialog, -1);
        }

        // show repair dialog if something was damaged and we didn't get a "you were attacked"
        if(player.tutorial_state === "COMPLETE" && session.home_base) {
            notification_queue.push_with_priority(invoke_repair_dialog_conditional, -2);
        } else if(session.is_quarry() && session.viewing_user_id == session.user_id) {
            notification_queue.push_with_priority(invoke_repair_dialog_conditional, -2);
        }

        var tip_shown = false;

        if(!tip_shown && session.viewing_base.base_climate && session.viewing_base.base_climate != 'normal') {
            var tip_name = session.viewing_base.base_climate_data['show_tip'];
            if(tip_name && (tip_name in gamedata['strings'])) {
                tip_shown = invoke_ingame_tip(tip_name, {frequency: GameTipFrequency.ALWAYS_UNLESS_IGNORED});
            }
        }

        if(!tip_shown &&
           session.viewing_base.base_landlord_id != session.user_id &&
           session.viewing_ai &&
           player.get_any_abtest_value('enable_enemy_unit_tips', gamedata['client']['enable_enemy_unit_tips'])) {
            var tips = {};
            session.for_each_real_object(function(obj) {
                if(obj.team !== 'player') {
                    var tip = 'enemy_unit_'+obj.spec['name'];
                    if(tip in gamedata['strings']) {
                        tips[tip] = 1;
                    }
                }
            });
            for(var name in tips) {
                // as soon as any tip is shown, stop.
                if(invoke_ingame_tip(name, {frequency: GameTipFrequency.ONCE_ONLY})) {
                    tip_shown = true;
                    break;
                }
            }
        }

        // if we were recording a replay, upload it
        if(session.is_recording()) {
            session.finish_and_upload_recording();
        }
    } else if(msg == "END_SERVER_HELLO") {
        session.server_hello_ended = true;

        player.quest_tracked = null; player.quest_tracked_dirty = true;
        player.update_quest_cache(true);

        if(player.tutorial_state == "COMPLETE" && !player.preferences['skip_tutorial']) {
            var pred = player.get_any_abtest_value('popup_notification_on_login_if', gamedata['client']['popup_notification_on_login_if']);
            if(pred && read_predicate(pred).is_satisfied(player, null)) {
                notification_queue.push_with_priority(function() { invoke_missions_dialog(true); }, -5);
            }
        }

        longpoll_send();

        // URL parameter processing

        // benchmark mode
        if(!spin_secure_mode) {
            var benchmark = get_query_string('benchmark');
            if(benchmark) {
                var context = JSON.parse(decodeURIComponent(benchmark));
                read_consequent({'consequent':'LIBRARY', 'name':'benchmark'}).execute(context);
            }
        }

        // allow developers to link directly to someone's base
        var immediate_visit = get_query_string('visit_base');
        if(player.is_developer() && immediate_visit) {
            visit_base(parseInt(immediate_visit,10));
        }

        // deep link to a replay
        var immediate_replay = get_query_string('replay');
        var immediate_battle_log =  get_query_string('battle_log');
        if(immediate_replay || immediate_battle_log) {
            // relies on the server's naming convention: "1457163456-828095-vs-3606753-at-s3606753_42"
            var fields = (immediate_replay || immediate_battle_log).split('-');
            var battle_time = parseInt(fields[0], 10);
            var attacker_id = parseInt(fields[1], 10);
            var defender_id = parseInt(fields[3], 10);
            var base_id = (fields.length >= 6 ? fields[5] : null);
            var signature = get_query_string('replay_signature');
            if(!signature || signature.length < 1) { signature = null; }
            if(immediate_replay || player.tutorial_state != "COMPLETE") {
                download_and_play_replay(battle_time, attacker_id, defender_id, base_id, signature, function() {
                    // failure path
                    if(player.tutorial_state != "COMPLETE") {
                        player.tutorial_hold = false;
                        tutorial_step(true);
                    }
                });
                // special case for replay on first visit

                if(player.tutorial_state != "COMPLETE") {
                    player.tutorial_hold = true;
                    tutorial_step(true);
                }
            } else if(immediate_battle_log) {
                query_battle_history(attacker_id, defender_id, -1, -1, 'any', [battle_time, battle_time+1],
                                     function(sumlist, siglist, is_final, is_error) {
                                         if(!is_error && sumlist && sumlist.length >= 1) {
                                             invoke_battle_log_dialog(sumlist[0], siglist[0], -1);
                                         }
                                     });
            }
        }

        // deep link to player info statistics
        if(player.tutorial_state == "COMPLETE") {
            var player_info_statistics = get_query_string('player_info_statistics');
            if(player_info_statistics) {
                var request = JSON.parse(decodeURIComponent(player_info_statistics));
                var dialog = PlayerInfoDialog.invoke(request['user_id'],
                                                     (function(_request) { return function(_dialog) {
                                                         PlayerInfoDialog.invoke_statistics_tab(_dialog, _request['preselect'] || null);
                                                     }; })(request));
            }
        }

        SPLWMetrics.send_event(spin_metrics_anon_id, '0120_client_ingame', add_demographics({'user_id': session.user_id,
                                                                                             'splash_image':spin_loading_screen_name,
                                                                                             'since_pageload': (new Date()).getTime()/1000 - spin_pageload_begin}));
        player.record_feature_use('client_ingame');

    } else if(msg == "OBJECT_REMOVED" || msg == "OBJECT_REMOVED2") {
        var id = data[1];
        if(!world.objects.has_object(id)) {
            console.log('race condition in OBJECT_REMOVED, ignoring');
            return;
        }
        var obj = world.objects.get_object(id);
        world.objects.rem_object(obj);
        if(msg == "OBJECT_REMOVED") {
            update_resources(data[2], false);
        }
    } else if(msg == "OBJECT_CREATED" || msg == "OBJECT_CREATED2") {
        var state = data[1];
        var obj = create_object(state, true);
        world.objects.add_object(obj);

        if(obj.is_mobile()) {
            // check for arming delay when in hostile territory
            if((obj.team == 'player' && session.viewing_base.base_landlord_id !== session.user_id) ||
               (obj.team == 'enemy' && session.viewing_base.base_landlord_id === session.user_id)) {
                // find the MAX arming delay among all relevant spells
                var arming_delay = -1;
                var spell_list = [];
                // check the auto spell
                var auto_spell = obj.get_auto_spell();
                if(auto_spell) {
                    spell_list.push(auto_spell);
                }
                // check special ability spells
                var special_ability = obj.get_special_ability_spell();
                if(special_ability) {
                    spell_list.push(special_ability[1]);
                }
                goog.array.forEach(spell_list, function(spell) {
                    if(spell['deployment_arming_delay']) {
                        arming_delay = Math.max(arming_delay, spell['deployment_arming_delay']);
                    }
                });
                if(arming_delay > 0) {
                    obj.create_aura(world, obj.id, obj.team, 'arming', 1, relative_time_to_tick(arming_delay), -1, null);
                }
            }

            invalidate_defender_threatlists();
            if(unit_deployment_latency_high()) {
                // spread sound effect time out by the min flush interval, to approximate units arriving smoothly over that time
                add_unit_deployment_vfx(world.fxworld, 'post_deploy', obj.pos, obj.spec, obj.level,
                                        2 * gamedata['client']['ajax_min_flush_interval']);
            }
        }

        if(msg == "OBJECT_CREATED") {
            // OBJECT_CREATED2 does not include player state
            update_resources(data[2], false);
        }
        player.invalidate_quest_cache();
        player.quest_tracked_dirty = true;
    } else if(msg == "OBJECT_STATE_UPDATE" || msg == "OBJECT_STATE_UPDATE2") {
        var state = data[1];
        var id = state[0];
        if(!world.objects.has_object(id)) {
            console.log('race condition in OBJECT_STATE_UPDATE, ignoring');
            return;
        }
        var obj = world.objects.get_object(id);
        obj.receive_state(state, false, false);

        if(msg == "OBJECT_STATE_UPDATE") {
                // OBJECT_STATE_UPDATE2 does not include player state
                update_resources(data[2], false);
        }

        if(obj.ping_sent) {
            obj.ping_sent = false;
        }
        player.invalidate_quest_cache();
        player.quest_tracked_dirty = true;
    } else if(msg == "OBJECT_AURAS_UPDATE") {
        var state = data[1];
        var id = state[0];
        if(!world.objects.has_object(id)) {
            console.log('race condition in OBJECT_AURAS_UPDATE, ignoring');
            return;
        }
        world.objects.get_object(id).receive_auras_update(world, state[1]);
    } else if(msg == "PLAYER_STATE_UPDATE") {
        update_resources(data[1], false);
        if(player.can_level_up()) {
            notification_queue.push_with_priority(invoke_level_up_dialog, -1);
        }
    } else if(msg == "ENEMY_STATE_UPDATE") {
        update_enemy_resources(data[1]);
    } else if(msg == "ENEMY_TECH_UPDATE") {
        enemy.tech = data[1];
    } else if(msg == "TECH_UPDATE") {
        player.tech = data[1];
        player.invalidate_quest_cache();
        player.claim_achievements();
    } else if(msg == "PLAYER_AURAS_UPDATE") {
        player.player_auras = data[1];

        // clear popups, if any
        if(session.home_base) {
            var dialog = desktop_dialogs['desktop_top'];
            if(dialog && dialog.user_data && dialog.user_data['aura_context']) {
                invoke_aura_context(dialog, null, -1, null, false);
            }
        }
    } else if(msg == "ENEMY_AURAS_UPDATE") {
        enemy.player_auras = data[1];
    } else if(msg == "PLAYER_STATTAB_UPDATE") {
        var old_combat_time_scale = combat_time_scale(); // remember old combat_time_scale, since stattab update can change it

        player.stattab = data[1];
        if(world) { // ignore updates prior to first connection (pre-hello consequents etc)
            Building.update_modstats('player', player.stattab['buildings']);
        }

        // check for any change to combat_time_scale
        var new_combat_time_scale = combat_time_scale();
        if(new_combat_time_scale != old_combat_time_scale) {
            // adjust in-progress time-dependent effects here
            if(session.incoming_attack_wave_time > server_time) {
                var delta = session.incoming_attack_wave_time - server_time;
                delta *= old_combat_time_scale / new_combat_time_scale;
                session.incoming_attack_wave_time = server_time + Math.floor(delta);
            }
        }
    } else if(msg == "ENEMY_STATTAB_UPDATE") {
        enemy.stattab = data[1];
        if(world) {
            Building.update_modstats('enemy', enemy.stattab['buildings']);
        }
    } else if(msg == "PLAYER_UNIT_EQUIP_UPDATE") {
        player.unit_equipment = data[1];
    } else if(msg == "ENEMY_UNIT_EQUIP_UPDATE") {
        enemy.unit_equipment = data[1];
    } else if(msg == "NEW_ENHANCEMENT") {
        var obj_id = data[1], enh_name = data[2], new_level = data[3];

        // trigger congrats message, if applicable
        notification_queue.push(goog.partial(invoke_enhancement_congrats, obj_id, enh_name, new_level));

        // fire M&M
        var lab = world.objects._get_object(obj_id);
        if(lab) {
            if(!player.is_cheater) {
                // trigger visual effect
                var fx_data = gamedata['client']['vfx']['building_enhancement_finish'];
                if(fx_data) {
                    var tech = gamedata['enhancements'][enh_name];
                    var unit = tech['associated_unit'] || tech['affects_unit'] || null;
                    var asset = lab.get_leveled_quantity(lab.spec['art_asset']);
                    var instance_data = { '%OBJECT_SPRITE': asset };
                    world.fxworld.add_visual_effect_at_time([lab.x,lab.y], 0, [0,1,0], client_time, fx_data,
                                                            true,
                                                            instance_data);
                    // hold notification until animation finishes
                    notification_queue.hold_until(client_time + 2.9);
                }
            }
        }

        session.clear_building_idle_state_caches(); // for ALL buildings

    } else if(msg == "NEW_TECH") {
        var newly_researched = data[1];
        var new_level = data[2];
        var lab_id = data[3];

        // trigger congrats message, if applicable
        var cb = (function (n) { return function() { invoke_tech_upgrade_congrats(n); }; })(newly_researched);
        notification_queue.push(cb);

        // update research dialog
        if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'research_dialog') {
            research_dialog_change_category(selection.ui, selection.ui.user_data['category'], selection.ui.user_data['page']);
        }

        // fire M&M
        var lab = world.objects._get_object(lab_id);
        if(lab) {
            if(!player.is_cheater) {
                // trigger visual effect
                var fx_data = gamedata['client']['vfx']['tech_research_finish'];
                var tech = gamedata['tech'][newly_researched];
                var unit = tech['associated_unit'] || tech['affects_unit'] || null;
                var asset = (unit ? get_leveled_quantity(gamedata['units'][unit]['art_asset'], Math.max(1,player.tech[unit['level_determined_by_tech']])) : lab.get_leveled_quantity(lab.spec['art_asset']));
                var instance_data = { '%OBJECT_SPRITE': asset };
                world.fxworld.add_visual_effect_at_time([lab.x,lab.y], 0, [0,1,0], client_time, fx_data,
                                                        true,
                                                        instance_data);
                // hold notification until animation finishes
                notification_queue.hold_until(client_time + 2.9);
            }
        }

        session.clear_building_idle_state_caches(); // for ALL buildings

    } else if(msg == "BASE_POWER_UPDATE") {
        session.viewing_base.update_power_state(data[1]);
    } else if(msg == "RES_LOOTER_UPDATE") {
        session.res_looter = data[1];
    } else if(msg == "BASE_SIZE_UPDATE") {
        session.viewing_base.base_size = data[1];
    } else if(msg == "PLAYER_TRAVEL_UPDATE") {
        player.travel_state = data[1];
    } else if(msg == "PLAYER_HISTORY_UPDATE") {
        player.history = data[1];
        player.invalidate_quest_cache();
        player.quest_tracked_dirty = true;
        player.claim_achievements();
    } else if(msg == "COOLDOWNS_UPDATE") {
        player.cooldowns = data[1];
    } else if(msg == "TUTORIAL_STATE_UPDATE") {
        player.tutorial_state = data[1];
    } else if(msg == "MAIL_UPDATE") {
        var msg_id = data[1];
        if(msg_id) { // update one individual mail
            var new_mail = data[2];
            for(var i = 0; i < player.mailbox.length; i++) {
                var old_mail = player.mailbox[i];
                if(old_mail['msg_id'] === msg_id) {
                    if('pending' in old_mail) { // carry over pending flag
                        new_mail['pending'] = old_mail['pending'];
                    }
                    player.mailbox[i] = new_mail;
                    break;
                }
            }
        } else {
            // full replacement of entire mailbox
            if(!synchronizer.is_in_sync(player.mailbox_sync_marker)) {
                // IGNORE this update - we have a MAIL_DELETE in flight
                return;
            }

            var old_mailbox = player.mailbox;
            player.mailbox = data[2];
            // carry over any in-flight pending flags
            goog.array.forEach(old_mailbox, function(old_mail) {
                if('pending' in old_mail) {
                    var new_mail = goog.array.find(player.mailbox, function(new_mail) { return new_mail['msg_id'] === old_mail['msg_id']; });
                    if(new_mail) {
                        new_mail['pending'] = old_mail['pending'];
                    }
                }
            });
        }

        if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] === 'mail_dialog') {
            update_mail_dialog(selection.ui, false);
        }

        player.invalidate_quest_cache();
    } else if(msg == "MAIL_TAKE_ATTACHMENTS_RESULT") {
        var msg_id = data[1], slot = data[2], success = data[3], fungible = data[4], new_mail = data[5];

        if(new_mail) {
            for(var i = 0; i < player.mailbox.length; i++) {
                var old_mail = player.mailbox[i];
                if(old_mail['msg_id'] === msg_id) {
                    if('pending' in old_mail) { // carry over pending flag
                        new_mail['pending'] = old_mail['pending'];
                    }
                    player.mailbox[i] = new_mail;
                    break;
                }
            }
        }

        if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] === 'mail_dialog') {
            if(success) {
                selection.ui.widgets['glow'].show = true;
                selection.ui.widgets['glow'].reset_fx();
                // make little rising text
                var framenum = slot - (selection.ui.user_data['attach_page']*selection.ui.data['widgets']['attach_frame']['array'][0]);
                var ui_msg = gamedata['strings']['combat_messages'][(fungible ? "collected" : "added_to_warehouse")];
                ItemDisplay.add_inventory_item_effect(session.get_draw_world().fxworld, selection.ui.widgets['attach_frame'+framenum.toString()], ui_msg, [1,1,0.3,1]);
            }
            var old_page = selection.ui.user_data['attach_page'];
            // reset state of mail dialog
            mail_dialog_scroll(selection.ui, selection.ui.user_data['first_row']);
            mail_dialog_select_mail(selection.ui, selection.ui.user_data['selected_row']);
            mail_dialog_attach_scroll(selection.ui, old_page);
        }
        player.quest_tracked_dirty = true;
    } else if(msg == "DONATED_UNITS_UPDATE") {
        player.donated_units = data[1];
    } else if(msg == "DONATED_UNITS_RECEIVED") {
        var unit_list = data[1];
        var from_id = data[2], from_fbid = data[3], from_name = data[4];
        var display_string = units_description(unit_list, ', ');
        user_log.msg(gamedata['strings']['you_got_reinforcements'].replace('%sender',from_name).replace('%units', display_string), new SPUI.Color(1,0,1,1));
    } else if(msg == "HELP_REQUESTED") {
        var obj_id = data[1];
        var pos = data[2];

        var str = gamedata['strings']['you_sent_help_request'];

        // offset pos a little bit
        var off = [0, -11];

        world.fxworld.add(new SPFX.CombatText(vec_add(pos, off), 0, str, [1, 0.2, 1, 1],
                                              world.fxworld.now_time(), 3.0,
                                              { drop_shadow: true, font_size: 20, text_style: 'normal' }));
        GameArt.play_canned_sound('request_help_sound');

        // pop up Alliance chat
        if(global_chat_frame) {
            change_chat_tab(global_chat_frame, 'ALLIANCE');
            chat_frame_size(global_chat_frame, true, true);
        }

    } else if(msg == "HELP_RESPONSE" || msg == "HELP_COMPLETE") {
        var from_name = data[1], req = data[2], time_saved = data[3];
        user_log.msg(gamedata['strings'][msg == "HELP_COMPLETE" ? 'you_got_help_complete': 'you_got_help_response'].replace('%sender', from_name).replace('%cur', req['helper_ids'].length.toString()).replace('%max', gamedata['alliance_help_quorum'].toString()).replace('%descr', help_request_ui_descr(req['req_props'])).replace('%time_saved', pretty_print_time(time_saved)), new SPUI.Color(1,0,1,1));
    } else if(msg == "INVENTORY_UPDATE") {
        player.max_inventory = data[1];
        player.inventory = data[2];
        player.reserved_inventory = data[3];

        goog.array.forEach(inventory_update_receivers, function(cb) { cb(); });

    } else if(msg == "LOOT_BUFFER_UPDATE") {
        player.loot_buffer = data[1];
        var immediate = data[2] && selection.ui && selection.ui.user_data && goog.array.contains(['inventory_dialog','crafting_dialog','crafting_table_of_contents_dialog'], selection.ui.user_data['dialog']);
        if(player.loot_buffer.length > 0 && session.home_base) {
            if(immediate) {
                invoke_loot_dialog();
            } else {
                notification_queue.push_with_priority(invoke_loot_dialog, -10);
            }
        }
        refresh_loot_dialog();
        player.claim_achievements();
    } else if(msg == "INVENTORY_USE_RESULT" || msg == "INVENTORY_TRASH_RESULT" || msg == "INVENTORY_REFUND_RESULT") {
        var index = data[1], specname = data[2], success = data[3], count = data[4];
        var spec = ItemDisplay.get_inventory_item_spec(specname);

        if(index < player.inventory.length && player.inventory[index]['spec'] == specname) {
            var item = player.inventory[index];
            if('pending' in item) {
                delete item['pending'];
                if('pending_action' in item) {
                    delete item['pending_action'];
                }
            }
        }

        if(success && msg == "INVENTORY_USE_RESULT") {
            var extra_spellargs = data[5];
            var log_item = {'spec': specname, 'stack': count};
            var log_target_pos = null;

            if('use_effect' in spec) {
                // check for null separately from checking if the effect exists so we can use a null effect
                // in the item spec to disable the game-wide effect
                if(spec['use_effect']) {
                    world.fxworld.add_visual_effect_at_time([0,0], 0, [0,1,0], client_time, spec['use_effect'], true, null);
                }
            } else if(gamedata['client']['vfx']['item_use']) {
                world.fxworld.add_visual_effect_at_time([0,0], 0, [0,1,0], client_time, gamedata['client']['vfx']['item_use'], true, null);
            }

            if('use' in spec) {
                var uselist = get_as_array(spec['use']);
                for(var m = 0; m < uselist.length; m++) {
                    var use = uselist[m];
                    if('spellname' in use) {
                        var spell = gamedata['spells'][use['spellname']];
                        if(('code' in spell) && (spell['code'] == 'projectile_attack')) {
                            var target_loc = extra_spellargs[0], target_height = 0;
                            log_target_pos = target_loc;
                            var launch_loc = vec_add(target_loc, [-20, 20]);
                            var launch_height = (('ground_plane' in session.viewing_base.base_climate_data && session.viewing_base.base_climate_data['ground_plane'] < 0) ? -100 : 100);


                            // check for anti-missile defenses
                            var interceptor = /** @type {GameObject|null} */ (session.for_each_real_object(function(obj) {
                                if(obj.is_building() && !obj.is_destroyed() && !obj.disarmed && !obj.combat_stats.stunned && (obj.team !== 'player') &&
                                   obj.equipment && obj.is_shooter()) {
                                    var chance = 1 - obj.combat_stats.anti_missile;
                                    if(chance > 0) {
                                        // check range
                                        var range = obj.weapon_range()[1];
                                        var dist = vec_distance(obj.raw_pos(), target_loc);
                                        if(range > 0 && dist < range) {
                                            // chance of interception
                                            if(Math.random() < chance) {
                                                target_height = (launch_height > 0 ? 10 : -4);
                                                return obj;
                                            }
                                        }
                                    }
                                }
                            }));

                            // missile effect
                            world.combat_engine.queue_projectile(new CombatEngine.ProjectileEffect('PLAYER', 'player',
                                                                                                   launch_loc, launch_height, launch_loc,
                                                                                                   // might be more correct to add 1 tick here,
                                                                                                   // since it won't be processed until next iteration
                                                                                                   world.combat_engine.cur_tick,
                                                                                                   0, null, -1,
                                                                                                   spell['name'], 1, null,
                                                                                                   target_loc, target_height,
                                                                                                   interceptor ? interceptor.id : null));
                        }
                    }
                }
            }
            world.combat_engine.log_item(new CombatEngine.ItemRecord(log_item, log_target_pos));
        }

        // update Warehouse UI
        if(selection.ui && selection.ui.user_data &&
           (selection.ui.user_data['dialog'] === 'inventory_dialog' || selection.ui.user_data['dialog'] === 'loot_dialog')) {
            var dialog = selection.ui;
            if(dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === index) {
                // clear context menu
                invoke_inventory_context(dialog, null, -1, null, false);
            }
            if(success) {
                var shown_index = index - dialog.user_data['page']*(dialog.user_data['rows_per_page']*dialog.user_data['cols_per_page']);
                if(shown_index >= 0 && shown_index < dialog.user_data['rows_per_page']*dialog.user_data['cols_per_page']) {
                    var x = (shown_index % dialog.user_data['cols_per_page']), y = Math.floor(shown_index / dialog.user_data['cols_per_page']);
                    var str = (count > 1 ? ItemDisplay.get_inventory_item_stack_prefix(spec, count) : '') + ItemDisplay.get_inventory_item_ui_name(spec);
                    console.log('x '+x.toString()+' y '+y.toString());
                    var color = [0.6,0.6,0.6,1];
                    if(msg == "INVENTORY_TRASH_RESULT") {
                        str += ' '+gamedata['strings']['combat_messages']['discarded'];
                    } else if(msg == "INVENTORY_REFUND_RESULT") {
                        str += ' '+gamedata['strings']['combat_messages']['refunded'];
                    } else if(msg == "INVENTORY_USE_RESULT") {
                        selection.ui.widgets['glow'].show = true;
                        selection.ui.widgets['glow'].reset_fx();
                        str += ' '+gamedata['strings']['combat_messages']['activated'];
                        color = [1,1,0.3,1];
                    }
                    ItemDisplay.add_inventory_item_effect(session.get_draw_world().fxworld, selection.ui.widgets['slot'+x.toString()+','+y.toString()], str, color);
                }
            }
        }
    } else if(msg == "ON_APPROACH_RESULT") {
        var defender_id = data[1], obj_id = data[2], client_start_time = data[3], server_receipt_time = data[4];
        if(!gamedata['client']['report_on_approach_latency']) { return; }
        metric_event('3973_on_approach_latency', {'client_start_time': client_start_time,
                                                  'client_end_time': client_time,
                                                  'server_receipt_time': server_receipt_time,
                                                  'latency': client_time - client_start_time,
                                                  'defender_id': defender_id});
    } else if(msg == "EQUIP_BUILDING_RESULT") {
        var my_arg = data[1], success = data[2];
        var unit_id = my_arg[1], addr = my_arg[2], inv_slot = my_arg[3], add_item = my_arg[4], remove_item = my_arg[5], ui_slot = my_arg[6];

        if(world.objects.has_object(unit_id)) {
            var unit = world.objects.get_object(unit_id);
            unit.equip_pending = false;

            // add feedback to Upgrade dialog
            if(success && selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'upgrade_dialog' && selection.ui.user_data['unit'] == unit) {
                var dialog = selection.ui;
                var str, color;
                var add_specname = (add_item ? add_item['spec'] : null), remove_specname = (remove_item ? remove_item['spec'] : null);
                var ui_name = ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(add_specname || remove_specname));
                if(!add_specname) {
                    var what_happened;
                    if(remove_specname && (remove_specname in gamedata['items']) && (gamedata['items'][remove_specname]['remove_fragility'] || 0) >= 1) {
                        what_happened = 'discarded';
                    } else {
                        what_happened = 'returned_to_warehouse';
                    }
                    str = ui_name + " "+ gamedata['strings']['combat_messages'][what_happened]; color = [0.6,0.6,0.6,1];
                } else {
                    str = ui_name + " "+ gamedata['strings']['combat_messages']['equipped']; color = [1,1,0.3,1];
                    dialog.widgets['equip_glow'+ui_slot].show = true;
                    dialog.widgets['equip_glow'+ui_slot].reset_fx();
                }
                ItemDisplay.add_inventory_item_effect(session.get_draw_world().fxworld, dialog.widgets['equip_frame'+ui_slot], str, color);
                player.claim_achievements();
            }
        }

    } else if(msg == "EQUIP_UNIT_RESULT") {
        var my_arg = data[1], success = data[2];
        var dest_spec_name = my_arg[1], addr = my_arg[2], inv_slot = my_arg[3], add_item = my_arg[4], remove_item = my_arg[5], ui_slot = my_arg[6];
        // add feedback to Upgrade dialog
        var dialog = find_dialog('upgrade_dialog');
        if(dialog && dialog.user_data['tech'] && dialog.user_data['tech']['associated_unit'] == dest_spec_name) {
            var str, color;
            var add_specname = (add_item ? add_item['spec'] : null), remove_specname = (remove_item ? remove_item['spec'] : null);
            var ui_name = ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(add_specname || remove_specname));
            if(!add_specname) {
                str = ui_name + " "+gamedata['strings']['combat_messages']['returned_to_warehouse']; color = [0.6,0.6,0.6,1];
            } else {
                str = ui_name + " "+ gamedata['strings']['combat_messages']['equipped']; color = [1,1,0.3,1];
                dialog.widgets['equip_glow'+ui_slot].show = true;
                dialog.widgets['equip_glow'+ui_slot].reset_fx();
            }
            ItemDisplay.add_inventory_item_effect(session.get_draw_world().fxworld, dialog.widgets['equip_frame'+ui_slot], str, color);
            player.claim_achievements();
        }

    } else if(msg == "ITEMS_DISCOVERED") {
        var items = data[1], duration = data[2], where = data[3];
        var invoker = (function(_items, _duration, _where) { return function() {
            invoke_items_discovered(_items, _duration, _where);
        }; })(items, duration, where);

        if(!session.server_hello_ended) {
            // if this comes in from a login_pre_hello consequent, wait for the queue
            notification_queue.push(invoker);
        } else {
            invoker(); // immediately add
        }
        /*
        if(find_dialog('new_store_dialog')) {
            invoker(); // immediately super-impose
        } else {
            notification_queue.push(invoker);
        }
        */
    } else if(msg == "YOU_GOT_BONUS_UNITS") {
        notification_queue.push(invoke_you_got_bonus_units);
    } else if(msg == "YOU_SENT_GIFT_ORDER") {
        var gift_order = data[1];
        var func = (function (_gift_order) { return function() { invoke_you_sent_gift_order_dialog(_gift_order); }; })(gift_order);
        notification_queue.push(func);
    } else if(msg == "ITEM_PURCHASED") {

        // awkward - delay so that the following LOOT_BUFFER_UPDATE takes effect
        window.setTimeout(function() { invoke_loot_dialog(gamedata['strings']['combat_messages']['item_purchased']); }, 1);

    } else if(msg == "QUEST_STATE_UPDATE") {
        // completely replace quest state with the server's version
        player.completed_quests = data[1];
        player.invalidate_quest_cache();
    } else if(msg == "ACHIEVEMENTS_UPDATE") {
        player.achievements = data[1];

        // primitive check for new achievements
        if(1) {
            player.claim_achievements();
        }

    } else if(msg == "ACHIEVEMENT_CLAIMED") {
        var name = data[1], props = data[2];
        player.achievements[name] = props;
        var spec = gamedata['achievements'][name];
        if(player.get_any_abtest_value('enable_ingame_achievements', gamedata['client']['enable_ingame_achievements'])) {
            notification_queue.achievements.push(spec);
            notification_queue.push(notify_achievements);
        }
    } else if(msg == "FB_APP_EVENT") {
        var name = data[1], value = data[2], params = data[3];
        SPFB.AppEvents.logEvent(name, value, params);
    } else if(msg == "COMPLETED_QUEST") {
        var name = data[1];
        var qdata = data[2];
        var quest = gamedata['quests'][name];

        if(player.quest_tracked === quest) { player.quest_tracked = null; player.quest_tracked_dirty = true; }

        player.completed_quests[name] = qdata;
        player.invalidate_quest_cache();
        player.update_quest_cache();

        var missions_dialog = find_dialog('missions_dialog');

        var cb = (function (_quest) { return function() {
            var _missions_dialog = find_dialog('missions_dialog');
            if(_missions_dialog) {
                _missions_dialog.user_data['just_completed_row'] = _missions_dialog.user_data['quest_list'].indexOf(quest);
                _missions_dialog.user_data['selected_row'] = -1;
                update_missions_dialog(_missions_dialog);
            }

            if('completion' in _quest) {
                execute_logic(_quest['completion']);
            }
            if(player.can_level_up()) {
                notification_queue.push_with_priority(invoke_level_up_dialog, -1);
            }
        }; })(quest);

        // note: wait for missions dialog animation to finish before running other steps
        var fx_time = missions_dialog ? missions_dialog.widgets['glow'].fx_time_remaining() : -1;
        if(fx_time > 0) {
            window.setTimeout(cb, 1000.0*fx_time);
        } else {
            cb();
        }

    } else if(msg == "GIFT_PROMPT") {
        if(player.resource_gifts_enabled() && read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null)) {
            notification_queue.push(invoke_gift_prompt_dialog);
        }
    } else if(msg == "INVITE_FRIENDS_PROMPT") {
        if(read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null)) {
            notification_queue.push(function() { invoke_invite_friends_prompt('from_server'); });
        }
    } else if(msg == "YOU_WERE_ATTACKED") {
        var recent_attacks = data[1];
        var cb = (function (ra) { return function() { invoke_you_were_attacked_dialog(ra); }; })(recent_attacks);
        // remove any pending invoke_repair_dialog_conditionals, because we override that with our own repair buttons
        notification_queue.remove(invoke_repair_dialog_conditional);
        notification_queue.push(cb);
    } else if(msg == "SHOW_BATTLE_HISTORY") {
        notification_queue.push(function() { invoke_battle_history_dialog(session.user_id, -1, session.alliance_id, '', -1); });
    } else if(msg == "DISPLAY_MOTD") {
        var motd = data[1];
        var cb = (function (m) { return function() { invoke_motd_dialog(m); }; })(motd);
        notification_queue.push(cb);
    } else if(msg == "DISPLAY_DAILY_TIP") {
        notification_queue.push((function (tipname) { return function() { invoke_daily_tip(tipname); } })(data[1]));
    } else if(msg == "DISPLAY_DAILY_TIP_PAGES") {
        notification_queue.push_with_priority((function (tiplist) { return function() { invoke_daily_tip_pages(tiplist); } })(data[1]), -6);

    // unfortunately, these two code paths are kind of redundant and confusing
    // DISPLAY_MESSAGE is used in AI base "completion" predicates to show the victory M&M
    // MESSAGE_BOX is used for tutorial instruction dialogs
    } else if(msg == "DISPLAY_MESSAGE") {
        var msgdat = data[1];
        var cons = new DisplayMessageConsequent(msgdat);
        cons.execute();
    } else if(msg == "MESSAGE_BOX") {
        var msgdat = data[1];
        notification_queue.push((function (_msgdata) { return function() {
            read_consequent(_msgdata).execute();
        }; })(msgdat));

    } else if(msg == "CLIENT_CONSEQUENT") {
        read_consequent(data[1]).execute();

    } else if(msg == "FLASH_OFFER") {
        var msgdat = data[1];
        var cb = (function (dat) { return function() { invoke_flash_offer(dat); }; })(msgdat);
        notification_queue.push(cb);

    } else if(msg == "SYSTEM_REFUND") {
        var loot = data[1];
        var ui_reason = data[2];
        notification_queue.push((function(_loot, _ui_reason) { return function() {
            invoke_message_dialog(gamedata['strings']['system_refund']['ui_title'],
                                  ui_reason,
                                  {'dialog': 'message_dialog_big'});
        }; })(loot, ui_reason));
    } else if(msg == "RECEIVED_GIFT2") {
        var sender_user_id = data[1];
        var sender_info = data[2]; // could be stale, so don't enter into PlayerCache
        var loot = data[3];

        gift_received(sender_user_id, sender_info, loot);

    } else if(msg == "SEND_GIFTS_BH_COMPLETE") {
        var id_list = data[1];
        var dialog = find_dialog('bh_invite_dialog');
        BHInvites.gifts_complete(dialog.widgets['gifts_tab'], id_list);

    } else if(msg == "SESSION_LOOT_UPDATE") {
        session.last_loot = session.loot;
        session.loot = data[1];
    } else if(msg == "LOOTED_RESOURCES" || msg == "HARVESTED_RESOURCES") {
        var res = data[1];
        var obj_id = data[2];
        var pos = data[3];
        var base_type = data[4] || null;
        var base_ui_name = data[5] || null;

        var anything_to_show = false;
        if(res['gamebucks'] || res['cooldown']) { anything_to_show = true; }
        for(var resname in gamedata['resources']) {
            if(res[resname]) { anything_to_show = true; break; }
        }
        if(!anything_to_show) { return; }

        var prefix;

        if(base_type == 'quarry') {
            if(base_ui_name) {
                prefix = gamedata['strings']['regional_map']['quarry'].replace('%s',base_ui_name)+': ';
            } else {
                prefix = gamedata['strings']['regional_map']['all_quarries']+': ';
            }
            if(!res['cooldown']) { seen_quarry_harvest = true; }
            if(session.home_base) {
                // use the central computer to show quarry activity
                var cc = player.get_townhall();
                pos = [cc.x, cc.y];
                obj_id = cc.id;

                // invalidate point count
                if(!res['cooldown']) {
                    var event = player.current_stat_tournament_event();
                    if(event && goog.array.contains(['strongpoint_resources', 'quarry_resources'], event['stat']['name'])) {
                        var dialog = desktop_dialogs['desktop_bottom'];
                        if('point_counts' in dialog.widgets['map_event_info'].user_data) {
                            delete dialog.widgets['map_event_info'].user_data['point_counts'];
                        }
                    }
                }
            }
        } else {
            prefix = '';
        }

        var text = [];

        if(res['cooldown'] > 0) {
            text.push({'color': gamedata['client']['loot_text_color']['cooldown'],
                       'str': prefix+ gamedata['strings']['combat_messages']['ready_in'].replace('%s',pretty_print_time_brief(res['cooldown']-server_time))});
        } else {
            var sign;
            if(msg == "LOOTED_RESOURCES" && session.home_base) {
                // taken by AI
                sign = '-';
            } else {
                sign = '+';
            }

            for(var resname in gamedata['resources']) {
                if((res[resname]||0) > 0) {
                    var bonus_str = ((resname+'_bonus') in res ? ' '+gamedata['strings']['combat_messages']['resource_bonus'].replace('%d', pretty_print_number(res[resname+'_bonus'])) : '');
                    text.push({'color':gamedata['resources'][resname]['loot_text_color'],
                               'size': ((msg == "LOOTED_RESOURCES" && 'loot_text_size' in gamedata['resources'][resname]) ? gamedata['resources'][resname]['loot_text_size'] : null),
                               'rise_time': ((msg == "LOOTED_RESOURCES" && 'loot_text_rise_time' in gamedata['resources'][resname]) ? gamedata['resources'][resname]['loot_text_rise_time'] : null),
                               'str': prefix + sign + pretty_print_number(res[resname]) + ' '+gamedata['resources'][resname]['ui_name'] + bonus_str});
                    if(msg == "LOOTED_RESOURCES" &&
                       gamedata['resources'][resname]['loot_effect'] &&
                       pos && pos[0] >= 0 && pos[1] >= 0) {
                        var props = goog.object.clone(gamedata['resources'][resname]['loot_effect']);
                        //props['emit_instant'] = props['max_count'] = (res[resname] >= props['res_big'] ? props['count_big'] : (res[resname] >= props['res_med'] ? props['count_med'] : props['count_small']));
                        world.fxworld.add_visual_effect_at_time(pos, 0, [0,1,0], client_time, props, true, null);
                    }
                }
            }

            if(res['gamebucks'] > 0) {
                text.push({'color':gamedata['client']['loot_text_color']['gamebucks'],
                           'str': prefix + sign + Store.display_user_currency_amount(res['gamebucks'],'full')});
            }
        }

        if(pos && pos[0] >= 0 && pos[1] >= 0) {
            // prevent overlap
            var text_delay = 0;
            if(msg != "LOOTED_RESOURCES") {
                if(client_time - last_loot_text_time < 1.0) {
                    if(last_loot_text_pos && last_loot_text_pos[0] == pos[0] && last_loot_text_pos[1] == pos[1]) {
                        last_loot_text_count += 1;
                    }
                } else {
                    last_loot_text_count = 0;
                }
                text_delay = 0.5 * last_loot_text_count;
            }

            var default_rise_time = ((base_type == 'quarry') ? 5.0 : 3.0);
            var text_props = { drop_shadow: true, text_style: 'thick' };
            var center = (text.length > 1 ? 0.5 : 0);
            for(var i = 0; i < text.length; i++) {
                text_props.font_size = (text[i]['size'] || 20);
                var left_right_offset = 7 * (text_props.font_size/20);
                var rise_time = (text[i]['rise_time'] || default_rise_time);
                world.fxworld.add(new SPFX.CombatText([pos[0]-4 + (i-center)*left_right_offset,pos[1]-4 - (i-center)*left_right_offset], 0,
                                                      text[i]['str'], text[i]['color'],
                                                      new SPFX.When(client_time + text_delay, null), rise_time,
                                                      text_props));
            }
        } else {
            last_loot_text_count = 0;
        }

        var flash_delay, ticker_delay;
        var need_glow_effect = false;

        if(msg == "HARVESTED_RESOURCES") {
            // peaceful harvesting
            var has_sound = false;
            for(var resname in gamedata['resources']) {
                if((res[resname]||0) > 0) {
                    if(gamedata['resources'][resname]['harvest_effect']) {
                        world.fxworld.add_visual_effect_at_time(pos, 0, [0,1,0], client_time, gamedata['resources'][resname]['harvest_effect'], !has_sound, null);
                        has_sound = true;
                    } else {
                        need_glow_effect = true;
                    }
                }
            }
            if(!has_sound && client_time - last_loot_text_time > 1.0) { // play a default sound effect
                GameArt.play_canned_sound('harvest_sound');
            }
            flash_delay = gamedata['client']['harvest_flash_delay'];
            ticker_delay = gamedata['client']['harvest_flash_delay'] + gamedata['client']['resource_ticker_delay'];
        } else {
            // combat loot
            if(gamedata['gradual_loot'] > 0) {
                flash_delay = ticker_delay = 0;
            } else {
                var loot_flash_delay = player.get_any_abtest_value('loot_flash_delay', gamedata['client']['loot_flash_delay']);
                flash_delay = loot_flash_delay;
                ticker_delay = loot_flash_delay + gamedata['client']['resource_ticker_delay'];
            }
            // note: FORCE the previous flash to conclude so that we
            // can restart it with a delay
            player.last_resource_time = -1;
            for(var resname in gamedata['resources']) {
                player.last_resource_state[resname] = player.resource_state[resname][1];
                if(res[resname]) { player.flash_res_time[resname] = -1; }
            }
        }

        for(var resname in gamedata['resources']) {
            if(res[resname] && player.flash_res_time[resname] <= 0) {
                player.flash_res_time[resname] = client_time + flash_delay;
            }
        }
        if(player.last_resource_time <= 0) {
            player.last_resource_time = client_time + ticker_delay;
        }

        if(need_glow_effect) { // trigger glow effect
            var obj = world.objects._get_object(obj_id);
            if(obj) {
                if(obj.is_building() && obj.is_producer()) {
                    obj.harvest_glow_time = client_time;
                }
            }
        }

        // "ding" sound for gamebucks
        if(res['gamebucks'] > 0) {
            if(gamedata['client']['vfx']['gamebucks_harvest_effect']) {
                world.fxworld.add_visual_effect_at_time(pos, 0, [0,1,0], client_time, gamedata['client']['vfx']['gamebucks_harvest_effect'], true, null);
            } else {
                GameArt.play_canned_sound('minor_level_up_sound');
            }
        }

        // GUI message
        if(res['gamebucks'] > 0) {
            var s = gamedata['strings']['gamebucks_discovered_in_deposit'];
            if(s) {
                invoke_child_message_dialog(s['ui_title'].replace('%s',Store.gamebucks_ui_name()),
                                            s['ui_description'].replace('%s', Store.display_user_currency_amount(res['gamebucks'], 'full')));
            }
        } else if(world.objects.has_object(obj_id) &&
                  world.objects.get_object(obj_id).spec['name'] == 'iron_deposit') {
            // see if this was the last deposit, and if so show consolation message
            var more_deposits = session.for_each_real_object(function(obj, id) {
                if(id != obj_id && obj.spec['name'] == 'iron_deposit') {
                    return true;
                }
            });

            if(!more_deposits &&
               player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks' &&
               player.get_any_abtest_value('gamebucks_in_deposits', gamedata['gamebucks_in_deposits'])) {
                var s = gamedata['strings']['deposits_mined_out'];
                if(s) {
                    invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%s', Store.gamebucks_ui_name()));
                }
            }
        }

        last_loot_text_time = client_time;
        last_loot_text_pos = pos;

    } else if(msg == "GAINED_XP" || msg == "GAINED_XP2") {
        var amount = data[1];
        var obj_id = data[2];
        var pos = data[3];

        if(msg == "GAINED_XP2") { // also includes new total
            var new_player_xp = data[4];
            update_resources_xp(new_player_xp);
        }

        if(/* player.get_any_abtest_value('show_xp_gains', gamedata['client']['show_xp_gains']) && */ pos[0] >= 0 && pos[1] >= 0) {
            var str = ' +' + pretty_print_number(amount) + ' XP';

            // offset pos a little bit since these almost always go with other combat text
            var off = [-2,-2];
            var font_size = 16;
            if(world.objects.has_object(obj_id)) {
                off = [0, -11];
                font_size = 20;
            }

            var flashy = player.flashy_loot();
            var text_props_flashy = { drop_shadow: true, font_size: font_size, text_style: 'thick' };
            var text_props_boring = { drop_shadow: false, font_size: 14, text_style: 'normal' };
            var text_props = flashy ? text_props_flashy : text_props_boring;

            world.fxworld.add(new SPFX.CombatText([pos[0]+off[0],pos[1]+off[1]], 0, str, [1, 0.2, 1, 1], world.fxworld.now_time(), 3.0, text_props));
        }

        GameArt.play_canned_sound('xp_gain_sound');

        if(player.can_level_up()) {
            notification_queue.push_with_priority(invoke_level_up_dialog, -1);
        }
    } else if(msg == "CRAFT_COMPLETE") {
        var obj_id = data[1], loot = data[2], attempt_ids = data[3];
        var obj = world.objects._get_object(obj_id);
        if(!obj || !obj.is_building()) { return; }
        var pos = [obj.x, obj.y];
        var off = [0, 0];
        var str, clr;

        if(attempt_ids && attempt_ids[0] && selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'fishing_dialog') {
            return; // dialog handles sight & sound
        }

        if(loot) {
            GameArt.play_canned_sound('xp_gain_sound');
            clr = [1,0.5,0,1];
            var ls = [];
            for(var i = 0; i < loot.length; i++) {
                var spec = ItemDisplay.get_inventory_item_spec(loot[i]['spec']);
                var stack = loot[i]['stack'] || 1;
                ls.push(ItemDisplay.get_inventory_item_stack_prefix(spec, stack) + ItemDisplay.get_inventory_item_ui_name(spec));
            }
            str = gamedata['strings']['craft_completed'].replace('%s', ls.join(', '));
        } else {
            GameArt.play_canned_sound('xp_gain_sound');
            clr = [1,0.0,0.0,1];
            str = gamedata['strings']['craft_fizzled'];
        }
        world.fxworld.add(new SPFX.CombatText(vec_add(pos, off), 0, str, clr, world.fxworld.now_time(), 3.0,
                                              { drop_shadow: true, font_size: 20, text_style: 'thick' }));
    } else if(msg == "ADD_FRIEND") {
        var user_id = data[1];
        var is_real_friend = data[2]
        var pcache_data = data[3];
        var relationship = data[4];
        if(pcache_data) { PlayerCache.update_batch(pcache_data); }
        var friend = new Friend(user_id, is_real_friend, pcache_data[0], relationship);
        player.friends.push(friend);
        if(session.home_base) {
            if(desktop_dialogs['desktop_bottom'] && desktop_dialogs['desktop_bottom'].widgets['friend_bar']) {
                scroll_friend_bar(desktop_dialogs['desktop_bottom'].widgets['friend_bar'], -1);
            }
        }
    } else if(msg == "UPDATE_FRIEND") {
        // obsolete
    } else if(msg == "REM_FRIEND") {
        var user_id = data[1];
        for(var i = 0; i < player.friends.length; i++) {
            if(player.friends[i].user_id === user_id) {
                player.friends.splice(i,1);
                i -= 1;
                //break; allow duplicates
            }
        }
    } else if(msg == "AI_ATTACK_WARNING") {
        session.incoming_attack_time = data[1];
        session.incoming_attack_units = data[2];
        session.incoming_attacker_name = data[3];
        var text_index = data[4];
        session.incoming_attack_direction = data[5];
        var warning_time = data[6];

        session.incoming_attack_units_destroyed = 0;
        session.incoming_attack_units_total = 0;

        goog.array.forEach(session.incoming_attack_units, function(wave) {
            goog.object.forEach(wave, function(val, key) {
                if(!(key in gamedata['units'])) { return; }
                if(typeof val === 'number') {
                    session.incoming_attack_units_total += val;
                } else {
                    session.incoming_attack_units_total += val['qty']||1;
                }
            });
        });

        if(warning_time > 0) {
            invoke_ai_attack_warning_dialog(gamedata['ai_attacks_client']['flavor_text'][text_index]);
        }

    } else if(msg == "AI_ATTACK_WAVE_DEPLOYED") {
        var finish_time = data[1];
        var units = data[2];
        var wave_time = data[3];
        var replay_token = data[4];

        session.has_attacked = true;
        session.set_attack_finish_time(finish_time);
        session.incoming_attack_units = units;
        session.incoming_attack_wave_time = wave_time;
        session.incoming_attack_wave_pending = false;

        if(!session.has_deployed) {
            session.has_deployed = true;
            session.deploy_time = server_time;
            APMCounter.reset();

            change_selection(null);

            // recall persisted playfield speed setting for battles only
            update_player_combat_time_scale(get_preference_setting(player.preferences, 'playfield_speed'));

            if(player.tutorial_state === 'ai_attack_begin') {
                metric_event('0260_tutorial_ai_attack_start', {});
                advance_tutorial();
            }

            init_desktop_dialogs();
            init_combat_item_bar();
            init_playfield_speed_bar();

            // use "recon" music if "combat" music not available
            change_backdrop_music(/** @type {!GameArt.Sprite} */ (GameArt.assets['background_music'].states[(GameArt.assets['background_music'].has_state('combat') ? 'combat' : 'recon')]).audio);
        }

        if(replay_token && !session.is_recording()) {
            session.start_recording(replay_token, client_time + (finish_time - server_time) + 5); // approximate battle end client_time, plus some fudge
        }
    } else if(msg == "PLAYER_ATTACK_WAVE_DEPLOYED") {
        var finish_time = data[1];
        var replay_token = data[2];

        session.has_attacked = true;
        session.set_attack_finish_time(finish_time);
        if(!session.has_deployed) {
            session.has_deployed = true;
            session.deploy_time = server_time;
            APMCounter.reset();

            if(session.viewing_base.deployment_allowed) {
                init_combat_item_bar();
            }

            if(GameArt.assets['background_music'].has_state('combat')) {
                // if no "combat" music is available, stick with "recon"
                change_backdrop_music(/** @type {!GameArt.Sprite} */ (GameArt.assets['background_music'].states['combat']).audio);
            }
        }

        if(replay_token && !session.is_recording()) {
            session.start_recording(replay_token, client_time + (finish_time - server_time) + 5); // approximate battle end client_time, plus some fudge
        }
    } else if(msg == "NOTIFICATION") {
        var message = data[1]; // SPHTTP.unwrap_string(data[1]);
        var format = ('format' in message ? message['format'] : 'game');
        if(format === 'bh' && spin_frame_platform === 'bh') {
            // use BHSDK format
            BHSDK.bh_popup_message({'ui_subject': message['ui_subject'] || null,
                                    'ui_body': message['ui_body']});
        } else {
            user_log.msg(message['ui_body'], new SPUI.Color(1,1,0,1));
        }
    } else if(msg == "CHAT_RECV") {
        var channel_name = data[1];
        var sender_info = data[2];
        var wrapped_body = data[3] || '';
        var chat_msg_id = data[4];
        var is_prepend = data[5];

        if(!global_chat_frame) { return; }
        chat_frame_accept_message(global_chat_frame, channel_name, sender_info, wrapped_body, chat_msg_id, is_prepend);
    } else if(msg == "CHAT_GETMORE_RESULT") {
        var request_tag = data[1], response = data[2], is_final = data[3];
        chat_getmore_receiver.dispatchEvent({type: request_tag, response: response, is_final: is_final});
    } else if(msg == "DONATE_UNITS_RESULT") {
        var success = data[1], error_reason = data[2];
        var dialog = find_dialog('unit_donation_dialog');
        if(dialog) { dialog.user_data['pending'] = false; }
        if(success) {
            GameArt.play_canned_sound('success_playful_22');;
            if(dialog) { close_parent_dialog(dialog.widgets['close_button']); }
        } else {
            var error = gamedata['errors'][error_reason];
            if(error) {
                invoke_child_message_dialog(gamedata['dialogs']['unit_donation_dialog']['ui_error_title'], error['ui_name'], {'dialog':'message_dialog_big'});
            }
        }
    } else if(msg == "GIVE_ALLIANCE_HELP_RESULT") {
        var success = data[1], error_reason = data[2];
        var dialog = find_dialog('alliance_help_dialog');
        if(dialog) { dialog.user_data['pending'] = false; }
        if(success) {
            GameArt.play_canned_sound('success_playful_22');;
            if(dialog) { close_parent_dialog(dialog.widgets['close_button']); }
        } else {
            var error = gamedata['errors'][error_reason];
            if(error) {
                invoke_child_message_dialog(error['ui_title'], error['ui_name'], {'dialog':'message_dialog_big'});
            }
        }
    } else if(msg == "LOTTERY_GET_SLATE_RESULT") {
        var slate = data[1];
        for(var i = 0; i < lottery_slate_receivers.length; i++) {
            lottery_slate_receivers[i](slate);
        }
        lottery_slate_receivers = [];
    } else if(msg == "LOTTERY_SCAN_RESULT") {
        var obj_id = data[1];
        var which_slot = data[2];
        var loot = data[3];

        var handle_it = (function (_world, _obj_id, _which_slot, _loot) { return function() {
            // clear idle state cache
            var obj = _world.objects._get_object(_obj_id);
            if(obj && obj.is_building()) {
                obj.idle_state_cache = null;
            }

            player.session_lottery_loot = player.session_lottery_loot.concat(_loot);

            if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'lottery_dialog') {
                lottery_dialog_scan_result(selection.ui, _which_slot, _loot);
            }
        }; })(world, obj_id, which_slot, loot);

        var delay = 0;
        if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'lottery_dialog') {
            delay = Math.max(0, selection.ui.data['widgets']['lottery_button']['min_wait'] - (client_time - selection.ui.user_data['scan_pending']));
        }
        if(delay >= 0) {
            window.setTimeout(handle_it, 1000*delay);
        } else {
            handle_it();
        }

    } else if(msg == "NEW_BATTLE_HISTORIES") {
        player.new_battle_histories = data[1];
    } else if(msg == "QUERY_RECENT_ATTACKERS_RESULT" || msg == "QUERY_SCOUT_REPORTS_RESULT") {
        var tag = data[1], result = data[2], pcache_data = data[3];
        if(pcache_data) { PlayerCache.update_batch(pcache_data); }
        battle_history_receiver.dispatchEvent({type: tag, result: result, signatures: null, is_final: true, is_error: false});
    } else if(msg == "QUERY_BATTLE_HISTORY_RESULT") {
        var tag = data[1], result = data[2], signatures = data[3], pcache_data = data[4], is_final = data[5], is_error = data[6];
        if(pcache_data) { PlayerCache.update_batch(pcache_data); }
        battle_history_receiver.dispatchEvent({type: tag, result: result, signatures: signatures, is_final: is_final, is_error: is_error});
    } else if(msg == "QUERY_MAP_LOG_RESULT") {
        var tag = data[1], result = data[2];
        map_log_receiver.dispatchEvent({type: tag, result:result});
    } else if(msg == "QUERY_PLAYER_ALLIANCE_MEMBERSHIP_HISTORY_RESULT") {
        var tag = data[1], result = data[2], alinfo_list = data[3], plinfo_list = data[4];
        if(alinfo_list) {
            goog.array.forEach(alinfo_list, function(alinfo) {
                if(alinfo) {
                    // note: ID field is returned as 'id' not 'alliance_id'!
                    AllianceCache.update(alinfo['id'], alinfo);
                }
            });
        }
        if(plinfo_list) { PlayerCache.update_batch(plinfo_list); }
        player_alliance_membership_history_receiver.dispatchEvent({type: tag, result:result});
    } else if(msg == "GET_BATTLE_LOG3_RESULT" || msg == "GET_BATTLE_REPLAY_RESULT") {
        var tag = data[1], result = data[2];
        if(tag in battle_log_receivers) {
            var cb = battle_log_receivers[tag];
            delete battle_log_receivers[tag];
            cb(data[2]);
        }
    } else if(msg == "QUERY_ACHIEVEMENTS_RESULT") {
        var tag = data[1], result = data[2];
        if(tag in achievements_receivers) {
            var cb = achievements_receivers[tag];
            delete achievements_receivers[tag];
            cb(result);
        }
    } else if(msg == "QUERY_PLAYER_CACHE_RESULT") {
        var result = data[1], tag = data[2];
        PlayerCache.receive_result(tag, result);
    } else if(msg == "SEARCH_PLAYER_CACHE_RESULT") {
        var result = data[1], pcache_data = data[2], tag = data[3];
        PlayerCache.update_batch(pcache_data);
        if(tag in search_player_cache_receivers) {
            var cb = search_player_cache_receivers[tag];
            delete search_player_cache_receivers[tag];
            cb(result);
        }
    } else if(msg == "QUERY_ALLIANCE_LIST_RESULT") {
        var result = data[1], tag = data[2];
        AllianceCache.receive_list_result(tag, result);
    } else if(msg == "QUERY_ALLIANCE_SCORE_LEADERS_RESULT") {
        var field = data[1], period = data[2], result = data[3], tag = data[4];
        AllianceCache.receive_list_result(tag, result);
    } else if(msg == "QUERY_ALLIANCE_INFO_RESULT") {
        var alliance_ids = data[1], result = data[2], tag = data[3];
        AllianceCache.receive_info_result(alliance_ids, tag, result);
    } else if(msg == "QUERY_ALLIANCE_MEMBERS_RESULT") {
        var alliance_id = data[1], result = data[2], pcache_data = data[3], invite_status = data[4], tag = data[5];
        // stick pcache_data into PlayerCache
        PlayerCache.update_batch(pcache_data);
        AllianceCache.receive_members(alliance_id, tag, result, invite_status);
    } else if(msg == "QUERY_PLAYER_SCORES2_RESULT") {
        var user_id_list = data[1], result = data[2], tag = data[3], info = data[4] || null;
        if(tag in player_scores_receivers) {
            var cb = player_scores_receivers[tag];
            delete player_scores_receivers[tag];
            cb(user_id_list, result, info);
        }
    } else if(msg == "QUERY_SCORE_LEADERS2_RESULT") {
        var tag = data[4];
        if(tag in score_leaders_receivers) {
            var cb = score_leaders_receivers[tag];
            delete score_leaders_receivers[tag];
            cb(data[1], data[2], data[3]);
        }
    } else if(msg == "QUERY_RIVALS_RESULT") {
        var tag = data[1];
        if(tag in rivals_receivers) {
            var cb = rivals_receivers[tag];
            delete rivals_receivers[tag];
            last_rivals_query_time = client_time;
            cb();
        }
    } else if(msg == "REGION_POP_QUERY_RESULT") {
        var tag = data[1], pops = data[2];
        if(tag in region_pop_receivers) {
            var cb = region_pop_receivers[tag];
            delete region_pop_receivers[tag];
            cb(pops);
        }
    } else if(msg == "QUARRY_QUERY_RESULT") {
        var tag = data[1];
        var region_id = data[2];
        var db_time = data[3];
        var codec = data[4];
        var z_result = data[5];
        var last_db_time = data[6];

        // note: in "raw" mode, the result is already a parsed JSON structure
        var result = (codec === 'raw' ? z_result : JSON.parse(unwrap_and_uncompress_string(codec, z_result)));

        last_quarry_query_time = client_time;

        if(session.region.data && session.region.data['id'] == region_id) {
            session.region.receive_update(db_time, result, last_db_time);
        }

        if(tag && (tag in quarry_receivers)) {
            var cb = quarry_receivers[tag];
            delete quarry_receivers[tag];
            cb(db_time, result, last_db_time);
        }

    } else if(msg == "REGION_TURF_UPDATE") {
        var region_id = data[1], updates = data[2];
        AllianceCache.turf_update(region_id, updates);
    } else if(msg == "REGION_MAP_UPDATES") {
        var region_id = data[1], updates = data[2], map_time = data[3];
        if(session.region.data && session.region.data['id'] == region_id) {
            goog.array.forEach(updates, function(update) { session.region.receive_feature_update(update); });
        } else {
            // ignore updates if we're not on a map
            console.log('ignoring spurious REGION_MAP_UPDATES'); console.log(data[1]);
        }
    } else if(msg == "REGION_MAP_ATTACK_START" || msg == "REGION_MAP_ATTACK_COMPLETE" || msg == "REGION_MAP_ATTACK_DIVERT" || msg == "REGION_MAP_ATTACK_BUMP") {
        var region_id = data[1], feature = data[2], attacker_id = data[3], defender_id = data[4], summary = data[5], pcache_data = data[6], map_time = data[7];

        if(session.region.data && session.region.data['id'] == region_id) {
            if(feature && ('base_map_loc' in feature)) { // note: exclude features where all we know is the lock state (regional map isn't loaded)
                PlayerCache.update_batch(pcache_data);

                var myrole = (session.user_id == defender_id ? 'defender' : (session.user_id == attacker_id ? 'attacker' : null));
                if(true) {
                    var what_happened;
                    if(msg == "REGION_MAP_ATTACK_DIVERT") {
                        what_happened = 'was_diverted';
                    } else if(msg == "REGION_MAP_ATTACK_BUMP") {
                        what_happened = 'was_bumped';
                    } else if(msg == "REGION_MAP_ATTACK_COMPLETE") {
                        if(summary['battle_type'] === 'raid') {
                            if(summary['raid_mode'] === 'scout') {
                                what_happened = 'was_scouted_' + summary['defender_outcome'];
                            } else {
                                what_happened = 'was_raided_' + summary['defender_outcome'];
                            }
                        } else {
                            what_happened = 'was_attacked_' + summary['defender_outcome'];
                        }
                    } else {
                        what_happened = 'is_under_attack';
                    }

                    // text message - for attacker and defender only
                    var str = null;
                    if(myrole) {
                        var ui_names = { 'attacker': null, 'defender': null };
                        var ui_names_pos = { 'attacker': null, 'defender': null };
                        goog.array.forEach([['attacker', attacker_id], ['defender', defender_id]], function (key_id) {
                            var key = key_id[0], id = key_id[1];
                            if(id == session.user_id) {
                                ui_names[key] = gamedata['strings']['regional_map']['msg_you'];
                                ui_names_pos[key] = gamedata['strings']['regional_map']['msg_you_pos'];
                            } else {
                                //var info = PlayerCache.query_sync(id); // can return null if an in-flight query already set 'pending' on the entry
                                var info = goog.array.find(pcache_data, function(entry) { return entry['user_id'] == id; });
                                if(!info) { throw Error('no info with '+msg+', id '+id.toString()+' pcache_data '+JSON.stringify(pcache_data)); }
                                ui_names[key] = PlayerCache.get_ui_name(info) + ' (L'+ info['player_level'].toString()+')';
                                ui_names_pos[key] = gamedata['strings']['regional_map']['msg_make_possessive'].replace('%s', ui_names[key]);
                            }
                        });

                        var str_key = 'msg_'+feature['base_type']+'_'+what_happened;
                        str = gamedata['strings']['regional_map'][str_key];

                        if(str) {
                            var base_ui_name = '';

                            if(feature['base_type'] == 'squad') {
                                var squad_id = parseInt(feature['base_id'].split('_')[1],10);
                                if(session.user_id == defender_id && squad_id.toString() in player.squads) {
                                    base_ui_name = player.squads[squad_id.toString()]['ui_name'];
                                } else {
                                    base_ui_name = '#'+squad_id.toString();
                                }
                            } else if(feature['base_type'] == 'quarry') {
                                base_ui_name = feature['base_ui_name'] || gamedata['strings']['regional_map']['unknown_name'];
                            }

                            str = str.replace('%x',x).replace('%y',y).replace('%basename',base_ui_name).replace('%attacker_pos',ui_names_pos['attacker']).replace('%attacker',ui_names['attacker']).replace('%defender_pos',ui_names_pos['defender']).replace('%defender',ui_names['defender']);
                            // capitalize first letter
                            str = str[0].toUpperCase() + str.substr(1);

                            // show message if you aren't looking at the base, of if you got raided
                            if(session.viewing_base.base_id != feature['base_id'] || (summary && summary['battle_type'] === 'raid')) {
                                user_log.msg(str, new SPUI.Color(1,1,0,1));
                            }
                        }
                    }

                    // update repeater on the map - even if you were not involved in the battle
                    if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'region_map_dialog') {
                        var dialog = selection.ui;
                        if(str) {
                            var onclick = (function (_dialog, _feature) { return function() {
                                _dialog.widgets['map'].pan_to_cell(_feature['base_map_loc'], {slowly:true});
                                _dialog.widgets['map'].zoom_all_the_way_in();
                            }; })(dialog, feature);
                            region_map_display_notification(dialog, '[color=#ff0000]'+str+'[/color]', {onclick: onclick});
                        }
                        // show explosion effect even if you were not involved in the battle
                        if(msg == "REGION_MAP_ATTACK_COMPLETE") {
                            dialog.widgets['map'].trigger_spfx_at(gamedata['client']['vfx']['region_map_battle_complete'], feature['base_map_loc']);
                        }
                    }
                }
            }
        }
    } else if(msg == "BASE_LOCK_STATE_UPDATE") {
        var base_id = data[1];
        var lock_state = data[2];
        if(base_id != session.viewing_base.base_id) { return; }
        var old_state = session.viewing_lock_state;
        session.viewing_lock_state = lock_state;

        // send lock state update into the player cache
        if(!session.home_base && !session.viewing_ai && (session.viewing_base.base_id == session.viewing_player_home_base_id)) {
            PlayerCache.update_lock_state(session.viewing_user_id, session.viewing_lock_state);
        }

        if(old_state == 0 && lock_state != old_state && !session.home_base && !session.has_attacked &&
           (lock_state == 2)) {
            // kick player out of base or quarry if it is attacked
            visit_base_home();
            notification_queue.push((function (_base) { return function() {
                var err = gamedata['errors'][(_base.base_type == 'quarry' ? "QUARRY_LOCK_TAKEN" : "OPPONENT_LOCK_TAKEN")];
                invoke_message_dialog(err['ui_title'], err['ui_name'].replace('%d', _base.base_ui_name));
            }; })(session.viewing_base));
        } else if(old_state != 0 && lock_state == 0 && !session.home_base && !session.has_attacked) {
            // opponent is now attackable, but reload because we have an old generation of his base
            if(session.is_remote_base()) {
                do_visit_base(-1, {base_id: session.viewing_base.base_id, force:true, short_loading_timeout: true});
            } else {
                do_visit_base(session.viewing_user_id, {force:true, short_loading_timeout: true});
            }
        }

    } else if(msg == "PING_BASE_DAMAGE_RESULT") {
        var base_id = data[1], base_damage = data[2], damage_flags = data[3];
        if(base_id != session.viewing_base.base_id || base_damage < 0 || damage_flags === null) { return; }
        var bars = desktop_dialogs['combat_damage_bar'];
        if(!bars) { return; }
        bars.user_data['base_damage_ping_recv_time'] = client_time;
        bars.user_data['base_damage_server'] = base_damage;
        bars.user_data['base_damage_server_flags'] = damage_flags;
    } else if(msg == "MANUFACTURE_OVERFLOW_TO_RESERVES") {
        if(!session.manufacture_overflow_warned && session.home_base && !session.has_attacked &&
           !(player.quest_tracked && player.quest_tracked['tips'])) {
            session.manufacture_overflow_warned = true;
            notification_queue.push(function() { invoke_ingame_tip('manufacture_overflow_to_reserves_tip', {frequency: GameTipFrequency.ALWAYS_UNLESS_IGNORED}); });
        }
    } else if(msg == "GAMEBUCKS_ORDER_ACK" || msg == "ITEM_ORDER_ACK" || msg == "FUNGIBLE_ORDER_ACK" || msg == "SCORE_ORDER_ACK" ||
              msg == "FBCREDITS_ORDER_ACK" || msg == "KGCREDITS_ORDER_ACK" || msg == "FBPAYMENT_ORDER_ACK") {
        var tag = data[1], success = data[2];
        Store.order_receiver.dispatchEvent({type: tag, success: success});
    } else if(msg == "XSOLLA_GET_TOKEN_RESULT") {
        var tag = data[1], token = data[2];
        if(tag in Store.xsolla_token_receivers) {
            var cb = Store.xsolla_token_receivers[tag];
            delete Store.xsolla_token_receivers[tag];
            cb(token);
        }
    } else if(msg == "UNIT_REPAIR_UPDATE") {
        receive_unit_repair_update(data[1]);
    } else if(msg == "SERVER_MAINTENANCE_WARNING") {
        var s = gamedata['strings']['server_going_down_short'];
        invoke_child_message_dialog(s['ui_title'], s['ui_description'], {'dialog': s['dialog']});
    } else if(msg == "RECONNECT_COMPLETE") {
        // wait until the server responds to record 0623_client_reconnected
        // (the session might have gone invalid)
        var props = add_demographics({'user_id':spin_user_id,
                                      'method':(the_websocket ? the_websocket.last_close_ui_method : 'no websocket'),
                                      'len':(the_websocket ? the_websocket.retry_count : -1),
                                      'since_connect': (session.connected() ? client_time - session.connect_time : -1),
                                      'since_pageload': client_time - spin_pageload_begin,
                                      'connection': gameapi_connection_method()
                                     });
        SPLWMetrics.send_event(spin_metrics_anon_id, '0623_client_reconnected', props);
    } else if(msg == "IDLE_CHECK") {
        invoke_idle_check_dialog(data[1]);
    } else if(msg == "UNSUPPORTED_BROWSER_REDIRECT") {
        do_unsupported_browser_redirect(data.length > 1 ? data[1] : null);
    } else if(msg == "ACCOUNT_BANNED") {
        do_account_banned_redirect();
    } else if(msg == "PUSH_PREFERENCES") {
        player.preferences = data[1] || {};
    } else if(msg == "PUSH_GAMEDATA") {
        var new_gamedata_str = data[1];
        var new_abtests = data[2];

        var new_gamedata = /** @type {Object.<string,?>} */ (JSON.parse(new_gamedata_str)); // eval('('+new_gamedata_str+')');
        /*
        console.log('HERE 0');
        console.log(new_gamedata);
        console.log('HERE 1 '+new_gamedata['spells']['MOTION_CANNON_SHOOT']['damage']);
        */
        gamedata = new_gamedata;
        /*
        console.log('HERE 2 '+gamedata['spells']['MOTION_CANNON_SHOOT']['damage']);
        */
        player.init_abtests(new_abtests);
        reset_specs();
    } else if(msg == "CLIENT_EVAL") {
        var str = data[1];
        var result = eval(str);
        send_to_server.func(["CLIENT_EVAL_RESULT", str, result]);
    } else if(msg == "SPROBE_RUN") {
        sprobe_run();
    } else if(msg == "SERVER_SYNC") {
        synchronizer.receive_sync(data[1]);
    } else if(msg == "CLIENT_TRACKING_PIXEL") {
        var str = data[1], tag = data[2];
        if(player.is_developer()) { console.log("CLIENT_TRACKING_PIXEL "+str); }
        var result = eval(str);
        if(typeof result == 'undefined') { result = null; }
        send_to_server.func(["CLIENT_TRACKING_PIXEL_RESULT", tag, result]);
    } else if(msg == "CLIENT_TRACKING_PIXEL_IMAGE") {
        var str = data[1], tag = data[2];
        if(player.is_developer()) { console.log("CLIENT_TRACKING_PIXEL_IMAGE "+str); }
        var img = new Image();
        if(str.indexOf('http') !== 0) {
            str = 'https://'+str; // default to HTTPS
        }
        img.src = str;
        result = true;
        send_to_server.func(["CLIENT_TRACKING_PIXEL_IMAGE_RESULT", tag, result]);
    } else if(msg == "CLIENT_TRACKING_PIXEL_BH") {
        var msg_data = data[1], tag = data[2];
        var success = false;
        if(spin_frame_platform === 'bh') {
            window.top.postMessage({'method': 'bh_metric_event_clientside', 'event_name': msg_data['event_name']}, '*');
            success = true;
        }
        send_to_server.func(["CLIENT_TRACKING_PIXEL_BH_RESULT", tag, success]);
    } else if(msg == "FORCE_RELOAD") {
        invoke_login_error_message("CANNOT_LOG_IN_VERSION_MISMATCH_GAMEDATA");
    } else if(msg == "LOGIN_ABUSE_WARNING") {
        var actual = data[1], limit = data[2], range = data[3];

        notification_queue.push_with_priority((function (_msg, _actual, _limit, _range) { return function() {
            var msg = gamedata['errors'][_msg];
            invoke_message_dialog(msg['ui_title'],
                                  msg['ui_name'].replace('%ACTUAL', (actual/3600.0).toFixed(0)).replace('%LIMIT', (limit/3600.0).toFixed(0)).replace('%RANGE', (range/3600.0).toFixed(0)).replace('%RANGE', (range/3600.0).toFixed(0)),
                                  {'dialog': msg['dialog']});
        }; })(msg, actual, limit, range), 99);
    } else if(msg == "LOAD_AI_BASE_RESULT" || msg == "SAVE_AI_BASE_RESULT" || msg == "PUBLISH_AI_BASE_RESULT") {
        var success = data[1], error_kind = data[2], info = data[3];
        var dlg = null;
        if(success) {
            if(msg == "LOAD_AI_BASE_RESULT") {
                // temporarily turn this off for the benchmark feature, later find a way to re-enable it selectively
                //dlg = gamedata['strings']['load_ai_base_success'];
            } else if(msg == "SAVE_AI_BASE_RESULT") {
                dlg = gamedata['strings']['save_ai_base_success'];
            } else if(msg == "PUBLISH_AI_BASE_RESULT") {
                dlg = gamedata['strings']['publish_ai_base_success'];
            }
            if(msg != "LOAD_AI_BASE_RESULT") { // LOAD_AI_BASE causes a session change on success
                cancel_loading_base_timer(); visit_base_pending = false; change_selection(null);
            }
        } else {
            cancel_loading_base_timer(); visit_base_pending = false; change_selection(null);
            dlg = gamedata['errors'][error_kind];
        }
        if(dlg) {
            invoke_message_dialog(dlg['ui_title'], (dlg['ui_description'] || dlg['ui_name']).replace('%s', info), {'dialog':(dlg['dialog'] || 'message_dialog_big')});
        }
    } else if(msg == "OFFER_PAYER_PROMO") {
        var currency_url = data[1];

        // note: offer_payer_promo() must be triggered from a
        // mouse-click event in order to avoid being suppressed by
        // pop-up blockers, since FB.ui({'method':'fbpromotion})
        // requires an old-fashioned popup window instead of the
        // iframe-compatible div popup.

        var after_promo_cb = function() { send_to_server.func(["PING_CREDITS"]); send_to_server.func(["PING_PLAYER"]); };
        var make_offer_func = (function (_url, _cb) { return function() {
            SPay.offer_payer_promo(_url, _cb);
        }; })(currency_url, after_promo_cb);

        var launch_offer_dialog = (function (_make_offer) { return function() {
            invoke_child_message_dialog(gamedata['dialogs']['message_dialog_payer_promo']['widgets']['title']['ui_name'],
                                        gamedata['dialogs']['message_dialog_payer_promo']['widgets']['description']['ui_name'].replace('%GAMEBUCKS',Store.gamebucks_ui_name()),
                                        {'dialog':'message_dialog_payer_promo',
                                         'close_button': 0,
                                         'ok_button_ui_name': 'View Offer',
                                         'on_ok': _make_offer});
        }; })(make_offer_func);

        notification_queue.push(launch_offer_dialog);
    } else if(msg == "INVOKE_FACEBOOK_AUTH") {
        var scope = data[1];
        var ui_title = data[2];
        var ui_description = data[3];

        if(spin_frame_platform != 'fb') { return; }

        if(player.has_facebook_permissions(scope)) {
            // already have all the requested permissions
            send_to_server.func(["INVOKE_FACEBOOK_AUTH_RESPONSE", scope, player.facebook_permissions.join(','), true]);
            return;
        }

        var launch_auth_window = (function (_scope) { return function() { invoke_facebook_permissions_dialog(_scope); }; })(scope);

        var launch_ingame_dialog = (function (_launch_auth_window) { return function() {
            invoke_child_message_dialog(ui_title, ui_description,
                                        {//'dialog':'message_dialog_big',
                                         'close_button': 0,
                                         'ok_button_ui_name': 'Proceed',
                                         'on_ok': _launch_auth_window});
        }; })(launch_auth_window);

        notification_queue.push(launch_ingame_dialog);

    } else if(msg == "UNIT_MANUFACTURED") {
        // data is of the form ["UNIT_MANUFACTURED", manufacturer_id, [unit_id0, unit_id1, ...]]
        var manufacturer_id = data[1];

        if(manufacturer_id && world.objects.has_object(manufacturer_id) && ('unit_manufactured' in gamedata['client']['vfx'])) {
            var effect = gamedata['client']['vfx']['unit_manufactured'];
            var manufacturer = world.objects.get_object(manufacturer_id);

            if(effect['type'] === 'phantom_unit') {
                // pick a random squad building to walk to
                var squad_buildings = find_all_objects_by_type(gamedata['squad_building']);
                var squad_building = squad_buildings[Math.floor(Math.random() * squad_buildings.length)];

                // prepare to calculate a path between the buildings (only done if a unit actually needs it)
                var start_pos = vec_add(manufacturer.raw_pos(), vec_scale(0.5, manufacturer.spec['gridsize']));
                var end_pos = vec_add(squad_building.raw_pos(), vec_scale(0.5, squad_building.spec['gridsize']));
                var path, path_tried = false; // note: path is undefined until path_tried is set the first time

                for(var i = 0; i < data[2].length; i++) {
                    var unit = player.my_army[data[2][i]];
                    var spec = gamedata['units'][unit['spec']];

                    // add a slight delay of 1 tick per unit so that multiple units don't stack up
                    var delay = TICK_INTERVAL * i;

                    if(spec['noclip'] || spec['flying']) {
                        world.fxworld.add_visual_effect_at_time(start_pos, spec['flying'] ? spec['altitude'] : 0, [1, 0, 1], client_time,
                                gamedata['client']['vfx']['unit_manufactured'], true,
                                {'spec': unit['spec'], 'level': unit['level'], 'path': [start_pos, end_pos], 'start_halted': delay});
                    } else {
                        // calculate the path if it hasn't already been done
                        // note: this does not interact with world.tick_astar_queries_left, it always runs the query unconditionally.
                        if(!path_tried) {
                            path_tried = true;
                            path = world.astar_context.search(start_pos, end_pos);
                            if(path && path.length > 0) {
                                path = world.astar_map.smooth_path(path);
                            }
                        }

                        if(path && path.length > 0) {
                            // only show phantoms for ground units if we have at least a partial path to the squad building
                            world.fxworld.add_visual_effect_at_time(start_pos, spec['flying'] ? spec['altitude'] : 0, [1, 0, 1], client_time,
                                    gamedata['client']['vfx']['unit_manufactured'], true,
                                    {'spec': unit['spec'], 'level': unit['level'], 'path': path.slice(0), 'start_halted': delay});
                        }
                    }
                }
            } else {
                world.fxworld.add_visual_effect_at_time(manufacturer.raw_pos(), 0, [0, 1, 0], client_time, gamedata['client']['vfx']['unit_manufactured'], true, null);
            }
        }
    } else if(msg == "FB_INVITABLE_FRIENDS_RESULT") {
        var request_tag = data[1], response = data[2];
        FBInviteFriends.invitable_friends_receiver.dispatchEvent({type: request_tag, response: response});
    } else if(msg == "ERROR") {
        data.shift();
        var name = data.shift();

        if(!(name in gamedata['errors'])) {
            throw Error('error info not found in gamedata: '+name);
        }

        var display_title = gamedata['errors'][name]['ui_title'] || null;
        var display_string = gamedata['errors'][name]['ui_name'];
        var display_button = gamedata['errors'][name]['ui_button'] || null;
        var argument = null;

        if(data.length > 0) {
            argument = data.shift();
            display_string = display_string.replace('%d', argument.toString());
        }

        // XXX hack - make sure GameArt is set up to be able to display errors pre-login
        if(!GameArt.initialized) {
            GameArt.init(client_time, canvas, ctx, gamedata['art'], gameart_onload, null, true, true, false);
        }

        if(name.indexOf("CANNOT_LOG_IN_") == 0) {
            client_state = client_states.UNABLE_TO_LOGIN;
            invoke_login_error_message(name);
        } else if(name == "UNKNOWN_SESSION") {
            // non-reportable error, because it can happen right after an idle kick
            invoke_timeout_message('0601_client_died_from_unknown_session', {}, {'ui_title': display_title, 'ui_description': display_string.replace('%d', '601'), 'ui_button': display_button, 'dialog': gamedata['errors'][name]['dialog'] || null});
        } else if(name == "KILL_SESSION") {
            // non-reportable, since it's usually caused by the player logging in simultaneously
            invoke_timeout_message('0602_client_died_from_killed_session', {}, {'ui_title': display_title, 'ui_description': display_string.replace('%d', '602'), 'ui_button': display_button, 'dialog': gamedata['errors'][name]['dialog'] || null});
        } else if(name == "IDLE_KICK") {
            invoke_timeout_message('0600_client_idle_timeout', {}, {});
        } else if(name == "MAINT_KICK") {
            invoke_timeout_message('0611_client_died_from_maint_kick', {}, {'ui_title': display_title, 'ui_description': display_string, 'ui_button': display_button});
        } else if(name == "SERVER_EXCEPTION") {
            invoke_timeout_message('0610_client_died_from_server_exception', {}, {});
        } else if(name == "SERVER_PROTOCOL") {
            invoke_timeout_message('0609_client_died_from_protocol_error', {}, {});
        } else if(name == "TOO_LAGGED_UPSTREAM") {
            invoke_timeout_message('0622_client_died_from_upstream_lag', {'method': 'server'}, {});
        } else if(name == "TOO_LAGGED_DOWNSTREAM") {
            invoke_timeout_message('0621_client_died_from_downstream_lag', {'method': 'server'}, {});
        } else if(name == "POWER_LIMIT") {
            var s = gamedata['strings']['requirements_help']['power']['unknown'];
            invoke_message_dialog(s['ui_title'], s['ui_description']);
        } else if(name == "UNIT_SPACE_LIMIT") {
            var helper = get_requirements_help('unit_space', null); if(helper) { helper(); }
        } else if(name == "INVENTORY_LIMIT") {
            var helper = get_requirements_help('inventory_space_need', null); if(helper) { helper(); }
        } else if(name == "EQUIP_INVALID_LIMITED" || name == "EQUIP_INVALID_UNIQUE") {
            display_string = display_string.replace('%s', ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(argument)));
            invoke_child_message_dialog(display_title, display_string, {'dialog': 'message_dialog_big'});
        } else if(name == "PLAYER_AURA_LIMIT") {
            var helper = get_requirements_help('player_aura_limit', null); if(helper) { helper(); }
        } else if(name == "FOREMAN_IS_BUSY" && player.foreman_is_busy()) {
            var helper = get_requirements_help('foreman', null);
            if(helper) {
                change_selection_ui(null);
                helper();
                return;
            } else {
                var busy_obj = player.foreman_get_tasks()[0]; // this just prompts to speed up one possible building
                change_selection(busy_obj);
                invoke_speedup_dialog('busy');
            }
        } else if(name == "LAB_IS_BUSY") {
            var busy_obj = world.objects._get_object(argument);
            if(busy_obj) {
                change_selection(busy_obj);
                invoke_speedup_dialog('research');
            }
        } else if(name == "WORKSHOP_IS_BUSY") {
            var busy_obj = world.objects._get_object(argument);
            if(busy_obj) {
                change_selection(busy_obj);
                invoke_speedup_dialog('crafting');
            }
        } else if(name == "INVALID_MAP_LOCATION" || name == "CANNOT_ALTER_SQUAD_WHILE_UNDER_ATTACK" ||
                  name == "SQUAD_RACE_CONDITION" || name == "CANNOT_MOVE_SQUAD_ON_COOLDOWN" ||
                  name.indexOf("CANNOT_DEPLOY_SQUAD") == 0 ||
                  name.indexOf("CANNOT_DEPLOY_RAID") == 0) {
            // stop whatever AI action the squad was trying to do
            if(argument && (argument.toString() in player.squads)) {
                var squad = player.squads[argument.toString()];
                player.squad_clear_client_data(argument); // unblock UI and erase orders
                invoke_squad_error(display_title, display_string.replace('%BATNAME', squad['ui_name']));
            }
        } else if(name.indexOf("CANNOT_CHANGE_REGION") == 0) {
            if(change_region_pending == 'paid') {
                display_string += gamedata['errors'][name]['ui_name_paid'].replace('%GAMEBUCKS', Store.gamebucks_ui_name());
            }
            invoke_child_message_dialog(display_title, display_string, {'dialog':'message_dialog_big'});
            change_region_pending = false;
        } else if(name.indexOf("CANNOT_SPY") == 0 ||
                  name == "CANNOT_LOCK_QUARRY" ||
                  name == "CANNOT_ATTACK_BASE_WHILE_ALREADY_UNDER_ATTACK" ||
                  name == "CANNOT_ATTACK_THEIR_SQUAD_MOVED" ||
                  name == "CANNOT_ATTACK_THEIR_SQUAD_OFFENSE" ||
                  name == "CANNOT_ATTACK_THEIR_SQUAD_DEFENSE" ||
                  name == "CANNOT_ATTACK_YOUR_SQUAD_RACE" ||
                  name == "CANNOT_ATTACK_YOUR_SQUAD_LOCKING_ISSUE" ||
                  name == "LADDER_MATCH_FAILED") {

            cancel_loading_base_timer();
            visit_base_pending = false;

            var cb = (function (_title, _str) { return function() {
                invoke_squad_error(_title, _str);
            }; })(display_title, display_string);

            change_selection(null);
            notification_queue.push(cb);

            if(name !== "LADDER_MATCH_FAILED") {
                if(!session.home_base) {
                    // note: Might not want to visit_base_home() unconditionally when name.indexOf("CANNOT_SPY") == 0,
                    // since you might just want to stay where you are
                    visit_base_home();
                } else if(session.last_map_dialog_state) {
                    // make sure region map is up and pointing to last location
                    var state = session.last_map_dialog_state;
                    // don't clear state, since this might be followed immediately by a session change
                    //session.last_map_dialog_state = null;
                    var dialog = invoke_region_map();
                    if(dialog) { dialog.widgets['map'].set_state(state); }
                }
            }

        } else if(name == "CANNOT_CALL_INVALID_AI_ATTACK") {
            var s = gamedata['errors'][name];
            invoke_message_dialog(s['ui_title'], s['ui_name']);
        } else if(name == "INSUFFICIENT_GAMEBUCKS") {
            var deficit = argument, client_price = data[0], unit_id = data[1], spellname = data[2], spellarg = data[3];
            var cb = (function (_deficit) { return function() {
                invoke_insufficient_alloy_message('server_initiated', _deficit,
                                                  {'price':client_price, 'unit_id':unit_id, 'spellname':spellname, 'spellarg':spellarg});
            }; })(deficit);
            notification_queue.push(cb);
        } else if(name == "INSUFFICIENT_RESOURCES_TO_REPAIR") {
            invoke_insufficient_resources_for_repair_message(argument || {}, data[0] || null);
        } else if(name.indexOf("CANNOT_CREATE_ALLIANCE")==0 || name == "ALLIANCES_OFFLINE" || name == "CANNOT_JOIN_ALLIANCE" || name == "ALIAS_BAD" || name == "ALIAS_TAKEN") {
            invoke_child_message_dialog(display_title, display_string, {'dialog': 'message_dialog_big'});
        } else if(name == "CANNOT_AUTO_RESOLVE_DEFENDER_TOO_MUCH_SPACE") {
            notification_queue.push_with_priority((function(display_title, display_string) { return function () {
                invoke_child_message_dialog(display_title, display_string, {'dialog': 'message_dialog_big'});
            }; })(display_title, display_string), 1); // display before battle-ended message
        } else {
            user_log.msg('Error: '+display_string, new SPUI.Color(1,0,0,1));
        }

    } else if(msg == "NOMESSAGE") {
    } else {
        document.write("AJAX error: "+data);
    }
}

// Ask player to refresh the browser. This is a catch-all message that
// is used not only for genuine timeouts, but also for any kind of
// "deadly" error that can only be resolved by logging in again (e.g.,
// integrity failure of the AJAX message stream).

SPINPUNCHGAME.client_death_sent = null;

/** @param {string} event_name
    @param {!Object} props
    @param {!Object} options */
function invoke_timeout_message(event_name, props, options) {
    var code = (event_name ? event_name.slice(0,4) : null);

    var s = gamedata['strings']['timeout_message'];
    var title = s['ui_title'];
    var descr = s['ui_description'];
    var button_text = s['ui_button'];

    if(code != '0600') {
        // abnormal client termination - add error code for debugging purposes
        s = gamedata['strings']['network_error'];
        title = options['ui_title'] || s['ui_title'];
        descr = options['ui_description'] || (s['ui_description'].replace('%d',code.toString()));
        button_text = ('ui_button' in options ? options['ui_button'] : s['ui_button']);

        if(code && !SPINPUNCHGAME.client_death_sent) {
            // only send the metric once, for the first "deadly" event
            SPINPUNCHGAME.client_death_sent = event_name;

            props['connection'] = gameapi_connection_method();
            props['since_connect'] = (session.connected() ? client_time - session.connect_time : session.connect_time);
            props['since_pageload'] = client_time - spin_pageload_begin;
            if(spin_user_id) { props['user_id'] = spin_user_id; }

            // note: force metric to be sent via the GIF fetch method rather than with the normal client/server stream,
            // because the normal stream may have been corrupted by this point
            SPLWMetrics.send_event(spin_metrics_anon_id, event_name, add_demographics(props));
        }
    }

    // XXX hack - make sure GameArt is set up to be able to display errors pre-login
    if(!GameArt.initialized) {
        GameArt.init(client_time, canvas, ctx, gamedata['art'], gameart_onload, null, true, true, false);
    }

    var dialog = invoke_message_dialog(title, descr, options);
    dialog.widgets['ok_button'].str = button_text;
    if(!button_text) {
        // for errors that involve server overload, do not provide a convenient "try again" button!
        dialog.widgets['ok_button'].show = dialog.widgets['close_button'].show = false;
    }

    // force a browser window refresh on click
    dialog.widgets['close_button'].onclick =
        dialog.widgets['ok_button'].onclick = (function (_options) { return function(w) {
            var dialog = w.parent;
            dialog.widgets['ok_button'].state = 'disabled';
            dialog.widgets['ok_button'].str = s['ui_button_pending'];
            dialog.widgets['close_button'].onclick =
                dialog.widgets['ok_button'].onclick = null;
            // put a timeout on the reload so that players can't spam it as easily
            window.setTimeout(reload_game, (_options['reload_delay'] || 2.0) * 1000);
        }; })(options);

    // deactivate simulation and do not send any more pings
    // if we loaded a base, then we need to go to TIMED_OUT state
    // otherwise, go to UNABLE_TO_LOGIN state
    if(client_state == client_states.LOADING) {
        client_state = client_states.UNABLE_TO_LOGIN;
    } else if(client_state != client_states.UNABLE_TO_LOGIN) {
        client_state = client_states.TIMED_OUT;
    }

    // tell websocket not to try reconnecting
    if(the_websocket) {
        the_websocket.enable_reconnect = 0;
    }

    if(!options['continue_graphics']) {
        // scale back on CPU usage after client dies
        FRAME_RATE_CAP = 1;

        // force one display refresh
        force_draw();
    }
}

function invoke_login_error_message(error_name) {
    var errdat = gamedata['errors'][error_name];
    if('redirect' in errdat) {
        // just redirect the browser
        location.href = errdat['redirect'];
        return;
    }

    invoke_timeout_message(errdat['metric_event'] || null, {'method':error_name},
                           {'uncached_reload': true,
                            'continue_graphics': true,
                            'ui_title': errdat['ui_title'] || gamedata['strings']['reload_required']['ui_title'],
                            'ui_description': errdat['ui_name'],
                            'ui_button': ('ui_button' in errdat ? errdat['ui_button'] : gamedata['strings']['reload_required']['ui_button']),
                            'dialog': errdat['dialog'] || null,
                            'reload_delay': errdat['reload_delay'] || null
                           });
}

/** store the combat damage state of all mutated objects to the server
 * @param {{buildings_only:(boolean|undefined),
 *          urgent_only:(boolean|undefined),
 *          skip_check:(boolean|undefined)}} options
 * buildings_only: only flush building damage deltas
 * skip_check: do not trigger slow integrity checks
 */
function flush_dirty_objects(options) {
    var args = [];

    // calculate HIGH_PRIORITY message time
    var flush_high_priority = false;
    if(client_time - last_high_priority_save > Math.max((gamedata['client']['combat_state_save_interval'] / 10), 1)) {
        last_high_priority_save = client_time;
        flush_high_priority = true;
    }

    session.for_each_real_object(function(obj) {
        if(obj.state_dirty != 0) {
            if(options.urgent_only && !((obj.state_dirty & obj_state_flags.URGENT) || ((obj.state_dirty & obj_state_flags.HIGH_PRIORITY) && flush_high_priority))) { return; }
            if(options.buildings_only && !obj.is_building()) { return; }
            var xy, orders = null;
            if(obj.is_mobile()) {
                // send the (quantized) client simulation position
                xy = [Math.floor(obj.pos[0]), Math.floor(obj.pos[1])];
                if((obj.state_dirty & obj_state_flags.ORDERS) && obj.orders.length > 0) {
                    orders = [];
                    for(var i = 0; i < obj.orders.length; i++) {
                        orders.push(obj.orders[i]);
                    }
                    //orders = [obj.orders[0]];
                }
            } else {
                xy = [obj.x, obj.y];
            }
            var this_arg = [obj.id,
                            obj.spec['name'],
                            xy,
                            (obj.state_dirty & obj_state_flags.HP ? obj.hp : -1),
                            orders,
                            (obj.is_building() ? obj.killer_info : null),
                            ((obj.is_mobile() && (obj.state_dirty & obj_state_flags.PATROL)) ? obj.patrol : null)
                           ];
            args.push(this_arg);

            // snoop update into my_army
            if(obj.state_dirty & obj_state_flags.HP) {
                if(obj.id in player.my_army) {
                    var entry = player.my_army[obj.id];
                    entry['hp_ratio'] = obj.hp/Math.max(obj.max_hp,1);
                }
            }

            obj.state_dirty = 0;
        }
    });

    if(args.length > 0 && session.has_attacked && player.tutorial_state == "COMPLETE" &&
      !options.urgent_only && !options.buildings_only && !options.skip_check) {
        session.get_real_world().report_damage_attribution();
    }

    if(args.length > 0) {
        send_to_server.func(["OBJECT_COMBAT_UPDATES", args]);
        if(session.is_recording()) {
            session.flush_recording();
        }
    }
}

var change_region_pending = null;

var loading_base_dialog = null;
var loading_base_dialog_timer = null;

function cancel_loading_base_timer() {
    if(loading_base_dialog_timer) {
        window.clearTimeout(loading_base_dialog_timer);
        loading_base_dialog_timer = null;
    }
};
function clear_loading_base_dialog() {
    if(loading_base_dialog) {
        close_dialog(loading_base_dialog);
    }
};
function invoke_loading_base_dialog(dialog_name) {
    if(loading_base_dialog) { throw Error('should not be invoked twice'); }
    loading_base_dialog_timer = null;
    var dialog_data = gamedata['dialogs'][dialog_name];
    var dialog = new SPUI.Dialog(dialog_data);
    loading_base_dialog = dialog; // set globally
    dialog.on_destroy = function() { loading_base_dialog = null; };
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    return dialog;
};

var visit_base_pending = false;

// switch to view another user's base (or your own base)
// if short_loading_timeout, then show loading screen immediately rather than delaying
function do_visit_base(uid, options) {
    if(uid === session.viewing_user_id && !session.has_attacked && session.viewing_player_home_base_id === session.viewing_base.base_id && !options.force) {
        // already looking at this user
        return;
    }

    if(visit_base_pending) {
        console.log('visit_base already pending');
        return;
    }

    // catch-all for leaving home when there is something in the loot buffer
    if(session.home_base && !session.has_attacked && (player.loot_buffer.length > 0)) {
        invoke_loot_dialog();
        return;
    }

    if(!options.skip_loot_storage_warning && session.home_base && !session.has_attacked && is_ai_user_id_range(uid) && player.tutorial_state == "COMPLETE") {
        var almost_full = {}, full = {}, any_almost_full = false, any_full = false;
        for(var res in gamedata['resources']) {
            if(('loot_storage_warning_if' in gamedata['resources'][res]) &&
               !read_predicate(gamedata['resources'][res]['loot_storage_warning_if']).is_satisfied(player,null)) { continue; }
            almost_full[res] = (player.resource_state[res][1] >= gamedata['client']['loot_storage_warning_threshold'] * player.resource_state[res][0]);
            if(almost_full[res]) { any_almost_full = true; }
            full[res] = (player.resource_state[res][1] >= player.resource_state[res][0]);
            if(full[res]) { any_full = true; }
        }
        if(player.get_any_abtest_value('loot_storage_warning', gamedata['client']['loot_storage_warning']) &&
           (any_full || any_almost_full) &&
           (player.get_townhall_level() >= gamedata['client']['loot_storage_warning_min_cc_level']) &&
           (player.get_townhall_level() <= gamedata['client']['loot_storage_warning_max_cc_level'])) {
            var new_options = goog.object.clone(options);
            new_options.skip_loot_storage_warning = true;
            var proceed = (function (_uid, _new_options) { return function() {
                do_visit_base(_uid, _new_options);
            }; })(uid, new_options);

            var complain_about, truly_full;
            if(any_full) {
                for(var res in gamedata['resources']) {
                    if(full[res]) {
                        complain_about = res;
                        truly_full = true;
                        break;
                    }
                }
            } else {
                for(var res in gamedata['resources']) {
                    if(almost_full[res]) {
                        complain_about = res;
                        truly_full = false;
                        break;
                    }
                }
            }

            var helper = get_requirements_help((truly_full ? 'storages_full_attack' : 'storages_almost_full_attack'),
                                               complain_about,
                                               {cancel_function: proceed});
            if(helper) {
                helper();
                return;
            }
        }
    }

    if(1) {
        flush_dirty_objects({});
        session.persist_debris();
    }

    if(uid > 0 || options.base_id || options.ladder_battle) {
        var msg;
        var props = {};
        if(options.apm) {
            props['apm'] = options.apm;
        }
        if(options.pre_attack) {
            props['pre_attack'] = options.pre_attack;
        }

        if(options.ladder_battle) {
            player.cooldown_client_trigger('VISIT_LADDER_RIVAL', gamedata['matchmaking']['ladder_match_client_cooldown']);
            msg = ["VISIT_LADDER_RIVAL", !!options.ladder_switch, props];
        } else if(options.base_id) {
            msg = ["VISIT_BASE2", options.base_id, props];
        } else {
            msg = ["VISIT_BASE", uid, props];
        }
        send_to_server.func(msg);
        visit_base_pending = true;

        // when leaving home base, save state of map dialog so we can come back to it
        if(session.home_base) {
            if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'region_map_dialog') {
                session.last_map_dialog_state = selection.ui.widgets['map'].get_state();
            } else {
                session.last_map_dialog_state = null;
            }
        }

        // schedule the "Loading Base" message to appear after a slight delay (in case the session change completes quickly)
        if(loading_base_dialog_timer == null) {
            if(options.ladder_battle) {
                invoke_loading_base_dialog('loading_ladder_base_dialog');
            } else if(options.short_loading_timeout || (gamedata['client']['loading_base_time'] === 0)) {
                invoke_loading_base_dialog('loading_base_dialog');
            } else {
                var load_time = gamedata['client']['loading_base_time'];
                if(load_time && load_time > 0) {
                    loading_base_dialog_timer = window.setTimeout(function() { invoke_loading_base_dialog('loading_base_dialog'); }, 1000*load_time);
                }
            }
        }
    }
}

function visit_base(uid) { return do_visit_base(uid, {}); };
function visit_base_with_loading_message(uid) { return do_visit_base(uid, {short_loading_timeout: true}); };

// return to home base
function visit_base_home() { visit_base(session.user_id); }

// force a session change to end the current attack. Normally returns
// to home base, but if it's a quarry attack, and you won, return to
// the quarry instead.
function visit_base_after_attack() {
    if(session.home_base) {
        do_visit_base(session.user_id, {apm: APMCounter.get()});
    } else if(session.is_quarry() && session.viewing_user_id != session.user_id && session.quarry_victory_satisfied()) {
        do_visit_base(0, {base_id: session.viewing_base.base_id, apm: APMCounter.get()});
    } else {
        do_visit_base(session.user_id, {apm: APMCounter.get()});
    }
}

function change_region(new_region, new_loc) { send_to_server.func(["CHANGE_REGION", new_region, new_loc]); }

// convert coordinates of DOM mouse event to canvas coordinates
function event_to_canvas(e) {
    // get canvas coordinates of mouse-click location
    var x, y;
    if(mouse_state.pointer_locked) {
        x = mouse_state.pointer_lock_origin[0] + e['webkitMovementX'];
        y = mouse_state.pointer_lock_origin[1] + e['webkitMovementY'];
        mouse_state.pointer_lock_origin = [x,y];
    } else {
        if(e.pageX || e.pageY) {
            x = e.pageX;
            y = e.pageY;
        } else {
            x = e.clientX; /*+ document.body.scrollLeft + document.documentElement.scrollLeft; */
            y = e.clientY; /*+ document.body.scrollTop + document.documentElement.scrollTop; */
        }
        if(true || !canvas_is_fullscreen) {
            x -= canvas_div_offsetLeft;
            y -= canvas_div_offsetTop;
        }
    }
    return [x,y];
}

function on_mouseup(e) {
   try {
       do_on_mouseup(e, false);
   } catch (ex) {
       log_exception(ex, 'do_on_mouseup');
   }
}

function do_on_mouseup(e, is_touch) {
    e.preventDefault();

    mouse_state.button.clear_button(/** @type {SPUI.MouseButton} */ (e.button));
    var button_delta = new SPUI.MouseButtonState(/** @type {SPUI.MouseButton} */ (e.button));

    // get canvas coordinates of mouse pointer location
    var xy = event_to_canvas(e);

    SPUI.dripper.stop(true, button_delta);

    if(mouse_state.dripper.is_active()) {
        // Dripper.stop() will fire the callback one more time, but it doesn't have any way of updating the player's APM
        if(mouse_state.dripper.times_fired <= 0) {
            if(gamedata['unit_deploy_style'] === 'drip') {
                APMCounter.record_action();
            }
        }

        mouse_state.dripper.stop(true, xy);
    }

    if(e.button === SPUI.MouseButton.RIGHT) {
        // end drag
        if(mouse_state.has_dragged) {
            mouse_state.has_dragged = false;
            if(selection.multi.length > 1) {
                player.record_feature_use('drag_select');
            }
        } else {
            if(tutorial_root.on_mouseup(xy, [0,0], button_delta)) {
                return;
            }
            if(player.quest_root.on_mouseup(xy, [0,0], button_delta)) {
                return;
            }
            if(SPUI.root.on_mouseup(xy, [0,0], button_delta)) {
                return;
            }
            if(player.tutorial_state != "COMPLETE") {
                return;
            }
            change_selection(null);
        }
        return;
    }

    if(mouse_state.has_scrolled == true) {
        mouse_state.has_scrolled = false;
        // do not trigger action if the mouse was just used for a BIG scroll
        if(Math.max(Math.abs(xy[0]-mouse_state.scroll_start_x),
                    Math.abs(xy[1]-mouse_state.scroll_start_y)) >= gamedata['client']['mouse_scroll_dead_zone']) {
            // but DO record use of "scrolling" feature
            player.record_feature_use('scrolling');
            return;
        }
    }

    // first let SPUI handle it
    if(tutorial_root.on_mouseup(xy, [0,0], button_delta)) {
        return;
    }

    if(player.quest_root.on_mouseup(xy, [0,0], button_delta)) {
        return;
    }

    if(SPUI.root.on_mouseup(xy, [0,0], button_delta)) {
        return;
    }

    // take back keyboard focus from SPUI
    SPUI.set_keyboard_focus(null);

    if(player.tutorial_state != "COMPLETE") {
        if('disable_landscape_clicks' in gamedata['tutorial'][player.tutorial_state]) {
            return;
        }
    } else {
        // disable landscape clicks while any notifications are pending
        //if(session.home_base && !session.has_attacked && notification_queue.pending() && !selection.ui) {
        //return;
        //}
    }

    if(!session.has_world()) { return; }
    if(!session.viewing_base) { return; }

    var world = session.get_draw_world();

    if(world !== session.get_real_world()) {
        // all the rest deals with player input, so ignore for non-real-world
        return;
    }

    if(session.viewing_base.base_landlord_id != session.user_id &&
       !session.has_attacked) {
        // do not allow control of attacker units prior to battle start
        return;
    }

    // find cell index (note: j,i are not quantized to integers)
    var ji = screen_to_ortho(xy);

    var ncells = session.viewing_base.ncells();

    // clamp ji to game map bounds
    // NOTE! xy is not clamped, and can be off the map - this is necessary to hit-detect flying units
    // whose altitude puts them "outside" the map, as seen from the isometric camera
    ji[0] = clamp(ji[0], 0, ncells[0]); ji[1] = clamp(ji[1], 0, ncells[1]);

    var j = ji[0], i = ji[1];

    // is a ground-targeted spell "armed"?
    if(selection.spellname) {
        if(selection.spellname === "MOVE_UNIT") {
            unit_command_move(world, j, i, false, !!e.shiftKey);
            change_selection_ui(null);
            selection.spellname = null;
            return;
        } else if(selection.spellname === "BUILD") {
            do_build(ji);
            return;
        } else if(selection.spellname === "MOVE_BUILDING") {
            if(selection.unit && ((selection.unit.is_building() && selection.unit.team == 'player') || player.is_cheater)) {
                ji = player.quantize_building_location(ji, selection.unit.spec);
                if((ji[0] != selection.unit.x || ji[1] != selection.unit.y) &&
                   player.is_building_location_valid(ji, selection.unit.spec, selection.unit, {ignore_perimeter: !!selection.unit.spec['ignore_perimeter']})) {
                    send_to_server.func(["CAST_SPELL",
                                         selection.unit.id,
                                         selection.spellname,
                                         ji]);
                    // play sound effect
                    GameArt.play_canned_sound('action_button_134px', 'bigaction');

                    // client-side predict - not 100% sure if this is safe?
                    var old_x = selection.unit.x, old_y = selection.unit.y;
                    selection.unit.x = ji[0]; selection.unit.y = ji[1];
                    selection.unit.update_map(selection.unit.world, [old_x, old_y], selection.unit.is_destroyed(), 'MOVE_BUILDING predict');
                }
            }
            change_selection(null);
            return;
        } else if(selection.spellname === "DEPLOY_UNITS") {
            if(!world.is_deployment_location_valid(ji)) {
                return;
            }

            var any_selected = goog.object.getCount(session.pre_deploy_units) > 0;

            if(any_selected) {

                // try to prevent breaking the tutorial by deploying less than a full load of units
                if((player.tutorial_state != 'COMPLETE') &&
                   (player.tutorial_state != 'place_robots_action')) {
                    return;
                }

                if(gamedata['unit_deploy_style'] != 'drip') {
                    APMCounter.record_action();
                    do_deploy([j,i], goog.object.getValues(session.pre_deploy_units));
                }
            }

            if((any_selected || session.has_deployed) && gamedata['unit_deploy_style'] != 'drip') {
                // if in combat, or units were deployed, kill cursor
                // but do not kill it on initial deployment when empty, so the deployment zone stays visible
                change_selection(null);
            }
            return;

        } else if(gamedata['spells'][selection.spellname]['activation'] === 'targeted_area') {
            // generic targeted spell activation
            if(selection.unit) {
                var spell_name = selection.spellname, spell = gamedata['spells'][selection.spellname];
                var success = false;
                success |= selection.unit.cast_client_spell_checked(world, spell_name, spell, null, [j,i]);
                for(var m = 0; m < selection.multi.length; m++) {
                    var u = selection.multi[m];
                    if(u !== selection.unit && u.spec === selection.unit.spec) {
                        success |= u.cast_client_spell_checked(world, spell_name, spell, null, [j,i]);
                    }
                }
                if(success) {
                    world.fxworld.add_under(new SPFX.ClickFeedback([j,i], [1,1,1,1], world.fxworld.now_time(), 0.15));
                }
            } else if(selection.item) {
                var spec = gamedata['items'][selection.item['spec']];
                var spell = gamedata['spells'][selection.spellname];

                inventory_send_request(selection.item, selection.slot, "INVENTORY_USE", [[j,i]], {trigger_gcd: session.has_deployed}); // trigger GCD during combat only

                var fxworld = world.fxworld;
                fxworld.add_under(new SPFX.ClickFeedback([j,i], [1,1,1,1], fxworld.now_time(), 0.15));
                if('ui_activation' in spell) {
                    fxworld.add(new SPFX.CombatText([j,i], 0,
                                                    spec['ui_name'] + " " + spell['ui_activation'],
                                                    [1,1,0.3],
                                                    fxworld.now_time(), 3.0,
                                                    { drop_shadow: true, font_size: 20, text_style: 'thick' }));
                }
            }
            APMCounter.record_action();

            change_selection_ui(null);
            selection.spellname = null;
            return;
        }
    }

    var found = find_object_at_screen_pixel(world, xy, ji, false);

    if(selection.unit && (selection.spellname === "AMOVE_UNIT" || selection.spellname === "PATROL_UNIT")) {
        if(selection.spellname === "AMOVE_UNIT") {
            player.record_feature_use('unit_attack_command');
            var add_waypoint = !!e.shiftKey;
            if(found &&
               (gamedata['allow_self_attack'] || player.is_developer() || (found.team != selection.unit.team))) {
                unit_command_attack(world, found, add_waypoint);
            } else {
                unit_command_move(world, j, i, true, add_waypoint);
            }
        } else if(selection.spellname === "PATROL_UNIT") {
            unit_command_patrol(world, j, i);
        }

        if(!e.shiftKey) {
            selection.spellname = null;
            change_selection_ui(null);
        }
        APMCounter.record_action();
        return;
    }


    if(found != null) {
        if((selection.unit != null) &&
           (selection.unit.spec['kind'] != 'virtual') &&
           (selection.unit.is_shooter()) &&
           (found != selection.unit) &&
           (found.team != selection.unit.team)) {

            unit_command_attack(world, found, !!e.shiftKey);

            if(player.tutorial_state === 'move_rover_action') {
                tutorial_step_move_rover_action_command();
            }

            world.fxworld.add_under(new SPFX.ClickFeedback(found.interpolate_pos(world), [1,0,0,1], world.fxworld.now_time(), 0.15));
            APMCounter.record_action();

        } else {
            if((found.team === 'player') && found.is_mobile() && player.unit_micro_enabled() && (!session.is_quarry() || session.has_deployed || session.region.data['storage'] == 'nosql')) {
                // naked click on a player's own unit

                if(e.ctrlKey ||
                   (mouse_state.last_unit_clicked === found &&
                    (client_time - mouse_state.last_click_time < DOUBLE_CLICK_TIME))) {
                    // it's a double-click or control-click
                    // select all on-screen units of same type
                    var units = find_objects_in_screen_rect(world, [0,0], [canvas_width,canvas_height], found.spec);
                    if(units.length > 0) { player.record_feature_use('double_click_select'); }

                    if(e.shiftKey) {
                        goog.array.forEach(units, function(u) {
                            add_unit_to_selection(u);
                        });
                    } else {
                        selection.multi = units;
                        if(!selection.unit && units.length > 0) { selection.unit = units[0]; }
                    }
                    mouse_state.last_unit_clicked = null;
                } else {
                    // NOT a double-click
                    mouse_state.last_unit_clicked = found;
                    mouse_state.last_click_time = client_time;

                    if(e.shiftKey) {
                        // flip selected state
                        toggle_unit_selection(found);
                        player.record_feature_use('shift_select');
                    } else {
                        // replace existing selection
                        change_selection(found);
                        selection.spellname = null;
                        selection.spellkind = null;

                        found.speak('click');
                    }
                }

                if(player.tutorial_state === 'click_on_rover_action') {
                    if(found.spec['name'] === gamedata['tutorial'][player.tutorial_state]['unit_type']) {
                        advance_tutorial();
                    } else {
                        goog.array.forEach(selection.multi, function(unit) {
                            if(unit.spec['name'] === gamedata['tutorial'][player.tutorial_state]['unit_type']) {
                                advance_tutorial();
                            }
                        });
                    }
                }

                return;
            } else if((found.team === 'player') &&
                      /* enable if not in combat (where "combat" explicitly excludes reinforcement mode at a friendly quarry/squad) */
                      (!session.has_attacked || (!session.home_base && session.viewing_user_id == session.user_id)) &&
                      (found.is_building() || found.is_inert()) &&
                      (session.home_base || !found.spec['quarry_invul'] || found.is_producer()) &&
                      (!selection.ui || !selection.ui.user_data || selection.ui.user_data['dialog'] !== 'deployment_markers_notice')
                     ) {
                // naked click on a player's own building
                change_selection(found);
                var allow_invoke = true;
                if(player.tutorial_state != "COMPLETE") {
                    allow_invoke = false;
                    if(player.tutorial_state === 'speedup_open_context_menu' &&
                       found.spec['name'] === gamedata['tutorial'][player.tutorial_state]['target']) {
                        allow_invoke = true;
                    }
                }

                if(session.has_attacked && !(!session.home_base && session.region.data && session.region.data['storage'] == 'nosql' &&
                                             (session.viewing_base.base_landlord_id == session.user_id) && (goog.array.contains(['squad','quarry'], session.viewing_base.base_type)))) {
                    allow_invoke = false;
                }

                if(allow_invoke) {
                    if(session.home_base && found.is_building() && found.is_producer() && gamedata['enable_oneclick_harvest'] &&
                       found.idle_state_cache && found.idle_state_cache['state'] &&
                       found.idle_state_cache['state'].indexOf('harvest_') == 0 &&
                       get_storage_fullness(found.produces_res()) < 1 &&
                       found.is_in_sync()) {
                        // do a one-click harvest iff the idle state is showing as "Collect"
                        do_harvest(false);
                    } else {
                        invoke_building_context_menu(xy);
                    }
                }
                return;
            } else if(player.is_cheater && found.is_inert()) {
                change_selection(found);
                invoke_building_context_menu(xy);
            }
        }
    } else {
        // click over empty ground
        if(selection.unit != null) {
            if(selection.unit.is_mobile()) {

                var use_amove = false;

                // in auto unit control mode and on touch screens, treat ALL (in combat) landscape clicks as a-move
                if(session.has_attacked && (is_touch || get_preference_setting(player.preferences, 'auto_unit_control'))) {
                    use_amove = true;
                    if(client_time - mouse_state.last_click_time < DOUBLE_CLICK_TIME) {
                        use_amove = false;
                        //mouse_state.last_click_time = 0;
                    }
                    mouse_state.last_click_time = client_time;
                }

                // move units
                unit_command_move(world, j, i, use_amove, !!e.shiftKey);
                APMCounter.record_action();
            } else {
                // deselect
                change_selection(null);
            }
        }
    }
}

function on_mouseout(e) {
   try {
       do_on_mouseout(e);
   } catch (ex) {
       log_exception(ex, 'do_on_mouseout');
   }
}

function do_on_mouseout(e) {
    mouse_state.button.clear_all_buttons();
    mouse_state.dripper.stop();
    mouse_state.has_scrolled = false;
    mouse_state.has_dragged = false;
    mouse_state.hovering_over = null;
}

function create_mouse_tooltip() {
    if(!session.has_world()) { return; }
    var world = session.get_draw_world();

    // no tooltips during tutorial
    if(player.tutorial_state != "COMPLETE") { return; }

    if(!mouse_tooltip) {
        mouse_tooltip = new SPUI.Tooltip({'ui_name':'TEMP','delay':0}, null);
        mouse_tooltip.text_hjustify = 'center';
        mouse_tooltip.font = SPUI.make_font(13, 17, 'normal');
    }

    mouse_tooltip.onenter();

    mouse_tooltip.ondraw = function(mouse_tooltip) {
        // don't show tooltip if any other UI is up, or if mouse has left the object
        if(selection.ui != null || !mouse_state.hovering_over) {
            mouse_tooltip.onleave();
            return;
        }

        // also kill the tooltip if the mouse is hovering over any desktop UI element
        for(var name in desktop_dialogs) {
            var dialog = desktop_dialogs[name];
            if(dialog.mouse_enter_time > 0) {
                for(var i = 0; i < dialog.children.length; i++) {
                    var child = dialog.children[i];
                    // XXX note: not all SPUI widgets have a mouse_enter_time member!
                    if(child.mouse_enter_time && child.mouse_enter_time > 0) {
                        mouse_tooltip.onleave();
                        return;
                    }
                }
            }
        }

        mouse_tooltip.text_color = SPUI.default_text_color;

        // update tooltip text
        var obj = mouse_state.hovering_over;
        var str = [];

        if(obj.is_mobile() || obj.is_building()) {
            if(obj.is_invisible() && (obj.team !== 'player' || session.is_replay())) {
                mouse_tooltip.onleave();
                return;
            }

            if(obj.is_building() && ((obj.is_emplacement() && obj.turret_head_item()) || (obj.is_trapped_barrier() && obj.barrier_trap_item()) || (obj.is_armed_building() && obj.building_weapon_item()) || (obj.is_armed_townhall() && obj.townhall_weapon_item()))) {
                var item = null;
                var low_power_warning_cursor = null;
                if (obj.is_emplacement()) {
                    item = obj.turret_head_item();
                    low_power_warning_cursor = 'low_power_turret';
                } else if (obj.is_trapped_barrier()) {
                    item = obj.barrier_trap_item();
                    low_power_warning_cursor = 'low_power_barrier_trap';
                } else if (obj.is_armed_building()) {
                    item = obj.building_weapon_item();
                    low_power_warning_cursor = 'low_power_building_weapon';
                } else if (obj.is_armed_townhall()) {
                    item = obj.townhall_weapon_item();
                    low_power_warning_cursor = 'low_power_townhall_weapon';
                }
                if(!(low_power_warning_cursor in gamedata['strings']['cursors'])) {
                    throw Error('Missing power warning curson in gamedata: ' + low_power_warning_cursor);
                }
                if(item) {
                    var item_spec = ItemDisplay.get_inventory_item_spec(item['spec']);
                    var ui_name = ItemDisplay.strip_inventory_item_ui_name_level_suffix(ItemDisplay.get_inventory_item_ui_name(item_spec));
                    str.push(ui_name);
                    if('associated_tech' in item_spec &&
                       (obj.team === 'player' || gamedata['enemy_tooltip_detail'][obj.spec['kind']])) {
                        var cur_level = ItemDisplay.get_inventory_item_level(item);
                        var max_level = get_max_ui_level(gamedata['tech'][item_spec['associated_tech']]);
                        str.push(gamedata['strings']['cursors']['level_x_of_y'].replace('%cur', cur_level.toString()).replace('%max', max_level.toString()));
                    }

                    // low power on armed mounted weapon slots
                    var powerfac = obj.combat_power_factor(world.base);
                    if(powerfac < 1) {
                        var ui_power_warning = gamedata['strings']['cursors'][low_power_warning_cursor]
                            .replace('%d', Math.min(99, 100.0*powerfac).toFixed(0));
                        str.push(ui_power_warning);
                    }

                    str.push('---'); // separator between mounted weapon and slot
                }
            }

            var nameline = obj.spec['ui_name'];
            if(obj.is_building() && obj.is_minefield() && (obj.id in session.minefield_tags_by_obj_id)) {
                nameline += ' '+session.minefield_tags_by_obj_id[obj.id];
            }
            if(obj.is_building() && obj.is_ambush() && (obj.id in session.ambush_point_tags_by_obj_id)) {
                nameline += ' '+session.ambush_point_tags_by_obj_id[obj.id];
            }
            str.push(nameline);

            if(obj.team === 'player' && obj.is_building() && obj.is_shooter() && !obj.is_minefield() && !obj.is_ambush() && !obj.is_emplacement() && !obj.is_trapped_barrier() && !obj.is_armed_building() && !obj.is_armed_townhall()) {
                // low power on ordinary turrets
                var powerfac = obj.combat_power_factor(world.base);
                if(powerfac < 1) {
                    var ui_power_warning = gamedata['strings']['cursors']['low_power_turret']
                        .replace('%d', Math.min(99, 100.0*powerfac).toFixed(0));
                    str.push(ui_power_warning);
                }
            }

            if((obj.team === 'player' || gamedata['enemy_tooltip_detail'][obj.spec['kind']]) && (obj.get_max_ui_level() > 1)) {
                var max_level = obj.get_max_ui_level();
                str.push(gamedata['strings']['cursors']['level_x_of_y'].replace('%cur', obj.level.toString()).replace('%max', max_level.toString()));
            }
        } else if(obj.is_inert()) {
            if(obj.metadata && 'tooltip' in obj.metadata) {
                str.push(obj.metadata['tooltip']);
            } else {
                str.push(obj.get_leveled_quantity(obj.spec['ui_name'] || obj.spec['name']));
                var max_level = obj.get_max_ui_level();
                if(max_level > 1) {
                    str.push(gamedata['strings']['cursors']['level_x_of_y'].replace('%cur', obj.level.toString()).replace('%max', max_level.toString()));
                }
            }
        }

        if(obj.is_building()) {
            if(obj.is_storage() && !obj.is_under_construction() && obj.spec['name'] != gamedata['townhall'] &&
               (obj.team === 'player' || gamedata['enemy_storage_detail'])) {
                var resname = null;
                for(var res in gamedata['resources']) {
                    if('storage_'+res in obj.spec) {
                        resname = res; break;
                    }
                }
                if(obj.is_damaged()) {
                    str.push(gamedata['strings']['cursors']['damaged']);
                } else if(resname) {
                    // get % fullness relative to max undestroyed storage capacity
                    var fullness = get_storage_fullness(resname);
                    if(session.viewing_ai || session.viewing_base.base_id != session.viewing_player_home_base_id) {
                        // no info
                    } else {
                        str.push(gamedata['strings']['cursors']['fullness'].replace('%pct',(100*fullness).toFixed(0)));
                    }
                }
            } else if(obj.is_producer() && !(obj.is_under_construction() || obj.is_removing())) {
                if(obj.is_upgrading() || obj.is_enhancing()) {
                    str.push(gamedata['strings']['cursors']['upgrading']);
                } else if(obj.team === 'player') {
                    // low power on harvesters
                    var powerfac = world.base.power_factor();
                    if(powerfac < 1) {
                        var ui_power_warning = gamedata['strings']['cursors']['low_power_harvester']
                            .replace('%d', Math.min(99, 100.0*powerfac).toFixed(0));
                        str.push(ui_power_warning);
                    }

                    var contents = obj.interpolate_contents();
                    var ui_contents = pretty_print_number(Math.floor(contents));
                    if(obj.produce_rate > 0 && obj.produce_rate < 1000 && contents < 10) {
                        // slow harvester - show fractional amounts
                        ui_contents += '.'+pad_with_zeros(Math.floor(100*(contents-Math.floor(contents))).toString(), 2);
                    }
                    var capacity = obj.get_production_capacity();
                    str.push(ui_contents+'/'+pretty_print_number(capacity));
                }
            }
        }

        // enhancement information
        if(obj.team === 'player' || gamedata['enemy_tooltip_detail'][obj.spec['kind']]) {
            if(obj.is_mobile()) {
                // mod techs
                var STAT_NAMES = gamedata['strings']['cursors']['mod_types'];
                var tech_dict = null;
                if(obj.team === 'player') {
                    tech_dict = player.tech;
                } else if(obj.team === 'enemy') {
                    tech_dict = enemy.tech;
                }
                if(tech_dict) {
                    for(var name in STAT_NAMES) {
                        var tech_name = obj.spec['name']+name;
                        if(tech_name in tech_dict) {
                            str.push('L'+tech_dict[tech_name].toFixed(0)+' '+STAT_NAMES[name]+' Mod');
                        }
                    }
                }
            }

            // show enhancements, on player only
            if(obj.team === 'player' && obj.enhancements) {
                for(var enh_name in obj.enhancements) {
                    if(enh_name in gamedata['enhancements']) {
                        var enh_level = obj.enhancements[enh_name];
                        var enh_ui_name = gamedata['enhancements'][enh_name]['ui_name']
                        //str.push(enh_ui_name + ' L'+enh_level.toFixed(0));
                        str.push(enh_ui_name + ' ' +
                                 gamedata['strings']['cursors']['level_x_of_y']
                                 .replace('%cur', enh_level.toFixed(0))
                                 .replace('%max', get_max_level(gamedata['enhancements'][enh_name]).toFixed(0)));
                    }
                }
            }

            if(player.get_any_abtest_value('enable_equipment', gamedata['client']['enable_equipment'])) {
                // list equipped items

                var equip = null;
                if(obj.is_building()) {
                    equip = obj.equipment;
                } else if(obj.is_mobile() && player.get_any_abtest_value('enable_unit_equipment', gamedata['client']['enable_unit_equipment'])) {
                    var eqdic = (obj.team === 'player' ? player.unit_equipment : enemy.unit_equipment);
                    if(eqdic) {
                        equip = eqdic[obj.spec['name']] || null;
                    }
                }

                if(equip) {
                    for(var slot_type in equip) {
                        if(!player.is_cheater &&
                           ((('show' in gamedata['strings']['equip_slots'][slot_type]) && !gamedata['strings']['equip_slots'][slot_type]['show']) ||
                            (('show_if' in gamedata['strings']['equip_slots'][slot_type]) &&
                             !read_predicate(gamedata['strings']['equip_slots'][slot_type]['show_if']).is_satisfied(player,null))
                           )) {
                            continue;
                        }

                        var item_list = equip[slot_type];
                        for(var i = 0; i < item_list.length; i++) {
                            if(item_list[i]) {
                                var item_spec = ItemDisplay.get_inventory_item_spec(player.decode_equipped_item(item_list[i])['spec']);
                                var equip_ui_name = ItemDisplay.get_inventory_item_ui_name(item_spec);
                                var ui_level = null;
                                if(obj.is_building() && ((obj.is_minefield() && obj.is_minefield_armed()) || (obj.is_ambush() && obj.is_ambush_armed()))) {
                                    if (equip_ui_name.indexOf('_L') === -1 && item_spec['associated_tech']) {
                                        var item_cur_level = player.decode_equipped_item(item_list[i])['level'];
                                        var tech_max_level = get_max_ui_level(gamedata['tech'][item_spec['associated_tech']]);
                                        if (item_cur_level && tech_max_level) {
                                            item_cur_level = item_cur_level.toString();
                                            tech_max_level = tech_max_level.toString();
                                            ui_level = "Level %d0 of %d1".replace('%d0', item_cur_level).replace('%d1', tech_max_level);
                                        }
                                    }
                                }
                                str.push(equip_ui_name);
                                if(ui_level) {
                                    str.push(ui_level);
                                }
                            }
                        }
                    }
                }

                if(obj.is_building() && obj.is_minefield() && !obj.is_minefield_armed()) {
                    str.push(gamedata['strings']['cursors']['no_mine_equipped']);
                    mouse_tooltip.text_color = SPUI.make_colorv([1,0,0,1]);
                } else if(obj.is_building() && obj.is_ambush() && !obj.is_ambush_armed()) {
                    str.push(gamedata['strings']['cursors']['no_ambush_equipped']);
                    mouse_tooltip.text_color = SPUI.make_colorv([1,0,0,1]);
                }
            }
        }

        var pos = mouse_state.hovering_over.interpolate_pos(world);
        var alt = (mouse_state.hovering_over.is_mobile() && mouse_state.hovering_over.is_flying() ?
                   mouse_state.hovering_over.combat_stats.altitude - 1 : 0);

        if(!spin_secure_mode && player.is_developer()) {
            str.push('Coords: '+pos[0].toFixed(0)+','+pos[1].toFixed(0));
        }

        mouse_tooltip.str = str.join('\n');

        // have to pre-measure here since setting xy requires a correct value for this.wh[0]
        mouse_tooltip.wh = mouse_tooltip.font.measure_string(mouse_tooltip.str);

        // reposition the tooltip so it tracks objects on the landscape
        mouse_tooltip.xy = ortho_to_screen_3d([pos[0],alt,pos[1]]);
        mouse_tooltip.xy[0] = Math.floor(mouse_tooltip.xy[0] - mouse_tooltip.wh[0]/2);
        mouse_tooltip.xy[1] = Math.floor(mouse_tooltip.xy[1] + 30);
    };
}

/** @param {!World.World} world
    @param {number} xmin
    @param {number} xmax
    @param {number} ymin
    @param {number} ymax
    @param {boolean} add_to_selection */
function do_on_mousemove_update_drag_selection(world, xmin, xmax, ymin, ymax, add_to_selection) {
    // do not change selection during move_rover_action tutorial step
    if(player.tutorial_state != 'move_rover_action') {
        var units = find_objects_in_screen_rect(world, [xmin,ymin], [xmax,ymax], null);

        if(add_to_selection) {
            // add to existing selection
            for(var i = 0; i < units.length; i++) {
                add_unit_to_selection(units[i]);
            }
        } else {
            // replace existing selection
            selection.multi = units;
        }

        if(player.tutorial_state === 'click_on_rover_action') {
            for(var i = 0; i < selection.multi.length; i++) {
                if(selection.multi[i].spec['name'] === gamedata['tutorial'][player.tutorial_state]['unit_type']) {
                    advance_tutorial();
                }
            }
        }

        // deselect selection.unit if it is not a member of selection.multi
        var keep_selection_unit = false;
        for(var i = 0; i < selection.multi.length; i++) {
            if(selection.multi[i] === selection.unit) {
                keep_selection_unit = true;
                break;
            }
        }
        if(!keep_selection_unit) {
            selection.unit = null;
        }

        if(selection.multi.length > 0 && !selection.unit) {
            // set selection.unit so multi-unaware code does the right thing
            selection.unit = selection.multi[0];
        }
    }
}

function on_mousewheel(e) {
   try {
       do_on_mousewheel(e);
   } catch (ex) {
       log_exception(ex, 'do_on_mousewheel');
   }
}

function do_on_mousewheel(e) {
    if(client_state != client_states.RUNNING) { return; }
    // get canvas coordinates of mouse pointer location
    var xy = event_to_canvas(e);

    var delta;
    if(e.deltaMode === 1) { // lines
        delta = -e.deltaY*0.75;
    } else { // pixels
        delta = -e.deltaY/60; // arbitrary scale factor
    }
    // check if player has reverse mousewheel scrolling checked before passing to SPUI root
    if(SPUI.root.on_mousewheel(xy, [0,0], (delta * (!!player.preferences['reverse_mousewheel_scroll'] ? -1 : 1)))) {
        if(e.preventDefault) { e.preventDefault(); }
        return;
    }

    // apply desktop zoom
    if(!selection.ui) {
        // turn on reverse zoom if it's on. It applies to the desktop
        var new_zoom = view_zoom_linear + delta * (!!player.preferences['reverse_mousewheel_zoom'] ? -1 : 1) * gamedata['client']['view_zoom_mousewheel_increment']
        set_view_zoom(new_zoom);
        if(e.preventDefault) { e.preventDefault(); }
        return;
    }
}

function on_mousemove(e) {
   try {
       do_on_mousemove(e);
    } catch (ex) {
        log_exception(ex, 'do_on_mousemove');
    }
}

function do_on_mousemove(e) {
    // do not fire event until server connection
    if(client_state != client_states.RUNNING) { return; }

    e.preventDefault();

    var allow_scroll = true;
    if(player.tutorial_state != "COMPLETE" &&
       ('disable_landscape_clicks' in gamedata['tutorial'][player.tutorial_state])) {
        allow_scroll = false;
    }

    // perform cleanup on first GUI event received after Facebook dialog goes away
    Store.force_order_cleanup();

    // get canvas coordinates of mouse pointer location
    var xy = event_to_canvas(e);
    var x = xy[0], y = xy[1];
    mouse_state.last_raw_x = x; mouse_state.last_raw_y = y;

    tutorial_root.on_mousemove(xy, [0,0]);
    if(!mouse_state.has_scrolled && !mouse_state.has_dragged) {
        if(SPUI.root.on_mousemove(xy, [0,0])) {
            // if SPUI handles the mousemove, that means the mouse is over
            // some UI element, so do not display the landscape tooltips
            if(mouse_state.hovering_over && mouse_tooltip) {
                mouse_tooltip.onleave();
            }
            mouse_state.hovering_over = null;
            return;
        }
    }

    // mouse tooltip processing. Skip if game not loaded, or in combat.
    if(!session.has_world()) { return; }
    var world = session.get_draw_world();

    if(session.viewing_base && (!session.has_attacked || gamedata['client']['enable_mouse_tooltip_in_battle'])) {
        var found = find_object_at_screen_pixel(world, xy, screen_to_ortho(xy), true);
        if(mouse_state.hovering_over != found) {
            if(mouse_state.hovering_over && mouse_tooltip) {
                mouse_tooltip.onleave();
            }
            mouse_state.hovering_over = found;
            if(mouse_state.hovering_over) {
                create_mouse_tooltip();
            } else {
                if(mouse_tooltip) {
                    mouse_tooltip.onleave();
                }
            }
        }
    } else {
        if(mouse_tooltip) { mouse_tooltip.onleave(); }
    }

    if(x != mouse_state.last_x || y != mouse_state.last_y) {
        if(mouse_state.button.get_button(SPUI.MouseButton.LEFT) && allow_scroll) {
            // scroll view
            var dx = x - mouse_state.last_x;
            var dy = y - mouse_state.last_y;
            view_pos[0] -= dx/view_zoom;
            view_pos[1] -= dy/view_zoom;
            view_pos[0] = clamp(view_pos[0], view_limits[0][0], view_limits[0][1]);
            view_pos[1] = clamp(view_pos[1], view_limits[1][0], view_limits[1][1]);

            mouse_state.drag_start_x += dx;
            mouse_state.drag_start_y += dy;

            if(!mouse_state.has_scrolled) {
                mouse_state.has_scrolled = true;
                mouse_state.scroll_start_x = x;
                mouse_state.scroll_start_y = y;
            }

            force_scroll_state.key = null; // kill current forced scroll move, if any

            // stop dripper, but only if the scroll is going to be a very large one. Ignore small moves.
            if(mouse_state.dripper.times_fired < 1 &&
               Math.max(Math.abs(x-mouse_state.scroll_start_x),
                        Math.abs(y-mouse_state.scroll_start_y)) >= gamedata['client']['mouse_scroll_dead_zone_dripper']) {
                mouse_state.dripper.stop(); // abort current drip operation
            }
        }
        if(world === session.get_real_world() && player.unit_micro_enabled() && (mouse_state.button.get_button(SPUI.MouseButton.RIGHT) || mouse_state.spacebar)) {
            // drag-select
            if(!mouse_state.has_dragged) {
                mouse_state.has_dragged = true;
                mouse_state.drag_start_x = x;
                mouse_state.drag_start_y = y;
            } else {
                var xmin = Math.min(x, mouse_state.drag_start_x);
                var xmax = Math.max(x, mouse_state.drag_start_x);
                var ymin = Math.min(y, mouse_state.drag_start_y);
                var ymax = Math.max(y, mouse_state.drag_start_y);

                do_on_mousemove_update_drag_selection(world, xmin, xmax, ymin, ymax, !!e.shiftKey);
            }
        }

        if(mouse_state.button.get_any_button() && mouse_state.has_scrolled) {
            // remove pop-up UI ONLY if it's a context menu
            if(player.tutorial_state == "COMPLETE" &&
               selection.ui != null &&
               selection.ui.user_data &&
               'dialog' in selection.ui.user_data &&
               selection.ui.user_data['dialog'] === 'context_menu') {
                change_selection_ui(null);
            }
        }

    }

    mouse_state.last_x = x; mouse_state.last_y = y;
    // draw(); may cause performance problems
}

// emulate a regular mouse event based on a TouchEvent
function touch_emulate_mouse(e, touchevt) {
    return {'pageX': touchevt.pageX,
            'pageY': touchevt.pageY,
            'preventDefault': function() {},
            'ctrlKey': e.ctrlKey,
            'shiftKey': e.shiftKey,
            'button':0
           };
};

function on_touchstart(e) {
    //console.log('touchstart'); console.log(e);
    e.preventDefault();
    if(e.changedTouches.length < 1) { return; }
    on_mousedown(touch_emulate_mouse(e, e.changedTouches[0]));
    mouse_state.has_dragged = false;
}

function on_touchend(e) {
    try {
        return do_on_touchend(e);
    } catch (ex) {
        log_exception(ex, 'do_on_touchend');
    }
}

function do_on_touchend(e) {
    //console.log('touchend'); console.log(e);
    e.preventDefault();
    if(e.changedTouches.length < 1) { return; }

    if(mouse_state.has_dragged) {
        mouse_state.has_dragged = false;
        if(e.targetTouches.length > 0) {
            var xy = event_to_canvas(e.targetTouches[0]);
            mouse_state.last_x = xy[0]; mouse_state.last_y = xy[1];
        }
    } else {
        do_on_mouseup(touch_emulate_mouse(e, e.changedTouches[0]), true);
    }
    mouse_state.has_dragged = false;
}

function on_touchmove(e) {
    //console.log('touchmove'); console.log(e);
    e.preventDefault();
    if(e.changedTouches.length < 1) { return; }

    var world = session.get_draw_world();
    if(!world) { return; }

        if(e.targetTouches.length > 1 && player.unit_micro_enabled()) {
            // two-finger multi-select
            var xy0 = event_to_canvas(e.targetTouches[0]);
            var xy1 = event_to_canvas(e.targetTouches[1]);

            mouse_state.last_x = xy1[0];
            mouse_state.last_y = xy1[1];

            if(!mouse_state.has_dragged) {
                mouse_state.has_dragged = true;
                mouse_state.drag_start_x = xy0[0];
                mouse_state.drag_start_y = xy0[1];
            } else {
                var xmin = Math.min(xy0[0], xy1[0]);
                var xmax = Math.max(xy0[0], xy1[0]);
                var ymin = Math.min(xy0[1], xy1[1]);
                var ymax = Math.max(xy0[1], xy1[1]);

                do_on_mousemove_update_drag_selection(world, xmin, xmax, ymin, ymax, false);
            }
        } else {
            on_mousemove(touch_emulate_mouse(e, e.changedTouches[0]));
        }
}

// we handle MSPointer events mostly the same as ordinary mouse events, just with some
// special tracking for multi-touch selection

// map of pointerId to {pageX, pageY} - conveniently makes event_to_canvas() work
var mspointer_state = {};
function on_MSPointerDown(e) {
    mspointer_state[e.pointerId] = {pageX: e.pageX, pageY: e.pageY};
    return on_mousedown(e);
}
function on_MSPointerUp(e) {
    try {
        return do_on_MSPointerUp(e);
    } catch (ex) {
        log_exception(ex, 'do_on_MSPointerUp');
    }
}
function do_on_MSPointerUp(e) {
    if(e.pointerId in mspointer_state) { delete mspointer_state[e.pointerId]; }

    if(mouse_state.has_dragged) {
        mouse_state.has_dragged = false;
        var xy = event_to_canvas(e);
        mouse_state.last_x = xy[0]; mouse_state.last_y = xy[1];
        e.preventDefault();
    } else {
        return do_on_mouseup(e, true);
    }
}
function on_MSPointerOut(e) {
    if(e.pointerId in mspointer_state) { delete mspointer_state[e.pointerId]; }
    return false;
}
function on_MSPointerMove(e) {
    mspointer_state[e.pointerId] = {pageX: e.pageX, pageY: e.pageY};
    var count = 0;
    var pointer0 = null, pointer1 = null;
    for(var id in mspointer_state) {
        count += 1;
        if(!pointer0) {
            pointer0 = mspointer_state[id];
        } else if(!pointer1) {
            pointer1 = mspointer_state[id];
        }
    }

    var world = session.get_draw_world();

    if((e.pointerType===e.MSPOINTER_TYPE_TOUCH) && (count >= 2) && world && player.unit_micro_enabled()) {
        // two-finger multi-select
        e.preventDefault();
        var xy0 = event_to_canvas(pointer0);
        var xy1 = event_to_canvas(pointer1);

        mouse_state.last_x = xy1[0];
        mouse_state.last_y = xy1[1];

        if(!mouse_state.has_dragged) {
            mouse_state.has_dragged = true;
            mouse_state.drag_start_x = xy0[0];
            mouse_state.drag_start_y = xy0[1];
        } else {
            var xmin = Math.min(xy0[0], xy1[0]);
            var xmax = Math.max(xy0[0], xy1[0]);
            var ymin = Math.min(xy0[1], xy1[1]);
            var ymax = Math.max(xy0[1], xy1[1]);

            do_on_mousemove_update_drag_selection(world, xmin, xmax, ymin, ymax, false);
        }
    } else {
        return on_mousemove(e);
    }
}

SPINPUNCHGAME.first_action_sent = false;

function register_player_input() {
    input_since_last_xmit = true;
    input_since_last_proxy_xmit = true;
    if(!SPINPUNCHGAME.first_action_sent &&
       (client_state != client_states.LOADING)) { // wait until logged in (or prevented from logging in, after successful connection attempt) before sending
        SPINPUNCHGAME.first_action_sent = true;
        SPLWMetrics.send_event(spin_metrics_anon_id, '0125_first_action', add_demographics({'user_id': session.user_id,
                                                                                            'since_pageload': (new Date()).getTime()/1000 - spin_pageload_begin}));
        if(session.connected()) {
            player.record_feature_use('first_action');
        }
    }

    if(GameArt.initialized) {
        GameArt.resume_audio();
    }
}

function on_mousedown(e) {
   try {
       do_on_mousedown(e);
   } catch (ex) {
       log_exception(ex, 'do_on_mousedown');
   }
}

function do_on_mousedown(e) {
    canvas.focus();
    register_player_input();

    e.preventDefault();
    mouse_state.button.set_button(/** @type {SPUI.MouseButton} */ (e.button));
    var button_delta = new SPUI.MouseButtonState(/** @type {SPUI.MouseButton} */ (e.button));

    // get canvas coordinates of mouse-click location
    var xy = event_to_canvas(e);
    // first let SPUI handle it
    if(tutorial_root.on_mousedown(xy, [0,0], button_delta)) {
        return;
    }
    if(player.quest_root.on_mousedown(xy, [0,0], button_delta)) {
        return;
    }
    if(SPUI.root.on_mousedown(xy, [0,0], button_delta)) {
        return;
    }

    if(e.button === SPUI.MouseButton.LEFT) {
        // reset scroll
        mouse_state.has_scrolled = false;
    } else if(e.button === SPUI.MouseButton.RIGHT) {
        // reset drag
        mouse_state.has_dragged = false;
    }

    var x = xy[0], y = xy[1];
    mouse_state.last_x = x; mouse_state.last_y = y;

    hitloc[0] = x; hitloc[1] = y;

    // if a popout UI is active, get rid of it
    if(selection.ui &&
       selection.ui.user_data &&
       'dialog' in selection.ui.user_data &&
       selection.ui.user_data['dialog'].indexOf('popout') != -1) {
        change_selection_ui(null);
    }

    if(!session.has_world()) { return; }
    var world = session.get_draw_world();

    // awkward special case for SG unit deployment
    // this has to fire on mousedown, not mouseup for "dripping" to work properly
    // so it cannot go together with the usual mouseup handling
    if(world === session.get_real_world() &&
       gamedata['unit_deploy_style'] == 'drip' && selection.spellname === "DEPLOY_UNITS") {
        APMCounter.record_action();

        var deployment_dripper_callback = function(mouse_xy) {
            var world = session.get_draw_world();

            var ji = screen_to_ortho(mouse_xy);
            if(!world.is_deployment_location_valid(ji)) {
                return true; // stop the dripper
            }
            var obj = null;
            // pick the first one
            for(var obj_id in session.pre_deploy_units) {
                obj = session.pre_deploy_units[obj_id];
                // predict new space accounting
                if(obj['source'] !== 'donated') {
                    session.deployed_unit_space += get_leveled_quantity(gamedata['units'][obj['spec']]['consumes_space'] || 0, obj['level']||1);
                }
                break;
            }
            if(obj) {
                do_deploy(ji, [obj]);
                return false; // do not stop dripper
            } else {
                // nothing left
                return true; // stop the dripper
            }
        }

        mouse_state.dripper.reset(deployment_dripper_callback,
                                  gamedata['client']['drip_deployment_rate'],
                                  client_time + gamedata['client']['drip_startup_delay']);
    }
}

/** @param {!World.World} world
    @param {!GameObject} unit
    @param {!GameObject} target
    @param {boolean} add_waypoint
    @param {boolean} also_make_aggressive */
function do_unit_command_attack(world, unit, target, add_waypoint, also_make_aggressive) {
    if(target.is_destroyed() || target.is_indestructible()) { return; }
    if(!unit.is_shooter()) { return; }
    if(unit === target) { return; }
    if(!unit.can_shoot_at(target)) { return; }

    var order = {'state': ai_states.AI_ATTACK_SPECIFIC,
                 'target': target.id};
    if(also_make_aggressive) {
        order['aggressive'] = 1;
    }
    unit.new_order(world, order, !add_waypoint);
}

/** @param {!World.World} world
    @param {!GameObject} target
    @param {boolean} add_waypoint */
function unit_command_attack(world, target, add_waypoint) {
    if(!selection.unit) { return; }

    selection.unit.speak('attack');

    do_unit_command_attack(world, selection.unit, target, add_waypoint, false);
    for(var i = 0; i < selection.multi.length; i++) {
        do_unit_command_attack(world, selection.multi[i], target, add_waypoint, false);
    }
}

/** @param {!World.World} world
    @param {!GameObject} unit */
function do_unit_command_patrol(world, unit) {
    var patrol_ai_state = ai_state_values[gamedata['default_patrol_ai_state']];

    if(!unit.patrol) {
        // start the patrol - append new order sending unit back to start position
        var start_pos = unit.raw_pos();
        unit.new_order(world, {'state':patrol_ai_state,
                               'patrol_origin': 1,
                               'dest': [Math.floor(start_pos[0]),Math.floor(start_pos[1])]}, false);
        unit.state_dirty |= obj_state_flags.ORDERS;
    }

    var found_origin = false;
    for(var i = 0; i < unit.orders.length; i++) {
        var ord = unit.orders[i];
        ord['state'] = patrol_ai_state;
        unit.state_dirty |= obj_state_flags.ORDERS;
        if(ord['patrol_origin']) { found_origin = true; }
    }

    // make sure there is a patrol_origin in the path
    if(!found_origin && unit.orders.length >= 1) {
        unit.orders[unit.orders.length-1]['patrol_origin'] = 1;
    }

    unit.ai_state = patrol_ai_state;
    unit.patrol = true;
    unit.state_dirty |= obj_state_flags.PATROL;
}

/** @param {!World.World} world
    @param {number} j
    @param {number} i */
function unit_command_patrol(world, j, i) {
    if(!selection.unit || !selection.unit.is_mobile()) { return; }

    player.record_feature_use('unit_patrol_command');

    unit_command_move(world, j, i, true, true);

    do_unit_command_patrol(world, selection.unit);
    goog.array.forEach(selection.multi, function(obj) {
        do_unit_command_patrol(world, obj);
    });
}

/** @param {!World.World} world
    @param {!GameObject} unit */
function do_unit_command_make_aggressive(world, unit) {
    for(var i = 0; i < unit.orders.length; i++) {
        if(unit.orders[i]['state'] != ai_states.AI_ATTACK_MOVE &&
           unit.orders[i]['state'] != ai_states.AI_ATTACK_ANY) {
            unit.orders[i]['state'] = ai_states.AI_ATTACK_ANY;
        }

        unit.orders[i]['aggressive'] = true;
    }
    unit.state_dirty |= obj_state_flags.ORDERS;
    unit.apply_orders(world);
}

/** @param {!World.World} world */
function unit_command_make_aggressive(world) {
    if(!selection.unit || !selection.unit.is_mobile()) { return; }

    do_unit_command_make_aggressive(world, selection.unit);
    for(var i = 0; i < selection.multi.length; i++) {
        do_unit_command_make_aggressive(world, selection.multi[i]);
    }
}

/** @param {!World.World} world
    @param {number} j
    @param {number} i
    @param {boolean} use_amove
    @param {boolean} add_waypoint */
function unit_command_move(world, j, i, use_amove, add_waypoint) {
    if(!selection.unit || !selection.unit.is_mobile()) { return; }

    world.fxworld.add_under(new SPFX.ClickFeedback([j,i], [1,1,1,1], world.fxworld.now_time(), 0.15));

    if(!add_waypoint || selection.unit.orders.length < 2) {
        selection.unit.speak('destination');
    }

    var force_attack_move_for_tutorial = ((player.tutorial_state === 'move_rover_action') || (player.tutorial_state === 'wait_for_battle_finish'));
    if(force_attack_move_for_tutorial) { use_amove = true; }

    // automatically append a-move if path already contains some non-normal movement
    if(add_waypoint && selection.unit.orders.length > 0 && selection.unit.orders[selection.unit.orders.length-1]['state'] != ai_states.AI_MOVE) {
        use_amove = true;
    }

    var use_state;
    if(use_amove) {
        if(selection.unit.patrol) {
            use_state = ai_state_values[gamedata['default_patrol_ai_state']];
        } else {
            if(get_preference_setting(player.preferences, 'auto_unit_control_dmove') && !force_attack_move_for_tutorial) {
                use_state = ai_states.AI_DEFEND_MOVE;
            } else {
                use_state = ai_states.AI_ATTACK_MOVE;
            }
        }
    } else {
        use_state = ai_states.AI_MOVE;
    }
    var my_order = {'state': use_state,
                    'dest': [j,i]};

    // EXPERIMENTAL
    // when in hostile territory and on auto_unit_control, make all player-initiated movement aggressive
    // otherwise, cancel aggressive mode
    var aggressive = (world.base.base_landlord_id !== session.user_id) &&
        ((get_preference_setting(player.preferences, 'auto_unit_control') && !get_preference_setting(player.preferences, 'auto_unit_control_dmove')) ||
         (('deploy_ai_order' in selection.unit.spec) && selection.unit.spec['deploy_ai_order']['aggressive']) ||
         gamedata['client']['default_deploy_ai_order']['manual']['aggressive']
        );
    my_order['aggressive'] = !!aggressive;

    selection.unit.new_order(world, my_order, !add_waypoint);

    if(selection.multi.length > 0) {
        // formation movement referenced against selection.unit
        var origin = selection.unit.raw_pos();
        var FORMATION_RADIUS2 = 20*20; // how close units must be in order to be considered "in formation"

        for(var n = 0; n < selection.multi.length; n++) {
            if(selection.multi[n] === selection.unit) {
                continue;
            }
            var mydest = [j,i];
            var offset = vec_sub(selection.multi[n].raw_pos(), origin);
            if(vec_length2(offset) <= FORMATION_RADIUS2) {
                mydest = vec_add([j,i], offset);
                var ncells = world.base.ncells();
                mydest = [clamp(mydest[0], 0, ncells[0]-1),
                          clamp(mydest[1], 0, ncells[1]-1)];
                // check if the formation-movement destination is blocked. If so, just send it directly to dest
                mydest = vec_floor(mydest);
                if(world.astar_map.is_blocked(mydest)) {
                    mydest = [j,i];
                }
            }

            var form_order = goog.object.clone(my_order);
            form_order['dest'] = mydest;

            var form_aggressive = (world.base.base_landlord_id !== session.user_id) &&
                ((get_preference_setting(player.preferences, 'auto_unit_control') && !get_preference_setting(player.preferences, 'auto_unit_control_dmove')) ||
                 (('deploy_ai_order' in selection.multi[n].spec) && selection.multi[n].spec['deploy_ai_order']['aggressive']) ||
                 gamedata['client']['default_deploy_ai_order']['manual']['aggressive']
                );
            form_order['aggressive'] = !!form_aggressive;

            selection.multi[n].new_order(world, form_order, !add_waypoint);
        }
    }

    if(player.tutorial_state === 'move_rover_action') {
        tutorial_step_move_rover_action_command();
    }
}

/** @param {!GameObject} unit */
function unit_command_toggle_force_team(unit) {
    // (assumes we are running in AI base design mode)
    if(unit.force_team === null) {
        unit.force_team = 'attacker';
    } else {
        unit.force_team = null;
    }
    send_to_server.func(["CAST_SPELL", unit.id, "SET_FORCE_TEAM", unit.force_team]);
}



function on_textInput(e) {
    console.log('textInput '+e.data);
};

function on_pointer_lock_change(e) {
    if(document['webkitPointerLockElement'] === canvas) {
        console.log("POINTER LOCK ON");
        mouse_state.pointer_locked = true;
        mouse_state.pointer_lock_origin = [mouse_state.last_x, mouse_state.last_y];
    } else {
        console.log("POINTER LOCK OFF");
        mouse_state.pointer_locked = false;
        mouse_state.pointer_lock_origin = [-1,-1];
    }
};

function on_keypress(e) {
    if(e.which != 0 && e.charCode != 0) {
        var world = (session.has_world() ? session.get_draw_world() : null);

        //console.log('KEYPRESS ' + e.which);
        var str = String.fromCharCode(e.which);

        if(SPUI.keyboard_focus) {
            if(SPUI.keyboard_focus.onkeypress(e.which, str)) {
                // do not continue processing
                if(e.preventDefault) { e.preventDefault(); }
                return false;
            }
        }

        // WoW-like shortcut to focus chat
        if(str === '/' || str === 't') {
            if(global_chat_frame && global_chat_frame.is_visible()) {
                var w = global_chat_frame.widgets['input'];
                w.str = '';
                SPUI.set_keyboard_focus(w);
                if(e.preventDefault) { e.preventDefault(); }
                return false;
            }
        } else if(str === 'f') {
            fps_counter.show = !fps_counter.show;
        } else if(str === 'm' && world) {
            if(!selection.unit) { toggle_region_map(); }
        } else if(str === 'z' && player.is_developer() && world) {
            world.control_paused = !world.control_paused;
        } else if(str === 'l') {
            if(pointer_lock_supported) {
                if(!mouse_state.pointer_locked) {
                    canvas['webkitRequestPointerLock']();
                } else {
                    document['webkitExitPointerLock']();
                }
            }
        }
    }
    return true;
}

var key_unit_command_map = {
    //8: 'REMOVE_OBJECT', // backspace
    46: 'REMOVE_OBJECT', // delete key (only for AI base design)
    69: 'SPECIAL_ABILITY', // e E
    109: 'MOVE_UNIT', 77: 'MOVE_UNIT', // m M
    97: 'AMOVE_UNIT', 65: 'AMOVE_UNIT', // a A
    70: 'TOGGLE_FORCE_TEAM', // Shift-F (only for AI base design)
    115: 'STOP_UNIT', 83: 'STOP_UNIT', // s S
    112: 'PATROL_UNIT', 80: 'PATROL_UNIT', // p P
    114: 'MAKE_AGGRESSIVE', 82: 'MAKE_AGGRESSIVE' // r R
};

function on_keydown(e) {
    register_player_input();

    var code = e.keyCode;
    //console.log('KEYDOWN ' + code);
    var world = (session.has_world() ? session.get_draw_world() : null);

    // escape key to get out of dialogs/chat
    if(player.tutorial_state === "COMPLETE" && code === 27) {
        if(selection.ui) {
            if(selection.ui.modal || (selection.ui.user_data && selection.ui.user_data['dialog'])) {
                // if it's a dialog, ensure that the close button is available
                if(selection.ui.widgets && 'close_button' in selection.ui.widgets &&
                   selection.ui.widgets['close_button'].show && selection.ui.widgets['close_button'].state != 'disabled' &&
                   !find_dialog('ui_locker')) {
                    // ok it's safe to close the dialog
                    var btn = selection.ui.widgets['close_button'];
                    if(btn.bg_image) {
                        var sprite = /** @type {!GameArt.Sprite} */ (GameArt.assets[btn.bg_image].states[btn.state]);
                        if(sprite.audio) {
                            sprite.audio.play(client_time);
                        }
                    }
                    btn.onclick(btn);
                }
            } else if(selection.spellname) {
                if(selection.spellname == "DEPLOY_UNITS" && !session.has_deployed) {
                    selection.ui.destroy(); // if not in combat, reset unit count to zero but do NOT remove cursor
                } else {
                    // cancel targeted spell
                    change_selection_ui(null);
                    selection.spellname = null;
                }
            }
        } else {
            change_selection(null);
        }
        if(global_chat_frame && global_chat_frame.is_visible()) {
            if(SPUI.keyboard_focus === global_chat_frame.widgets['input']) {
                SPUI.set_keyboard_focus(null);
            }
        }

        if(e.preventDefault) { e.preventDefault(); }
        return false;
    }

    if(SPUI.keyboard_focus) {
        if(SPUI.keyboard_focus.onkeydown(code)) {
            if(e.preventDefault) { e.preventDefault(); }
            return false;
        }
        // skip unit commands and continue processing
        // EVEN IF SPUI does not consider the event "handled",
        // because if may produce a subsequent onkeypress event!
        return true;
    }

    if(code === 13) { // ENTER key
        var button = null;
        if(selection.ui && !g_ui_locker) {
            button = selection.ui.default_button || null;
            // hack - handle nested dialogs
            if(selection.ui.children) {
                for(var i = 0; i < selection.ui.children.length; i++) {
                    if(selection.ui.children[i].default_button) {
                        button = selection.ui.children[i].default_button;
                    }
                }
            }
        } else if(tutorial_root.children.length >= 1 && tutorial_root.children[0].default_button) {
            button = tutorial_root.children[0].default_button;
        }
        if(button && button.is_clickable() && button.onclick) {
            button.onclick(button);
            if(e.preventDefault) { e.preventDefault(); }
            return false;
        }

        if(world && world === session.get_real_world()) {
            // if build spell is armed, fire it
            if(selection.spellname == "BUILD") {
                do_build(screen_to_ortho([mouse_state.last_x, mouse_state.last_y]));
                if(e.preventDefault) { e.preventDefault(); }
                return false;
            }

            // if a building is under construction, offer to speed it up (not during tutorial)
            if(player.tutorial_state == "COMPLETE") {
                var obj = session.for_each_real_object(function(obj) {
                    if(obj.is_building() && obj.team == 'player' && obj.is_under_construction()) {
                        return obj;
                    }
                });
                if(obj) {
                    change_selection(obj);
                    invoke_speedup_dialog('speedup');
                    if(e.preventDefault) { e.preventDefault(); }
                    return false;
                }
            }
        }
    }

    // 0-9 control group keys
    if(player.tutorial_state === "COMPLETE" && code >= 48 && code <= 57) {
        var group = code - 48;
        //console.log('group '+group.toString()+' '+e.shiftKey+' '+e.ctrlKey);
        if(e.ctrlKey && !e.shiftKey) {
            control_group_define(group);
        } else if(e.ctrlKey && e.shiftKey) {
            control_group_add(group);
        } else if(e.shiftKey) {
            control_group_toggle(group);
        } else {
            control_group_activate(group);
        }
        // do not continue keypress processing
        if(e.preventDefault) { e.preventDefault(); }
        return false;
    }

    // left arrow 37 right arrow 39 up arrow 38 down arrow 40 pgup 33 pgdown 34
    /*
    if(player.tutorial_state === "COMPLETE") {
        var scroll = null;
        if(code == 37 || code == 38 || code == 33) {
            scroll = 'scroll_left';
        } else if (code == 39 || code == 40 || code == 34) {
            scroll = 'scroll_right';
        }
    }
    */

    // spacebar
    if(code == 32) {
        mouse_state.spacebar = true;
        // do not continue keypress processing
        if(e.preventDefault) { e.preventDefault(); }
        return false;
    }

    if(code in key_unit_command_map && key_unit_command_map[code] === 'SPECIAL_ABILITY' && session.has_attacked) {
        if(global_spell_icon) { global_spell_icon.pushed_key = true; }
    }

    return true; // continue on to keypress processing
}

function on_keyup(e) {
    var code = e.keyCode;
    //console.log('KEYUP ' + code);

    if(SPUI.keyboard_focus) { return true; } // event should have been handled already

    if(!session.has_world()) { return true; }
    var world = session.get_draw_world();

    if(world === session.get_real_world() && selection.unit && selection.unit.is_mobile()) {
        if(code in key_unit_command_map) {
            var cmd = key_unit_command_map[code];
            if(cmd === 'SPECIAL_ABILITY' && selection.unit.can_accept_commands()) {
                if(session.has_attacked || player.is_cheater) {
                    if(global_spell_icon) { global_spell_icon.pushed_key = false; }
                    selection.unit.use_special_ability(world);
                    for(var j = 0; j < selection.multi.length; j++) {
                        if(selection.multi[j] === selection.unit) { continue; }
                        selection.multi[j].use_special_ability(world);
                    }
                }
            } else if(cmd === 'STOP_UNIT' && selection.unit.can_accept_commands()) {
                var order = {'state': ai_states.AI_ATTACK_STATIONARY, 'aggressive': false};
                selection.unit.new_order(world, order, true);
                selection.unit.ai_threatlist = null; selection.unit.ai_threatlist_dirty = true;
                for(var i = 0; i < selection.multi.length; i++) {
                    selection.multi[i].new_order(world, order, true);
                    selection.multi[i].ai_threatlist = null; selection.multi[i].ai_threatlist_dirty = true;
                }
            } else if(cmd === 'MAKE_AGGRESSIVE' && selection.unit.can_accept_commands()) {
                unit_command_make_aggressive(world);
            } else if(cmd === 'REMOVE_OBJECT') {
                if(player.is_cheater) {
                    world.send_and_remove_object(selection.unit);
                    var temp = goog.array.clone(selection.multi); // send_and_remove mutates selection.multi
                    for(var i = 0; i < temp.length; i++) {
                        world.send_and_remove_object(temp[i]);
                    }
                }
            } else if(cmd === 'TOGGLE_FORCE_TEAM') {
                if(player.is_cheater) {
                    unit_command_toggle_force_team(selection.unit);
                    for(var i = 0; i < selection.multi.length; i++) {
                        if(selection.multi[i] === selection.unit) { continue; }
                        unit_command_toggle_force_team(selection.multi[i]);
                    }
                }
            } else if(selection.unit.can_accept_commands()) {
                // "arm" the spell for the next mousedown
                selection.spellname = cmd;
                var cursor;
                if(cmd === 'AMOVE_UNIT' || cmd === 'PATROL_UNIT') {
                    cursor = make_shoot_cursor();
                } else {
                    cursor = make_move_cursor();
                }
                change_selection_ui(cursor);
            }
            APMCounter.record_action();
            // do not continue keypress processing
            if(e.preventDefault) { e.preventDefault(); }
            return false;
        }
    }

    if(code == 32) { // spacebar
        if(mouse_state.has_dragged) {
            mouse_state.has_dragged = false;
            if(selection.multi.length > 1) {
                player.record_feature_use('drag_select');
            }
        }
        mouse_state.spacebar = false;
    } else if(code == 16) { // shift
        // get rid of move/amove/build cursors
        if(selection.spellname != null) {
            selection.spellname = null;
            change_selection_ui(null);
        }
    }

    return true;
}

function change_backdrop_music(new_backdrop_music) {
    if(new_backdrop_music != backdrop_music) {
        if(backdrop_music != null) {
            backdrop_music.unloop();
            if(GameArt.music_volume > 0) {
                backdrop_music.fadeOut(1.0);
            } else {
                backdrop_music.stop(client_time);
            }

            backdrop_music = null;
        }
        backdrop_music = new_backdrop_music;
        if(backdrop_music) {
            //backdrop_music.stop(client_time);

            if(GameArt.music_volume > 0) {
                backdrop_music.loop();

                // setTime causes audio to stop playing on Firefox
                if(spin_demographics['browser_name'] === 'Explorer') {
                    backdrop_music.setTime(0);
                    backdrop_music.play(client_time);
                }

                backdrop_music.fadeIn(1.5);
            }
        }
    }
}

var APMCounter = {
    start_time: -1,
    actions: 0
};
APMCounter.reset = function() {
    APMCounter.start_time = client_time;
    APMCounter.actions = 0;
};
APMCounter.record_action = function() { APMCounter.actions += 1; };
APMCounter.get = function() {
    if(APMCounter.start_time > 0) {
        return (60.0*APMCounter.actions)/(client_time - APMCounter.start_time);
    }
    return -1;
};

/** @constructor @struct */
var FPSCounter = function() {
    this.cur_fps = 0;
    this.last_time = 0;
    this.frame_count = 0;
    this.update_interval = 20; // # of frames between updates

    this.metric_interval = 3000; // # of seconds between framerate metric transmissions
    this.first_metric_interval = 60; // # of seconds after game start before metrics will be transmitted
    this.metric_wait = -1;
    this.last_metric = -1;
    this.show = false;
    this.transmit_metrics = false;
};

FPSCounter.prototype.get = function() {
    if(this.frame_count >= this.update_interval && FRAME_RATE_CAP >= 10) {
        this.frame_count = 0;
        this.cur_fps = this.update_interval / (client_time - this.last_time);
        this.last_time = client_time;

        if(this.transmit_metrics) {
            if(this.last_metric === -1) {
                this.last_metric = client_time;
                this.metric_wait = this.first_metric_interval;
            } else if((client_time - this.last_metric) >= this.metric_wait) {
                this.last_metric = client_time;
                this.metric_wait = this.metric_interval;
                metric_event('0960_framerate', add_demographics({'framerate':this.cur_fps,
                                                                 'framerate_cap':FRAME_RATE_CAP,
                                                                 'server_time_offset':server_time_offset,
                                                                 'canvas_width':canvas_width,
                                                                 'canvas_height':canvas_height,
                                                                 'canvas_oversample':canvas_oversample,
                                                                 'devicePixelRatio':window['devicePixelRatio'] || null
                                                                }));
            }
        }
    }
    this.frame_count += 1;
    return this.cur_fps;
};

var fps_counter = new FPSCounter();

function sprobe_init(cb) {
    var on_result = (function (_cb) { return function(probe) {
        metric_event('0961_sprobe_result', {'viewing_base_id':session.viewing_base.base_id, 'report':probe.report()});
        if(_cb()) { _cb(); }
    }; })(cb);
    var probe = new SProbe.ProbeRun(on_result,
                                    spin_server_host, spin_server_http_port, spin_server_ssl_port,
                                    spin_game_server_host, spin_game_server_snam, spin_game_server_http_port, spin_game_server_ssl_port,
                                    spin_game_server_ws_port, spin_game_server_wss_port,
                                    (fps_counter ? fps_counter.cur_fps : -1), canvas_width, canvas_height, canvas_oversample,
                                    window['devicePixelRatio'] || null);
    return probe;
}

var g_sprobe = null; // currently-running sprobe
function sprobe_run() {
    if(g_sprobe) { return; }
    g_sprobe = sprobe_init(function() { g_sprobe = null; });
    g_sprobe.go();
}

// last time draw() painted the screen *relative to client_time*
var last_draw_time = 0;

// force at least one canvas repaint to happen, regardless of FRAME_RATE_CAP
var forced_draw_timer = null;
function force_draw() {
    if(client_state != client_states.RUNNING && client_state != client_states.TIMED_OUT) {
        return;
    }
    if(!forced_draw_timer) {
        forced_draw_timer = window.setTimeout(function() {
            forced_draw_timer = null;
            do_draw();
        }, 1);
    }
};

function draw() {
    // update world time
    update_client_and_server_time();
    SPUI.time = client_time;
    GameArt.sync_time(client_time);

    //console.log('frame at '+client_time+' last_draw_time '+last_draw_time);

    // check how much time has elapsed since last draw()
    if((client_time - last_draw_time) < (1/FRAME_RATE_CAP)) {
        // don't draw faster than target frame rate - wait for next refresh instead
        var delay = (1 / FRAME_RATE_CAP) - (client_time - last_draw_time);
        //console.log('waiting for '+delay*1000+' ms');
        window['requestAnimFrame'](draw, canvas, delay*1000);
        return;
    } else {
        //console.log('doing draw');
    }
    last_draw_time = client_time;

    try {
        do_draw();
    } catch (e) {
        // kill any active dialogs, in case they are causing repeated errors
        change_selection(null);
        log_exception(e, 'do_draw');
    }

    flush_message_queue(false);

    window['requestAnimFrame'](draw, canvas, 1000 / FRAME_RATE_CAP);
}

// sort objects by z-order for drawing
function sort_scene_objects(a,b) {
    var atemp = a.draw_pos_cache;
    var pa = atemp[0], za = atemp[1];
    var btemp = b.draw_pos_cache;
    var pb = btemp[0], zb = btemp[1];
    if(za == zb) {
        // break ties to avoid Z-fighting
        if(pa[0] == pb[0]) {
            if(pa[1] == pb[1]) {
                return 0;
            }
            return (pa[1] < pb[1] ? -1 : 1);
        }
        return (pa[0] < pb[0] ? -1 : 1);
    }
    return (za < zb ? -1 : 1);
}

// apply the transformation matrix for drawing the playfield
function set_playfield_draw_transform(context) {
    if(view_is_zoomed() && session.has_world()) {
        // shift view so that view_pos puts center grid cell at middle of canvas
        var ncells = session.get_draw_world().base.ncells();
        context.transform(view_zoom, 0, 0, view_zoom,
                          -view_pos[0]*view_zoom + canvas_width_half,
                          -view_pos[1]*view_zoom + canvas_height_half - view_zoom*cellsize[1]*ncells[1]/2);
    }
}

/** @typedef {{text: string,
               pos: !Array.<number>,
               color: (string|null|undefined),
               drop_shadow: (boolean|undefined)}} */
var PlayfieldText = {};

function draw_playfield_text(text_list) {
    goog.array.forEach(text_list, function(text) {
        if(text.color) {
            ctx.save();
            ctx.fillStyle = text.color;
        }
        if(text.drop_shadow) {
            draw_centered_text_with_shadow(ctx, text.text, text.pos);
        } else {
            draw_centered_text(ctx, text.text, text.pos);
        }
        if(text.color) {
            ctx.restore();
        }
    });
}

function do_draw() {
    if(forced_draw_timer) { window.clearTimeout(forced_draw_timer); forced_draw_timer = null; }

    // snoop canvas_div.offsetLeft/Top in case the browser reflowed without us knowing
    if(gamedata['client']['canvas_div_offset_snoop_time'] > 0 && (client_time - canvas_div_offset_snoop_time > gamedata['client']['canvas_div_offset_snoop_time'])) {
        canvas_div_offset_snoop_time = client_time;
        canvas_div_offsetLeft = canvas_div.offsetLeft;
        canvas_div_offsetTop = canvas_div.offsetTop;
        //console.log("SNOOP "+canvas_div_offsetTop);

        // also snoop Facebook iframe coordinates
        if(spin_frame_platform == 'fb' && spin_facebook_enabled && gamedata['client']['facebook_iframe_resize_hack']) {
            fb_iframe_update(null);
        }
    }

    if(!ctx || !SPUI.desktop_font) {
        throw Error('do_draw() in invalid state: ctx '+(ctx ? 'OK' : '0')+' SPUI '+(SPUI.desktop_font ? 'OK': '0') + ' shutdown_in_progress '+SPINPUNCHGAME.shutdown_in_progress.toString()+' connect_time '+session.connect_time.toString());
    }

    // set default graphics state

    // Firefox craps out when you set the font on a context that's in an iframe in some (hidden?) states - if so, skip draw
    try {
        ctx.font = SPUI.desktop_font.str();
    } catch(e) {
        return;
    }

    ctx.fillStyle = "#ffffff";
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1;
    set_default_canvas_transform(ctx);

    if(backdrop_music && GameArt.music_volume > 0) {
        backdrop_music.check_delay_load();
    }

    var world = (session.has_world() ? session.get_draw_world() : null);
    if(world) {
        world.fxworld.set_time(client_time, world.combat_engine.cur_tick);
    }

    if(client_state == client_states.UNABLE_TO_LOGIN || SPINPUNCHGAME.client_death_sent) { // TIMED_OUT gets handled below
        kill_loading_screen();

        // clear background
        ctx.fillRect(0,0,canvas_width,canvas_height);

        // this will display the error message dialog
        SPUI.draw_all();
    } else if(client_state == client_states.LOADING ||
              client_art_state == client_art_states.DOWNLOADING_ESSENTIAL) {

        /** @type {string} to display loading progress in the GUI */
        var msg;

        if(client_state == client_states.LOADING) {
            var data = gamedata['strings']['connecting_to_server'];
            var index = Math.floor((client_time/data['interval']) % data['frames'].length);
            msg = data['frames'][index];
        } else {
            var progress;
            progress = GameArt.get_dl_progress_essential();
            msg = gamedata['strings']['loading_screen_loading'].replace('%pct',(100*progress).toFixed(0));
        }

        if(startup_div_shown) {
            document.getElementById('startup_msg').innerHTML = msg;
        } else {

        ctx.save();

        if(spin_frame_platform === 'bh') {
            // BH: clear to transparent
            ctx.clearRect(0,0,canvas_width,canvas_height);
        } else {
            // other platforms: clear to white
            ctx.fillRect(0,0,canvas_width,canvas_height);
        }

        ctx.fillStyle = '#ffffff';

        // draw "Loading..." screen

        // center image on canvas.
        var wh = [736,423]; // hard-coded image dimensions
        var x = Math.floor((canvas_width-wh[0])/2);
        var y = Math.floor((canvas_height-wh[1])/2);
        x = clamp(x, 0, canvas_width);
        y = clamp(y, 0, canvas_height);

        if(loading_screen_image.complete && loading_screen_image.width > 0) {
            try { // this sometimes fails on FireFox even if 'complete' is true
                ctx.drawImage(loading_screen_image, x, y, 736, 423);
            } catch (e) {}
            // use white text
        } else if(spin_frame_platform !== 'bh') {
            // black text
            ctx.fillStyle = "#000000";
        }

        // fails on FireFox due to ctx garbage collection
        try {
            ctx.font = "bold 15px sans-serif";
        } catch(e) {}

        /** @type {!Array<{str: string, xy: !Array<number>}>} */
        var text_to_draw = [];

        // beta message
        if(gamedata['strings']['loading_screen_beta']) {
            text_to_draw.push({str: gamedata['strings']['loading_screen_beta'], xy: [x+215, y+398]});
        }
        text_to_draw.push({str:msg, xy: [x+450, y+398]});

        // drop shadow
        ctx.save();
        ctx.fillStyle = '#000000';
        goog.array.forEach(text_to_draw, function(entry) {
            ctx.fillText(entry.str, entry.xy[0]+1, entry.xy[1]+1);
        });
        ctx.restore();

        // main text
        goog.array.forEach(text_to_draw, function(entry) {
            ctx.fillText(entry.str, entry.xy[0], entry.xy[1]);
        });
        ctx.restore();

        }

    } else if(client_state == client_states.RUNNING || client_state == client_states.TIMED_OUT) {
        kill_loading_screen();

        if(client_state == client_states.RUNNING && !visit_base_pending) {

        SPUI.dripper.activate(client_time, mouse_state.button); // pass current button state

        mouse_state.dripper.activate(client_time, [mouse_state.last_x, mouse_state.last_y]); // pass current cursor location

        // run deferred citizens update
        world.do_update_citizens(player);

        // run game simulation tick, if enough time has elapsed since last tick
        world.run_unit_ticks();

        // if enough time has elapsed, save combat damage states to server
        if(client_time - last_combat_save > gamedata['client']['combat_state_save_interval']) {
            last_combat_save = client_time;
            flush_dirty_objects({});
        }

        // try to free A* memory
        if(session.region && session.region.occupancy) { session.region.occupancy.cleanup(); }

        if(global_chat_frame) { update_chat_frame(global_chat_frame); }

        // if enough time has elapsed, send a ping message to the server
        if(client_state != client_states.TIMED_OUT) {
            if(!gamedata['client']['enable_ajax_longpoll'] && (client_time - last_server_ping > gamedata['client']['player_ping_interval'])) {
                last_server_ping = client_time;
                last_chat_ping = client_time;
                last_websocket_keepalive = client_time;
                send_to_server.func(["PING_PLAYER"]);
            } else if(desktop_dialogs['chat_frame'] && desktop_dialogs['chat_frame'].parent &&
                      (desktop_dialogs['chat_frame'].user_data['size'] === 'big') &&
                      (client_time - last_chat_ping > gamedata['client']['chat_ping_interval'])) {
                last_chat_ping = client_time;
                last_websocket_keepalive = client_time;
                send_to_server.func(["PING_CHAT", player.chat_seen, 'chat_ping']);
            } else if(the_websocket && gamedata['client']['websocket_keepalive_interval'] > 0 &&
                      (client_time - last_websocket_keepalive > gamedata['client']['websocket_keepalive_interval'])) {
                last_chat_ping = client_time;
                last_websocket_keepalive = client_time;
                send_to_server.func(["PING_CHAT", player.chat_seen, 'websocket_keepalive']);
            }

            // check if we should be sending screenshots for analysis
            upload_screen_capture_check();
        }

        // send any pending user/alliance queries
        PlayerCache.launch_batch_queries(client_time, false);
        AllianceCache.launch_batch_queries();

        // perform squad movement
        player.advance_squads();

        // if in battle, keep comparing client clock speed to server
        if(session.has_deployed) {
            SPClockRace.launch();
        }

        // send lock state query
        if(!session.home_base && !session.has_attacked &&
           (!session.viewing_ai || session.is_remote_base()) &&
           !player.cooldown_active('lock_state_poll')) {
            player.cooldown_client_trigger('lock_state_poll', gamedata['lock_state_poll_cooldown']+1);
            send_to_server.func(["POLL_BASE_LOCK_STATE", session.viewing_base.base_type, session.viewing_base.base_id]);
        }

        // check if we need to send a keepalive to the proxy server
        if(spin_game_direct_connect &&
           (gamedata['client']['proxy_keepalive_interval'] > 0) &&
           (client_time - last_proxy_keepalive > gamedata['client']['proxy_keepalive_interval'])) {
            // send proxy keepalive regardless of input, since this is necessary to prevent login locking issues
            // the game server will take care of terminating idle sessions
            if(true || input_since_last_proxy_xmit) {
                input_since_last_proxy_xmit = false;
                last_proxy_keepalive = client_time;
                send_proxy_keepalive();
            }
        }

        check_battle_outcome();

        if(session.has_attacked && session.attack_finish_time > 0 && server_time >= session.attack_finish_time) {
            // force the attack to conclude
            session.set_attack_finish_time(-1);
            visit_base_after_attack();
        } else if(session.incoming_attack_time > 0 && server_time >= session.incoming_attack_time) {
            // tell server to spawn units (if the server hasn't gotten around to it yet)
            start_incoming_attack();
        } else if(session.incoming_attack_wave_time > 0 && server_time >= session.incoming_attack_wave_time) {
            if(!session.incoming_attack_wave_pending) {
                session.incoming_attack_wave_pending = true;
                send_to_server.func(["NEXT_AI_ATTACK_WAVE"]);
            }
        } else {
            // fire pending notification(s) - one at a time until a GUI dialog appears
            while(notification_queue.pending() && (selection.ui === null || (selection.ui.user_data && selection.ui.user_data['dialog']=='region_map_dialog')) &&
                  (!session.has_attacked || (session.viewing_base.base_type == 'quarry' && session.viewing_base.base_landlord_id == session.user_id))) {
                // set minimum priority to 200 for notifications to fire during tutorial
                if(!notification_queue.fire_next(player.tutorial_state !== "COMPLETE" ? NotificationQueue.TUTORIAL_MIN_PRIO-1 : -Infinity)) { break; }
            }
        }

        // trigger the daily attack sequence
        if(player.daily_attack_time > 0 &&
           session.home_base && !session.has_attacked && !session.incoming_attack_pending() &&
           client_time >= player.daily_attack_time && player.tutorial_state === "COMPLETE") {
            player.daily_attack_time = -1;
            send_to_server.func(["START_DAILY_ATTACK"]);
        }

        player.update_quest_cache();

        // update quest tips UI
        if(selection.ui_change_time > 0) {
            if(client_time - selection.ui_change_time >= ((player.quest_tracked ? player.quest_tracked['ui_quiet_time'] : null) || gamedata['client']['ui_quiet_time']) &&
               ((player.quest_tracked && player.quest_tracked['ui_quiet_time'] === 0) || !notification_queue.pending()) &&
               synchronizer.is_globally_in_sync()) {
                selection.ui_change_time = -1;
                player.quest_tracked_dirty = true;
            }
        }

        if(player.quest_tracked_dirty) {
            player.quest_tracked_dirty = false;
            player.quest_root.clear();
            player.quest_landscape_arrow = null;
            if(player.quest_tracked && player.tutorial_state === "COMPLETE" &&
               (('tips' in player.quest_tracked) || player.quest_tracked['force_claim']) &&
               ((player.quest_tracked && player.quest_tracked['ui_quiet_time'] === 0) || !notification_queue.pending()) &&
               !session.is_replay() &&
               (session.home_base || player.quest_tracked['tips_in_enemy_base'])) {

                var can_complete = player.can_complete_quest(player.quest_tracked);
                if(can_complete && !selection.ui && player.quest_tracked_complete_time < 0 && player.quest_tracked['force_claim']) {
                    // pop up the missions dialog after a timeout to force claiming
                    player.quest_tracked_complete_time = client_time + player.get_any_abtest_value('ui_quest_complete_pop_time', gamedata['client']['ui_quest_complete_pop_time']);
                }

                var missions_dialog = ((selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'missions_dialog') ? selection.ui : null);

                // note: wait for missions dialog animation to finish before running tips_in_missions_dialog
                var fx_time = (missions_dialog && missions_dialog.widgets['glow'].show) ? missions_dialog.widgets['glow'].fx_time_remaining() : -1;
                if(player.quest_tracked['tips_in_missions_dialog'] && (fx_time > 0)) {
                    selection.ui_change_time = client_time + fx_time;
                } else if(player.quest_tracked['tips'] && (!can_complete || player.quest_tracked['tips_when_complete']) && (!session.has_attacked || player.quest_tracked['tips_in_combat'])) {
                    // display tips
                    execute_logic(player.quest_tracked['tips']);
                }

                // if missions dialog is up and pointing to the tracked mission, show arrow pointing to either "Accept" or "Claim"
                if(missions_dialog) {
                    var selected_quest = missions_dialog.user_data['quest_list'][missions_dialog.user_data['selected_row']];

                    // if the Missions dialog is showing the currently-tracked quest, show arrow to EITHER "Accept" OR "Claim"
                    if(selected_quest['force_claim'] && (selected_quest === player.quest_tracked) && (!player.quest_tracked['tips_in_missions_dialog'] || player.can_complete_quest(selected_quest))) {
                        read_consequent({'consequent':'TUTORIAL_ARROW',
                                         'arrow_type':'button',
                                         'direction':'up',
                                         'dialog_name':'missions_dialog',
                                         'widget_name':'claim_button'}).execute();
                        // AND disable/hide close button
                        if(selected_quest['force_claim']) {
                            missions_dialog.widgets['close_button'].show = false;
                            missions_dialog.widgets['messages_button'].state = 'disabled';
                        }
                    }
                }
            }
        }

        if(session.home_base && player.quest_tracked && player.quest_tracked_complete_time > 0 &&
           client_time >= player.quest_tracked_complete_time && !selection.ui && !notification_queue.pending() && !session.is_replay()) {
            player.quest_tracked_complete_time = -1;
            if(player.can_complete_quest(player.quest_tracked)) {
                var method = player.get_any_abtest_value('on_quest_tips_complete', gamedata['client']['on_quest_tips_complete'] || 'missions_dialog');
                if(method == 'quest_bar') {
                    read_consequent({'consequent':'TUTORIAL_ARROW',
                                     'arrow_type':'button',
                                     'direction':'up', // XXX left?
                                     'dialog_name':'quest_bar',
                                     'widget_name':'frame0'}).execute();
                } else {
                    invoke_missions_dialog(true);
                    player.quest_tracked_dirty = true;
                }
            }
        }

        } // END only do these if actually running, not timed out or waiting for session change

        var powerfac = world.base.power_factor();

        if(mouse_state.hovering_over && mouse_tooltip) {
            mouse_tooltip.activation_check();
        }

        // adjust view_pos for forced scrolling
        force_scroll_eval();

        // adjust view_pos according to shake
        var shake = world.fxworld.get_camera_shake();
        var dx = shake[0], dy = shake[1];
        if(dx != 0 || dy != 0) {
            view_pos[0] += shake[0]/view_zoom;
            view_pos[1] += shake[1]/view_zoom;
        }

        view_pos[0] = clamp(view_pos[0], view_limits[0][0], view_limits[0][1]);
        view_pos[1] = clamp(view_pos[1], view_limits[1][0], view_limits[1][1]);

        if(view_is_zoomed()) {
            // draw space is playfield space
            view_roi = [screen_to_playfield([0,0]), screen_to_playfield([canvas_width,canvas_height])];
        } else {
            // quantize view_pos to pixels when not zoomed, to avoid drawing at non-integer pixel coordinates
            view_pos = draw_quantize(view_pos);
            view_roi = [[0,0],[canvas_width,canvas_height]]; // draw space is screen space
        }

        // keep track of whether any enemy units are on-screen for displaying the direction arrow
        var any_enemy = false, any_enemy_onscreen = false;

        /** @type {GameObject|null} */
        var offscreen_enemy_unit = null;

        // when intensive GUI dialogs are up, skip drawing playfield objects for speed
        var draw_playfield_objects = true;
        if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'region_map_dialog') {
            draw_playfield_objects = false;
        }

        if(1) {
            // draw playfield (zoomed within these braces)
            ctx.save();
            set_playfield_draw_transform(ctx);

            // when zoomed out, force image smoothing ON for nice downsampling
            // (this pushes it onto the stack, overriding the global setting from on_resize_game() just for the playfield)
            // really this should be set on a sprite-by-sprite basis to detect minification, a la OpenGL
            if(view_zoom < 1) {
                ctx['imageSmoothingEnabled'] = true;
            }

            /** @type {!Array.<!PlayfieldText>} */
            var playfield_text_list = [];

            // draw backdrop
            if(get_query_string('nobackdrop') === '1') {
                Backdrop.draw_blank();
                if(world.base) {
                    Backdrop.draw_area_bounds(world.base.ncells());
                }
            } else {
                playfield_text_list = playfield_text_list.concat(
                    Backdrop.draw(world.base,
                                  world.objects,
                                  (world.base === null || world.base.base_id === player.home_base_id),
                                  (world.base && (world.base.base_landlord_id === session.user_id)),
                                  draw_playfield_objects)
                );
            }

            // draw map grid
            if(PLAYFIELD_DEBUG_DRAW) {
                draw_debug_map(world);
            }

            if(draw_playfield_objects) {
                // draw special effects
                world.fxworld.draw_under();

                // draw flying unit shadows
                world.objects.for_each(function(obj) { draw_shadow(world, obj); });

                // prepare phantom objects for drawing and draw shadows if necessary
                var phantom_objects = world.fxworld.get_phantom_objects(world);
                goog.array.forEach(phantom_objects, function(obj) {
                    obj.update_draw_pos(world);
                    draw_shadow(world, obj);
                    if(obj.team === 'enemy') { // special case for enemy deployment markers
                        draw_selection_highlight(world, obj, 'enemy');
                    }
                });

                // draw selection
                if(selection.unit && selection.unit.id &&
                   selection.unit.id !== GameObject.DEAD_ID && selection.unit.id !== GameObject.VIRTUAL_ID) {
                    draw_selection_highlight(world, selection.unit);
                }
                for(var i = 0; i < selection.multi.length; i++) {
                    if(selection.multi[i] !== selection.unit && selection.multi[i].id &&
                       selection.multi[i].id !== GameObject.DEAD_ID && selection.multi[i].id !== GameObject.VIRTUAL_ID) {
                        draw_selection_highlight(world, selection.multi[i]);
                    }
                }

                // draw highlights on certain non-selected units e.g. to indicate team membership
                world.objects.for_each(function(obj) {
                    // highlight enemy units
                    if(session.has_attacked && obj.is_mobile() && obj.team != 'player' && !obj.is_destroyed() &&
                       (!obj.spec['cloaked'] || !obj.is_invisible())) {
                        draw_selection_highlight(world, obj);

                    } else if(!session.has_attacked && (obj.force_team === 'attacker' || (!session.home_base && !session.viewing_base.deployment_allowed && obj.team === 'player'))) {
                        draw_selection_highlight(world, obj, 'force_team:attacker');
                    }
                });

                if(!selection.ui && !session.has_attacked && mouse_state.hovering_over && mouse_state.hovering_over.is_building() && mouse_state.hovering_over.team == 'player') {
                    draw_selection_highlight(world, mouse_state.hovering_over, 'hover');
                }

                // if mouse is hovering over a turret and there is no other UI up, draw all turret ranges
                /*
                  if(!selection.ui &&
                  mouse_state.hovering_over &&
                  mouse_state.hovering_over.is_building()) {
                  var range = mouse_state.hovering_over.weapon_range()[1];
                  if(range > 0) {
                  draw_turret_ranges(world, null);
                  }
                  }
                */

                // draw units and buildings in sorted Z-order
                var scene = [];

                world.objects.for_each(function(obj) {
                    if(!obj.spec['is_scenery'] || !obj.spec['draw_flat']) {
                        obj.update_draw_pos(world);
                        scene.push(obj);
                    }
                });
                goog.array.forEach(phantom_objects, function(obj) {
                    scene.push(obj);
                });
                scene.sort(sort_scene_objects);

                for(var i = 0; i < scene.length; i++) {
                    var obj = scene[i];
                    if(obj.is_mobile()) {
                        var visible = draw_unit(world, obj);
                        if(obj.team === 'enemy' && !obj.is_destroyed()) {
                            any_enemy = true;
                            if(visible) {
                                any_enemy_onscreen = true;
                            } else {
                                offscreen_enemy_unit = obj;
                            }
                        }
                    } else if(obj.is_building() || obj.is_inert()) {
                        var newtext = draw_building_or_inert(world, obj, powerfac);
                        if(newtext.length > 0) {
                            playfield_text_list = playfield_text_list.concat(newtext);
                        }
                    }
                }

                // draw special effects
                world.fxworld.draw_over();

                draw_playfield_text(playfield_text_list);

                // draw A* debug info
                if(PLAYFIELD_DEBUG) {
                    draw_debug_astar_paths(world);
                }

            } // END draw playfield objects

            ctx.restore();
        } // END draw playfield

        draw_drag_selection();

        // draw a transparent black rect over the screen to simulate darkened lighting
        if(world.base && ('light_level' in world.base.base_climate_data) && (SPFX.detail >= 2) && draw_playfield_objects) {
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,'+(1-world.base.base_climate_data['light_level']).toString()+')';
            ctx.fillRect(0,0,canvas_width,canvas_height);
            ctx.restore();
        }

        //console.log('any '+any_enemy+' any_onscreen' +any_enemy_onscreen+' offscreen_enemy_unit '+!!offscreen_enemy_unit);

        var arrow_pos = null;
        if(any_enemy && !any_enemy_onscreen && offscreen_enemy_unit) {
            arrow_pos = offscreen_enemy_unit.interpolate_pos(world);
        } else if(session.incoming_attack_pending() && session.incoming_attack_direction && session.incoming_attack_direction != 'tutorial') {
            var spawn_location = gamedata['ai_attacks_client']['directions'][session.incoming_attack_direction];
            // exaggerate spawn_location's distance from the middle of the map in order to force it offscreen
            var ncells = world.base.ncells();
            arrow_pos = [ncells[0]*(5*(spawn_location[0]-0.5)+0.5), ncells[1]*(5*(spawn_location[1]-0.5)+0.5)];
        } else if(player.quest_landscape_arrow) {
            // show white arrow pointing towards the tutorial arrow
            var loc = player.quest_landscape_arrow.user_data['reticle_loc'];
            if(loc) { arrow_pos = loc; }
        }

        if(!offscreen_unit_arrow) {
            offscreen_unit_arrow = new SPFX.OffscreenArrow();
            world.fxworld.add(offscreen_unit_arrow);
        }
        offscreen_unit_arrow.reset(arrow_pos);

        var fps = fps_counter.get();
        // draw developer-only FPS counter and art progress display
        if(1) {
            var origin = [5, canvas_height-30];
            var btm = desktop_dialogs['desktop_bottom'];
            if(btm) {
                origin = [btm.xy[0]+10, btm.xy[1]- (session.home_base ? 33 : 120)];
            }
            // draw nonessential art download progress (only for first minute though)
            if(client_art_state != client_art_states.DONE && (player.is_developer() || (client_time - session.connect_time < 60.0))) {
                ctx.fillText("Downloading ("+(100*GameArt.get_dl_progress_all()).toFixed(0)+"%)...", origin[0], origin[1]);
            }
            if(fps_counter.show) {
                var lines = [];
                lines.push('Performance Info: (Press "F" key to hide)');
                lines.push('FPS: '+fps.toFixed(2)+' (limit '+FRAME_RATE_CAP.toString()+')');
                if(USING_REQUESTANIMATIONFRAME) {
                    lines.push("using requestAnimationFrame()");
                } else {
                    lines.push("using window.setTimeout("+LAST_ANIM_FRAME_TIMEOUT.toFixed(0)+"ms)");
                }
                lines.push('Client/server clock offset: '+(-1000*server_time_offset).toFixed(0)+'ms');
                lines.push('Combat tick: '+session.get_real_world().combat_engine.cur_tick.get().toString());
                lines.push('Retransmit buffer size: client '+retrans_buffer.length().toFixed(0)+'/'+gamedata['client']['ajax_message_buffer'].toFixed(0)+' server est '+(ajax_next_serial - 2 - ajax_last_ack).toFixed(0));
                ctx.save();
                var fsize = 13;
                ctx.font = SPUI.make_font(fsize, fsize+6, 'thick').str();
                goog.array.forEach(lines, function(line, y) {
                    ctx.fillText(line, origin[0], origin[1] + 18 + (fsize+6) * y);
                });
                ctx.restore();
            }
        }

        // draw UI elements
        SPUI.draw_all();

        // draw tutorial UI elements
        if(player.tutorial_state != "COMPLETE" && client_state == client_states.RUNNING && !player.tutorial_hold) {
            var data = gamedata['tutorial'][player.tutorial_state];
            if('bg_fill_color' in data) {
                var col = data['bg_fill_color'];
                var color = new SPUI.Color(col[0], col[1], col[2], col[3]);
                ctx.fillStyle = color.str();
                ctx.fillRect(0,0,canvas_width,canvas_height);
            }
        }
        player.quest_root.draw([0,0]);
        tutorial_root.draw([0,0]);

        // draw UI special effects
        world.fxworld.draw_ui();

        // draw active tooltip on top of everything else
        SPUI.draw_active_tooltip();

        // XXX temp - draw mouse location for debugging purposes
        if(get_query_string('show_mouse_loc') === '1') {
            ctx.save();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(0,255,0,1.0)';
            ctx.beginPath();
            ctx.arc(mouse_state.last_x, mouse_state.last_y, 6, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.restore();
        }

        // draw synthetic cursor
        if(mouse_state.pointer_locked) {
            ctx.save();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(0,255,0,1.0)';
            ctx.beginPath();
            ctx.arc(mouse_state.pointer_lock_origin[0], mouse_state.pointer_lock_origin[1], 6, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.restore();
        }

    } // END client_state == RUNNING

    // once first frame renders successfully, clear the watchdog timer
    if(SPINPUNCHGAME.watchdog_timer) {
        window.clearTimeout(SPINPUNCHGAME.watchdog_timer);
        SPINPUNCHGAME.watchdog_timer = null;
    }
}

// check a building for "idleness" ("can produce", "can manufacture", "can research", etc)
Building.prototype.get_idle_state = function() {
    if(this.spec['worth_less_xp']) { return null; } // exclude barriers
    if(this.is_destroyed()) { return null; }
    if(this.is_damaged() || this.is_upgrading() || this.is_under_construction() || this.is_enhancing() || this.is_removing()) { return null; }

    if(this.idle_state_cache === null || (this.idle_state_cache_valid_until > 0 && client_time > this.idle_state_cache_valid_until)) {
        // note: assumes get_idle_state_advanced/legacy() never return null
        if(player.get_any_abtest_value('idle_icon_type', gamedata['client']['idle_icon_type'] || 'old') == 'advanced') {
            this.idle_state_cache = this.get_idle_state_advanced(); // new SuperCell-like version
        } else {
            this.idle_state_cache = this.get_idle_state_legacy(); // old SpinPunch version
        }
        this.idle_state_cache_valid_until = -1;

        // for harvesters, invalidate a null cache every idle period in case its contents climb above threshold
        if(this.idle_state_cache['state'] === null && this.is_producer() && (this.produce_start_time > 0 && this.produce_rate > 0)) {
            this.idle_state_cache_valid_until = client_time + (gamedata['client']['harvester_idle_seconds'] || 60);
        }
    }

    // harvester sync gets handled outside of the cache since it needs low latency
    if(this.is_producer()) {
        if(!synchronizer.is_in_sync(session.quarry_harvest_sync_marker)) {
            if(session.region.data && session.region.refresh_progress() >= 0) {
                return {'state': 'harvest_in_progress_pct', 'can_upgrade': this.idle_state_cache['can_upgrade'],
                        's_replace': (100.0*Math.min(session.region.refresh_progress(), 0.99)).toFixed(0)};
            } else {
                return {'state': 'harvest_in_progress', 'can_upgrade': this.idle_state_cache['can_upgrade']};
            }
        } else if(!this.is_in_sync()) {
            return {'state': 'harvest_in_progress', 'can_upgrade': this.idle_state_cache['can_upgrade']}; // XXX could be out of sync for other reasons!
        }
    }

    // generic "Working..." message
    if(!this.is_in_sync() && !this.idle_state_cache['state']) { return {'state': 'pending', 'can_upgrade': this.idle_state_cache['can_upgrade']}; }

    return this.idle_state_cache;
};

Building.prototype.get_idle_state_legacy = function() {
    var draw_idle_icon = null;
    var draw_idle_icon_s = null;

    if(this.is_producer()) {
        var contents = this.interpolate_contents();
        var threshold = (this.produce_start_time > 0 && this.produce_rate > 0 ? Math.max(2, Math.floor((this.produce_rate/3600.0) * (gamedata['client']['harvester_idle_seconds'] || 60))) : -1);
        var resname = null;
        for(var res in gamedata['resources']) {
            if(('produces_'+res) in this.spec) {
                resname = res; break;
            }
        }
        if(contents >= this.get_production_capacity()) {
            draw_idle_icon = 'harvest_'+resname+'_full';
        } else if(threshold > 0 && contents >= threshold) {
            draw_idle_icon = 'harvest_'+resname;
        }
    } else if(this.is_storage() && this.spec['name'] != gamedata['townhall']) {
        // fullness state
        var resname = null;
        for(var res in gamedata['resources']) {
            if(('storage_'+res) in this.spec) {
                resname = res; break;
            }
        }
        if(resname) {
            var fullness = get_storage_fullness(resname);
            if(fullness >= 1) { draw_idle_icon = 'full'; }
        }
    } else if(this.is_factory() && !this.is_manufacturing()) {
        // do not show icon if all units this building can manufacture have a quantity limit and are already in the army
        var all_limited = true;
        var count_by_specname = null;
        for(var uspecname in gamedata['units']) {
            var uspec = gamedata['units'][uspecname];
            if(uspec['manufacture_category'] == this.spec['manufacture_category']) {
                if(!uspec['limit']) {
                    all_limited = false;
                    break;
                } else {
                    if(count_by_specname === null) {
                        count_by_specname = player.get_army_unit_count_by_specname();
                    }
                    if((count_by_specname[uspecname]||0) < uspec['limit']) {
                        all_limited = false;
                        break;
                    }
                }
            }
        }
        if(!all_limited) {
            var cur_count = player.get_army_unit_count_by_specname();
            var space_usage = player.get_army_space_usage_by_squad();
            if(space_usage['ALL'] < 0.9*player.stattab['total_space']) { draw_idle_icon = 'manufacture'; }
        }
    } else if(this.is_researcher()) {
        if(!this.is_researching()) { draw_idle_icon = 'research'; }
    } else if(this.is_crafter()) {
        if((!this.is_crafting() || this.crafting_progress_one() < 0) && !(this.is_emplacement() && this.turret_head_item()) && !(this.is_trapped_barrier() && this.barrier_trap_item()) && !(this.is_armed_building() && this.building_weapon_item()) && !(this.is_armed_townhall() && this.townhall_weapon_item())) {
            var crafter_cats = this.spec['crafting_categories'];
            goog.array.forEach(this.spec['crafting_categories'], function(cat) {
                if(cat && Array.isArray(cat)){
                    crafter_cats = this.get_leveled_quantity(this.spec['crafting_categories']);
                }
            }, this);
            for(var i = 0; i < crafter_cats.length; i++) {
                var catname = crafter_cats[i];
                var cat = gamedata['crafting']['categories'][catname];
                if(catname == 'mines') {
                    if(!player.all_minefields_armed()) {
                        draw_idle_icon = cat['idle_state'] || 'craft';
                        break;
                    } else {
                        continue;
                    }
                }
                draw_idle_icon = cat['idle_state'] || 'craft';
                if(draw_idle_icon == 'fish') {
                    if(player.cooldown_active('fish_slate_assigned')) {
                        // show no idle icon if all available fishing SKUs are exhausted
                        if(!goog.object.findKey(gamedata['crafting']['recipes'], function(recipe) {
                            return (recipe['crafting_category'] == 'fishing' && read_predicate(recipe['show_if']).is_satisfied(player, null));
                        })) {
                            draw_idle_icon = null;
                        }
                    }
                }
                break;
            }
        } else if(this.crafting_progress_one() < 0) {
            /* draw_idle_icon = 'craft_done'; */
        }

        if((this.is_emplacement() && this.turret_head_item()) || (this.is_security_node() && this.security_node_item()) || (this.is_trapped_barrier() && this.barrier_trap_item()) || (this.is_armed_building() && this.building_weapon_item()) || (this.is_armed_townhall() && this.townhall_weapon_item())){ // assumes mounted weapon recipients are crafters
            var item = null;
            var mounted_weapon_idle_icon = null;
            if(this.is_emplacement()) {
                item = this.turret_head_item();
                mounted_weapon_idle_icon = 'under_leveled_turret_head';
            } else if(this.is_security_node()) {
                item = this.security_node_item();
                mounted_weapon_idle_icon = 'under_leveled_security_node';
            }  else if(this.is_trapped_barrier()) {
                item = this.barrier_trap_item();
                mounted_weapon_idle_icon = 'under_leveled_barrier_trap';
            } else if(this.is_armed_building()) {
                item = this.building_weapon_item();
                mounted_weapon_idle_icon = 'under_leveled_building_weapon';
            } else if(this.is_armed_townhall()) {
                item = this.townhall_weapon_item();
                mounted_weapon_idle_icon = 'under_leveled_townhall_weapon';
            }
            if (!(mounted_weapon_idle_icon in gamedata['strings']['idle_buildings'])) {
                throw Error('Icon ' + mounted_weapon_idle_icon + ' missing from gamedata');
            }
            if(item) {
                var item_spec = ItemDisplay.get_inventory_item_spec(item['spec']);

                if('associated_tech' in item_spec) {
                    // check if our tech level for this item is above its own level
                    var item_level = ItemDisplay.get_inventory_item_level(item);
                    var tech_level = player.tech[item_spec['associated_tech']] || 0;
                    if(tech_level > item_level) {
                        draw_idle_icon = mounted_weapon_idle_icon;
                    }
                }
            }
        }
    } else if(this.spec['name'] === gamedata['alliance_building']) {
        if(!session.is_in_alliance()) {
            if(!player.cooldown_active('alliance_deserter')) {
                var pr = gamedata['predicate_library']['alliance_join_requirement'];
                if(read_predicate({'predicate':'LIBRARY','name':'alliance_join_requirement'}).is_satisfied(player, null)) {
                    draw_idle_icon = 'join_alliance';
                } else if(pr['predicate'] == 'BUILDING_LEVEL' && pr['building_type'] === this.spec['name'] && this.level < pr['trigger_level']) {
                    draw_idle_icon = 'upgrade';
                }
            }
        } else {
            if(player.unit_donation_enabled()) {
                var spell = gamedata['spells']['REQUEST_UNIT_DONATION'];
                var togo = player.cooldown_togo(spell['cooldown_name']);
                if(player.donated_units_space() < player.donated_units_max_space() && (togo <= 0)) {
                    draw_idle_icon = 'request_unit_donation';
                }
            }
        }
    }

    // lottery takes priority over others
    if(this.is_lottery_building()) {
        var state = player.get_lottery_state(this);
        if((state.can_scan && state.next_scan_method != 'paid') || !state.on_cooldown) {
            draw_idle_icon = 'lottery_scan';
        }
    }

    return {'state': draw_idle_icon,
            's_replace': draw_idle_icon_s,
            'can_upgrade': false};
};

Building.prototype.get_idle_state_advanced = function() {
    var draw_idle_icon = null;
    var draw_idle_icon_s = null;
    var can_upgrade = false;

    // check for upgradeability
    if((!player.foreman_is_busy() || (this.time_until_finish() <= 0 && gamedata['foreman_ignore_zero_time_building'])) && this.time_until_finish() < 0 && this.level < this.get_max_ui_level()) {
        var req = get_leveled_quantity(this.spec['requires']||null, this.level+1);
        if(req && !read_predicate(req).is_satisfied(player, null)) {
            // cannot upgrade due to requirement predicate
        } else {
            // check minimum resource amounts
            can_upgrade = true;
            for(var res in gamedata['resources']) {
                var cost = get_leveled_quantity(this.spec['build_cost_'+res] || 0, this.level+1);
                if(cost < 0) {
                    // Use Resources is not allowed - do not show arrow
                    can_upgrade = false;
                    break;
                } else if(player.resource_state[res][1] < cost) {
                    // cannot upgrade
                    can_upgrade = false;
                    break;
                }
            }
        }
    }

    // check for idleness
    if(this.is_producer()) {
        var contents = this.interpolate_contents();
        var threshold = (this.produce_start_time > 0 && this.produce_rate > 0 ? Math.max(2, Math.floor((this.produce_rate/3600.0) * (gamedata['client']['harvester_idle_seconds'] || 60))) : -1);
        var resname = null;
        for(var res in gamedata['resources']) {
            if(('produces_'+res) in this.spec) {
                resname = res; break;
            }
        }
        if(contents >= this.get_production_capacity()) {
            draw_idle_icon = 'harvest_'+resname+'_full';
        } else if(threshold > 0 && contents >= threshold) {
            draw_idle_icon = 'harvest_'+resname;
        }
    } else if(this.is_storage() && this.spec['name'] != gamedata['townhall']) {
        // fullness state
        var resname = null;
        for(var res in gamedata['resources']) {
            if(('storage_'+res) in this.spec) {
                resname = res; break;
            }
        }
        if(resname) {
            var fullness = get_storage_fullness(resname);
            if(fullness >= 1) { draw_idle_icon = 'full'; }
        }
    } else if(this.is_factory() && !this.is_manufacturing()) {
        // do not show icon if all units this building can manufacture have a quantity limit and are already in the army
        var all_limited = true;
        var count_by_specname = null;
        for(var uspecname in gamedata['units']) {
            var uspec = gamedata['units'][uspecname];
            if(uspec['manufacture_category'] == this.spec['manufacture_category']) {
                if(!uspec['limit']) {
                    all_limited = false;
                    break;
                } else {
                    if(count_by_specname === null) {
                        count_by_specname = player.get_army_unit_count_by_specname();
                    }
                    if((count_by_specname[uspecname]||0) < uspec['limit']) {
                        all_limited = false;
                        break;
                    }
                }
            }
        }
        if(!all_limited) {
            var space_usage = player.get_army_space_usage_by_squad();
            if(space_usage['ALL'] < player.stattab['total_space']) {
                for(var specname in gamedata['units']) {
                    var spec = gamedata['units'][specname];

                    if(spec['manufacture_category'] == this.spec['manufacture_category']) {
                        var level = unit_unlock_level(specname);
                        if(level > 0) {
                            var pred_ok = true;
                            for(var pred in {'requires':1,'activation':1,'show_if':1}) {
                                if(pred in spec && !read_predicate(get_leveled_quantity(spec[pred], level)).is_satisfied(player, null)) {
                                    pred_ok = false;
                                    break;
                                }
                            }
                            if(pred_ok && player.stattab['total_space'] >= space_usage['ALL'] + get_leveled_quantity(spec['consumes_space'],level)) {
                                var res_ok = true;
                                var cost = mobile_cost_to_repair(spec, level, 0, 1, player, COST_MODE.MANUFACTURE, this);
                                for(var res in gamedata['resources']) {
                                    if(player.resource_state[res][1] < cost[res]) {
                                        // cannot manufacture
                                        res_ok = false;
                                        break;
                                    }
                                }
                                if(res_ok) { // can make at least one unit
                                    // detect human units by looking for a walk cycle in units.json
                                    draw_idle_icon = (spec['walk_period'] ? 'train_advanced' : (spec['flying'] && 'manufacture_flying_advanced' in gamedata['strings']['idle_buildings'] ? 'manufacture_flying_advanced' : 'manufacture_advanced'));
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    } else if(this.is_researcher() && !this.is_researching()) {
        for(var specname in gamedata['tech']) {
            var spec = gamedata['tech'][specname];
            var cur_level = player.tech[specname]||0;
            if(cur_level < get_max_ui_level(spec) && goog.array.contains(this.spec['research_categories'], spec['research_category'])) {
                var pred_ok = true;
                for(var pred in {'requires':1,'activation':1,'show_if':1}) {
                    if(pred in spec && !read_predicate(get_leveled_quantity(spec[pred], cur_level+1)).is_satisfied(player, null)) {
                        pred_ok = false;
                        break;
                    }
                }
                if(pred_ok) {
                    var res_ok = true;
                    for(var res in gamedata['resources']) {
                        if(player.resource_state[res][1] < get_leveled_quantity(spec['cost_'+res] || 0, cur_level+1)) {
                            // cannot manufacture
                            res_ok = false;
                            break;
                        }
                    }
                    if(res_ok) { // can research at least one tech
                        draw_idle_icon = 'research_advanced';
                        break;
                    }
                }
            }
        }
    } else if(this.is_crafter()) {
        if((!this.is_crafting() || this.crafting_progress_one() < 0) && !(this.is_emplacement() && this.turret_head_item()) && !(this.is_security_node() && this.security_node_item())  && !(this.is_trapped_barrier() && this.barrier_trap_item()) && !(this.is_armed_building() && this.building_weapon_item()) && !(this.is_armed_townhall() && this.townhall_weapon_item())) {
            var building_cat = this.spec['crafting_categories'];
            goog.array.forEach(this.spec['crafting_categories'], function(cat) {
                if(cat && Array.isArray(cat)){
                    building_cat = this.get_leveled_quantity(this.spec['crafting_categories']);
                }
            }, this);
            for(var i = 0; i < building_cat.length; i++) {
                var catname = building_cat[i];
                var cat = gamedata['crafting']['categories'][catname];
                if(!cat) {
                    throw Error ('no such category as ' + catname);
                }
                if(catname == 'mines') {
                    if(!player.all_minefields_armed()) {
                        draw_idle_icon = cat['idle_state'] || 'craft_advanced';
                        break;
                    } else {
                        continue;
                    }
                } else if(catname == 'missiles' && cat['delivery'] == 'building_slot' && cat['delivery_building_for_ui']) {
                    // only show idle icon if there is a free slot in a delivery building somewhere
                    var found = false;
                    var building_list = find_all_objects_by_type(cat['delivery_building_for_ui']);
                    for(var i = 0; i < building_list.length; i++) {
                        var building = building_list[i];
                        var num_slots = building.get_leveled_quantity(building.spec['equip_slots'][cat['delivery_slot_type']]);
                        if(building.equipment && cat['delivery_slot_type'] in building.equipment && building.equipment[cat['delivery_slot_type']].length >= num_slots) {
                            for(var j = 0; j < building.equipment[cat['delivery_slot_type']].length; j++) {
                                if(building.equipment[cat['delivery_slot_type']][j] === null) {
                                    found = true; // empty slot
                                    break;
                                }
                            }
                            if(!found) { // all slots full
                                continue;
                            } else {
                                break;
                            }
                        } else {
                            found = true; break; // empty slot
                        }
                    }
                    if(found) {
                        draw_idle_icon = cat['idle_state'] || 'craft_advanced';
                        break;
                    } else {
                        continue;
                    }
                }
                draw_idle_icon = cat['idle_state'] || 'craft_advanced';
                if(draw_idle_icon == 'fish') {
                    if(player.cooldown_active('fish_slate_assigned')) {
                        // show no idle icon if all available fishing SKUs are exhausted
                        if(!goog.object.findKey(gamedata['crafting']['recipes'], function(recipe) {
                            return (recipe['crafting_category'] == 'fishing' && read_predicate(recipe['show_if']).is_satisfied(player, null));
                        })) {
                            draw_idle_icon = null;
                        }
                    }
                }
                break;
            }
        } else if(this.crafting_progress_one() < 0) {
            /* draw_idle_icon = 'craft_done'; */
        }

        if((this.is_emplacement() && this.turret_head_item()) || (this.is_security_node() && this.security_node_item()) || (this.is_trapped_barrier() && this.barrier_trap_item()) || (this.is_armed_building() && this.building_weapon_item()) || (this.is_armed_townhall() && this.townhall_weapon_item())){ // assumes mounted weapon recipients are crafters
            var item = null;
            var mounted_weapon_idle_icon = null;
            if(this.is_emplacement()) {
                item = this.turret_head_item();
                mounted_weapon_idle_icon = 'under_leveled_turret_head';
            } else if(this.is_security_node()) {
                item = this.security_node_item();
                mounted_weapon_idle_icon = 'under_leveled_security_node';
            } else if(this.is_trapped_barrier()) {
                item = this.barrier_trap_item();
                mounted_weapon_idle_icon = 'under_leveled_barrier_trap';
            } else if(this.is_armed_building()) {
                item = this.building_weapon_item();
                mounted_weapon_idle_icon = 'under_leveled_building_weapon';
            } else if(this.is_armed_townhall()) {
                item = this.townhall_weapon_item();
                mounted_weapon_idle_icon = 'under_leveled_townhall_weapon';
            }
            if (!(mounted_weapon_idle_icon in gamedata['strings']['idle_buildings'])) {
                throw Error('Icon ' + mounted_weapon_idle_icon + ' missing from gamedata');
            }
            var item_spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            if('associated_tech' in item_spec) {
                // check if our tech level for this item is above its own level
                var item_level = ItemDisplay.get_inventory_item_level(item);
                var tech_level = player.tech[item_spec['associated_tech']] || 0;
                if(tech_level > item_level) {
                    draw_idle_icon = mounted_weapon_idle_icon;
                }
            }
        }
    } else if(this.is_crafter() && this.crafting_progress_one() < 0) {
        /* draw_idle_icon = 'craft_done_advanced'; */
    } else if(this.spec['name'] === gamedata['alliance_building']) {
        if(!session.is_in_alliance()) {
            if(!player.cooldown_active('alliance_deserter')) {
                var pr = gamedata['predicate_library']['alliance_join_requirement'];
                if(read_predicate({'predicate':'LIBRARY','name':'alliance_join_requirement'}).is_satisfied(player, null)) {
                    draw_idle_icon = 'join_alliance_advanced';
                } else if(pr['predicate'] == 'BUILDING_LEVEL' && pr['building_type'] === this.spec['name'] && this.level < pr['trigger_level']) {
                    draw_idle_icon = 'upgrade_to_join_alliance';
                }
            }
        } else {
            if(player.unit_donation_enabled()) {
                var spell = gamedata['spells']['REQUEST_UNIT_DONATION'];
                var togo = player.cooldown_togo(spell['cooldown_name']);
                if(player.donated_units_space() < player.donated_units_max_space() && (togo <= 0)) {
                    draw_idle_icon = 'request_unit_donation_advanced';
                }
            }
        }
    } else if(this.spec['name'] === gamedata['squad_building']) {
        if(can_upgrade) {
            draw_idle_icon = 'upgrade_to_add_army_space';
        }
        /* // disregard resource requirements?
        if(this.level < this.get_max_ui_level()) {
            var req = get_leveled_quantity(this.spec['requires']||null, this.level+1);
            if(!req || read_predicate(req).is_satisfied(player, null)) {
                draw_idle_icon = 'upgrade_to_add_army_space';
            }
        }
        */
    }

    // lottery takes priority over others
    if(this.is_lottery_building()) {
        var state = player.get_lottery_state(this);
        if((state.can_scan && state.next_scan_method != 'paid') || !state.on_cooldown) {
            draw_idle_icon = 'lottery_scan';
        }
    }

    return {'state': draw_idle_icon,
            's_replace': draw_idle_icon_s,
            'can_upgrade': can_upgrade};
};

/** Draw a building or inert object
    @param {World.World|null} world
    @param {!GameObject} obj
    @param {number} powerfac
    @return {!Array.<!PlayfieldText>} */
function draw_building_or_inert(world, obj, powerfac) {
    /** @type {!Array.<!PlayfieldText>} */
    var text_list = [];
    var xy = draw_quantize(playfield_to_draw(obj.playfield_xy()));

    var icon;
    var icon_state = 'unset';
    var icon_alternates = null; // substitutes in case icon is still loading [list of [icon, state]]
    var icon_time = client_time;
    var status_text = [];
    var sprite_data = null;

    if(obj.get_leveled_quantity(obj.spec['art_asset']) in GameArt.assets) {
        var sprite_name = obj.get_leveled_quantity(obj.spec['art_asset']);
        icon = GameArt.assets[sprite_name];
        sprite_data = gamedata['art'][sprite_name];
    } else {
        icon = "MISSING";
    }

    if(obj.is_destroyed()) {

        icon_alternates = [];
        if('damaged' in icon.states) {
            // use damaged version as alternate, if available
            icon_alternates.push([icon, 'damaged']);
        }
        // use normal version as alternate, if available
        icon_alternates.push([icon, 'normal']);

        var icon_name;

        if('destroyed_asset' in obj.spec) {
            icon_name = obj.spec['destroyed_asset'];
        } else {
            // use generic crater asset
            var size_str = obj.spec['gridsize'][0].toString()+'x'+obj.spec['gridsize'][1].toString();
            icon_name = 'building_crater_'+size_str;
        }

        if(!(icon_name in GameArt.assets)) {
            console.log('Missing destroyed building art asset '+icon_name);
            icon = "MISSING";
        } else {
            icon = GameArt.assets[icon_name];
        }
        icon_state = 'normal';
    } else if(obj.is_building() && obj.is_minefield()) {
        if(obj.is_minefield_armed()) {
            icon_state = 'loaded';
        } else {
            icon_state = 'normal';
        }
    } else if(obj.is_building() && obj.is_ambush()) {
        if(obj.is_ambush_armed()) {
            icon_state = 'loaded';
        } else {
            icon_state = 'normal';
        }
    } else if(obj.is_building() && obj.is_under_construction()) {
        // use generic under-construction asset
        var icon_name;
        if('under_construction_asset' in obj.spec) {
            icon_name = obj.spec['under_construction_asset'];
        } else {
            var size_str = obj.spec['gridsize'][0].toString()+'x'+obj.spec['gridsize'][1].toString();
            icon_name = 'building_construction_'+size_str;
        }

        if(!(icon_name in GameArt.assets)) {
            console.log('Missing under-construction building art asset '+icon_name);
            icon = "MISSING";
        } else {
            icon = GameArt.assets[icon_name];
        }
        icon_state = 'normal';
    } else if(obj.is_damaged() && !('turn_rate' in obj.spec)) {
        // ^ do not use damaged state for turrets, because it has no compass animation frames
        if(gamedata['client']['use_enemy_sprites'] && obj.team === 'enemy') {
            icon_state = 'enemy_damaged';
        } else {
            icon_state = 'damaged';
        }
        icon_alternates = [[icon, 'normal']]; // use normal version as alternate

    } else if(obj.is_building() && obj.is_storage() && obj.spec['name'] != gamedata['townhall'] && sprite_data && ('normal_fullness000' in sprite_data['states'])) {
        // fullness state
        var resname = null;
        for(var res in gamedata['resources']) {
            if(('storage_'+res) in obj.spec) {
                resname = res; break;
            }
        }
        if(resname) {
            var fullness = get_storage_fullness(resname);
            var TABLE = [[-Infinity,'000'],[0.25,'025'],[0.50,'050'],[0.75,'075'],[1.0,'100']];
            for(var i = 0; i < TABLE.length; i++) {
                if(fullness >= TABLE[i][0]) {
                    icon_state = 'normal_fullness'+TABLE[i][1];
                } else {
                    break;
                }
            }
        } else {
            throw Error("Cannot determine resname for "+obj.spec['name']);
        }

    } else {
        if(gamedata['client']['use_enemy_sprites'] && obj.team === 'enemy') {
            icon_state = 'enemy';
        } else {
            icon_state = 'normal';
        }
    }

    if(obj.is_invisible() && (obj.team !== 'player' || session.is_replay()) && !obj.is_destroyed()) {
        return text_list; // hidden building!
    }

    if(obj.is_building() && obj.is_repairing()) {
        var progress = 1 + (server_time - obj.repair_finish_time)/(obj.get_leveled_quantity(obj.spec['repair_time'])/obj.get_stat('repair_speed',1));
        if(progress >= 1) {
            progress = 1;
            // ping server to see if it's been repaired
            if(/*obj.team === 'player' && */!obj.ping_sent) {
                send_to_server.func(["PING_OBJECT", obj.id, "repair_check", obj.spec['ui_name']]);
                obj.ping_sent = true;
            }
        }

        if(obj.needs_power_ping() && (obj.last_ui_hp >= (obj.last_ping_hp + (obj.max_hp / 20)))) {
            // if generator is using the power level that update with HP level, pings every time the current HP is at least 5% of max_hp higher than the last ping
            // this will max out the number of pings at 20x per generator per player, infrequent enough to prevent overwhelming traffic
            obj.last_ping_hp = obj.last_ui_hp;
            send_to_server.func(["PING_OBJECT", obj.id, "power_repair_check", obj.spec['ui_name']]);
        }
        status_text.push(gamedata['strings']['cursors']['repairing']+': '+pretty_print_time(obj.repair_finish_time - server_time));
    }

    var progress = 0;

    if((obj.is_building() || obj.is_inert()) && obj.is_removing()) {
        progress = obj.remove_progress();
        if(progress >= 0 && (progress < 1 || obj.team == 'player')) {
            status_text.push(gamedata['strings']['cursors']['removing']+': ' + pretty_print_time(obj.remove_time_left()));
        }
    } else if(obj.is_building() && (obj.is_under_construction() || obj.is_upgrading() || obj.is_enhancing() ||
                                    obj.is_researching() || obj.is_manufacturing() || obj.is_crafting())) {
        if(obj.is_under_construction()) {
            progress = obj.build_progress();
            if(progress >= 0 && (progress < 1 || obj.team == 'player')) {
                status_text.push(gamedata['strings']['cursors']['constructing']+': ' + (session.enable_progress_timers ? pretty_print_time(obj.build_time_left()) : ' ...'));
            }
        } else if(obj.is_upgrading()) {
            progress = obj.upgrade_progress();
            if(progress >= 0 && (progress < 1 || obj.team == 'player')) {
                status_text.push(gamedata['strings']['cursors']['upgrading']+': ' + (session.enable_progress_timers ? pretty_print_time(obj.upgrade_time_left()) : ' ...'));
            }
        } else if(obj.is_enhancing()) {
            progress = obj.enhance_progress();
            if(progress >= 0 && (progress < 1 || obj.team == 'player')) {
                // reuse researching text for enhancing
                status_text.push(gamedata['strings']['cursors']['researching'].replace('%tech',gamedata['enhancements'][obj.enhancing['enhance']['spec']]['ui_name']).replace('%d', obj.enhancing['enhance']['level'].toString())+': ' + pretty_print_time(obj.enhance_time_left()));
            }
        } else if(obj.is_researching()) {
            var tech = (session.home_base ? player.tech : enemy.tech);
            var current = ((obj.research_item in tech) ? tech[obj.research_item] : 0);
            progress = obj.research_progress();
            if(progress >= 0 && (progress < 1 || obj.team == 'player')) {
                status_text.push(gamedata['strings']['cursors']['researching'].replace('%tech',gamedata['tech'][obj.research_item]['ui_name']).replace('%d', (current+1).toString())+': '+ (session.enable_progress_timers ? pretty_print_time(obj.research_time_left()) : ' ...'));
            }
        } else if(obj.is_crafting()) {
            var recipe = gamedata['crafting']['recipes'][obj.is_crafting()];
            progress = obj.crafting_progress_one();
            if(progress < 0) {
                // pending collection
                progress = 0;
            } else if(progress < 1 || obj.team == 'player') {
                // existence of first entry is guaranteed by .is_crafting()
                var recipe_level = obj.get_crafting_queue()[0]['craft']['level'] || 1;
                var ui_recipe = get_crafting_recipe_ui_name(recipe, recipe_level);
                var bus = obj.get_crafting_queue()[0]['craft'];
                if(recipe['max_level'] > 1 && (bus['level'] || 1) > 1) {
                    ui_recipe += ' L'+bus['level'].toString();
                }
                status_text.push(ui_recipe + ': '+pretty_print_time(obj.crafting_time_left_one()));
            }
        } else if(obj.is_manufacturing()) {
            var item = obj.manuf_queue[0];
            progress = obj.manuf_progress_one();
            if(progress < 1 || obj.team == 'player') {
                var s = gamedata['units'][item['spec_name']]['ui_name'];
                if(obj.manuf_queue.length > 1) {
                    s += ' ... ';
                }
                status_text.push(s + ': ' + (session.enable_progress_timers ? pretty_print_time(obj.manuf_time_left()) : ' ...'));
            }
        }
    }

    if(progress >= 1) {
        progress = 1;
        // ping server to see if the action is finished
        if(obj.team === 'player' && !obj.ping_sent) {
            send_to_server.func(["PING_OBJECT", obj.id, "action_check", obj.spec['ui_name'], status_text.join('\n')]);
            obj.ping_sent = true;
        }
    }

    var producer_halted = false;
    if(obj.is_building() && obj.is_producer()) {
        // draw harvester stats
        var contents = obj.interpolate_contents();
        var capacity = obj.get_production_capacity();

        // halt animation if full or disabled by low power
        if(powerfac == 0) {
            producer_halted = true;
        } else if(contents >= capacity && obj.team == 'player') {
            // note: do not stop animation on harvesters owned by other players or AIs, even if they are actually full
            producer_halted = true;
        }
    }

    // pause animation for idle factories and research labs
    if(obj.is_building() &&
       (obj.is_upgrading() || obj.is_enhancing() || obj.is_removing() ||
        (obj.is_factory() && !obj.is_manufacturing()) ||
        (obj.is_researcher() && !obj.is_researching()) ||
        (obj.is_producer() && producer_halted) ||
        (obj.is_crafter() && !obj.is_crafting() && !obj.spec['invert_idle']))) {
        icon_time = 0;
    } else if(obj.spec['invert_idle'] && obj.is_building() && !obj.is_destroyed() && obj.is_crafter() && obj.is_crafting()) {
        // this is used for Logistics Dispatch
        // icon_time = 0; // do not halt rotor blades when collection is pending
        if(obj.crafting_progress_one() >= 0 && icon_state == 'normal' && icon.has_state('normal_idle')) {
            icon_state = 'normal_idle'; // or if a job is in progress right now, show no helicopter
        }
    } else {
        // de-synchronize building animation loops
        icon_time += 2.7*obj.anim_offset;
    }

    // find wall segments
    var draw_as_wall = get_leveled_quantity(obj.spec['draw_as_wall']||null, obj.level);
    var wall_to = {'north':false, 'east':false, 'south':false, 'west':false}, wall_spacing = 0, wall_seg_offset = 0;
    if(world && draw_as_wall && !obj.is_destroyed() && ((icon_state+'_ns') in sprite_data['states'])) {
        wall_spacing = Math.floor(obj.spec['gridsize'][0]/2);
        // this extra offset is necessary for wall segments to be right on the centerline between posts
        // when the spacing is greater than 1 grid unit (SG)
        wall_seg_offset = (wall_spacing > 1 ? 0.25 : 0);

        var OFFSETS = [[0,-2*wall_spacing,'north'],
                       [0, 2*wall_spacing,'south'],
                       [-2*wall_spacing,0,'west'],
                       [ 2*wall_spacing,0,'east']
                      ];

        for(var i = 0; i < OFFSETS.length; i++) {
            var objlist = world.voxel_map_accel.objects_near_xy([obj.x+OFFSETS[i][0], obj.y+OFFSETS[i][1]], obj.team);
            if(objlist) {
                for(var j = 0; j < objlist.length; j++) {
                    var o = objlist[j];
                    if(!o.is_destroyed() && o.spec === obj.spec && o.team === obj.team) {
                        if(o.y == obj.y+OFFSETS[i][1] && o.x == obj.x+OFFSETS[i][0]) {
                            wall_to[OFFSETS[i][2]] = true;
                        }
                    }
                }
            }
        }

        /* // unoptimized brute-force version
        for(var id in session.cur_objects.objects) {
            var o = session.cur_objects.objects[id];
            if(o.y >= obj.y && (o.y - obj.y) < 2*wall_spacing && o.x == obj.x+2*wall_spacing) {
                wall_to['east'] = true;
            } else if(o.x >= obj.x && (o.x - obj.x) < 2*wall_spacing && o.y == obj.y+2*wall_spacing) {
                wall_to['south'] = true;
            }
        }
        */
    }

    // when the draw_as_wall setting is "corner_posts", do not draw posts in the middle of a continuous long NS or EW string
    var skip_wall_post = (draw_as_wall == 'corner_posts' &&
                          ((wall_to['north'] && wall_to['south'] && !wall_to['east'] && !wall_to['west']) ||
                           (!wall_to['north'] && !wall_to['south'] && wall_to['east'] && wall_to['west'])));
    // DRAW BUILDING

    if(icon != "MISSING" && !skip_wall_post) {
        var facing = 0;
        if(obj.is_inert() && obj.metadata && 'facing' in obj.metadata) {
            facing = obj.metadata['facing'];
        } else if('turn_rate' in obj.spec && !(obj.is_building() && (obj.is_upgrading() || obj.is_enhancing() || obj.is_removing() || obj.is_repairing() || obj.disarmed))) {
            facing = (world ? obj.interpolate_facing(world) : obj.cur_facing);
        }
        if(icon) {
            var ready = icon.prep_for_draw(xy, facing, icon_time, icon_state);

            // if desired icon state is not ready to draw yet, but an alternate exists and is ready to draw, use that instead
            var drawn = false;
            if(!ready && icon_alternates) {
                for(var i = 0; i < icon_alternates.length; i++) {
                    var alt = icon_alternates[i][0], st = icon_alternates[i][1];
                    if(alt.ready_to_draw(xy, facing, icon_time, st)) {
                        alt.draw(xy, facing, icon_time, st);
                        drawn = true;
                        break;
                    }
                }
            }

            if(!drawn) {
                icon.draw(xy, facing, icon_time, icon_state);
            }
        } else {
            throw Error('missing art asset for '+obj.spec['name']);
        }

        if(obj.is_building() && obj.is_invul() && obj.spec['max_hp'] !== 0) {
            var asset = (obj.spec['gridsize'][0] >= 12 ? 'building_shield_big' : 'building_shield_small');
            if(asset in GameArt.assets) { GameArt.assets[asset].draw(xy, facing, client_time, 'normal'); }
        }
    }

    // draw weapon
    if(obj.is_building() && !obj.is_destroyed() && ('weapon_offset' in obj.spec)) {
        obj = /** @type {!Building} */ (obj);
        var weapon_asset = obj.get_stat('weapon_asset', null);
        if(weapon_asset) {
            var weapon_icon = GameArt.assets[weapon_asset];
            if(weapon_icon) {
                var odd_shift = obj.get_odd_shift();
                var x = obj.x + odd_shift[0], z = obj.y + odd_shift[1];
                var weapon_offset = obj.get_leveled_quantity(obj.spec['weapon_offset']);
                var pos = draw_quantize(ortho_to_draw_3d(v3_add([x,0,z], weapon_offset)));
                weapon_icon.draw(pos, facing + ((Math.PI/180)*(obj.combat_stats.weapon_facing_fudge)), icon_time, icon_state);
            } else {
                //console.log('cannot find '+weapon_asset);
            }
        }
    }

    // draw wall segments
    if(wall_to['east']) {
        icon.draw(draw_quantize(ortho_to_draw([obj.x+wall_spacing, obj.y-wall_seg_offset])), facing, icon_time, icon_state + '_ew');
    }
    if(wall_to['south']) {
        icon.draw(draw_quantize(ortho_to_draw([obj.x-wall_seg_offset, obj.y+wall_spacing])), facing, icon_time, icon_state + '_ns');
    }

    /*
    // draw lottery scans remaining
    if(obj.team === 'player' && obj.is_building() && obj.is_lottery_building() && obj.contents >= 1) {
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = 'rgba(213,0,0,1)';
        SPUI.add_beveled_rectangle_to_path(vec_add(xy, obj.spec['scan_counter_offset']), [12+8*Math.floor(Math.log(obj.contents)/Math.log(10)),14], 2);
        ctx.fill();
        ctx.font = SPUI.make_font(13, 16, 'thick').str();
        ctx.fillStyle = 'rgba(255,255,255,1)';
        var txy = vec_add(vec_add(xy, obj.spec['scan_counter_offset']), [2,12]);
        ctx.fillText(pretty_print_number(obj.contents), txy[0], txy[1]);
        ctx.restore();
    }
    */

    // draw harvest glow
    if(obj.harvest_glow_time > 0) {
        var glow_t = (client_time - obj.harvest_glow_time)/gamedata['client']['harvest_glow_time'];
        var glow = 0;
        if(glow_t > 1) {
            obj.harvest_glow_time = -1;
        } else if(glow_t > 0) {
            glow = Math.exp(-12*(glow_t-0.3)*(glow_t-0.3));
        }
        if(glow > 0) {
            ctx.save();

            // manual hack to position the effect over the harvester
            var off = ('harvest_glow_pos' in obj.spec ? obj.spec['harvest_glow_pos'] : [0,0]);

            if(obj.team === 'player') {
                // draw glow sprite
                ctx.globalAlpha = 0.75*glow;
                GameArt.assets['harvester_glow'].states['normal'].draw([xy[0]+off[0],xy[1]+off[1]], 0, 0);
            }

            // draw ringy things
            ctx.strokeStyle = 'rgba(128,255,255,1.0)';
            ctx.lineWidth = 3;
            var ring_y;
            ctx.globalAlpha = 0.55*(1-glow_t);
            ctx.save();
            ctx.beginPath();
            ring_y = -120*glow_t + 45;
            ctx.transform(1, 0, 0, 0.5, xy[0]+off[0], xy[1]+off[1]+ring_y);
            ctx.arc(0, 0, 60, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.restore();

            ctx.save();
            ctx.beginPath();
            ring_y = -240*glow_t + 45;
            ctx.transform(1, 0, 0, 0.5, xy[0]+off[0], xy[1]+off[1]+ring_y);
            ctx.arc(0, 0, 30, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.restore();

            ctx.save();
            ctx.beginPath();
            ring_y = -360*glow_t + 45;
            ctx.transform(1, 0, 0, 0.5, xy[0]+off[0], xy[1]+off[1]+ring_y);
            ctx.arc(0, 0, 15, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.restore();

            ctx.restore();
        }
    }

    // draw level flags
    if(obj.is_building() && !obj.is_destroyed() && player.get_any_abtest_value('enable_building_level_flags', gamedata['client']['enable_building_level_flags']) &&
      ('level_flag_offset' in obj.spec)) {
        var fsprite_name = 'building_level_flag_L'+obj.level.toFixed(0);
        if(fsprite_name in GameArt.assets) {
            var fsprite = GameArt.assets[fsprite_name].states['normal'];
            var foffset = ortho_to_draw_vector(obj.spec['level_flag_offset']);
            fsprite.draw_topleft(draw_quantize(vec_add(xy, foffset)), 0, 0);
        }
    }

    // draw equip icons
    if(obj.is_building() && obj.equipment && !obj.is_ambush()) {
        var ecount = 0, elevel = 0;
        for(var slot_type in obj.equipment) {
            if(!(slot_type in gamedata['strings']['equip_slots'])) {
                throw Error('Equipment slot type ' + slot_type + ' missing from gamedata strings');
            }
            if(slot_type == "mine" || // maybe set "show":0 on mine slots?
               (('show' in gamedata['strings']['equip_slots'][slot_type]) && !gamedata['strings']['equip_slots'][slot_type]['show']) ||
               (('show_if' in gamedata['strings']['equip_slots'][slot_type]) &&
                !read_predicate(gamedata['strings']['equip_slots'][slot_type]['show_if']).is_satisfied(player,null))) {
                continue;
            }
            var item_list = obj.equipment[slot_type];
            for(var i = 0; i < item_list.length; i++) {
                if(item_list[i]) {
                    var espec = ItemDisplay.get_inventory_item_spec(player.decode_equipped_item(item_list[i])['spec']);
                    if(('equip' in espec) && ('show_to_enemy' in espec['equip']) && !espec['equip']['show_to_enemy'] && obj.team !== 'player') { continue; }
                    elevel = Math.max(elevel, espec['level'] || 1);
                    ecount += 1;
                }
            }
        }
        var esprite_name = 'equip_icon'; // 'equip_icon_rarity'+rarity.toString();
        var esprite = GameArt.assets[esprite_name].states['normal'];
        var draw_count = elevel; // draw one icon per level, for the max level among all equips
        if(draw_count > 0) {
            var eoffset_map, edelta_map;
            if('equip_icon_offset' in obj.spec) {
                eoffset_map = obj.spec['equip_icon_offset'];
            } else {
                var d = gamedata['client']['default_equip_icon_offset'];
                eoffset_map = [d[0]*obj.spec['gridsize'][0]/2, d[1]*obj.spec['gridsize'][1]/2];
            }
            if('equip_icon_delta' in obj.spec) {
                edelta_map = obj.spec['equip_icon_delta'];
            } else {
                edelta_map = gamedata['client']['default_equip_icon_delta'];
            }
            var eoffset = ortho_to_draw_vector(eoffset_map);
            var edelta = ortho_to_draw_vector(edelta_map);
            //ctx.save();
            //ctx.globalAlpha = gamedata['client']['cloaked_opacity'];
            for(var i = 0; i < draw_count; i++) {
                esprite.draw_topleft(draw_quantize(vec_add(vec_add(xy, eoffset), vec_scale(i, edelta))), 0, 0);
            }
            //ctx.restore();
        }
    }

    // draw alliance membership

    if('show_alliance_at' in obj.spec) {
        var alliance_id = -1;
        if(obj.team === 'player') {
            alliance_id = session.alliance_id;
        } else if(obj.team === 'enemy' && !session.home_base && !session.viewing_ai) {
            var player_entry = PlayerCache.query_sync(session.viewing_user_id);
            if(player_entry && ('alliance_id' in player_entry) && player_entry['alliance_id'] > 0) {
                alliance_id = player_entry['alliance_id'];
            }
        }
        var alliance_name = null;
        if(alliance_id > 0) {
            var info = AllianceCache.query_info_sync(alliance_id);
            if(info && ('ui_name' in info)) {
                alliance_name = alliance_display_name(info);
            }
        }

        if(alliance_name) {
            var s = gamedata['strings']['alliance_building_tag'].replace('%s', alliance_name);
            text_list.push({text: s, pos: vec_add(xy, obj.spec['show_alliance_at']), drop_shadow: true});
        }
    }

    // draw status text
    var default_text_height = obj.get_health_bar_dims()[2];
    var status_text_height = default_text_height + 6;
    if(obj.is_damaged()) {
        // move to not conflict with health bar
        status_text_height = default_text_height - 30;
    }

    var count = 0;

    // draw "low power" icon
    if(powerfac < 1 && obj.is_building() && !obj.is_destroyed() && player.tutorial_state == "COMPLETE" &&
       ((obj.is_shooter() && !obj.is_minefield() && !obj.is_ambush()) || obj.is_producer())
      /* obj.get_leveled_quantity(obj.spec['consumes_power'] || 0) > 0 */
      ) {
        GameArt.assets['low_power_icon'].states['normal'].draw([xy[0]+30+20*count,xy[1]-default_text_height+5], 0, 0);
        count++;
    }

    // draw auras and status text
    if(!obj.spec['worth_less_xp']) {
        if(obj.combat_stats.stunned && !obj.is_destroyed()) {
            GameArt.assets['stun_icon'].states['normal'].draw([xy[0]+30+20*count,xy[1]-default_text_height+5], 0, 0);
            count++;
        }

        for(var i = 0; i < obj.auras.length; i++) {
            var aura = obj.auras[i];
            if(world && aura.visual_effect) {
                var pos = obj.interpolate_pos(world);
                aura.visual_effect.reposition([pos[0], 0, pos[1]]);
            }

            if(aura.expire_tick.is_infinite()) {
                // don't draw permanent auras on buildings
                continue;
            }

            if(obj.is_destroyed()) {
                // don't draw auras if the building/inert is dead
                continue;
            }

            if(draw_aura(xy, [xy[0]+30+20*count, xy[1]-default_text_height+5], aura)) {
                count++;
            }
        }

        // draw status text
        if(status_text.length > 0) {
            var text_xy = [xy[0], xy[1]-status_text_height+6-0*SPUI.desktop_font.size];
            var LINEHEIGHT = 20;

            for(var i = 0; i < status_text.length; i++) {
                var text = {text: status_text[i], pos: [text_xy[0], text_xy[1]+i*LINEHEIGHT], drop_shadow: true};
                // color top line white, lower lines gray (to indicate paused actions)
                var paused = (i != 0) || (obj.is_damaged() && !obj.is_repairing());
                if(paused) {
                    text.color = 'rgba(200,200,200,1)';
                }
                text_list.push(text);
            }
        }
    }

    // draw health bar
    draw_health_bar(xy, obj);

    // draw build idle status
    if(obj.is_building()) {
        var appearance = obj.get_idle_state_appearance();
        var idle = (appearance ? appearance.idle : null);
        if(idle && idle['can_upgrade'] && ('upgrade_advanced' in gamedata['strings']['idle_buildings'])) {
            // draw "can upgrade" arrow, based on equip icon position
            var img = GameArt.assets[gamedata['strings']['idle_buildings']['upgrade_advanced']['icon']].states['normal'];

            var uoffset;
            if('level_flag_offset' in obj.spec) {
                uoffset = obj.spec['level_flag_offset'];
            } else {
                uoffset = vec_add(vec_scale(0.5, obj.spec['gridsize']),
                                  gamedata['strings']['idle_buildings']['upgrade_advanced']['default_icon_offset']);
            }
            var pos = draw_quantize(vec_add(xy, ortho_to_draw_vector(uoffset)));

            if(gamedata['strings']['idle_buildings']['upgrade_advanced']['ui_name_short']) {
                pos = draw_centered_text_with_shadow(ctx, gamedata['strings']['idle_buildings']['upgrade_advanced']['ui_name_short'], pos);
                pos = vec_add(pos, vec_scale(-1, gamedata['strings']['idle_buildings']['upgrade_advanced']['text_offset']));
            }

            img.draw(pos, 0, client_time);
        }
        if(appearance && appearance.asset) {
            // draw idle state
            var icon_sprite = GameArt.assets[appearance.asset].states['normal'];

            if(appearance.text_str) {
                text_list.push({text: appearance.text_str, pos: playfield_to_draw(appearance.text_pos), drop_shadow: true});
            }

            var has_state = false;
            if(appearance.pulse_period > 0 && mouse_state.hovering_over !== obj) {
                has_state = true;
                ctx.save();
                var amp = appearance.pulse_amplitude;
                ctx.globalAlpha = (1-amp) + amp * (0.5*(Math.sin(2*Math.PI*(client_time/appearance.pulse_period + obj.anim_offset))+1));
            }
            icon_sprite.draw(draw_quantize(playfield_to_draw(appearance.icon_pos)), 0, client_time);
            if(has_state) {
                ctx.restore();
            }
        }
    }

    if(CLICK_DETECTION_DEBUG) { draw_click_detection(obj); }

    if(AI_DEBUG && obj.is_building() && obj.is_shooter()) {
        // draw ai state
        draw_centered_text(ctx, control_state_names[obj.control_state], [xy[0],xy[1]+30]);
        draw_centered_text(ctx, ai_state_names[obj.ai_state], [xy[0],xy[1]+45]);
    }

    if(world) {
        obj.update_permanent_effect(world);
    }
    return text_list;
}

/**
 * Draws separate shadow sprites for a given GameObject.
 * @param {!World.World} world
 * @param {!GameObject} unit
 */
function draw_shadow(world, unit) {
    if(!unit.is_mobile() || !unit.is_flying()) { return; }
    unit = /** @type {!Mobile} */ (unit);

    if(session.viewing_base.base_climate_data['fly_at_ground_level']) { return; }

    if(unit.combat_stats.altitude > 0 && !unit.is_destroyed() && 'shadow_asset' in unit.spec) {
        var curpos = unit.interpolate_pos_for_draw(world);
        var xy = draw_quantize(ortho_to_draw(curpos));

        if((xy[0]+MAX_UNIT_SPRITE_SIZE < view_roi[0][0]) ||
           (xy[0]-MAX_UNIT_SPRITE_SIZE > view_roi[1][0]) ||
           (xy[1]+MAX_UNIT_SPRITE_SIZE < view_roi[0][1]) ||
           (xy[1]-MAX_UNIT_SPRITE_SIZE > view_roi[1][1])) {
            // cull
            return;
        }
        var alpha = ('unit_shadow_alpha' in session.viewing_base.base_climate_data ? session.viewing_base.base_climate_data['unit_shadow_alpha'] : 1);
        if(alpha > 0) {
            if(alpha != 1) { ctx.save(); ctx.globalAlpha = alpha; }
            GameArt.assets[unit.spec['shadow_asset']].draw(ortho_to_draw(curpos), 0, client_time, 'normal');
            if(alpha != 1) { ctx.restore(); }
        }
    }
}

/** @param {!World.World} world
    @param {!Mobile} unit
    @return {boolean} true if the unit is on screen, false if offscreen */
function draw_unit(world, unit) {
    // get simulated position
    var curpos = unit.interpolate_pos_for_draw(world);
    var alt = unit.combat_stats.altitude;

    // don't levitate debris piles
    if(unit.hp <= 0 && !unit.is_indestructible()) { alt = 0; }

    // perturb altitude to make flying units bob up and down
    if(alt > 0) {
        alt += 0.08 * Math.sin(2.2*client_time + 2*Math.PI*unit.anim_offset);
        if(unit.is_mobile() && unit.combat_stats.erratic_flight > 0) {
            curpos[0] += 0.7 * unit.combat_stats.erratic_flight * Math.sin(3.14*client_time + 2*Math.PI*unit.anim_offset);
            curpos[1] += 0.7 * unit.combat_stats.erratic_flight * Math.sin(3.64*client_time + 2*Math.PI*unit.anim_offset);
        }
    }

    var xy = ortho_to_draw_3d([curpos[0], alt, curpos[1]]);

    if(unit.combat_stats.altitude > 0 || view_is_zoomed()) {
        // NOTE: do not quantize xy, to get subpixel motion on the hovering effect for flying units
        // may be slow on some browsers!
    } else {
        xy = draw_quantize(xy);
    }

    if((xy[0]+MAX_UNIT_SPRITE_SIZE < view_roi[0][0]) ||
       (xy[0]-MAX_UNIT_SPRITE_SIZE > view_roi[1][0]) ||
       (xy[1]+MAX_UNIT_SPRITE_SIZE < view_roi[0][1]) ||
       (xy[1]-MAX_UNIT_SPRITE_SIZE > view_roi[1][1])) {
        // cull
        return false;
    }

    var state;
    if(gamedata['client']['use_enemy_sprites'] && unit.team === 'enemy') {
        state = 'enemy';
    } else {
        state = 'normal';
    }

    // draw the sprite
    var sprite, alpha;
    if(unit.hp > 0 || unit.max_hp === 0) {

        sprite = unit.get_leveled_quantity(unit.spec['art_asset']);

        if(unit.combat_stats.art_asset) { // attempt to over-ride the art asset with one specified in combat stats
            if(unit.combat_stats.art_asset in gamedata['art']) {
                sprite = unit.combat_stats.art_asset;
            } else {
                // uh oh, the stat refers to a missing asset (maybe it's an out-of-date replay)
                // fall back to the original art asset
                console.log('warning: unit.combat_stats.art_asset refers to missing asset "' + unit.combat_stats.art_asset + '"');
            }
        }

        // special movement states
        var sprite_data = gamedata['art'][sprite];
        var mystates = sprite_data['states'];
        if((unit.control_state === control_states.CONTROL_SHOOT) && unit.control_spellname && ('melee_cycle' in sprite_data)) {
            // melee strikes
            var spell = gamedata['spells'][unit.control_spellname];
            // seconds remaining before next strike initiation
            var remaining_cooldown = unit.control_cooldown * TICK_INTERVAL - (client_time - world.last_tick_time);

            // calculate the spell's final cooldown value, accounting for things like unit rate of fire and power loss
            var cooldown = unit.get_leveled_quantity(spell['cooldown']);
            cooldown = cooldown / unit.combat_stats.rate_of_fire;
            cooldown = cooldown / unit.combat_power_factor(world.base);

            var animation_progress = -1;
            if('melee_cycle_duration' in spell) {
                // animation_start and animation_end are represented as a time delta from client_time to when those events occur(ed)
                var animation_start = remaining_cooldown - cooldown;
                var animation_duration = spell['melee_cycle_duration'];
                var animation_end = animation_start + animation_duration;

                if(animation_start <= 0 && animation_end > 0) {
                    animation_progress = Math.min(Math.max(1.0 - (animation_end / animation_duration), 0), 0.999);
                }
            } else {
                // run the melee animation across the entire actual spell cooldown
                animation_progress = Math.min(Math.max(1.0 - (remaining_cooldown / cooldown), 0), 0.999); // don't go to 1.0 since that will overflow the cycle length
            }

            if(animation_progress != -1) {
                var frame = Math.floor(sprite_data['melee_cycle'].length * animation_progress);
                state = sprite_data['melee_cycle'][frame];
            } else {
                // default to the "pausing between strikes" frame outside of the actual attack animation
                state = state + '_shoot';
            }
        } else if((unit.control_state === control_states.CONTROL_SHOOT) && (state+'_shoot' in mystates)) {
            state = state+'_shoot';
        } else if((unit.control_state === control_states.CONTROL_MOVING) && ('walk_cycle' in sprite_data) &&
                  !vec_equals(unit.vel, [0,0])) {
            var walk_period = unit.get_leveled_quantity(unit.spec['walk_period'] || 1.0);
            var cycprog = ((world.control_paused ? 0 : (combat_time_scale()*client_time/walk_period)) + unit.anim_offset) % 1.0;
            var cycfrm = Math.floor(sprite_data['walk_cycle'].length*cycprog);
            state = sprite_data['walk_cycle'][cycfrm];
        }

        if(unit.spec['cloaked']) {
            if(unit.is_invisible() && (unit.team !== 'player' || session.is_replay())) {
                return false; // hidden unit!
            }
            if(unit.team === 'player') {
                if(unit.is_invisible()) {
                    alpha = gamedata['client']['invisible_opacity'];
                } else {
                    alpha = gamedata['client']['cloaked_opacity'];
                }
            } else {
                // even moving cloaked units get the lower opacity if they are unfriendly
                alpha = gamedata['client']['invisible_opacity'];
            }

        } else {
            alpha = 1;
        }
        alpha *= unit.cur_opacity;
    } else {
        if('destroyed_inert' in unit.spec) {
            if(unit.spec['destroyed_inert']) {
                sprite = gamedata['inert'][unit.spec['destroyed_inert']]['art_asset'];
            } else {
                sprite = null;
            }
        } else {
            sprite = gamedata['inert'][gamedata['default_debris_inert']]['art_asset'];
        }
        alpha = 1;
    }

    // fade in/out
    if(alpha != unit.last_opacity) {
        var trans_time = gamedata['client'][(unit.spec['cloaked'] ? 'cloak_transition_time' : 'unit_fade_time')];
        var trans_rate = 1.0 / trans_time;
        var trans_amt = Math.max(0, client_time - unit.last_opacity_time) * trans_rate;
        if(alpha < unit.last_opacity) {
            alpha = Math.max(alpha, unit.last_opacity - trans_amt);
        } else {
            alpha = Math.min(alpha, unit.last_opacity + trans_amt);
        }
        unit.last_opacity = alpha;
        unit.last_opacity_time = Math.max(client_time, unit.last_opacity_time);
    }

    var scale = unit.cur_scale;

    if(sprite) {
        var has_state = ((alpha != 1) || (scale[0] != 1) || (scale[1] != 1));
        var draw_xy = xy;
        if(has_state) { ctx.save(); }
        if(alpha != 1) { ctx.globalAlpha = alpha; }
        if(scale[0] != 1 || scale[1] != 1) {
            ctx.transform(scale[0], 0, 0, scale[1], xy[0], xy[1]);
            draw_xy = [0,0];
        }
        GameArt.assets[sprite].draw(draw_xy, unit.interpolate_facing(world), client_time, state);
        if(has_state) { ctx.restore(); }
    }

    if(unit.hp > 0 && unit.spec['elite_marker_offset'] && (SPFX.detail < 2) && !player.get_any_abtest_value('enable_pixel_manipulation_in_low_gfx', gamedata['client']['enable_pixel_manipulation_in_low_gfx'])) {
        GameArt.assets['elite_marker'].states['normal'].draw(vec_add(xy, unit.spec['elite_marker_offset']), 0, 0);
    }

    draw_health_bar(xy, unit);


    // draw repair wrench
    if(session.home_base && !session.has_attacked && unit.is_under_repair() && unit.team == 'player') {
        GameArt.assets['repair_wrench_' + (player.unit_repair_queue[0]['obj_id'] === unit.id ? 'green' : 'gray')].states['normal'].draw([xy[0]+20,xy[1]+15], 0, 0);
    } else if(unit.hp == 0 && unit.team == 'player') {
        // draw zombie skull
        GameArt.assets['repair_skull'].states['normal'].draw([xy[0]+20,xy[1]+15], 0, 0);
    } else if((unit.hp > 0) && ((unit.hp / unit.max_hp) < gamedata['zombie_debuff_threshold']) && unit.team == 'player') {
        // when at home base, show yellow wrench unconditionally when at critical damage
        // but when attacking, only show if the weak_zombie aura truly applies (i.e. ignore battle damage that occurs DURING the fight).
        var show_yellow_wrench = session.home_base || unit.is_weak_zombie();
        if(show_yellow_wrench) {
            GameArt.assets['repair_wrench_yellow'].states['normal'].draw([xy[0]+20,xy[1]+15], 0, 0);
        }
    }

    // ping to make sure we bring the object up as soon as possible
    if(unit.is_under_repair() && (unit.hp == 0 || server_time > unit.under_repair_finish)) {
        request_unit_repair_update();
    }



    // draw ai state
    if(AI_DEBUG) {
        draw_centered_text(ctx, control_state_names[unit.control_state], [xy[0],xy[1]+30]);
        draw_centered_text(ctx, ai_state_names[unit.ai_state] + (unit.ai_aggressive ? '(Agg)' : ''), [xy[0],xy[1]+45]);
        draw_centered_text(ctx, 'DEST: '+(unit.ai_dest ? unit.ai_dest[0]+','+unit.ai_dest[1] : 'null'), [xy[0],xy[1]+60]);
        if(unit.squad_id) {
            draw_centered_text(ctx, 'SQUAD: '+unit.squad_id.toString(), [xy[0],xy[1]+75]);
        } else if(unit.pack_id) {
            draw_centered_text(ctx, 'PACK: '+unit.pack_id, [xy[0],xy[1]+75]);
        }
        if(unit.ai_threatlist !== null) {
            var s_list = goog.array.map(unit.ai_threatlist, function(entry) { return JSON.stringify(entry); });
            var s = s_list.join("\n");
            if(s) {
                draw_centered_text(ctx, s, [xy[0], xy[1]+75]);
            }
        }
        if(GameTypes.TickCount.lt(world.combat_engine.cur_tick, unit.ai_leash_after)) {
            draw_centered_text(ctx, '(leashing suppressed)', [xy[0],xy[1]+90]);
        } else if(unit.is_leashing) {
            draw_centered_text(ctx, 'LEASHING', [xy[0],xy[1]+90]);
        }
    }

    // draw auras
    var count = 0;
    if(unit.combat_stats.stunned && !unit.is_destroyed()) {
        GameArt.assets['stun_icon'].states['normal'].draw([xy[0]+15*count,xy[1]-25], 0, 0);
        count++;
    }

    for(var i = 0; i < unit.auras.length; i++) {
        var aura = unit.auras[i];
        if(aura.visual_effect) {
            aura.visual_effect.reposition([curpos[0], unit.combat_stats.altitude, curpos[1]]);
        }
        if(draw_aura(xy, [xy[0]+15*count, xy[1]-35], aura)) {
            count++;
        }
    }

    if(CLICK_DETECTION_DEBUG) { draw_click_detection(unit); }

    unit.update_permanent_effect(world);

    // return whether unit is visible on screen or not (in addition to being unculled), for the purpose of determining whether to show the offscreen-unit arrow
    var visible = (xy[0] >= view_roi[0][0] &&
                   (xy[0] < view_roi[1][0]) &&
                   (xy[1] >= view_roi[0][1]) &&
                   (xy[1] < view_roi[1][1]));
    return visible;
}

/** @param {Array.<number>} xy
    @param {Array.<number>} indicator_xy
    @param {!Aura} aura
    @return {boolean} if shown */
function draw_aura(xy, indicator_xy, aura) {
    if(aura.spec['visual_effect'] // aura has its own graphics
       || aura.spec['show'] === 0 // aura is hidden
      ) { return false; } // don't draw

    // skip weak_zombie here
    // (it's handled separately for UI consistency when debuff is not actually applied)
    if(('effects' in aura.spec) && aura.spec['effects'].length > 0) {
        for(var j = 0; j < aura.spec['effects'].length; j++) {
            var eff = aura.spec['effects'][j];
            if(eff['code'] === 'weak_zombie' || eff['code'] === 'weak_secteam') {
                return false;
            }
        }
    }

    var color;
    if('color' in aura.spec) {
        var c = SPUI.make_colorv(aura.spec['color']);
        color = c.str().split(',').slice(0,3).join(',')+',';
    } else if('help' in aura.spec) {
        color = 'rgba(0,50,255,';
    } else if('harm' in aura.spec) {
        color = 'rgba(255,50,0,';
    } else {
        color = 'rgba(200,200,200,'
    }

    if(aura.range > 0) {
        ctx.save();
        ctx.fillStyle = color+'0.125)';
        ctx.strokeStyle = color+'0.25)';
        ctx.transform(1, 0, 0, 0.5, xy[0], xy[1]);
        ctx.beginPath();
        ctx.arc(0, 0, 10*gamedata['map']['range_conversion'] * aura.range, 0, 2*Math.PI, false);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }

    draw_clock(indicator_xy, color+'1.0)', aura.start_tick, aura.expire_tick);
    return true;
}

/** @param {Array.<number>} xy
    @param {string} color
    @param {!GameTypes.TickCount} start_tick
    @param {!GameTypes.TickCount} end_tick */
function draw_clock(xy, color, start_tick, end_tick) {
    var world = session.get_draw_world();
    if(GameTypes.TickCount.lt(world.combat_engine.cur_tick, start_tick) ||
       GameTypes.TickCount.gt(world.combat_engine.cur_tick, end_tick)) { return; }
    var client_tick_smooth = world.combat_engine.cur_tick.get() + Math.min((client_time - world.last_tick_time)/(TICK_INTERVAL/combat_time_scale()), 1);
    var progress;
    if(end_tick.get() - start_tick.get() > 1.5/TICK_INTERVAL) {
        progress = (client_tick_smooth - start_tick.get()) / (end_tick.get() - start_tick.get());
    } else {
        progress = 1;
    }
    progress = Math.min(Math.max(progress,0.001),0.999);
    var radius = 10;
    ctx.save();
    ctx.globalAlpha = 0.5;

    // circular background
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(xy[0]+radius,xy[1]+radius,radius, 0,2*Math.PI,false);
    ctx.fill();

    // sweeping "clock timer"
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath();
    ctx.moveTo(xy[0]+radius,xy[1]+radius);
    ctx.lineTo(xy[0]+radius,xy[1]);
    ctx.arc(xy[0]+radius, xy[1]+radius, radius, 0-Math.PI/2, 2*Math.PI*(progress)-Math.PI/2, true);
    ctx.lineTo(xy[0]+radius,xy[1]+radius);
    ctx.fill();

    ctx.restore();
}

function draw_unit_control_order_segment(xy, state, d) {
    ctx.beginPath();
    ctx.strokeStyle = gamedata['client']['unit_control_colors'][(state == ai_states.AI_ATTACK_MOVE || state == ai_states.AI_ATTACK_MOVE_AGGRO || state == ai_states.AI_ATTACK_SPECIFIC) ? 'amove_later' : 'move_later'];
    xy = draw_quantize(xy);
    ctx.moveTo(xy[0], xy[1]);

    xy = draw_quantize(ortho_to_draw(d));
    ctx.lineTo(xy[0], xy[1]);

    if(gamedata['client']['unit_control_detail'] >= 2) { // arc drawing is slow
        ctx.save();
        ctx.transform(1, 0, 0, 0.5, xy[0], xy[1]);
        ctx.arc(0, 0, 6, 0, 2*Math.PI, false);
        ctx.stroke();
        ctx.restore();
    } else {
        ctx.stroke();
    }

    return xy;
}

// draw one step in the order queue
// NOTE: xy will be updated to point to the "endpoint" of this order
function draw_unit_control_order(world, xy, ord) {
    var d;
    if(ord['target'] && world.objects.has_object(ord['target'])) {
        d = world.objects.get_object(ord['target']).interpolate_pos(world);
    } else if(ord['dest']) {
        d = vec_add(ord['dest'], [0.5,0.5]);
    } else {
        return xy;
    }

    return draw_unit_control_order_segment(xy, ord['state'], d);
}

/** @param {!World.World} world
    @param {!GameObject} unit
    @param {!Array<number>} curpos */
function draw_unit_control(world, unit, curpos) {
    //ctx.save();
    var xy = draw_quantize(ortho_to_draw(curpos));

    // draw line to target
    var target_line_drawn = false;

    if(unit.control_target_id &&
       world.objects.has_object(unit.control_target_id) &&
       (unit.control_state != control_states.CONTROL_STOP)) {
        var target = world.objects.get_object(unit.control_target_id);
        if(target) {
            ctx.strokeStyle = gamedata['client']['unit_control_colors']['target'];
            ctx.beginPath();
            ctx.moveTo(xy[0],xy[1]);
            var target_pos = target.interpolate_pos(world);
            var target_xy = draw_quantize(ortho_to_draw(target_pos));
            ctx.lineTo(target_xy[0], target_xy[1]);
            ctx.stroke();
            target_line_drawn = true;
        }
    }

    if(unit.path_valid && unit.path.length >= 1 &&
       unit.ai_state !== ai_states.AI_ATTACK_SPECIFIC &&
        unit.ai_state !== ai_states.AI_ATTACK_STATIONARY &&
       (unit.ai_state !== ai_states.AI_ATTACK_ANY || unit.control_state === control_states.CONTROL_MOVING)) {
        //if(unit.path.length < 1) { return; }
        if(unit.ai_state === ai_states.AI_ATTACK_MOVE || unit.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO) {
            ctx.strokeStyle = gamedata['client']['unit_control_colors']['amove_now'];
        } else {
            ctx.strokeStyle = gamedata['client']['unit_control_colors']['move_now'];
        }
        //ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(xy[0], xy[1]);
        for(var i = 0; i < unit.path.length; i++) {
            xy = draw_quantize(ortho_to_draw(vec_add(unit.path[i],[0.5,0.5])));
            ctx.lineTo(xy[0], xy[1]);
        }

        if(gamedata['client']['unit_control_detail'] >= 2) { // arc drawing is slow
            ctx.save();
            ctx.transform(1, 0, 0, 0.5, xy[0], xy[1]);
            ctx.arc(0, 0, 6, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.restore();
        } else {
            ctx.stroke();
        }
    }

    if(!unit.is_mobile()) { return; }

    if(typeof unit.orders == 'undefined') {
        console.log('unit.orders undefined!');
        console.log(unit);
        return;
    }

    if(unit.is_mobile() && unit.orders.length > 0 &&
       (unit.orders.length > 1 || !target_line_drawn)) {

        for(var i = 0; i < unit.orders.length; i++) {
            var ord = unit.orders[i];
            xy = draw_unit_control_order(world, xy, ord);
        }

        if(unit.patrol) {
            xy = draw_unit_control_order_segment(xy, unit.orders[unit.orders.length-1]['state'], curpos);
        }
    }
    //ctx.restore();
};

function draw_drag_selection() {
    if(!mouse_state.has_dragged) { return; }

    var xmin = Math.min(mouse_state.drag_start_x, mouse_state.last_x);
    var xmax = Math.max(mouse_state.drag_start_x, mouse_state.last_x);
    var ymin = Math.min(mouse_state.drag_start_y, mouse_state.last_y);
    var ymax = Math.max(mouse_state.drag_start_y, mouse_state.last_y);

    ctx.save();
    ctx.strokeStyle = 'rgba(0,255,0,0.8)';
    ctx.fillStyle = 'rgba(0,255,0,0.18)';
    ctx.beginPath();
    ctx.moveTo(xmin, ymin);
    ctx.lineTo(xmax, ymin);
    ctx.lineTo(xmax, ymax);
    ctx.lineTo(xmin, ymax);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
};

/** @param {!World.World} world
    @param {GameObject} unit
    @param {string=} config_override */
function draw_selection_highlight(world, unit, config_override) {
    var curpos = unit.interpolate_pos(world);
    ctx.save();

    var config_name;
    if(config_override) {
        config_name = config_override;
    } else if(unit.team !== 'player') {
        config_name = 'enemy';
    } else if(unit.ai_state === ai_states.AI_ATTACK_STATIONARY) {
        config_name = 'hold_position';
    } else if(unit.ai_aggressive) {
        config_name = 'aggressive';
    } else {
        config_name = 'normal';
    }
    var config = gamedata['client']['unit_highlights'][config_name];
    var stroke_alpha = config['stroke_alpha'];

    ctx.strokeStyle = config['basecol']+stroke_alpha.toString()+')';
    ctx.fillStyle = config['basecol']+config['fill_alpha'].toString()+')';

    if(unit.is_mobile()) {
        unit = /** @type {!Mobile} */ (unit);

        // draw ellipse underneath the object
        var xy = draw_quantize(ortho_to_draw(curpos));

        if(gamedata['client']['unit_selection_shape'] == 'arc') { // arc drawing is slow
            ctx.save();
            ctx.beginPath();
            ctx.transform(1, 0, 0, 0.5, xy[0], xy[1]);
            ctx.arc(0, 0, Math.floor(10*config['ring_size']*unit.spec['gridsize'][0]), 0, 2*Math.PI, false);
            ctx.fill();
            if(stroke_alpha > 0) { ctx.stroke(); }
            ctx.restore();
        } else if(gamedata['client']['unit_selection_shape'] == 'rectangle') {
            var r = Math.floor(8*config['ring_size']*unit.spec['gridsize'][0]);
            ctx.fillRect(xy[0]-r, xy[1]-r/2, 2*r, r);
            if(stroke_alpha > 0) {
                ctx.strokeRect(xy[0]-r, xy[1]-r/2, 2*r, r);
            }
        } else if(gamedata['client']['unit_selection_shape'] == 'diamond') {
            var r = Math.floor(10*config['ring_size']*unit.spec['gridsize'][0]);
            ctx.beginPath();
            ctx.moveTo(xy[0]-r, xy[1]);
            ctx.lineTo(xy[0], xy[1]-r/2);
            ctx.lineTo(xy[0]+r, xy[1]);
            ctx.lineTo(xy[0], xy[1]+r/2);
            ctx.closePath();
            ctx.fill();
            if(stroke_alpha > 0) { ctx.stroke(); }
        }

        // draw weapon range
        if(unit.team === 'player' &&
           (gamedata['client']['always_draw_mobile_weapon_range'] || unit.is_invisible())) {
            var ran = unit.weapon_range();
            var range = ran[1], aoe = ran[2], min_range = ran[4];
            if(range > 0) {
                draw_weapon_range(xy, range, true, false, min_range, null);
            }
        }

        if(unit.combat_stats.altitude > 0 && gamedata['client']['unit_control_detail'] >= 2) {
            // draw height line for flying units
            var xya = draw_quantize(ortho_to_draw_3d([curpos[0], unit.combat_stats.altitude, curpos[1]]));
            ctx.strokeStyle = config['basecol']+config['altitude_alpha'].toString()+')';
            ctx.beginPath();
            ctx.moveTo(xy[0], xy[1]);
            ctx.lineTo(xya[0], xya[1]);
            if(stroke_alpha > 0) { ctx.stroke(); }
        }
    } else {
        // draw rectangular outline for buildings
        var bound = get_grid_bounds(curpos, unit.spec['gridsize']);
        ctx.beginPath();
        SPUI.add_quad_to_path([draw_quantize(ortho_to_draw([bound[0][0], bound[1][0]])),
                               draw_quantize(ortho_to_draw([bound[0][1], bound[1][0]])),
                               draw_quantize(ortho_to_draw([bound[0][1], bound[1][1]])),
                               draw_quantize(ortho_to_draw([bound[0][0], bound[1][1]]))]);
        ctx.fill();
        if(stroke_alpha > 0) { ctx.stroke(); }
    }
    if(unit.team === 'player') {
        draw_unit_control(world, unit, curpos);
    }
    ctx.restore();
}

/** @param {!GameObject} unit */
function draw_click_detection(unit) {
    var world = session.get_draw_world();

    ctx.save();
    // color uniquely
    var COLORS = ['rgb(255,0,0)','rgba(0,255,0)','rgb(0,0,255)'];
    var index = unit.id.charCodeAt(unit.id.length-1);
    ctx.fillStyle = ctx.strokeStyle = COLORS[index % COLORS.length];
    ctx.globalAlpha = 0.15;
    var position_fuzz = 2;
    if(unit.is_building()) {
        var pos = unit.interpolate_pos(world);
        var bound = get_grid_bounds(pos, unit.spec['gridsize']);
        ctx.beginPath();
        SPUI.add_quad_to_path([ortho_to_draw([bound[0][0], bound[1][0]]),
                               ortho_to_draw([bound[0][1], bound[1][0]]),
                               ortho_to_draw([bound[0][1], bound[1][1]]),
                               ortho_to_draw([bound[0][0], bound[1][1]])]);
        ctx.fill();
        ctx.stroke();

        if(unit.spec['click_bounds']) {
            var c = ortho_to_playfield(pos);
            var b = unit.spec['click_bounds'];
            ctx.save();
            set_default_canvas_transform(ctx); // undo playfield transform
            ctx.beginPath();
            SPUI.add_quad_to_path([playfield_to_screen([c[0]+b[0][0], c[1]+b[1][0]]),
                                   playfield_to_screen([c[0]+b[0][1], c[1]+b[1][0]]),
                                   playfield_to_screen([c[0]+b[0][1], c[1]+b[1][1]]),
                                   playfield_to_screen([c[0]+b[0][0], c[1]+b[1][1]])]);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        } else if(unit.spec['click_detection'] == 'sprite') {
            var asset = GameArt.assets[unit.get_leveled_quantity(unit.spec['art_asset'])];
            var sprite = asset.states['normal'];
            var cound = sprite.detect_click_bounds(ortho_to_screen(pos), unit.interpolate_facing(world), client_time, view_zoom, position_fuzz);
            if(cound) {
                ctx.save();
                set_default_canvas_transform(ctx); // undo playfield transform
                ctx.beginPath();
                SPUI.add_quad_to_path([[cound[0][0], cound[1][0]],
                                       [cound[0][1], cound[1][0]],
                                       [cound[0][1], cound[1][1]],
                                       [cound[0][0], cound[1][1]]]);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
        }
    }
    ctx.restore();
}

/** @param {CanvasRenderingContext2D} ctx
    @param {string} str
    @param {!Array<number>} xy
    @return {!Array<number>} */
function draw_centered_text_with_shadow(ctx, str, xy) {
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,1)';
    draw_centered_text(ctx, str, vec_add(xy, [1,1]));
    ctx.restore();
    return draw_centered_text(ctx, str, xy);
}

/** @param {CanvasRenderingContext2D} ctx
    @param {string} str
    @param {!Array<number>} xy
    @return {!Array<number>} */
function draw_centered_text(ctx, str, xy) {
    var ret = vec_copy(xy);
    var lines = str.split('\n');
    for(var i = 0; i < lines.length; i++) {
        if(lines[i].length > 0) {
            var dims = ctx.measureText(lines[i]);
            var text_xy = draw_quantize(vec_add(xy, [-Math.floor(dims.width/2), i*SPUI.desktop_font.leading]));
            ret[0] = Math.min(ret[0], text_xy[0]);
            ctx.fillText(lines[i], text_xy[0], text_xy[1]);
        }
    }
    return ret;
}
function measure_centered_text(ctx, str, xy) { // saw as draw_centered_text(), but don't draw anything
    var ret = vec_copy(xy);
    var lines = str.split('\n');
    for(var i = 0; i < lines.length; i++) {
        if(lines[i].length > 0) {
            var dims = ctx.measureText(lines[i]);
            var text_xy = draw_quantize(vec_add(xy, [-Math.floor(dims.width/2), i*SPUI.desktop_font.leading]));
            ret[0] = Math.min(ret[0], text_xy[0]);
        }
    }
    return ret;
}

// return [width, height, yoffset] of unit health bar
GameObject.prototype.get_health_bar_dims = function() {
    return [50, 5, 40];
};
Mobile.prototype.get_health_bar_dims = function() {
    if('health_bar_dims' in this.spec) {
        return this.spec['health_bar_dims'];
    }
    return goog.base(this, 'get_health_bar_dims');
};
Building.prototype.get_health_bar_dims = function() {
    if('health_bar_dims' in this.spec) {
        return this.spec['health_bar_dims'];
    }
    return [Math.floor(120*this.spec['gridsize'][0]/12), 8, Math.floor(70 + 10*(this.spec['gridsize'][1]/12))];
};

function draw_health_bar(xy, obj) {
    var hp = obj.hp;
    var max_hp = obj.max_hp;

    if(obj.last_ui_hp_time == -1) { // init state for smooth transitions
        obj.last_ui_hp_stable = hp;
        obj.last_ui_hp = hp;
    }

    var show_at_full_health = (obj.is_mobile() &&
                               !obj.spec['never_show_full_health_bar'] &&
                               (get_preference_setting(player.preferences, 'always_show_unit_health') ||
                                gamedata['client']['always_show_unit_health']));

    if(!show_at_full_health && obj.is_mobile()) {
        // shortcut
        if(hp === 0 || hp === max_hp) {
            obj.last_ui_hp_time = client_time;
            return;
        }
    }

    var dims = obj.get_health_bar_dims();
    var w = dims[0], h = dims[1], yoff = dims[2];

    if(obj.is_building() && obj.is_repairing()) {
        // estimate HP level
        var rep = 1 + (server_time - obj.repair_finish_time)/(obj.get_leveled_quantity(obj.spec['repair_time'])/obj.get_stat('repair_speed',1));
        hp = Math.floor(/*(1-rep)*obj.hp + */ rep*max_hp);
    }

    var displayed_hp;
    var trans_time = gamedata['client']['health_bar_transition_time'] || 0;
    if(trans_time > 0 && hp != obj.last_ui_hp_stable) { // perform smooth transition
        var rate = max_hp / trans_time; // "seconds per HP bar"
        // make rate faster for smaller health bars and slower for larger health bars, so it's basically constant in screen space
        rate *= 50/dims[0];
        var delta_t = (client_time - obj.last_ui_hp_time);
        var sign = (hp < obj.last_ui_hp ? -1 : 1);
        var delta_hp = sign * rate * delta_t;
        if(Math.abs(delta_hp) >= Math.abs(hp - obj.last_ui_hp)) {
            // transition done, reset the stable level
            displayed_hp = hp;
            obj.last_ui_hp_stable = hp;
        } else {
            displayed_hp = obj.last_ui_hp + delta_hp;
        }
    } else {
        displayed_hp = hp;
    }
    obj.last_ui_hp = displayed_hp;
    obj.last_ui_hp_time = client_time;


    ctx.save();

    if((displayed_hp!=0) &&
       (show_at_full_health || (displayed_hp < max_hp))) {

        var throb_speed = -1;
        if(obj.is_building() && obj.is_repairing()) {
            //if((obj.repair_finish_time - server_time) >= Store.get_free_speedup_time(player)) {
            if(player.tutorial_state === "COMPLETE") {
                throb_speed = 12;
            } else {
                throb_speed = 90;
            }
        }
        var color_set = gamedata['client'][(obj.team === 'enemy' ? 'health_bar_colors_enemy' : 'health_bar_colors_friendly')];

        // optionally add tickmarks on the bar to represent large amounts of HP
        var num_ticks = 0;

        /* logarithmic calculation example based on FS:
        var log_scale_min = Math.log10(150);
        var log_scale_max = Math.log10(150000);
        var scale = (Math.log10(max_hp) - log_scale_min) / (log_scale_max - log_scale_min);
        scale = clamp(scale, 0, 1);
        num_ticks = Math.floor(2 + (20 - 2) * scale);
        */

        if('health_bar_ticks' in obj.spec) {
            num_ticks = obj.get_leveled_quantity(obj.spec['health_bar_ticks']);
        }

        draw_bar([xy[0]-Math.floor(w/2), xy[1]-yoff], w, h,
                 Math.floor(w*(clamp(hp/max_hp,0,1))),
                 Math.floor(w*(clamp(displayed_hp/max_hp,0,1))),
                 color_set, throb_speed, num_ticks);
    }

    // also draw progress bar for building actions
    var progress = -1;
    if((obj.is_building() || obj.is_inert()) && obj.is_removing()) {
        progress = obj.remove_progress();
    } else if(obj.is_building()) {
        if(obj.is_under_construction()) {
            progress = obj.build_progress();
        } else if(obj.is_upgrading()) {
            progress = obj.upgrade_progress();
        } else if(obj.is_enhancing()) {
            progress = obj.enhance_progress();
        } else if(obj.is_researching()) {
            progress = obj.research_progress();
        } else if(obj.is_crafting()) {
            progress = obj.crafting_progress_one();
        } else if(obj.is_manufacturing()) {
            progress = obj.manuf_progress_one();
        }
    }

    if(progress > -1 && (progress < 1 || obj.team == 'player')) {
        progress = clamp(progress, 0, 1);
        var pw = w, ph = 6, pyoff = yoff - 12;
        var prog = Math.floor(pw*progress);
        draw_bar([xy[0]-Math.floor(pw/2), xy[1]-pyoff],
                 pw,
                 ph, prog, prog,
                 gamedata['client']['progress_bar_colors'], 10, 0);
    }

    ctx.restore();
}

/**
 * Test params
 * @param {number} w
 * @param {number} h
 * @param {number} prog - instantaneous progress, pixels
 * @param {number} prog2 - transitioning progress, pixels
 * @param {number} throb_speed
 * @param {number} num_ticks
 */
function draw_bar(xy, w, h, prog, prog2, colors, throb_speed, num_ticks) {

    /** evaluate a color specified in gamedata, which could be either a literal string (HTML5 canvas color)
        or a step-function specified as an array [[min_prog, color], [min_prog, color], ...]
        @param {?} data
        @param {number} p
        @param {number} max_p
        @return {string} */
    function get_color(data, p, max_p) {
        if(typeof(data) === 'string') {
            return data; // literal string
        } else {
            // array indexed by min 'p' ratio
            var r = p/max_p;
            var i;
            for(i = 0; i < data.length; i++) {
                var entry = data[i];
                if(r < entry[0]) {
                    i -= 1;
                    break;
                }
            }
            i = Math.min(Math.max(i, 0), data.length-1);
            return data[i][1];
        }
    };

    // fill center/background
    ctx.fillStyle = colors['bg'];
    ctx.fillRect(xy[0], xy[1], w, h);
    // fill "progress" area
    ctx.fillStyle = get_color(colors['fg'], prog, w);
    ctx.fillRect(xy[0], xy[1], prog, h);
    ctx.lineWidth = (h >= 6 ? 2 : 1);
    ctx.strokeStyle = get_color(colors['highlight'], prog, w);
    ctx.beginPath();
    ctx.moveTo(xy[0], xy[1]+1);
    ctx.lineTo(xy[0]+prog, xy[1]+1);
    ctx.stroke();

    if(prog2 > prog) {
        ctx.fillStyle = get_color(colors['fg_transition'], prog2, w);
        ctx.fillRect(xy[0]+prog, xy[1], prog2 - prog, h);
    }

    // throbbing NOTE: disabled for now
    /*
    if(0 && throb_speed > 0) {
        ctx.strokeStyle = '#FFFFFF';
        ctx.globalAlpha = 0.4;
        ctx.lineWidth = 3;
        var NBARS = 5;
        ctx.beginPath();
        var margin = 2;
        var spacing = (w-2*margin) / NBARS;
        for(var i = 0; i < NBARS; i++) {
            var bar_x = Math.floor(i*spacing + client_time*throb_speed) % (w-2*margin);
            ctx.moveTo(xy[0]+bar_x+margin, xy[1]);
            ctx.lineTo(xy[0]+bar_x+margin, xy[1]+h);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
    }
    */

    // stroke tickmarks
    if(num_ticks > 0) {
        var tick_spacing = w / num_ticks;
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = colors['tick'];
        for(var tx = tick_spacing; tx <= w /*Math.max(prog, prog2)*/; tx += tick_spacing) {
            var origin = draw_quantize([xy[0] + tx, xy[1]]);
            ctx.moveTo(origin[0], origin[1]);
            ctx.lineTo(origin[0], origin[1] + h);
        }
        ctx.stroke();
    }

    // stroke outline
    ctx.lineWidth = 1; // (h >= 6 ? 2 : 1);
    ctx.strokeStyle = colors['outline'];
    ctx.strokeRect(xy[0], xy[1], w, h);
};

function draw_debug_astar_paths(world) {
    ctx.save();

    world.objects.for_each(function(unit) {
        if(!unit.is_mobile() ||
           unit.path.length < 1) {
            return;
        }

        var path = unit.path;

        ctx.strokeStyle = (unit.path_new ? '#ffffff' : (unit.path_valid ? '#ffff00' : '#ff0000'));
        ctx.lineWidth = (unit.path_new ? 3 : 1);
        unit.path_new = false;
        ctx.beginPath();

        var pos = unit.interpolate_pos(world);
        var xy = ortho_to_draw(pos);
        ctx.moveTo(xy[0], xy[1]);
        for(var i = 0; i < path.length; i++) {
            xy = ortho_to_draw(vec_add(path[i], [0.5,0.5]));
            ctx.lineTo(xy[0], xy[1]);
        }
        ctx.stroke();
    });
    ctx.restore();
};

/** @param {!World.World} world */
function draw_debug_map(world) {
    ctx.save();
    ctx.font = SPUI.make_font(8, 12, 'normal').str();

    var ncells = world.base.ncells();

    for(var i = 0; i < ncells[1]; i++) {
        for(var j = 0; j < ncells[0]; j++) {
            var xy = ortho_to_draw([j,i]);
            var sprite;
            if(!world.astar_map.is_blocked([j,i])) {
                continue; // skip clear cells
                //ctx.strokeStyle = "green";
                //sprite = GameArt.assets['TEMP_mapcell'].states['open'].images[0];
            } else {
                ctx.strokeStyle = "red";
                sprite = /** @type {!GameArt.Sprite} */ (GameArt.assets['TEMP_mapcell'].states['blocked']).images[0];
            }

            // translate to upper-left corner of cell sprite (left of the diamond tip)
            xy = [xy[0]-cellsize[0]/2,xy[1]];

            // cull against view bounds
            if((xy[0]+cellsize[0] < view_roi[0][0]) ||
               (xy[0] > view_roi[1][0]) ||
               (xy[1]+cellsize[1] < view_roi[0][1]) ||
               (xy[1] > view_roi[1][1])) {
                // cull
                continue;
            }

            // draw grid cell as sprite
            sprite.drawSubImage([0,0], sprite.wh, xy, sprite.wh);
        }
    }
    ctx.restore();

    if(world.astar_context) { world.astar_context.debug_draw(ctx); }
}

function test_consequent(cons) {
    read_consequent(cons).execute();
};

goog.exportSymbol('SPINPUNCHGAME.init', SPINPUNCHGAME.init);
goog.exportSymbol('SPINPUNCHGAME.shutdown', SPINPUNCHGAME.shutdown);
goog.exportSymbol('start_ai_attack', start_ai_attack);
goog.exportSymbol('visit_base', visit_base);
goog.exportSymbol('change_region', change_region);
goog.exportSymbol('test_fancy_victory_dialog', test_fancy_victory_dialog);
goog.exportSymbol('test_you_were_attacked_dialog', test_you_were_attacked_dialog);
goog.exportSymbol('test_notify_achievements', test_notify_achievements);
goog.exportSymbol('test_flash_offer', test_flash_offer);
goog.exportSymbol('test_consequent', test_consequent);
goog.exportSymbol('invoke_post_screenshot', invoke_post_screenshot);
goog.exportSymbol('sprobe_run', sprobe_run);
goog.exportSymbol('invoke_gift_prompt_dialog', invoke_gift_prompt_dialog);
goog.exportSymbol('invoke_daily_tip', invoke_daily_tip);
goog.exportSymbol('invoke_splash_message', invoke_splash_message);
goog.exportSymbol('invoke_region_map_replay', RegionMapReplay.invoke);
goog.exportSymbol('invoke_battle_replay', BattleReplay.invoke);
goog.exportSymbol('give_me_item', give_me_item);
goog.exportSymbol('load_ai_base', load_ai_base);
goog.exportSymbol('save_ai_base', save_ai_base);
goog.exportSymbol('publish_ai_base', publish_ai_base);
goog.exportSymbol('do_visit_base', do_visit_base);
goog.exportSymbol('enable_muffins', enable_muffins);
goog.exportSymbol('anon_mode', anon_mode);
goog.exportSymbol('FORCE_BASE_DAMAGE_PING', FORCE_BASE_DAMAGE_PING);
goog.exportSymbol('metric_event', metric_event); // for calling by spin_header_content/spin_footer_content

// this global name conflicts with one of Facebook or our advertising systems' JavaScript
var js = null;
goog.exportSymbol('js', js);
