goog.provide('SPINPUNCHGAME');

// Copyright (c) 2015 SpinPunch. All rights reserved.
// Use of this source code is governed by an MIT-style license that can be
// found in the LICENSE file.

/** @fileoverview
    @suppress {reportUnknownTypes} XXX we are not typesafe yet
*/

goog.require('goog.object');
goog.require('goog.array');
goog.require('goog.net.XhrIo');
goog.require('goog.net.ErrorCode');
goog.require('goog.crypt.base64');
goog.require('Iuppiter');
goog.require('lz4');

goog.require('AStar');
goog.require('ModChain');
goog.require('Predicates');
goog.require('Consequents');
goog.require('PlayerCache');
goog.require('AllianceCache');
goog.require('BattleLog');
goog.require('ChatFilter');
goog.require('Congrats');
goog.require('GameArt');
goog.require('GameTypes');
goog.require('SPUI');
goog.require('SPText');
goog.require('SPHTTP');
goog.require('SPFX');
goog.require('SPFB');
goog.require('FBInviteFriends');
goog.require('FBSendRequests');
goog.require('SPay');
goog.require('SProbe');
goog.require('SPWebsocket');
goog.require('SPVideoWidget');
goog.require('ItemDisplay');
goog.require('Dripper');
goog.require('CombatEngine');
goog.require('Showcase');
goog.require('TurretHeadDialog');
goog.require('QuestBar');
goog.require('UpgradeBar');
goog.require('RegionMap');
goog.require('RegionMapIndex');
goog.require('TeamMapAccelerator');
goog.require('VoxelMapAccelerator');
goog.require('buzz');
goog.require('Traceback');
goog.require('Citizens');

// detect whether browser has touch-screen events
var touch_modes = {
    NONE : 0,
    TOUCHEVENT : 1,
    MSPOINTER: 2
}
var touch_mode = touch_modes.NONE;
var touch_primary = false; // true if touch is the primary input method (changes unit movement behavior)

if(typeof Touch === 'object') {
    touch_mode = touch_modes.TOUCHEVENT;
    touch_primary = true;
} else if(window.navigator['msPointerEnabled'] && window.navigator['msMaxTouchPoints'] > 1) {
    // be conservative here and only enable MSPointer on multi-touch hardware
    // in the future MSPointer could replace mouse input on IE10+
    touch_mode = touch_modes.MSPOINTER;
    // touch_primary is detected from MSPointerMove events
}

// for iOS: <meta name="viewport" content="width=device-width, initial-scale=0.5, user-scalable=no"/>
// but need canvas scaling

//
// function library
//

// for debug message printing use console.log()
if(!window.console) { window.console = /** @type {!Console} */ ({}); };
if(!window.console.log) { window.console.log = function(){}; };

function get_query_string(name) {
    var query = window.location.search;
    var start = query.indexOf(name+'=');
    if(start == -1) { return null; }
    start += name.length+1;
    var end = query.indexOf('&', start);
    if(end == -1) { end = query.length; }
    return query.substring(start, end);
};

function chrome_version_atleast(min_big, min_major, min_minor, min_release) {
    var ua = navigator.userAgent;
    var m = ua.match(new RegExp('Chrome/([0-9]+).([0-9]+).([0-9]+).([0-9]+)'));
    if(m) {
        var big = parseInt(m[1],10), major = parseInt(m[2],10), minor = parseInt(m[3],10), release = parseInt(m[4],10);
        if(big < min_big) {
            return false;
        } else if(big > min_big) {
            return true;
        } else {
            if(major < min_major) {
                return false;
            } else if(major > min_major) {
                return true;
            } else {
                if(minor < min_minor) {
                    return false;
                } else if(minor > min_minor) {
                    return true;
                } else {
                    return (release >= min_release);
                }
            }
        }
    }
    return false;
};

function clamp(x,a,b) {
    if(x < a)
        return a;
    if(x > b)
        return b;
    return x;
}

function log10(x) { return Math.log(x)/Math.log(10.0); }

/** @param {!Array.<number>} v
    @return {!Array.<number>} */
function vec_copy(v) { return [v[0], v[1]]; }

/** @param {!Array.<number>} v
    @param {!Array.<number>} w
    @return {!Array.<number>} */
function vec_add(v, w) {
    return [v[0]+w[0],v[1]+w[1]];
}
/** @param {!Array.<number>} v
    @param {!Array.<number>} w
    @return {!Array.<number>} */
function vec_mul(v, w) {
    return [v[0]*w[0], v[1]*w[1]];
}
function vec_div(v, w) {
    return [v[0]/w[0], v[1]/w[1]];
}
function vec_max(v, w) { return [Math.max(v[0],w[0]), Math.max(v[1],w[1])]; }

/** @param {!Array.<number>} v
    @return {!Array.<number>} */
function vec_floor(v) { return [Math.floor(v[0]), Math.floor(v[1])]; }

function vec_mod(v, n) { return [v[0]%n, v[1]%n]; }
function v3_add(v, w) { return [v[0]+w[0], v[1]+w[1], v[2]+w[2]]; }
function v3_sub(v, w) { return [v[0]-w[0], v[1]-w[1], v[2]-w[2]]; }

/** @param {!Array.<number>} v
    @param {!Array.<number>} w
    @return {!Array.<number>} */
function vec_sub(v, w) {
    return [v[0]-w[0],v[1]-w[1]];
}

function vec_scale(s, v) {
    return [s*v[0],s*v[1]];
}
function vec_lerp(a, b, x) {
    return vec_add(a, vec_scale(x, vec_sub(b, a)));
}
function lerp(a, b, x) {
    return a + x*(b-a);
}

function v3_scale(s, v) { return [s*v[0], s*v[1], s*v[2]]; }

function v3_length(v) { return Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); }
function v3_distance(a, b) {
    var dx = b[0] - a[0], dy = b[1] - a[1], dz = b[2] - a[2];
    return Math.sqrt(dx*dx + dy*dy + dz*dz);
}
function v3_mad(v, s, w) { return [v[0]+s*w[0], v[1]+s*w[1], v[2]+s*w[2]]; }
function v3_mul(v, w) { return [v[0]*w[0], v[1]*w[1], v[2]*w[2]]; }

function v3_normalized(v) {
    var len = v3_length(v);
    if(len > 0) {
        return [v[0]/len, v[1]/len, v[2]/len];
    } else {
        return [0,1,0];
    }
}

function v3_rotate_by_facing(facing, v) {
    // facing=0 means looking east, convert that so that angle=0 when facing north
    var angle = facing + 0.5*Math.PI;
    var c = Math.cos(angle), s = Math.sin(angle);
    var x =  c*v[0]-s*v[2];
    var z =  s*v[0]+c*v[2];
    return [x,v[1],z];
}

// V + s * W
function vec_mad(v, s, w) { return [v[0]+s*w[0], v[1]+s*w[1]]; }

function vec_dot(a,b) { return a[0]*b[0]+a[1]*b[1]; }
function vec_length2(v) { return v[0]*v[0]+v[1]*v[1]; }
function vec_length(v) { return Math.sqrt(v[0]*v[0]+v[1]*v[1]); }

/** @param {!Array.<number>} a
    @param {!Array.<number>} b
    @return {number} */
function vec_distance(a, b) {
    var dx = b[0] - a[0], dy = b[1] - a[1];
    return Math.sqrt(dx*dx + dy*dy);
}

function vec_normalized(v) {
    var len = vec_length(v);
    return [v[0]/len, v[1]/len];
}

var POSITION_EPSILON = 0.01;

function vec_equals(v, w) {
    var delta = vec_sub(v,w);
    if((delta[0]*delta[0]+delta[1]*delta[1]) < POSITION_EPSILON*POSITION_EPSILON) {
        return true;
    } else {
        return false;
    }
}

function vec_equals_integer(v, w) {
    if(Math.floor(v[0]) == Math.floor(w[0]) &&
       Math.floor(v[1]) == Math.floor(w[1])) {
        return true;
    }
    return false;
}

/** @param {!Array.<!Array.<number>>} ls
    @return {!Array.<!Array.<number>>} */
function vec_list_reversed(ls) {
    return ls.reverse();
}

function vec_print(v) { return v[0].toString()+','+v[1].toString(); };

function hex_slanted(a) {
    // transform to "slanted" coordinate system for easier distance computation
    var new_x = a[0] - Math.floor(a[1]/2);
    return [new_x, a[1]];
}
function hex_distance(a,b) {
    var a2 = hex_slanted(a), b2 = hex_slanted(b);
    var dx = b2[0]-a2[0], dy = b2[1]-a2[1];
    var dd = dx + dy;
    //console.log('dx '+dx+' dy '+dy+' dd '+dd);
    return Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dd));
}

// convert a floating-point number of seconds into a string like '10d 4h 5m 10s'
// 'limit' limits how many "words" are in the result
var time_unit_table = {
    'd': 'Day', 'h': 'Hour', 'm': 'Min', 's': 'Sec'
};

function do_pretty_print_time_unit(qty, abbrev, spell_it) {
    if(spell_it) {
        var u = time_unit_table[abbrev];
        if(qty != 1) {
            u = (u + 's');
        }
        return qty.toString() + ' ' + u;
    } else {
        return qty.toString() + abbrev;
    }
};

function do_pretty_print_time(sec, limit, spell_units) {
    if(sec < 1) { // includes negative
        return '0';
    }

    var ret = [];
    var show_seconds = true;

    if(sec >= (24*60*60)) {
        var days = Math.floor(sec/(24*60*60));
        ret.push(do_pretty_print_time_unit(days, 'd', spell_units));
        sec -= days * (24*60*60);
        show_seconds = false;
    }
    if(sec >= (60*60)) {
        var hours = Math.floor(sec/(60*60));
        ret.push(do_pretty_print_time_unit(hours, 'h', spell_units));
        sec -= hours * (60*60);
    }
    if(sec >= 60) {
        var mins = Math.floor(sec/60);
        ret.push(do_pretty_print_time_unit(mins, 'm', spell_units));
        sec -= mins * 60;
    }
    if(sec >= 1 && show_seconds) {
        var secs = Math.floor(sec);
        ret.push(do_pretty_print_time_unit(secs, 's', spell_units));
    }
    ret = ret.slice(0, limit);
    return ret.join(spell_units ? ', ' : ' ');
}

function pretty_print_time(sec) {
    return do_pretty_print_time(sec, 10, false);
}
function pretty_print_time_brief(sec) {
    return do_pretty_print_time(sec, 2, false);
}
function pretty_print_time_very_brief(sec) {
    return do_pretty_print_time(sec, 1, false);
}

// turns a UNIX timestamp into a string like "2013 Dec 9"
function pretty_print_date(ts) {
    var d = new Date(ts*1000);
    return d.getFullYear().toString()+' '+gamedata['strings']['months_short'][d.getMonth()]+' '+d.getDate().toString();
}

// pad a string with zeros until it is length 'n'
function pad_with_zeros(s, n) {
    var ret = s;
    while(ret.length < n) {
        ret = '0' + ret;
    }
    return ret;
}

function pretty_print_qty_brief(n) {
    if(n >= 1000000) {
        var d = n/1000000, rem = n % 1000000;
        return d.toFixed(rem == 0 ? 0 : 1)+'m';
    } else if(n >= 1000) {
        var d = n/1000, rem = n % 1000;
        return d.toFixed(rem == 0 ? 0 : 1)+'k';
    } else {
        return n.toFixed(0);
    }
}

// print a number in the form xxx,xxx,xxx
function pretty_print_number(n) {
    var sign;
    if(n < 0) {
        sign = '-';
        n = -n;
    } else {
        sign = '';
    }
    var ret = [];

    while(n >= 1) {
        var term = Math.floor(n % 1000);
        n = Math.floor(n/1000);
        var s = term.toFixed(0);
        if(n >= 1) {
            s = pad_with_zeros(s,3);
        }
        ret.push(s);
    }

    // special case for 0
    if(ret.length === 0) { ret.push('0'); }

    return sign + ret.reverse().join(',');
}

function reverse_digits(n) {
    if(n <= 0) { return '0'; }
    n = Math.ceil(n);
    var ret = '';
    while(n > 0) {
        ret += (n%10).toString();
        n = Math.floor(n/10);
    }
    return ret;
}

function current_pvp_week() {
    return Math.floor((player.get_absolute_time() - gamedata['matchmaking']['week_origin'])/(7*24*60*60));
}

function current_pvp_season() {
    var t = player.get_absolute_time();
    var seasons = gamedata['matchmaking']['season_starts'];
    for(var i = 0; i < seasons.length; i++) {
        if(seasons[i] > t) {
            return i;
        }
    }
    return seasons.length;
}


// only works after init()
function has_true_fullscreen() {
    if(!(canvas['SPINrequestFullScreen'] && document['SPINcancelFullScreen'])) { return false; }
    if(get_query_string('truefullscreen') === '1') { return true; }
    return read_predicate(gamedata['client']['truefullscreen']).is_satisfied(player,null);
}

function toggle_true_fullscreen() {
    if(canvas_is_fullscreen) {
        document['SPINcancelFullScreen']();
    } else {
        player.record_feature_use('truefullscreen');
        if(player.tutorial_state != "COMPLETE") {
            player.record_feature_use('truefullscreen_during_tutorial');
        }
        canvas['SPINrequestFullScreen']();
    }
}

function friend_invites_enabled() {
    return read_predicate(gamedata['client']['friend_invites_enabled']).is_satisfied(player, null);
}

// globals

// if true, obscure real names of player and friends
var anon_mode = false;
var ANON_NAME = 'John Smithson', ANON_NAME2 = 'Smith Johnson';

var LOTS_OF_METRICS = false;

// global state of game client
var client_states = {
    LOADING : 0,
    RUNNING : 1,
    UNABLE_TO_LOGIN: 2,
    TIMED_OUT: 3
};
var client_state = client_states.LOADING;

// state of GameArt downloads
var client_art_states = {
    DOWNLOADING_ESSENTIAL : 0,
    DOWNLOADING_ALL : 1,
    DONE : 2
};
var client_art_state = client_art_states.DOWNLOADING_ESSENTIAL;

// handles to the HTML5 div, canvas, and drawing context
var canvas_div, canvas, ctx;

// cache canvas dimensions to avoid reflows
// see comment at http://eli.thegreenplace.net/2010/02/13/finding-out-the-mouse-click-position-on-a-canvas-with-javascript/
var canvas_width = 0, canvas_height = 0, canvas_width_half = 0, canvas_height_half = 0;
var canvas_div_offsetLeft = 0, canvas_div_offsetTop = 0;
var canvas_div_offset_snoop_time = -1;
var canvas_is_fullscreen = false;

// server_time is our estimate of the server's clock, in (floating-point) seconds
// NOTE: server_time may not be monotonically increasing, because we re-adjust it when we receive each AJAX message!
var server_time = 0, server_time_offset = 0;

// client_time is the client-side clock. It will usually be monotonically increasing (assuming the browser/OS works that way).
/** @type {number} */
var client_time = 0;

var last_clock_update_time = 0;
var last_clock_slew_time = 0; // ensure clock is slewed only once per frame

// try to adjust our server_time to match the server, but smoothly, without jumps
function update_client_and_server_time() {
    client_time = (new Date()).getTime()/1000;
    var prev_server_time = server_time + (client_time - last_clock_update_time);
    last_clock_update_time = client_time;

    var target_server_time = client_time + server_time_offset;
    if(Math.abs(prev_server_time - target_server_time) >= gamedata['client']['clock_slew_limit']) {
        // big discrepancy - instantly realign clock
        if(server_time != 0) {
            console.log('large server clock offset ('+(target_server_time-prev_server_time).toString()+'), snapping to server time');
        }
        server_time = target_server_time;
    } else {
        var delta_t = client_time - last_clock_slew_time;
        if(delta_t >= gamedata['client']['clock_slew_min_interval']) {
            // slew towards the "correct" offset
            var incr = gamedata['client']['clock_slew_rate'] * delta_t;
            server_time = Math.min(Math.max(target_server_time, prev_server_time - incr), prev_server_time + incr);
            last_clock_slew_time = client_time;
        } else {
            // preserve current offset
            server_time = prev_server_time;
        }
    }
}

// for tracking mouse movement
var mouse_state = { last_x: 0, last_y: 0, // last x,y location of movement that the game field handled
                    last_raw_x: 0, last_raw_y: 0, // last x,y location of movement, regardless of who handled the event
                    button: 0,  // bitmask of button states
                    spacebar: false, // whether or not spacebar is being held down
                    // state of view-scroll operation
                    has_scrolled: false, scroll_start_x: 0, scroll_start_y: 0,
                    // state of drag-select operation
                    has_dragged: false, drag_start_x: 0, drag_start_y: 0,
                    // building over which the mouse is currently hovering
                    hovering_over: null,

                    dripper: new Dripper.Dripper(null, -1, -1), // state of current "drip" operation (used for SG-style unit deployment)
                    // webkit PointerLock API in use and pointer is locked
                    pointer_locked: false, pointer_lock_origin: [-1,-1],

                    // last unit that received a single click (cleared upon double-click)
                    last_unit_clicked: null,
                    last_click_time: -1 // client_time when the click was made
                  };
mouse_state.get_button = function(num) { return (mouse_state.button & (1<<num)) != 0; };
mouse_state.set_button = function(num) { mouse_state.button |= (1<<num); };
mouse_state.clear_button = function(num) { mouse_state.button &= ~(1<<num); };
mouse_state.clear_all_buttons = function() { mouse_state.button = 0; };

// number of seconds after a click within which a second click will be considered a double-click
var DOUBLE_CLICK_TIME = 0.6;

// tooltip for buildings on the landscape - re-used for each one
var mouse_tooltip = null;

var pointer_lock_supported = false;

// currently-selected unit and spell
// 'selection' is a very important global variable that maintains the state of whatever
// unit or building the player has selected with the mouse, and it also maintains the
// state of any modal actions the user might be applying to it. The main mouse-click
// handler sets selection.unit, then selection.spellname and selection.spellkind are
// set later, when the user has specified what kind of action they want to perform.
// e.g. if the player is in the middle of moving a building, selection.spellname will be 'MOVE_BUILDING'.

// selection.ui is a reference to a SPUI object associated with
// the current modal action (e.g., a dialog box or building
// placement cursor). You must add or remove this object from SPUI.root when changing selection.ui!

var selection = { unit: null,
                  multi: [], // only used for drag-selection of multiple mobile units
                  spellname: null,
                  spellkind: null,
                  item: null, // inventory item
                  ui: null,
                  ui_change_time: -1
                };

var control_groups = [];
for(var i = 0; i < 10; i++) {
    control_groups.push({});
}

function control_group_define(group) {
    control_groups[group] = {};
    control_group_add(group);
};

function control_group_add(group) {
    var grp = control_groups[group];
    if(selection.unit) {
        grp[selection.unit.id] = selection.unit;
        for(var i = 0; i < selection.multi.length; i++) {
            var u = selection.multi[i];
            grp[u.id] = u;
        }
    }
};

function control_group_toggle(group) {
    var grp = control_groups[group];
    if(selection.unit) {
        if(selection.unit.id in grp) {
            delete grp[selection.unit.id];
        } else {
            grp[selection.unit.id] = selection.unit;
        }
        for(var i = 0; i < selection.multi.length; i++) {
            var u = selection.multi[i];
            if(u === selection.unit) { continue; }
            if(u.id in grp) {
                delete grp[u.id];
            } else {
                grp[u.id] = u;
            }
        }
    }
};

// have to be careful because member units may have been destroyed
function control_group_activate(group) {
    var grp = control_groups[group];

    // preserve selection.unit if it's in the group
    var old_selection_unit = selection.unit;
    change_selection_unit(null);

    if(old_selection_unit && old_selection_unit.id in grp) {
        selection.unit = old_selection_unit;
    }

    for(var id in grp) {
        var u = grp[id];
        if(u.is_destroyed()) {
            delete grp[id];
            continue;
        }
        if(!selection.unit) {
            selection.unit = u;
        }
        selection.multi.push(u);
    }
};


// handles to SPUI dialogs for desktop UI
var desktop_dialogs = {};

// handle to SPFX instance for displaying the "enemy units offscreen" direction arrow
var offscreen_unit_arrow = null;

// user-visible error log
var user_log;

var backdrop_music = null;

var LION_STONE_ID = 1002; // hard-coded Lion Stone base ID for rails tutorial

// game map

// the width and height of one map cell in pixels, as projected into the isometric view
// note: must be divisible by 2!
/** @const */
var cellsize = [20,10]; // 64 32

/** @type {?AStar.AStarRectMap} current A* map for playfield movement queries */
var astar_map = null;

/** @type {?AStar.CachedAStarContext} current A* context for playfield movement queries */
var astar_context = null;

// note: astar_map is used for A* pathing and building placement queries ("is this cell blocked?")
// combat-engine targeting queries ("list all objects near this point") are done using MapAccelerator

// scroll offset of game view relative to center of play area, in units of pixels *at view_zoom=1.0*
// when equal to [0,0], the game view is centered on the play area
var view_pos = [0,0];
var view_limits = [ [0,0], [0,0] ]; // min/max value constraints on view_pos
var view_zoom_linear = 0; // controller for view_zoom, indexes into gamedata.client.view_zoom_steps
var view_zoom = 1; // zoom factor applied between playfield and screen coordinates
var view_roi = [[0,0],[0,0]]; // corners of visible region, in "draw" coordinate space

// we apply certain optimizations when view_zoom is 1 for faster drawing
function view_is_zoomed() { return Math.abs(view_zoom-1) >= 0.01; }

var hitloc = [0,0]; // last mouse-down location (*for debugging only*)

// forced scrolling (for tutorials, etc)

var force_scroll_state = {
    target: [0,0],
    key: null,
    speed: 0
};

/** initiate forced scrolling
 * @param {string|null} obj_type
 * @param {Array.<number>|null} pos
 * @param {string} key
 * @param {number=} speed
 */
function force_scroll(obj_type, pos, key, speed) {
    if(force_scroll_state.key == key) { return; }
    if(!speed) { speed = gamedata['client']['force_scroll_speed']; }

    if(obj_type) {
        var obj = find_object_by_type(obj_type);
        if(!obj) { return; }
        pos = obj.interpolate_pos();
    }

    var ncells = (session.viewing_base ? session.viewing_base.ncells() : [0,0]);

    // new target = 2D pixel offset from center of map to 'pos'
    force_scroll_state.key = key;
    force_scroll_state.target = ortho_to_playfield_vector(vec_sub(pos, vec_scale(0.5,ncells)));
    force_scroll_state.speed = speed;
}

function force_scroll_eval() {
    if(player.is_cheater || force_scroll_state.key === null) { return; }
    var delta = vec_sub(force_scroll_state.target, view_pos);
    var dist = vec_length(delta);

    if(dist >= 2/view_zoom) {
        var dir = vec_scale(1.0/dist, delta);
        var dpos = vec_scale(force_scroll_state.speed*dist, dir);
        if(vec_length(dpos) >= 0.5/view_zoom) {
            view_pos = vec_add(view_pos, dpos);
            return;
        }
    }
    // done
    force_scroll_state.key = null;
}

// Auras

/** @constructor
    @struct
    @param {GameObject|null} source object
    @param {Object} spec
    @param {?} strength
    @param {number} range
    @param {!CombatEngine.TickCount} start_tick
    @param {!CombatEngine.TickCount} expire_tick
    @param {Object|null=} vs_table
*/
function Aura(source, spec, strength, range, start_tick, expire_tick, vs_table) {
    this.source = source;
    this.spec = spec;
    this.strength = strength;
    this.range = range;
    /** @type {!CombatEngine.TickCount} */
    this.start_tick = start_tick;
    /** @type {!CombatEngine.TickCount} */
    this.expire_tick = expire_tick;
    this.stacks = 1;
    this.vs_table = vs_table || null;
    this.visual_effect = null;
};
/** @param {!GameObject} obj */
Aura.prototype.apply = function(obj) {
    if('client' in this.spec && !this.spec['client']) { return; }
    goog.array.forEach(this.spec['effects'], function(effect) {
        var code = effect['code'];
        if(code === 'speed_boosted') {
            obj.combat_stats.maxvel *= (1 + this.strength);
        } else if(code === 'defense_boosted') {
            obj.combat_stats.damage_taken *= (1-this.strength);
        } else if(code === 'defense_weakened') {
            obj.combat_stats.damage_taken *= (1+this.strength);
        } else if(code === 'radiation_hardened') {
            var val = obj.combat_stats.damage_taken_from['radiation'] || 1.0;
            obj.combat_stats.damage_taken_from['radiation'] = val * this.strength;
        } else if(code === 'frozen') {
            if(obj.is_mobile()) {
                obj.combat_stats.maxvel *= (1 - this.strength);
                obj.combat_stats.turn_rate *= (1 - this.strength);
                obj.combat_stats.erratic_flight = Math.max(obj.combat_stats.erratic_flight, this.strength);
            }
        } else if(code === 'ice_shielded') {
            obj.combat_stats.ice_effects *= this.strength;
        } else if(code === 'ice_encrusted') {
            // note: like "frozen", but reduce by ice_shielded/ice_effects
            if(obj.is_mobile()) {
                obj.combat_stats.maxvel *= (1 - obj.combat_stats.ice_effects*this.strength);
                obj.combat_stats.turn_rate *= (1 - obj.combat_stats.ice_effects*this.strength);
                obj.combat_stats.erratic_flight = Math.max(obj.combat_stats.erratic_flight, obj.combat_stats.ice_effects*this.strength);
            }
        } else if(code === 'swamp_shielded') {
            obj.combat_stats.swamp_effects *= this.strength;
        } else if(code === 'moving_in_swamp') {
            if(obj.is_mobile()) {
                obj.combat_stats.maxvel *= (1 - obj.combat_stats.swamp_effects*this.strength);
                obj.combat_stats.turn_rate *= (1 - obj.combat_stats.swamp_effects*this.strength);
            }
        } else if(code === 'rate_of_fire_boosted') {
            obj.combat_stats.rate_of_fire *= (1 + this.strength);
        } else if(code === 'damage_boosted') {
            obj.combat_stats.weapon_damage *= (1 + this.strength);
        } else if(code === 'armor_boosted') {
            obj.combat_stats.extra_armor = Math.max(obj.combat_stats.extra_armor, this.strength);
        } else if(code === 'defense_booster') {
            // apply the defense_boosted aura to this and nearby units
            var obj_list = query_objects_within_distance(obj.interpolate_pos(),
                                                         gamedata['map']['range_conversion'] * this.range,
                                                         { only_team: obj.team, mobile_only: true });
            for(var i = 0; i < obj_list.length; i++) {
                var o = obj_list[i].obj;
                o.create_aura(obj, 'defense_boosted', this.strength, new CombatEngine.TickCount(1), 0);
            }
        } else if(code === 'damage_booster') {
            // apply the damage_boosted aura to this and nearby units
            var obj_list = query_objects_within_distance(obj.interpolate_pos(),
                                                         gamedata['map']['range_conversion'] * this.range,
                                                         { only_team: obj.team, mobile_only: true });
            for(var i = 0; i < obj_list.length; i++) {
                var o2 = obj_list[i].obj;
                o2.create_aura(obj, 'damage_boosted', this.strength, new CombatEngine.TickCount(1), 0);
            }
        } else if(code === 'stunned') {
            obj.combat_stats.stunned += this.strength;
        } else if(code === 'disarmed') {
            obj.combat_stats.disarmed += this.strength;
        } else if(code === 'range_reduction') {
            obj.combat_stats.weapon_range *= Math.max(0, (1-this.strength));
        } else if(code === 'weak_zombie') {
            obj.combat_stats.maxvel *= this.spec['zombie_speed'];
            obj.combat_stats.weapon_damage *= this.spec['zombie_damage'];
        } else if(code === 'on_fire') {
            var apply_interval = effect['apply_interval'] || TICK_INTERVAL;
            // apply effect every N ticks
            var n_ticks = Math.floor(apply_interval/TICK_INTERVAL + 0.5);
            if(n_ticks <= 1 || (((session.combat_engine.cur_tick.get() - this.start_tick.get()) % n_ticks) == 0)) {
                var dmg = Math.max(1, Math.floor(this.strength*apply_interval));
                session.combat_engine.damage_effect_queue.push(new CombatEngine.TargetedDamageEffect(session.combat_engine.cur_tick.copy(), client_time, this.source, obj, dmg, effect['damage_vs'] || this.vs_table));
            }
        } else if(code === 'projectile_speed_reduced') {
            obj.combat_stats.projectile_speed *= (1 - this.strength);
        } else if(code === 'cast_spell_continuously') {
            if(!obj.is_destroyed()) {
                var spellname = effect['spell'];
                obj.cast_client_spell(spellname, gamedata['spells'][spellname], null, null);
            }
        } else {
            console.log('unhandled aura code '+code);
        }
    }, this);

    if(('visual_effect' in this.spec) && !obj.spec['worth_less_xp'] && (obj.team != 'enemy' || !obj.is_invisible())) {
        // do not show FX on barriers or invisible objects
        var vfx_props = {'radius': 0.8*obj.hit_radius() };
        this.visual_effect = SPFX.add_visual_effect(obj.interpolate_pos(), (obj.is_mobile() ? obj.altitude : 0), [0,1,0], client_time, this.spec['visual_effect'], true, vfx_props);
    }
};

Aura.prototype.end = function(obj) {
    if('end_spell' in this.spec) {
        var spell_name = this.spec['end_spell'];
        obj.cast_client_spell(spell_name, gamedata['spells'][spell_name], obj, null);
    }
};

// to reduce the amount of AJAX traffic, group together all client->server messages
// that are sent within each iteration of the main game loop

/** @constructor */
function AJAXMessageQueue() {
    this.queue = [];
    this.serial = -1;
    this.recv_progress = -1; // UNRELIABLE indication of progress receiving the response to this message bundle (-1 if unknown)
}
AJAXMessageQueue.prototype.push = function(msg) {
    this.queue.push(msg);
};
AJAXMessageQueue.prototype.length = function() { return this.queue.length; };
AJAXMessageQueue.prototype.prepend = function(msgs) {
    this.queue = msgs.concat(this.queue);
};

var message_queue = new AJAXMessageQueue();

// serial number for each AJAX message
var message_serial = 0;

// for obfuscation purposes
/** @constructor */
function ServerSender() {
    this.foo = 123;
};
ServerSender.prototype.func = function(msg) {
    message_queue.push(msg);
};
var send_to_server = new ServerSender();

// general-purpose mechanism for waiting for the server to acknowledge all actions submitted up to now
/** @constructor */
function Synchronizer() {
    this.last_sent = 0;
    this.last_received = -1;
};
Synchronizer.INIT = -1; // this should be the starting value for variables used as sync markers
Synchronizer.prototype.request_sync = function() {
    var marker = this.last_sent;
    send_to_server.func(["CLIENT_SYNC", marker]);
    if(this.last_sent > 0xFFFFFFFF) {
        this.last_sent = 0;
        console.log('this.last_sent overflow!');
    } else {
        this.last_sent += 1;
    }
    return marker;
};
Synchronizer.prototype.receive_sync = function(marker) {
    this.last_received = marker;
};
Synchronizer.prototype.is_in_sync = function(marker) { return this.last_received >= marker; };

// returns false if ANY marker has not been replied yet
Synchronizer.prototype.is_globally_in_sync = function() {
    return (this.last_received >= this.last_sent-1);
};

var synchronizer = new Synchronizer();

// game objects

// Object actions are determined by two "layers" of code:
//
// 1) The lower "control" layer governs the unit's current movement/firing state
// and applies game rules (e.g. movement speed, spell range limit, and cooldown timer)
//
// 2) The higher "ai" layer tells the "control" layer what to do in order to accomplish
// goals like "move here" "attack this thing" etc.

var AI_DEBUG = 0; // 1 = display unit AI states, 2 = also print lots of AI info to console
var PLAYFIELD_DEBUG = false; // display unit and building info debug text
var COMBAT_DEBUG = (get_query_string('wombat') == '1');

// object movement/spell control states
var control_states = {
    CONTROL_STOP : 0, // not doing anything
    CONTROL_MOVING : 1, // moving towards 'this.dest'
    CONTROL_SHOOT : 2 // casting control_spellname at control_target
};
var control_state_names = {};
control_state_names[control_states.CONTROL_STOP] = 'CONTROL_STOP';
control_state_names[control_states.CONTROL_MOVING] = 'CONTROL_MOVING';
control_state_names[control_states.CONTROL_SHOOT] = 'CONTROL_SHOOT';

// object AI states
var ai_states = {
    AI_STOP : 0, // do nothing
    AI_ATTACK_SPECIFIC : 1, // attack ai_target (and only ai_target, moving into range if necessary)
    AI_ATTACK_ANY : 2, // attack ai_target, but switch to any other target that becomes closer/more threatening.
                       // and be willing to move to pursue enemies within aggro radius, BUT leash back to commanded position (ai_dest) otherwise (if ai_dest is not null, otherwise stand still)
    AI_MOVE : 3, // move to 'this.ai_dest' (do not stop to shoot)
    AI_ATTACK_STATIONARY : 4, // do not move, but shoot anything that comes within range
    AI_ATTACK_MOVE : 5, // StarCraft-style A-move: move towards ai_dest but stop and shoot if target comes in range
    AI_ATTACK_MOVE_AGGRO : 6, // like A-move, but pursue enemies within aggro radius (which is longer than weapon range)
    AI_DEFEND_MOVE : 7 // like regular move, but flip info A-move if attacked
};
var ai_state_names = {};
ai_state_names[ai_states.AI_STOP] = 'AI_STOP';
ai_state_names[ai_states.AI_ATTACK_SPECIFIC] = 'AI_ATTACK_SPECIFIC';
ai_state_names[ai_states.AI_ATTACK_ANY] = 'AI_ATTACK_ANY';
ai_state_names[ai_states.AI_MOVE] = 'AI_MOVE';
ai_state_names[ai_states.AI_ATTACK_STATIONARY] = 'AI_ATTACK_STATIONARY';
ai_state_names[ai_states.AI_ATTACK_MOVE] = 'AI_ATTACK_MOVE';
ai_state_names[ai_states.AI_ATTACK_MOVE_AGGRO] = 'AI_ATTACK_MOVE_AGGRO';
ai_state_names[ai_states.AI_DEFEND_MOVE] = 'AI_DEFEND_MOVE';

var ai_state_values = {
    'AI_STOP': ai_states.AI_STOP,
    'AI_ATTACK_SPECIFIC': ai_states.AI_ATTACK_SPECIFIC,
    'AI_ATTACK_ANY': ai_states.AI_ATTACK_ANY,
    'AI_MOVE': ai_states.AI_MOVE,
    'AI_ATTACK_STATIONARY': ai_states.AI_ATTACK_STATIONARY,
    'AI_ATTACK_MOVE': ai_states.AI_ATTACK_MOVE,
    'AI_ATTACK_MOVE_AGGRO': ai_states.AI_ATTACK_MOVE_AGGRO,
    'AI_DEFEND_MOVE': ai_states.AI_DEFEND_MOVE
};
function ai_state_can_be_queued(state) {
    return (state == ai_states.AI_ATTACK_SPECIFIC || state == ai_states.AI_MOVE || state == ai_states.AI_ATTACK_MOVE || state == ai_states.AI_ATTACK_MOVE_AGGRO || state == ai_states.AI_DEFEND_MOVE);
}

// The playfield_check_*() functions check for violations of
// invariants where a certain cell or Bresenham path between two cells
// are supposed to be free of obstacles.

// check for invalid blocked cell
function playfield_check_pos(pos, reason) {
    if(!PLAYFIELD_DEBUG) { return; }
    if(astar_map.is_blocked(vec_floor(pos))) {
        console.log(reason+': invalid blocked cell! '+pos[0].toString()+','+pos[1].toString());
    }
}

// check for invalid path (containing blocked cells)
function playfield_check_path(path, reason) {
    if(!PLAYFIELD_DEBUG) { return; }
    for(var i = 0; i < path.length; i++) {
        var error = null;
        if(astar_map.is_blocked(vec_floor(path[i]))) {
            error = 'blocked cell in path! cell i='+i.toString()+': '+path[i][0].toString()+','+path[i][1].toString();
        } else if(i >= 1 && vec_distance(vec_floor(path[i-1]), vec_floor(path[i])) > 1 && !astar_map.linear_path_is_clear(vec_floor(path[i-1]), vec_floor(path[i]))) {
            error ='blocked jump in path! cell i='+(i-1).toString()+'-'+i.toString()+': '+path[i-1][0].toString()+','+path[i-1][1].toString()+'-'+path[i][0].toString()+','+path[i][1].toString();
        }
        if(error) {
            console.log(reason+': '+error);
            console.log(path);
            return;
        }
    }
};

// flags for tracking which parts of the GameObject state are dirty and need to be sent to the server
var obj_state_flags = {
    XY: 1, // position
    HP: 2, // health/damage (also includes last_attacker, and killer_info if destroyed)
    ORDERS: 4, // movement orders
    PATROL: 8, // patrol flag
    URGENT: 16, // mark that this object should be flushed immediately at the end of the tick, instead of waiting for the next time-interval-based save
    ALL: 255
};

/** @typedef {string} */
var GameObjectId = {};

/** @typedef {string} */
var TeamId = {};

/** @constructor */
function GameObject() {
    /** @type {GameObjectId} */
    this.id = 'DEAD'; // = DEAD_ID if the object is "dead" or otherwise not part of the game world

    /** @type {Object} */
    this.spec = null;
    this.x = -1;
    this.y = -1;
    this.hp = -1;
    this.max_hp = -1;
    /** @type {TeamId} */
    this.team = 'invalid';
    this.level = -1;
    this.equipment = null;

    // true if there are unsaved changes that should be sent back to
    // the server before the session is closed
    // (only applies to hitpoints, and xy position and orders for mobile units)
    this.state_dirty = 0;

    this.control_state = control_states.CONTROL_STOP;
    this.control_target = null;
    this.control_spellname = null;
    // this is a cooldown timer just for the default auto "shoot" spell
    this.control_cooldown = 0;

    this.ai_state = ai_states.AI_STOP;
    this.ai_target = null;

    // eventually the "threatlist" might be a full WoW-style threat list, but for now
    // it is just used as a way to cache the results of ai_pick_target() across ticks when there are no "map topology" changes
    this.ai_threatlist = null;
    this.ai_threatlist_dirty = true;

    // reference to last object that shot at us.
    // NOTE! we do not make effort to track whether the referred-to object is actually still alive
    // so check the id field before using
    this.last_attacker = null;


    this.last_speak_sound = null; // client-side state to prevent sound FX spam
    this.last_speak_time = -1;

    this.feedback_pending = false; // mouse-click feedback pending

    // combat stats - pulled from gamedata but modified by auras
    this.combat_stats = {};

    /** @type {Array.<Aura>} */
    this.auras = [];

    this.cooldowns = {}; // XXXXXX create a type for this

    // random number for offsetting looped animations
    this.anim_offset = Math.random();


    // direction object is looking (for graphics only, sim does not use!)
    this.cur_facing = this.anim_offset*2*Math.PI; // current (may be changing as it turns)
    this.next_facing = this.cur_facing;
    this.target_facing = this.cur_facing; // direction we want to look eventually


    // cache for this.calc_draw_pos()
    this.draw_pos_cache = [[0,0],0];

    // for graphics only (fading-in/out effects), last object opacity
    this.cur_opacity = 1;
    this.last_opacity = gamedata['client']['unit_spawn_opacity'];
    this.last_opacity_time = client_time; // note: resets as unit is spawned

    // for graphics only, last stabilized hp value
    this.last_ui_hp_stable = -1;
    this.last_ui_hp_time = -1;
    this.last_ui_hp = -1;

    // SPFX effect that exists all the time the object is alive
    /** @type {Object|null} - pointer into gamedata for this effect (the level-dependent post-get_leveled_quantity value) */
    this.permanent_effect_source = null;
    /** @type {SPFX.Effect|null} */
    this.permanent_effect = null;
}

/** @const
    @type {GameObjectId} */
GameObject.DEAD_ID = 'DEAD';
/** @const
    @type {GameObjectId} */
GameObject.VIRTUAL_ID = 'VIRTUAL';

// pull raw combat stats from gamedata and initialize non-gamedata values

var RESURRECT_NEVER = 1;
var RESURRECT_AND_REPAIR_WITH_TECH = 2;
var RESURRECT_AND_REPAIR_ALWAYS = 10;

GameObject.prototype.get_raw_stats = function() {
    this.combat_stats.stunned = 0;
    this.combat_stats.disarmed = 0;
    this.combat_stats.damage_taken = 1;
    this.combat_stats.damage_taken_from = {};
    this.combat_stats.rate_of_fire = 1;
    this.combat_stats.accuracy = 1;
    this.combat_stats.weapon_damage = 1;
    this.combat_stats.weapon_damage_vs = {}; // multiplies with the usual damage_vs_table
    this.combat_stats.effective_weapon_range = 1;
    this.combat_stats.weapon_range = 1;
    this.combat_stats.extra_armor = 0;
    this.combat_stats.anti_air = 0;
    this.combat_stats.anti_missile = 1; // note! this is the chance that a missile is NOT intercepted
    this.combat_stats.turn_rate = 1;
    this.combat_stats.ice_effects = 1;
    this.combat_stats.swamp_effects = 1;
    this.combat_stats.projectile_speed = 1;
    this.combat_stats.splash_range = 1;
};

// "merge" together two damage_vs tables, returning a table that has
// the multiplicative product of all entries from tables "a" and "b".
function merge_damage_vs(a, b) {
    var ret = {};
    for(var key in a) {
        if(!(key in ret)) {
            ret[key] = a[key];
        } else {
            ret[key] *= a[key];
        }
    }
    for(var key in b) {
        if(!(key in ret)) {
            ret[key] = b[key];
        } else {
            ret[key] *= b[key];
        }
    }
    return ret;
}

GameObject.prototype.modify_stats_by_modstats = function() {};
GameObject.prototype.modify_stats_by_modstats_table = function(table) {
    if('maxvel' in table) { this.combat_stats.maxvel = table['maxvel']['val']; } // note: replace, don't multiply

    if('weapon_damage' in table) { this.combat_stats.weapon_damage *= table['weapon_damage']['val']; }
    if('weapon_range' in table) {
        this.combat_stats.weapon_range *= table['weapon_range']['val'];
        this.combat_stats.effective_weapon_range *= table['weapon_range']['val']; // also change effective_range
    }
    //if('effective_weapon_range' in table) { this.combat_stats.effective_weapon_range *= table['effective_weapon_range']['val']; }
    if('accuracy' in table) { this.combat_stats.accuracy *= table['accuracy']['val']; }
    if('rate_of_fire' in table) { this.combat_stats.rate_of_fire *= table['rate_of_fire']['val']; }
    if('ice_effects' in table) { this.combat_stats.ice_effects *= table['ice_effects']['val']; }
    if('swamp_effects' in table) { this.combat_stats.swamp_effects *= table['swamp_effects']['val']; }
    if('damage_taken' in table) { this.combat_stats.damage_taken *= table['damage_taken']['val']; }
    if('armor' in table) {
        // XXX this should just be "armor" not "extra_armor" (?)
        this.combat_stats.extra_armor = Math.max(this.combat_stats.extra_armor, table['armor']['val'] - this.get_leveled_quantity(this.spec['armor']||0));
    }
    if('anti_air' in table) { this.combat_stats.anti_air = Math.max(this.combat_stats.anti_air, table['anti_air']['val']); }
    if('anti_missile' in table) { this.combat_stats.anti_missile *= table['anti_missile']['val']; }
    if('splash_range' in table) { this.combat_stats.splash_range *= table['splash_range']['val']; }

    // apply weapon_damage_vs:something and damage_taken_from:something effects
    for(var key in table) {
        if(key.indexOf('weapon_damage_vs:') === 0) {
            var kind = key.split(':')[1];
            var cur_val = (kind in this.combat_stats.weapon_damage_vs ? this.combat_stats.weapon_damage_vs[kind] : 1.0);
            this.combat_stats.weapon_damage_vs[kind] = cur_val * table[key]['val'];
        } else if(key.indexOf('damage_taken_from:') === 0) {
            var kind = key.split(':')[1];
            var cur_val = (kind in this.combat_stats.damage_taken_from ? this.combat_stats.damage_taken_from[kind] : 1.0);
            this.combat_stats.damage_taken_from[kind] = cur_val * table[key]['val'];
        }
    }
};

// check for aura expiration, and apply aura modifiers to combat stats
GameObject.prototype.update_and_apply_auras = function() {
    for(var i = 0; i < this.auras.length; i++) {
        var a = this.auras[i];
        if(!a.expire_tick.is_infinite() && CombatEngine.TickCount.gt(session.combat_engine.cur_tick, a.expire_tick)) {
            this.auras.splice(i,1);
            a.end(this);
            continue;
        }
        a.apply(this);
    }
};

// called once per tick
GameObject.prototype.update_stats = function() {
    this.get_raw_stats();
    this.modify_stats_by_modstats();
    this.update_and_apply_auras(); // XXX move before modstats?
};

// Return true if the ability identified by 'key' (usually spell name) is able to be used
/** @param {string} key
    @return {boolean} */
GameObject.prototype.get_cooldown = function(key) {
    if(key in this.cooldowns && CombatEngine.TickCount.lte(session.combat_engine.cur_tick, this.cooldowns[key].expire_tick)) {
        // old timer is still active
        return false;
    } else {
        return true;
    }
};
/** @param {string} key
    @param {!CombatEngine.TickCount} start
    @param {!CombatEngine.TickCount} expire */
GameObject.prototype.set_cooldown = function(key, start, expire) {
    this.cooldowns[key] = { start_tick: start, expire_tick: expire };
};

GameObject.prototype.receive_auras_update = function(alist) {
    // remove all permanent and expired auras
    for(var i = 0; i < this.auras.length; i++) {
        var a = this.auras[i];
        if(a.expire_tick.is_infinite() || CombatEngine.TickCount.gt(session.combat_engine.cur_tick, a.expire_tick)) {
            this.auras.splice(i,1);
            a.end(this);
            continue;
        }
    }

    if(!alist) { return; }
    for(var i = 0; i < alist.length; i++) {
        var data = alist[i];
        this.create_aura(null, data['name'], data['strength'],
                         ('duration' in data? relative_time_to_tick(data['duration']) : CombatEngine.TickCount.infinity),
                         ('range' in data? data['range'] : -1));
    }
};

function get_spec(specname) {
    var spec = gamedata['buildings'][specname] || gamedata['units'][specname] || gamedata['inert'][specname];
    if(!spec) {
        console.log('unknown spec name '+specname);
    }
    return spec;
}

// relink specs of all current objects into gamedata (called when gamedata is reloaded)
function reset_specs() {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        obj.spec = get_spec(obj.spec['name']);
    }
}

GameObject.prototype.receive_state = function(data, init, is_deploying) {
    this.id = /** @type {string} */ (data.shift());
    var specname = data.shift();
    this.spec = get_spec(specname);

    var newx = data.shift(), newy = data.shift();
    if((newx >= 0 && newy >= 0) || init) {
        // only apply position update if values are not -1,-1
        this.x = newx;
        this.y = newy;

        var ncells = session.viewing_base.ncells();
        this.x = clamp(this.x, 0, ncells[0]-1);
        this.y = clamp(this.y, 0, ncells[1]-1);
    }

    var updated_hp = data.shift();
    if(updated_hp >= 0) {
        this.hp = updated_hp;
    }
    this.max_hp = data.shift();
    this.team = data.shift();
    this.level = data.shift();
    this.equipment = data.shift();

    this.update_stats();
    if(updated_hp >= 0) {
        this.state_dirty = 0;
    } else {
        this.state_dirty &= obj_state_flags.HP;
    }

    if(this.hp > this.max_hp) { console.log('hp disagreement '+this.hp+' '+this.max_hp); }
    //this.hp = Math.min(this.hp, this.get_leveled_quantity(this.spec['max_hp']));

    // initialize AI
    if(init && this.is_shooter()) {
        if(player.tutorial_state === "START" && this.team === 'player') {
            // special case for start of tutorial - don't have the player's units attack until moved manually
            this.ai_state = ai_states.AI_STOP;
        } else {
            // when in manual unit control, and deploying units into battle on hostile territory, start them in hold position
            if((session.viewing_base.base_landlord_id !== session.user_id) &&
               (this.team == 'player') &&
               (!get_preference_setting(player.preferences, 'auto_unit_control'))) {
                if('deploy_ai_order' in this.spec) {
                    this.ai_state = ai_state_values[this.spec['deploy_ai_order']['state']];
                } else {
                    this.ai_state = ai_state_values[gamedata['client']['default_deploy_ai_order']['manual']['state']];
                }
            } else {
                this.ai_state = ai_state_values[gamedata['client']['default_deploy_ai_order']['auto']['state']];
            }

            // check for arming delay when in hostile territory
            if((this.team == 'player' && session.viewing_base.base_landlord_id !== session.user_id) ||
               (this.team == 'enemy' && session.viewing_base.base_landlord_id === session.user_id)) {
                var auto_spell = this.get_auto_spell();
                if(auto_spell && auto_spell['deployment_arming_delay']) {
                    this.create_aura(this, 'arming', 1, relative_time_to_tick(auto_spell['deployment_arming_delay']), -1, null);
                }
            }
        }
    }
};

function get_leveled_quantity(qty, level) {
    if((typeof qty) == 'undefined') {
        throw Error('get_leveled_quantity of undefined');
    }

    if(qty === null ||
       (typeof qty) === 'number' ||
       (typeof qty) === 'string' ||
       (typeof qty) === 'boolean') {
        return qty;
    } else if(0 in qty) {
        // hope it's an array
        return qty[level-1];
    } else {
        // anything else
        return qty;
    }
};

// some pieces of gamedata can be either scalars or arrays, this forces the result to an array
function get_as_array(qty) {
    if(0 in qty) { return qty; }
    return [qty];
};

// get a spec quantity that is possibly level-dependent (list indexed by level-1)
GameObject.prototype.get_leveled_quantity = function(qty) { return get_leveled_quantity(qty, this.level); }

GameObject.prototype.run_tick = function() {
    this.update_stats();
    this.ai_threatlist_update();
    this.run_ai();
    this.run_control();
    this.update_facing();
};

GameObject.prototype.update_facing = function() {
    if('turn_rate' in this.spec) {
        this.cur_facing = this.next_facing;

        // turn from cur_facing towards target_facing
        if(this.cur_facing != this.target_facing && !this.is_destroyed() && !this.combat_stats.stunned) {
            // how much the unit can turn in one tick
            // degrees/sec
            var max_degrees = this.combat_stats.turn_rate * this.get_leveled_quantity(this.spec['turn_rate'] || 230.0);
            // convert to radians/tick
            var turn_amount = Math.min(max_degrees*(Math.PI/180.0)*TICK_INTERVAL, Math.PI);

            // to avoid complex modulo math, do the computations with 2D vectors
            var cur = [Math.cos(this.cur_facing), Math.sin(this.cur_facing)];
            var tgt = [Math.cos(this.target_facing), Math.sin(this.target_facing)];

            var dot = cur[0]*tgt[0] + cur[1]*tgt[1];

            dot = Math.min(dot, 1); // avoid acos NaNs with rounding errors

            if(dot > Math.cos(turn_amount)) {
                // angle between vectors is less than turn_amount, snap cur to target
                this.next_facing = this.target_facing;
                var cross = cur[0]*tgt[1] - cur[1]*tgt[0];

                if(cross > 0) {
                    this.cur_facing = this.next_facing - Math.acos(dot);
                } else {
                    this.cur_facing = this.next_facing + Math.acos(dot);
                    //this.next_facing = this.cur_facing - turn_amount;
                }
            } else {
                // angle between vectors is greater than turn_amount
                // choose direction to turn depending on Z component of cross product
                var cross = cur[0]*tgt[1] - cur[1]*tgt[0];
                if(cross > 0) {
                    this.next_facing = this.cur_facing + turn_amount;
                } else {
                    this.next_facing = this.cur_facing - turn_amount;
                }
            }
        }
    }
};
/** @return {boolean} */
GameObject.prototype.is_building = function() { return (this.spec['kind'] === 'building'); };
/** @return {boolean} */
GameObject.prototype.is_mobile = function() { return (this.spec['kind'] === 'mobile'); };
/** @return {boolean} */
GameObject.prototype.is_flying = function() { return false; };
/** @return {boolean} */
GameObject.prototype.is_inert = function() { return (this.spec['kind'] === 'inert'); };
/** @return {boolean} */
GameObject.prototype.is_blocker = function() { return false; };
/** @return {!Array.<number>} */
GameObject.prototype.raw_pos = function() { return [this.x, this.y]; };
/** @return {!Array.<number>} */
GameObject.prototype.interpolate_pos = function() { return [this.x, this.y]; };
/** @return {!Array.<number>} */
GameObject.prototype.interpolate_pos_for_draw = function() { return this.interpolate_pos(); };
/** @return {boolean} */
GameObject.prototype.is_invisible = function() { return false; };

// return [[x,y], depth] for sprite drawing on game field
GameObject.prototype.calc_draw_pos = function() {
    var p = this.interpolate_pos();
    var depth = ortho_to_depth(p);
    return [p, depth];
};
GameObject.prototype.update_draw_pos = function() { this.draw_pos_cache = this.calc_draw_pos(); };

/** @return {boolean} */
GameObject.prototype.is_indestructible = function() {
    return (this.max_hp === 0);
};
/** @return {boolean} */
GameObject.prototype.is_damaged = function() {
    if(this.max_hp === 0) { return false; } // indestructible object
    return (this.hp < this.max_hp);
};
/** @return {boolean} */
GameObject.prototype.is_destroyed = function() {
    if(this.max_hp === 0) { return false; } // indestructible object
    return (this.hp === 0) || (this.id === GameObject.DEAD_ID);
};
/** @return {boolean} */
GameObject.prototype.is_under_construction = function() {
    return false;
};

function get_max_level(spec) {
    if(spec['kind'] === 'mobile') {
        return spec['max_hp'].length;
    } else if(spec['kind'] === 'building') {
        return spec['build_time'].length;
    } else if('research_time' in spec) {
        return spec['research_time'].length;
    } else {
        return 1;
    }
}

// return maximum level that should be displayed to players
// (may be lower than true max level)
function get_max_ui_level(spec) {
    var max_level = get_max_level(spec);
    if(!player.is_cheater && ('max_ui_level' in spec)) {
        max_level = Math.min(max_level, eval_cond_or_literal(spec['max_ui_level'], player, null));
    }
    return max_level;
}

GameObject.prototype.get_max_level = function() { return get_max_level(this.spec); };
GameObject.prototype.get_max_ui_level = function() { return get_max_ui_level(this.spec); };

// for an object at 'cur_level', find the next level at which stat 'statname' gets bigger
// if the object or stat is already maxed out, return -1
function get_next_level_with_stat_increase(spec, statname, cur_level) {
    var max_level = get_max_ui_level(spec);
    if(cur_level >= max_level) { return -1; }

    var cur_stat = get_leveled_quantity(spec[statname], cur_level);
    var max_stat = get_leveled_quantity(spec[statname], max_level);
    if(cur_stat >= max_stat) { return -1; }

    var next_level_that_gains_stat = cur_level + 1;
    while(get_leveled_quantity(spec[statname], next_level_that_gains_stat) <= cur_stat) {
        next_level_that_gains_stat += 1;
        if(next_level_that_gains_stat >= max_level) { break; }
    }
    return next_level_that_gains_stat;
}

/** @return {number} radius of "hitbox" - nonzero only for objects that cause collisions */
GameObject.prototype.hit_radius = function() { return 0; };

GameObject.prototype.get_auto_spell = function() { return null; }; // for inerts etc
GameObject.prototype.get_auto_spell_level = function() { return this.level; }; // index for stats of the auto spell

function is_melee_spell(spell) {
    if(spell['projectile_color'] === null && spell['projectile_speed'] < 0 &&
       ('priority_vs' in spell) && ('inaccessible' in spell['priority_vs'])) {
        return true;
    }
    return false;
}

function get_weapon_range(stats, level, spell) {
    var range = -1, trigger_range = -1, min_range = -1;

    if(spell && (spell['code'] == 'pbaoe') && ('splash_range' in spell)) {
        // max range at which damage is done
        range = gamedata['map']['splash_range_conversion'] * get_leveled_quantity(spell['splash_range'], level);
        // max range at which an attacker triggers the effect
        trigger_range = gamedata['map']['range_conversion'] * get_leveled_quantity(spell['range'] || -1, level);
        if(stats) {
            range *= stats.splash_range;
            trigger_range *= stats.weapon_range;
        }
    } else if(spell) {
        range = gamedata['map']['range_conversion'] * get_leveled_quantity(spell['range'] || -1, level);
        if(stats) {
            range *= stats.weapon_range;
        }
        if('min_range' in spell) {
            min_range = gamedata['map']['range_conversion'] * get_leveled_quantity(spell['min_range'] || -1, level);
        }
    }

    return [spell, range, (spell && ('splash_range' in spell)), trigger_range, min_range];
};

GameObject.prototype.is_shooter = function() { return (this.get_auto_spell() != null); };
GameObject.prototype.weapon_range = function() {
    var spell = this.get_auto_spell();
    if(!spell && ('continuous_cast' in this.spec)) {
        var s = gamedata['spells'][this.spec['continuous_cast']];
        if(s['code'] == 'pbaoe' && 'splash_range' in s) { spell = s; }
    }
    return get_weapon_range(this.combat_stats, this.get_auto_spell_level(), spell);
};
GameObject.prototype.is_invul = function() { return this.spec['quarry_invul'] && session.is_quarry(); };

// return true if we have a weapon that can shoot at target (regardless of whether target is in range or not)
GameObject.prototype.can_shoot_at = function(target) {
    var auto_spell = this.get_auto_spell();
    if(!auto_spell) { return false; }
    if(target.is_invul()) { return false; }
    if('targets_nonmobile' in auto_spell && !auto_spell['targets_nonmobile'] && !target.is_mobile()) { return false; }
    if('help' in auto_spell && auto_spell['help'] && !target.is_damaged()) { return false; }
    if(target.is_flying()) {
        return (auto_spell['targets_air'] || this.combat_stats.anti_air);
    } else {
        return auto_spell['targets_ground'];
    }
};

GameObject.prototype.get_special_ability_spell = function() {
    var spell_name = null, spell = null;
    for(var i = 0; i < this.spec['spells'].length; i++) {
        spell_name = this.spec['spells'][i];
        var sp = gamedata['spells'][spell_name];
        if((sp['activation'] === 'instant' || sp['activation'] === 'targeted_area') &&
           spell_name !== 'MOVE_UNIT' &&
           (!sp['developer_only'] || (!spin_secure_mode && player.is_developer()))) {
            spell = sp; break;
        }
    }
    if(!spell) { return null; }
    return [spell_name, spell];
};

GameObject.prototype.use_special_ability = function() {
    var name_sp = this.get_special_ability_spell();
    if(!name_sp) { return false; }
    var spell_name = name_sp[0], spell = name_sp[1];
    if(spell['activation'] === 'instant') {
        return this.cast_client_spell(spell_name, spell, this, null);
    } else if(spell['activation'] === 'targeted_area') {
        if(!this.get_cooldown(spell_name)) { return; }
        selection.spellname = spell_name;
        var range = gamedata['map']['range_conversion'] * this.get_leveled_quantity(spell['range'] || 0);
        var splash = gamedata['map']['splash_range_conversion'] * this.get_leveled_quantity(spell['splash_range'] || 0) * this.combat_stats.splash_range;
        change_selection_ui(new AOEUICursor(this, range, splash));
        return false;
    } else {
        console.log('unhandled ability activation type '+spell['activation']);
    }
    return false;
}

// same as cast_client_spell, but has no effect if the spell is not castable by this unit
GameObject.prototype.cast_client_spell_checked = function(spell_name, spell, target, location) {
    var found = false;
    for(var i = 0; i < this.spec['spells'].length; i++) {
        if(this.spec['spells'][i] === spell_name) {
            found = true;
            break;
        }
    }
    if(found) {
        return this.cast_client_spell(spell_name, spell, target, location);
    } else {
        return false;
    }
};

/** @param {string} spell_name
    @param {Object} spell
    @param {GameObject|null} target
    @param {Array.<number>|null} location */
GameObject.prototype.cast_client_spell = function(spell_name, spell, target, location) {
    if(!this.get_cooldown(spell_name)) {
        return false;
    }

    if('applies_aura' in spell) {
        var aura_name = spell['applies_aura'];
        var strength = this.get_leveled_quantity(spell['aura_strength'] || 1);
        var duration = this.get_leveled_quantity(spell['aura_duration'] || -1);
        var range = this.get_leveled_quantity(spell['aura_range'] || 0);
        this.create_aura(null, aura_name, strength, (duration < 0 ? CombatEngine.TickCount.infinity : relative_time_to_tick(duration)), range);
    }

    if('code' in spell) {
        var code = spell['code'];
        if(code === 'pbaoe') {
            var radius, radius_rect;
            if(spell['splash_radius_from_gridsize']) {
                radius = -1;
                radius_rect = this.spec['gridsize'];
            } else {
                radius = gamedata['map']['splash_range_conversion'] * this.get_leveled_quantity(spell['splash_range'] || 0) * this.combat_stats.splash_range;
                radius_rect = null;
            }

            var cooldown = this.get_leveled_quantity(spell['cooldown'] || 1.0);
            // note: damage in spells.json is PER SECOND
            var damage = this.get_leveled_quantity(spell['damage']) * cooldown;

            var impact_pos = this.interpolate_pos();

            if(spell['kills_self']) {
                // Detonator droid/landmine
                // queue BEFORE other damage so it's listed in this order in the battle log
                var death_client_time = client_time + (spell['kills_self_delay']||0);
                var death_tick = CombatEngine.TickCount.add(session.combat_engine.cur_tick,
                                                            relative_time_to_tick(/** @type {number} */ (spell['kills_self_delay']||0)));
                session.combat_engine.damage_effect_queue.push(new CombatEngine.KillDamageEffect(death_tick, death_client_time, this, this));
            }

            if(spell['impact_auras']) {
                for (var i = 0; i < spell['impact_auras'].length; i++) {
                    var imp_aura = spell['impact_auras'][i];
                    var effect = new CombatEngine.AreaAuraEffect(session.combat_engine.cur_tick.copy(), client_time, this, impact_pos,
                                                    ('targets_ground' in spell ? spell['targets_ground'] : 1),
                                                    ('targets_air' in spell ? spell['targets_air'] : 1),
                                                    radius, radius_rect,
                                                    this.get_leveled_quantity(spell['splash_falloff'] || 'linear'),
                                                    this.get_leveled_quantity(imp_aura['strength'] || 1),
                                                    this.get_leveled_quantity(imp_aura['spec']),
                                                    relative_time_to_tick(this.get_leveled_quantity(imp_aura['duration'] || 1)),
                                                    this.get_leveled_quantity(imp_aura['range'] || 0),
                                                    spell['damage_vs'] || {}, imp_aura['duration_vs'] || {},
                                                    spell['always_friendly_fire'] || false);
                    session.combat_engine.damage_effect_queue.push(effect);
                }
            }

            var effect = new CombatEngine.AreaDamageEffect(session.combat_engine.cur_tick.copy(), client_time, this, impact_pos,
                                              ('targets_ground' in spell ? spell['targets_ground'] : 1),
                                              ('targets_air' in spell ? spell['targets_air'] : 1) || this.combat_stats.anti_air,
                                              radius,
                                              this.get_leveled_quantity(spell['splash_falloff'] || 'linear'),
                                              damage, spell['damage_vs'] || {},
                                              spell['always_friendly_fire'] || false);
            session.combat_engine.damage_effect_queue.push(effect);

            var vfx = spell['visual_effect'] || spell['impact_visual_effect'] || null;
            if(vfx) {
                SPFX.add_visual_effect(impact_pos, 0, [0,1,0], client_time, this.get_leveled_quantity(vfx), true, null);
            }
        } else if(code === 'projectile_attack') {
            // make sure we are in range
            if(location) {
                var range = gamedata['map']['range_conversion'] * this.get_leveled_quantity(spell['range'] || 0);
                var dist = vec_distance(this.interpolate_pos(), location);
                //console.log('range: dist '+dist+' range '+range+' loc '+location);
                if(dist > range) {
                    return false;
                }
                this.fire_projectile(client_time, -1, spell, this.level, target, location, 0); // use object level for the spell
            } else {
                throw Error('projectile_attack with no location from '+this.spec['name']);
            }
        }
    }

    var visual_cooldown = 0;
    if('cooldown' in spell) {
        var cd_seconds = this.get_leveled_quantity(spell['cooldown']);
        if(this.is_building()) {
            cd_seconds /= this.combat_power_factor(); // increase cooldown if power_factor < 1
        }
        var cd_ticks = Math.floor(cd_seconds/TICK_INTERVAL);
        visual_cooldown = client_time + (cd_ticks+1)*TICK_INTERVAL;
        this.set_cooldown(spell_name, session.combat_engine.cur_tick.copy(), CombatEngine.TickCount.add(session.combat_engine.cur_tick, new CombatEngine.TickCount(cd_ticks)));
    }

    if(global_spell_icon && global_spell_icon.unit === this) {
        global_spell_icon.activated = client_time;
        global_spell_icon.cooldown = visual_cooldown;
    }

    return true;
};

/** @param {GameObject|null} creator
    @param {string} aura_name
    @param {?} strength
    @param {!CombatEngine.TickCount} duration
    @param {number} range
    @param {Object=} vs_table */
GameObject.prototype.create_aura = function(creator, aura_name, strength, duration, range, vs_table) {
    var aura_spec = gamedata['auras'][aura_name];
    var end_tick;
    if(duration.is_infinite()) {
        end_tick = CombatEngine.TickCount.infinity; // infinite
    } else {
        end_tick = CombatEngine.TickCount.add(session.combat_engine.cur_tick, duration);
    }

    var i;

    if(aura_spec['stacking'] !== 'independent') {
        // check for existing applications of the aura, and update them if found
        for(i = 0; i < this.auras.length; i++) {
            if(this.auras[i].spec === aura_spec) {
                this.auras[i].strength = Math.max(this.auras[i].strength, strength);
                this.auras[i].range = Math.max(this.auras[i].range, range);
                this.auras[i].start_tick = session.combat_engine.cur_tick.copy();
                this.auras[i].source = creator;
                if(!this.auras[i].expire_tick.is_infinite()) {
                    this.auras[i].expire_tick = CombatEngine.TickCount.max(this.auras[i].expire_tick, end_tick);
                }
                break;
            }
        }
    } else {
        i = this.auras.length;
    }

    if(i >= this.auras.length) {
        // no existing applications, create one
        this.auras.push(new Aura(creator, aura_spec, strength, range, session.combat_engine.cur_tick.copy(), end_tick, vs_table));
    }
};

GameObject.prototype.speak = function(name) {
    var field = 'sound_'+name;
    if(!(field in this.spec)) { return; }
    if(this.last_speak_sound == name && (client_time - this.last_speak_time) < gamedata['client']['min_speak_interval']) { return; }
    this.last_speak_sound = name;
    this.last_speak_time = client_time;
    GameArt.assets[this.spec[field]].states['normal'].audio.play(client_time);
};

function apply_queued_damage_effects() {
    var any_left = session.combat_engine.apply_queued_damage_effects();
    if(!any_left && session.no_more_units) {
        session.no_more_units = false;
        session.set_battle_outcome_dirty();
    }
}

function create_debris(target, pos) {
    // add client-side debris effect
    var inert_specname;
    if('destroyed_insert' in target.spec) {
        inert_specname = target.spec['destroyed_inert']; // can be null
    } else {
        inert_specname = gamedata['default_debris_inert'];
    }

    if(!inert_specname) { return; }

    var inertspec = gamedata['inert'][inert_specname];

    var debris = new SPFX.Debris(pos, inertspec['art_asset'], target.interpolate_facing())
    debris.show = (!('show_debris' in session.viewing_base.base_climate_data) || session.viewing_base.base_climate_data['show_debris']);
    SPFX.add_under(debris);

    var tooltip = target.spec['ui_name'] + ' ' + inertspec['ui_name'];
    if(target.team === 'player') {
        tooltip += ' ('+player.get_ui_name()+')';
    } else if(target.team === 'enemy') {
        if(session.home_base) {
            if(session.incoming_attacker_name) {
                tooltip += ' ('+session.incoming_attacker_name+')';
            }
        } else {
            tooltip += ' ('+session.ui_name.split(' ')[0]+')';
        }
    }
    // add user_data that persist_debris() will reference at end of combat
    debris.user_data = { 'persist': 'debris',
                         'spec': inertspec['name'],
                         'pos': vec_floor(pos),
                         'metadata': {'facing':target.interpolate_facing(), 'tooltip': tooltip} };
}

function persist_debris() {
    if(!session.has_deployed) { return; }
    if(('show_debris' in session.viewing_base.base_climate_data) && !session.viewing_base.base_climate_data['show_debris']) { return; }
    for(var id in SPFX.current_under) {
        var effect = SPFX.current_under[id];
        if(effect.user_data && effect.user_data['persist'] === 'debris') {
            send_to_server.func(["CREATE_INERT", effect.user_data['spec'], effect.user_data['pos'], effect.user_data['metadata']]);
            effect.user_data = null;
            SPFX.remove(effect);
        }
    }
}

/** Modify damage by vs_table coefficients
    @param {Object.<string,number>} vs_table
    @param {GameObject} target
    @return {CombatEngine.Coeff} */
function get_damage_modifier(vs_table, target) {
    var damage_mod = 1;
    if(vs_table) {
        if(!('defense_types' in target.spec)) {
            if('default' in vs_table) {
                damage_mod *= vs_table['default'];
            }
        } else {
            for(var i = 0; i < target.spec['defense_types'].length; i++) {
                var kind = target.spec['defense_types'][i];
                if(kind in vs_table) {
                    var coeff = vs_table[kind];
                    damage_mod *= coeff;
                }
            }
        }
        for(var kind in target.combat_stats.damage_taken_from) {
            if(kind in vs_table) {
                damage_mod *= vs_table[kind] * target.combat_stats.damage_taken_from[kind];
            }
        }
    }
    return damage_mod;
};

function hurt_object(target, damage, vs_table, source) {
    if(target.id === GameObject.DEAD_ID) {
        throw Error('hurt_object called on dead object');
    }
    //console.log('hurt_object '+target.spec['name']+' from '+(source?source.spec['name']:'null'));

    // save for metrics use, because destroy_object() sets id to -1
    var original_target_id = target.id;

    if(target.max_hp === 0) { return; } // can't hurt indestructible objects

    var pos = target.interpolate_pos();

    // offset time to de-synchronize visual effects
    var time_offset = Math.random()*TICK_INTERVAL/combat_time_scale();

    damage *= get_damage_modifier(vs_table, target);


    if(damage > 0) {

        if(!vs_table || !vs_table['ignores_armor']) {
            // reduce damage (not healing) by target's armor, down to a minimum of 1
            var armor = target.get_leveled_quantity(target.spec['armor'] || 0);
            armor += target.combat_stats.extra_armor;

            if(armor > 0) {
                damage -= armor;
            }
        }

        // modify by damage_taken combat stat
        damage *= target.combat_stats.damage_taken;

        if(damage < 1) { damage = 1; }
    }

    damage = Math.floor(damage);

    if(COMBAT_DEBUG) {
        // Damage text
        SPFX.add(new SPFX.CombatText(pos,
                                     target.is_flying() ? target.altitude : 0,
                                     pretty_print_number(Math.abs(damage)),
                                     (damage >= 0 ? [1, 1, 0.1, 1] : [0,1,0,1]),
                                     client_time + time_offset, client_time + 1.0 + time_offset, {drop_shadow:true}));
    }

    // make player units invincible during the tutorial
    if(player.tutorial_state != "COMPLETE") {
        if(target.team === 'player') {
            var health_limit;
            if(target.is_building() && target.is_shooter()) {
                health_limit = target.max_hp;
            } else {
                health_limit = Math.floor(0.2 * target.max_hp);
            }
            if(target.hp - damage < health_limit) {
                damage = target.hp - health_limit;
            }
        }
    }

    var was_destroyed = (target.hp <= 0); // always going be false unless we implement building repair

    var original_target_hp = target.hp;

    target.hp -= damage;
    target.last_attacker = source;
    target.state_dirty |= obj_state_flags.HP;

    if(target.is_building()) {
        // immediately show that repair/research/upgrade/production stops in the UI. Subsequent OBJECT_STATE_UPDATE will return correct HP value and start/stop times.
        target.repair_finish_time = -1;
        if(target.research_start_time > 0) {
            target.research_done_time += server_time - target.research_start_time;
            target.research_start_time = -1;
            target.state_dirty |= obj_state_flags.URGENT;
        }
        if(target.build_start_time > 0) {
            target.build_done_time += server_time - target.build_start_time;
            target.build_start_time = -1;
            target.state_dirty |= obj_state_flags.URGENT;
        }
        if(target.upgrade_start_time > 0) {
            target.upgrade_done_time += server_time - target.upgrade_start_time;
            target.upgrade_start_time = -1;
            target.state_dirty |= obj_state_flags.URGENT;
        }
        if(target.manuf_start_time > 0) {
            target.manuf_done_time += server_time - target.manuf_start_time;
            target.manuf_start_time = -1;
            target.state_dirty |= obj_state_flags.URGENT;
        }
        if(target.is_crafting()) {
            var cat = gamedata['crafting']['categories'][gamedata['crafting']['recipes'][target.is_crafting()]['crafting_category']];
            if(('haltable' in cat) && !cat['haltable']) {
                // not haltable
            } else {
                // client-side predict what will happen

                // first check if we're going to modify anything,
                // since we do not want start_client_prediction() to
                // fire a sync request if there is no actual mutation.
                var need_to_halt = false;
                goog.array.forEach(target.get_crafting_queue(), function(bus) {
                    if(bus['start_time'] > 0) {
                        need_to_halt = true;
                    }
                });
                if(need_to_halt) {
                    // XXX the request_sync here might need to be reordered after OBJECT_COMBAT_UPDATES
                    var craft_queue = target.start_client_prediction('crafting.queue', target.crafting['queue']);
                    goog.array.forEach(craft_queue, function(bus) {
                        if(bus['start_time'] > 0) {
                            bus['done_time'] += Math.max(0, server_time - bus['start_time']);
                            bus['start_time'] = -1;
                            target.state_dirty |= obj_state_flags.URGENT;
                        }
                    });
                }
            }
        }
    }

    if(target.hp <= 0) {
        // object is destroyed
        target.hp = 0;

        if(target.is_building() && target.killer_info === null) {
            target.killer_info = get_killer_info(source);
        }

        // visual explosion and debris effects
        var fx_data = null;
        if(target === source && ('suicide_explosion_effect' in target.spec)) {
            fx_data = target.spec['suicide_explosion_effect'];
        } else if(target.is_mobile()) {
            create_debris(target, pos);
            if('explosion_effect' in target.spec) {
                fx_data = target.spec['explosion_effect'];
            } else {
                fx_data = player.get_any_abtest_value('unit_explosion_effect', gamedata['client']['vfx']['unit_explosion']);
            }
        } else {
            // buildings
            if('explosion_effect' in target.spec) {
                fx_data = target.spec['explosion_effect'];
            } else if(target.spec['gridsize'][0] > 2) {
                // big buildings
                fx_data = player.get_any_abtest_value('building_explosion_normal_effect', gamedata['client']['vfx']['building_explosion_normal']);
            } else {
                fx_data = player.get_any_abtest_value('building_explosion_small_effect', gamedata['client']['vfx']['building_explosion_small']);
            }
        }

        if(fx_data) {
            SPFX.add_visual_effect(pos, (target.is_mobile() && target.is_flying() ? target.altitude : 0), [0,1,0], client_time+time_offset, fx_data, true, null);
        }

        target.update_permanent_effect();

        // destruction of mobile units and buildings is handled differently
        if(target.is_mobile()) {
            if('on_death_spell' in target.spec) {
                var death_spell_name = target.spec['on_death_spell'];
                target.cast_client_spell(death_spell_name, gamedata['spells'][death_spell_name], target, null);
            } else {
                send_and_destroy_object(target, source);
            }
        } else if(target.is_building() || target.is_inert()) {
            target.state_dirty |= obj_state_flags.URGENT;

            // mark the tracked quest as dirty so we can update any quest tips
            player.quest_tracked_dirty = true;
            if(target.is_building()) {
                session.set_battle_outcome_dirty();
            }
        }

    } else if(damage < 0) {
        // healing
        if(target.hp > target.max_hp) { target.hp = target.max_hp; }
    } else {
        // took damage but was not destroyed
        if(target.is_mobile() && target.ai_state === ai_states.AI_DEFEND_MOVE) {
            // switch to attack-move-aggro
            for(var i = 0; i < target.orders.length; i++) {
                var order = target.orders[i];
                order['state'] = ai_states.AI_ATTACK_MOVE_AGGRO;
            }
            target.apply_orders();
        }

        // check for gradual looting
        if(target.is_building() && (target.is_storage() || target.is_producer())) {
            // "ticks" here refer to the chunks of loot given out as certain hitpoint thresholds are crossed
            // see gameserver/ResLoot.py for the details.
            var tick_size = ('gradual_loot' in gamedata ? gamedata['gradual_loot'] : -1);
            if(tick_size > 0) {
                var last_tick = Math.floor((original_target_hp-1)/tick_size) + 1;
                var this_tick = Math.floor((target.hp-1)/tick_size) + 1;
                if(this_tick < last_tick) {
                    target.state_dirty |= obj_state_flags.URGENT; // transmit the new hp value at the end of this tick
                }
            }
        }

        if('damaged_effect' in target.spec) {
            SPFX.add_visual_effect(pos, (target.is_mobile() && target.is_flying() ? target.altitude : 0), [0,1,0], client_time+time_offset, target.spec['damaged_effect'], true, null);
        }
    }

    if(target.is_blocker() && was_destroyed != target.is_destroyed()) {
        if(!was_destroyed) {
            target.block_map(-1);
        }
        if(!target.is_destroyed()) {
            target.block_map(1);
        }
    }

    if(player.is_suspicious) {
        metric_event('3950_object_hurt', {'attack_event': true,
                                          'shooter_id': source ? source.id : -1,
                                          'shooter_type': (source && source.spec && source.spec['name']) ? source.spec['name'] : 'unknown',
                                          'shooter_team': source ? source.team : 'none',
                                          'target_id': original_target_id,
                                          'target_type': target.spec['name'],
                                          'target_team': target.team,
                                          'target_pos': pos,
                                          'damage': damage,
                                          'hp_before': original_target_hp,
                                          'hp_left': target.hp,
                                          'client_time': client_time
                                        });
    }
}

function check_battle_outcome() {
    if(!session.battle_outcome_dirty) { return; }
    if(!synchronizer.is_in_sync(session.battle_outcome_sync_marker)) { return ; } // waiting for server to sync up
    session.battle_outcome_dirty = false;

    var outcome = calculate_battle_outcome();
    if(outcome != 'undecided') {
        if(session.home_base && (player.tutorial_state === 'wait_for_battle_finish')) {
            window.setTimeout(advance_tutorial, 1000);
        }
        var DELAY = gamedata['client']['battle_end_delay'];
        if(session.attack_finish_time <= 0 || (session.attack_finish_time - server_time > DELAY)) {
            session.set_attack_finish_time(server_time + DELAY);

            // set attacking units to hold position (celebration time, they won!)
            if(!session.home_base) {
                var order = {'state': ai_states.AI_ATTACK_STATIONARY, 'aggressive': false};
                for(var id in session.cur_objects.objects) {
                    var obj = session.cur_objects.objects[id];
                    if(!obj.is_destroyed() && obj.is_mobile() && obj.team == 'player') {
                        obj.new_order(order, true);
                    }
                }
            }
        }
    }
}

function calculate_battle_outcome() {
    var victory = true, defeat = true;

    if(session.home_base) {
        // home-turf battles are won if all enemy attackers are dead
        // and lost if all player units and buildings are dead

        if(session.incoming_attack_units.length > 0) {
            // more waves are yet to come
            return 'undecided';
        }

        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.team === 'enemy' && !obj.is_destroyed()) {
                victory = false;
            }
            if(obj.team === 'player' && !obj.is_destroyed()) {
                defeat = false;
            }
        }
    } else {
        // foreign-turf battles are won if all enemy units and buildings are dead
        // and UNDECIDED if all player units are dead (let player End Attack manually)
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];

            // do not count barriers
            if(obj.spec['name'] === 'barrier') { continue; }

            // do not count invulnerable objects (e.g. quarry harvesters)
            if(obj.spec['max_hp'] === 0 || obj.is_invul()) { continue; }

            if(player.tutorial_state != "COMPLETE") {
                // special case for tutorial: end battle once the three main buildings are destroyed
                var tut_targets = gamedata['tutorial']['wait_battle_finish2']['targets'];
                if(obj.team === 'enemy' && !obj.is_destroyed() && obj.spec['name'] in tut_targets) {
                    victory = false;
                }
            } else {
                if(obj.team === 'enemy' && !obj.is_destroyed()) {
                    /*
                    if(player.is_developer()) {
                        console.log('undestroyed enemy '+obj.spec['name']);
                        console.log(obj);
                    }
                    */
                    victory = false;
                }
            }

            if(obj.team === 'player' && !obj.is_destroyed()) {
                defeat = false;
            }
        }

        if(player.tutorial_state == "COMPLETE" && !gamedata['client']['end_battle_on_defeat']) {
            defeat = false; // allow battle to go on even if player has no units left
        }

        // check if the player has any more deployable units
        if(defeat && session.count_deployable_units() > 0) {
            defeat = false;
        }

        // don't end the battle if the player has usable combat items
        if(defeat) {
            for(var i = 0; i < player.inventory.length; i++) {
                var item = player.inventory[i];

                if(inventory_item_is_usable_in_combat(ItemDisplay.get_inventory_item_spec(item['spec']), session)) {
                    defeat = false;
                    session.no_more_units = true;
                    break;
                }
            }
        }

        // check for inbound missiles and damage over time effects
        if(defeat && session.combat_engine.damage_effect_queue.length > 0) {
            defeat = false;
            session.no_more_units = true;
        }
    }

    if(victory) {
        return 'victory';
    } else if(defeat) {
        return 'defeat';
    } else {
        return 'undecided';
    }
}

function for_all_objects_of_type(specname, func) {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.spec['name'] === specname) {
            func(obj);
        }
    }
}

function remove_all_barriers() {
    for_all_objects_of_type('barrier', function(obj) { send_and_remove_object(obj); });
}
function upgrade_all_barriers() {
    for_all_objects_of_type('barrier', function(obj) { Store.place_user_currency_order(obj.id, 'UPGRADE_FOR_MONEY', null, null, null); });
}

GameObject.prototype.run_control = function() {
    if(this.control_cooldown > 0) {
        this.control_cooldown -= 1;
    }

    if(this.combat_stats.stunned) { return; }

    if(this.control_state === control_states.CONTROL_SHOOT) {

        // turn to face target
        if(this.control_target && 'turn_rate' in this.spec) {
            var dir = vec_sub(this.control_target.interpolate_pos(), this.interpolate_pos());
            if((dir[1]*dir[1]+dir[0]*dir[0]) > 0.0001) {
                this.target_facing = Math.atan2(dir[1], dir[0]);
            }
        }


        if((this.control_cooldown <= 0) &&
           (!this.combat_stats.disarmed) &&
           !(this.is_building() && (this.is_upgrading() || this.is_repairing() || this.disarmed)) &&
           (!this.is_under_construction()) &&
           (!this.is_destroyed())) {

            if(player.tutorial_state != "COMPLETE") {
                if('disable_combat' in gamedata['tutorial'][player.tutorial_state] &&
                   gamedata['tutorial'][player.tutorial_state]['disable_combat']) {
                    // no shooting until after the first part of the tutorial
                    return;
                }
            }

            var target = this.control_target;

            if(target.is_destroyed()) {
                // target is already dead
                this.control_state = control_states.CONTROL_STOP;
                return;
            }

            var spell = gamedata['spells'][this.control_spellname];
            var spell_level = this.get_auto_spell_level(); // assumes auto_spell here

            if(('firing_arc' in spell) && ('turn_rate' in this.spec)) {
                // convert max angle difference to radians
                var max_arc = Math.min(get_leveled_quantity(spell['firing_arc'], spell_level)*(Math.PI/180.0), Math.PI);

                // to avoid complex modulo math, do the computations with 2D vectors
                var cur = [Math.cos(this.cur_facing), Math.sin(this.cur_facing)];
                var tgt = [Math.cos(this.target_facing), Math.sin(this.target_facing)];

                // dot product between current and target headings
                var dot = cur[0]*tgt[0] + cur[1]*tgt[1];
                dot = Math.min(dot, 1); // avoid acos NaNs with rounding errors

                if(Math.acos(dot) > max_arc) {
                    // not facing close enough to the right direction yet, wait before shooting
                    return;
                }
            }

            var cooldown = get_leveled_quantity(spell['cooldown'], spell_level);

            var cd = cooldown/this.combat_stats.rate_of_fire;
            cd /= this.combat_power_factor(); // increase cooldown if power_factor < 1
            this.control_cooldown = Math.floor(cd/TICK_INTERVAL);

            if('cooldown_name' in spell) {
                // trigger non-auto-attack cooldown
                if(!this.get_cooldown(spell['cooldown_name'])) { return; }
                var cd_ticks = Math.floor(get_leveled_quantity(spell['cooldown'], spell_level)/TICK_INTERVAL);
                this.set_cooldown(spell['cooldown_name'], session.combat_engine.cur_tick.copy(),
                                  CombatEngine.TickCount.add(session.combat_engine.cur_tick, new CombatEngine.TickCount(cd_ticks)));
            }

            var target_pos, target_height;

            if(spell['targets_self']) {
                target_pos = this.interpolate_pos();
                target_height = this.is_flying() ? this.altitude : 0;
            } else {
                target_pos = target.interpolate_pos();
                target_height = target.is_flying() ? target.altitude : 0;
            }

            this.fire_projectile(client_time, -1, spell, spell_level, target, target_pos, target_height);
        }
    } else if(this.control_state === control_states.CONTROL_STOP) {

        if(this.is_building() && 'turn_rate' in this.spec) {
            // idle turrets - rotate them around slowly
            var incr = gamedata['client']['turret_scan_speed']*Math.PI/180;
            incr *= this.combat_power_factor(); // turn more slowly if depowered
            if(this.anim_offset > 0.5) { incr *= -1; }
            this.target_facing = this.next_facing + incr*TICK_INTERVAL;
            if(this.target_facing > 2*Math.PI) {
                this.target_facing -= 2*Math.PI;
            }
        }
    }

    if(this.spec['continuous_cast'] &&
       (this.is_inert() ||
        (!this.is_destroyed() &&
         this.control_state === control_states.CONTROL_STOP &&
         !(this.is_building() && (this.is_under_construction() || this.is_upgrading() || this.is_repairing() || this.disarmed))))) {
        var name = this.spec['continuous_cast'];
        this.cast_client_spell(name, gamedata['spells'][name], null, null);
    }
};

/** adjust a shot vector to aim ahead of a target (from a stationary shooter), extrapolating its path linearly to impact
 * @param {Array.<number>} P shot vector from shooter to target at proposed impact time
 * @param {Array.<number>} target_vel velocity vector of target
 * @param {number} speed of bullet
 * @returns {number} time-of-flight of bullet, when fired in a way that will hit target at its linearly-extrapolated location
 * note: may fail to compute a time-of-flight if the target is moving away faster than the bullet can fly, in which case, returns -1.
 */
function apply_target_lead(P, target_vel, speed) {
    // attempt an accurate quadratic solution that takes into account target range changing with velocity
    // see http://playtechs.blogspot.com/2007/04/aiming-at-moving-target.html
    var a = speed*speed - vec_length2(target_vel);
    var b = vec_dot(P, target_vel);
    var c = vec_dot(P, P);
    var d = b*b + a*c;
    var t = -999;
    if(d > 0) {
        var root0 = (b - Math.sqrt(d)) / a;
        var root1 = (b + Math.sqrt(d)) / a;
        t = root0;
        if(t < 0 || (root1 >= 0 && root1 < t)) {
            t = root1;
        }
    }

    if(t > 0) {
        // only use the quadratic solution if a valid root is found
        // one might NOT be found if the target is moving away faster than the bullet can fly
        return t;
    }
    return -1; // no solution found
}

/** @param {GameObject} my_source
    @param {GameObjectId} my_id
    @param {string} my_spec_name
    @param {number} my_level
    @param {TeamId} my_team
    @param {Object} my_stats
    @param {!Array.<number>} my_pos
    @param {number} my_height
    @param {Array.<number>} my_muzzle_pos
    @param {number} fire_time
    @param {number} force_hit_time
    @param {Object} spell
    @param {GameObject|null} target
    @param {!Array.<number>} target_pos
    @param {number} target_height
    @param {boolean} fizzle
*/
function do_fire_projectile(my_source, my_id, my_spec_name, my_level, my_team, my_stats, my_pos, my_height, my_muzzle_pos, fire_time, force_hit_time, spell, target, target_pos, target_height, fizzle) {
    var max_range = gamedata['map']['range_conversion'] * get_leveled_quantity(spell['range'], my_level) * (my_stats ? my_stats.weapon_range : 1);
    var eff_range = ('effective_range' in spell ? (gamedata['map']['range_conversion'] * get_leveled_quantity(spell['effective_range'], my_level) * (my_stats ? my_stats.effective_weapon_range : 1)) : max_range);
    var shot_v = vec_sub(target_pos, my_pos);

    var shot_length;
    if(spell['distance_calc'] == '3d') {
        shot_length = v3_distance([my_pos[0], my_height, my_pos[1]], [target_pos[0], target_height, target_pos[1]]);
        // don't throw off the accuracy calculation below! hack - eventually we should use full 3D math for all target range calcs.
        max_range += Math.abs(target_height - my_height);
        eff_range += Math.abs(target_height - my_height);
    } else if(vec_equals(shot_v, [0,0])) {
        // hack - pure vertical shots
        shot_length = target_height - my_height;
    } else {
        shot_length = vec_length(shot_v);
    }

    // adjust target_pos and shot_length to account for non-zero hitbox radius
    if(target) {
        var rad = target.hit_radius();
        if(rad > 0) {
            if(shot_length > rad+0.001) {
                var new_shot_length = (shot_length - rad);
                target_pos = vec_mad(my_pos, (new_shot_length/shot_length), shot_v);
                shot_v = vec_sub(target_pos, my_pos);
                shot_length = new_shot_length;
            }
        }
    }

    var damage;
    var damage_vs = spell['damage_vs'] || {};
    if(fizzle) {
        damage = 0;
    } else {
        damage = get_leveled_quantity(spell['damage'], my_level);

        if(damage != 0) {
            // damage in spec file is PER SECOND, must convert it to PER SHOT
            damage *= get_leveled_quantity(spell['cooldown'] || 1, my_level);
            if(my_stats) {
                // apply combat stat modifiers
                damage *= my_stats.weapon_damage;
                damage_vs = merge_damage_vs(damage_vs, my_stats.weapon_damage_vs);
            }

            // quantize damage to integers, and set lower bound to 1
            if(damage >= 0) {
                damage = Math.max(Math.ceil(damage), 1);
            } else {
                damage = Math.min(Math.ceil(damage), -1);
            }
        }
    }

    var speed = player.get_any_abtest_value('global_projectile_speed_scale', gamedata['map']['global_projectile_speed_scale']) * get_leveled_quantity(spell['projectile_speed'] || 0, my_level) * (my_stats ? my_stats.projectile_speed : 1) * combat_time_scale();
    // use_lead actually changes combat target position for splash weapons
    // for non-splash weapons, it affects graphics only (since hits are computed independently)
    var use_lead = get_leveled_quantity(spell['lead_target'] || 0, my_level);
    var lead_applied = false;
    var arc = SPFX.global_gravity * get_leveled_quantity(spell['projectile_arc'] || 0, my_level);
    var copies = get_leveled_quantity(spell['projectile_burst_size'] || 1, my_level);
    if(SPFX.detail < 1) {
        copies = Math.min(Math.max(Math.floor(SPFX.detail * copies), 1), 2);
    }
    var interval = get_leveled_quantity(spell['projectile_burst_interval'] || 0, my_level);
    var prefire_delay = get_leveled_quantity(spell['prefire_delay'] || 0, my_level) / combat_time_scale();
    var postfire_delay = get_leveled_quantity(spell['postfire_delay'] || 0, my_level) / combat_time_scale();

    var shot_time, shot_height;
    if(speed > 0) {
        // account for projectile travel time
        var P = shot_v;
        shot_time = shot_length/speed;
        shot_height = shot_length * arc;

        // fire splash weapons at extrapolated target position
        if(use_lead > 0 && ('splash_range' in spell) && target && target.is_mobile() && (target.vel[0] != 0 || target.vel[1] != 0)) {
            lead_applied = true;

            if(prefire_delay+postfire_delay > 0) {
                P = vec_mad(P, prefire_delay+postfire_delay, target.vel);
            }
            var lead_shot_time = apply_target_lead(P, target.vel, speed);
            if(lead_shot_time >= 0) {
                shot_time = lead_shot_time;
            }

            // propose extrapolated target position
            var test_pos = vec_mad(target_pos, (shot_time + prefire_delay + postfire_delay) * use_lead, target.vel);

            // constrain impact distance by maximum weapon range
            var test_len = vec_distance(test_pos, my_pos);
            if(test_len > max_range) {
                //console.log('CONSTRAIN test_len '+test_len.toFixed(3)+ ' max '+max_range.toFixed(3));

                // constrain to max range
                target_pos = vec_mad(my_pos, max_range, vec_normalized(vec_sub(test_pos, my_pos)));
                // recompute shot_time
                shot_time = max_range / speed;
            } else {
                // use proposed position
                target_pos = test_pos;
            }

            // recompute shot_v and shot_length
            shot_v = vec_sub(target_pos, my_pos);
            shot_length = vec_length(shot_v);

            //console.log('shot_time '+shot_time.toFixed(3)+' t '+t.toFixed(3)+' max '+max_shot_time.toFixed(3));
        }

    } else {
        // instant hit
        shot_time = 0;
        shot_height = 0;
    }

    // hit_time is the time at which the bullet will reach its final destination
    // hit_time+postfire_delay is when it will explode and do damage

    var hit_time, impact_spread;
    if(force_hit_time > 0) {
        hit_time = force_hit_time;
        impact_spread = 0; // shoot directly at target location
    } else {
        hit_time = fire_time + prefire_delay + shot_time;
        impact_spread = get_leveled_quantity(spell['projectile_impact_spread'] || 1.5, my_level);
    }

    var miss = 0; // nonzero if the shot is a miss
    var accuracy = get_leveled_quantity(spell['accuracy'] || 1, my_level) * (my_stats ? my_stats.accuracy : 1);
    if(shot_length > eff_range) { // degrade accuracy linearly between eff_range and max_range
        //console.log("MISS! "+shot_length.toString()+" eff "+eff_range.toString());
        accuracy *= 1 - (shot_length-eff_range)/(max_range-eff_range);
    }
    if(accuracy < 1) {
        if(Math.random() >= accuracy) {
            // miss
            miss = 1;
            impact_spread *= 3;
        }
        //console.log('range '+shot_length.toFixed(1)+' ('+eff_range.toFixed(1)+'-'+max_range.toFixed(1)+') accuracy '+accuracy.toFixed(2));
    }

    // create graphical projectiles and impact effects
    var color = null;
    if(('projectile_color' in spell) && spell['projectile_color'] === null) {
        // no projectile
    }  else {
        color = spell['projectile_color'] || [1,1,0.5];
        if (my_stats && (my_stats.projectile_speed < 1)) {
            color = [0,0,0]; // special-case for really slow "bomb" shots
        } else if(my_team !== 'player') {
            if('projectile_hostile_color' in spell) {
                color = spell['projectile_hostile_color'];
            } else if(my_source.is_mobile()) {
                // hack - swap red and blue components for hostile attacks
                color = [color[2], 0.5*color[1], color[0]];
            }
        }
    }

    var exhaust = get_leveled_quantity(spell['projectile_particles'] || 0, my_level);
    if(SPFX.detail < 1) { exhaust = 0; }

    for(var i = 0; i < copies; i++) {
        // offset to de-synchronize visual effects
        var tick_offset = ('projectile_vfx_time_offset' in spell ? spell['projectile_vfx_time_offset'] : 1 ) * Math.random();
        var time_offset = tick_offset*TICK_INTERVAL/combat_time_scale();

        var impact_pos = vec_add(target_pos, [impact_spread*(-1+2*Math.random()),
                                              impact_spread*(-1+2*Math.random())]);
        var impact_height = target_height;
        var muzzle_time = fire_time+i*interval+time_offset; // time at which muzzle flash effect begins (bullet emerges prefire_delay later)
        var impact_time = hit_time+i*interval+time_offset; // time at which bullet reaches destination

        // when using unit_draw_scatter, adjust the visual effect target point towards the drawn location
        if(target && target.is_mobile() && gamedata['client']['unit_draw_scatter']) {
            impact_pos = vec_mad(impact_pos, gamedata['client']['unit_draw_scatter'], target.draw_offset);
        }
        var my_shot_v = vec_sub(impact_pos, my_pos);

        // if lead is enabled for a non-splash weapon, apply it to the graphical effect
        if(use_lead > 0 && !lead_applied && target && target.is_mobile() && (target.vel[0] != 0 || target.vel[1] != 0)) {
            var lead_shot_time = apply_target_lead(vec_mad(my_shot_v, prefire_delay+postfire_delay, target.vel), target.vel, speed);
            if(lead_shot_time >= 0) {
                impact_time = (muzzle_time + prefire_delay + lead_shot_time);
                impact_pos = vec_mad(impact_pos, (lead_shot_time + prefire_delay + postfire_delay) * use_lead, target.vel);
            }
        }

        // visual projectile effect
        if(color !== null) {
            SPFX.add(new SPFX.Projectile(my_muzzle_pos, my_height,
                                         impact_pos, impact_height,
                                         muzzle_time+prefire_delay, impact_time,
                                         shot_height, color, (exhaust ? exhaust : null),
                                         get_leveled_quantity(spell['projectile_size'] || 2, my_level),
                                         get_leveled_quantity(spell['projectile_min_length'] || 0, my_level),
                                         get_leveled_quantity(spell['projectile_fade_time'] || 0, my_level),
                                         (spell['projectile_composite_mode'] || null),
                                         (spell['projectile_glow'] || 0),
                                         (spell['projectile_asset'] || null)
                                        ));
        }

        // visual weapon impact effect
        var impact_vfx = null;
        if(fizzle && ('fizzle_visual_effect' in spell)) {
            impact_vfx = spell['fizzle_visual_effect'];
        } else if('impact_visual_effect' in spell) {
            impact_vfx = spell['impact_visual_effect'];
        } else if('splash_range' in spell) {
            impact_vfx = gamedata['client']['vfx']['weapon_hit_splash'];
        } else {
            impact_vfx = gamedata['client']['vfx']['weapon_hit_nonsplash'];
        }

        // instance properties passed to vfx system
        var vfx_props = {};
        if(my_shot_v[0] != 0 || my_shot_v[1] != 0) {
            vfx_props['heading'] = Math.atan2(my_shot_v[1], my_shot_v[0]);
        }

        if(my_source.is_mobile()) {
            vfx_props['tick_offset'] = tick_offset;
            vfx_props['my_next_pos'] = my_source.next_pos; // position we will have at start of next combat tick
        }

        if(impact_vfx) {
            SPFX.add_visual_effect(impact_pos, impact_height, [0,1,0],
                                   impact_time,
                                   impact_vfx, (i == 0), vfx_props); // only play audio for first impact
        }

        // visual muzzle flash effect
        var muzzle_vfx = null;
        if('muzzle_flash_effect' in spell) {
            muzzle_vfx = spell['muzzle_flash_effect'];
        } else if(copies > 1) {
            muzzle_vfx = gamedata['client']['vfx']['muzzle_flash_burst'];
        } else {
            muzzle_vfx = gamedata['client']['vfx']['muzzle_flash_single'];
        }

        // only apply muzzle flash on first copy
        if(muzzle_vfx && (i == 0)) {
            SPFX.add_visual_effect(my_muzzle_pos, my_height,
                                   v3_normalized([my_shot_v[0], 0, my_shot_v[1]]),
                                   muzzle_time,
                                   muzzle_vfx, true, vfx_props);
        }
    }

    // queue the actual damage effects
    if(!fizzle) {

    var effects = [];

    if('splash_range' in spell) {
        var radius = gamedata['map']['splash_range_conversion'] * get_leveled_quantity(spell['splash_range'], my_level) * (my_stats ? my_stats.splash_range : 1);
        // splash impact aura
        if(spell['impact_auras']) {
            for (var i = 0; i < spell['impact_auras'].length; i++) {
                var imp_aura = spell['impact_auras'][i];
                effects.push(new CombatEngine.AreaAuraEffect(absolute_time_to_tick(hit_time+postfire_delay), hit_time+postfire_delay, my_source, target_pos,
                                                ('splash_to_ground' in spell ? spell['splash_to_ground'] : false) || !(target_height > 0),
                                                ('splash_to_air' in spell ? spell['splash_to_air'] : false) || (target_height > 0),
                                                radius, false,
                                                get_leveled_quantity(spell['splash_falloff'] || 'linear', my_level),
                                                get_leveled_quantity(imp_aura['strength'] || 1, my_level),
                                                get_leveled_quantity(imp_aura['spec'], my_level),
                                                relative_time_to_tick(get_leveled_quantity(imp_aura['duration'] || 1, my_level)),
                                                get_leveled_quantity(imp_aura['range'] || 0, my_level),
                                                damage_vs, imp_aura['duration_vs'] || {},
                                                // enable friendly fire ONLY if targeted at same-team object
                                                spell['always_friendly_fire'] || (target && target.team === my_team)));
            }
        }

        // splash damage
        if(damage != 0) {
            effects.push(new CombatEngine.AreaDamageEffect(absolute_time_to_tick(hit_time+postfire_delay), hit_time+postfire_delay, my_source, target_pos,
                                              ('splash_to_ground' in spell ? spell['splash_to_ground'] : false) || !(target_height > 0),
                                              ('splash_to_air' in spell ? spell['splash_to_air'] : false) || (target_height > 0),
                                              radius,
                                              get_leveled_quantity(spell['splash_falloff'] || 'linear', my_level),
                                              damage, damage_vs,
                                              // enable friendly fire ONLY if targeted at same-team object
                                              spell['always_friendly_fire'] || (target && target.team === my_team)));
        }

    } else {
        if(target && !miss) {
            if(spell['impact_auras']) {
                for (var i = 0; i < spell['impact_auras'].length; i++) {
                    var imp_aura = spell['impact_auras'][i];
                    effects.push(new CombatEngine.TargetedAuraEffect(absolute_time_to_tick(hit_time+postfire_delay), hit_time+postfire_delay, my_source, target,
                                                        get_leveled_quantity(imp_aura['strength'] || 1, my_level),
                                                        get_leveled_quantity(imp_aura['spec'], my_level),
                                                        relative_time_to_tick(get_leveled_quantity(imp_aura['duration'] || 1, my_level)),
                                                        get_leveled_quantity(imp_aura['range'] || 0, my_level),
                                                        damage_vs, imp_aura['duration_vs'] || {}
                                                       ));
                }
            }

            if(damage != 0) {
                effects.push(new CombatEngine.TargetedDamageEffect(absolute_time_to_tick(hit_time+postfire_delay), hit_time+postfire_delay, my_source, target, damage, damage_vs));
            }
        }
    }

    for(var i = 0; i < effects.length; i++) {
        session.combat_engine.damage_effect_queue.push(effects[i]);
    }

    if(miss && COMBAT_DEBUG) {
        // "Miss" alert text
        SPFX.add(new SPFX.CombatText(target_pos, 0, "MISS", [1,1,0.1,1],
                                     client_time, client_time + 1.0, {drop_shadow:true}));
    }

    }

    if(player.is_suspicious) {
        metric_event('3940_shot_fired', {'attack_event': true,
                                         'shooter_id': my_id,
                                         'shooter_team': my_team,
                                         'shooter_type': my_spec_name,
                                         'shooter_pos': my_pos,
                                         'target_id': target ? target.id : -1,
                                         'target_type': target ? target.spec['name'] : 'aoe',
                                         'target_team': target ? target.team : null,
                                         'target_pos': target_pos,
                                         'range': vec_length(vec_sub(target_pos, my_pos)),
                                         'damage': damage,
                                         'speed': speed,
                                         'client_time': client_time,
                                         'fire_time': fire_time,
                                         'hit_time': hit_time,
                                         'miss': miss
                                        });
    }

    return hit_time;
};

/** @param {number} fire_time
    @param {number} force_hit_time
    @param {Object} spell
    @param {number} spell_level
    @param {GameObject|null} target
    @param {!Array.<number>} target_pos
    @param {number} target_height */
GameObject.prototype.fire_projectile = function(fire_time, force_hit_time, spell, spell_level, target, target_pos, target_height) {
    var my_pos = this.interpolate_pos();
    var my_height = (this.is_flying() ? this.altitude : 0);
    var my_muzzle_pos = my_pos;

    // compute bullet origin in map coordinates
    // note: this is only for visual effect, the combat-engine firing position is always unit origin,
    // to avoid pathfinding issues wiht facing

    if('muzzle_offset' in this.spec) {
        var facing = this.interpolate_facing();
        // note: convert muzzle_offset from model coordinates (+z north) to map coordinates (-z north)
        var offset = v3_rotate_by_facing(facing, v3_mul([1,1,-1], this.spec['muzzle_offset']));
        my_muzzle_pos = vec_add(my_muzzle_pos, [offset[0], offset[2]]);
        my_height += this.spec['muzzle_offset'][1];
    } else if('muzzle_height' in this.spec) {
        my_height += this.spec['muzzle_height'];
    }

    if(spell['kills_self']) {
        // special for Detonator Droids - kill self
        var death_client_time = client_time + (spell['kills_self_delay']||0);
        var death_tick = absolute_time_to_tick(fire_time + /** @type {number} */ (spell['kills_self_delay']||0));
        session.combat_engine.damage_effect_queue.push(new CombatEngine.KillDamageEffect(death_tick, death_client_time, this, this));
    }

    var hit_time = do_fire_projectile(this, this.id, this.spec['name'],
                                      spell_level,
                                      this.team, this.combat_stats, my_pos, my_height, my_muzzle_pos, fire_time, force_hit_time, spell, target, target_pos, target_height, false);
};


GameObject.prototype.ai_threatlist_update = function() {
    if(!this.spec['enable_ai_threatlist']) { return; }
    if(this.ai_threatlist !== null && !this.ai_threatlist_dirty) { return; }

    // throttle how many of these updates can take place per frame, since they can involve expensive queries
    if(this.is_mobile() && tick_astar_queries_left === 0) {
        return;
    }
    tick_astar_queries_left -= 1;

    // remember previous target, to try to re-target it if possible
    var prev_target_id = null;
    if(this.ai_threatlist !== null && this.ai_threatlist.length >= 1) {
        prev_target_id = this.ai_threatlist[0]['obj_id'];
    }

    this.ai_threatlist_dirty = false;
    this.ai_threatlist = [];

    var auto_spell = this.get_auto_spell();
    if(!auto_spell) { return; }
    var auto_spell_level = this.get_auto_spell_level();

    var aggro_radius;
    if(this.is_mobile()) {
        // search entire map for targets. Target found will be
        // position-dependent, but we assume that any changes to game
        // state that would change our choice of target will also
        // dirty the threatlist.

        var ncells = session.viewing_base.ncells();
        aggro_radius = Math.sqrt(2)*Math.max(ncells[0], ncells[1]);
    } else {
        // turrets only look within weapon range
        aggro_radius = gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['range'], auto_spell_level) * this.combat_stats.weapon_range;
    }

    var targeting_result = this.ai_pick_target_classic(auto_spell, auto_spell_level, aggro_radius, false, prev_target_id, 'ai_threatlist_update');
    if(targeting_result && targeting_result.target) {
        this.ai_threatlist.push({'obj_id': targeting_result.target.id,
                                 'spec': targeting_result.target.spec.name,
                                 'path_end': targeting_result.path_end || null});
    }
};

// find "best" thing to target within shoot_range (which may be <= 0, or longer than weapon range)
/** @param {Object} auto_spell
    @param {number} auto_spell_level
    @param {number} shoot_range
    @param {boolean} nearest_only
    @param {string} tag */
GameObject.prototype.ai_pick_target = function(auto_spell, auto_spell_level, shoot_range, nearest_only, tag) {
    if(this.spec['enable_ai_threatlist']) {
        if(this.ai_threatlist !== null) {
            return this.ai_pick_target_by_threatlist(auto_spell, auto_spell_level, shoot_range);
        } else {
            // this can happen if A* is starved
            if(AI_DEBUG >= 2) { console.log(this.spec['name']+' no active threatlist!'); }
            return {target:null};
        }
    } else {
        return this.ai_pick_target_classic(auto_spell, auto_spell_level, shoot_range, nearest_only, null, tag);
    }
};

/** @param {Object} auto_spell
    @param {number} auto_spell_level
    @param {number} shoot_range */
GameObject.prototype.ai_pick_target_by_threatlist = function(auto_spell, auto_spell_level, shoot_range) {
    // weed out dead objects
    this.ai_threatlist = goog.array.filter(this.ai_threatlist, function(a) {
        var obj = session.cur_objects.get_object(a['obj_id']);
        if(!obj || obj.is_destroyed()) { return false; }
        return true;
    });
    if(this.ai_threatlist.length > 0) {
        var entry = this.ai_threatlist[0];
        var obj = session.cur_objects.get_object(entry['obj_id']);
        var his_pos = obj.interpolate_pos();
        return {target: obj,
                pos: his_pos,
                dist: Math.max(0, vec_distance(this.interpolate_pos(), his_pos) - obj.hit_radius()),
                path_end: (entry['path_end'] || null)};
    }
    return {target:null};
};

// stateless version of target-picking
/** @param {Object} auto_spell
    @param {number} auto_spell_level
    @param {number} shoot_range
    @param {boolean} nearest_only
    @param {string|null} prev_target_id
    @param {string} tag */
GameObject.prototype.ai_pick_target_classic = function(auto_spell, auto_spell_level, shoot_range, nearest_only, prev_target_id, tag) {
    var verbose = (AI_DEBUG >= 2 && this.is_mobile());

    var auto_spell_range = gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['range'], auto_spell_level) * this.combat_stats.weapon_range;
    var auto_spell_min_range = ('min_range' in auto_spell) ? gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['min_range'], auto_spell_level) : -1; // * Math.max(1,this.combat_stats.weapon_range); ?
    var priority_far_range = ('priority_far_range' in auto_spell) ? (gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['priority_far_range'], auto_spell_level) * Math.max(1,this.combat_stats.weapon_range)) : -1;

    var target_team = null;

    var target_full_health_objects;
    if(auto_spell['help']) {
        target_team = this.team;
        target_full_health_objects = false;
    } else {
        if(this.team === 'player') {
            target_team = 'enemy';
        } else {
            target_team = 'player';
        }
        target_full_health_objects = true;
    }

    var target_mobile_only;
    if(('targets_nonmobile' in auto_spell && !auto_spell['targets_nonmobile']) || (this.ai_state === ai_states.AI_DEFEND_MOVE)) {
        target_mobile_only = true;
    } else {
        target_mobile_only = false;
    }

    // create targeting priority table
    var priority_table = gamedata['base_priority_vs']; // start with game defaults

    if(auto_spell['priority_vs'] || auto_spell['damage_vs']) { // merge in spell's priority_vs or damage_vs, if present
        priority_table = merge_damage_vs(priority_table, auto_spell['priority_vs'] || auto_spell['damage_vs']);
    }

    // in the future, this table could be used to cut down on the object query (by skipping objects whose priority would be <= 0)

    var my_pos = this.interpolate_pos();

    // do we want to bother querying for barriers?
    var exclude_barriers;
    if(auto_spell['priority_vs'] && ('barrier' in auto_spell['priority_vs']) && (auto_spell['priority_vs']['barrier'] > 0)) {
        // if the weapon spell has a positive priority_vs for "barrier", assume we always care about them
        exclude_barriers = false;
    } else {
        // player units ignore barriers when on auto control, or when target_barriers preference is off.
        exclude_barriers = (this.team === 'player' && (get_preference_setting(player.preferences, 'auto_unit_control') || !get_preference_setting(player.preferences, 'target_barriers')));
    }

    var obj_list = query_objects_within_distance(my_pos, shoot_range,
                                                 { ignore_object: this,
                                                   exclude_invul: true,
                                                   only_team: target_team,
                                                   exclude_full_health: !target_full_health_objects,
                                                   exclude_barriers: exclude_barriers,
                                                   mobile_only: target_mobile_only,
                                                   exclude_flying: !(auto_spell['targets_air'] || this.combat_stats.anti_air),
                                                   flying_only: !auto_spell['targets_ground'],
                                                   exclude_invisible_to: this.team,
                                                   nearest_only: nearest_only,
                                                   tag: tag
                                                 });

    // within this list, find the object that is 1) highest priority and 2) nearest
    var ret_obj = null;
    var max_priority = -1;
    var min_dist = 9999;
    var min_pos = null;
    var min_path_end = null; // best target requires movement towards this point to reach firing range

    for(var i = 0; i < obj_list.length; i++) {
        var obj = obj_list[i].obj, dist = obj_list[i].dist, pos = obj_list[i].pos;
        var override_priority = obj_list[i].override_priority || null; // this is set for "blocker" objects
        var override_path_end = obj_list[i].override_path_end || null; // this is set for "blocker" objects
        var debug_orig_target = obj_list[i].debug_orig_target || null; // this is set for "blocker" objects

        var path_end = (override_path_end || null);

        if(auto_spell_min_range > 0 && (dist+2*obj.hit_radius()) < auto_spell_min_range) { continue; } // too close

        var priority;
        if(override_priority !== null) {
            priority = override_priority;
        } else {
            priority = get_damage_modifier(priority_table, obj);

            if(prev_target_id && obj.id === prev_target_id && ('prev_target' in priority_table)) {
                // unit prefers to re-use the previous target, even if a new, higher-priority one becomes available
                priority *= priority_table['prev_target'];
            }

            var is_far = false;
            if(priority > 0 && priority_far_range > 0 && dist > priority_far_range && ('far' in priority_table)) {
                // if target is very far away (beyond priority_far_range), then reduce its priority
                priority *= priority_table['far'];
                is_far = true;
            }

            //if(verbose) { console.log(this.spec['name']+' -> '+obj.spec['name']+': dist '+dist.toString()+' auto_spell_range '+auto_spell_range.toString()+' prio '+priority.toString() + (is_far ? 'FAR' : '')); }

        }

        if(verbose) {
            var s = 'considering target: '+obj.spec['name']+' at '+vec_print(obj.interpolate_pos());
            if(debug_orig_target) { s += ' blocking '+debug_orig_target.spec['name']; }
            console.log(s);
        }

        if(override_priority === null) {

            if(priority > 0 && (dist > auto_spell_range) && ('inaccessible' in priority_table)) {
                // if the spell cares about accessibility, we have to
                // figure out whether we can get in range of the target
                // without destroying something in the way

                // See diagram at https://docs.google.com/a/spinpunch.com/spreadsheets/d/1q9XGfbzhnzK_5V8FP7BoBgkdcK93cQbuMAsf5BIP-Q0/edit?usp=sharing

                // "dest" is the point furthest from the target (along the vector from us to it) where we can just barely be in range to shoot it
                var dest = pos;
                var delta = vec_sub(pos, my_pos);
                var full_len = vec_length(delta);
                if(dist < full_len) {
                    dest = vec_add(my_pos, vec_scale(dist/full_len, delta));
                }
                var ncells = session.viewing_base.ncells();
                var cur_cell = [clamp(Math.floor(my_pos[0]),0,ncells[0]-1),
                                clamp(Math.floor(my_pos[1]),0,ncells[1]-1)];
                var dest_cell = [clamp(Math.floor(dest[0]),0,ncells[0]-1),
                                 clamp(Math.floor(dest[1]),0,ncells[1]-1)];
                var accessible = astar_map.linear_path_is_clear(cur_cell, dest_cell) ? 1 : 0;
                if(verbose) { console.log('    direct path clear? '+accessible.toString()); }

                if(!accessible) { // straight-line path is not clear - try an A* path to any cell within shooting range of the target
                    var test_path = null;

                    var test_point = vec_floor(pos);
                    if(!astar_map.is_blocked(test_point)) {
                        // destination itself is unblocked, try getting directly to it
                        test_path = astar_context.search(cur_cell, test_point);
                    } else {
                        // need to search in an expanding ring for unblocked cells
                        var ring_size = Math.ceil(auto_spell_range + obj.hit_radius());
                        test_path = astar_context.ring_search(cur_cell, test_point, ring_size);
                    }

                    if(verbose) {
                        console.log('    PATH to '+obj.spec['name']+':'); console.log(test_path);
                        if(test_path && test_path.length >= 1) {
                            console.log('    remainder '+(vec_distance(test_path[test_path.length-1], pos) - obj.hit_radius()).toString());
                        }
                    }

                    if(test_path && test_path.length >= 1 && vec_distance(test_path[test_path.length-1], pos) - obj.hit_radius() <= auto_spell_range) {
                        // target IS accessible by moving around obstacles

                        if(verbose) { console.log('    obstacles '+(vec_distance(test_path[test_path.length-1], pos)).toString()+' hit_radius '+obj.hit_radius().toString()+' spell_range '+auto_spell_range.toString()); }

                        // but if the path takes us farther away than our priority_far_range BEYOND the direct path, consider the path not usable
                        // note: using test_path.length here directly is the Manhattan distance approximation, not true distance
                        // XXX the middle test in this if() statement might need further refinement, tweaking exactly
                        // how far out of the way a unit should be willing to go before deciding to break through obstacles instead.
                        if(priority_far_range > 0 && test_path.length >= priority_far_range && ('far' in priority_table)) {
                            if(verbose) { console.log('    deviation too big ('+test_path.length.toString()+' vs '+priority_far_range.toString()+'), treating it as inaccessible'); }
                            accessible = 0;
                            path_end = test_path[test_path.length-1];
                        } else {
                            // target CAN be reached with small path deviation
                            if(verbose) { console.log('    deviation small, going around obstacles'); }
                            accessible = 2;
                            path_end = test_path[test_path.length-1];
                        }
                    }

                    if(!accessible && ('blocker' in priority_table)) { // no cell within shooting range of the target is accessible by a fully clear path
                        // try to identify a barrier along the way, and promote it up near the target's priority
                        var temp = this.ai_pick_target_find_blocker(cur_cell, dest_cell, target_team, obj, auto_spell_range);
                        if(temp) {
                            var blocker = temp.blocker, blocker_path_end = temp.blocker_path_end;
                            // found something in the way that we can smash!
                            // append it to the list of objects to examine, with priority set to *our main target's* priority, scaled by 'blocker'
                            if(verbose) { console.log("    BLOCKER "+blocker.spec['name']+ ' at '+vec_print(blocker.raw_pos())+' prio '+(priority * priority_table['blocker']).toString()); }
                            obj_list.push(new GameTypes.GameObjectQueryResult(blocker, vec_distance(my_pos, blocker.raw_pos()) - blocker.hit_radius(), blocker.raw_pos(),
                                                                    priority * priority_table['blocker'],
                                                                    blocker_path_end,
                                                                    obj));
                        }
                    }
                }

                if(!accessible) {
                    priority *= priority_table['inaccessible'];
                }
            }
        }

        // switch to this target if it is higher priority than any other target we've checked,
        // OR (it is equal to the highest priority AND closer than any other target of that priority)
        if((priority > max_priority) ||
           ((priority == max_priority) && (dist < min_dist))) {

            if(auto_spell['kills_self'] && priority <= 0) {
                // do not waste suicide explosions against targets that will take no damage from them.
                continue;
            }

            if(verbose) {
                var s = 'new best target! '+obj.spec['name']+' prio '+priority.toString()+' at '+vec_print(obj.interpolate_pos());
                if(debug_orig_target) { s += ' blocking '+debug_orig_target.spec['name']; }
                console.log(s);
            }

            max_priority = priority;
            min_dist = dist;
            min_pos = pos;
            min_path_end = path_end;
            ret_obj = obj;
        }
    }

    var ret = {target:ret_obj, pos:min_pos, dist:min_dist, /*priority:max_priority,*/ path_end:min_path_end};
    if(verbose) {
        console.log(this.spec['name']+' '+this.id+' now targeting -> '+ret_obj.spec['name']+' at '+vec_print(ret_obj.interpolate_pos()));
        //console.log(ret);
    }
    return ret;
};

/** This function is called from the target-picking code when a target object is not accessibly by any clear path.
    It tries to find the best blocking object to break to clear the way. (note: regular buildings can also count
    as "blockers", it doesn't have to be a barrier).
    @param {!Array.<number>} cur_cell - where we are now
    @param {!Array.<number>} dest_cell - where we want to go (might be blocked)
    @param {string} target_team - limit candidate objects to those on this team
    @param {GameObject} obj - the actual target we're trying to reach
    @param {number} auto_spell_range - our weapon range
    @return {{blocker:!GameObject, blocker_path_end: !Array.<number>}|null} - the blocking object, and the nearby cell coordinates from which we can hit it */
// XXX should be a member of Mobile, not GameObject
GameObject.prototype.ai_pick_target_find_blocker = function(cur_cell, dest_cell, target_team, obj, auto_spell_range) {
    var blocker = null;
    var blocker_path_end = null;

    /** @type {Object.<string,boolean>} - set of object IDs we've seen */
    var seen_objects = {}; // for making sure we only evaluate each candidate blocker once

    // Naive/greedy blocker detection: march along the straight line from cur to dest, picking the closest reachable obstacle along it.
    // This could be improved by using A* with a cost function.
    var straight_path = astar_map.get_linear_path(cur_cell, dest_cell);

    // Alternatively, this iteration could be done using astar_map, now that it can remember which objects are responsible for blocking a cell.
    // It would probably be faster that way.
    for(var j = 0; j < straight_path.length; j++) {
        // XXX note: this will return slightly different results depending on map_accel_chunk!
        var blocker_list = voxel_map_accel.objects_near_xy(straight_path[j], target_team);
        if(!blocker_list) { continue; }
        var min_blocker_dist = Infinity; // use minimum distance from us to blocker to break ties
        for(var k = 0; k < blocker_list.length; k++) {
            var b = blocker_list[k];
            if(b !== obj && !b.is_destroyed() && b.is_building() && b.is_blocker() && !(b.id in seen_objects)) {
                seen_objects[b.id] = true;

                // Check if b actually lies on any cell in the straight path.
                // Since voxel_map_accel is conservative, we have to check each object it returns to see if it's actually on the path.
                // The original SG release didn't have this check, so units would flail around destroying ALL
                // nearby objects returned by voxel_map_accel, instead of only the ones that block their path!
                if(!b.covers_any_of(straight_path)) { continue; }

                var b_pos = b.interpolate_pos();
                var d = vec_distance(b_pos, cur_cell);
                if(d < min_blocker_dist) {
                    // construct linear path towards blocker
                    var b_path = astar_map.get_linear_path(cur_cell, b_pos);

                    // march along the linear path, trying to get in range before hitting a blocker
                    for(var p = 0; p < b_path.length; p++) {
                        var pt = b_path[p];
                        if(p > 0 && astar_map.is_blocked(vec_floor(pt))) {
                            break; // can't get directly to this blocker
                        }
                        // in range yet?
                        if(vec_distance(pt, b_pos) - b.hit_radius() <= auto_spell_range) {
                            // found a viable blocker!
                            blocker_path_end = pt;
                            playfield_check_pos(blocker_path_end, 'blocker_path_end');
                            blocker = b;
                            min_blocker_dist = d;
                            break;
                        }
                    }
                }
            }
            // don't stop here - just picking the first one found causes grouped units to pick different targets - not good
        }
        if(blocker) { break; } // stop - any other objects would be further along the path and thus further away
    }
    return (blocker && blocker_path_end) ? {blocker:blocker, blocker_path_end:blocker_path_end} : null;
};

// AI-level function - set control state to stop
GameObject.prototype.ai_stop = function() {
    this.control_state = control_states.CONTROL_STOP;
    this.control_spellname = null;
    this.control_target = null;
};

// AI-level function - set control state to shoot. Trusts that target is in range!
GameObject.prototype.ai_shoot = function(auto_spell, target) {
    this.control_state = control_states.CONTROL_SHOOT;
    this.control_spellname = auto_spell['name'];
    this.control_target = target;
};

// AI-level function - set control state to move to a location. "target" is an optional target object to set as control_target
// XXX should be a member of Mobile, not GameObject
GameObject.prototype.ai_move_towards = function(new_dest, target, reason) {
    if(!new_dest) { this.ai_stop(); return; } // nowhere to go
    playfield_check_pos(new_dest, 'ai_move_towards ('+reason+')');

    this.control_spellname = null;
    this.control_target = target || null;

    if(vec_equals(this.interpolate_pos(), new_dest)) {
        this.control_state = control_states.CONTROL_STOP; // already here
        this.dest = new_dest;
    } else {
        this.control_state = control_states.CONTROL_MOVING;
        if(!vec_equals(this.dest, new_dest)) {
            if(!vec_equals_integer(this.dest, new_dest)) {
                this.path_valid = false;
            }
            this.dest = new_dest;
        }
    }
};

// AI-level function - set control state to attack or pursue a target, as retured by ai_pick_target()
/** @param {Object} auto_spell
    @param {number} auto_spell_level
    @param {Object} targeting_result */
GameObject.prototype.ai_pursue_target = function(auto_spell, auto_spell_level, targeting_result) {
    var auto_spell_range = gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['range'], auto_spell_level) * this.combat_stats.weapon_range;
    var auto_spell_eff_range = ('effective_range' in auto_spell) ? gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['effective_range'], auto_spell_level) * this.combat_stats.effective_weapon_range : auto_spell_range;
    var auto_spell_min_range = ('min_range' in auto_spell) ? gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['min_range'], auto_spell_level) : -1; // * Math.max(1,this.combat_stats.weapon_range); ?

    this.ai_target = targeting_result.target;

    // if the target is in effective range, shoot it.
    // if the target is in range but not in effective range, shoot it if our weapon is not on cooldown
    // if our weapon is on cooldown, move closer (but if in hold-position, do not move)
    // otherwise, move closer
    if((targeting_result.dist <= auto_spell_range) &&
       (auto_spell_min_range < 0 || (targeting_result.dist+2*targeting_result.target.hit_radius()) >= auto_spell_min_range) &&
       ((targeting_result.dist <= auto_spell_eff_range) || (this.ai_state === ai_states.AI_ATTACK_STATIONARY) || (this.control_cooldown <= 0))) {
        this.ai_shoot(auto_spell, this.ai_target);
    } else if(this.is_mobile() && this.ai_state !== ai_states.AI_ATTACK_STATIONARY) {
        if(auto_spell_min_range >= 0) { throw Error('need to implement ai_move_away'); }
        var dest;
        if(targeting_result.path_end) {
            dest = targeting_result.path_end;
            playfield_check_pos(dest, 'ai_pursue_target (targeting_result.path_end)');
        } else {
            dest = targeting_result.pos;
            var reason = 'targeting_result.pos';

            if(gamedata['enable_accurate_target_selection_distance'] &&
               (targeting_result.dist > 0 || astar_map.is_blocked(vec_floor(dest)))) {
                // move to nearest edge of target, not center of target
                // (not sure about the is_blocked check - when dist is zero so that unit will stay in place (dest = my_pos) (?))
                var my_pos = this.interpolate_pos();
                var delta = vec_sub(targeting_result.pos, my_pos);
                var full_len = vec_length(delta);
                if(targeting_result.dist < full_len) {
                    dest = vec_add(my_pos, vec_scale(targeting_result.dist/full_len, delta));
                    reason = 'targeting_result.pos -> accurate';
                }
            }
            playfield_check_pos(dest, 'ai_pursue_target ('+reason+')');
        }
        this.ai_move_towards(dest, this.ai_target, 'ai_pursue_target');
    } else {
        this.ai_stop(); // can't move

        // if a turret's current target moves out of range, try to switch to a closer target
        if(!this.is_mobile() && this.ai_threatlist !== null) {
            this.ai_threatlist_dirty = true;
        }
    }
};

// move on to next queued order, defaulting to AI_ATTACK_ANY (and returning true) if none apply
GameObject.prototype.next_ai_order = function() {
    this.state_dirty |= obj_state_flags.ORDERS;

    if(this.orders.length > 0) {
        var old_order = this.orders.shift();

        if(this.is_mobile() && this.patrol) {
            // recycle old order
            this.orders.push(old_order);
        }
    }

    if(this.orders.length == 0) {
        var dest;
        if(this.ai_dest) {
            dest = this.ai_dest;
        } else if(session.viewing_base.base_landlord_id != session.user_id && this.team === 'player') {
            // on offense, units should not adopt any position as "home" to leash back to
            // not sure if we want to also apply this to enemy units invading player's home base
            dest = null;
        } else {
            dest = this.interpolate_pos();
        }

        // quantize dest
        if(dest) { dest = [Math.floor(dest[0]), Math.floor(dest[1])]; }

        var order = {'state': ai_states.AI_ATTACK_ANY, 'dest': dest};
        this.new_order(order, true);
        return true;
    } else {
        this.apply_orders();
    }
    return false;
};

GameObject.prototype.run_ai = function() {
    var auto_spell = this.get_auto_spell();
    var auto_spell_level = this.get_auto_spell_level();
    var auto_spell_range, auto_spell_eff_range, auto_spell_min_range;
    if(auto_spell) {
        auto_spell_range = gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['range'], auto_spell_level) * this.combat_stats.weapon_range;
        auto_spell_eff_range = ('effective_range' in auto_spell) ? gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['effective_range'], auto_spell_level) * this.combat_stats.effective_weapon_range : auto_spell_range;
        auto_spell_min_range = ('min_range' in auto_spell) ? gamedata['map']['range_conversion'] * get_leveled_quantity(auto_spell['min_range'], auto_spell_level) : -1; // * Math.max(1,this.combat_stats.weapon_range); ?

    } else {
        auto_spell_range = auto_spell_eff_range = auto_spell_min_range = -1;
    }

    if(this.ai_state === ai_states.AI_ATTACK_SPECIFIC) {
        if(!auto_spell) {
            throw Error('AI_ATTACK state but unit has no auto-cast spell');
        }
        if(auto_spell_min_range > 0) { throw Error('AI_ATTACK_SPECIFIC not supported when spell has min_range'); } // needs code to back away if too close

        // if the target is dead, switch to AI_ATTACK_ANY
        if(this.ai_target === null || this.ai_target.is_destroyed()) {
            this.ai_target = null;
            this.next_ai_order();
        } else if(!(auto_spell['targets_air'] || this.combat_stats.anti_air) && this.ai_target.is_flying()) {
            // prevent non-anti-air weapons from shooting at air target
            this.ai_target = null;
            this.next_ai_order();
        } else if(!auto_spell['targets_ground'] && !this.ai_target.is_flying()) {
            // prevent anti-air-only weapons from shooting at ground target
            this.ai_target = null;
            this.next_ai_order();
        } else {
            var target_pos = this.ai_target.interpolate_pos();
            var dist = vec_distance(this.interpolate_pos(), target_pos) - this.ai_target.hit_radius();
            this.ai_pursue_target(auto_spell, auto_spell_level, {target:this.ai_target, pos:target_pos, dist:dist});
        }
    }

    if(this.ai_state === ai_states.AI_ATTACK_ANY || this.ai_state === ai_states.AI_ATTACK_STATIONARY ||
       this.ai_state === ai_states.AI_ATTACK_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO || this.ai_state === ai_states.AI_DEFEND_MOVE) {
        if(!auto_spell) {
            throw Error('AI_ATTACK state but unit has no auto-cast spell');
        }

        var shoot_range = auto_spell_range;

        var offense_or_defense;
        if(this.team == 'player') {
            offense_or_defense = (session.viewing_base.base_landlord_id == session.user_id ? 'defense' : 'offense');
        } else {
            offense_or_defense = (session.viewing_base.base_landlord_id == session.user_id ? 'offense' : 'defense');
        }

        var leash_radius = -1;
        // do not leash during tutorial, it causes problems...
        if(!this.ai_aggressive && player.get_any_abtest_value('enable_leash_radius', gamedata['enable_leash_radius']) && (player.tutorial_state == "COMPLETE")) {
            if('leash_radius' in this.spec) {
                leash_radius = this.get_leveled_quantity(this.spec['leash_radius']);
            } else {
                leash_radius = gamedata['map']['leash_radius'][this.team][offense_or_defense];
            }
        }

        var leash_distance = -1;
        if(leash_radius > 0 &&
           (this.ai_state === ai_states.AI_ATTACK_ANY || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO) &&
           this.ai_dest) {
            leash_distance = vec_distance(this.interpolate_pos(), this.ai_dest);

            // check leash before shooting
            if(player.get_any_abtest_value('enable_leash_radius_while_shooting', gamedata['enable_leash_radius_while_shooting'])) {
                if(leash_distance >= leash_radius) {
                    // ignore all targets, leash!
                    shoot_range = 0;
                }
            }
        }

        // reset targeting
        this.ai_target = null;

        // find best targetable objects within shooting range
        var targeting_result = null;
        if(this.is_mobile() && this.ai_state !== ai_states.AI_ATTACK_STATIONARY && (gamedata['enable_global_targeting'] || auto_spell['global_targeting'])) {
            targeting_result = null; // skip directly to the aggro-range query
        } else if(shoot_range > 0) {
            targeting_result = this.ai_pick_target(auto_spell, auto_spell_level, shoot_range, false, 'enemies_near');
        }

        if(targeting_result && targeting_result.target) {
            // a target has been found within max weapon range
            this.ai_pursue_target(auto_spell, auto_spell_level, targeting_result);

            // BUT, as a special case, if we are mobile and shooting at a
            // nonmobile, non-dangerous target, and we are being
            // attacked by something that we are able to shoot, then
            // retarget and either shoot or move towards the attacker
            if(this.is_mobile() && shoot_range > 0 && !this.ai_target.is_mobile() && !this.ai_target.is_shooter() &&
               (!this.ai_target.is_building() || !this.ai_target.is_turret()) &&
               ((this.ai_state !== ai_states.AI_ATTACK_STATIONARY) || (this.team !== 'player')) &&
               this.last_attacker && !this.last_attacker.is_destroyed() && (this.last_attacker.is_mobile() || this.last_attacker.is_building()) &&
               ((auto_spell['targets_ground'] && !this.last_attacker.is_flying()) ||
                ((auto_spell['targets_air'] || this.combat_stats.anti_air) && this.last_attacker.is_flying())) &&
               vec_distance(this.interpolate_pos(), this.last_attacker.interpolate_pos()) <= this.last_attacker.weapon_range()[1] &&
               !(auto_spell['help'] || 0)) {
                //console.log('SPECIAL CASE: SWITCHING TARGET TO '+this.last_attacker.spec['name']);

                var last_attacker_pos = this.last_attacker.interpolate_pos();
                this.ai_pursue_target(auto_spell, auto_spell_level, {target:this.last_attacker, pos:last_attacker_pos, dist:vec_distance(this.interpolate_pos(), last_attacker_pos) - this.last_attacker.hit_radius()});
            }

        } else {
            // no target within shooting range - look beyond range now

            if(!this.is_mobile()) {
                this.ai_stop(); // can't move

                // but, turrets should stay on the lookout for new targets that come into range
                if(this.ai_threatlist !== null) {
                    this.ai_threatlist_dirty = true;
                }

            } else {

                if(this.ai_state === ai_states.AI_ATTACK_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO) {
                    // proceed to a-move destination
                    this.ai_move_towards(this.ai_dest, null, 'amove');
                }

                // if no target has been found yet, and we're mobile, then move towards the nearest enemy object
                // within aggro radius
                if(this.ai_aggressive || this.ai_state === ai_states.AI_ATTACK_ANY || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO) {

                    // only pursue targets within aggro radius
                    var aggro_radius;

                    // if aggressive or a healer, use the entire map
                    if(this.ai_aggressive /* || auto_spell['help'] */) {
                        // entire map
                        var ncells = session.viewing_base.ncells();
                        aggro_radius = Math.max(ncells[0], ncells[1]);
                    } else {
                        if('aggro_radius' in this.spec) {
                            aggro_radius = this.get_leveled_quantity(this.spec['aggro_radius']);
                        } else {
                            aggro_radius = gamedata['map']['aggro_radius'][this.team][offense_or_defense];
                        }

                        // if unit is too far from its origin point, leash back
                        if(leash_distance > 0) {
                            if(leash_distance >= leash_radius) {
                                // leash back
                                aggro_radius = 0;
                            } else {
                                // limit aggro to "gap" (distance remaining before leash ends) plus weapon range, to avoid oscillation when aggro expands after beginning to leash
                                aggro_radius = Math.min(aggro_radius, (leash_radius - leash_distance) + shoot_range);
                            }
                        }
                    }

                    if(aggro_radius > 0) {
                        // make sure aggro radius is at least as big as weapon range
                        aggro_radius = Math.max(aggro_radius, shoot_range);
                    }

                    // find nearest targetable object within aggro range
                    this.ai_target = null;

                    // note: using the nearest_only flag here, which turns
                    // off prioritization for distant targets, is probably
                    // wrong behavior-wise, but the old (pre-SG) code
                    // behaved that way, and we do not want to
                    // unexpectedly change combat AI behavior in old
                    // games, so optionally use the old behavior.
                    var bad_long_range_targeting = !gamedata['enable_prioritized_long_range_targeting'];
                    var long_range_targeting_result = this.ai_pick_target(auto_spell, auto_spell_level, aggro_radius, bad_long_range_targeting, 'enemies_far');

                    if(long_range_targeting_result && long_range_targeting_result.target) {
                        this.ai_pursue_target(auto_spell, auto_spell_level, long_range_targeting_result);
                    } else if(this.ai_dest) {
                        // leash back to "home" location
                        this.ai_move_towards(this.ai_dest, null, 'leash');
                    }
                }
            }
        }
    }

    if(this.ai_state === ai_states.AI_STOP) {
        this.ai_stop();
    }

    if('special_ai' in this.spec) {
        read_consequent(this.spec['special_ai']).execute({'source_obj':this}); // , 'xy': this.interpolate_pos()});
    }
};

/**
 * Get the map cells occupied by a building or inert at position "xy" with size "gridsize"
 * returns [[x_lo,x_hi], [y_lo,y_hi]]  (where lo to hi-1 are blocked, hi itself is not blocked)
 * Must match get_grid_bounds() in server Python!
 * @param {Array.<number>} xy
 * @param {Array.<number>} gridsize
 */
function get_grid_bounds(xy, gridsize) {
    // by convention, xy is at the "center" of the object
    // for objects with odd gridsizes, the bound is extended one unit east/south
    var half = [gridsize[0]>>1, gridsize[1]>>1]; // vec_floor(vec_add(vec_scale(0.5, gridsize), [0.5,0.5]));
    var extra = [(gridsize[0]&1) ? 1 : 0,
                 (gridsize[1]&1) ? 1 : 0];
    return [[xy[0]-half[0], xy[0]+half[0]+extra[0]],
            [xy[1]-half[1], xy[1]+half[1]+extra[1]]];
}

/**
 * Instantiate any permanent SPFX effect specified by this object's spec and stores a reference to it
 * in this.permanent_effect. Does nothing if that effect has already been created.
 */
GameObject.prototype.update_permanent_effect = function() {
    if(this.is_destroyed() || this.is_under_construction()) {
        this.remove_permanent_effect();
        return;
    }

    var fx = this.get_leveled_quantity(this.spec['permanent_effect'] || null);
    if(!fx) {
        this.remove_permanent_effect();
        return;
    }

    var pos = this.interpolate_pos();

    // if we already have an effect, but it's the wrong one, then remove it
    if(this.permanent_effect && (this.permanent_effect_source !== fx)) {
        this.remove_permanent_effect();
    }

    if(this.permanent_effect) {
        // move existing effect
        this.permanent_effect.reposition([pos[0], this.altitude || 0, pos[1]]);
    } else {
        // create new effect
        this.permanent_effect = SPFX.add_visual_effect(pos, this.altitude || 0, [0, 1, 0], client_time, fx, true, null);
        this.permanent_effect_source = fx;
    }
};

/**
 * Removes any permanent SPFX effects attached to this object.
 */
GameObject.prototype.remove_permanent_effect = function() {
    if(this.permanent_effect) {
        SPFX.remove(this.permanent_effect);
        this.permanent_effect = null;
        this.permanent_effect_source = null;
    }
};

/**
 * @constructor
 * @extends GameObject
 */
function MapBlockingGameObject() {
    goog.base(this);
}
goog.inherits(MapBlockingGameObject, GameObject);

MapBlockingGameObject.prototype.is_blocker = function() { return true; };

MapBlockingGameObject.prototype.receive_state = function(data, init, is_deploying) {
    var old_x = this.x, old_y = this.y;
    var was_destroyed = this.spec && this.is_destroyed();

    goog.base(this, 'receive_state', data, init, is_deploying);

    this.update_map(old_x, old_y, was_destroyed);
};

MapBlockingGameObject.prototype.update_map = function(old_x, old_y, was_destroyed) {
    // update collision data structure
    if(this.x != old_x || this.y != old_y || was_destroyed != this.is_destroyed()) {
        if(old_x != -1 && old_y != -1 && !was_destroyed) {
            // unblock old location
            this.block_map_at(old_x, old_y, -1);
        }
        // block new location
        if(!this.is_destroyed()) {
            this.block_map(1);
        }
    }
};

/** Return true if this object overlays any grid cell along a list of cells
    @param {Array.<Array.<number>>} path
    @return {boolean} */
MapBlockingGameObject.prototype.covers_any_of = function(path) {
    var bounds = get_grid_bounds([this.x,this.y], this.spec['unit_collision_gridsize']);
    return goog.array.some(path, function(xy) {
        return (xy[0] >= bounds[0][0] && xy[0] < bounds[0][1] &&
                xy[1] >= bounds[1][0] && xy[1] < bounds[1][1]);
    });
};

MapBlockingGameObject.prototype.block_map_at = function(x,y,incr) {
    if(this.spec['unit_collision_gridsize'][0] <= 0) {
        return;
    }
    var bounds = get_grid_bounds([x,y], this.spec['unit_collision_gridsize']);
    astar_map.block_map([bounds[0][0], bounds[1][0]], [bounds[0][1]-bounds[0][0], bounds[1][1]-bounds[1][0]], incr);
    invalidate_unit_paths();
    invalidate_all_threatlists();
};
MapBlockingGameObject.prototype.block_map = function(incr) {
    this.block_map_at(this.x, this.y, incr);
};
/** @override */
MapBlockingGameObject.prototype.hit_radius = function() {
    // approximation - multiply by sqrt(2) for the diagonal
    var rad = 1.414 * 0.5 * Math.max(this.spec['unit_collision_gridsize'][0],
                                     this.spec['unit_collision_gridsize'][1]);
    rad *= gamedata['map']['building_hitbox_scale'];
    return rad;
};

// as a special case, destroyed map objects are pushed backwards in Z order
MapBlockingGameObject.prototype.calc_draw_pos = function() {
    // in space, drop buildings downward
    var flat = (this.is_building() && session.viewing_base.base_climate_data['fly_at_ground_level']);

    if(!this.is_destroyed() && !flat) {
        return goog.base(this, 'calc_draw_pos');
    }

    var p = [this.x - this.spec['unit_collision_gridsize'][0]/2,
             this.y - this.spec['unit_collision_gridsize'][1]/2];
    var depth = ortho_to_depth(p);
    return [[this.x, this.y], depth];
};

/**
 * @constructor
 * @extends MapBlockingGameObject
 */
function Inert() {
    goog.base(this);
    this.metadata = null;
    // true if we sent a collect action and are waiting to hear back from server
    this.collect_sent = false;
}
goog.inherits(Inert, MapBlockingGameObject);
Inert.prototype.receive_state = function(data, init, is_deploying) {
    goog.base(this, 'receive_state', data, init, is_deploying);
    this.metadata = data.shift();
};
// as a special case, "flat" inert objects are pushed backwards in Z order
Inert.prototype.calc_draw_pos = function() {
    if(this.spec['draw_flat']) {
        // use depth of the far northwest corner rather than the center
        var p = [this.x - this.spec['gridsize'][0]/2,
                 this.y - this.spec['gridsize'][1]/2];
        var depth = ortho_to_depth(p);
        // add bias to Z depth calc for layering
        var depth_bias = ('depth_bias' in this.spec ? this.spec['depth_bias'] : (this.spec['auto_spawn'] ? -1 : 0));
        depth += 1000*depth_bias;
        return [[this.x, this.y], depth];
    } else {
        return goog.base(this, 'calc_draw_pos');
    }
};

/**
 * @constructor
 * @extends MapBlockingGameObject
 */
function Building() {
    goog.base(this);
    this.repair_finish_time = -1;
    this.disarmed = false;

    this.build_total_time = -1;
    this.build_start_time = -1;
    this.build_done_time = -1;

    this.upgrade_total_time = -1;
    this.upgrade_start_time = -1;
    this.upgrade_done_time = -1;

    this.research_item = '';
    this.research_total_time = -1;
    this.research_start_time = -1;
    this.research_done_time = -1;

    this.produce_start_time = -1;
    this.produce_rate = -1;
    this.contents = 0;
    this.manuf_queue = [];
    this.manuf_start_time = -1;
    this.manuf_done_time = -1;

    this.modstats = {};

    // true if we sent a state ping and are waiting to hear back from server
    this.ping_sent = false;
    this.equip_pending = false; // true if we are waiting to hear back from the server on an equip request XXX use sync_marker
    this.sync_marker = Synchronizer.INIT; // for holding the UI until server catches up to a specific request
    this.client_predictions = null; // client-side predicted manuf_queue, only non-null if out of sync

    // dictionary of data about the object who killed us - used to track between the actual kill and the transmission of the combat update
    // note that this is data is queried from the attacker and "frozen" at the moment of the kill to avoid race conditions
    this.killer_info = null;

    this.harvest_glow_time = -1; // graphical effect only

    this.idle_state_cache = null; // for GUI display only - cache result of get_idle_state()
    this.idle_state_cache_valid_until = -1;
}
goog.inherits(Building, MapBlockingGameObject);

Building.prototype.request_sync = function() { this.sync_marker = synchronizer.request_sync(); return this.sync_marker; };
Building.prototype.is_in_sync = function() { return synchronizer.is_in_sync(this.sync_marker); };

Building.prototype.start_client_prediction = function(field, original) {
    this.request_sync();
    if(!this.client_predictions) { this.client_predictions = {}; }
    if(!(field in this.client_predictions)) {
        this.client_predictions[field] = original.slice(0); // XXX needs help for non-arrays
    }
    return this.client_predictions[field];
};
Building.prototype.get_client_prediction = function(field, original) {
    if(this.is_in_sync()) {
        this.client_predictions = null;
    } else if(this.client_predictions && (field in this.client_predictions)) {
        return this.client_predictions[field];
    }
    return original;
};

Building.update_modstats = function(team, update) {
    goog.object.forEach(session.cur_objects.objects, function(obj, id) {
        if(obj.is_building() && obj.team == team) {
            obj.modstats = (obj.id in update ? update[obj.id] : {});

            if(obj.is_minefield() || obj.is_emplacement()) {
                // initialize AI state
                obj.ai_state = (obj.is_shooter() ? ai_states.AI_ATTACK_ANY : ai_states.AI_STOP);
            }
        }
    });
};

Building.prototype.get_stat = function(stat, default_value) {
    return ModChain.get_stat(this.modstats[stat]||null, default_value);
};

Building.prototype.get_auto_spell = function() {
    if(('spells' in this.spec) && (this.spec['spells'].length > 0)) {
        var spellname = this.get_stat('weapon', this.spec['spells'][0]);
        if(spellname) {
            var auto_spell = gamedata['spells'][spellname];
            if(auto_spell['activation'] === 'auto') {
                return auto_spell;
            }
        }
    }
    return null;
};
Building.prototype.get_auto_spell_level = function() {
    return this.get_stat('weapon_level', this.level);
};

Building.prototype.receive_state = function(data, init, is_deploying) {
    var old_level = this.level;
    var old_manuf_queue = this.manuf_queue;
    var old_build_start = this.build_start_time;
    var was_under_construction = this.is_under_construction();

    goog.base(this, 'receive_state', data, init, is_deploying);

    var old_repair_time = this.repair_finish_time;
    this.repair_finish_time = data.shift();
    this.build_total_time = data.shift();
    this.build_start_time = data.shift();
    this.build_done_time = data.shift();
    this.upgrade_total_time = data.shift();
    this.upgrade_start_time = data.shift();
    this.upgrade_done_time = data.shift();
    this.research_item = data.shift();
    this.research_total_time = data.shift();
    this.research_start_time = data.shift();
    this.research_done_time = data.shift();
    this.produce_start_time = data.shift();
    this.produce_rate = data.shift();
    this.contents = data.shift();
    this.manuf_queue = data.shift();
    this.manuf_start_time = data.shift();
    this.manuf_done_time = data.shift();
    this.disarmed = data.shift();
    this.crafting = data.shift();
    this.config = data.shift();

    session.clear_building_idle_state_caches(); // for ALL buildings

    if(player.tutorial_state === 'wait_for_repairs') {
        if(old_repair_time > 0 && this.repair_finish_time < 0) {
            advance_tutorial();
        }
    }

    if((player.tutorial_state === 'defensive_cannon_complete' ||
        player.tutorial_state === 'speedup_open_context_menu' ||
        player.tutorial_state === 'speedup_open_speedup_menu' ||
        player.tutorial_state === 'speedup_click_finish') && old_build_start > 0 && this.build_start_time < 0) {
        // skip the speedup tutorial steps
        if(player.tutorial_state != 'defensive_cannon_complete') {
            metric_event(gamedata['tutorial']['defensive_cannon_complete']['metric'], {});
        }
        player.tutorial_state = 'defensive_cannon_complete';
        advance_tutorial();
    }

    // invoke building upgrade congrats
    if(((old_level != -1 && this.level > old_level) ||
        was_under_construction && !this.is_under_construction()) &&
        this.team == 'player') {

        var congrats_func = (function (_spec_name, _level) { return function() {
            invoke_building_upgrade_congrats(_spec_name, _level);
        }; })(this.spec['name'], this.level);

        if(!player.is_cheater) {
            // trigger visual effect
            var fx_data = ('upgrade_finish_effect' in this.spec ?
                           this.spec['upgrade_finish_effect'] :
                           gamedata['client']['vfx']['building_upgrade_finish']);
            if(fx_data) {
                SPFX.add_visual_effect([this.x,this.y], 0, [0,1,0], client_time, fx_data,
                                       !this.spec['worth_less_xp'], // no sound for barrier upgrades
                                       { '%OBJECT_SPRITE': this.get_leveled_quantity(this.spec['art_asset'])});
            }
            // hold notification until animation finishes
            notification_queue.hold_until(client_time + 2.9);
        }

        if(player.tutorial_state == "COMPLETE") {
            notification_queue.push(congrats_func);
        }
    }
};
Building.prototype.is_turret = function() { return this.spec['history_category'] === 'turrets'; };
Building.prototype.is_emplacement = function() { return this.spec['equip_slots'] && ('turret_head' in this.spec['equip_slots']); };
// return the name of the turret head item equipped here, if any, otherwise null
Building.prototype.turret_head_item = function() {
    if(this.equipment && this.equipment['turret_head'] && this.equipment['turret_head'].length > 0) {
        return this.equipment['turret_head'][0];
    }
    return null;
};
// return name of turret head item currently being crafted (assumes is_crafting() is true)
Building.prototype.turret_head_inprogress_item = function() {
    var craft_queue = this.get_crafting_queue();
    if(craft_queue.length > 0) {
        return gamedata['crafting']['recipes'][craft_queue[0]['craft']['recipe']]['product'][0]['spec'];
    }
    return null;
};
Building.prototype.is_minefield = function() { return this.spec['equip_slots'] && ('mine' in this.spec['equip_slots']); };
Building.prototype.is_minefield_armed = function() { return (this.equipment && this.equipment['mine'] && this.equipment['mine'].length > 0); };
// returns the name of mine item associated with this minefield, if any, otherwise null
Building.prototype.minefield_item = function() {
    if(this.equipment && this.equipment['mine'] && this.equipment['mine'].length > 0) {
        return this.equipment['mine'][0];
    } else if(this.config && this.config['mine'] && this.config['mine'].length > 0) {
        return (typeof(this.config['mine']) === 'string' ? this.config['mine'] : this.config['mine'][0]);
    }
    return null;
};

Building.prototype.is_producer = function() {
    return ('production_capacity' in this.spec);
};

/** Return the name of the resource this building produces
    @return {string|null} */
Building.prototype.produces_res = function() {
    if('production_capacity' in this.spec) {
        for(var res in gamedata['resources']) {
            if(('produces_'+res) in this.spec) {
                return res;
            }
        }
    }
    return null;
};

Building.prototype.get_production_capacity = function() {
    var cap = this.get_leveled_quantity(this.spec['production_capacity']);
    //cap = Math.floor(cap * player.get_abtest_value('T001_harvester_cap', 'modifier', 1));
    return cap;
};
Building.prototype.is_storage = function() {
    for(var res in gamedata['resources']) {
        if(('storage_'+res) in this.spec) {
            return true;
        }
    }
    return false;
};
Building.prototype.is_factory = function() {
    return (this.spec['spells'].indexOf("MAKE_DROIDS") != -1);
};
Building.prototype.is_researcher = function() {
    return (this.spec['spells'].indexOf("RESEARCH_FOR_FREE") != -1);
};
Building.prototype.is_crafter = function() {
    return (this.spec['spells'].indexOf("CRAFT_FOR_FREE") != -1);
};
Building.prototype.is_manufacturer = function() {
    return (this.spec['spells'].indexOf("MAKE_DROIDS") != -1);
};
Building.prototype.is_lottery_building = function() {
    return (this.spec['spells'].indexOf("LOTTERY_SCAN") != -1);
};
Building.prototype.is_warehouse = function() {
    return ('provides_inventory' in this.spec);
};
Building.prototype.is_repairing = function() {
    return (this.repair_finish_time > 0);
};
Building.prototype.is_under_construction = function() {
    return (this.build_total_time > 0);
};
Building.prototype.is_upgrading = function() {
    return (this.upgrade_total_time > 0);
};
Building.prototype.is_researching = function() {
    return !!(this.research_item);
};
Building.prototype.get_crafting_queue = function() {
    return this.get_client_prediction('crafting.queue', this.crafting ? this.crafting['queue'] : []);
};
Building.prototype.is_crafting = function() { // return current recipe name or null if not crafting
    var craft_queue = this.get_crafting_queue();
    if(craft_queue && craft_queue.length > 0) {
        return craft_queue[0]['craft']['recipe'];
    }
    return false;
};
Building.prototype.is_manufacturing = function() {
    return (this.manuf_queue.length > 0);
};
Building.prototype.manuf_total_time = function() {
    var tot = 0;
    for(var i = 0; i < this.manuf_queue.length; i++) {
        tot += this.manuf_queue[i]['total_time'];
    }
    return tot;
};

Building.prototype.is_using_foreman = function() {
    if(this.is_under_construction() || this.is_upgrading()) { return true; }
    if(this.is_crafting()) {
        var craft_queue = this.get_crafting_queue();
        for(var i = 0; i < craft_queue.length; i++) {
            if(gamedata['crafting']['categories'][gamedata['crafting']['recipes'][craft_queue[0]['craft']['recipe']]['crafting_category']]['foreman']) {
                return true;
            }
        }
    }
    return false;
};

Building.prototype.time_until_finish = function() {
    if(this.is_repairing()) {
        return this.repair_finish_time - server_time;
    } else if(this.is_upgrading()) {
        if(this.upgrade_start_time <= 0) { throw Error('invalid state: upgrade halted'); }
        return this.upgrade_total_time - (server_time - this.upgrade_start_time) - this.upgrade_done_time;
    } else if(this.is_under_construction()) {
        if(this.build_start_time <= 0) { throw Error('invalid state: construct halted'); }
        return this.build_total_time - (server_time - this.build_start_time) - this.build_done_time;
    } else if(this.is_researching()) {
        if(this.research_start_time <= 0) { throw Error('invalid state: research halted'); }
        return this.research_total_time - (server_time - this.research_start_time) - this.research_done_time;
    } else if(this.is_crafting()) {
        var craft_queue = this.get_crafting_queue();
        if(craft_queue[0]['start_time'] <= 0) { throw Error('invalid state: crafting halted'); }
        var last = craft_queue[craft_queue.length-1];
        return last['start_time'] + last['total_time'] - last['done_time'] - server_time;
    } else if(this.is_manufacturing()) {
        if(this.manuf_start_time <= 0) { throw Error('invalid state: manufacturing halted'); }
        return this.manuf_total_time() - (server_time - this.manuf_start_time) - this.manuf_done_time;
    } else {
        return -1;
    }
};

Building.prototype.activity_speedup_kind = function() {
    if(this.is_repairing()) {
        return 'building_repair';
    } else if(this.is_upgrading() || this.is_under_construction()) {
        return 'building_upgrade';
    } else if(this.is_researching()) {
        return 'tech_research';
    } else if(this.is_manufacturing()) {
        return 'unit_manufacture';
    } else if(this.is_crafting()) {
        return 'crafting';
    } else {
        return null;
    }
};


Building.prototype.is_busy = function() {
    return this.is_repairing() || this.is_upgrading() || this.is_under_construction() || this.is_researching() || this.is_manufacturing() || this.is_crafting();
};

Building.prototype.research_time_left = function() {
    var ret = this.research_total_time - this.research_done_time;
    if(this.research_start_time > 0) {
        ret -= (server_time - this.research_start_time);
    }
    return ret;
};
Building.prototype.research_progress = function() {
    return (this.research_done_time + (this.research_start_time > 0 ? (server_time - this.research_start_time) : 0))/this.research_total_time;
};

Building.prototype.crafting_time_left_all = function() {
    var ret = 0;
    goog.array.forEach(this.get_crafting_queue(), function(bus) {
        ret += bus['total_time'] - bus['done_time'];
        if(bus['start_time'] > 0) {
            ret -= Math.max(0, server_time - bus['start_time']);
        }
    });
    return ret;
};

// return time left on currently in-progress recipe
// if there are finished recipes to collect, but none in progress, return -1
Building.prototype.crafting_time_left_one = function() {
    var craft_queue = this.get_crafting_queue();
    for(var i = 0; i < craft_queue.length; i++) {
        var bus = craft_queue[i];
        var ret = bus['total_time'] - bus['done_time'];
        var cat = gamedata['crafting']['categories'][gamedata['crafting']['recipes'][bus['craft']['recipe']]['crafting_category']];
        if(bus['start_time'] > 0) {
            ret -= Math.max(0, server_time - bus['start_time']);
        }
        if(ret <= 0 && ('auto_collect' in cat) && !cat['auto_collect']) {
            continue; // done; skip
        }
        return ret;
    }
    return -1; // nothing going on
};
Building.prototype.crafting_progress_all = function() {
    var total = this.crafting_time_left_all();
    if(total > 0) {
        var done = 0;
        goog.array.forEach(this.get_crafting_queue(), function(bus) {
            done += bus['done_time'] + (bus['start_time'] > 0 && bus['start_time'] < server_time ? (server_time - bus['start_time']) : 0);
        });
        return done / total;
    } else {
        return 1;
    }
};

// progress on earliest entry in queue
// NOT counting any entries that are already finished pending collection
// if everything in the queue is finished pending collection, return -1
Building.prototype.crafting_progress_one = function() {
    var queue = this.get_crafting_queue();
    for(var i = 0; i < queue.length; i++) {
        var bus = queue[i];
        var cat = gamedata['crafting']['categories'][gamedata['crafting']['recipes'][bus['craft']['recipe']]['crafting_category']];
        var prog = (bus['done_time'] + (bus['start_time'] > 0 ? (server_time - bus['start_time']) : 0))/bus['total_time'];
        if(prog >= 1 && ('auto_collect' in cat) && !cat['auto_collect']) {
            continue; // SKIP non-auto-collect entries
        }
        return prog;
    }
    // non-auto-collect entry is pending, but there is no further work
    return -1;
};

Building.prototype.build_time_left = function() {
    var ret = this.build_total_time - this.build_done_time;
    if(this.build_start_time > 0) {
        ret -= (server_time - this.build_start_time);
    }
    return ret;
};
Building.prototype.build_progress = function() {
    return (this.build_done_time + (this.build_start_time > 0 ? (server_time - this.build_start_time) : 0))/this.build_total_time;
};

Building.prototype.upgrade_time_left = function() {
    var ret = this.upgrade_total_time - this.upgrade_done_time;
    if(this.upgrade_start_time > 0) {
        ret -= (server_time - this.upgrade_start_time);
    }
    return ret;
};
Building.prototype.upgrade_progress = function() {
    return (this.upgrade_done_time + (this.upgrade_start_time > 0 ? (server_time - this.upgrade_start_time) : 0))/this.upgrade_total_time;
};

Building.prototype.manuf_time_left = function() {
    var ret = this.manuf_total_time() - this.manuf_done_time;
    if(this.manuf_start_time > 0) {
        ret -= (server_time - this.manuf_start_time);
    }
    return ret;
};

Building.prototype.manuf_time_left_one = function() {
    var ret = this.manuf_queue[0]['total_time'] - this.manuf_done_time;
    if(this.manuf_start_time > 0) {
        ret -= (server_time - this.manuf_start_time);
    }
    return ret;
};
// % completion of FIRST unit in queue
Building.prototype.manuf_progress_one = function() {
    if(this.manuf_queue[0]['total_time'] <= 0) { return 1; }
    return (this.manuf_done_time + (this.manuf_start_time > 0 ? (server_time - this.manuf_start_time) : 0))/this.manuf_queue[0]['total_time'];
};

// estimate the current contents of a producer building based on last server-provided data
// this is only used for GUI purposes. Note: returns continuous float, not quantized!
Building.prototype.interpolate_contents = function() {
    if(this.produce_start_time < 0) {
        // building is idle
        return this.contents;
    }

    var estimate = this.contents + this.produce_rate * (server_time - this.produce_start_time)/(60*60);
    estimate = Math.max(0, Math.min(estimate, this.get_production_capacity()));
    return estimate;
};

Building.prototype.combat_power_factor = function() {
    if(gamedata['enable_power']) {
        var powerfac = session.viewing_base.power_factor();
        if(powerfac < 1) {
            var min_fac = gamedata['minimum_combat_power_factor'];
            return min_fac + (1-min_fac)*powerfac;
        }
    }
    return 1;
};

// these functions are for client-side prediction only - server will override true state with next OBJECT_STATE_UPDATE
Building.prototype.update_research = function(undamaged_time) {
    if(!this.research_item) { return; }
    if(this.repair_finish_time > 0 || this.is_damaged()) { return; }
    if(this.research_start_time > 0) { return; }
    if(undamaged_time >= 0) {
        this.research_done_time += server_time - undamaged_time;
    }
    this.research_start_time = server_time;
};

function _update_crafting(queue, undamaged_time) {
    var delay = 0;
    goog.array.forEach(queue, function(bus) {
        var old_done_time = bus['done_time'];
        if(bus['start_time'] < 0) {
            if(undamaged_time >= 0) {
                if('creation_time' in bus && bus['creation_time'] >= 0) { undamaged_time = Math.max(undamaged_time, bus['creation_time']); }
                bus['done_time'] += Math.max(0, Math.min(server_time - undamaged_time - delay, bus['total_time'] - bus['done_time']));
            }
            bus['start_time'] = server_time + delay;
        }
        delay = bus['total_time'] - bus['done_time']; // delay start of next action in queue by remaining time on preceding action
        if(undamaged_time >= 0) {
            undamaged_time += bus['done_time'] = old_done_time; // un-credit next action for progress accured to preceding action
        }
    });
}

Building.prototype.update_crafting = function(undamaged_time) {
    if(!this.is_crafting()) { return; }
    var craft_queue = this.get_crafting_queue();
    if(this.repair_finish_time > 0 || this.is_damaged()) {
        var cat = gamedata['crafting']['categories'][gamedata['crafting']['recipes'][craft_queue[0]['craft']['recipe']]['crafting_category']];
        if(('haltable' in cat) && !cat['haltable']) {
            // not haltable
        } else {
            return; // halted
        }
    }
    return _update_crafting(craft_queue, undamaged_time);
};

Building.prototype.update_build = function(undamaged_time) {
    if(this.build_total_time < 0) { return; }
    if(this.repair_finish_time > 0 || this.is_damaged()) { return; }
    if(this.build_start_time > 0) { return; }
    if(undamaged_time >= 0) {
        this.build_done_time += server_time - undamaged_time;
    }
    this.build_start_time = server_time;
};

Building.prototype.update_manuf = function(undamaged_time) {
    if(this.manuf_queue.length < 1) { return; }
    if(this.repair_finish_time > 0 || this.is_damaged()) { return; }
    if(this.manuf_start_time > 0) { return; }
    if(undamaged_time >= 0) {
        this.manuf_done_time += server_time - undamaged_time;
    }
    this.manuf_start_time = server_time;
};

Building.prototype.update_upgrade = function(undamaged_time) {
    if(this.upgrade_total_time < 0) { return; }
    if(this.repair_finish_time > 0 || this.is_damaged()) { return; }
    if(this.upgrade_start_time > 0) { return; }
    if(undamaged_time >= 0) {
        this.upgrade_done_time += server_time - undamaged_time;
    }
    this.upgrade_start_time = server_time;
};

Building.prototype.update_all_actions = function(undamaged_time) {
    this.update_research(undamaged_time);
    this.update_upgrade(undamaged_time);
    this.update_build(undamaged_time);
    this.update_manuf(undamaged_time);
    this.update_crafting(undamaged_time);
};

Building.prototype.modify_stats_by_modstats = function() {
    this.modify_stats_by_modstats_table(this.modstats);
};

// return true if the object should be invisible to opponents
Building.prototype.is_invisible = function() { return !!this.spec['invisible']; };

// ObjectCollection

// note: unlike in the server (where ObjectCollection assigns id numbers), in the client we assume
// that incoming objects added to the collection already have their id fields set (usually by receive_state()).

// We manually set ids of deleted objects to -1 so that any other reference-holders can know that the
// object isn't valid anymore.

/** @constructor */
function ObjectCollection() {
    this.objects = {};
}
ObjectCollection.prototype.add_object = function(obj) { this.objects[obj.id] = obj; };
ObjectCollection.prototype.has_object = function(id) { return (id in this.objects); };
ObjectCollection.prototype.get_object = function(id) { return this.objects[id]; };
ObjectCollection.prototype.rem_object = function(obj) {
    delete this.objects[obj.id];
    obj.id = GameObject.DEAD_ID;
};
ObjectCollection.prototype.clear = function() {
    for(var id in this.objects) {
        this.objects[id].id = GameObject.DEAD_ID;
    }
    this.objects = {};
};


// Base
// this is going to start becoming more parallel to the Base class in gameserver
/** @constructor */
function Base(id) {
    this.base_id = id;
    this.base_landlord_id = -1;
    this.base_size = 0;
    this.base_ncells = null;
    this.base_climate = null;
    this.base_climate_data = {};
    this.base_map_loc = null;
    this.base_expire_time = -1;
    this.base_last_attack_time = -1;
    this.base_ui_name = 'Unknown';
    this.base_type = null;
    this.deployment_buffer = 1;

    this.power_state = [0,0]; // power [produced,consumed]
    this.power_factor_cache = 0; // must be reset when power_state changes
}

Base.prototype.ncells = function() {
    if(this.base_ncells !== null) { return this.base_ncells; }
    return gamedata['map']['default_ncells'];
};

Base.prototype.midcell = function() {
    return vec_floor(vec_scale(0.5, this.ncells()));
};

function compute_power_factor(power) {
    if(power[1] <= power[0]) {
        return 1;
    } else {
        return power[0]/(1.0*power[1]);
    }
}

Base.prototype.update_power_state = function(newstate) {
    this.power_state = newstate;
    this.power_factor_cache = compute_power_factor(this.power_state);
};

Base.prototype.power_factor = function() { return this.power_factor_cache; };

Base.prototype.get_base_radius = function() {
    var size = this.base_size;
    if(size < 0 || size > gamedata['map']['base_perimeter'].length) {
        throw Error('invalid base_size '+size);
    }
    return Math.floor(gamedata['map']['base_perimeter'][size]/2);
};

Base.prototype.has_deployment_zone = function() {
    return (this.deployment_buffer && typeof(this.deployment_buffer) != 'boolean' && typeof(this.deployment_buffer) != 'number');
};

Base.prototype.deployment_zone_centroid = function() {
    if(!this.has_deployment_zone()) { return null; }
    if(this.deployment_buffer['type'] != 'polygon') { throw Error('unhandled deployment buffer type'+this.deployment_buffer['type'].toString()); }
    var centroid = [0,0];
    for(var i = 0; i < this.deployment_buffer['vertices'].length; i++) {
        centroid = vec_add(centroid, this.deployment_buffer['vertices'][i]);
    }
    centroid = vec_scale(1.0/this.deployment_buffer['vertices'].length, centroid);
    return centroid;
};

// returns whether combat units can be deployed (by the player) at this location
Base.prototype.is_deployment_location_valid = function(xy) {
    var ncells = this.ncells();

    // check against play area bounds
    if(xy[0] < 0 || xy[0] >= ncells[0] || xy[1] < 0 || xy[1] >= ncells[1]) {
        return false;
    }

    if(this.base_landlord_id === session.user_id) {
        return true; // landlord can deploy anywhere
    }

    // check against base perimeter or deployment zone
    if(this.has_deployment_zone()) {
        // Gangnam style
        if(this.deployment_buffer['type'] != 'polygon') { throw Error('unhandled deployment buffer type'+this.deployment_buffer['type'].toString()); }
        // point-in-polygon test via winding order
        var sign = 0;
        for(var i = 0; i < this.deployment_buffer['vertices'].length; i++) {
            var iend = ((i+1) % this.deployment_buffer['vertices'].length);
            var start = this.deployment_buffer['vertices'][i];
            var end = this.deployment_buffer['vertices'][iend];
            var seg = vec_sub(end, start);
            var point = vec_sub(xy, start);
            var k = seg[0]*point[1] - seg[1]*point[0];
            var sign_k = (k >= 0 ? 1 : -1);
            if(sign == 0) {
                sign = sign_k;
            } else if(sign_k != sign) {
                return false;
            }
        }
    } else if(gamedata['map']['deployment_buffer'] >= 0) {
        // old style
        var mid = this.midcell();
        var rad = [this.get_base_radius(), this.get_base_radius()];

        if(this.deployment_buffer) { rad[0] += gamedata['map']['deployment_buffer']; rad[1] += gamedata['map']['deployment_buffer']; }
        rad[0] += Math.max(0, (ncells[0] - gamedata['map']['default_ncells'][0])/2);
        rad[1] += Math.max(0, (ncells[1] - gamedata['map']['default_ncells'][1])/2);
        if(xy[0] >= mid[0]-rad[0] && xy[0] <= mid[0]+rad[0] && xy[1] >= mid[1]-rad[1] && xy[1] <= mid[1]+rad[1]) {
            return false;
        }
    }

    // check against blockage from buildings
    if(astar_map.is_blocked(vec_floor(xy))) {
        return false;
    }

    // check building deployment buffer
    if((gamedata['map']['building_deployment_buffer']||0) > 0) {
        var buf = gamedata['map']['building_deployment_buffer'];
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.is_building() && obj.team != 'player') {
                var hisbound = get_grid_bounds([obj.x,obj.y], obj.spec['gridsize']);
                if(xy[0] >= hisbound[0][0]-buf && xy[0] < hisbound[0][1]+buf &&
                   xy[1] >= hisbound[1][0]-buf && xy[1] < hisbound[1][1]+buf) {
                    return false;
                }
            }
        }
    }
    return true;
};

Base.prototype.draw_deployable_area = function() {
    return this.draw_base_perimeter('deploy');
};

// stroke a path outlining the base area perimeter
// optionally shade either the inside or outside to indicate invalid locations
Base.prototype.draw_base_perimeter = function(purpose) {
    var shade_inside = ((purpose === 'deploy' && (this.base_landlord_id !== session.user_id) && gamedata['map']['deployment_buffer'] >= 0) || purpose === 'dev_edit');
    var shade_outside = (purpose === 'build');
    var shade_offmap = (purpose !== 'dev_edit');

    var ncells = this.ncells();
    var mid = this.midcell();
    var rad = [this.get_base_radius(), this.get_base_radius()];
    var old_deployment_buffer = (!!this.deployment_buffer && !this.has_deployment_zone());
    var new_deployment_buffer = this.has_deployment_zone();

    if(purpose === 'deploy' && old_deployment_buffer) {
        if(gamedata['map']['deployment_buffer'] >= 0) {
            rad[0] += gamedata['map']['deployment_buffer'];
            rad[1] += gamedata['map']['deployment_buffer'];
        }
        rad[0] += Math.max(0, (ncells[0] - gamedata['map']['default_ncells'][0])/2);
        rad[1] += Math.max(0, (ncells[1] - gamedata['map']['default_ncells'][1])/2);
    }

    // vertices of base perimeter
    var v = [ortho_to_draw([mid[0]-rad[0], mid[1]-rad[1]]),
             ortho_to_draw([mid[0]+rad[0], mid[1]-rad[1]]),
             ortho_to_draw([mid[0]+rad[0], mid[1]+rad[1]]),
             ortho_to_draw([mid[0]-rad[0], mid[1]+rad[1]])];

    SPUI.ctx.save();
    SPUI.ctx.strokeStyle = '#FFFFFF';
    SPUI.ctx.fillStyle = 'rgba(255,0,0,0.25)';

    if(shade_inside) {
        if(new_deployment_buffer) {
            // Gangnam style
            if(this.deployment_buffer['type'] != 'polygon') { throw Error('unhandled deployment buffer type'+this.deployment_buffer['type'].toString()); }
            SPUI.ctx.beginPath();
            // vertices of entire play area
            var outer = [ortho_to_draw([0, 0]),
                         ortho_to_draw([ncells[0], 0]),
                         ortho_to_draw([ncells[0], ncells[1]]),
                         ortho_to_draw([0, ncells[1]])];
            for(var i = 0; i < outer.length+1; i++) {
                var vtx = outer[(i==outer.length ? 0 : i)];
                if(i == 0) {
                    SPUI.ctx.moveTo(vtx[0], vtx[1]);
                } else {
                    SPUI.ctx.lineTo(vtx[0], vtx[1]);
                }
            }

            // add the deployment zone as a subpath with reverse winding order to make a "hole"
            SPUI.ctx.closePath();
            for(var i = 0; i < this.deployment_buffer['vertices'].length+1; i++) {
                var vtx = this.deployment_buffer['vertices'][(i==this.deployment_buffer['vertices'].length ? this.deployment_buffer['vertices'].length - 1 : this.deployment_buffer['vertices'].length - i - 1)];
                var loc = ortho_to_draw(vtx);
                if(i == 0) {
                    SPUI.ctx.moveTo(loc[0], loc[1]);
                } else {
                    SPUI.ctx.lineTo(loc[0], loc[1]);
                }
            }
            if(purpose !== 'dev_edit') { SPUI.ctx.fill(); }
            SPUI.ctx.stroke();
        } else {
            shade_quad(v);
        }
    }

    if(shade_outside) {
        // all across the top
        shade_quad([ortho_to_draw([0,0]), ortho_to_draw([ncells[0], 0]), ortho_to_draw([ncells[0], mid[1]-rad[1]]), ortho_to_draw([0, mid[1]-rad[1]])]);
        // left side
        shade_quad([ortho_to_draw([0,mid[1]-rad[1]]), ortho_to_draw([mid[0]-rad[0], mid[1]-rad[1]]), ortho_to_draw([mid[0]-rad[0], mid[1]+rad[1]]), ortho_to_draw([0, mid[1]+rad[1]])]);
        // right side
        shade_quad([ortho_to_draw([mid[0]+rad[0],mid[1]-rad[1]]), ortho_to_draw([ncells[0], mid[1]-rad[1]]), ortho_to_draw([ncells[0], mid[1]+rad[1]]), ortho_to_draw([mid[0]+rad[0], mid[1]+rad[1]])]);
        // all across the bottom
        shade_quad([ortho_to_draw([0,mid[1]+rad[1]]), ortho_to_draw([ncells[0], mid[1]+rad[1]]), ortho_to_draw([ncells[0], ncells[1]]), ortho_to_draw([0, ncells[1]])]);
    }

    if(0 && shade_offmap) { // XXX this is broken in view_is_zoomed case
        var top = ortho_to_draw([0,0]), right = ortho_to_draw([ncells[0], 0]), bottom = ortho_to_draw([ncells[0], ncells[1]]), left = ortho_to_draw([0, ncells[1]]);
        // bar across the top
        if(top[1] > 0) { shade_quad([[0,0], [canvas_width,0], [canvas_width, top[1]], [0, top[1]]]); }
        // upper-left quad
        shade_quad([[0,top[1]], top, left, [0,left[1]]]);
        // lower-left quad
        shade_quad([[0,left[1]], left, bottom, [0,bottom[1]]]);
        // upper-right quad
        shade_quad([top, [canvas_width,top[1]], [canvas_width,right[1]], right]);
        // lower-right quad
        shade_quad([right, [canvas_width,right[1]], [canvas_width,bottom[1]], bottom]);
        // bar across the bottom
        if(bottom[1] < canvas_height) { shade_quad([[0,bottom[1]], [canvas_width,bottom[1]], [canvas_width,canvas_height], [0,canvas_height]]); }
    }

    // draw outline
    if(!new_deployment_buffer && purpose != 'build_ignore_perimeter' &&
       !(purpose == 'deploy' && gamedata['map']['deployment_buffer'] < 0)) {
        SPUI.ctx.beginPath();
        SPUI.ctx.moveTo(v[0][0], v[0][1]);
        SPUI.ctx.lineTo(v[1][0], v[1][1]);
        SPUI.ctx.lineTo(v[2][0], v[2][1]);
        SPUI.ctx.lineTo(v[3][0], v[3][1]);
        SPUI.ctx.lineTo(v[0][0], v[0][1]);
        SPUI.ctx.stroke();
    }

    SPUI.ctx.restore();
}

Base.prototype.has_climate_unit_restrictions = function() {
    if(this.base_climate_data['include_manufacture_categories'] ||
       this.base_climate_data['exclude_manufacture_categories'] ||
       this.base_climate_data['exclude_air_units'] ||
       this.base_climate_data['exclude_ground_units'] ||
       this.base_climate_data['include_units'] ||
       this.base_climate_data['exclude_units']) {
        return true;
    }
    return false;
};
Base.prototype.has_climate_restrictions = function() {
    return (this.has_climate_unit_restrictions() ||
            this.base_climate_data['applies_aura'] ||
            this.base_climate_data['exclude_missiles']);
};
Base.prototype.can_deploy_unit = function(spec) {
    if(('include_manufacture_categories' in this.base_climate_data)) {
        if(!goog.array.contains(this.base_climate_data['include_manufacture_categories'], spec['manufacture_category'])) { return false; }
    }
    if(('exclude_manufacture_categories' in this.base_climate_data)) {
        if(goog.array.contains(this.base_climate_data['exclude_manufacture_categories'], spec['manufacture_category'])) { return false; }
    }
    if(this.base_climate_data['exclude_air_units'] && spec['flying']) { return false; }
    if(this.base_climate_data['exclude_ground_units'] && !spec['flying']) { return false; }
    if('include_units' in this.base_climate_data) {
        if(!goog.array.contains(this.base_climate_data['include_units'], spec['name'])) { return false; }
    }
    if('exclude_units' in this.base_climate_data) {
        if(goog.array.contains(this.base_climate_data['exclude_units'], spec['name'])) { return false; }
    }
    return true;
};
Base.prototype.get_climate_unit_restrictions = function() {
    var data = this.base_climate_data;
    var strings = gamedata['strings']['climate_restrictions'];
    var ls = [];
    goog.array.forEach(['include_manufacture_categories','exclude_manufacture_categories'], function(kind) {
        if(kind in data) {
            var catlist = [];
            goog.array.forEach(data[kind], function(cat) {
                catlist.push(gamedata['strings']['manufacture_categories'][cat]['plural']);
            });
            ls.push(strings[kind].replace('%s', catlist.join(', ')));
        }
    });
    goog.array.forEach(['include_units','exclude_units'], function(kind) {
        if(kind in data) {
            var catlist = [];
            goog.array.forEach(data[kind], function(specname) {
                catlist.push(gamedata['units'][specname]['ui_name']);
            });
            ls.push(strings[kind].replace('%s', catlist.join(', ')));
        }
    });
    goog.array.forEach(['exclude_air_units','exclude_ground_units'], function(kind) {
        if(data[kind]) { ls.push(strings[kind]); }
    });
    return ls;
};
Base.prototype.describe_climate_restrictions = function() {
    var data = this.base_climate_data;
    var strings = gamedata['strings']['climate_restrictions'];
    var ls = this.get_climate_unit_restrictions();
     goog.array.forEach(['exclude_missiles'], function(kind) {
        if(data[kind]) { ls.push(strings[kind]); }
    });
    if('applies_aura' in data) {
        ls.push(gamedata['auras'][data['applies_aura']]['ui_description']);
    }
    return ls.join('. ');
};
Base.prototype.describe_climate_unit_restrictions = function() {
    return this.get_climate_unit_restrictions().join('. ');
};

// session state
var session = {};
session.connect_time = -1; // set to client_time upon receiving first SERVER_HELLO message
session.client_hello_packet = null; // keep our CLIENT_HELLO message in case we need to re-transmit it
session.server_hello_ended = false; // flag is set once we receive END_SERVER_HELLO

session.user_id = spin_user_id; // player's SpinPunch user ID
session.session_id = spin_session_id; // unique ID for this connection to the server
session.alliance_id = -1; // player's current alliance ID, <= 0 is invalid
session.alliance_membership = null; // player's current alliance membership info (alliance_members row), null for no membership
session.region = null; // world map region we are connected to
session.cur_objects = new ObjectCollection();
session.minefield_tags_by_obj_id = {}; // mapping from obj_id to tag of player minefield buildings, used for GUI purposes only
session.minefield_tags_by_tag = {}; // mapping from tag to obj_id
session.factory_tags_by_obj_id = {}; // GUI purposes only - identify unique factories (same as minefield tags above)
session.factory_tags_by_tag = {};
session.viewing_user_id = null; // SpinPunch user ID of the person whose base we are looking at
session.viewing_player_home_base_id = null; // base_id of home base for viewing_player
session.viewing_player_home_region = null; // home_region for viewing_player
session.viewing_base = null; // base we are looking at
session.viewing_ai = false; // whether we are viewing an AI player
session.viewing_friend = null; // reference to member of player.friends we are looking at (may be null for AI or non-friends)
session.ui_name = ''; // User-visible name of the person whose base we are looking at
session.home_base = 1; // true if we are looking at our own base
session.has_attacked = false; // true if there has been an attack in the current session
session.has_deployed = false; // true if there has been an attack AND player has deployed at least one unit
session.deploy_time = -1; // server_time at which has_deployed became 1
session.enable_combat_resource_bars = true; // used by the tutorial to hide combat resource bars (via ENABLE_COMBAT_RESOURCE_BARS consequent)
session.enable_dialog_completion_buttons = true; // used by the tutorial to disable completions button when player shouldn't press them (via ENABLE_DIALOG_COMPLETION consequent)
session.surrender_pending = false; // true if player has pressed Surrender and we are waiting for the session change
session.retreat_pending = -1; // client_time at which retreat will happen (between clicking "End Attack" and session change request)
session.no_more_units = false; // true if all of the player's units have been destroyed and we need to check the battle outcome next time the damage effect queue empties
session.attack_finish_time = -1; // server_time at which attack timer runs out
session.incoming_attack_time = -1; // server_time at which AI units will spawn
session.incoming_attack_wave_time = -1; // time at which next wave should be spawned
session.incoming_attack_wave_pending = false; // whether we sent next_ai_attack_wave yet
session.incoming_attack_units = []; // list of waves, where each wave is a map (specname->quantity) of AI units that will spawn
session.incoming_attack_direction = null; // key in gamedata/ai_attacks/directions
session.incoming_attacker_name = ''; // user-visible name of the attacking AI
session.incoming_attack_units_total = 0; // number of AI units involved in current attack
session.incoming_attack_units_destroyed = 0; // number of AI units destroyed during current attack (not counting secteams)
session.battle_outcome_sync_marker = Synchronizer.INIT; // synchronizer to make sure server is up to date before client tries to end battle
session.battle_outcome_dirty = false; // whether we need to check for win/loss - always update sync_marker when setting true
session.deployed_unit_space = 0; // how much "space" worth of units has been deployed into battle
session.weak_zombie_warned = false; // whether or not we have already shown the "you are about to deploy a zombie unit" warning
session.manufacture_overflow_warned = false; // whether we have already shown the "base defenders full, new units diverted to reserves" message
session.quarry_harvest_sync_marker = Synchronizer.INIT; // synchronizer used for showing Loading... while harvesting quarries
session.deployable_squads = [];
session.defending_squads = [];

/** @type {CombatEngine.CombatEngine|null} */
session.combat_engine = null;

// pre/post_deploy_units are dictionaries of "army_unit" structures, indexed by obj_id
// {'123456': {'obj_id': '123456', 'spec': 'asdf', 'level': 1},
//  'DONATED-1234': {'obj_id': 'DONATED-1234', 'source':'DONATED', 'spec': 'asdf', 'stack': 2}}
session.pre_deploy_units = {}; // units that are "loaded" into the cursor to be deployed
session.post_deploy_units = {}; // units that are already deployed

session.loot = {}; // exact copy of server's session.loot
session.last_loot = {}; // previous value of session.loot, for graphical ticker effect only
session.last_looted_uncapped = {}; // previous value of session.res_looter['looted_uncapped'], for graphical ticker effect only

session.res_looter = null; // raw JSON ResLooter state sent from server; drives client GUI display

session.pvp_balance = null; // which party is favored in PvP
session.ladder_state = null; // identical to session.ladder_state in server
session.home_warehouse_busy = false; // business state of warehouse upon session change
session.home_equip_items = []; // list of equipped items from home that we can use during combat
session.last_map_dialog_state = null; // stash state of map dialog when leaving home base, so we can come back to it

/** @type Citizens.Context */
session.citizens = null; // army units walking around the base
session.citizens_dirty = false;
session.lazy_update_citizens = function() { session.citizens_dirty = true; };
session.do_update_citizens = function() {
    if(session.citizens) {
        var data_list;
        if(session.citizens_dirty) { // need to tell Citizens about changes to army contents
            session.citizens_dirty = false;
            data_list = [];
            goog.object.forEach(player.my_army, function(obj) {
                if((obj['squad_id']||0) == SQUAD_IDS.BASE_DEFENDERS) {
                    data_list.push(new Citizens.UnitData(obj['obj_id'], obj['spec'], obj['level']||1, ('hp_ratio' in obj ? obj['hp_ratio'] : 1)));
                }
            });
        } else {
            data_list = null; // no update to army contents
        }
        session.citizens.update(data_list);
    }
};

session.viewing_lock_state = 0; // lock state of (foreign) base being viewed
session.viewing_isolate_pvp = 0; // isolate_pvp flag of base being viewed
session.repeat_attack_cooldown_expire = 0; // repeat attack cooldown expiration time of base being viewed

session.incoming_attack_pending = function() { return (session.incoming_attack_time > server_time); };
session.connected = function() { return session.connect_time > 0; };
session.is_remote_base = function() { return (session.viewing_player_home_base_id !== session.viewing_base.base_id); };
session.is_quarry = function() { return (session.viewing_base.base_type === 'quarry'); };
session.is_squad = function() { return (session.viewing_base.base_type === 'squad'); };
session.is_ladder_battle = function() { return !!session.ladder_state; };

session.is_in_alliance = function() { return (session.alliance_id > 0); };

session.get_my_alliance_role_info = function() {
    if(session.alliance_membership) {
        var info = AllianceCache.query_info_sync(session.alliance_membership['alliance_id']);
        if(info) {
            var my_role = session.alliance_membership['role'] || 0;
            return info['roles'][my_role.toString()];
        }
    }
    return null;
};
session.check_alliance_perm = function(want_perm) {
    var role_info = session.get_my_alliance_role_info();
    if(role_info) {
        return goog.array.contains(role_info['perms'], want_perm);
    }
    return false;
};

// returns true if using new map/squads deployment, instead of conventional deploy-your-base-defenders method
session.using_squad_deployment = function() {
    return (session.deployable_squads.length != 1 || session.deployable_squads[0] != SQUAD_IDS.BASE_DEFENDERS);
};

session.foreach_deployable_unit = function(func) {
    goog.object.forEach(player.my_army, function(obj) {
        // squad must be in deployable_squads
        if(!goog.array.contains(session.deployable_squads, (obj['squad_id']||0))) { return; }

        // check that the unit is not already deployed
        if(obj['obj_id'] in session.post_deploy_units) { return; }

        // check that the unit is not dead
        var curmax = army_unit_hp(obj);
        if(curmax[0] <= 0) { return; }

        // check that the unit satisfies climate restrictions
        var spec = gamedata['units'][obj['spec']];
        if(!session.viewing_base.can_deploy_unit(spec)) { return; }

        func(obj);
    });
};

// return number of deployable units (optionally, that satisfy filter_func)
/** @param {function(Object): boolean=} filter_func */
session.count_deployable_units = function(filter_func) {
    var count = 0;
    session.foreach_deployable_unit(function(obj) {
        if(filter_func && !filter_func(obj)) { return; }
        count += 1;
    });
    return count;
};
session.count_deployable_units_of_spec = function(specname) {
    return session.count_deployable_units(function(obj) { return (obj['spec'] === specname); });
};

// note: checking obj['source'] == 'donated' might make sense if we ever start considering donated units as part of space limits again

// count units of this type loaded into the deployment cursor
session.count_pre_deploy_units_of_spec = function(specname) {
    return goog.object.getCount(goog.object.filter(session.pre_deploy_units, function(obj) { return obj['spec'] == specname && obj['source'] !== 'donated'; }));
};

session.count_pre_deploy_donated_units = function() {
    return goog.object.getCount(goog.object.filter(session.pre_deploy_units, function(obj) { return obj['source'] === 'donated'; }));
};

// count units of this type that have been deployed on the battlefield
session.count_post_deploy_units_of_spec = function(specname) {
    return goog.object.getCount(goog.object.filter(session.post_deploy_units, function(obj) { return obj['spec'] == specname && obj['source'] !== 'donated'; }));
};
session.count_post_deploy_units = function() {
    return goog.object.getCount(goog.object.filter(session.post_deploy_units, function(obj) { return obj['source'] !== 'donated'; }));
};

// return [army_unit, zombie_status] representing next (healthiest undeployed) unit we can deploy of a certain spec
session.get_next_deployable_unit = function(specname) {
    var unit = null, highest_hp = -1, is_zombie = false;
    session.foreach_deployable_unit(function (obj) {
        if(obj['spec'] != specname) { return; }
        if(obj['obj_id'] in session.post_deploy_units ||
           obj['obj_id'] in session.pre_deploy_units) { return; }
        var obj_hp = army_unit_hp(obj)[0];
        if(obj_hp > highest_hp) {
            highest_hp = obj_hp;
            unit = obj;
        }
    });
    if(!unit) { throw Error('get_next_deployable_unit('+specname+') failed'); }
    if(unit && player.get_any_abtest_value('enable_zombie_debuff', gamedata['enable_zombie_debuff'])) {
        var curmax = army_unit_hp(unit);
        var ratio = curmax[0]/Math.max(curmax[1],1);
        if(ratio < gamedata['zombie_debuff_threshold']) { is_zombie = true; }
    }
    return [unit, is_zombie];
};

// return the army_unit of the weakest (non-donated) unit of this spec in pre-deploy, for canceling unit deployment one-by-one
session.get_weakest_pre_deploy_unit = function(specname) {
    var weakest = null, lowest_hp = Infinity;
    for(var obj_id in session.pre_deploy_units) {
        var obj = session.pre_deploy_units[obj_id];
        if(obj['spec'] == specname && obj['source'] !== 'donated') {
            var hp = army_unit_hp(obj)[0];
            if(hp < lowest_hp) {
                lowest_hp = hp;
                weakest = obj;
            }
        }
    }
    return weakest;
};

session.quarry_victory_satisfied = function() {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.team === 'enemy') {
            if(obj.is_building() && !obj.is_destroyed() && obj.spec['history_category'] == 'turrets') {
                return false;
            }
            if(obj.is_mobile() && !obj.is_destroyed()) {
                return false;
            }
        }
    }
    return true;
};

// add new object to session
session.add_object = function(obj) {
    session.cur_objects.add_object(obj);

    // add to minefield tag index
    // XXX does this need to remain sorted?
    if(obj.is_building() && obj.team == 'player') {
        if(obj.is_minefield()) {
            var dims = gamedata['dialogs']['crafting_dialog_status_mines']['widgets']['mine_slot']['array'];
            var count = goog.object.getCount(session.minefield_tags_by_obj_id);
            var rownum = Math.floor(count/dims[0]);
            var collet = count - rownum*dims[0];
            var tag = String.fromCharCode('A'.charCodeAt(0) + collet)+(rownum+1).toString();
            session.minefield_tags_by_obj_id[obj.id] = tag;
            session.minefield_tags_by_tag[tag] = obj.id;
        } else if(obj.is_factory()) {
            var count = goog.object.getCount(session.factory_tags_by_obj_id[obj.spec['name']] || {});
            var tag = String.fromCharCode('A'.charCodeAt(0) + count).toString();
            if(!(obj.spec['name'] in session.factory_tags_by_obj_id)) {
                session.factory_tags_by_obj_id[obj.spec['name']] = {};
                session.factory_tags_by_tag[obj.spec['name']] = {};
            }
            session.factory_tags_by_obj_id[obj.spec['name']][obj.id] = tag;
            session.factory_tags_by_tag[obj.spec['name']][tag] = obj.id;
        }
    }
};

session.clear_building_idle_state_caches = function() {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.is_building()) { obj.idle_state_cache = null; }
    }
};

// flag the session so that, after the server catches up, we'll check for battle end at next opportunity
// should be called after any state change that could change the result of calculate_battle_outcome()
session.set_battle_outcome_dirty = function() {
    // delay checking for battle outcome until server acknowledges this
    session.battle_outcome_sync_marker = synchronizer.request_sync();
    session.battle_outcome_dirty = true;
};

// player state
var player = {};
player.resource_state = {
    "space": [0,0], // [provided,occupied]
    "gamebucks": -1,
    "facebook_credits": -1,
    "player_level": 1,
    "xp": 0,
    "protection_end_time": 0
};
player.my_army = {};
player.squads = null;
player.squad_client_data = {}; // squad control state only used in the client

player.travel_state = {'dest_loc': null, 'start_time': -1, 'end_time': -1, 'attacks_made': 0};

// for graphical display purposes ONLY, track the last update
// to resource_state, so we can display a running-ticker effect
player.last_resource_state = { "xp": 0, "facebook_credits": -1, "gamebucks": -1 };
player.last_resource_time = -1; player.last_xp_time = -1; player.last_credits_time = -1;

// set this to >= client_time to trigger flash effect
player.flash_res_time = {};
player.flash_credits_time = -1;

// if >0, client_time at which daily attack should be triggered
player.daily_attack_time = -1;
player.new_battle_histories = 0; // count of unseen battle history entries

// same format as server's player.inventory
player.max_inventory = 0;
player.reserved_inventory = 0;
player.inventory = [];
player.loot_buffer = [];
player.donated_units = {};

player.init = function() {
    for(var res in gamedata['resources']) {
        player.resource_state[res] = [0,0]; // [max,current]
        player.last_resource_state[res] = 0;
        player.flash_res_time[res] = -1;
    }
};

player.max_usable_inventory = function() {
    return player.max_inventory - player.reserved_inventory;
};

var _min_attackable_level = function(attacker_level, mode) {
    var table = gamedata['max_pvp_level_gap'][mode];
    var max_gap;
    if((typeof table) === 'number') {
        max_gap = table;
    } else {
        var ind = Math.min(Math.max(attacker_level-1,0), table.length-1);
        max_gap = table[ind];
    }
    return Math.max(attacker_level - max_gap, 0);
};
var attackable_level_range = function(attacker_level, mode) {
    var lower_bound = _min_attackable_level(attacker_level, mode);
    var upper_bound;
    if(gamedata['apply_pvp_level_gap_upward']) {
        upper_bound = lower_bound;
        while(_min_attackable_level(upper_bound, mode) <= attacker_level) {
            upper_bound += 1;
        }
        if(upper_bound > lower_bound) { upper_bound -= 1; }
    } else {
        upper_bound = -1;
    }
    return [lower_bound, upper_bound];
};
var in_level_range = function(x, r) {
    if(r[0] >= 0 && x < r[0]) { return false; }
    if(r[1] >= 0 && x > r[1]) { return false; }
    return true;
};
var in_attackable_level_range = function(attacker_level, defender_level, mode) { return in_level_range(defender_level, attackable_level_range(attacker_level, mode)); };

player.level = function() { return player.resource_state['player_level']; };

player.unit_donation_enabled = function() {
    return player.get_any_abtest_value('enable_unit_donation', gamedata['enable_unit_donation']);
};

player.donated_units_icon = function() {
    // try to use alliance icon, otherwise use default icon
    var icon = gamedata['auras']['donated_units']['icon'];
    if(session.is_in_alliance()) {
        var info = AllianceCache.query_info_sync(session.alliance_id);
        if(info['logo']) {
            icon = 'alicon_'+info['logo'];
        }
    }
    return icon;
};

function units_description(unit_list, separator) {
    // create text description of the donated units
    var by_type = {};
    for(var i = 0; i < unit_list.length; i++) {
        var incr = unit_list[i]['stack'] || 1;
        var specname = unit_list[i]['spec'];
        if(!(specname in by_type)) { by_type[specname] = 0; }
        by_type[specname] += incr;
    }
    var descr_list = [];
    // list donated units in reverse "coolness" order from gamedata['units']
    for(var name in gamedata['units']) {
        if(name in by_type) {
            var qty = by_type[name];
            descr_list.push(qty.toFixed(0)+'x '+gamedata['units'][name]['ui_name']);
        }
    }
    descr_list.reverse();
    var descr = descr_list.join(separator);
    return descr;
}

player.donated_units_description = function(separator) {
    var by_specname = {};
    goog.object.forEach(player.donated_units, function(entry) {
        if(!(entry['spec'] in by_specname)) { by_specname[entry['spec']] = 0; }
        by_specname[entry['spec']] += ('stack' in entry ? entry['stack'] : 1);
    });
    var ret = [];
    goog.object.forEach(by_specname, function(count, specname) {
        ret.push({'spec': specname, 'stack':count});
    });
    return units_description(ret, separator);
};

player.donated_units_space = function() {
    var consumes_space = 0;
    goog.object.forEach(player.donated_units, function(entry) {
        var stack = ('stack' in entry ? entry['stack'] : 1);
        consumes_space += stack * get_leveled_quantity(gamedata['units'][entry['spec']]['consumes_space'], entry['level'] || 1);
    });
    return consumes_space;
};

player.count_donated_units = function() {
    var count = 0;
    goog.object.forEach(player.donated_units, function(entry) {
        count += ('stack' in entry ? entry['stack'] : 1);
    });
    return count;
};

player.has_donated_units = function() { return goog.object.getCount(player.donated_units) > 0; };

player.donated_units_max_space = function() {
    var alliance_building = find_object_by_type(gamedata['alliance_building']);
    if(!alliance_building) { return -1; }
    return alliance_building.get_leveled_quantity(alliance_building.spec['provides_donated_space'] || 0);
};

// same as player.mailbox on the server
player.mailbox = [];

// same as player.map_bookmarks on server
player.map_bookmarks = {};

// table of completed quests from server (same format as server's player.completed_quests)
player.completed_quests = {};

player.achievements = null; // same as player.achievements on server side

// for UI purposes only, compute the last "ui_step" value per "ui_category" of quests
player.quest_chain_lengths = [];

// quest_cache memoizes the activation/claimability status of all quests
var QUEST_CACHE_DEBUG = false;
player.quest_cache = {}; // map from quest name -> quest_status flags
player.quest_cache_dirty = true;
player.quest_status = {
    // ACTIVE and CLAIMABLE are bits that can be OR'ed together
    ACTIVE : 1,
    CLAIMABLE: 2
};

player.active_quests = []; // list of quests that are active (including satisfied but unclaimed quests), sorted in priority order
player.claimable_quests = -1; // number of quests that are completed but rewards not claimed yet. -1 for "not computed yet".


// "quest_tracked" is the "currently accepted" quest, and means that GUI tips from that quest will be shown
player.quest_tracked = null;
player.quest_tracked_dirty = false; // flag used for knowing when the quest tip UI must be re-evaluated
player.quest_tracked_complete_time = -1; // time until the mission complete dialog will be invoked automatically
player.quest_root = new SPUI.Container();
player.quest_root.transparent_to_mouse = true;
player.quest_landscape_arrow = null; // reference to tutorial arrow SPUI Dialog, if one is up

player.tutorial_state = 'START';

player.unit_repair_queue = [];
player.tech = {};
player.unit_equipment = {};
player.player_auras = [];
player.stattab = {'player':{'combat_time_scale':ModChain.make_chain(1)},'units':{},'buildings':{},'INIT':'player'};
player.history = {};
player.abtests = {};
player.cooldowns = {};
// NOTE! global_cooldown is relative to client_time, NOT server_time like all other cooldowns!
player.global_cooldown = {'start':-1, 'end':-1}; // the GCD is client-side only for now
player.developer = false; // developer access ON LIVE SERVER (e.g. shows chat gagging options)
player.is_suspicious = false; // extra logging to track suspected hackers
player.is_chat_mod = false; // whether player has chat moderation authority
player.isolate_pvp = 0; // same as server's isolate_pvp flag
player.acquisition_campaign = null; // acquisition_campaign field, from server
player.home_base_id = null; // base_id of player's home
player.home_base_loc = null; // base_map_loc of player's home
player.enable_muffins = false; // show extra-secret hidden developer features
player.is_cheater = false; // allow breaking of unit space/building limits (NOT ON LIVE SERVER)
player.ui_name = '(Unknown)';
player.facebook_name = '(Unknown)';
player.facebook_currency = null;
player.facebook_permissions = spin_facebook_login_permissions.split(',');
player.facebook_third_party_id = null;
player.friends = [];
player.preferences = {};
player.country = 'unknown';
player.price_region = 'unknown';
player.country_tier = 'unknown';
player.logged_in_times = -1;
player.creation_time = -1;
player.chat_seen = {}; // same as server

function enable_muffins() {
    if(!player.is_developer()) { return; }
    player.enable_muffins = !player.enable_muffins;
};

player.is_developer = function() { return player.developer; };

player.has_facebook_permissions = function(scope) {
    var want_perms = scope.split(',');
    var has_all = true;
    for(var i = 0; i < want_perms.length; i++) {
        if(!goog.array.contains(player.facebook_permissions, want_perms[i])) {
            has_all = false;
            break;
        }
    }
    return has_all;
};

player.is_syfy_user = function() {
    if(get_query_string('syfy_test') === '1') { return true; }
    if(!player.acquisition_campaign || player.acquisition_campaign.length < 4) { return false; }
    return (player.acquisition_campaign.substr(0,2) === "63");
};

player.get_ui_name = function() {
    if(anon_mode) {
        return ANON_NAME;
    }
    return player.ui_name;
};

// same as server-side function, used for gathering summary dimensions for metric events
player.get_denormalized_summary_props = function(format) {
    if(format != 'brief') { throw Error('unhandled format '+format); }
    var ret = {'plat': spin_frame_platform,
               'cc': player.get_townhall_level(),
               'rcpt': player.history['money_spent'] || 0,
               'ct': player.country,
               'tier': player.country_tier};
    if(player.is_developer()) { ret['developer'] = 1; }
    return ret;
};

player.has_blocked_user = function(uid) {
    if(!('blocked_users' in player.preferences)) { return false; }
    var blist = player.preferences['blocked_users'];
    for(var i = 0; i < blist.length; i++) {
        if(blist[i] === uid) { return true; }
    }
    return false;
};
player.block_user = function(uid) {
    if(player.has_blocked_user(uid)) { return; }
    if(!('blocked_users' in player.preferences)) {
        player.preferences['blocked_users'] = [];
    }
    player.preferences['blocked_users'].push(uid);
    send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
};
player.unblock_user = function(uid) {
    if(!player.has_blocked_user(uid)) { return; }
    var blist = player.preferences['blocked_users'];
    for(var i = 0; i < blist.length; i++) {
        if(blist[i] === uid) {
            blist.splice(i,1);
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
            return;
        }
    }
};

player.cooldown_togo = function(cd_name) {
    var cd = null;
    if(cd_name === 'GCD') {
        cd = player.global_cooldown;
        return (cd['end'] - client_time);
    } else if(cd_name in player.cooldowns) {
        cd = player.cooldowns[cd_name];
        return (cd['end'] - server_time);
    }
    return -1;
};

/** @param {string} cd_name
    @param {Object=} match_data */
player.cooldown_active = function(cd_name, match_data) {
    if(player.cooldown_togo(cd_name) > 0) {
        var cd = player.cooldowns[cd_name];
        if(match_data) {
            var data = ('data' in cd ? cd['data'] : {});
            for(var k in match_data) {
                if(!(k in data) || data[k] != match_data[k]) {
                    return 0; // mismatchh
                }
            }
        }
        if('stack' in cd) { return cd['stack']; }
        return 1;
    }
    return 0;
};

// NOTE: this is for client-side cooldowns only, and is cleared on every COOLDOWN_UDPATE! (except for GCD)
player.cooldown_client_trigger = function(cd_name, duration) {
    if(cd_name === 'GCD') {
        player.global_cooldown = {'start': client_time, 'end': client_time + duration};
    } else {
        player.cooldowns[cd_name] = {'start': server_time, 'end': server_time + duration};
    }
};

player.travel_satisfied = function(base_loc) {
    if(!base_loc || (player.home_base_loc && vec_equals(base_loc, player.home_base_loc))) { return true; }
    return (player.travel_state['dest_loc'] &&
            vec_equals(player.travel_state['dest_loc'], base_loc) &&
            server_time >= player.travel_state['end_time'] &&
            player.travel_state['attacks_made'] < gamedata['territory']['deployments_per_travel']);
};

player.travel_time_to = function(dest_loc) {
    if(!dest_loc || !player.home_base_loc || vec_equals(dest_loc, player.home_base_loc)) { return 0; }
    var delta = hex_distance(player.home_base_loc, dest_loc);
    if(player.is_developer() && get_query_string('fast_travel')) {
        // developer-only option for debugging
        delta = Math.min(delta, 1);
    }
    var t = delta * gamedata['territory']['travel_time_per_hex'];
    if(t > 0) {
        t = Math.max(1, Math.floor(t / get_player_stat(player.stattab, 'travel_speed')));
    }
    return t;
};

function tutorial_opt_out() {
    if(!player.preferences['skip_tutorial']) {
        player.record_feature_use('skip_tutorial');
        player.preferences['skip_tutorial'] = 1;
        send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
    }
    player.quest_tracked = null;
    player.quest_tracked_dirty = true;
}

/** @param {Object=} quest */
function tutorial_opt_in(quest) {
    if('skip_tutorial' in player.preferences) {
        player.record_feature_use('resume_tutorial');
        delete player.preferences['skip_tutorial'];
        send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
    }

    if(quest) {
        player.quest_tracked = quest;
        player.quest_tracked_dirty = true;
    } else {
        // automatically accept next eligible quest
        player.update_quest_cache(true);
    }

    // return what we managed to pick as a quest
    return player.quest_tracked;
}

player.claim_achievements = function () {
    if(player.achievements === null) { return; } // not initialized yet
    for(var name in gamedata['achievements']) {
        if(name in player.achievements) { continue; }
        var spec = gamedata['achievements'][name];
        if(('activation' in spec) && !read_predicate(spec['activation']).is_satisfied(player, null)) { continue; }
        if(('show_if' in spec) && !read_predicate(spec['show_if']).is_satisfied(player, null)) { continue; }
        if(read_predicate(spec['goal']).is_satisfied(player, null)) {
            player.achievements[name] = {'pending': 1};
            send_to_server.func(["CLAIM_ACHIEVEMENT", name]);
        }
    }
};

player.get_quest_status = function(quest) {
    var status = 0;
    if('show' in quest && !quest['show']) { return status; }
    if(quest['developer_only'] && (spin_secure_mode || !player.is_developer())) { return status; }

    var qdata = (quest['name'] in player.completed_quests ? player.completed_quests[quest['name']] : null);

    if('repeat_interval' in quest) {
        // repeatable quest
        if(qdata !== null) {
            if(server_time - qdata['time'] < quest['repeat_interval']) {
                return status; // not enough time has passed since last completion
            }
        }
    } else {
        // not a repeatable quest
        if(qdata !== null) {
            return status; // already completed
        }
    }

    // note: the read_predicate calls below can recurse into player.can_activate/can_complete
    // but that's fine and efficient because status is memoized by quest_cache

    if(('show_if' in quest) && !read_predicate(quest['show_if']).is_satisfied(player, qdata)) {
        return status; // show_if predicate not true
    }

    if(('activation' in quest) && !read_predicate(quest['activation']).is_satisfied(player, qdata)) {
        return status; // activation predicate not true
    }

    status |= player.quest_status.ACTIVE; // quest is active!

    if(read_predicate(quest['goal']).is_satisfied(player, qdata)) {
        status |= player.quest_status.CLAIMABLE; // quest is claimable!
    }

    return status;
};

player.has_any_units = function() {
    return !goog.object.isEmpty(player.my_army);
};

player.can_activate_quest = function(quest) {
    if(!(quest['name'] in player.quest_cache)) {
        player.quest_cache[quest['name']] = player.get_quest_status(quest);
    }
    return (player.quest_cache[quest['name']] & player.quest_status.ACTIVE);
};

player.can_complete_quest = function(quest) {
    if(!(quest['name'] in player.quest_cache)) {
        player.quest_cache[quest['name']] = player.get_quest_status(quest);
    }
    return (player.quest_cache[quest['name']] & player.quest_status.CLAIMABLE);
};

player.invalidate_quest_cache = function() { player.quest_cache_dirty = true; };
player.refresh_quest_cache_entry = function(quest) {
    if(quest['name'] in player.quest_cache) {
        delete player.quest_cache[quest['name']];
    }
    player.can_complete_quest(quest); // force re-evaluation
};

/** @param {boolean=} force */
player.update_quest_cache = function(force) {
    if(!force && !player.quest_cache_dirty) { return; }
    if(QUEST_CACHE_DEBUG) { console.log("UPDATE QUEST CACHE"); }
    player.quest_cache_dirty = false;

    player.quest_cache = {};
    player.active_quests = [];

    for(var name in gamedata['quests']) {
        var quest = gamedata['quests'][name];
        if(player.can_activate_quest(quest)) {
            player.active_quests.push(quest);
        }
    }

    // sort active quest list so that it appears in the UI in good order,
    // and, if auto-accepting, make sure we accept the highest-priority eligible quest
    var compare_by_priority = function(a,b) {
        var pa = a['ui_priority'] || 0, pb = b['ui_priority'] || 0;

        // group all claimable quests together at the front of the list
        var ca = player.can_complete_quest(a), cb = player.can_complete_quest(b);

        // sort by claimability first, and then ui_priority
        if(ca && !cb) {
            return -1;
        } else if(cb && !ca) {
            return 1;
        } else if(pa < pb) {
            return 1;
        } else if(pa > pb) {
            return -1;
        } else {
            return 0;
        }
    };

    player.active_quests.sort(compare_by_priority);

    player.claimable_quests = 0;
    var found_tracked = false;
    var first_completable_quest = null, first_incomplete_quest = null;

    for(var i = 0; i < player.active_quests.length; i++) {
        var quest = player.active_quests[i];

        if(player.can_complete_quest(quest)) {
            player.claimable_quests += 1;
            if(!first_completable_quest) { first_completable_quest = quest; }
        } else {
            if(!first_incomplete_quest) { first_incomplete_quest = quest; }
        }

        // candidate quests for tracking: either FORCE_CLAIM (regardless of claimability) or NOT CLAIMABLE
        if(quest['force_claim'] || !player.can_complete_quest(quest)) {
            // if no quest is currently tracked, and not skipping tutorial,
            // auto-track the highest-priority candidate quest
            if(!player.quest_tracked && !player.preferences['skip_tutorial']) {
                player.quest_tracked = quest; player.quest_tracked_dirty = true;
                found_tracked = true;
                if(QUEST_CACHE_DEBUG) { console.log("HERE A "+player.quest_tracked['name']); }
            } else if(quest === player.quest_tracked) {
                found_tracked = true;
                if(QUEST_CACHE_DEBUG) { console.log("HERE FOUND "+player.quest_tracked['name']); }
            }
        }
    }

    if(!found_tracked) {
        if(QUEST_CACHE_DEBUG) { console.log("NO QUEST FOUND IN FIRST PASS"); }
        player.quest_tracked = null;
        player.quest_tracked_dirty = true;
    }

    // retrack an appropriate quest
    if(!player.preferences['skip_tutorial']) {
        // skip_claim behavior - grab next incomplete quest if nothing is tracked, or if the tracked quest is complete and not foce_claim
        if(first_incomplete_quest &&
           (!player.quest_tracked || (player.can_complete_quest(player.quest_tracked) && !player.quest_tracked['force_claim']))) {
            player.quest_tracked = first_incomplete_quest;
            player.quest_tracked_dirty = true;
            if(QUEST_CACHE_DEBUG) { console.log("HERE B "+player.quest_tracked['name']); }
        }
    }
}

player.prune_expired_mail = function() {
    for(var i = 0; i < player.mailbox.length; i++) {
        var mail = player.mailbox[i];
        if(('expire_time' in mail) && (mail['expire_time'] > 0) && (server_time >= mail['expire_time'])) {
            player.mailbox.splice(i,1);
            i -= 1;
        }
    }
};
player.mailbox_remove = function(mail) {
    for(var i = 0; i < player.mailbox.length; i++) {
        if(player.mailbox[i] === mail) { player.mailbox.splice(i,1); break; }
    }
};
player.mailbox_iter = function(func) {
    var nth = 0;
    for(var i = 0; i < player.mailbox.length; i++) {
        if('show_if' in player.mailbox[i] && player.mailbox[i]['show_if'] in gamedata['predicate_library']) {
            if(!read_predicate({'predicate':'LIBRARY', 'name': player.mailbox[i]['show_if']}).is_satisfied(player, null)) {
                continue;
            }
        }
        if(func(player.mailbox[i], nth)) { break; }
        nth += 1;
    }
};
player.mailbox_count = function() {
    var count = 0;
    player.mailbox_iter(function(mail) { count += 1; });
    return count;
};
player.mailbox_nth = function(n) {
    var ret = null;
    player.mailbox_iter(function(mail, i) { if(i == n) { ret = mail; return true } });
    if(!ret) {
        throw Error('mail message not found! '+n.toString()+' from '+JSON.stringify(player.mailbox));
    }
    return ret;
};
player.has_unread_mail = function() {
    if(!player.get_any_abtest_value('enable_inventory', gamedata['enable_inventory'])) { return 0; }
    var count = 0;
    player.mailbox_iter(function(mail) { if(!mail['read']) { count += 1; } });
    return count;
};

player.mail_message_has_money = function(msg) {
    if('gift_order' in msg && 'attachments' in msg && msg['attachments'].length>0) {
        return true;
    }
    // also check for any mail with attached gamebucks
    if('attachments' in msg) {
        for(var i = 0; i < msg['attachments'].length; i++) {
            if(goog.array.contains(['gamebucks','alloy'], msg['attachments'][i]['spec'])) {
                return true;
            }
        }
    }
    return false;
};

player.mail_message_is_discardable = function(msg) {
    if('attachments' in msg) {
        for(var i = 0; i < msg['attachments'].length; i++) {
            if(msg['attachments'][i]['undiscardable']) {
                return false;
            }
        }
    }
    return true;
};

player.has_uncollected_gift_mail = function() {
    var gifts_waiting = 0;
    player.mailbox_iter(function(msg) {
        if(player.mail_message_has_money(msg)) {
            gifts_waiting += 1;
        }
    });
    return gifts_waiting;
};

// returns next level player is qualified for, or 0 if no levelup is possible
player.can_level_up = function() {
    var data = gamedata['player_xp']['level_xp'];

    var level = player.resource_state['player_level'];

    while(level < data.length-1) {
        if(player.resource_state['xp'] >= data[level+1]) {
            level += 1;
            continue;
        } else {
            break;
        }
    }
    return (level > player.resource_state['player_level'] ? level : 0);
};

player.unit_micro_enabled = function() { return (!('enable_unit_micro' in gamedata) || gamedata['enable_unit_micro'] || player.is_cheater); };
player.squads_enabled = function() { return read_predicate({'predicate':'LIBRARY', 'name': 'squads_enabled'}).is_satisfied(player, null); };
player.unit_speedups_enabled = function() { return player.is_cheater || !('enable_unit_speedups' in gamedata) || gamedata['enable_unit_speedups']; };
player.crafting_speedups_enabled = function() { return player.is_cheater || !('enable_crafting_speedups' in gamedata) || gamedata['enable_crafting_speedups']; };
player.resource_gifts_enabled = function() { return (player.get_any_abtest_value('enable_resource_gifts', gamedata['enable_resource_gifts']) && (spin_frame_platform == 'fb')); };
player.upgrade_bar_enabled = function() { return player.get_any_abtest_value('enable_upgrade_bar', gamedata['client']['enable_upgrade_bar']) &&
                                          read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null); };

player.num_mobile_squads = function() { return goog.object.getCount(player.squads)-1; };
player.num_deployed_squads = function() {
    var count = 0;
    goog.object.forEach(player.squads, function(d) { if('map_loc' in d) { count += 1; } });
    return count;
};

/** returns whether or not all foremen are in use
 * @returns {boolean} */
player.foreman_is_busy = function() {
    return player.foremen_in_use() >= player.stattab['total_foremen'];
};

/** returns a list of buildings that are currently being worked on by a foreman
 * @returns {Array.<GameObject>} */
player.foreman_get_tasks = function() {
    var tasks = [];

    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.is_building() && obj.is_using_foreman()) {
            tasks.push(obj);
        }
    }

    return tasks;
};

/** returns the number of foreman that are occupied by a task
 * @returns {number} */
player.foremen_in_use = function() { return player.foreman_get_tasks().length; };

player.all_minefields_armed = function() {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.is_building() && obj.team == 'player' && obj.is_minefield() && !obj.is_minefield_armed()) {
            return false;
        }
    }
    return true;
};

player.alliance_building_is_busy = function() {
    var alliance_building = find_object_by_type(gamedata['alliance_building']);
    if(!alliance_building || alliance_building.is_under_construction() || alliance_building.is_upgrading() || alliance_building.is_damaged()) {
        return true;
    }
    return false;
};
player.region_map_building_is_busy = function() {
    var region_map_building = find_object_by_type(gamedata['region_map_building']);
    if(!region_map_building ||
       ((region_map_building.is_under_construction() || region_map_building.is_upgrading()) && !player.get_any_abtest_value('region_map_available_during_transmitter_upgrade', gamedata['territory']['region_map_available_during_transmitter_upgrade'])) ||
       (region_map_building.is_damaged() && !player.get_any_abtest_value('region_map_available_during_transmitter_repair', gamedata['territory']['region_map_available_during_transmitter_repair']))) {
        return true;
    }
    return false;
};
player.warehouse_is_busy = function() {
    if(player.get_any_abtest_value('enable_inventory', gamedata['enable_inventory'])) {
        if(!session.home_base) { return session.home_warehouse_busy; }
        var warehouse = find_object_by_type(gamedata['inventory_building']);
        if(!warehouse ||
           ((warehouse.is_under_construction() || warehouse.is_upgrading()) && !player.get_any_abtest_value('inventory_available_during_warehouse_upgrade', gamedata['inventory_available_during_warehouse_upgrade'])) ||
           (warehouse.is_damaged() && !player.get_any_abtest_value('inventory_available_during_warehouse_repair', gamedata['inventory_available_during_warehouse_repair']))) {
            return true;
        }
    }
    return false;
};
player.squad_bay_is_busy = function() {
    if(player.squads_enabled()) {
        var bay = find_object_by_type(gamedata['squad_building']);
        if(!bay ||
           ((bay.is_under_construction() || bay.is_upgrading()) && !player.get_any_abtest_value('squads_available_during_squad_bay_upgrade', gamedata['squads_available_during_squad_bay_upgrade'])) ||
           (bay.is_damaged() && !player.get_any_abtest_value('squads_available_during_squad_bay_repair', gamedata['squads_available_during_squad_bay_repair']))) {
            return true;
        }
    }
    return false;
};
player.lottery_is_busy = function() {
    if(player.get_any_abtest_value('enable_lottery', gamedata['enable_lottery'])) {
        var scanner = find_object_by_type('scanner');
        if(!scanner ||
           ((scanner.is_under_construction() || scanner.is_upgrading()) && !player.get_any_abtest_value('lottery_available_during_scanner_upgrade', gamedata['lottery_available_during_scanner_upgrade'])) ||
           (scanner.is_damaged() && !player.get_any_abtest_value('lottery_available_during_scanner_repair', gamedata['lottery_available_during_scanner_repair']))) {
            return true;
        }
    }
    return false;
};

player.quantize_building_location = function(ji, spec) {
    if(spec['quantize_location']) {
        var q = spec['quantize_location'];
        if(q > 2) {
            // new SG-style quantization
            // because of the convention that a building's x,y coordinates are its center, and not its corner,
            // we can't quantize just by snapping the x,y coordinates. We have to do more math to pick the right center.
            var gridsize = spec['gridsize'];
            if(gridsize[0]&1 || gridsize[1]&1) { throw Error('cannot quantize odd gridsize with q = '+q.toString()); }
            var half = [gridsize[0]>>1, gridsize[1]>>1];
            // this is where the corner was BEFORE quantization
            var old_corner = [ji[0]-half[0], ji[1]-half[1]];
            // this is where we want the corner to be AFTER quantization
            var corner = [q*Math.floor(old_corner[0]/q),
                          q*Math.floor(old_corner[1]/q)];
            return [corner[0]+half[0], corner[1]+half[1]];
        } else {
            // 2-unit TR-style quantization
            return [q*Math.floor(ji[0]/q),
                    q*Math.floor(ji[1]/q)];
        }
    }
    return ji;
};

player.is_building_location_valid = function(ji, spec, myself, options) {
    return player.is_building_location_valid_detailed(ji, spec, myself, options)[0];
};
player.is_building_location_valid_detailed = function(ji, spec, myself, options) {
    var gridsize = spec['gridsize'];

    if(spec['quantize_location']) { // enforce quantization
        var test_ji = player.quantize_building_location(ji, spec);
        if(ji[0] != test_ji[0] || ji[1] != test_ji[1]) {
            return [false,'overlap'];
        }
    }

    // find bounding box of building
    var bound = get_grid_bounds(ji, gridsize);

    // check against base size
    var ncells = session.viewing_base.ncells();
    var mid = session.viewing_base.midcell();
    var rad = session.viewing_base.get_base_radius();

    // allow outside perimeter in developer mode
    if(player.is_cheater || (options && options.ignore_perimeter)) {
        // just clamp against entire play area
        if(bound[0][0] < 0 || bound[0][1] > ncells[0] ||
           bound[1][0] < 0 || bound[1][1] > ncells[1]) {
            return [false,'perimeter'];
        }
    } else {
        // clamp against base perimeter
        if(bound[0][0] < mid[0]-rad || bound[0][1] > mid[0]+rad ||
           bound[1][0] < mid[1]-rad || bound[1][1] > mid[1]+rad) {
            return [false,'perimeter'];
        }
    }

    // allow overlap in developer mode
    if(player.is_cheater) { return [true,null]; }

    // get curret bounds, for an object that's already built
    var mybound = (myself ? get_grid_bounds([myself.x,myself.y], gridsize) : null);

    // check against map-object blockage
    for(var v = bound[1][0]; v <= bound[1][1]-1; v++) {
        for(var u = bound[0][0]; u <= bound[0][1]-1; u++) {
            // ignore collisions from the building itself
            if(mybound) {
                if(v >= mybound[1][0] && v < mybound[1][1] &&
                   u >= mybound[0][0] && u < mybound[0][1]) {
                    continue;
                }
            }
            if(astar_map.is_blocked([u,v])) {
                return [false,'overlap'];
            }
        }
    }

    // also check against all buildings
    // since we want to restrict on gridsize, NOT unit_collision_gridsize (which controls map blocking)
    // and block placement on top of destroyed buildings, which do not block the astar map!

    // expand boundary to include exclusion zone
    var zone = spec['exclusion_zone'] || [0,0];
    var excl_bound = [[bound[0][0]-zone[0], bound[0][1]+zone[0]],
                      [bound[1][0]-zone[1], bound[1][1]+zone[1]]];

    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj !== myself && obj.is_building()) {
            var hisbound = get_grid_bounds([obj.x,obj.y], obj.spec['gridsize']);
            // if OTHER object has an exclusion zone, then apply OUR exclusion zone
            var b = (obj.spec['exclusion_zone'] ? excl_bound : bound);

            if((b[0][0] < hisbound[0][0] && b[0][1] > hisbound[0][0]) ||
               (b[0][0] >= hisbound[0][0] && b[0][0] < hisbound[0][1])) {

                if((b[1][0] < hisbound[1][0] && b[1][1] > hisbound[1][0]) ||
                   (b[1][0] >= hisbound[1][0] && b[1][0] < hisbound[1][1])) {
                    return [false,'overlap'];
                }
            }
        }
    }

    return [true,null];
}

// returns PlayerCache entries for each giftable friend
player.get_giftable_friend_info_list = function() {
    var giftable_friends = [];
    for(var i = 0; i < player.friends.length; i++) {
        var friend = player.friends[i];
        if(!friend.is_giftable() || !friend.get_facebook_id()) {
            continue;
        }
        // note: cannot rely on actual PlayerCache info entries being present in the cache,
        // since a clear() can get rid of them. Reconstruct a fake entry instead.
        giftable_friends.push({'user_id': friend.user_id,
                               'facebook_id': friend.get_facebook_id(),
                               'ui_name': friend.get_ui_name()});
    }
    return giftable_friends;
};

player.map_bookmark_create = function(region_id, ui_name, coords) {
    coords = vec_floor(coords);
    if(!(region_id in player.map_bookmarks)) { player.map_bookmarks[region_id] = []; }
    var found = false;
    for(var i = 0; i < player.map_bookmarks[region_id].length; i++) {
        if(vec_equals(coords, player.map_bookmarks[region_id][i]['coords'])) {
            player.map_bookmarks[region_id][i]['ui_name'] = ui_name;
            found = true; break;
        }
    }
    if(!found) {
        player.map_bookmarks[region_id].push({'region':region_id, 'coords':coords, 'ui_name':ui_name});
    }
    send_to_server.func(["MAP_BOOKMARK_UPDATE", region_id, SPHTTP.wrap_string(ui_name), coords]);
};
player.map_bookmark_rename = player.map_bookmark_create;
player.map_bookmark_find = function(region_id, coords) {
    coords = vec_floor(coords);
    if(!(region_id in player.map_bookmarks)) { return null; }
    for(var i = 0; i < player.map_bookmarks[region_id].length; i++) {
        if(vec_equals(coords, player.map_bookmarks[region_id][i]['coords'])) {
            return player.map_bookmarks[region_id][i];
        }
    }
    return null;
};
player.map_bookmark_delete = function(region_id, coords) {
    coords = vec_floor(coords);
    if(!(region_id in player.map_bookmarks)) { return; }
    for(var i = 0; i < player.map_bookmarks[region_id].length; i++) {
        if(vec_equals(coords, player.map_bookmarks[region_id][i]['coords'])) {
            player.map_bookmarks[region_id].splice(i,1);
            send_to_server.func(["MAP_BOOKMARK_UPDATE", region_id, SPHTTP.wrap_string('DELETED'), coords]);
            break;
        }
    }
    if(player.map_bookmarks[region_id].length < 1) {
        delete player.map_bookmarks[region_id];
    }
};

player.get_max_storage = function() {
    var ret = goog.object.map(gamedata['resources'], function() { return 0; });
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.is_building() && !obj.spec['worth_less_xp'] && !obj.is_under_construction()) {
            for(var res in gamedata['resources']) {
                ret[res] += obj.get_leveled_quantity(obj.spec['storage_'+res] || 0);
            }
        }
    }
    return ret;
};

function get_storage_fullness(resname) {
    // XXX probably should make this clearer by separating base vs. player data
    if(session.viewing_ai || session.viewing_base.base_id != session.viewing_player_home_base_id) {
        return 0.5;
    } else {
        var max_res = player.get_max_storage();
        if(max_res <= 0) { return 0; }
        var p = (session.home_base ? player.resource_state : enemy.resource_state);
        return p[resname][1]/max_res[resname];
    }
}

player.init_abtests = function(test_data) {
    player.abtests = test_data;
    // modify gamedata

    if(spin_art_path) {
        // NOTE! this is for testing only, and only affects downloads that begin AFTER server connection!
        spin_art_path = player.get_any_abtest_value('art_cdn_path', spin_art_path);
    }

    for(var test_name in player.abtests) {
        var group = player.abtests[test_name];
        if(test_name in gamedata['abtests'] && gamedata['abtests'][test_name]['active'] && (group in gamedata['abtests'][test_name]['groups'])) {
            var data = gamedata['abtests'][test_name]['groups'][group];
            if(data['patches_client_gamedata']) {
                var kinds = ['resources', 'spells', 'units', 'buildings', 'tech', 'art', 'dialogs', 'strings', 'map', 'quests', 'predicate_library', 'consequent_library', 'tutorial'];
                for(var i = 0; i < kinds.length; i++) {
                    var kind = kinds[i];
                    if(kind in data) {
                        var patches = data[kind];
                        var target = gamedata[kind];
                        for(var klass in patches) {
                            var patch = patches[klass];
                            if(typeof patch === 'object') {
                                var ktarg = target[klass];
                                for(var key in patch) {

                                    // special case for dialogs.json:
                                    // add widget properties rather than replace
                                    if(kind === 'dialogs' && key === 'widgets') {
                                        for(var widget_name in patch[key]) {
                                            for(var prop_name in patch[key][widget_name]) {
                                                ktarg[key][widget_name][prop_name] = patch[key][widget_name][prop_name];
                                            }
                                        }
                                    } else {
                                        ktarg[key] = patch[key];
                                    }
                                }
                            } else {
                                target[klass] = patch;
                            }
                        }
                    }
                }
            }
        }
    }

    // now that quests are all patched, compute last step of each ui_category
    player.quest_chain_lengths = {};
    for(var name in gamedata['quests']) {
        var quest = gamedata['quests'][name];
        if('ui_category' in quest) {
            var last = (quest['ui_category'] in player.quest_chain_lengths ? player.quest_chain_lengths[quest['ui_category']] : 0);
            var cur = quest['ui_step'] || 1;
            player.quest_chain_lengths[quest['ui_category']] = Math.max(last, cur);
        }
    }

    // select FB payments API
    var api_name = eval_cond_or_literal(player.get_any_abtest_value('payments_api', gamedata['store']['payments_api']), player, null);
    if(!api_name) { throw Error('cannot get payments_api name'); }
    SPay.set_api(api_name);
};

player.get_abtest_value = function(test_name, key, default_value) {
    if(test_name in gamedata['abtests']) {
        var group;
        if(gamedata['abtests'][test_name]['active'] && (test_name in player.abtests)) {
            group = player.abtests[test_name];
        } else {
            group = gamedata['abtests'][test_name]['default_group'];
        }
        if(group in gamedata['abtests'][test_name]['groups']) {
            return gamedata['abtests'][test_name]['groups'][group][key];
        }
    }
    return default_value;
};

player.get_any_abtest_value = function(key, default_value) {
    for(var test_name in player.abtests) {
        var group = player.abtests[test_name];
        if(test_name in gamedata['abtests']) {
            var data = gamedata['abtests'][test_name];
            if(data['active'] && group in data['groups']) {
                var group_data = data['groups'][group];
                if(key in group_data) {
                    return group_data[key];
                }
            }
        }
    }
    return default_value;
};

player.flashy_loot = function() {
    if(player.get_abtest_value('T010_flashy_loot', 'enable', 1) &&
       player.get_abtest_value('T012_flashy2', 'enable', 1)) {
        return true;
    } else {
        return false;
    }
};

player.record_feature_use = function(name) {
    var key = 'feature_used:'+name;
    if(!(key in player.history) || player.history[key] < 1) {
        player.history[key] = 1;
        send_to_server.func(["RECORD_FEATURE_USE", name]);

        // update quest status, because some quests are completed by a feature_used: value going nonzero
        player.invalidate_quest_cache();
        player.quest_tracked_dirty = true;
    }
};
player.check_feature_use = function(name) {
    var key = 'feature_used:'+name;
    return !!(player.history[key]);
};

player.record_client_history = function(name, incr) {
    send_to_server.func(["RECORD_CLIENT_HISTORY", name, incr]);
};

// find the type of building that can perform research on "category"
function get_lab_for(category) {
    for(var name in gamedata['buildings']) {
        var cats = gamedata['buildings'][name]['research_categories'] || null;
        if(cats && goog.array.contains(cats, category)) {
            return name;
        }
    }
    return null;
}
// find the type of building that can produce units of a specific category
function get_factory_for(category) {
    for(var name in gamedata['buildings']) {
        if((gamedata['buildings'][name]['manufacture_category'] || null) == category) {
            return name;
        }
    }
    return null;
}
// find the type of building that can craft items of a specific category
function get_workshop_for(category) {
    for(var name in gamedata['buildings']) {
        var cats = gamedata['buildings'][name]['crafting_categories'] || null;
        if(cats && goog.array.contains(cats, category)) { return name; }
    }
    throw Error('no workshop for category '+category);
}

// find the type of building that increases your TOTAL army space
function total_space_building() {
    for(var specname in gamedata['buildings']) {
        var spec = gamedata['buildings'][specname];
        if((player.squads_enabled() && 'provides_total_space' in spec) ||
           (!player.squads_enabled() && ('provides_space' in spec))) {
            return specname;
        }
    }
    return gamedata['townhall']; // fallback
}
// find the type of building that increases your DEPLOYABLE army space
function attack_space_building() {
    for(var specname in gamedata['buildings']) {
        var spec = gamedata['buildings'][specname];
        if('provides_space' in spec) {
            return specname;
        }
    }
    return gamedata['townhall']; // fallback
}

// enemy player state
var enemy = {
    facebook_portrait: null,
    resource_state: {
        "protection_end_time": 0,
        "player_level": 0
    },
    instance_expiration_time:-1,
    tech: {},
    unit_equipment: {},
    stattab: {},
    player_auras: [],
    is_pvp_player_cache: true
};

enemy.init = function() {
    for(var res in gamedata['resources']) {
        enemy.resource_state[res] = [0,0];
    }
};

enemy.is_pvp_player = function() { return enemy.is_pvp_player_cache; };

enemy.is_ladder_player = function() {
    if(!enemy.is_pvp_player()) { return false; }
    return gamedata['ladder_pvp'] || (session.viewing_player_home_region && (session.viewing_player_home_region in gamedata['regions']) && gamedata['regions'][session.viewing_player_home_region]['ladder_pvp']);
};
enemy.is_legacy_pvp_player = function() {
    if(!enemy.is_pvp_player()) { return false; }
    if(('legacy_pvp' in gamedata) && !gamedata['legacy_pvp']) { return false; }
    if(session.viewing_player_home_region && session.viewing_player_home_region in gamedata['regions']) {
        var data = gamedata['regions'][session.viewing_player_home_region];
        if('legacy_pvp' in data && !data['legacy_pvp']) { return false;}
    }
    return true;
};

player.get_townhall = function() {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.team === 'player' && obj.spec['name'] === gamedata['townhall']) {
            return obj;
        }
    }
    return null;
};
player.get_townhall_level = function() {
    var cc = player.get_townhall();
    if(cc) {
        return cc.level;
    } else if(session.is_remote_base()) {
        if(gamedata['townhall']+'_level' in player.history) {
            return player.history[gamedata['townhall']+'_level'];
        } else {
            // XXX nasty hack
            return 5;
        }
    }
    return 0;
};

player.is_pvp_player = function() { return read_predicate({'predicate':'LIBRARY','name':'pvp_requirement'}).is_satisfied(player,null); };

player.is_ladder_player = function() {
    if(!player.is_pvp_player()) { return false; }
    return gamedata['ladder_pvp'] || (session.region && session.region.data && session.region.data['ladder_pvp']);
};
player.is_legacy_pvp_player = function() {
    if(!player.is_pvp_player()) { return false; }
    if(('legacy_pvp' in gamedata) && !gamedata['legacy_pvp']) { return false; }
    if(session.region && session.region.data && ('legacy_pvp' in session.region.data) && !session.region.data['legacy_pvp']) { return false; }
    return true;
};

player.home_continent = function() {
    if(session.region && session.region.data) { return session.region.data['continent_id']; }
    return eval_cond_or_literal(gamedata['continent_assignment'], player, null);
};

player.can_resurrect_unit = function(obj) {
    if(obj.spec['resurrectable']) { return true; }
    return get_unit_stat(player.stattab, obj.spec['name'], 'resurrection', RESURRECT_NEVER) >= RESURRECT_AND_REPAIR_WITH_TECH;
};

player.can_repair_unit_of_spec = function(spec, hp) {
    if(hp > 0) { return true; }
    var ability = (spec['resurrectable'] ? ((gamedata['resurrect_requires_tech'] && !spec['resurrectable_without_tech']) ? RESURRECT_AND_REPAIR_WITH_TECH : RESURRECT_AND_REPAIR_ALWAYS) : RESURRECT_NEVER);
    ability = Math.max(ability, get_unit_stat(player.stattab, spec['name'], 'resurrection', RESURRECT_NEVER));
    if(ability >= RESURRECT_AND_REPAIR_ALWAYS) {
        return true;
    } else if(ability >= RESURRECT_AND_REPAIR_WITH_TECH) {
        if((player.tech[spec['level_determined_by_tech']] || 0) >= 1) { return true; }
    }
    return false;
};

player.can_repair_unit = function(obj) { return player.can_repair_unit_of_spec(obj.spec, obj.hp); };

player.inventory_item_quantity_and_expiration = function(specname) {
    var total = 0, expire_time = -1;
    for(var i = 0; i < player.inventory.length; i++) {
        var item = player.inventory[i];
        if(item['spec'] == specname) {
            if((!('expire_time' in item)) || (item['expire_time'] >= server_time)) {
                var stack = (('stack' in item) ? item['stack'] : 1);
                total += stack;
                if('expire_time' in item) {
                    if(expire_time > 0) {
                        expire_time = Math.min(expire_time, item['expire_time']);
                    } else {
                        expire_time = item['expire_time'];
                    }
                }
            }
        }
    }
    return [total, expire_time];
};
player.inventory_item_quantity = function(specname) {
    var quant_expr = player.inventory_item_quantity_and_expiration(specname);
    return quant_expr[0];
};

player.stored_item_iter = function(func) {
    var stop = false;
    goog.array.forEach(player.inventory, function(entry) { stop |= func(entry); }); if(stop) { return; }
    goog.array.forEach(player.loot_buffer, function(entry) { stop |= func(entry); }); if(stop) { return; }
};

/** If an item of "espec" can theoretically go into a slot on a "thing" (works with both building and unit specs),
    then return the applicable criteria object from within espec, otherwise null.
    (ignores unique_equipped/limited_equipped constraints)
    @param {Object} host_spec
    @param {number} host_level
    @param {string} slot_type
    @param {Object} espec of the equipment item
    @param {boolean=} ignore_min_level ignore the min_level requirment
    @return {Object|null} */
function equip_is_compatible_with_slot(host_spec, host_level, slot_type, espec, ignore_min_level) {
    if(!('equip' in espec)) { return null; }
    var crit_list;
    if('compatible' in espec['equip']) {
        crit_list = espec['equip']['compatible'];
    } else {
        crit_list = [espec['equip']]; // legacy items use raw outer JSON
    }
    for(var i = 0; i < crit_list.length; i++) {
        var crit = crit_list[i];
        if(('kind' in crit) && (crit['kind'] != host_spec['kind'])) { continue; }
        if(('name' in crit) && (crit['name'] != host_spec['name'])) { continue; }
        if(('manufacture_category' in crit) && (crit['manufacture_category'] != host_spec['manufacture_category'])) { continue; }
        if(('history_category' in crit) && (crit['history_category'] != host_spec['history_category'])) { continue; }
        if(('slot_type' in crit) && crit['slot_type'] != slot_type) { continue; }
        if(!ignore_min_level && ('min_level' in crit) && (host_level < crit['min_level'])) { continue; }
        return crit;
    }
    return null;
}

/** Return true if an item of "espec" can theoretically go into a slot on a building
    (ignores unique_equipped/limited_equipped constraints)
    @param {Building} unit
    @param {string} slot_type
    @param {Object} espec of the equipment item
    @param {boolean=} ignore_min_level
    @return {Object|null}
*/
function equip_is_compatible_with_building(unit, slot_type, espec, ignore_min_level) {
    return equip_is_compatible_with_slot(unit.spec, unit.level, slot_type, espec, ignore_min_level);
}

/** Return true if an item of "espec" can theoretically go into a slot on a unit spec
    (ignores unique_equipped/limited_equipped constraints)
    @param {string} techname of the unit-associated tech
    @param {string} specname of the unit
    @param {string} slot_type
    @param {Object} espec of the equipment item
    @param {boolean=} ignore_min_level
    @return {Object|null}
*/
function equip_is_compatible_with_unit(techname, specname, slot_type, espec, ignore_min_level) {
    return equip_is_compatible_with_slot(gamedata['units'][specname], player.tech[techname]||0, slot_type, espec, ignore_min_level);
}

/** Reference to a specific slot in an equipment data structure
    @constructor
    @struct
    @param {string} slot_type
    @param {number} slot_index */
var EquipSlotAddress = function(slot_type, slot_index) {
    this.slot_type = slot_type;
    this.slot_index = slot_index;
};
EquipSlotAddress.prototype.equals = function(other) {
    return (this.slot_type == other.slot_type && this.slot_index == other.slot_index);
};

/** Reference to a specific slot on a specific building, e.g. used as delivery address for crafting products
    @constructor
    @struct
    @extends EquipSlotAddress
    @param {GameObjectId} obj_id
    @param {string} slot_type
    @param {number} slot_index */
var BuildingEquipSlotAddress = function(obj_id, slot_type, slot_index) {
    goog.base(this, slot_type, slot_index);
    this.obj_id = obj_id;
};
goog.inherits(BuildingEquipSlotAddress, EquipSlotAddress);
BuildingEquipSlotAddress.prototype.equals = function(other) {
    return (goog.base(this, 'equals', other) && this.obj_id == other.obj_id);
};

/** Reference to a specific slot on a specific unit type
    @constructor
    @struct
    @extends EquipSlotAddress
    @param {string} specname
    @param {string} slot_type
    @param {number} slot_index */
var UnitEquipSlotAddress = function(specname, slot_type, slot_index) {
    goog.base(this, slot_type, slot_index);
    this.specname = specname;
};
goog.inherits(UnitEquipSlotAddress, EquipSlotAddress);
UnitEquipSlotAddress.prototype.equals = function(other) {
    return (goog.base(this, 'equals', other) && this.specname == other.specname);
};

/** Iterate through all equipped items
    @param {function(Object, EquipSlotAddress):(boolean|undefined)} func (return true to stop iteration) */
player.equipped_item_iter = function(func) {
    var stop = false;
    goog.object.forEach(player.unit_equipment, function(equipment, specname) {
        goog.object.forEach(equipment, function(name_list, slot_type) {
            goog.array.forEach(name_list, function(name, slot_index) { if(name) { stop |= func({'spec':name}, new UnitEquipSlotAddress(specname, slot_type, slot_index)); } });
        });
    });
    if(stop) { return; }
    goog.object.forEach(session.cur_objects.objects, function(obj) {
        if(obj.is_building() && obj.team === 'player') {
            if(obj.equipment) {
                goog.object.forEach(obj.equipment, function(name_list, slot_type) {
                    goog.array.forEach(name_list, function(name, slot_index) { if(name) { stop |= func({'spec':name}, new BuildingEquipSlotAddress(obj.id, slot_type, slot_index)); } });
                });
            }
        }
    });
};

player.mail_attachments_iter = function(func) {
    goog.array.forEach(player.mailbox, function(mail) {
        if('attachments' in mail) {
            goog.array.forEach(mail['attachments'], func);
        }
    });
};

/** Iterate through all crafting queues for ingredients and products
    @param {function(Object, (EquipSlotAddress|null)):(boolean|undefined)} func (return true to stop iteration) */
player.crafting_queue_ingredients_and_products_iter = function(func) {
    goog.object.forEach(session.cur_objects.objects, function(obj) {
        if(obj.is_building() && obj.team === 'player' && obj.is_crafter() && obj.is_crafting()) {
            goog.array.forEach(obj.get_crafting_queue(), function(bus) {
                var recipe_name = bus['craft']['recipe'];
                var recipe = gamedata['crafting']['recipes'][recipe_name] || null;
                if(recipe) {
                    goog.array.forEach(recipe['product'], function(prod) {
                        if('spec' in prod) { // only works on deterministic products!
                            var address = null;
                            var delivery = bus['craft']['delivery'];
                            if(delivery && delivery['obj_id']) {
                                address = new BuildingEquipSlotAddress(delivery['obj_id'], delivery['slot_type'], delivery['slot_index']);
                            }
                            func(prod, address);
                        }
                    });
                    var ingr_list = bus['craft']['ingredients'] || null;
                    if(ingr_list && gamedata['crafting']['categories'][recipe['crafting_category']]['refund_ingredients']) {
                        // only check ingredients if they are refundable and thus available to the player if cancelled
                        goog.array.forEach(ingr_list, (function(ingr_item) { func(ingr_item, null); }));
                    }
                }
            });
        }
    });
};

/** Return true if crafting a new item of spec "product_spec" into "delivery_address" would violate a limited_equipped constraint
 @param {Object} product_spec
 @param {BuildingEquipSlotAddress|null} delivery_address
 @return {boolean} */
player.would_violate_limited_equipped = function(product_spec, delivery_address) {
    if(!product_spec['limited_equipped']) { return false; }
    var limit = player.stattab['limited_equipped'][product_spec['limited_equipped']] || 0;
    if(limit < 1) { return true; }
    var count = 0;
    var check_func = function(other_item, other_address) {
        var other_spec = ItemDisplay.get_inventory_item_spec(other_item['spec']);

        // skip our own destination slot if it matches (assumes we're replacing this item)
        if(delivery_address && other_address && other_address instanceof BuildingEquipSlotAddress && other_address.equals(delivery_address) &&
           other_spec['limited_equipped'] == product_spec['limited_equipped']) { return false; }

        if(other_spec && other_spec['limited_equipped']==product_spec['limited_equipped']) {
            count += 1;
            if(count+1 > limit) { return true; }
        }
        return false;
    };

    // check existing items
    player.equipped_item_iter(check_func);
    if(count+1 > limit) { return true; }

    // check crafting queues
    player.crafting_queue_ingredients_and_products_iter(check_func);
    if(count+1 > limit) { return true; }

    return false;
};

/** Return true if crafting a new item of spec "product_spec" into "delivery_address" would violate a unique_equipped constraint
 @param {Object} product_spec
 @param {BuildingEquipSlotAddress|null} delivery_address
 @return {boolean} */
player.would_violate_unique_equipped = function(product_spec, delivery_address) {
    if(!product_spec['unique_equipped']) { return false; }
    var count = 0;
    var check_func = function(other_item, other_address) {
        var other_spec = ItemDisplay.get_inventory_item_spec(other_item['spec']);

        // skip our own destination slot if it matches (assumes we're replacing this item)
        if(delivery_address && other_address && other_address instanceof BuildingEquipSlotAddress && other_address.equals(delivery_address) &&
           other_spec['unique_equipped'] == product_spec['unique_equipped']) { return false; }

        if(other_spec && other_spec['unique_equipped']==product_spec['unique_equipped']) {
            count += 1;
            if(count > 0) { return true; }
        }
        return false;
    };

    // check existing items
    player.equipped_item_iter(check_func);
    if(count > 0) { return true; }

    // check crafting queues
    player.crafting_queue_ingredients_and_products_iter(check_func);
    if(count > 0) { return true; }

    return false;
};

/** Return current count of a limited_equipped item pool, ignoring anything that matches in delivery_address
    @param {Object} product_spec
    @param {BuildingEquipSlotAddress|null} delivery_address
    @return {number} */
player.count_limited_equipped = function(product_spec, delivery_address) {
    var count = 0;
    var count_func = function(other_item, other_address) {
        var other_spec = ItemDisplay.get_inventory_item_spec(other_item['spec']);

        // skip our own destination slot if it matches (assumes we're replacing this item)
        if(delivery_address && other_address && other_address instanceof BuildingEquipSlotAddress && other_address.equals(delivery_address) &&
           other_spec['limited_equipped'] == product_spec['limited_equipped']) { return; }

        if(other_spec && other_spec['limited_equipped']==product_spec['limited_equipped']) {
            count += 1;
        }
    };
    player.equipped_item_iter(count_func);
    player.crafting_queue_ingredients_and_products_iter(count_func);
    return count;
};

/** search player for an item with the given name
 * @param {string} name
 * @param {number=} min_count
 * @param {boolean=} check_mail
 * @param {boolean=} check_crafting
 */
player.has_item = function(name, min_count, check_mail, check_crafting) {
    if(!min_count) { min_count = 1; }
    var count = 0;
    var func = function(x) {
        if(x['spec'] == name) {
            count += ('stack' in x ? x['stack'] : 1);
            if(count >= min_count) {
                return true;
            }
        }
        return false;
    };
    player.stored_item_iter(func); if(count >= min_count) { return true; }
    player.equipped_item_iter(func); if(count >= min_count) { return true; }
    if(check_mail) { player.mail_attachments_iter(func); }; if(count >= min_count) { return true; }
    if(check_crafting) { player.crafting_queue_ingredients_and_products_iter(func); }; if(count >= min_count) { return true; }
    return false;
}
/** search player for an item with the given name and return how many we have
 * @param {string} name
 * @param {boolean=} check_mail
 * @param {boolean=} check_crafting
 */
player.count_item = function(name, check_mail, check_crafting) {
    var count = 0;
    var func = function(x) {
        if(x['spec'] == name) {
            count += ('stack' in x ? x['stack'] : 1);
        }
        return false;
    };
    player.stored_item_iter(func);
    player.equipped_item_iter(func);
    if(check_mail) { player.mail_attachments_iter(func); }
    if(check_crafting) { player.crafting_queue_ingredients_and_products_iter(func); }
    return count;
}

player.has_item_equipped = function(item_name) {
    var found = false;
    var func = function(x) {
        if(x['spec'] == item_name) {
            found = true;
            return true;
        }
        return false;
    };
    player.equipped_item_iter(func); if(found) { return found; }
    return false;
}

function is_ai_user_id_range(id) { return (id > 0 && id <= 1100); }
function home_base_id(user_id) { return 'h' + user_id.toString(); }

// NOTE: "Friend" represents AIs, True Facebook Friends, and "Rivals" (strangers the server gives you to attack)
// to differentiate, use is_ai() and is_real_friend

/** @constructor */
function Friend(user_id, battle_count, last_battle_time, is_real_friend, info) {
    this.user_id = user_id;
    this.battle_count = battle_count;
    this.last_battle_time = last_battle_time;
    this.is_real_friend = !!is_real_friend;

    // store some PlayerCache properties to preserve them even across a clear()
    if(!info) { throw Error('no pcache_data for '+this.user_id.toString()); }
    this.facebook_id_memo = (info['facebook_id'] && info['facebook_id'] !== -1 && info['facebook_id'] !== '-1') ? info['facebook_id'].toString() : null;
    this.social_id_memo = info['social_id'] || null;
    this.is_ai_memo = (info['social_id'] == 'ai' || (info['facebook_id'] && (info['facebook_id'] === -1 || info['facebook_id'] === '-1')));
    this.ui_name_memo = PlayerCache._get_ui_name(info) || 'Unknown(Friend)';
    this.player_level_memo = info['player_level'] || 1;
}

Friend.prototype.get_facebook_id = function() { return this.facebook_id_memo; };
Friend.prototype.get_social_id = function() { return this.social_id_memo; };
Friend.prototype.is_ai = function() { return this.is_ai_memo; };
Friend.prototype.get_ui_name = function() { return this.ui_name_memo; };
Friend.prototype.is_giftable = function() {
    return !this.is_ai() && player.resource_gifts_enabled() && !player.cooldown_active('send_gift:'+this.user_id.toString());
};
Friend.prototype.get_player_level = function() {
    if(this.is_ai_memo) { return this.player_level_memo; } // assume AI levels do not change
    var info = PlayerCache.query_sync_fetch(this.user_id);
    if(info) {
        return info['player_level'] || 1;
    }
    return this.player_level_memo; // fallback
};

Friend.prototype.classify_ai_difficulty = function() {
    var p_level = player.resource_state['player_level'];
    var gap = (p_level >= 5 ? 5 : 3);
    if(this.player_level_memo < 3) {
        return 'easy';
    } else if(this.player_level_memo < 9) {
        return 'medium';
    } else if(this.player_level_memo < 15) {
        return 'hard';
    } else if(this.player_level_memo < 25) {
        return 'monstrous';
    } else {
        return 'extreme';
    }
};

function get_alliance_logo_asset(logo) {
    if(logo) {
        var name = 'alicon_'+logo.toString();
        if(name in GameArt.assets) {
            return name;
        }
    }
    return 'inventory_unknown';
}

// fungible items go immediately into resource storage
function fungible_inventory_item_can_fit(spec, stack) {
    if(spec['resource'] == 'gamebucks') {
        return true;
    } else if(spec['resource'] in player.resource_state) {
        if(stack + player.resource_state[spec['resource']][1] <= player.resource_state[spec['resource']][0]) {
            return true;
        }
    }
    return false;
}

function inventory_item_can_fit(item, inventory, max_usable_inventory) {
    var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
    var togo = ('stack' in item ? item['stack'] : 1);

    if(spec['fungible'] && !fungible_inventory_item_can_fit(spec, 1)) { // check for at least 1 unit to fit
        return false;
    }

    // open slot
    if(inventory.length < max_usable_inventory) { return true; }

    // can stack with existing (returns true as long as 1 can fit)

    var stack_max = (spec['stack_max'] || 1);
    var orig_stack = togo;
    for(var i = 0; i < inventory.length; i++) {
        var inv = inventory[i];
        if(inv['spec'] === item['spec']) {
            var inv_stack = ('stack' in inv? inv['stack'] : 1);
            if(inv_stack < stack_max) {
                togo -= (stack_max - inv_stack);
                if(togo <= 0) { break; }
            }
        }
    }
    return (togo < orig_stack); // return true if ANY one can be taken from the stack
}

function inventory_items_can_all_fit(items, inventory, max_usable_inventory) {
    // operate on a copy of the inventory
    var scratch = [];
    for(var i = 0; i < inventory.length; i++) {
        scratch.push(goog.object.clone(inventory[i]));
    }
    for(var i = 0; i < items.length; i++) {
        var item = items[i];
        var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
        var stack_max = (spec['stack_max'] || 1);
        var togo = ('stack' in item ? item['stack'] : 1);

        if(spec['fungible'] && !fungible_inventory_item_can_fit(spec, togo)) { // check for entire stack to fit
            return false;
        }

        // check for stackable item
        for(var j = 0; j < scratch.length; j++) {
            var inv = scratch[j];
            if(inv['spec'] === item['spec']) {
                var inv_stack = ('stack' in inv? inv['stack'] : 1);
                if(inv_stack < stack_max) {
                    var added = Math.min(togo, (stack_max - inv_stack))
                    togo -= added;
                    inv['stack'] = inv_stack + added;
                }
            }
        }
        if(togo <= 0) { continue; } // able to accommodate everything just by stacking
        if(scratch.length >= max_usable_inventory) { return false; } // now we need a free slot
        scratch.push(goog.object.clone(item));
    }
    return true;
}

function get_crafting_recipe_ui_name(spec) { // XXXXXX move to ItemDisplay.js
    if('ui_name' in spec) {
        return spec['ui_name'];
    }
    if(spec['product'][0]['spec']) {
        return ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(spec['product'][0]['spec']));
    }
    throw Error('cannot determine ui_name for crafting recipe '+spec['name']);

}
function get_crafting_recipe_icon(spec) { // XXXXXX move to ItemDisplay.js
    if('icon' in spec) {
        return spec['icon'];
    }
    if(spec['product'][0]['spec']) {
        return ItemDisplay.get_inventory_item_spec(spec['product'][0]['spec'])['icon'];
    }
    throw Error('cannot determine icon for crafting recipe '+spec['name']);
}

// get a spec quantity that is possibly level-dependent (list indexed by level-1)
player.get_leveled_quantity = function(qty) {
    if((typeof qty) === 'number') {
        return qty;
    } else {
        // assume it's an array
        return qty[player.resource_state['player_level']-1];
    }
};

// note: only looks at friendly units, used for drag selection
function find_objects_in_screen_rect(xy0, xy1, look_for_spec) {
    var found_units = [];
    var mouserect = [ [xy0[0], xy1[0]],
                      [xy0[1], xy1[1]] ];

    // drag-selection seems to feel better with a smaller amount of fuzz than click-selection
    var position_fuzz = 2;

    for(var id in session.cur_objects.objects) {
        var temp = session.cur_objects.objects[id];
        if(look_for_spec && (temp.spec !== look_for_spec)) { continue; }
        if(!temp.is_mobile()) { continue; }
        if(temp.is_destroyed()) { continue; }
        if(temp.team != 'player' || (session.is_quarry() && !session.has_deployed && session.region.data['storage'] != 'nosql')) { continue; }
        var objji = temp.interpolate_pos();
        var asset = GameArt.assets[temp.get_leveled_quantity(temp.spec['art_asset'])];
        if(asset.detect_rect(ortho_to_screen(objji), temp.interpolate_facing(), client_time, 'normal', mouserect, view_zoom, position_fuzz)) {
            found_units.push(temp);
        }
    }
    return found_units;
};

function find_object_at_screen_pixel(xy, ji, include_unselectable) {
    // note: prioritize units over buildings if there is any overlap
    // also sort units by Z order
    var found_units = [];
    var found_building = null;

    // fudge factor for clicking on units - you can be off by this many pixels (at zoom=1) and still hit
    var position_fuzz = 2;
    if(player.tutorial_state === 'click_on_rover_action') {
        position_fuzz = 10;
    }

    // could speed up with some form of 2D data structure
    for(var id in session.cur_objects.objects) {
        var temp = session.cur_objects.objects[id];
        var objji = temp.interpolate_pos();

        if(temp.is_inert() && !player.is_cheater) {
            if(temp.spec['is_scenery'] && !temp.spec['has_tooltip']) {
                continue;
            }
            if(!include_unselectable && !temp.spec['selectable']) {
                continue;
            }
        }

        if(temp.is_invisible() && temp.team !== 'player') { continue; }

        if(!temp.is_mobile()) {
            // in combat, skip destroyed buildings (but in peacetime keep them, because you want the context menu to repair)
            if(temp.is_destroyed() && session.has_attacked && (session.viewing_base.base_type != 'quarry' || session.viewing_base.base_landlord_id != session.user_id)) { continue; }

            // non-mobile

            // check orthogonal grid position against object's base area
            var bounds = get_grid_bounds(objji, temp.spec['gridsize']);
            if((ji[0] >= bounds[0][0] && ji[0] < bounds[0][1] && ji[1] >= bounds[1][0] && ji[1] < bounds[1][1]) ||
               (temp.spec['click_detection'] == 'sprite' && GameArt.assets[temp.get_leveled_quantity(temp.spec['art_asset'])].detect_click(ortho_to_screen(objji),
                                                                                                                                           0, client_time, 'normal', xy, view_zoom, position_fuzz))) {
                found_building = temp;
                // do not break out of loop
            }

        } else {
            // mobile units use the sprite hit detection code
            if(temp.is_destroyed()) { continue; }

            var asset = GameArt.assets[temp.get_leveled_quantity(temp.spec['art_asset'])];
            if(asset.detect_click(ortho_to_screen_3d([objji[0], temp.altitude, objji[1]]), temp.interpolate_facing(), client_time, 'normal', xy, view_zoom, position_fuzz)) {
                found_units.push(temp);
            }
        }
    }

    if(found_units.length > 0) {
        var ret;
        if(found_units.length < 2) {
            ret = found_units[0];
        } else {
            // return unit with highest Z coordinate
            var high_unit = found_units[0], high_z = -1;
            for(var i = 0; i < found_units.length; i++) {
                var unit_xy = found_units[i].interpolate_pos();
                var unit_z = ortho_to_depth(unit_xy);
                if(unit_z > high_z) {
                    high_z = unit_z;
                    high_unit = found_units[i];
                }
            }
            ret = high_unit;
        }
    } else {
        ret = found_building;
    }

    if(player.tutorial_state === 'click_on_rover_action') {
        if(ret && ret.spec['name'] != gamedata['tutorial'][player.tutorial_state]['unit_type']) {
            return null;
        }
    } else if(player.tutorial_state === 'move_rover_action') {
        return null;
    }
    return ret;
}

var voxel_map_accel = new VoxelMapAccelerator.VoxelMapAccelerator([0,0], 1);
var team_map_accel = new TeamMapAccelerator.TeamMapAccelerator();

// stats tracking for map queries
var MAP_DEBUG = 0;
var map_queries_by_tag = {'ticks':0};
function map_query_stats() {
    console.log("MAP QUERIES:");
    for(var k in map_queries_by_tag) {
        if(k == 'ticks') { continue; }
        var msec = 1000.0*map_queries_by_tag[k]/(1.0*map_queries_by_tag['ticks']);
        if(msec >= 0.1) {
            console.log(k + ' ' + msec.toFixed(1) + 'ms per tick');
        }
    }
}

// NEW object query function
// params:
// ignore_object = ignore this single object
// exlude_barriers = do not return any barrier objects
// include_collidable_inerts = include objects that are inert
// only_team = only return objects on this team
// mobile_only = only return mobile units
// exclude_flying = exclude flying mobile units
// flying_only = only return flying mobile units
// exclude_invisible_to = ignore objects that are not visible to this team

/** @param {!Array.<number>} loc
 *  @param {number} dist
 *  @param {{nearest_only:(boolean|undefined),
 *           tag:(string|undefined),
 *           only_team:(string|null|undefined),
 *           ignore_object:(Object|undefined),
 *           exclude_barriers:(boolean|undefined),
 *           exclude_invul:(boolean|undefined),
 *           include_collidable_inerts:(boolean|undefined),
 *           include_destroyed:(boolean|undefined),
 *           exclude_full_health:(boolean|undefined),
 *           mobile_only:(boolean|undefined),
 *           exclude_flying:(boolean|undefined),
 *           flying_only:(boolean|undefined),
 *           exclude_invisible_to:(string|null|undefined)}} params
 * @return {!Array.<!GameTypes.GameObjectQueryResult>}
 */
function query_objects_within_distance(loc, dist, params) {
    if(dist <= 0) {
        return [];
    }
    if(params.include_destroyed) {
        throw Error('include_destroyed not supported'); // since they are not added to the accelerators
    }

    /** @type {!Array.<!GameTypes.GameObjectQueryResult>} */
    var ret = [];
    var neardist = 99999999;
    var nearest = null; // obj/dist/pos tuple representing nearest object

    // log it
    var debug_tag = 'tag:' + (params.tag || 'UNKNOWN');
    if(params.nearest_only) { debug_tag += '_nearest_only'; }
    if(params.only_team) { debug_tag += '_one_team'; } else { debug_tag += '_any_team'; }
    var start_time;
    if(MAP_DEBUG) {
        start_time = (new Date()).getTime();
    }

    var use_accel = gamedata['client']['use_map_accel'];

    if(use_accel && params.only_team && !voxel_map_accel.has_any_of_team(params.only_team)) {
        // no objects exist
        debug_tag += ':EMPTY';
    } else if(use_accel && (dist < gamedata['client']['map_accel_limit'])) {
        // do not use map accelerator for very large query radii, since it results in lots of unnecessary extra work
        // due to big objects overlapping many cells
        var filter = (params.only_team || 'ALL');
        debug_tag += ':LOCAL';
        // TEMPORARY - duplicated code
        var bounds = voxel_map_accel.get_circle_bounds_xy_st(loc, dist);
        if(MAP_DEBUG >= 2) {
            var area_s = (bounds[1][1]-bounds[1][0]);
            var area_t = (bounds[0][1]-bounds[0][0]);
            debug_tag += '('+area_s.toString()+','+area_t.toString()+')';
        }
        var seen_ids = {};
        //console.log(" Y "+bounds[1][0]+"-"+bounds[1][1]+" X "+bounds[0][0]+"-"+bounds[0][1]);
        for(var t = bounds[1][0]; t < bounds[1][1]; t++) {
            for(var s = bounds[0][0]; s < bounds[0][1]; s++) {
                var objlist = voxel_map_accel.objects_at_st([s,t], filter);
                if(!objlist) { continue; }
                for(var i = 0, len = objlist.length; i < len; i++) {
                    var temp = objlist[i];

                    if(temp.id in seen_ids) { continue; }
                    seen_ids[temp.id] = 1;

                    if(params.ignore_object && temp === params.ignore_object) { continue; }
                    if(params.exclude_barriers && temp.spec['name'] === 'barrier') { continue; }
                    if(params.exclude_invul && temp.is_invul()) { continue; }
                    if(temp.is_inert() && (!params.include_collidable_inerts || !temp.spec['unit_collision_gridsize'][0])) { continue; }
                    if(params.only_team && params.only_team !== temp.team) { continue; }
                    if(!params.include_destroyed && temp.is_destroyed()) { continue; }
                    if(params.exclude_full_health && !temp.is_damaged()) { continue; }
                    if(params.mobile_only && !temp.is_mobile()) { continue; }
                    if(params.exclude_flying && temp.is_flying()) { continue; }
                    if(params.flying_only &&!temp.is_flying()) { continue; }
                    if(params.exclude_invisible_to && temp.is_invisible() && (temp.team !== params.exclude_invisible_to)) { continue; }



                    // note: it is OK to use the quantized combat-sim position of the unit here, as long as this is only called
                    // from combat-sim step functions
                    var xy = temp.raw_pos();
                    var temp_dist = vec_distance(loc, xy) - temp.hit_radius();
                    if(temp_dist < dist) {
                        var r = new GameTypes.GameObjectQueryResult(temp, temp_dist, xy);
                        ret.push(r);
                        if(temp_dist < neardist) {
                            nearest = r;
                            neardist = temp_dist;
                        }
                    }
                }
            }
        }
    } else {
        // big O(N) query
        debug_tag += ':GLOBAL';
        var filter = (params.only_team || 'ALL');
        var objlist = team_map_accel.objects_on_team(filter);
        if(objlist) {
            for(var i = 0, len = objlist.length; i < len; i++) {
                temp = objlist[i];
                if(params.ignore_object && temp === params.ignore_object) { continue; }
                if(params.only_team && params.only_team !== temp.team) { continue; }
                if(params.exclude_barriers && temp.spec['name'] === 'barrier') { continue; }
                if(params.exclude_invul && temp.is_invul()) { continue; }
                if(temp.is_inert() && (!params.include_collidable_inerts || !temp.spec['unit_collision_gridsize'][0])) { continue; }
                if(!params.include_destroyed && temp.is_destroyed()) { continue; }
                if(params.exclude_full_health && !temp.is_damaged()) { continue; }
                if(params.mobile_only && !temp.is_mobile()) { continue; }
                if(params.exclude_flying && temp.is_flying()) { continue; }
                if(params.flying_only &&!temp.is_flying()) { continue; }
                if(params.exclude_invisible_to && temp.is_invisible() && (temp.team !== params.exclude_invisible_to)) { continue; }

                // note: it is OK to use the "retarded" combat-sim position of the unit here, as long as this is only called
                // from combat-sim step functions
                var xy = temp.raw_pos(); // temp.interpolate_pos();
                var temp_dist = vec_distance(loc, xy) - temp.hit_radius();
                if(temp_dist < dist) {
                    var r2 = new GameTypes.GameObjectQueryResult(temp, temp_dist, xy);
                    ret.push(r2);
                    if(temp_dist < neardist) {
                        nearest = r2;
                        neardist = temp_dist;
                    }
                }
            }
        }
    }

    if(MAP_DEBUG) {
        var end_time = (new Date()).getTime();
        var secs = (end_time - start_time)/1000;
        map_queries_by_tag[debug_tag] = (map_queries_by_tag[debug_tag] || 0) + secs;
    }

    if(params.nearest_only) {
        return (!!nearest ? [/** @type {!GameTypes.GameObjectQueryResult} */ (nearest)] : []);
    } else {
        return ret;
    }
}

// update resource_state from server protocol message
var update_resources_is_first_call = true;
function update_resources(data, init) {
    var res_changed = false, res_reduced = false;
    for(var res in gamedata['resources']) {
        if(data[res][1] != player.resource_state[res][1]) {
            res_changed = true;
            if(data[res][1] < player.resource_state[res][1]) {
                res_reduced = true;
            }
        }
    }
    if(res_changed) {
        if(init && update_resources_is_first_call) {
            // do not cause ticker effects on very first call
        } else {
            if(player.last_resource_time <= 0) {
                var delay;
                if(res_reduced) {
                    // do not delay ticker effect on reduction
                    delay = 0;
                } else {
                    delay = gamedata['client']['resource_ticker_delay'];
                }
                player.last_resource_time = client_time + delay;
            }

            // trigger flashes
            // NOTE: this will overlap with the flashes from receiving the HARVESTED_RESOURCES message,
            // but checking for flash_X_time <= 0 means that the flash should be triggered correctly
            // because the server sends HARVESTED_RESOURCES *before* the actual resource level update
            for(var res in gamedata['resources']) {
                if(data[res][1] > player.resource_state[res][1] && player.flash_res_time[res] <= 0) {
                    player.flash_res_time[res] = client_time;
                }
            }
        }
        for(var res in gamedata['resources']) {
            player.last_resource_state[res] = player.resource_state[res][1];
        }

        session.clear_building_idle_state_caches(); // for ALL buildings
    }

    var currency = (player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks' ? 'gamebucks' : 'facebook_credits');
    if(data[currency] != player.resource_state[currency]) {
        if(init && update_resources_is_first_call) {
        } else {
            if(player.last_credits_time <= 0) {
                player.last_credits_time = client_time;
            }
            if(data[currency] > player.resource_state[currency] && player.flash_credits_time <= 0) {
                player.flash_credits_time = client_time;
            }
        }
        player.last_resource_state[currency] = player.resource_state[currency];
    }

    update_resources_xp(data['xp']);

    player.resource_state["space"] = data["space"];
    for(var res in gamedata['resources']) {
        player.resource_state[res] = data[res];
    }
    player.resource_state["gamebucks"] = data["gamebucks"];
    player.resource_state["facebook_credits"] = data["facebook_credits"];
    player.resource_state["player_level"] = data["player_level"];
    player.resource_state["protection_end_time"] = data["protection_end_time"];

    if(init && update_resources_is_first_call) {
        update_resources_is_first_call = false;
    }
}

function update_resources_xp(data_xp) {
    if(data_xp != player.resource_state['xp']) {
        player.last_resource_state['xp'] = player.resource_state['xp'];
        player.last_xp_time = client_time;
    }
    player.resource_state["xp"] = data_xp;
}

function update_enemy_resources(data) {
    for(var res in gamedata['resources']) {
        enemy.resource_state[res] = data[res];
    }
    enemy.resource_state["player_level"] = data["player_level"];
    enemy.resource_state["protection_end_time"] = data["protection_end_time"];
}

// game units

player.virtual_units = {};

var MAX_UNIT_SPRITE_SIZE = 64; // max pixel dimensions of all unit sprites (for culling)
var FRAME_RATE_CAP = 60; // maximum screen update rate, in Hz
if(1) {
    var x = get_query_string('frame_rate_cap');
    if(x) { FRAME_RATE_CAP = parseInt(x,10); }
}
var USING_REQUESTANIMATIONFRAME = false;
var LAST_ANIM_FRAME_TIMEOUT = 0;

var TICK_INTERVAL = 0.25; // # of seconds between unit simulation ticks
var last_tick_time = 0; // client_time at which last unit simulation tick was run

// temporary bridge until entire combat engine is converted to ticks
/** @param {number} t
    @return {!CombatEngine.TickCount} */
function absolute_time_to_tick(t) {
    var delta = t - client_time;
    return new CombatEngine.TickCount(session.combat_engine.cur_tick.get() + Math.floor(delta/TICK_INTERVAL + 0.5));
};
/** @param {number} t
    @return {!CombatEngine.TickCount} */
function relative_time_to_tick(t) {
    return new CombatEngine.TickCount(Math.floor(t/TICK_INTERVAL + 0.5));
};

var player_combat_time_scale = 1.0; // additional time scaling applied by playfield speed bar controls
var player_playfield_speed = 0; // incremental version, used to drive player_combat_time_scale
function update_player_combat_time_scale(new_speed) {
    var limits = gamedata['client']['playfield_speed_limits'];
    player_playfield_speed = clamp(new_speed, limits[0], limits[1]);
    player_combat_time_scale = gamedata['client']['playfield_speeds'][player_playfield_speed.toFixed(0)] || 1;
    //session.set_attack_finish_time(session.true_attack_finish_time);
};
function combat_time_scale() {
    var sc = get_player_stat(player.stattab, 'combat_time_scale');
    return player_combat_time_scale * sc;
};

// note: to preserve balance, attack_finish_time might have to be adjusted according to the player_combat_time_scale!
session.set_attack_finish_time = function(new_time) {
    session.attack_finish_time = new_time;
};

// display session.attack_finish_time, but in units of seconds unaffected by player_combat_time_scale
session.ui_attack_time_togo = function() {
    if(session.attack_finish_time <= server_time) {
        return 0;
    }
    return session.attack_finish_time - server_time;
};

var last_combat_save = 0;
var last_server_ping = 0;
var last_proxy_keepalive = 0;

// chat ping interval is obtained from gamedata
var last_chat_ping = 0;

// for spacing out rapid-fire loot CombatText notifications
var last_loot_text_time = 0;
var last_loot_text_count = 0;
var last_loot_text_pos = null;
var tick_astar_queries_left = 0;

function run_unit_ticks() {
    if(client_time - last_tick_time > TICK_INTERVAL/combat_time_scale()) {
        // record time at which this tick was computed
        last_tick_time = client_time;

        if(astar_map) {
            astar_map.cleanup();
        }

        // Limit the number of A* path queries that can be run per
        // unit tick. Massive numbers of units re-targeting at the same time often
        // causes performance glitches
        tick_astar_queries_left = gamedata['client']['astar_max_queries_per_tick'];

        // randomly permute the order of objects each tick, so we don't starve
        // out objects waiting for A*
        // http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
        // (note: will need to be deterministically seeded if we want deterministic combat)

        var obj_list = [null];
        var i = 0;
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            // ignore inerts with no auras or contiuously-casting spells on them
            if(obj.is_inert() && obj.auras.length === 0 && !('continuous_cast' in obj.spec)) { continue; }

            var j = Math.floor(Math.random()*(i+1));
            obj_list[i] = obj_list[j];
            obj_list[j] = obj;
            i++;
        }

        // rebuild map query acceleration data structure
        voxel_map_accel.clear();
        team_map_accel.clear();
        map_queries_by_tag['ticks'] += 1;
        if(obj_list[0] !== null) {
            for(i = 0; i < obj_list.length; i++) {
                var obj = obj_list[i];

                // check for any objects in blocked areas
                if(PLAYFIELD_DEBUG && obj.is_mobile() && !obj.is_destroyed()) {
                    playfield_check_path([obj.pos, obj.next_pos], 'pos->next_pos at beginning of tick');
                }

                if(!obj.is_destroyed()) {
                    // don't bother adding destroyed objects, since no users of query_objects_within_distance() look for destroyed things
                    team_map_accel.add_object(obj);
                    voxel_map_accel.add_object(obj);
                }
            }
            for(i = 0; i < obj_list.length; i++) {
                obj_list[i].run_tick();
            }
        }

        // run phantom unit controllers
        tick_astar_queries_left = -1; // should not disturb actual unit control
        goog.array.forEach(SPFX.get_phantom_objects(), function(obj) {
            obj.run_control();
            obj.update_facing();
        });

        apply_queued_damage_effects();
        flush_dirty_objects({urgent_only:true, skip_check:true});
        session.combat_engine.cur_tick.inc();
    }
}

// cause all defending units/turrets to recalculate their threatlists
// called when new attacking units are spawned
function invalidate_defender_threatlists() {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(!obj.is_destroyed() &&
           ((session.home_base && obj.team == 'player') || (!session.home_base && obj.team != 'player')) &&
           (obj.is_building() || obj.is_mobile())) {
            if(obj.ai_threatlist !== null) {
                obj.ai_threatlist_dirty = true;
            }
        }
    }
}

// cause all units to recalculate their threatlists
// called when map blockage changes, because
// the current system for setting threatlist depends on A*
// queries to determine accessibility
function invalidate_all_threatlists() {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(!obj.is_destroyed() &&
           (obj.is_building() || obj.is_mobile())) {
            if(obj.ai_threatlist !== null) {
                obj.ai_threatlist_dirty = true;
            }
        }
    }
}

// cause all mobile units to recalculate their movement paths
// called when map blockage changes
function invalidate_unit_paths() {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.is_mobile()) {
            obj.path_valid = false;
        }
    }
}

/**
 * @constructor
 * @extends GameObject
 */
function Mobile() {
    goog.base(this);
    this.squad_id = null;
    this.orders = [];
    this.patrol = null;

    // client side reference only, the authoritive source is player.unit_repair_queue
    this.under_repair_finish = -1;

    this.ai_dest = null;
    this.ai_aggressive = false;

    // Movement of mobile units is handled by the client using a
    // StarCraft-style deterministic simulation. The server only
    // tracks movement to the coarseness of the map grid (like
    // buildings), which is recorded in this.x and this.y. Every few
    // seconds we send updates using OBJECT_COMBAT_UPDATES telling the
    // server roughly where the object is.

    /** @type {!Array.<number>} */
    this.pos = [-1,-1]; // position at end of last computed tick
    /** @type {Array.<number>} */
    this.vel = [0,0];     // velocity at end of last computed tick
    /** @type {!Array.<number>} */
    this.next_pos = [-1,-1]; // position at beginning of next tick

    /** @type {number} altitude above ground, if flying */
    this.altitude = 0;

    /** @type {?Array.<number>} */
    this.dest = [-1,-1]; // final movement destination

    /** @type {!Array.<!Array.<number>>} */
    this.path = []; // list of xy coords along A* path
    this.path_valid = false; // whether the A* path can be re-used
    this.path_new = false; // whether the A* path was just re-computed (for debugging only)
    this.stuck_loc = null; // state for tracking A* frustration

    // random vector for offsetting draw location
    if(gamedata['client']['unit_draw_scatter']) {
        // uniformly distributed point in unit circle
        var theta = 2*Math.PI*Math.random();
        var sqrt_r = Math.sqrt(Math.random());
        this.draw_offset = [sqrt_r*Math.cos(theta), sqrt_r*Math.sin(theta)];
    } else {
        this.draw_offset = null;
    }
}

goog.inherits(Mobile, GameObject);

Mobile.prototype.is_flying = function() { return this.spec['flying'] || false; };
Mobile.prototype.passes_through_walls = function() { return this.spec['flying'] || this.spec['noclip']; };
Mobile.prototype.is_under_repair = function() { return this.under_repair_finish > 0; };
Mobile.prototype.combat_power_factor = function() { return 1; };

// return true if the object should be invisible to opponents
Mobile.prototype.is_invisible = function() {
    // mobile units only go invisible when:
    // 1) invis_on_hold: 1 in unit spec
    // 2) unit is in hold position mode
    // 3) unit is within a base owned by the unit's owner (i.e. it's playing defense, not offense)
    // 4) unit is NOT in a quarry or naked squad
    if(this.spec['invis_on_hold'] && this.orders && this.orders.length == 1 &&
       !this.orders[0]['aggressive'] &&
       this.orders[0]['state'] == ai_states.AI_ATTACK_STATIONARY) {
        // check if in friendly base
        if((this.team === 'player' && session.viewing_user_id === session.user_id) ||
           (this.team === 'enemy' && session.viewing_user_id !== session.user_id)) {
            if(!session.is_quarry() && !session.is_squad()) {
                return true;
            }
        }
    }
    return false;
};

function get_player_stat(stattab, stat) { return ModChain.get_stat(stattab['player'][stat], null); }

function get_unit_stat(stattab, specname, stat, default_value) {
    if(specname in stattab['units']) {
        return ModChain.get_stat(stattab['units'][specname][stat]||null, default_value);
    }
    return default_value;
}

// this version of get_auto_spell disregards modstats - this is only
// to be used when getting stats for a new building you have not built
// yet, or a unit you have not unlocked.
function get_auto_spell_raw(spec) {
    if(('spells' in spec) && (spec['spells'].length > 0)) {
        var spellname = spec['spells'][0];
        if(spellname) {
            var auto_spell = gamedata['spells'][spellname];
            if(auto_spell['activation'] === 'auto') {
                return auto_spell;
            }
        }
    }
    return null;
}

// includes player or enemy modstats
function get_auto_spell_for_unit(player_or_enemy, unit_spec) {
    if(('spells' in unit_spec) && (unit_spec['spells'].length > 0)) {
        var spellname = get_unit_stat(player_or_enemy.stattab, unit_spec['name'], 'weapon', unit_spec['spells'][0]);
        if(spellname) {
            var auto_spell = gamedata['spells'][spellname];
            if(auto_spell['activation'] === 'auto') {
                return auto_spell;
            }
        }
    }
    return null;
}
function get_auto_spell_level_for_unit(player_or_enemy, unit_spec, unit_level) {
    return get_unit_stat(player_or_enemy.stattab, unit_spec['name'], 'weapon_level', unit_level);
}

Mobile.prototype.get_auto_spell = function() {
    var owner = (this.team === 'player' ? player : enemy);
    return get_auto_spell_for_unit(owner, this.spec);
};
Mobile.prototype.get_auto_spell_level = function() {
    var owner = (this.team === 'player' ? player : enemy);
    return get_auto_spell_level_for_unit(owner, this.spec, this.level);
};

function get_auto_spell_for_item(item_spec) {
    var spellname = ItemDisplay.get_inventory_item_weapon_spellname(item_spec);
    if(spellname) {
        return gamedata['spells'][spellname];
    }
    return null;
}

function mobile_cost_to_repair(spec, level, cur_hp, max_hp, player) {
    var cost_ratio = ('unit_repair_resources' in spec ? spec['unit_repair_resources'] : player.get_any_abtest_value('unit_repair_resources', gamedata['unit_repair_resources']));
    var time_ratio = ('unit_repair_time' in spec ? spec['unit_repair_time'] : player.get_any_abtest_value('unit_repair_time', gamedata['unit_repair_time']));

    var health_ratio = 1.0 - 1.0*cur_hp/max_hp;

    var cost_time = get_leveled_quantity(spec['build_time'], level);
    var spd = get_unit_stat(player.stattab, spec['name'], 'repair_speed', 1);
    var rep_time = Math.max(1, Math.floor(time_ratio * health_ratio * cost_time / spd));
    var ret = {'time':rep_time};

    for(var res in gamedata['resources']) {
        ret[res] = Math.max(0, Math.floor(cost_ratio * health_ratio * get_leveled_quantity(spec['build_cost_'+res] || 0, level)));
    }

    return ret;
}

Mobile.prototype.cost_to_repair = function(player) { return mobile_cost_to_repair(this.spec, this.level, this.hp, this.max_hp, player); };

Mobile.prototype.get_raw_stats = function() {
    goog.base(this, 'get_raw_stats');
    this.combat_stats.maxvel = player.get_any_abtest_value('global_maxvel_scale', gamedata['map']['global_maxvel_scale']) * this.get_leveled_quantity(this.spec['maxvel']);
    this.combat_stats.erratic_flight = 0;
};

Mobile.prototype.modify_stats_by_modstats = function() {
    var tbl = null;
    if(this.team === 'player') {
        tbl = (player.stattab['units']||{})[this.spec['name']];
    } else {
        tbl = (enemy.stattab['units']||{})[this.spec['name']];
    }
    if(tbl) { this.modify_stats_by_modstats_table(tbl); }
};

Mobile.prototype.receive_state = function(data, init, is_deploying) {
    var old_x = this.x, old_y = this.y;
    goog.base(this, 'receive_state', data, init, is_deploying);
    this.squad_id = data.shift();
    var orders = data.shift();
    var patrol = data.shift();

    if(patrol !== null) { this.patrol = !!patrol; }

    if(init || old_x != this.x || old_y != this.y) {
        // apply position update

        this.pos = [this.x, this.y];
        var ncells = session.viewing_base.ncells();
        if(this.pos[0] < 0 || this.pos[0] >= ncells[0] || this.pos[1] < 0 || this.pos[1] >= ncells[1]) {
            console.log('received state for out-of-bounds unit! '+this.pos[0]+' '+this.pos[1]);
            this.pos[0] = clamp(this.pos[0], 0, ncells[0]-1);
            this.pos[1] = clamp(this.pos[1], 0, ncells[1]-1);
        }

        this.next_pos = [this.pos[0], this.pos[1]];
        this.dest = [this.pos[0], this.pos[1]];
    }

    this.altitude = (this.get_leveled_quantity(this.spec['altitude'] || 0));
    if(this.altitude != 0 && session.viewing_base.base_climate_data['fly_at_ground_level']) {
        // set altitudes low, but not to zero, so it doesn't screw up anti-air/anti-ground weapon behavior
        this.altitude = 1.0;
    }

    if(init) {
        // on object creation, apply persistent orders to AI state
        // however, do not accept AI_STOP as it is almost certainly not what the player wants
        // also, do not apply orders to player's units when being deployed in an attack
        if(orders && orders[0]['state'] != ai_states.AI_STOP &&
           (this.team != 'player' || !is_deploying || session.home_base)) {
            this.orders = orders;
        } else {
            // no effect, use default AI state
            var order = {'state': this.ai_state};
            if(this.ai_state === ai_states.AI_ATTACK_ANY && is_deploying) {
                order['dest'] = null; // do not set "home" location
            } else {
                order['dest'] = [Math.floor(this.pos[0]),Math.floor(this.pos[1])];
            }

            this.orders = [order];

            // enable aggressive mode for invading units (except for player-owned units in manual mode)
            if(
                ((session.viewing_base.base_landlord_id !== session.user_id) && (this.team == 'player') &&
                 (get_preference_setting(player.preferences, 'auto_unit_control') ||
                  (('deploy_ai_order' in this.spec) && this.spec['deploy_ai_order']['aggressive']) ||
                  gamedata['client']['default_deploy_ai_order']['manual']['aggressive']
                 )) ||

                ((session.viewing_base.base_landlord_id === session.user_id) && (this.team != 'player'))) {
                this.ai_aggressive = true;
            }

            // propagate orders to server
            this.state_dirty |= obj_state_flags.ORDERS;
        }
        this.apply_orders();
    }

    // snoop update into my_army
    if(this.id in player.my_army) {
        var obj = player.my_army[this.id];
        obj['hp_ratio'] = this.hp/this.max_hp;
        obj['level'] = this.level;
    }

    if(is_deploying) {
        invalidate_defender_threatlists();
        if(unit_deployment_latency_high()) {
            // spread sound effect time out by the min flush interval, to approximate units arriving smoothly over that time
            add_unit_deployment_vfx('post_deploy', this.interpolate_pos(), this.spec, this.level, 2 * gamedata['client']['ajax_min_flush_interval']);
        }
    }
};

Mobile.prototype.apply_orders = function() {
    if(typeof this.pos === 'undefined') {
        throw Error('apply_orders on '+this.spec['name']+' with this.pos undefined');
    }

    if(this.orders.length > 0) {
        var ord = this.orders[0];
        this.ai_state = ord['state'];
        this.ai_target = null;
        if('target' in ord) {
            var target_id = ord['target'];
            if(target_id in session.cur_objects.objects) {
                this.ai_target = session.cur_objects.objects[target_id];
            }
        }
        if('dest' in ord) {
            if(ord['dest'] === null) {
                this.ai_dest = null;
            } else {
                this.ai_dest = [Math.floor(ord['dest'][0]), Math.floor(ord['dest'][1])];
            }
        } else {
            this.ai_dest = [Math.floor(this.pos[0]), Math.floor(this.pos[1])];
        }
        if('aggressive' in ord) {
            this.ai_aggressive = ord['aggressive'];
        }
        // note: if 'aggressive' not in ord, then do NOT change current state
        this.path_valid = false;
    }
};

Mobile.prototype.new_order = function(neword, replace) {
    if(replace || this.orders.length == 0 ||
       !ai_state_can_be_queued(this.orders[0]['state'])) {
        this.orders = [neword];

        // turn off patrolling
        this.patrol = null;
        this.state_dirty |= obj_state_flags.PATROL;

        this.apply_orders();
    } else {
        // limit max # of orders
        if(this.orders.length >= gamedata['client']['max_unit_orders']) { return; }

        // when patrolling, insert the new waypoint BEFORE the patrol_origin order
        if(this.patrol && this.orders.length >= 2) {
            var origin = -1;
            for(var i = 0; i < this.orders.length; i++) { if(this.orders[i]['patrol_origin']) { origin = i; break; } }
            if(origin < 0) { origin = this.orders.length-1; }
            this.orders.splice(origin, 0, neword);
        } else {
            this.orders.push(neword);
        }
    }
    this.state_dirty |= obj_state_flags.ORDERS;
};

/** quantized location as of last combat tick
    @override */
Mobile.prototype.raw_pos = function() { return this.pos; };

// interpolated location at current client_time
Mobile.prototype.interpolate_pos = function () {
    var progress = (visit_base_pending ? 1 : (client_time - last_tick_time)/(TICK_INTERVAL/combat_time_scale()));
    return vec_add(this.pos, vec_scale(progress, vec_sub(this.next_pos, this.pos)));
};

// interpolated location, with added offset for un-dogpiling units
Mobile.prototype.interpolate_pos_for_draw = function() {
    var pos = this.interpolate_pos();
    if(gamedata['client']['unit_draw_scatter']) {
        return vec_mad(pos, gamedata['client']['unit_draw_scatter'], this.draw_offset);
    }
    return pos;
};

GameObject.prototype.interpolate_facing = function() {
    var progress = (visit_base_pending ? 1 : (client_time - last_tick_time)/(TICK_INTERVAL/combat_time_scale()));
    return this.cur_facing + progress*(this.next_facing - this.cur_facing);
};

Mobile.prototype.run_ai = function() {
    if(this.ai_state === ai_states.AI_ATTACK_STATIONARY) {
        this.control_state = control_states.CONTROL_STOP;
    }

    // run this before the base class run_ai() because we may switch to AI_ATTACK_ANY
    if(this.ai_state === ai_states.AI_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO || this.ai_state === ai_states.AI_DEFEND_MOVE ||
       (this.ai_state === ai_states.AI_ATTACK_ANY && !this.ai_target)) {
        if(this.ai_dest && vec_equals(this.interpolate_pos(), this.ai_dest)) {
            // arrived at destination
            this.ai_stop();

            if(this.ai_state === ai_states.AI_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO || this.ai_state === ai_states.AI_DEFEND_MOVE) {
                this.next_ai_order();
            }
        } else {
            this.ai_move_towards(this.ai_dest, null, 'run_ai/ai_dest');
        }
    }

    goog.base(this, 'run_ai');

    // Anti-clumping

    // If the unit doesn't have anything important to do, then try to have it spread away from other close units.
    // We use a "gas diffusion" approach: treat the density of units as a scalar "pressure" and try to move the
    // unit along the gradient towards lower pressure.
    var declump_radius = player.get_any_abtest_value('unit_declump_radius', gamedata['client']['unit_declump_radius']);
    //console.log('declump? '+this.spec['name'] +' '+declump_radius.toString()+' pos '+this.interpolate_pos()[0].toString()+','+this.interpolate_pos()[1].toString()+' dest '+this.ai_dest[0].toString()+','+this.ai_dest[1].toString()+' ai_state '+ai_state_names[this.ai_state]+' ai_target '+(this.ai_target? this.ai_target.spec['name'] : 'none')+' control_state '+control_state_names[this.control_state]);

    if((declump_radius > 0) &&
       (tick_astar_queries_left !== 0 || !gamedata['client']['unit_declump_avoid_astar']) &&
       (this.ai_state === ai_states.AI_ATTACK_ANY || this.ai_state === ai_states.AI_ATTACK_STATIONARY || this.ai_state === ai_states.AI_ATTACK_MOVE || this.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO || this.ai_state === ai_states.AI_DEFEND_MOVE) &&
       (this.control_state === control_states.CONTROL_STOP || player.get_any_abtest_value('unit_declump_urgently',gamedata['client']['unit_declump_urgently']))) {
        // consider units this far away in pressure gradient calculation
        var gradient = [0,0]; // pressure gradient
        var pos = this.interpolate_pos(); // get our position

        // Compute contribution to pressure gradient of each nearby unit

        // This is an O(N^2) algorithm, but it works OK as long as the average number of units per grid
        // cell is low (in this game it's typically < 1). If there are lots of units per grid cell, then
        // it would be better to use a particle-cell model and accumulate unit density in a grid
        // data structure.

        var objlist = query_objects_within_distance(pos, declump_radius,
                                                    { ignore_object: this,
                                                      // should this also look at inerts? not sure...
                                                      // but, collidable inerts generally have a big extent, so I'm not sure
                                                      // what the point would be of including them. Also, performance is likely to suffer.
                                                      //include_collidable_inerts: true,
                                                      exclude_flying: !this.is_flying(),
                                                      flying_only: this.is_flying()
                                                    });

        for(var n = 0; n < objlist.length; n++) {
            if(objlist[n].obj === this) { continue; }
            var dist = objlist[n].dist;
            var loc = objlist[n].pos;
            var direction;
            if(dist < POSITION_EPSILON) {
                direction = vec_normalized([-1+2*Math.random(), -1+2*Math.random()]);
            } else {
                direction = vec_normalized(vec_sub(loc, pos));
            }
            var weight = Math.exp(-dist);
            gradient[0] += weight * direction[0];
            gradient[1] += weight * direction[1];
        }

        // If a nonzero gradient is detected, then get the unit moving
        if(gradient[0] != 0 || gradient[1] != 0) {
            gradient = vec_normalized(gradient);
            this.control_state = control_states.CONTROL_MOVING;
            this.control_target = null;
            var target_pos = [pos[0], pos[1]];

            // arbitrarily move 1 unit along the gradient towards lower pressure
            var mdist = 1;
            target_pos[0] += mdist * -gradient[0];
            target_pos[1] += mdist * -gradient[1];

            // clamp against map boundaries
            var ncells = session.viewing_base.ncells();
            target_pos[0] = clamp(target_pos[0], 0, ncells[0]-1);
            target_pos[1] = clamp(target_pos[1], 0, ncells[1]-1);

            // avoid sending the unit into blocked areas
            if(!this.passes_through_walls()) {
                while((target_pos[0] > 0) && (target_pos[1] > 0) &&
                      (target_pos[0] < ncells[0]-1) && (target_pos[1] < ncells[1]-1) &&
                      (astar_map.is_blocked(vec_floor(target_pos)))) {
                    target_pos[0] += mdist * -gradient[0];
                    target_pos[1] += mdist * -gradient[1];
                }
                target_pos[0] = clamp(target_pos[0], 0, ncells[0]-1);
                target_pos[1] = clamp(target_pos[1], 0, ncells[1]-1);
            }

            if(!vec_equals(this.dest, target_pos)) {
                if(!vec_equals_integer(this.dest, target_pos)) {
                    this.path_valid = false;
                }
                this.dest = target_pos;
                // XXX hack - reset ai_dest to avoid looping during leash behavior
                if(this.ai_state === ai_states.AI_ATTACK_ANY && this.ai_dest) {
                    this.ai_dest = this.dest;
                }
            }
        }
    }
};

Mobile.prototype.run_control = function() {
    goog.base(this, 'run_control');

    if(this.is_destroyed()) {
        // we're dead, Jim.
        return;
    }

    if(this.combat_stats.stunned) { this.control_state = control_states.CONTROL_STOP; }

    if(this.control_state === control_states.CONTROL_STOP ||
       this.control_state === control_states.CONTROL_SHOOT) {
        // stop at end of this tick's motion
        this.pos = this.next_pos;
        this.vel = [0,0];

    } else if(this.control_state === control_states.CONTROL_MOVING) {
        var maxvel = this.combat_stats.maxvel; // this.get_leveled_quantity(this.spec['maxvel']);
        if(this.dest === null) { throw Error('dest must be non-null here'); }

        // update pos
        if(this.next_pos[0] != this.pos[0] || this.next_pos[1] != this.pos[1]) {
            this.pos = this.next_pos;

            // eventually persist the new location to the server
            this.state_dirty |= obj_state_flags.XY;
        }

        if(PLAYFIELD_DEBUG >= 2 && this === last_created_object) {
            console.log(this.spec['name']+' CONTROL_MOVING pos '+this.pos[0].toString()+','+this.pos[1].toString()+' dest '+this.dest[0].toString()+','+this.dest[1].toString()+' path_valid '+this.path_valid.toString());
        }

        // vector to destination
        var to_dest = vec_sub(this.dest, this.pos);

        // distance to destination
        var dist = vec_length(to_dest);

        if(dist < POSITION_EPSILON) {
            // arrived at destination
            this.pos = this.dest;
            this.next_pos = this.dest;
            this.vel = [0,0];
            this.path = [];
            this.path_valid = false;
            // leave rover.facing alone
            this.control_state = control_states.CONTROL_STOP;

        } else {
            // follow A* path
            var path_next; // coordinates of next cell in movement path

            /* placate Closure compiler */ path_next = this.pos;

            // compute A* path
            var ncells = session.viewing_base.ncells();
            var cur_cell = [clamp(Math.floor(this.pos[0]),0,ncells[0]-1),
                            clamp(Math.floor(this.pos[1]),0,ncells[1]-1)];
            var dest_cell = [clamp(Math.floor(this.dest[0]),0,ncells[0]-1),
                             clamp(Math.floor(this.dest[1]),0,ncells[1]-1)];
            playfield_check_pos(dest_cell, 'dest_cell');
            if((cur_cell[0] == dest_cell[0]) && (cur_cell[1] == dest_cell[1])) {
                // rover is same cell as final destination, no need to compute path
                if(!this.dest) { throw Error('this.dest is null'); }
                path_next = this.dest;
                playfield_check_path([this.pos,path_next], 'copy_from_this.dest');
            } else {
                // update the A* path
                if(!this.path_valid) {
                    // first see if a direct route is open
                    if(this.passes_through_walls() || astar_map.linear_path_is_clear(cur_cell, dest_cell)) {
                        // if so, construct a direct route, and skip the call to A*
                        if(PLAYFIELD_DEBUG >= 2 && this === last_created_object) {
                            console.log(this.spec['name']+' taking direct route');
                        }
                        this.path = [cur_cell, dest_cell];
                        this.path_valid = true; this.path_new = true;
                        if(!this.passes_through_walls()) {
                            playfield_check_path(this.path, 'direct_skip_A*');
                        }
                    } else {
                        if(tick_astar_queries_left === 0) {
                            // do nothing until the client has CPU to run A*
                            if(PLAYFIELD_DEBUG >= 2 && this === last_created_object) {
                                console.log(this.spec['name']+' starved for A* time');
                            }
                            path_next = this.pos;
                            playfield_check_path([this.pos,path_next], 'A*_starved');
                        } else {
                            // run the slow A* search
                            tick_astar_queries_left -= 1;
                            this.path = astar_context.search(cur_cell, dest_cell);
                            playfield_check_path(this.path, 'A*');
                            astar_map.smooth_path(this.path);
                            playfield_check_path(this.path, 'A*_smoothed');
                            this.path_valid = true;
                            this.path_new = true;
                            if(PLAYFIELD_DEBUG >= 2 && this === last_created_object) {
                                var p = '';
                                goog.array.forEach(this.path, function(loc) { p += ' '+loc[0].toString()+','+loc[1].toString(); });
                                console.log(this.spec['name']+' A* result:'+p);
                            }
                        }
                    }
                }
                if(this.path.length == 0) {
                    // path is blocked
                    path_next = this.pos;
                    playfield_check_path([this.pos,path_next], 'path is blocked');

                    // check against blockage ON TOP OF unit
                    if(astar_map.is_blocked(cur_cell)) {
                        // unit is trapped inside of a blocked area
                        // construct a fake path that allows it to pass out
                        var temp = [cur_cell[0]+2, cur_cell[1]+2];
                        while(temp[0] < ncells[0]-1 && temp[1] < ncells[1]-1) {
                            if(!astar_map.is_blocked(temp)) {
                                this.path = [temp];
                                path_next = [this.path[0][0]+0.5, this.path[0][1]+0.5];
                                this.path_valid = true; this.path_new = true;
                                break;
                            }
                            temp[0] += 1;
                            temp[1] += 1;
                        }
                        if(PLAYFIELD_DEBUG) {
                            console.log(this.spec['name']+' trapped, moving out of '+cur_cell[0].toString()+','+cur_cell[1].toString());
                        }
                    }

                } else {

                    // follow movement path
                    if(PLAYFIELD_DEBUG >= 2 && this === last_created_object) {
                        var p = '';
                        goog.array.forEach(this.path, function(loc) { p += ' '+loc[0].toString()+','+loc[1].toString(); });
                        console.log(this.spec['name']+' following path'+p);
                    }
                    while(this.path.length >= 1) {
                        path_next = vec_add(this.path[0], [0.5, 0.5]);
                        var next_cell = vec_floor(path_next);
                        if(cur_cell[0] != next_cell[0] || cur_cell[1] != next_cell[1]) {
                            // we have to cross at least one more cell
                            break;
                        } else {
                            // we have reached the cell containing the next waypoint
                            if(vec_distance(this.pos, path_next) < 0.001) {
                                // we're right at the waypoint, move on to the next one
                                this.path.shift();
                            } else {
                                // we have not quite reached the next waypoint yet, but see if we can "cut the corner"
                                if(this.path.length > 1) {
                                    // not the final waypoint - cut the corner, but only if we can make it
                                    // to the next waypoint without entering a blocked area
                                    if(this.passes_through_walls() || astar_map.linear_path_is_clear(this.pos, this.path[1])) {
                                        this.path.shift(); // cut off the corner
                                    } else {
                                        break; // cannot cut the corner
                                    }
                                } else {
                                    // final waypoint - just stop after this tick
                                    this.path.shift();
                                    break;
                                }
                            }
                        }
                    }

                    /* OLD code - broken because it can "cut corners" into blocked cells
                    // delete head of path until next path point is at least (maxvel*TICK_INTERVAL) units away
                    // also delete nodes closer than ~1.5 units to avoid stair-stepping (since smooth_path does not
                    // know about continuous coordinates, it will still leave stair-steps at the beginning of the path)

                    while(this.path.length > 0) {
                        path_next = [this.path[0][0]+0.5, this.path[0][1]+0.5];
                        var path_next_dist = vec_length(vec_sub(path_next,this.pos));
                        if(path_next_dist >= Math.max(1.5,(maxvel*TICK_INTERVAL))) {
                            break;
                        }
                        if(this.path.length <= 1) { break; }
                        this.path.shift(); // remove head
                    }
                    */
                }
            }

            // recompute dist and to_dest based on A* path
            to_dest = vec_sub(path_next, this.pos);
            dist = vec_length(to_dest);

            // how far the rover will go in this tick
            var move_dist;
            if(dist < maxvel*TICK_INTERVAL) {
                move_dist = dist;
            } else {
                move_dist = maxvel*TICK_INTERVAL;
            }

            if(dist > 0.001) {
                // unit-vector direction to destination
                var dir = vec_scale(1/dist, to_dest);
                this.vel = vec_scale(maxvel, dir);
                this.target_facing = Math.atan2(this.vel[1], this.vel[0]);

                var can_move = true;

                if(this.spec['turn_before_move'] > 0) {
                    // convert max angle difference to radians
                    var max_arc = Math.min(this.get_leveled_quantity(this.spec['turn_before_move'])*(Math.PI/180.0), Math.PI);

                    // to avoid complex modulo math, do the computations with 2D vectors
                    var cur = [Math.cos(this.cur_facing), Math.sin(this.cur_facing)];
                    var tgt = [Math.cos(this.target_facing), Math.sin(this.target_facing)];

                    // dot product between current and target headings
                    var dot = cur[0]*tgt[0] + cur[1]*tgt[1];
                    dot = Math.min(dot, 1); // avoid acos NaNs with rounding errors

                    if(Math.acos(dot) > max_arc) {
                        // not facing close enough to the right direction yet, wait before moving
                        can_move = false;
                    }
                }

                if(can_move) {
                    this.next_pos = vec_add(this.pos, vec_scale(move_dist, dir));
                    playfield_check_path([this.pos, path_next], 'CONTROL_MOVING (normal, path_next)');
                    playfield_check_path([this.pos, this.next_pos], 'CONTROL_MOVING (normal, next_pos)');
                    this.next_pos[0] = clamp(this.next_pos[0], 0, ncells[0]-1);
                    this.next_pos[1] = clamp(this.next_pos[1], 0, ncells[1]-1);
                } else {
                    this.next_pos = this.pos;
                    this.vel = [0,0];
                }

//                this.stuck_loc = null;
            } else {
                //  rover wants to move, but path is blocked
                this.next_pos = this.pos;
                this.vel = [0,0];
                // leave rover.facing alone

                // give it one chance to un-stick, in case there is a valid path beyond the iter limit
                if(gamedata['client']['astar_unstick_radius'] >= 0 &&
                   (!this.stuck_loc || vec_distance(this.pos, this.stuck_loc) >= gamedata['client']['astar_unstick_radius'])) {
                    if(PLAYFIELD_DEBUG && this === last_created_object) {
                        console.log("UNSTICKING "+this.spec['name']+' at '+this.pos[0].toString()+','+this.pos[1].toString());
                    }
                    this.stuck_loc = vec_copy(this.pos);
                    this.path_valid = false; // recalc path on next tick
                }
            }

            if(PLAYFIELD_DEBUG >= 2 && this === last_created_object) { console.log(this.spec['name']+' pos '+this.pos[0].toString()+','+this.pos[1].toString()+' path_next '+path_next[0].toString()+','+path_next[1].toString()+' dist '+dist.toString()+' move_dist '+move_dist.toString()+' next_pos '+this.next_pos[0].toString()+','+this.next_pos[1].toString()); }

        }

        if(this.feedback_pending) {
            this.feedback_pending = false;
            //unit_path_feedback(this);
        }

        if('movement_effect' in this.spec) {
            SPFX.add_visual_effect(this.pos, this.altitude, [0,1,0], client_time, this.spec['movement_effect'], true, null);
        }
    } // END control_moving

    if(typeof(this.pos) == 'undefined') {
        throw Error(this.spec['name']+' exited run_control (' + control_state_names[this.control_state] + ') with undefined this.pos');
    }
};

var last_created_object = null; // for debugging messages

// instantiate game object from server message
function create_object(data, is_deploying) {
    // peek inside state message to determine object type
    var specname = data[1];
    var spec = get_spec(specname);
    if(!spec) {
        throw Error('cannot create object of unrecognized type '+specname);
    }

    var kind = spec['kind'];
    var obj;
    if(kind === 'building') {
        obj = new Building();
    } else if(kind === 'mobile') {
        obj = new Mobile();
    } else if(kind === 'inert') {
        obj = new Inert();
    } else {
        throw Error('bad spec kind '+kind);
    }

    obj.receive_state(data, true, is_deploying);

    // spread units on attack deployment
    // the server only stores positions with the granularity of one map cell.
    // for mobile units, scatter them randomly within the cell so they aren't
    // all on top of each other
    if(!session.home_base && obj.team === 'player' && obj.is_mobile()) {
        var radius = player.get_any_abtest_value('unit_deploy_spread', gamedata['unit_deploy_spread']);
        var ncells = session.viewing_base.ncells();
        obj.pos = [clamp(obj.pos[0]+radius*(Math.random()-0.5), 0, ncells[0]-1),
                   clamp(obj.pos[1]+radius*(Math.random()-0.5), 0, ncells[1]-1)];
        obj.next_pos = vec_copy(obj.pos);
        obj.dest = vec_copy(obj.pos);
        if(obj.ai_dest) { obj.ai_dest = vec_copy(obj.pos); }
        if(obj.orders.length == 1 && obj.orders[0]['dest']) { // only if not null or missing
            obj.orders[0]['dest'] = vec_copy(obj.pos);
        }
        if(!obj.is_destroyed() && player.unit_micro_enabled()) {
            add_unit_to_selection(obj);
        }
    }

    // when spawning new temporary units (e.g. security teams) during an AI attack, add those to the count of attackers so the bookkeeping works out accurately
    if(session.home_base && session.attack_finish_time > server_time && obj.team == 'enemy' && (obj.id.indexOf('TEMP')===0)) {
        session.incoming_attack_units_total += 1;
    }

    last_created_object = obj;
    return obj;
};

// remove object from client session
// (but does NOT touch my_army)
function remove_object(obj) {
    // update map
    if(obj.is_blocker() && !obj.is_destroyed()) {
        obj.block_map(-1);
    }

    // deselect

    // remove from selection.multi
    for(var i = 0; i < selection.multi.length; i++) {
        if(selection.multi[i] === obj) {
            selection.multi.splice(i,1);
        }
    }

    if(selection.unit === obj) {
        // try to select something else in the multi group
        if(selection.multi.length > 0) {
            selection.unit = selection.multi[0];
        } else {
            change_selection(null);
        }
    }
    if(mouse_state.hovering_over === obj) {
        mouse_state.hovering_over = null;
    }

    if(obj.is_mobile() && obj.is_under_repair()) {
        for(var i = 0; i < player.unit_repair_queue.length; i++) {
            var item = player.unit_repair_queue[i];
            if(item['obj_id'] == obj.id) {
                player.unit_repair_queue.splice(i,1);
                break;
            }
        }
    }

    obj.remove_permanent_effect();

    session.cur_objects.rem_object(obj);
};

// for level-editing only
function send_and_remove_object(obj) {
    if(obj.id && obj.id !== GameObject.DEAD_ID) {
        send_to_server.func(["REMOVE_OBJECT", obj.id]);
        remove_object(obj);
    }
}

// called when an object actually *dies* in battle
function destroy_object(obj) {
    if(obj.is_mobile()) {
        if(obj.team == 'player') {
            // snoop hp update into my_army
            if(obj.id in player.my_army) {
                if(player.can_resurrect_unit(obj)) {
                    var entry = player.my_army[obj.id];
                    if('hp' in entry) {
                        entry['hp'] = 0;
                    } else if('hp_ratio' in entry) {
                        entry['hp_ratio'] = 0;
                    } else {
                        entry['hp_ratio'] = 0;
                    }
                } else {
                    delete player.my_army[obj.id];
                }
            }
        } else if(session.home_base /*&& session.attack_finish_time > server_time*/ && obj.team == 'enemy' && obj.id !== GameObject.DEAD_ID /*&& (obj.id.indexOf('TEMP')!=0)*/ ) {
            session.incoming_attack_units_destroyed += 1;
        }
    }

    remove_object(obj);
}

// pack up what we know about the object that got a killing blow on another object
function get_killer_info(killer) {
    if(killer && killer.id !== GameObject.VIRTUAL_ID) {
        // note: killer.id = 'VIRTUAL' for the virtual "player" unit, i.e. tactical missiles and such
        var ret = {'team': killer.team,
                   'spec': killer.spec['name'],
                   'level': killer.level,
                   'id': killer.id};
        if(killer.is_building()) {
            if(killer.is_minefield() && killer.is_minefield_armed()) {
                ret['mine'] = killer.minefield_item();
            } else if(killer.is_emplacement() && killer.turret_head_item()) {
                ret['turret_head'] = killer.turret_head_item();
            }
        }
        return ret;
    }
    return null;
}

function send_and_destroy_object(victim, killer) {
    send_to_server.func(["DSTROY_OBJECT",
                         victim.id,
                         victim.interpolate_pos(),
                         get_killer_info(killer)
                        ]);
    destroy_object(victim);
    session.set_battle_outcome_dirty();
}


//
// engine code
//

// URL to game server GAMEAPI, preferring direct connection if possible
function gameapi_url() {
    if(spin_game_use_websocket && parseInt(spin_game_server_wss_port,10) > 0) {
        return 'wss://'+spin_game_server_host+':'+spin_game_server_wss_port+'/WS_GAMEAPI';
    } else if(spin_game_use_websocket && parseInt(spin_game_server_ws_port,10) > 0) {
        return 'ws://'+spin_game_server_host+':'+spin_game_server_ws_port+'/WS_GAMEAPI';
    } else if(spin_game_direct_connect) {
        // most modern browsers now disallow pages hosted via HTTPS from making non-HTTPS AJAX requests :(
        // so prefer HTTPS if available
        if(spin_server_protocol === 'https://') {
            return 'https://'+spin_game_server_host+":"+spin_game_server_ssl_port+"/GAMEAPI";
        } else {
            return 'http://'+spin_game_server_host+":"+spin_game_server_http_port+"/GAMEAPI";
        }
    } else {
        // go via proxyserver
        return proxy_gameapi_url();
    }
}

function gameapi_connection_method() {
    if(spin_game_direct_connect) {
        var url = gameapi_url();
        if(url.indexOf('https') == 0) {
            return 'direct_ssl';
        } else if(url.indexOf('wss') == 0) {
            return 'direct_wss';
        } else if(url.indexOf('ws') == 0) {
            return 'direct_ws';
        } else {
            return 'direct_http';
        }
    } else {
        return 'proxy_ssl';
    }
}

// URL to proxyserver GAMEAPI, used as fallback and for sending keepalives when in direct connect mode
function proxy_gameapi_url() {
    return spin_server_protocol+spin_server_host+":"+spin_server_port+"/GAMEAPI";
}

function send_proxy_keepalive() {
    console.log('send_proxy_keepalive()');
    var resp = function(event) {
        //console.log('proxy keepalive resp '+event.target.getStatusText()+' text '+event.target.getResponseText());
    };
    goog.net.XhrIo.send(proxy_gameapi_url(), resp, 'POST',
                        'proxy_keepalive_only=1&session='+session.session_id.toString(), {},
                        1000*ajax_config['message_timeout_gameplay']);
}

var metric_0107_sent = false, metric_0120_sent = false;

function gameart_onload() {
    var all = GameArt.get_dl_progress_all();
    var essential = GameArt.get_dl_progress_essential();

    var time_to_load = (new Date()).getTime()/1000 - spin_pageload_begin;

    if(essential >= 1) {
        if(gamedata['client']['delay_load_art'] && client_art_state === client_art_states.DOWNLOADING_ESSENTIAL) {
            client_art_state = client_art_states.DOWNLOADING_ALL;
            if(!metric_0107_sent) {
                if(gamedata['client']['enable_loading_metrics']) {
                    metric_event('0107_game_loaded_essential_art', {'time_to_assetload_essential':time_to_load});
                }
                metric_0107_sent = true;
            }
        }
    }

    if(all >= 1) {
        client_art_state = client_art_states.DONE;
        if(!metric_0120_sent) {
            if(gamedata['client']['enable_loading_metrics']) {
                metric_event('0120_loaded_game', {'time_to_assetload':time_to_load});
            }
            metric_0120_sent = true;
        }
    }
}

// COORDINATE TRANSFORMS

// "ortho" cell indices are j (= horizontal, + to right/east) i (= vertical, + down/south) with 0,0 at northwest corner of the base
// (the isometric view has +j towards lower-right and +i towards lower-left)
// pixel coordinates are always x (= horizontal, + to right) y (= vertical, + down)
// "playfield" coordinates are pixel coordinates with 0,0 at northwest corner of ortho cell 0,0
// "screen" coordinates are "playfield" coordinates shifted by view_pos then zoomed by view_zoom
// "draw" coordinates at the coordinates within the canvas transform set by do_draw() when drawing the playfield
// (when zoom = 1, it is the same as "screen", and when zoom != 1, it is the same as "playfield")


// convert orthographic cell index to pixel coordinate of top (northwest) corner of cell
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function ortho_to_playfield(ji) {
    // rotate to diamond pixel grid
    var x = (cellsize[0]*ji[0] - cellsize[0]*ji[1])/2;
    var y = (cellsize[1]*ji[0] + cellsize[1]*ji[1])/2;
    return [x,y];
}
/** @param {!Array.<number>} p
    @return {!Array.<number>} */
function playfield_to_screen(p) {
    // shift view so that view_pos puts center grid cell at middle of canvas
    var ncells = (session.viewing_base ? session.viewing_base.ncells() : [0,0]);
    return vec_add(vec_scale(view_zoom, vec_sub(p, view_pos)),
                   [canvas_width_half, canvas_height_half - view_zoom*cellsize[1]*ncells[1]/2]);
}
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function ortho_to_screen(ji) {
    return playfield_to_screen(ortho_to_playfield(ji));
}
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function ortho_to_draw(ji) {
    if(view_is_zoomed()) {
        return ortho_to_playfield(ji);
    } else {
        return ortho_to_screen(ji);
    }
}
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function ortho_to_draw_vector(ji) {
    if(view_is_zoomed()) {
        return ortho_to_playfield_vector(ji);
    } else {
        return ortho_to_screen_vector(ji);
    }
}
/** @param {!Array.<number>} j_height_i
    @return {!Array.<number>} */
function ortho_to_screen_3d(j_height_i) {
    var xy = ortho_to_screen([j_height_i[0], j_height_i[2]]);
    xy[1] += j_height_i[1] * -15 * view_zoom;
    return xy;
}
/** @param {!Array.<number>} j_height_i
    @return {!Array.<number>} */
function ortho_to_draw_3d(j_height_i) {
    var xy = ortho_to_draw([j_height_i[0], j_height_i[2]]);
    xy[1] += j_height_i[1] * -15;
    return xy;
}

// transform a vector (not a point) from orthographic cell coordinates to playfield coordinates
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function ortho_to_playfield_vector(ji) {
    var x = (cellsize[0]*ji[0] - cellsize[0]*ji[1])/2;
    var y = (cellsize[1]*ji[0] + cellsize[1]*ji[1])/2;
    return [x,y];
};
/** @param {!Array.<number>} ji
    @return {!Array.<number>} */
function ortho_to_screen_vector(ji) {
    var p = ortho_to_playfield_vector(ji);
    if(view_is_zoomed()) {
        p = vec_scale(view_zoom, p);
    }
    return p;
};

// return depth corresponding to an orthographic cell position
// higher values are closer to the "camera"
/** @param {!Array.<number>} ji
    @return {number} */
function ortho_to_depth(ji) {
    return ji[0] + ji[1];
}

/** @param {!Array.<number>} xy
    @return {!Array.<number>} */
function screen_to_playfield(xy) {
    // undo view window shift
    var ncells = session.viewing_base.ncells(); // let's try to catch errors where base is null
    return vec_add(view_pos, vec_scale(1/view_zoom, vec_sub(xy, [canvas_width_half, canvas_height_half - view_zoom*cellsize[1]*ncells[1]/2])));
}
/** @param {!Array.<number>} xy
    @return {!Array.<number>} */
function playfield_to_ortho(xy) {
    // rotate to orthogonal grid
    var j = xy[0]/(cellsize[0]) + xy[1]/(cellsize[1]);
    var i = -xy[0]/(cellsize[0]) + xy[1]/(cellsize[1]);
    // quantize
    return vec_floor([j,i]);
}
/** @param {!Array.<number>} xy
    @return {!Array.<number>} */
function screen_to_ortho(xy) {
    return playfield_to_ortho(screen_to_playfield(xy));
}


// cache of last known pixel dimensions of Facebook iframe area
var fb_iframe_dims = null;
var fb_iframe_scroll = null;
var fb_iframe_offset = null;

// query Facebook for the iframe viewport dimensions
function fb_iframe_update(cb) {
    FB.Canvas.getPageInfo((function (_cb) { return function(info) {
        // only write console message on active ping and not passive snoop
        if(_cb) { console.log('FB.Canvas.getPageInfo: '+info.clientWidth+'x'+info.clientHeight); }
        fb_iframe_dims = [info.clientWidth, info.clientHeight];
        fb_iframe_scroll = [info.scrollLeft, info.scrollTop];
        fb_iframe_offset = [info.offsetLeft, info.offsetTop];
        if(_cb) { _cb(); }
    }; })(cb));
}

// called when browser window changes size - query for max iframe size
function on_resize_browser(e) {
    console.log('BROWSER '+window.innerWidth+' x '+window.innerHeight+' screen '+screen.width+' x '+screen.height);
    fb_iframe_dims = null;

    var force_width_s = get_query_string('force_width'), force_height_s = get_query_string('force_height');
    var force_width = (force_width_s ? parseInt(force_width_s,10) : -1), force_height = (force_height_s ? parseInt(force_height_s,10) : -1);

    if(force_width > 0 && force_height > 0) {
        fb_iframe_dims = [force_width, force_height];
        on_resize_iframe(null);
    } else if(spin_frame_platform == 'fb' && spin_facebook_enabled && gamedata['client']['facebook_iframe_resize_hack'] && (typeof FB != 'undefined')) {
        fb_iframe_update(function() { on_resize_iframe(null); });
    } else {
        // no Facebook API, just use natural iframe size as determined by browser CSS layout
        on_resize_iframe(null);
    }
};

// called when game iframe SHOULD change size to be appropriate for the browser window size
function on_resize_iframe(e) {
    if(spin_frame_platform == 'fb' && spin_facebook_enabled && gamedata['client']['facebook_iframe_resize_hack']) {
        // On Facebook App settings page, Canvas Height should be in "Fixed" (not "Fluid") mode for this to work

        var newheight;

        // Facebook used to auto-scroll canvas games downward to put the top of the game canvas at the
        // top of the browser window. So we used to use the exact pixel viewport size in that case,
        // to get a sort-of-fullscreen appearance (within the blue Facebook frame).

        // As of 2014 Nov 22, Facebook no longer auto-scrolls canvas games down. So this ends up chopping
        // off the bottom of the canvas. Code disabled but left in for reference only.

        // 2014 Nov 25 update - this path IS required for Firefox in truefullscreen mode, otherwise mouse click tracking gets the wrong height offset.
        var needs_firefox_hack = (spin_demographics['browser_name'] === 'Firefox' && canvas_is_fullscreen);

        if(needs_firefox_hack /* || window.innerWidth >= (screen.width-320) */) {
            // I THINK WE MIGHT BE IN FAKE FULLSCREEN MODE
            if(fb_iframe_dims) {
                // if Facebook has given us the exact pixel viewport size, use that
                newheight = fb_iframe_dims[1];
            } else {
                // otherwise, try to almost take up the entire screen height
                // need to provide some padding for browser toolbars etc.
                // 30px works OK on Chrome/Firefox/IE
                newheight = screen.availHeight-30;
            }

        } else {
            // WINDOWED MODE
            if(fb_iframe_dims) {
                // occupy almost full vertical canvas, but leave room for Facebook chrome
                newheight = Math.max(425, fb_iframe_dims[1] - (fb_iframe_offset !== null ? fb_iframe_offset[1] : 43));

                // maybe conditionalize on if(!canvas_is_fullscreen)?
                var header = document.getElementById('spin_header');
                if(header) { newheight -= header.clientHeight; }

                // SHOW TOP PORTION OF SPIN_FOOTER with forum links etc.
                newheight -= gamedata['client']['facebook_iframe_footer_peek'];

            } else {
                // no clue about browser height. Just use fixed height (like Kixeye)
                newheight = 625;
            }
        }

        canvas_div.style.height = newheight.toString()+'px';
        if(get_query_string('force_width')) {
            canvas_div.style.width = fb_iframe_dims[0].toString()+'px';
            //canvas.style.width = canvas_div.style.width;
            //canvas.style.height = canvas_div.style.height;
        }

        // resize startup_div to match, if it is still visible
        var startup_div = document.getElementById('startup_div');
        if(startup_div.offsetWidth > 0 && startup_div.offsetHeight > 0) {
            startup_div.style.height = canvas_div.style.height;
            startup_div.style.width = canvas_div.style.width;
        }

        if(typeof FB != 'undefined') {
            var iframe_width = canvas_width;
            var iframe_height = newheight + parseInt(document.getElementById('spin_footer').style.height,10);
            console.log('FB.Canvas.setSize: '+iframe_width+'x'+iframe_height);
            FB.Canvas.setSize({'width':iframe_width, 'height': iframe_height});
        }
    }

    on_resize_game();
}



// read current canvas_div width/height and set game canvas accordingly
function on_resize_game() {
    canvas.width = canvas_div.offsetWidth;
    canvas.height = canvas_div.offsetHeight;

    // update cached dimensions
    canvas_width = canvas.width;
    canvas_height = canvas.height;
    canvas_width_half = Math.floor(canvas_width/2);
    canvas_height_half = Math.floor(canvas_height/2);
    canvas_div_offsetLeft = canvas_div.offsetLeft;
    canvas_div_offsetTop = canvas_div.offsetTop;

    set_view_limits();
    //console.log('GAME '+canvas_width+'x'+canvas_height);

    SPUI.on_resize(canvas_width, canvas_height);
    tutorial_root.wh = [canvas_width, canvas_height];
    tutorial_root.on_resize();
    player.quest_root.wh = [canvas_width, canvas_height];
    player.quest_root.on_resize();

    force_draw();
}

function set_view_zoom(new_linear) {
    if(new_linear != get_preference_setting(player.preferences, 'playfield_zoom')) {
        player.preferences['playfield_zoom'] = new_linear;
        send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
    }

    view_zoom_linear = clamp(new_linear, gamedata['client']['view_zoom_limits'][0], gamedata['client']['view_zoom_limits'][1]);
    if(Math.abs(view_zoom_linear) < 0.01) {
        // ensure that we use fast paths when not zooming
        view_zoom_linear = 0;
        view_zoom = 1;
    } else {
        view_zoom = Math.exp(view_zoom_linear);
    }
    set_view_limits();
}

function set_view_limits() {
    var BORDER = gamedata['client']['playfield_scroll_margin'];
    var ncells = (session.viewing_base ? session.viewing_base.ncells() : [0,0]);
    view_limits[0] = [-cellsize[0]*ncells[0]/2+canvas_width_half/view_zoom-BORDER[0],
                      cellsize[0]*ncells[0]/2-canvas_width_half/view_zoom+BORDER[0] ];
    if(view_limits[0][1] < view_limits[0][0]) { view_limits[0] = [0,0]; };
    view_limits[1] = [-cellsize[1]*ncells[1]/2+canvas_height_half/view_zoom-BORDER[1],
                      cellsize[1]*ncells[1]/2-canvas_height_half/view_zoom+BORDER[1] ];
    if(view_limits[1][1] < view_limits[1][0]) { view_limits[1] = [0,0]; };
}

// note: sound/music, fullscren, and settings buttons
function invoke_playfield_controls_bar() {
    var orient = (gamedata['client']['playfield_controls_bar_layout'] || 'vertical');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['playfield_controls_bar_'+orient]);
    dialog.user_data['dialog'] = 'playfield_controls_bar_'+orient;
    dialog.transparent_to_mouse = true;

    // true FS support
    if(has_true_fullscreen()) {
        dialog.widgets['fullscreen_button'].show = true;
    } else {
        // fake FS dialog - breaks tutorial and has no useful info for non-Windows/Mac browsers
        dialog.widgets['fullscreen_button'].show = ((player.tutorial_state == "COMPLETE") &&
                                                    (spin_demographics['browser_OS'] === "Mac" ||
                                                     spin_demographics['browser_OS'] === "Windows"));
    }
    dialog.widgets['fullscreen_button'].onclick = function() {
        if(has_true_fullscreen()) {
            toggle_true_fullscreen();
        } else {
            invoke_fullscreen_instructions();
        }
    };

    dialog.widgets['settings_button'].show = ((player.tutorial_state == "COMPLETE") ||
                                              gamedata['tutorial'][player.tutorial_state]['enable_desktop_control_buttons']);
    dialog.widgets['settings_button'].onclick = invoke_settings_dialog;

    dialog.widgets['music_button'].show = GameArt.enable_audio;
    dialog.widgets['sound_button'].show = GameArt.enable_audio;

    if(GameArt.enable_audio) {
        // sound/music toggle callbacks
        var cbmaker = function(sound_or_music) { return function() {
            if(sound_or_music === 'sound') {
                GameArt.sound_volume = (GameArt.sound_volume > 0 ? 0 : 1);
            } else {
                GameArt.music_volume = (GameArt.music_volume > 0 ? 0 : 1);
                if(backdrop_music) {
                    if(GameArt.music_volume > 0) {
                        backdrop_music.loop();
                        backdrop_music.play(client_time);
                        backdrop_music.fadeTo(50*GameArt.music_volume,1);
                    } else {
                        backdrop_music.unloop();
                        backdrop_music.stop(client_time);
                    }
                }
            }
            player.preferences['sound_volume'] = GameArt.sound_volume;
            player.preferences['music_volume'] = GameArt.music_volume;
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
        }; };
        dialog.widgets['music_button'].onclick = cbmaker('music');
        dialog.widgets['sound_button'].onclick = cbmaker('sound');
    }
    dialog.ondraw = update_playfield_controls_bar;
    return dialog;
}
function update_playfield_controls_bar(dialog) {
    if(dialog.user_data['dialog'] == 'playfield_controls_bar_horizontal') {
        var top = desktop_dialogs['desktop_top'];
        if(!top) { dialog.show = false; return; }
        dialog.show = true;
        if('alliances_button' in top.widgets) {
            dialog.xy = vec_add(dialog.data['spacing_under'], vec_add([0,top.widgets['alliances_button'].wh[1]], top.widgets['alliances_button'].get_absolute_xy()));
        } else {
            dialog.xy = vec_add(dialog.data['spacing_right'], top.get_absolute_xy());
        }
    } else {
        // attach to right side of desktop
        dialog.xy = vec_add(dialog.data['spacing'], [canvas_width-dialog.wh[0], Math.floor(canvas_height/2 - dialog.wh[1])]);
    }
    dialog.widgets['fullscreen_button'].state = canvas_is_fullscreen ? 'reverse' : 'normal';
    if(GameArt.enable_audio) {
        dialog.widgets['music_button'].state = GameArt.music_volume > 0 ? 'on' : 'off';
        dialog.widgets['sound_button'].state = GameArt.sound_volume > 0 ? 'on' : 'off';
    }
}

function invoke_playfield_zoom_bar() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['playfield_zoom_bar']);
    dialog.user_data['dialog'] = 'playfield_zoom_bar';
    var zoom_cb = function(incr) { return function(w) {
        player.record_feature_use('playfield_zoom');
        set_view_zoom(view_zoom_linear + incr * gamedata['client']['view_zoom_click_increment']);
    }; };
    dialog.widgets['zoom_in_button'].onclick = zoom_cb(1);
    dialog.widgets['zoom_out_button'].onclick = zoom_cb(-1);
    dialog.ondraw = update_playfield_zoom_bar;
    return dialog;
}
function update_playfield_zoom_bar(dialog) {
    // attach to right side of desktop
    //if('playfield_controls_bar' in desktop_dialogs && (desktop_dialogs['playfield_controls_bar'].user_data['dialog'] == 'playfield_controls_bar_vertical')) { ... }
    dialog.xy = vec_add(dialog.data['spacing'], [canvas_width-dialog.wh[0], Math.floor((canvas_height /* -dialog.wh[1]*/ )/2)]);
    dialog.widgets['zoom_readout'].str = dialog.data['widgets']['zoom_readout']['ui_name'].replace('%d', (view_zoom_linear >= 0 ? '+' : '') + view_zoom_linear.toFixed(1));
    dialog.widgets['zoom_readout'].text_color = SPUI.make_colorv(dialog.data['widgets']['zoom_readout']['text_color_'+(view_zoom_linear === 0 ? 'zero' : 'nonzero')]);
    dialog.widgets['zoom_in_button'].state = (view_zoom_linear >= gamedata['client']['view_zoom_limits'] ? 'disabled' : 'normal');
    dialog.widgets['zoom_out_button'].state = (view_zoom_linear < gamedata['client']['view_zoom_limits'] ? 'disabled' : 'normal');
}

function init_playfield_speed_bar() {
    if(player.get_any_abtest_value('enable_playfield_speed_bar', gamedata['client']['enable_playfield_speed_bar']) &&
       !('playfield_speed_bar' in desktop_dialogs)) {
        var dialog = invoke_playfield_speed_bar();
        if(dialog) {
            desktop_dialogs['playfield_speed_bar'] = dialog;
            SPUI.root.add_under(dialog);
        }
    }
}
function invoke_playfield_speed_bar() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['playfield_speed_bar']);
    dialog.user_data['dialog'] = 'playfield_speed_bar';
    var speed_cb = function(incr) { return function(w) {
        player.record_feature_use('playfield_speed');
        var new_speed = player_playfield_speed + incr;
        update_player_combat_time_scale(new_speed);
        if(player.preferences['playfield_speed'] != player_playfield_speed) {
            player.preferences['playfield_speed'] = player_playfield_speed;
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
        }
    }; };
    dialog.widgets['speed_up_button'].onclick = speed_cb(1);
    dialog.widgets['speed_down_button'].onclick = speed_cb(-1);
    dialog.ondraw = update_playfield_speed_bar;
    return dialog;
}
function update_playfield_speed_bar(dialog) {
    // attach to right side of desktop, underneath zoom bar
    //if('playfield_controls_bar' in desktop_dialogs && (desktop_dialogs['playfield_controls_bar'].user_data['dialog'] == 'playfield_controls_bar_vertical')) { ... }
    dialog.xy = vec_add(dialog.data['spacing'], [canvas_width-dialog.wh[0], Math.floor((canvas_height/2) + gamedata['dialogs']['playfield_zoom_bar']['dimensions'][1])]);
    goog.array.forEach(['speed_amount', 'speed_label'], function(wname) {
        dialog.widgets[wname].text_color = SPUI.make_colorv(dialog.data['widgets'][wname]['text_color_'+(player_playfield_speed === 0 ? 'zero' : 'nonzero')]);
    });
    dialog.widgets['speed_up_button'].state = (player_playfield_speed >= gamedata['client']['playfield_speed_limits'][1] ? 'disabled' : 'normal');
    dialog.widgets['speed_down_button'].state = (player_playfield_speed <= gamedata['client']['playfield_speed_limits'][0] ? 'disabled' : 'normal');
    dialog.widgets['speed_amount'].str = dialog.data['widgets']['speed_amount']['ui_name'].replace('%f', player_combat_time_scale.toFixed(1));
}

var last_flush_time = 0;

// test server robustness against lag by adding delay to AJAX transmissions
var inject_lag = 0;

var ajax_config = null; // pointer into gamedata.client.ajax_config

// set to true if there has been any mouse/keyboard input since the last transmission to the server.
// if not, then set the nokeepalive flag so that automated messages do not hold the connection open
var input_since_last_xmit = true;
var input_since_last_proxy_xmit = true;

// go through some gymnastics to preserve a reference to the XMLHttpRequest hidden inside a goog.net.XhrIo so we can attach our own progress listener.
/** @constructor
  * @extends goog.net.XmlHttpFactory */
function MyXmlHttpFactory(request) {
    this.request = request;
};
goog.inherits(MyXmlHttpFactory, goog.net.XmlHttpFactory);
MyXmlHttpFactory.prototype.getOptions = goog.net.XmlHttp.getOptions;
MyXmlHttpFactory.prototype.createInstance = function() { return this.request; };

var last_ajax_serial = -1;
var last_ajax_xmit_time = -1;
var last_ajax_xmit_len = -1;

var the_websocket = null;
var last_websocket_keepalive = -1;
var last_websocket_xmit_time = -1;
var last_websocket_xmit_len = -1;
var last_websocket_queue = null; // last AJAXMessageQueue queued for transmission on the websocket
var last_websocket_serial = -1; // serial number of last_websocket_queue

/** @param {boolean=} force
    @param {number=} my_timeout */
function flush_message_queue(force, my_timeout) {
    if(message_queue.length() < 1) {
        return;
    }

    // limit AJAX requests to ocurring no more frequently than one per this number of seconds
    if(!force && (client_time - last_flush_time) < gamedata['client']['ajax_min_flush_interval']) {
        //console.log('Throttling back AJAX');
        return;
    }
    last_flush_time = client_time;

    // test server robustness against different groupings of messages within an AJAX request
    var GROUPTEST = false;
    if(GROUPTEST && message_queue.length() < 2 && message_queue.queue[0][0] != "CLIENT_HELLO") {
        return;
    }

    if(player.is_developer()) {
        goog.array.forEach(message_queue.queue, function(msg) {
            console.log(['To Server ('+gameapi_connection_method()+')', message_serial.toString()].concat(msg));
        });
    }

    // tag messages that are sent without human input as 'nokeepalive'
    // so they won't hold the session open past its timeout
    var keepalive = input_since_last_xmit;
    input_since_last_xmit = false;

    var send_it;

    if(spin_game_use_websocket) {
        // Websockets
        var data_dict = {'myarg': message_queue.queue, // NOT stringified internally
                         'serial': message_serial,
                         'session': session.session_id};
        if(!keepalive) {
            // message is automatic, do not keepalive
            data_dict['nokeepalive'] = 1;
        }

        var data_str = JSON.stringify(data_dict);
        message_queue.serial = message_serial;

        // save this message bundle in case websocket fails and we need to re-transmit it via HTTP
        last_websocket_queue = message_queue;
        last_websocket_serial = message_serial;
        last_websocket_xmit_time = client_time;
        last_websocket_xmit_len = data_str.length;

        if(!the_websocket) {
            the_websocket = new SPWebsocket.SPWebsocket(gameapi_url(), ajax_config['message_timeout_hello'], ajax_config['message_timeout_gameplay']);
            var on_websocket_error = function(event) {
                if(!the_websocket) { return; } // irrelevant
                the_websocket.close();
                the_websocket = null;

                var error_props = {'user_id': spin_user_id,
                                   'method': (event.data||'unknown'),
                                   'serial': last_websocket_serial,
                                   'len': last_websocket_xmit_len,
                                   'elapsed': client_time - last_websocket_xmit_time,
                                   'since_connect': (session.connected() ? client_time - session.connect_time : -1),
                                   'since_pageload': client_time - spin_pageload_begin,
                                   'connection': gameapi_connection_method()
                                  };

                // can we recover?
                var can_recover = false;
                if(last_websocket_serial == message_serial-1) { // we only had one message on the wire
                    if(ajax_config['enable_proxy']) { // can fall back to proxied HTTP
                        can_recover = true;

                        // note: force metric to be sent via the GIF fetch method rather than with the normal client/server stream
                        SPLWMetrics.send_event(spin_metrics_anon_id, '0645_direct_ws_failure_falling_back_to_proxy', add_demographics(error_props));
                        spin_game_use_websocket = false;
                        spin_game_direct_connect = false;

                        // switch back to HTTP and retransmit failed bundle
                        message_serial -= 1;
                        message_queue.prepend(last_websocket_queue.queue);
                        last_websocket_queue = null;
                        last_websocket_serial = -1;
                        flush_message_queue(true);
                        if(session.connected()) {
                            longpoll_send();
                        }
                    }
                }

                if(can_recover) {
                    return;
                }

                // permadeath
                if(event.data == 'connect_timeout') {
                    invoke_timeout_message('0641_client_died_from_ws_connect_timeout', error_props, {});
                } else if(event.data == 'xmit_error') {
                    invoke_timeout_message('0642_client_died_from_ws_xmit_failure', error_props, {});
                } else {
                    invoke_timeout_message('0649_client_died_from_ws_unknown_failure', error_props, {});
                }

            };
            var on_websocket_message = function(event) {
                on_ajax(event.data, (the_websocket && the_websocket.url.indexOf('ws://') == 0 ? 'direct_ws' : 'direct_wss'));
            };
            goog.events.listen(the_websocket.target, 'error', on_websocket_error);
            goog.events.listen(the_websocket.target, 'message', on_websocket_message);

            the_websocket.connect();
        }

        send_it = (function (_data_str, _the_websocket) { return function() { _the_websocket.send(_data_str); }; })(data_str, the_websocket);

    } else {
        // Google Closure XhrIo method
        var msg = 'myarg='+encodeURIComponent(JSON.stringify(message_queue.queue));
        message_queue.serial = message_serial;
        msg += '&serial='+message_serial.toString();
        msg += '&session='+session.session_id.toString();
        if(!keepalive) {
            // message is automatic, do not keepalive
            msg += '&nokeepalive=1';
        }

        last_ajax_serial = message_serial;
        last_ajax_xmit_time = client_time;
        last_ajax_xmit_len = msg.length;

        var timeout_ms = 1000*(my_timeout ? my_timeout : ajax_config['message_timeout_gameplay']);

        // needs to be true for Firefox 25 etc due to very strict CORS policies
        // note, this requires that the server respond with an Access-Control-Allow-Origin that exactly matches the Origin: on the request,
        // wildcard (*) is NOT ok!
        var use_cors_credentials = true;

        send_it = (function(_msg, _timeout_ms, _use_cors_credentials) { return function() {
            //goog.net.XhrIo.send(gameapi_url(), on_ajax_goog, 'POST', _msg, {}, _timeout_ms, _use_cors_credentials);

            // go through some gymnastics to preserve a reference to the XMLHttpRequest so we can attach a progress listener
            var request = goog.net.XmlHttp();
            var x = new goog.net.XhrIo(new MyXmlHttpFactory(request));
            goog.events.listen(x, goog.net.EventType.COMPLETE, on_ajax_goog);
            goog.events.listen(x, goog.net.EventType.READY, (function (_x) { return function() { _x.dispose(); }; })(x));

            // partial-progress event that updates the message bundle's response progress
            // note: this is not supported and will not fire on IE < 10
            request.addEventListener('progress', (function (_message_queue) { return function(e) {
                if(e.lengthComputable && e.total > 0) {
                    _message_queue.recv_progress = e.loaded/e.total;
                }
            }; })(message_queue), false);

            x.setTimeoutInterval(_timeout_ms);
            x.setWithCredentials(_use_cors_credentials);
            x.send(gameapi_url(), 'POST', _msg, {});
        }; })(msg, timeout_ms, use_cors_credentials);
    }

    if(inject_lag > 0) {
        window.setTimeout(send_it, Math.floor(1000*inject_lag));
    } else {
        send_it();
    }

    message_queue = new AJAXMessageQueue();
    message_serial += 1;
}

var longpoll_error_count = 0;
var longpoll_in_progress = false;
function longpoll_send() {
    if(longpoll_in_progress) { return; }
    if(!gamedata['client']['enable_ajax_longpoll']) { return; }
    if(spin_game_use_websocket) { return; }

    var msg = 'myarg='+JSON.stringify([["LONGPOLL"]])+'&serial=-1&longpoll=1&session='+session.session_id.toString()+'&nokeepalive=1';
    if(player.is_developer()) {
        console.log('To Server: LONGPOLL');
    }

    longpoll_in_progress = true;
    goog.net.XhrIo.send(gameapi_url(), function(event) {
        longpoll_in_progress = false;
        var repeat = (client_state != client_states.TIMED_OUT);
        if(!event.target.isSuccess()) {
            var code = event.target.getLastErrorCode();
            console.log('LONGPOLL error code '+code);
            if(code === goog.net.ErrorCode.HTTP_ERROR) {
                // we failed to send the request, or got a bad HTTP response code back
                longpoll_error_count += 1;
                if(longpoll_error_count >= 4) { repeat = false; } // don't spam if we can't get requests through
            } else if(code === goog.net.ErrorCode.TIMEOUT) {
                // ordinary timeout
            } else {
                // some unknown error
                repeat = false;
            }
        } else {
            if(on_ajax(event.target.getResponseText(), 'LONGPOLL') < 0) {
                // when we get a message back with -1 as the serial, treat that as a serious error
                repeat = false; // longpoll_error_count += 1;
            }
        }
        if(repeat) {
            longpoll_send(); // send again
        }
    }, 'POST', msg, {}, 1000*gamedata['client']['ajax_longpoll_timeout'], true);
}

// queue of user notifications that occur upon login or next session change
// (not active during initial on-rails tutorial or in combat)
/** @constructor */
function NotificationQueue() {
    this.queue = [];
    this.hold_time = -1;
    this.achievements = []; // buffer up achievements in case we get more than one in a single transaction
}

// fire the next notification message in the queue
NotificationQueue.prototype.fire_next = function() {
    if(this.hold_time > 0 && client_time < this.hold_time) { return; }

    var item = null, item_i = -1, prio = -1000;

    for(var i = 0; i < this.queue.length; i++) {
        // only fire notifications when at home OR at a friendly quarry OR if the show_if_away option is set
        if(session.home_base ||
           (session.is_quarry() && (session.viewing_user_id == session.user_id)) ||
           this.queue[i]['show_if_away']) {
            if(this.queue[i]['priority'] > prio) {
                item_i = i;
                item = this.queue[i];
                prio = item['priority'];
            }
        }
    }

    if(item) {
        this.queue.splice(item_i,1);
        item['cb']();
        player.quest_tracked_dirty = true;
    }
};

NotificationQueue.prototype.push = function(cb, params) {
    if(!params) { params = {}; }
    this.queue.push({'cb':cb,
                     'priority': params['priority'] || 0,
                     'show_if_away': params['show_if_away'] || false
                    });
};
NotificationQueue.prototype.push_with_priority = function(cb, priority) { this.push(cb, {'priority':priority}); };

NotificationQueue.prototype.pending = function() { return this.queue.length > 0; };
NotificationQueue.prototype.clear = function() { this.queue = []; };
NotificationQueue.prototype.hold_until = function(t) { this.hold_time = Math.max(this.hold_time, t); };
NotificationQueue.prototype.remove = function(cb) {
    for(var i = 0; i < this.queue.length; i++) {
        if(this.queue[i]['cb'] === cb) {
            this.queue.splice(i,1);
            i -= 1;
        }
    }
};

var notification_queue = new NotificationQueue();


// main code

// spin_loading_screen_mode meanings:
// "canvas" = old method, hide startup_div immediately and paint loading_screen_image on white canvas
// "div" = new method, keep startup_div visible until canvas is ready to paint game
var loading_screen_image = null; // reference to HTML5 Image element for OLD loading screen
var startup_div_shown = true;

var kill_startup_div = function() {
    if(!startup_div_shown) { return; }
    startup_div_shown = false;
    var startup_div = document.getElementById('startup_div');
    var fade_time = (spin_loading_screen_mode == 'div' ? (gamedata['client']['startup_div_fade_time'] || 0.5) : -1);
    if(fade_time > 0) {
        var set_startup_div_fade = (function (_start_time, _end_time, _div) { return function() {
            if(client_time >= _end_time) {
                _div.style.display = 'none'; return;
            }
            _div.style.opacity = 1.0 - (client_time - _start_time)/(_end_time - _start_time);
            window.setTimeout(set_startup_div_fade, 1000*gamedata['client']['startup_div_fade_tick']);
        }; })(client_time, client_time + fade_time, startup_div);
        set_startup_div_fade();
    } else {
        startup_div.style.display = 'none';
    }
};
var kill_loading_screen = function() {
    kill_startup_div();
    loading_screen_image = null; // don't need this any more, let GC have it
};

var blacklist_audio = false;

SPINPUNCHGAME.watchdog_timer = null;
SPINPUNCHGAME.shutdown_in_progress = false;

SPINPUNCHGAME.shutdown = function() {
    SPINPUNCHGAME.shutdown_in_progress = true;

    if(SPINPUNCHGAME.watchdog_timer) {
        window.clearTimeout(SPINPUNCHGAME.watchdog_timer);
        SPINPUNCHGAME.watchdog_timer = null;
    }

    if(session.connected()) {
        // flush damage changes
        flush_dirty_objects({});
        send_to_server.func(["LOGOUT"]);
        flush_message_queue(true);

        // mark session as not connected anymore so we don't try to send messages again
        session.connect_time = -1;
    }

    if(the_websocket) {
        the_websocket.close();
        the_websocket = null;
    }
};

// sends metric to game server
function metric_event(event_name, props) {
    if(typeof props === 'undefined') { props = {}; }
    if(session.connected()) {
        // send through the server connection
        SPLWMetrics.prepare_props(event_name, props);
        send_to_server.func(["REPORT_METRIC", event_name, props]);
    } else {
        // send through the early metrics connection
        SPLWMetrics.send_event(spin_metrics_anon_id, event_name, props);
    }
}

// send exception info to server as a metric event
SPINPUNCHGAME.client_exception_sent = false;
function log_exception(e, where) {
    if(SPINPUNCHGAME.client_exception_sent) { return; }
    SPINPUNCHGAME.client_exception_sent = true;
    var msg;
    if(e) {
        msg = e.toString();
        if(e.stack) {
            // some browsers (Chrome) repeat the message at the beginning of the stack - trim that off
            var stack = e.stack.toString();
            if(stack.indexOf(msg) == 0) {
                stack = stack.slice(msg.length);
                while(stack.length >= 1 && stack[0] == '\n') { stack = stack.slice(1); } // strip off leading newlines
            }
            msg += '\nstack:\n'+stack;
        }
        if(e.message) {
            msg += '\nmessage: '+e.message.toString();
        }

        /* I don't think this works anymore...
        try {
            msg += '\ntraceback: ' +Traceback.printStackTrace({e:e, guess:false}).join('\n');
        } catch(ex) {}
        */
    } else {
        msg = 'none';
    }

    // show in JS console
    console.log('Exception thrown in '+where+':\n'+msg);

    if(player.is_developer()) {
        window.alert('SpinPunch CLIENT EXCEPTION in \"'+where+'\" (check JS Console for more detail):\n'+msg);
    }

    // phone home
    var MAX_LEN = gamedata['client']['max_exception_msg_length'];
    if(msg.length > MAX_LEN) { msg = msg.slice(0,MAX_LEN); }
    metric_event('0970_client_exception', add_demographics({'method':msg, 'location':where,
                                                            'since_connect': (session.connected() ? client_time - session.connect_time : -1),
                                                            'since_pageload': client_time - spin_pageload_begin,
                                                            'gameclient_build_date':(typeof gameclient_build_date === 'undefined' ? 'unknown' : gameclient_build_date),
                                                            'gamedata_build_info':gamedata['gamedata_build_info']}));
}

function do_unsupported_browser_redirect(url) {
    location.href = (url ? url : spin_unsupported_browser_landing);
}

function do_account_banned_redirect() {
    location.href = gamedata['strings']['account_banned_landing'];
}

// fill in "Your Player ID:" at right side of linkbar
function linkbar_put_id(user_id) {
    if(user_id <= 0) { return; }
    var bar = document.getElementById('spin_footer_linkbar_id');
    if(!bar) { return; }
    bar.innerHTML = '<font size="-1">Your Player ID: <b>'+user_id.toString()+'</b></font>&nbsp;&nbsp;&nbsp;';
}

// replace __USER_ID__/__ISSUE_ID__ in URL paths (or any string) with the player's actual user_id and camouflaged money_spent amount
function url_put_info(url, user_id, money_spent) {
    // replace __ISSUE_ID__ with camouflaged money_spent
    var camo = gamedata['game_id']+'_';
    for(var c = 0; c < 6; c++) { camo += Math.floor(10*Math.random()).toString(); }
    camo += '_';
    camo += reverse_digits(money_spent);

    // replace Zendesk "PP_code" with another camouflaged money_spent
    var PP_CODES = [[1000,'pp_code_3888'], [100,'pp_code_2888'], [0.01, 'pp_code_1866'], [-1, 'pp_code_0866']];
    var pp;
    for(pp = 0; pp < PP_CODES.length; pp++) {
        if(money_spent >= PP_CODES[pp][0]) {
            break;
        }
    }

    var replacements = {
        '__USER_ID__': user_id.toString(),
        '__SOCIAL_ID__': spin_social_id ? spin_social_id.toString() : '',
        '__FACEBOOK_ID__': spin_facebook_user ? spin_facebook_user.toString() : '',
        '__KONGREGATE_ID__': spin_kongregate_user ? spin_kongregate_user.toString() : '',
        '__FRAME_PLATFORM__': spin_frame_platform.toString(),
        '__ISSUE_ID__': camo,
        '__PP_CODE__': PP_CODES[pp][1]
    };

    goog.object.forEach(replacements, function(v,k) {
        while(url.indexOf(k) != -1) {
            url = url.replace(k, v);
        }
    });

    return url;
}

SPINPUNCHGAME.init = function() {
    console.log('init');

    var p = get_query_string('inject_lag');
    if(p) { inject_lag = parseFloat(p); }

    ajax_config = gamedata['client']['ajax_config'][(spin_ajax_config in gamedata['client']['ajax_config']) ? spin_ajax_config : 'default'];

    // we've had trouble with some browsers (Chrome, Safari) not firing these events reliably when navigating away from the game page
    // call shutdown from BOTH unload and beforeunload to be as sure as possible that we send a logout (though it is still not guaranteed)
    window.addEventListener("beforeunload", SPINPUNCHGAME.shutdown, false);
    window.addEventListener("unload", SPINPUNCHGAME.shutdown, false);

    if(document.URL.indexOf('anon_mode=1') != -1) { anon_mode = true; }
    if(document.URL.indexOf('dev_linkbar=1') != -1) { document.getElementById('canvas_div').style.height = '50%'; }

    linkbar_put_id(spin_user_id);

    // this timer is cleared after the first frame renders successfully.
    // if it ever actually fires, then chances are the browser encountered an error running the client code
    SPINPUNCHGAME.watchdog_timer = window.setTimeout(function() {
        metric_event('0950_watchdog_timer_fired', add_demographics({}));
        SPINPUNCHGAME.watchdog_timer = null;
    }, 10*1000);

    canvas_div = document.getElementById('canvas_div');
    canvas = document.getElementById('canvas');

    ctx = null;
    if(canvas.getContext) {
        ctx = canvas.getContext('2d');
    }

    // check for bad browsers
    var unsupported_reason = null, unsupported_url = null;
    if(!ctx || !ctx.fillText) {
        console.log('Browser does not support HTML5 canvas!');
        unsupported_reason = 'HTML5 Canvas';
    } else if(spin_demographics['browser_name'] === 'Firefox' &&
              spin_demographics['browser_version'] < 6) {
        unsupported_reason = 'Firefox version < 6';
    } else if(spin_demographics['browser_name'] === 'Chrome' &&
              spin_demographics['browser_version'] <= 6) {
        unsupported_reason = 'Chrome version < 6';
        unsupported_url = gamedata['strings']['bad_chrome_version_landing'];
    } else if(spin_demographics['browser_name'] === 'Chrome' &&
              chrome_version_atleast(33,0,1700,0) &&
              !chrome_version_atleast(33,0,1721,0)) {
        unsupported_reason = 'Chrome v33 beta with JS parser bug';
        unsupported_url = gamedata['strings']['bad_chrome_version_landing'];
    }

    if(unsupported_reason) {
        SPLWMetrics.send_event(spin_metrics_anon_id, '0940_unsupported_browser',
                               add_demographics({'method':unsupported_reason}));
        // wait to hopefully allow metrics to fire
        window.setTimeout((function (_url) { return function() { do_unsupported_browser_redirect(_url); }; })(unsupported_url), 1500);
        return;
    }

    // initialize graphics modules

    // detect browser font rendering gamma
    var fonts_are_thick = false;
    if(spin_demographics['browser_name'] === 'Firefox') {
        fonts_are_thick = true;
    } else if(spin_demographics['browser_name'] === 'Chrome') {
        // Chrome switched from "thin" to "thick" gamma in Chrome/22.0.1229.79
        // and back again to "thin" in Chrome/22.0.1229.92
        // and back again to "thick" in Chrome/24.0.1312.52
        fonts_are_thick = (chrome_version_atleast(22,0,1229,79) && !chrome_version_atleast(22,0,1229,92)) || chrome_version_atleast(24,0,1312,52);
    }

    // hack for horrible Chrome text rendering bug
    var low_fonts = false;
    if(get_query_string('low_fonts') == '1') {
        low_fonts = true;
    } else if(spin_demographics['browser_name'] === 'Chrome') {
        low_fonts |= (chrome_version_atleast(30,0,1599,69) && !chrome_version_atleast(30,0,1599,101));
    }

    SPUI.init(canvas, ctx, {fonts_are_thick: fonts_are_thick, low_fonts: low_fonts});

    window.addEventListener("resize", on_resize_browser, false);

    // call once to set initial canvas size
    on_resize_browser(null);

    // better locate tutorial stuff on first run
    view_pos = [0,50];

    // disable browser's default right-click->context menu behavior on the canvas
    canvas.addEventListener("contextmenu", function(e) { e.preventDefault(); }, true);

    if(touch_mode === touch_modes.TOUCHEVENT) {
        canvas.addEventListener("touchstart", on_touchstart, false);
        canvas.addEventListener("touchend", on_touchend, false);
        canvas.addEventListener("touchcancel", on_touchend, false);
        canvas.addEventListener("touchmove", on_touchmove, false);
    } else if(touch_mode === touch_modes.MSPOINTER && 1) { // disable this if anything breaks on IE
        canvas.addEventListener("MSPointerDown", on_MSPointerDown, false);
        canvas.addEventListener("MSPointerUp", on_MSPointerUp, false);
        canvas.addEventListener("MSPointerOut", on_MSPointerOut, false);
        canvas.addEventListener("MSPointerMove", on_MSPointerMove, false);
    }

    canvas.addEventListener("mousedown", on_mousedown, false);
    canvas.addEventListener("mouseup", on_mouseup, false);
    canvas.addEventListener("mousemove", on_mousemove, false);

    if(!touch_primary) {
        if(spin_demographics['browser_name'] === "Firefox") {
            canvas.addEventListener("DOMMouseScroll", on_mousewheel, false);
        } else {
            canvas.addEventListener("mousewheel", on_mousewheel, false);
        }
    }


    // allow canvas to acquire focus (and force focus when mouse is over it) so that keydown events work
    // see http://www.dbp-consulting.com/tutorials/canvas/CanvasKeyEvents.html
    canvas.setAttribute('tabindex', '0');
    canvas.focus();
    canvas.addEventListener("mouseover", function(e) { canvas.focus(); }, false);
    canvas.addEventListener("mouseout", on_mouseout, false);
    canvas.addEventListener("mouseout", function(e) { canvas.blur(); }, false);
    canvas.addEventListener("keydown", on_keydown, false);
    canvas.addEventListener("keypress", on_keypress, false);
    canvas.addEventListener("keyup", on_keyup, false);
    canvas.addEventListener("textInput", on_textInput, false);

    pointer_lock_supported = ('webkitPointerLockElement' in document);
    if(pointer_lock_supported) {
        document.addEventListener("webkitpointerlockchange", on_pointer_lock_change, false);
        document.addEventListener("mousemove", on_mousemove, false);
    }

    // requestAnimationFrame shim from http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    window['requestAnimFrame'] = (function(){
        var fun =
              window['requestAnimationFrame']       ||
              window['webkitRequestAnimationFrame'] ||
              window['mozRequestAnimationFrame']    ||
              window['oRequestAnimationFrame']      ||
              window['msRequestAnimationFrame'];
        // disable this on Chrome on Mac OSX since it performs terribly
//      if((navigator.userAgent.indexOf('Chrome') != -1) &&
//         (navigator.platform.indexOf('Mac') != -1)) {
//          console.log('Disabling requestAnimationFrame for Chrome on Mac OSX due to performance bugs!');
//          fun = null;
//      } else {
        if(get_query_string('requestAnimationFrame') != '1') {
            fun = null;
        }
//      }

        var ret;
        USING_REQUESTANIMATIONFRAME = (fun != null);
        if(fun != null) {
            console.log("using requestAnimationFrame for animation");
            ret = function(callback, element, delay_ms) { fun(callback, element); };
        } else {
            ret = function(/* function */ callback, /* DOMElement */ element, /* number */ delay_ms){
                LAST_ANIM_FRAME_TIMEOUT = delay_ms;
                window.setTimeout(callback, delay_ms);
            };
            console.log("requestAnimationFrame not available or disabled; using setTimeout for animation");
        }
        return ret;
    })();

    // note: Closure incorrectly obfuscates these canvas/document properties, so manually quote all lookups
    canvas['SPINrequestFullScreen'] = (function() {
        var event_name = null, fun = null;

        // standard version
        fun = canvas['requestFullScreenWithKeys'] ||
            canvas['requestFullScreen'];
        if(fun) {
            event_name = 'fullscreenchange';
        } else {
            // try webkit version
            fun = canvas['webkitRequestFullScreenWithKeys'] ||
                  canvas['webkitRequestFullScreen'];
            if(fun) {
                event_name = 'webkitfullscreenchange';
                // manually ensure keyboard input works
                if(fun === canvas['webkitRequestFullScreen']) {
                    fun = function() { canvas['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']); };
                }
            } else {
                // try mozilla version
                fun = canvas['mozRequestFullScreenWithKeys'] ||
                      canvas['mozRequestFullScreen'];
                if(fun) {
                    event_name = 'mozfullscreenchange';
                } else {
                    // try IE version
                    fun = canvas['msRequestFullScreenWithKeys'] ||
                          canvas['msRequestFullScreen'];
                    if(fun) {
                        event_name = 'msfullscreenchange';
                    }
                }
            }
        }
        if(fun && event_name) {
            console.log("fullscreen support is available (event "+event_name+")");
            document['SPINcancelFullScreen'] = document['cancelFullScreen'] ||
                                           document['webkitCancelFullScreen'] ||
                                           document['mozCancelFullScreen'] ||
                                           document['msCancelFullScreen'];
            // install event handler
            document.addEventListener(event_name, function(e) {
                if(!document['fullScreenElement'] && !document['mozFullScreen'] && !document['webkitIsFullScreen'] &&
                   // not sure what flag to use here
                   !document['msIsFullScreen'] && !document['msFullScreen']
                  ) {
                    console.log('exiting fullscreen mode');
                    canvas_is_fullscreen = false;
                } else {
                    console.log('entering fullscreen mode');
                    canvas_is_fullscreen = true;
                }
            }, false);
        } else {
            console.log("fullscreen support is NOT available in this browser");
        }
        return fun;
    })();

    console.log("Client starting, using gamedata version "+gamedata["version"]);

    player.init();
    enemy.init();

    // add virtual units
    for(var name in gamedata["virtual_units"]) {
        player.virtual_units[name] = { spec: gamedata["virtual_units"][name], id: GameObject.VIRTUAL_ID, team: 'player', stats: {},
                                       is_mobile: function() { return 0; },
                                       is_building: function() { return 0; },
                                       is_destroyed: function() { return 0; }
                                     };
    }

    if(spin_loading_screen_mode == 'canvas') {
        // start downloading the splash screen before GameArt init
        loading_screen_image = new Image();
        loading_screen_image.src = GameArt.art_url(spin_loading_screen_data, false);
    }

    // old Chrome on Windows crashes with audio
    if(spin_demographics['browser_name'] === 'Chrome' &&
       spin_demographics['browser_OS'] === 'Windows' &&
       !chrome_version_atleast(17, 0, 963, 66)) {
        blacklist_audio = true;
        console.log('blacklisting audio on Windows Chrome version < 17.0.963.66');
    }

    // iOS hangs audio
    if(spin_demographics['browser_name'] === 'Safari' &&
       spin_demographics['browser_OS'] === 'iOS') {
        blacklist_audio = true;
        console.log('blacklisting audio on iOS Safari');
    }

    if(spin_demographics['browser_name'] === 'Opera') {
        blacklist_audio = true;
        console.log('blacklisting audio on Opera');
    }

    SPUI.time = SPFX.time = client_time = (new Date()).getTime()/1000;
    ctx.font = SPUI.desktop_font.str();

    // set up permanent UI elements

    // add error log
    user_log = new SPUI.ErrorLog(5);
    desktop_dialogs['user_log'] = user_log;
    //SPUI.root.add(user_log);
    user_log.xy = [200, 120];

    // display any messages passed from the web page scripts
    for(var i = 0; i < spin_init_messages.length; i++) {
        user_log.msg(spin_init_messages[i], new SPUI.Color(0.5,1,1,1));
    }

    // send time_to_loading metric
    if(gamedata['client']['enable_loading_metrics']) {
        var time_to_loading = (new Date()).getTime()/1000 - spin_pageload_begin;
        SPLWMetrics.send_event(spin_metrics_anon_id, '0105_game_load_start',
                               {'time_to_loading':time_to_loading});
    }

    // try websockets by default, if able and gamedata.client.enable_websockets is true
    if(spin_game_direct_connect && gamedata['client']['enable_websockets'] && SPWebsocket.is_supported() &&
       (parseInt(spin_game_server_ws_port,10) > 0 || parseInt(spin_game_server_wss_port,10) > 0)) {
        spin_game_use_websocket = true;
    }

    // send CLIENT_HELLO first to try to make sure it doesn't get pushed behind graphics download
    var user_demographics = [spin_demographics['browser_name'] || 'unknown',
                             spin_demographics['browser_version'] || 'unknown',
                             spin_demographics['browser_OS'] || 'unknown',
                             spin_demographics['locale'] || 'unknown',
                             spin_demographics['browser_hardware'] || 'unknown'];

    // send browser caps metric
    var audio_context_works = false;
    try { if((typeof(AudioContext) != 'undefined') || (typeof(webkitAudioContext) != 'undefined')) { audio_context_works = true; } } catch(e) {};
    /*
    var webgl_works = false;
    try {
        var temp = document.createElement('canvas');
        var ctxNames = ['webgl', 'experimental-webgl'];
        var glCtx = temp.getContext('webgl') || temp.getContext('experimental-webgl');
        if(glCtx) { webgl_works = true; }
    } catch(e) {}
    */
    var browser_caps = {'canvas': 1,
                        //'webgl': webgl_works ? 1 : 0,
                        'websocket': SPWebsocket.is_supported() ? 1 : 0,
                        'audio_element': (buzz.isSupported() ? 1 : 0),
                        'audio_ogg': (buzz.isSupported() && buzz.isOGGSupported() ? 1 : 0),
                        'audio_wav': (buzz.isSupported() && buzz.isWAVSupported() ? 1 : 0),
                        'audio_mp3': (buzz.isSupported() && buzz.isMP3Supported() ? 1 : 0),
                        'audio_aac': (buzz.isSupported() && buzz.isAACSupported() ? 1 : 0),
                        'audio_context': (audio_context_works ? 1 : 0)};

    if(spin_demographics['browser_hardware'] == "iPad" || spin_demographics['browser_hardware'] == "iPhone") {
        browser_caps['retina_display'] = ((window['devicePixelRatio'] && (window['devicePixelRatio'] >= 2)) ? 1 : 0);
    }

    last_proxy_keepalive = client_time; // unnecessary to send a proxy keepalive immediately

    var client_build_date_str = (typeof gameclient_build_date === 'undefined' ? 'unknown' : gameclient_build_date);

    session.client_hello_packet = ["CLIENT_HELLO",
                                   SPHTTP.wrap_string(spin_game_query_string),
                                   spin_facebook_signed_request,
                                   spin_social_id,
                                   spin_metrics_anon_id,
                                   spin_session_id,
                                   user_demographics,
                                   browser_caps,
                                   gamedata['gamedata_build_info'],
                                   client_build_date_str,
                                   spin_session_time,
                                   spin_session_data,
                                   spin_facebook_oauth_token,
                                   spin_session_signature,
                                   spin_facebook_login_permissions,
                                   null,
                                   spin_login_country,
                                   spin_user_id];

    SPLWMetrics.send_event(spin_metrics_anon_id, '0105_client_start', add_demographics({'splash_image':spin_loading_screen_name}));

    // uncomment these brackets to test proxyserver race conditions
    //window.setTimeout(function() {
    send_to_server.func(session.client_hello_packet);

    flush_message_queue(true, ajax_config['message_timeout_hello']);

    if(spin_loading_screen_mode == 'canvas') {
        kill_startup_div();
    }

    draw();
    //}, 3000);

    SPFB.AppEvents.activateApp();
};

// spawn desktop dialogs
// This should be called every time the session changes, because the dialogs are different
// depending on whether the player is looking at their own base or someone else's.

var global_chat_frame = null; // same chat frame is re-used for entire session
var global_spell_icon = null;

function init_desktop_dialogs() {
    // destroy the current desktop
    for(var name in desktop_dialogs) {
        var dialog = desktop_dialogs[name];
        if(dialog.parent) {
            if(name === 'chat_frame' || name === 'user_log') {
                // do not destroy these dialogs, just unparent
                dialog.parent.unparent(dialog);
            } else {
                dialog.parent.remove(dialog);
                delete desktop_dialogs[name];
            }
        }
    }

    // top dialog
    var dialog_name;
    if(session.home_base) {
        dialog_name = 'desktop_top';
    } else {
        dialog_name = 'desktop_top_visitor';
    }
    dialog = new SPUI.Dialog(gamedata['dialogs'][dialog_name]);
    dialog.transparent_to_mouse = true;
    desktop_dialogs['desktop_top'] = dialog;

    if(session.home_base && session.has_deployed) {
        // defensive battle bars
        var defensive_battle_bars = invoke_defensive_battle_bars();
        desktop_dialogs['defensive_battle_bars'] = defensive_battle_bars;
        SPUI.root.add(defensive_battle_bars);
    }

    var enable_control_buttons = (!session.has_attacked &&
                                  ((player.tutorial_state == "COMPLETE") ||
                                   gamedata['tutorial'][player.tutorial_state]['enable_desktop_control_buttons']));

    if(session.home_base) {
        dialog.widgets['keyboard_shortcuts_button'].show =
            dialog.widgets['battle_history_button'].show =
           dialog.widgets['battle_history_jewel'].show =
            dialog.widgets['leaderboard_button'].show = enable_control_buttons;

        dialog.widgets['leaderboard_button'].onclick = function(w) { invoke_leaderboard(); };
        dialog.widgets['keyboard_shortcuts_button'].onclick = invoke_keyboard_shortcuts;
        dialog.widgets['keyboard_shortcuts_jewel'].ondraw = update_notification_jewel;
        dialog.widgets['keyboard_shortcuts_jewel'].show = enable_control_buttons && player.get_any_abtest_value('enable_keyboard_shortcuts_jewel', gamedata['client']['enable_keyboard_shortcuts_jewel']);

        dialog.widgets['battle_history_button'].onclick = function(w) { invoke_battle_history_dialog(session.user_id, -1, '', -1, w); };
        dialog.widgets['battle_history_jewel'].ondraw = update_notification_jewel;

        dialog.widgets['trialpay_button'].onclick = function(w) { Store.trialpay_invoke(); };
        dialog.widgets['trialpay_button'].show = enable_control_buttons && ((player.tutorial_state === "COMPLETE") && player.get_abtest_value('T015_offer_wall_t4', 'enable', 0));
        dialog.widgets['alliances_button'].show = enable_control_buttons && ((player.tutorial_state === "COMPLETE") && player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances']));
        dialog.widgets['alliances_button'].onclick = invoke_alliance_dialog;

        dialog.widgets['quest_tracker_title'].onclick =
            dialog.widgets['quest_tracker_descr'].onclick = function() {
                invoke_missions_dialog(true, player.quest_tracked);
            };

    } else { // NOT at home base

        // set up enemy portrait
        if(session.viewing_base.base_landlord_id != session.user_id) {
            var enemy_portrait_dialog = invoke_enemy_portrait_dialog();
            desktop_dialogs['enemy_portrait_dialog'] = enemy_portrait_dialog;
            SPUI.root.add(enemy_portrait_dialog);

            var enemy_resource_bars = new SPUI.Dialog(gamedata['dialogs']['enemy_resource_bars']);
            enemy_resource_bars.ondraw = update_enemy_resource_bars;
            desktop_dialogs['enemy_resource_bars'] = enemy_resource_bars;
            SPUI.root.add(enemy_resource_bars);

            init_playfield_speed_bar();
        }
    }

    if(session.home_base) {
        // developer button
        if(!spin_secure_mode && player.is_developer() && !anon_mode) {
            dialog.widgets['developer_button'].show = true;
            dialog.widgets['developer_button'].onclick = invoke_cheat_menu;
        } else {
            dialog.widgets['developer_button'].show = false;
        }

        dialog.widgets['skip_tutorial_button'].onclick = function() {
            var s = gamedata['strings']['skip_tutorial_confirm'];
            invoke_child_message_dialog(s['ui_title'], s['ui_description'],
                                        {'cancel_button': true,
                                         'ok_button_ui_name': s['ui_button'],
                                         'on_ok': tutorial_opt_out});
        };
        dialog.widgets['question_button'].onclick = function() {
            player.quest_tracked = null; player.quest_tracked_dirty = true; // allow re-initialization of highest-priority quest
            var tracked = tutorial_opt_in();

            // if we can't automatically pick up a quest with GUI tips, punt by showing missions dialog
            if(!tracked || tracked['ui_instructions']) {
                invoke_missions_dialog(true);
            }
        };
    }

    // when defending home base against AI attack, hide resource bars and show "Surrender" button
    if(session.home_base) {
        if(session.has_attacked) {
            if(player.tutorial_state == "COMPLETE") {
                dialog.widgets['surrender_button'].show = true;
            } else {
                dialog.widgets['surrender_button'].show = false;
            }

            dialog.widgets['surrender_button'].onclick = surrender_to_ai_attack;
        }
    }

    // parent user_log to desktop_top
    dialog.add(user_log);

    // the desktop_top ondraw function goes and updates ALL desktop dialogs
    dialog.ondraw = update_desktop_dialogs;
    SPUI.root.add(dialog);

    // player portrait
    var player_portrait_dialog = invoke_player_portrait_dialog();
    desktop_dialogs['player_portrait_dialog'] = player_portrait_dialog;
    SPUI.root.add(player_portrait_dialog);

    // attack button dialog
    if(!session.home_base) {
        var attack_button_dialog = new SPUI.Dialog(gamedata['dialogs']['attack_button_dialog']);
        desktop_dialogs['attack_button_dialog'] = attack_button_dialog;
        attack_button_dialog.ondraw = update_attack_button_dialog;
        SPUI.root.add(attack_button_dialog);
    }

    // aura bar
    // IMPORTANT - must be added AFTER player_portrait_dialog because its ondraw needs to read the portrait's position
    var aura_bar = new SPUI.Dialog(gamedata['dialogs']['aura_bar']);
    aura_bar.transparent_to_mouse = true;
    desktop_dialogs['aura_bar'] = aura_bar;
    aura_bar.ondraw = update_aura_bar;
    SPUI.root.add(aura_bar);

    // combat resource bars
    if(!session.home_base) {
        var damage_bar = invoke_combat_damage_bar();
        damage_bar.show = false; // turn off initially so it doesn't flash on session change
        desktop_dialogs['combat_damage_bar'] = damage_bar;
        SPUI.root.add_under(damage_bar);

        var bars = invoke_combat_resource_bars();
        bars.show = false; // turn off initially so it doesn't flash on session change
        desktop_dialogs['combat_resource_bars'] = bars;
        SPUI.root.add_under(bars);
    }

    // playfield zoom bar
    if(player.get_any_abtest_value('enable_playfield_zoom', gamedata['client']['enable_playfield_zoom'])) {
        var zoombar = invoke_playfield_zoom_bar();
        desktop_dialogs['playfield_zoom_bar'] = zoombar;
        SPUI.root.add_under(zoombar);
    }

    // playfield controls bar
    var controls_bar = invoke_playfield_controls_bar();
    desktop_dialogs['playfield_controls_bar'] = controls_bar;
    SPUI.root.add_under(controls_bar);

    // desktop bottom

    if(session.home_base) {
        if(session.has_attacked) {
            dialog_name = 'desktop_bottom_defense';
        } else {
            dialog_name = 'desktop_bottom';
        }
    } else {
        dialog_name = 'desktop_bottom_visitor';
    }

    dialog = new SPUI.Dialog(gamedata['dialogs'][dialog_name]);
    dialog.transparent_to_mouse = true;
    desktop_dialogs['desktop_bottom'] = dialog;
    SPUI.root.add(dialog);

    if(session.home_base) {
        if(session.has_attacked) {
        } else {
            dialog.widgets['missions_button'].onclick = function() {
                if(player.tutorial_state == "COMPLETE" && (player.has_unread_mail() || player.has_uncollected_gift_mail())) {
                    invoke_mail_dialog(true);
                } else {
                    invoke_missions_dialog(true);
                }
            };
            dialog.widgets['map_button'].onclick = function() { invoke_map_dialog(null); };
            dialog.widgets['store_button'].onclick = function(w) { invoke_store(); };

            var do_add_friend = function() { change_selection(null); invoke_invite_friends_dialog('friend_bar'); }
            for(var i = 0; i < dialog.widgets['friend_bar'].data['widgets']['friend_icon']['array'][0]; i++) {
                dialog.widgets['friend_bar'].widgets['add_friend_button'+i.toString()].onclick = do_add_friend;
            }

            // last slot always shows add-friend button
            if(friend_invites_enabled()) {
                dialog.widgets['friend_bar'].widgets['add_friend_button6'].show = true;
                dialog.widgets['friend_bar'].widgets['friend_icon6'].show = false;
            } else {
                dialog.widgets['friend_bar'].widgets['add_friend_button6'].show = false;
                dialog.widgets['friend_bar'].widgets['friend_icon6'].show = true;
            }

            dialog.widgets['friend_bar'].user_data['friend_bar_pos'] = 0;
            dialog.widgets['friend_bar'].user_data['popout'] = null; // reference to popout dialog

            scroll_friend_bar(dialog.widgets['friend_bar'], -1);
            var friend_bar_scroller = function(_incr) { return function(w) {
                scroll_friend_bar(w.parent, w.parent.user_data['friend_bar_pos']+_incr);
            }; };
            dialog.widgets['friend_bar'].widgets['scroll_left'].onclick = friend_bar_scroller(-1);
            dialog.widgets['friend_bar'].widgets['scroll_right'].onclick = friend_bar_scroller(1);

            dialog.widgets['friend_bar'].show = read_predicate(gamedata['client']['friend_bar_enabled']).is_satisfied(player, null);

            dialog.widgets['friend_bar'].user_data['transition_start_time'] = -1;
            dialog.widgets['friend_bar'].user_data['maximized'] = !('friend_bar_minimized' in player.preferences && player.preferences['friend_bar_minimized']);

            get_preference_setting(player.preferences, 'enable_fishing_notifications')
            dialog.widgets['grow_toggle'].onclick = function(w) {
                var dialog = w.parent;
                dialog.widgets['friend_bar'].user_data['maximized'] = !dialog.widgets['friend_bar'].user_data['maximized'];

                player.preferences['friend_bar_minimized'] = !dialog.widgets['friend_bar'].user_data['maximized'];
                send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);

                dialog.widgets['friend_bar'].user_data['transition_start_time'] = client_time;
                if(dialog.widgets['friend_bar'].user_data['popout']) { close_dialog(dialog.widgets['friend_bar'].user_data['popout']); }
            };

            dialog.widgets['friend_bar'].ondraw = update_friend_bar;

            dialog.widgets['store_jewel'].user_data['count'] =
                dialog.widgets['you_have_mail_jewel'].user_data['count'] =
                dialog.widgets['buildings_jewel'].user_data['count'] = 0;
            dialog.widgets['store_jewel'].ondraw =
                dialog.widgets['you_have_mail_jewel'].ondraw =
                dialog.widgets['buildings_jewel'].ondraw = update_notification_jewel;
        }
    } else {
        dialog.widgets['home_button'].onclick = visit_base_home;
        dialog.widgets['home_button'].str = dialog.data['widgets']['home_button']['ui_name'+(session.using_squad_deployment() ? '_squads' : '')];

        // dynamically set up unit deployment bar
        var deployment_bar = (gamedata['unit_deploy_style'] == 'drip' ? 'unit_deployment_bar_drip' : 'unit_deployment_bar_batch');
        var d = new SPUI.Dialog(gamedata['dialogs'][deployment_bar]);
        if(gamedata['unit_deploy_style'] == 'drip') {
            d.user_data['drip_unit'] = null; // which unit is currently selected
        }
        dialog.add(d); dialog.widgets['unit_deployment_bar'] = d;
    }

    // chat frame
    if(!global_chat_frame) {
        global_chat_frame = init_chat_frame();
        desktop_dialogs['chat_frame'] = global_chat_frame;
    }

    if(session.home_base && !session.has_attacked) {
        SPUI.root.add(global_chat_frame);
        global_chat_frame.show = (player.tutorial_state === "COMPLETE");

        if(player.tutorial_state === "COMPLETE" && player.get_any_abtest_value('enable_desktop_quest_bar', gamedata['client']['enable_desktop_quest_bar'])) {
            QuestBar.init();
        }
    }

}

function update_notification_jewel(dialog) {
    // for jewel display: "text", a string, overrides "count", a number
    var text = dialog.user_data['text'] || null;
    var count = dialog.user_data['count'] || 0;
    dialog.widgets['num_bg'].show = dialog.widgets['num'].show = (count || text);
    if(dialog.widgets['num'].show) {
        dialog.widgets['num'].str = text || pretty_print_number(count);
        dialog.widgets['num_bg'].xy = dialog.widgets['num_bg'].data['xy' + (count >= 10 ? '_wide' : '' )];
        dialog.widgets['num_bg'].wh = dialog.widgets['num_bg'].data['dimensions' + (count >= 10 ? '_wide' : '' )];
    }
}

function scroll_friend_bar(dialog, page) {
    if(!dialog.parent) { return; } // orphaned

    if(page === -1) {
        page = dialog.user_data['friend_bar_pos'];
    } else {
        dialog.user_data['friend_bar_pos'] = page;
    }

    // remove popout
    if(dialog.user_data['popout']) {
        close_dialog(dialog.user_data['popout']);
    }

    // make list of real human friends
    var friend_list_hi = []; // >= level 3
    var friend_list_lo = []; // < level 3
    for(var i = 0; i < player.friends.length; i++) {
        var friend = player.friends[i];
        if(friend.is_ai() || !friend.is_real_friend) {
            continue;
        }
        if(friend.get_player_level() >= 3) {
            friend_list_hi.push(friend);
        } else {
            friend_list_lo.push(friend);
        }
    }

    var compare_by_player_level = function (a,b) {
        if(a.get_player_level() > b.get_player_level()) {
            return -1;
        } else if(a.get_player_level() < b.get_player_level()) {
            return 1;
        } else {
            return 0;
        }
    };

    // sort high-level list by player level (HIGH TO LOW)
    friend_list_hi.sort(compare_by_player_level);

    friend_list_lo.sort(compare_by_player_level);

    /*
    // sort low-level list by login time (recent to old) XXX needs PlayerCache info
    friend_list_lo.sort(function (a,b) {
        if(a.last_login_time > b.last_login_time) {
            return -1;
        } else if(a.last_login_time < b.last_login_time) {
            return 1;
        } else {
            return 0;
        }
    });
    */

    // only show first 10 people of low level
    var friend_list = friend_list_hi;
    for(var i = 0; i < Math.min(10, friend_list_lo.length); i++) {
        friend_list.push(friend_list_lo[i]);
    }

    // now fill in the dialog widgets
    var row = 0;
    var rows_per_page = dialog.data['widgets']['friend_icon']['array'][0]-1; // how many rows show up on each page

    var chapter_friends = friend_list.length; // total number of friends in this chapter

    // how many pages are in this chapter
    var chapter_pages = Math.floor((chapter_friends+rows_per_page-1)/rows_per_page);

    // reset the page index if it's out of bounds
    dialog.user_data['friend_bar_pos'] = page = (chapter_pages === 0 ? 0 : clamp(page, 0, chapter_pages-1));

    if(chapter_pages > 0) {
        // if any friends are to be shown

        // indices of the first and last friends able to be shown in the page
        var first_friend_on_page = page * rows_per_page;
        var last_friend_on_page = (page+1)*rows_per_page - 1;
        last_friend_on_page = Math.max(0, Math.min(last_friend_on_page, chapter_friends-1));

        // on click for friend button
        var click_cbmaker = function(uid, fbid, friend) { return function(w) {
            var friend_bar = w.parent;
            if(friend_bar.user_data['popout']) {
                    if(friend_bar.user_data['popout'].user_data['user_id'] == uid) {
                        // popout already up - visit base
                        visit_base(uid);
                        return;
                    } else {
                        close_dialog(friend_bar.user_data['popout']);
                    }
            }

            // spawn popout
            change_selection_ui(null);
            var dialog_data = gamedata['dialogs']['friend_bar_popout'];
            var dialog = new SPUI.Dialog(dialog_data);
            dialog.user_data['dialog'] = 'friend_bar_popout';
            dialog.user_data['user_id'] = uid;
            dialog.user_data['fbid'] = fbid;
            dialog.user_data['is_giftable'] = friend.is_giftable();
            selection.ui = dialog;
            SPUI.root.add(dialog);

            friend_bar.user_data['popout'] = dialog;
            dialog.on_destroy = (function (_friend_bar) { return function() { _friend_bar.user_data['popout'] = null; }; })(friend_bar);

            dialog.xy = vec_add(w.get_absolute_xy(), [-50, -161]);
            dialog.widgets['spy_button'].onclick = function(w) { visit_base(w.parent.user_data['user_id']); };

            dialog.widgets['gift_button'].show = (!!fbid && player.resource_gifts_enabled());
            if(dialog.widgets['gift_button'].show) {
                if(dialog.user_data['is_giftable']) {
                    dialog.widgets['gift_button'].state = 'normal';
                    dialog.widgets['gift_button'].tooltip.str = null;
                    dialog.widgets['gift_button'].onclick = function(w) {
                        var fbid = w.parent.user_data['fbid'];
                        change_selection_ui(null);
                        FBSendRequests.invoke_send_gifts_dialog(fbid);
                    };
                } else if(player.get_any_abtest_value('ungiftable_fallback_to_invite', gamedata['client']['ungiftable_fallback_to_invite'])) {
                    dialog.widgets['gift_button'].state = 'normal';
                    dialog.widgets['gift_button'].tooltip.str = null;
                    dialog.widgets['gift_button'].onclick = function(w) {
                        change_selection_ui(null);
                        // ANY giftable friends?
                        if(player.get_giftable_friend_info_list().length > 0) {
                            FBSendRequests.invoke_send_gifts_dialog(null);
                        } else {
                            var s = gamedata['errors']['NO_GIFTABLE_FRIENDS'];
                            invoke_child_message_dialog(s['ui_title'], s['ui_name'],
                                                        {'dialog': 'message_dialog_big',
                                                         'ok_button_ui_name': s['ui_button'],
                                                         'cancel_button': false,
                                                         'on_ok': function() {
                                                             invoke_invite_friends_dialog('ungiftable_fallback');
                                                         }});
                        }
                    };
                } else {
                    dialog.widgets['gift_button'].state = 'disabled';
                    dialog.widgets['gift_button'].tooltip.str = dialog.data['widgets']['gift_button']['ui_tooltip_already_sent'];
                }
            }

            dialog.widgets['message_button'].show = (!!fbid && (spin_frame_platform == 'fb'));
            if(dialog.widgets['message_button'].show) {
                dialog.widgets['message_button'].onclick = function(w) {
                    var uid = w.parent.user_data['user_id'];
                    var fbid = w.parent.user_data['fbid'];
                    change_selection_ui(null);
                    invoke_facebook_message_dialog(fbid, uid);
                };
            }

            dialog.widgets['info_button'].onclick = function(w) {
                var uid = w.parent.user_data['user_id'];
                change_selection_ui(null);
                invoke_player_info_dialog_unknown(uid);
            };

        }; };

        for(var i = first_friend_on_page; i <= last_friend_on_page; i++) {
            var friend = friend_list[i];
            var widget = dialog.widgets['friend_icon'+row.toString()];
            widget.show = true;
            widget.set_user(friend.user_id);
            widget.onclick = click_cbmaker(friend.user_id, friend.get_facebook_id(), friend);
            dialog.widgets['add_friend_button'+row.toString()].show = false;
            row += 1;
        }
    }

    // clear out empty rows
    while(row < rows_per_page) {
        dialog.widgets['add_friend_button'+row.toString()].show = friend_invites_enabled();
        dialog.widgets['friend_icon'+row.toString()].show = !dialog.widgets['add_friend_button'+row.toString()].show;
        dialog.widgets['friend_icon'+row.toString()].onclick = null;
        dialog.widgets['friend_icon'+row.toString()].set_user(null);
        row += 1;
    }

    // set clickability of scroll arrows
    if(page != 0) {
        dialog.widgets['scroll_left'].state = 'normal';
    } else {
        dialog.widgets['scroll_left'].state = 'disabled';
    }

    if(page < (chapter_pages-1)) {
        dialog.widgets['scroll_right'].state = 'normal';
    } else {
        dialog.widgets['scroll_right'].state = 'disabled';
    }

};

function update_friend_bar(dialog) {
    if(!dialog.parent) { return; } // dialog was closed

    dialog.parent.widgets['grow_up'].show = !dialog.user_data['maximized'];
    dialog.parent.widgets['grow_down'].show = !dialog.parent.widgets['grow_up'].show;

    var t = (dialog.user_data['transition_start_time'] > 0 ? clamp((client_time - dialog.user_data['transition_start_time']) / dialog.data['transition_time'], 0, 1) : 1);
    var base_xy_max = vec_add(dialog.parent.data['widgets']['friend_bar']['xy'], dialog.data['xy']);
    var base_xy_min = vec_add(dialog.parent.data['widgets']['friend_bar']['xy'], dialog.data['xy_minimized']);
    dialog.xy = vec_floor(vec_lerp(dialog.user_data['maximized'] ? base_xy_min : base_xy_max,
                                   dialog.user_data['maximized'] ? base_xy_max : base_xy_min, t));
}

function invoke_player_portrait_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['player_portrait_dialog']);
    dialog.widgets['player_portrait'].set_user(session.user_id);
    dialog.widgets['player_name'].onclick =
        dialog.widgets['player_portrait'].onclick = function() {
        if(player.tutorial_state != "COMPLETE") { return; }
        change_selection(null);
        invoke_player_info_dialog_self();
    };
    dialog.ondraw = update_player_portrait_dialog;
    return dialog;
}

function invoke_enemy_portrait_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['enemy_portrait_dialog']);
    if(!dialog.widgets['enemy_portrait'].user_id) {
        dialog.widgets['enemy_portrait'].set_user(session.viewing_user_id);
        if(session.viewing_ai) {
            dialog.widgets['enemy_portrait'].tooltip.str = ''; // get rid of Player Info tooltip for AIs
        }

        dialog.widgets['enemy_name'].onclick =
            dialog.widgets['enemy_portrait'].onclick = function() {
                if(player.tutorial_state != "COMPLETE" || session.viewing_ai || session.has_attacked) { return; }
                change_selection(null);
                invoke_player_info_dialog_unknown(session.viewing_user_id);
            };
    }
    dialog.ondraw = update_enemy_portrait_dialog;
    return dialog;
}

// update the small trophy counter displayed on yourself (who="player") or enemy (who="enemy") portrait dialogs
function update_portrait_trophy_widgets(dialog, who) {
    var show_it = player.is_ladder_player() || (player.current_trophy_pve_challenge_togo() > 0) || player.current_trophy_pvp_challenge_name();
    if(who == 'enemy' && (session.viewing_user_id == session.user_id || (session.viewing_ai && !session.is_ladder_battle()))) {
        show_it = false;
    }

    dialog.widgets[who+'_trophy_icon'].show = dialog.widgets[who+'_trophy_count'].show = show_it;
    if(!show_it) { return; }

    var trophy_type = (player.is_ladder_player() || player.current_trophy_pvp_challenge_name() ? 'pvp' : 'pve');
    var ui_trophy_type = gamedata['events'][(trophy_type == 'pvp' ? 'challenge_pvp_ladder' : player.current_trophy_pve_challenge_name())]['ui_name'];
    dialog.widgets[who+'_trophy_icon'].state = trophy_type;

    var count = 0;
    if(who == 'player') {
        var player_data = PlayerCache.query_sync(session.user_id);
        if(player_data && (('trophies_'+trophy_type) in player_data)) {
            count = player_data['trophies_'+trophy_type];
        }
    } else {
        // XXX if(session.viewing_ai && session.is_ladder_battle()) { ... do some adjustment? }
        var enemy_data = PlayerCache.query_sync(session.viewing_user_id);
        if(enemy_data && (('trophies_'+trophy_type) in enemy_data)) {
            count = enemy_data['trophies_'+trophy_type];
        }
    }

    var togo;
    if(trophy_type === 'pvp') {
        if(gamedata['matchmaking']['ladder_point_frequency'] === 'season') {
            togo = -1;
        } else {
            togo = player.current_trophy_pvp_challenge_togo();
        }
    } else {
        togo = player.current_trophy_pve_challenge_togo();
    }
    var display_count = display_trophy_count(count, trophy_type);

    dialog.widgets[who+'_trophy_count'].str = pretty_print_number(display_count);
    dialog.widgets[who+'_trophy_count'].text_color = (display_count >= 0 ? SPUI.default_text_color : SPUI.error_text_color);
    dialog.widgets[who+'_trophy_count'].tooltip.str = dialog.data['widgets'][who+'_trophy_count']['ui_tooltip'].replace('%d',dialog.widgets[who+'_trophy_count'].str).replace('%type', ui_trophy_type);
    if(togo > 0) {
        dialog.widgets[who+'_trophy_count'].tooltip.str += dialog.data['widgets'][who+'_trophy_count']['ui_tooltip_expiry'].replace('%expiry', gamedata['strings']['trophies_expire_in']).replace('%s', pretty_print_time_brief(togo));
    }

    // clicking on the trophy count brings up (in order of availability):
    // 1) Top Alliances tab, if an alliance PvP tournament is going on
    // 2) Leaderboard, PvP page
    // 3) nothing
    var trophy_cb = null;
    if(player.use_trophies()) {
        trophy_cb = function(w) {
            change_selection_ui(null);
            var d = _invoke_alliance_dialog();
            if(d) { alliance_list_change_tab(d, 'top'); }
        }
    } else if(read_predicate(gamedata['strings']['leaderboard']['categories']['trophies_pvp']['leaderboard_show_if']).is_satisfied(player,null)) {
        trophy_cb = function(w) {
            change_selection_ui(null);
            invoke_leaderboard(gamedata['matchmaking']['ladder_point_frequency'], 'all', 'trophies_pvp');
        }
    }

    dialog.widgets[who+'_trophy_count'].onclick = dialog.widgets[who+'_trophy_icon'].onclick = trophy_cb;
}


function update_player_portrait_dialog(dialog) {
    var convention = gamedata['client']['visiting_portrait_convention'] || 'both_players';
    var placement = null;

    if(convention == 'both_players') {
        // always show in upper-left
        placement = 'top_left';
    } else if(convention == 'base_owner') {
        if(session.viewing_base.base_landlord_id == session.user_id) {
            // show in upper-left
            placement = 'top_left';
        }
        // otherwise, not our base
    } else {
        throw Error('unhandled visiting_portrait_convention ' + convention);
    }

    if(placement == 'top_left') {
        var anchor = gamedata['client']['player_portrait_anchor'] || 'desktop_top';
        if(anchor == 'desktop_top') {
            dialog.xy = vec_add(get_shifted_console_position(), dialog.data['xy_desktop_top']);
        } else if(anchor == 'canvas_edge') {
            dialog.xy = vec_add([0,0], dialog.data[(global_chat_frame.is_visible() ? 'xy_with_chat' : 'xy')]);
        } else {
            throw Error('unhandled player_portrait_anchor '+anchor);
        }
    } else {
        dialog.show = false; return;
    }

    dialog.widgets['player_name'].str = player.get_ui_name();
    dialog.widgets['player_level'].str = dialog.widgets['player_level'].data['ui_name'].replace('%d', player.resource_state['player_level'].toString());
    dialog.widgets['player_name'].state = dialog.widgets['player_portrait'].state = (session.has_attacked ? 'disabled' : 'normal');
    dialog.widgets['player_portrait'].tooltip.str = (session.has_attacked ? null : dialog.data['widgets']['player_portrait']['ui_tooltip']);

    // display trophy counts
    update_portrait_trophy_widgets(dialog, 'player');

    // XP amount
    var next_level = player.resource_state['player_level']+1;
    var data = gamedata['player_xp']['level_xp'];
    var next_xp, next_xp_text, progress;
    if(next_level < data.length) {
        next_xp = data[next_level];
        next_xp_text = pretty_print_number(next_xp);
        var last_xp = data[next_level-1];
        progress = (player.resource_state['xp']-last_xp)/(next_xp-last_xp);
    } else {
        // exceeded max level!
        next_xp = -1;
        next_xp_text = '-';
        progress = 1;
    }
    var xp_text = pretty_print_number(player.resource_state['xp']);
    dialog.widgets['player_level'].tooltip.str =
        dialog.data['widgets']['player_level']['ui_tooltip'].replace('%s1', xp_text).replace('%s2', next_xp_text);

    dialog.widgets['player_xp_bar'].progress = progress;

    // flash effect
    var flashy_loot = player.flashy_loot();
    var t = (client_time - player.last_xp_time)/gamedata['client']['xp_bar_flash_duration'];
    var wdata = dialog.data['widgets']['player_xp_bar'];
    var col = wdata['full_color'];
    if(!flashy_loot || t >= 1) {
        t = 1;
        player.last_resource_state['xp'] = player.resource_state['xp'];
    } else if(t > 0) {
        var amp = Math.exp(-5*(t-0.2)*(t-0.2));
        var col0 = wdata['full_color'], col1 = wdata['flash_color'];
        col = [col0[0] + amp*(col1[0]-col0[0]),
               col0[1] + amp*(col1[1]-col0[1]),
               col0[2] + amp*(col1[2]-col0[2]),
               col0[3] + amp*(col1[3]-col0[3])];
    }
    dialog.widgets['player_xp_bar'].full_color = new SPUI.Color(col[0], col[1], col[2], col[3]);
}

function update_enemy_portrait_dialog(dialog) {
    var convention = gamedata['client']['visiting_portrait_convention'] || 'both_players';

    if(convention == 'both_players') {
        // always show in upper-right
        var anchor = gamedata['client']['player_portrait_anchor'] || 'desktop_top';
        if(anchor == 'canvas_edge') {
            dialog.xy = vec_add([canvas_width,0], dialog.data['xy_top_right']);
        } else {
            dialog.xy = vec_add(get_shifted_console_position(), dialog.data['xy_desktop_top']);
        }
    } else if(convention == 'base_owner') {
        // always show in upper-left
        dialog.xy = vec_add([0,0], dialog.data['xy_top_left']);
    } else {
        throw Error('unhandled visiting_portrait_convention ' + convention);
    }

    var enemy_name = session.ui_name;
    var max_len = dialog.data['widgets']['enemy_name']['max_len'];
    if(enemy_name.length > max_len) {
        enemy_name = enemy_name.slice(0,max_len)+'...';
    }
    dialog.widgets['enemy_name'].str = (anon_mode ? ANON_NAME2 : enemy_name);
    dialog.widgets['enemy_level'].str = dialog.widgets['enemy_level'].data['ui_name'].replace('%d',enemy.resource_state['player_level'].toString());
    dialog.widgets['enemy_name'].state = (session.has_attacked ? 'disabled' : 'normal');
    dialog.widgets['enemy_portrait'].tooltip.str = (session.has_attacked || session.viewing_ai ? null : dialog.data['widgets']['enemy_portrait']['ui_tooltip']);

    update_portrait_trophy_widgets(dialog, 'enemy');
}

// update the resource loot bars on the enemy player
// note: fancy flashing and dynamic movement not implemented
function update_enemy_resource_bars(dialog) {
    dialog.show = !!session.res_looter && session.viewing_base.base_type != 'squad';
    if(!dialog.show) { return; }

    var convention = gamedata['client']['visiting_portrait_convention'] || 'both_players';

    if(convention == 'both_players') {
        // anchor below enemy portrait at top-right
        dialog.xy = vec_add([canvas_width,0], dialog.data['xy_top_right_under_portrait']);
    } else if(convention == 'base_owner') {
        // always show in top-right
        dialog.xy = vec_add([canvas_width,0], dialog.data['xy_top_right']);
    } else {
        throw Error('unhandled visiting_portrait_convention ' + convention);
    }

    var starting = session.res_looter['starting'];
    var cur = session.res_looter['cur'];

    // resource fullness progress bars
    for(var res in gamedata['resources']) {
        var resdata = gamedata['resources'][res];
        var disp = cur[res] || 0;
        var show_me = (disp > 0) && (!('show_if' in resdata) || read_predicate(resdata['show_if']).is_satisfied(player,null));
        goog.array.forEach(['', '_prog', '_icon', '_amount'], function(w) {
            if('resource_bar_'+res+w in dialog.widgets) {
                dialog.widgets['resource_bar_'+res+w].show = show_me;
            }
        });
        if('resource_bar_'+res+'_amount' in dialog.widgets) {
            dialog.widgets['resource_bar_'+res+'_amount'].str = pretty_print_number(disp);
            dialog.widgets['resource_bar_'+res+'_amount'].text_scale = 1;
        }
        if('resource_bar_'+res+'_prog' in dialog.widgets) {
            dialog.widgets['resource_bar_'+res+'_prog'].full_color = SPUI.make_colorv(gamedata['resources'][res]['bar_full_color']);
            dialog.widgets['resource_bar_'+res+'_prog'].progress = Math.min(1, disp/starting[res]);
        }
        if(('resource_bar_'+res in dialog.widgets) && dialog.widgets['resource_bar_'+res].tooltip) {
            dialog.widgets['resource_bar_'+res].tooltip.str = dialog.data['widgets']['resource_bar_'+res]['ui_tooltip'].replace('%RES', resdata['ui_name']);
        }
    }
}

// update resource displays for desktop dialogs and the Store, with fancy ticker effects
/** @param {SPUI.Dialog} dialog
    @param {boolean} primary - if true, then apply the magnetic attractors for loot burst particle effects (only main desktop should have this)
    @param {boolean} use_res_looter - if true, reference session.res_looter instead of player resource state
    @param {boolean} show_during_combat */
function update_resource_bars(dialog, primary, use_res_looter, show_during_combat) {
    var flashy_loot = player.flashy_loot();
    var currency = (player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks' ? 'gamebucks' : 'facebook_credits');

    // overall hide/show
    goog.array.forEach(goog.object.getKeys(gamedata['resources']).concat(['fbcredits']), function(res) {
        if('resource_bar_'+res in dialog.widgets) {
            var show_me, show_button, show_button_asset;
            if(res == 'fbcredits') {
                show_me = show_during_combat || !session.has_attacked;
                show_button = show_me;
                show_button_asset = show_button;
                if(currency == 'gamebucks') {
                    dialog.widgets['resource_bar_'+res+'_icon'].asset = player.get_any_abtest_value('gamebucks_resource_icon', gamedata['store']['gamebucks_resource_icon']);
                } else {
                    dialog.widgets['resource_bar_'+res+'_icon'].asset = 'resource_icon_fbcredits';
                }
            } else {
                var resdata = gamedata['resources'][res];
                show_me = (show_during_combat || !session.has_attacked) && (!('show_if' in resdata) || read_predicate(resdata['show_if']).is_satisfied(player,null));
                show_button = show_me && !session.has_attacked;
                show_button_asset = show_button && (!('allow_instant' in resdata) || resdata['allow_instant']);
                dialog.widgets['resource_bar_'+res+'_icon'].asset = resdata['icon_small'];
            }
            goog.array.forEach(['', '_prog', '_icon', '_button', '_amount'], function (w) {
                if('resource_bar_'+res+w in dialog.widgets) {
                    dialog.widgets['resource_bar_'+res+w].show = (w == '_button' ? show_button : show_me);
                    if(w == '_button' && !show_button_asset) {
                        dialog.widgets['resource_bar_'+res+w].bg_image = null; // blank out the button, but still show it
                    }
                }
            });
            if('resource_bar_'+res+'_button' in dialog.widgets && show_me) {
                dialog.widgets['resource_bar_'+res+'_button'].state = (player.tutorial_state === "COMPLETE") ? 'normal':'disabled';
                if(res == 'fbcredits') {
                    dialog.widgets['resource_bar_'+res+'_button'].onclick =
                        dialog.widgets['resource_bar_'+res+'_icon'].onclick =
                        dialog.widgets['resource_bar_'+res].onclick =
                        Store.get_balance_plus_cb();
                } else {
                    dialog.widgets['resource_bar_'+res+'_button'].onclick =  (function (_res) { return function(w) {
                        if(w.parent) { w.parent.onleave(); } // get rid of tooltips
                        if(('allow_instant' in gamedata['resources'][_res]) && !gamedata['resources'][_res]['allow_instant']) {
                            var helper = get_requirements_help(_res, 1);
                            if(helper) { helper(); }
                        } else {
                            invoke_store(_res);
                        }
                    }; })(res);
                }
            }
        }
    });

    // SPFX physics attractors for loot burst effects
    if(primary && player.get_any_abtest_value('enable_loot_burst_effects', gamedata['client']['enable_loot_burst_effects']) && session.viewing_base) {
        for(var res in gamedata['resources']) {
            if('resource_bar_'+res+'_prog' in dialog.widgets) {
                if(!dialog.user_data[res+'_magnet']) {
                    var props = goog.object.clone(gamedata['client']['vfx']['resource_burst_magnet']);
                    props['charge'] = res;
                    dialog.user_data[res+'_magnet'] = SPFX.add_visual_effect([0,0],0,[0,1,0],client_time, props, false, null);
                    props = goog.object.clone(gamedata['client']['vfx']['resource_burst_drag']);
                    props['charge'] = res;
                    dialog.user_data[res+'_drag'] = SPFX.add_visual_effect([0,0],0,[0,1,0],client_time, props, false, null);
                }
                var magnet_pos_canvas = vec_add(dialog.xy, vec_add(dialog.widgets['resource_bar_'+res+'_prog'].xy, vec_scale(0.5, dialog.widgets['resource_bar_'+res+'_prog'].wh)));
                var magnet_pos_ortho = screen_to_ortho(magnet_pos_canvas); // projection of point at altitude=0
                var fake_alt = 20; // fake the magnet being "at altitude" above the ground
                dialog.user_data[res+'_magnet'].pos = [magnet_pos_ortho[0] + (10/15)*fake_alt, fake_alt, magnet_pos_ortho[1] + (10/15)*fake_alt];
            }
        }
    }

    // "resource_t" interpolates displayed resource values from old to new,
    // and controls the text-grow and ticker effect (but not the flashes)
    // use shorter ticker effects when gradual looting is happening
    var ticker_duration = ((session.has_attacked && gamedata['gradual_loot'] > 0) ? 0.1 : 1) * gamedata['client']['resource_ticker_duration'];
    var resource_t = (client_time - player.last_resource_time)/ticker_duration;
    if(resource_t >= 1) {
        resource_t = 1;
        player.last_resource_time = -1;
        for(var res in gamedata['resources']) {
            player.last_resource_state[res] = player.resource_state[res][1];
            session.last_loot[res] = session.loot[res] || 0;
            if(session.res_looter) {
                session.last_looted_uncapped[res] = session.res_looter['looted_uncapped'][res] || 0;
            }
        }
    } else if(resource_t < 0) {
        resource_t = 0;
    }

    var credits_t = (client_time - player.last_credits_time)/gamedata['client']['resource_ticker_duration'];
    if(credits_t >= 1) {
        credits_t = 1;
        player.last_credits_time = -1;
    } else if(credits_t < 0) {
        credits_t = 0;
    }

    var resource_text_scale = 1, credits_text_scale = 1;
    var PEAK = gamedata['client']['resource_ticker_grow_peak'];
    var GROW_AMOUNT = gamedata['client']['resource_ticker_grow_amount'];
    var SPEED = gamedata['client']['resource_ticker_decay_speed'];
    if(flashy_loot && !SPUI.low_fonts && resource_t > 0 && resource_t < 1) {
        var amp = Math.exp(-SPEED*(resource_t-PEAK)*(resource_t-PEAK));
        resource_text_scale = 1 + amp*(GROW_AMOUNT-1.0);
    }
    if(flashy_loot && !SPUI.low_fonts && credits_t > 0 && credits_t < 1) {
        var amp = Math.exp(-SPEED*(credits_t-PEAK)*(credits_t-PEAK));
        credits_text_scale = 1 + amp*(GROW_AMOUNT-1.0);
    }

    // resource bar flashes (both main resources at home and looted resources in attacks)
    var glow_credits = 0;
    var glow_res = {}; for(var res in gamedata['resources']) { glow_res[res] = 0; }
    if(flashy_loot && ((session.home_base && !session.has_attacked) || (!session.home_base && session.has_attacked && !(gamedata['gradual_loot']>0)))) {
        var t_credits = (player.flash_credits_time > 0 ? (client_time - player.flash_credits_time)/gamedata['client']['harvest_flash_time'] : 0);
        if(t_credits > 0 && t_credits < 1) {
            glow_credits = Math.sin(1*Math.PI*gamedata['client']['harvest_flash_count']*t_credits);
        } else if(t_credits >= 1) {
            player.flash_credits_time = -1;
        }
        for(var res in gamedata['resources']) {
            var t_res = (player.flash_res_time[res] > 0 ? (client_time - player.flash_res_time[res])/gamedata['client']['harvest_flash_time'] : 0);
            if(t_res > 0 && t_res < 1) {
                glow_res[res] = Math.sin(1*Math.PI*gamedata['client']['harvest_flash_count']*t_res);
            } else if(t_res >= 1) {
                player.flash_res_time[res] = -1; // reset effect
            }
        }
    }

    for(var res in gamedata['resources']) {
        if('resource_bar_'+res+'_glow' in dialog.widgets) {
            dialog.widgets['resource_bar_'+res+'_glow'].show = true;
            dialog.widgets['resource_bar_'+res+'_glow'].alpha = glow_res[res]*glow_res[res];
        }
    }

    if('resource_bar_fbcredits_glow' in dialog.widgets) {
        dialog.widgets['resource_bar_fbcredits_glow'].alpha = glow_credits*glow_credits;
    }

    // resource amounts - this is a little complicated to do the running-ticker effect
    var old_res = {}, cur_res = {};
    var capacity = {};

    for(var res in gamedata['resources']) {
        if(session.home_base) { // normal resource display
            capacity[res] = player.resource_state[res][0];
            old_res[res] = player.last_resource_state[res]
            cur_res[res] = player.resource_state[res][1];
        } else {
            if(use_res_looter) { // display uncapped looted amount vs. starting looot amount available
                old_res[res] = session.last_looted_uncapped[res] || 0;
                cur_res[res] = session.res_looter['looted_uncapped'][res] || 0;
                capacity[res] = session.res_looter['starting'][res] || 0;
            } else { // display capped looted amount vs. home base storage
                old_res[res] = session.last_loot[res] || 0;
                cur_res[res] = session.loot[res] || 0;
                capacity[res] = player.resource_state[res][0];
            }
        }
    }

    if(session.home_base) {
        if('resource_bar_fbcredits_amount' in dialog.widgets) {
            var old_credits = player.last_resource_state[currency];
            var cur_credits = player.resource_state[currency];

            if(cur_credits >= 0 || currency == 'gamebucks') {
                var disp_credits = (old_credits >= 0 ? Math.floor(old_credits + credits_t * (cur_credits - old_credits)) : cur_credits);
                // special hack - do not show fractional gamebucks amounts while ticking
                if(currency == 'gamebucks' && credits_t > 0 && credits_t < 1) {
                    var divisor = player.get_any_abtest_value('gamebucks_display_divisor', gamedata['store']['gamebucks_display_divisor']);
                    if(divisor != 1) {
                        disp_credits = divisor * Math.floor(disp_credits/divisor);
                    }
                }

                dialog.widgets['resource_bar_fbcredits_amount'].str = Store.display_user_currency_amount(disp_credits, 'compact');
                dialog.widgets['resource_bar_fbcredits_amount'].text_scale = (cur_credits <= old_credits) ? 1 : credits_text_scale;
            } else {
                dialog.widgets['resource_bar_fbcredits_amount'].str = '?'; // no data available
                dialog.widgets['resource_bar_fbcredits_amount'].text_scale = 1;
            }
        }
    }

    // resource fullness progress bars
    for(var res in gamedata['resources']) {
        var disp = Math.floor(old_res[res] + resource_t * (cur_res[res] - old_res[res]));
        if('resource_bar_'+res+'_amount' in dialog.widgets) {
            dialog.widgets['resource_bar_'+res+'_amount'].str = pretty_print_number(disp);
            dialog.widgets['resource_bar_'+res+'_amount'].text_scale = (cur_res[res] <= old_res[res]) ? 1 : resource_text_scale;
        }
        if('resource_bar_'+res+'_prog' in dialog.widgets) {
            var glow = glow_res[res];
            dialog.widgets['resource_bar_'+res+'_prog'].progress = Math.min(1, disp/Math.max(capacity[res],0.01));
            var wdata = dialog.data['widgets']['resource_bar_'+res+'_prog'];
            var amp = 0.33*glow*glow;
            var col0 = gamedata['resources'][res]['bar_full_color'], col1 = wdata['flash_color'];
            var col = [col0[0] + amp*(col1[0]-col0[0]),
                       col0[1] + amp*(col1[1]-col0[1]),
                       col0[2] + amp*(col1[2]-col0[2]),
                       col0[3] + amp*(col1[3]-col0[3])];
            dialog.widgets['resource_bar_'+res+'_prog'].full_color = SPUI.make_colorv(col);
        }
    }


    // token count update
    var shift = [0,0]; // shift other widgets over to make room
    if('resource_bar_tokens' in dialog.widgets) {
        var token_name = player.get_any_abtest_value('show_item_quantity', gamedata['store']['show_item_quantity']);
        var show_tokens = !!token_name;
        dialog.widgets['resource_bar_tokens'].show =
            dialog.widgets['resource_bar_tokens_icon'].show =
            dialog.widgets['resource_bar_tokens_expire_icon'].show =
            dialog.widgets['resource_bar_tokens_amount'].show = show_tokens;

        if(show_tokens) {
            var spec = ItemDisplay.get_inventory_item_spec(token_name);
            var qty_expr = player.inventory_item_quantity_and_expiration(token_name);
            var qty = qty_expr[0], expr = qty_expr[1];
            dialog.widgets['resource_bar_tokens_expire_icon'].show = (expr > 0);
            dialog.widgets['resource_bar_tokens_icon'].asset = spec['store_icon'];
            dialog.widgets['resource_bar_tokens_amount'].str = pretty_print_number(qty);
            dialog.widgets['resource_bar_tokens'].tooltip.str = dialog.data['widgets']['resource_bar_tokens']['ui_tooltip'].replace('%d0', pretty_print_number(qty)).replace('%s1', spec['ui_name_plural'] || spec['ui_name']).replace('%s2', spec['ui_name_plural'] || spec['ui_name']).replace('%expire', (expr > 0 ? dialog.data['widgets']['resource_bar_tokens']['ui_tooltip_expire'].replace('%s', pretty_print_time(expr-server_time)) : ''));

        }
        // update other widget positions
        /*
        var shift = (show_tokens ? dialog.data['widgets']['resource_bar_tokens']['shift_other_bars'] : [0,0]);
        for(var wname in dialog.widgets) {
            if(wname.indexOf('resource_bar_') == 0 && wname.indexOf('resource_bar_tokens') == -1) {
                dialog.widgets[wname].xy = vec_add(dialog.data['widgets'][wname]['xy'], shift);
                if(dialog.widgets[wname].tooltip) {
                    dialog.widgets[wname].tooltip.xy = vec_add(dialog.xy, vec_add(shift, dialog.data['widgets'][wname]['fixed_tooltip_offset']));
                }
            }
        }
        */
    }

    // tooltips
    if(1) {
        for(var res in gamedata['resources']) {
            if(('resource_bar_'+res in dialog.widgets) && dialog.widgets['resource_bar_'+res].tooltip) {
                var resdata = gamedata['resources'][res];
                dialog.widgets['resource_bar_'+res].tooltip.str = dialog.data['widgets']['resource_bar_'+res]['ui_tooltip'].replace('%d0',
                                                                                                                                    pretty_print_number(player.resource_state[res][0])).replace('%RES', resdata['ui_name']).replace('%STORAGES1', gamedata['buildings'][resdata['storage_building']]['ui_name_plural']).replace('%STORAGES2', gamedata['buildings'][resdata['storage_building']]['ui_name_plural']);
            }
        }

        if('resource_bar_fbcredits' in dialog.widgets) {
            dialog.widgets['resource_bar_fbcredits'].tooltip.str = Store.get_balance_tooltip();
            if(('fixed_tooltip_offset_'+currency) in dialog.data['widgets']['resource_bar_fbcredits']) {
                var tipoff = dialog.data['widgets']['resource_bar_fbcredits']['fixed_tooltip_offset_'+currency];
                dialog.widgets['resource_bar_fbcredits'].tooltip.xy = vec_add(shift, [dialog.xy[0]+tipoff[0], dialog.xy[1]+tipoff[1]]);
            }
        }
    }
}

function invoke_defensive_battle_bars() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['defensive_battle_bars']);
    dialog.ondraw = update_defensive_battle_bars;
    return dialog;
}
function update_defensive_battle_bars(dialog) {
    dialog.xy = dialog.data['xy']; // anchor to top-left

    // AI attack wave indicators
    var show_wave_indicators = false, show_next_wave = false, show_combat_timer = true;

    if(session.attack_finish_time > server_time && player.tutorial_state == "COMPLETE") {
        show_wave_indicators = true;
        if(session.incoming_attack_wave_time > 0) {
            show_next_wave = true;
            dialog.widgets['next_wave_time'].str = dialog.data['widgets']['next_wave_time']['ui_name'].replace('%s', pretty_print_time(session.incoming_attack_wave_time - server_time));
        } else {
            dialog.widgets['next_wave_time'].str = dialog.data['widgets']['next_wave_time']['ui_name_final'];
        }
        // show number of attackers destroyed/left
        var prog = session.incoming_attack_units_destroyed/Math.max(1, session.incoming_attack_units_total);
        dialog.widgets['wave_damage_prog'].progress = prog;
        dialog.widgets['wave_damage_amount'].str = Math.floor(100*prog).toFixed(0)+'%';
    }

    goog.array.forEach(['wave_damage_bar','wave_damage_prog','wave_damage_icon','wave_damage_amount'],
                       function (name) { dialog.widgets[name].show = show_wave_indicators; });
    goog.array.forEach([/*'next_wave_bar','next_wave_icon',*/ 'next_wave_time'],
                       function (name) { dialog.widgets[name].show = show_wave_indicators && show_next_wave; });

    // protection/attack time bar
    if(session.attack_finish_time > server_time) {
        // player is defending against an attack
        dialog.widgets['protection_time_icon'].asset = 'resource_icon_combat_time';
        var str = pretty_print_time(session.ui_attack_time_togo());
        dialog.widgets['protection_time_amount'].str = str;
        dialog.widgets['protection_time_bar'].tooltip.str = dialog.data['widgets']['protection_time_bar']['ui_tooltip_attack_ends_in'].replace('%s', str);
    } else if(session.incoming_attack_pending()) {
        // an attack is incoming on the player's home base
        if(player.tutorial_state != "COMPLETE") {
            dialog.widgets['protection_time_icon'].asset = 'resource_icon_combat_time';
            var str = pretty_print_time(session.incoming_attack_time - server_time);
            dialog.widgets['protection_time_amount'].str = str;
            dialog.widgets['protection_time_bar'].tooltip.str = dialog.data['widgets']['protection_time_bar']['ui_tooltip_incoming_attack'].replace('%s', str);
        } else {
            // "Evil Valentina"
            show_combat_timer = false;
        }
    } else {
        show_combat_timer = false;
    }

    dialog.widgets['protection_time_bar'].show =
        dialog.widgets['protection_time_icon'].show =
        dialog.widgets['protection_time_amount'].show = show_combat_timer;
}

function invoke_combat_damage_bar() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['combat_damage_bar']);
    dialog.transparent_to_mouse = true;
    dialog.user_data['base_damage_server'] = 0;
    dialog.user_data['base_damage_server_flags'] = {};
    dialog.user_data['base_damage_client_flags'] = {};
    dialog.user_data['base_damage_ping_pending'] = false;
    dialog.user_data['base_damage_ping_time'] = 0;
    dialog.ondraw = update_combat_damage_bar;
    return dialog;
}
function update_combat_damage_bar(dialog) {
    var placement = gamedata['client']['combat_damage_bar_placement'] || 'top_left';
    if(placement == 'top_left') {
        dialog.xy = dialog.data['xy_'+placement];
    } else if(placement == 'bottom_right') {
        dialog.xy = vec_add([canvas_width,canvas_height], dialog.data['xy_'+placement]);
    } else {
        throw Error('unhnadled combat_damage_bar_placement '+placement);
    }

    goog.array.forEach(['damage_bar','damage_prog','damage_icon','damage_amount'], function(wname) {
        if(gamedata['client']['combat_resource_bars_transparent'] && !('battle_stars' in gamedata) && goog.array.contains(['damage_bar', 'damage_prog'], wname)) {
            dialog.widgets[wname].show = false;
        } else {
            dialog.widgets[wname].show = (session.viewing_base.base_type != 'squad');
        }
    });
    goog.array.forEach(['damage_prog_tick0','damage_prog_tick1','damage_prog_win'], function(wname) {
        dialog.widgets[wname].show = false;
    });

    dialog.widgets['battle_stars_bg'].show = dialog.widgets['base_damage_label'].show =('battle_stars' in gamedata);

    for(var i = 0; i < dialog.data['widgets']['battle_stars_star']['array'][0]; i++) {
        dialog.widgets['battle_stars_hole'+i.toString()].show = ('battle_stars' in gamedata);
        dialog.widgets['battle_stars_star'+i.toString()].show = ('battle_stars' in gamedata &&
                                                                  'battle_stars' in session.loot &&
                                                                  i < goog.object.getCount(session.loot['battle_stars']));
    }

    // fix up the CombatText offsets according to dialog placement
    var transform_text_offset = function(off) {
        return vec_mul(placement == 'bottom_right' ? [-1,-1] : [1,1], off);
    };

    var do_sound = false;
    var base_damage;
    if(session.viewing_base.base_type == 'squad') {
        base_damage = 0;
    } else {
        base_damage = calc_base_damage();
        dialog.widgets['damage_prog'].progress = base_damage;
        dialog.widgets['damage_amount'].str = Math.floor(100*base_damage).toFixed(0)+'%'; // (100.0*base_damage).toFixed(2)+'%';
        dialog.widgets['damage_amount'].text_color = ((base_damage < gamedata['matchmaking']['ladder_win_damage'] && session.is_ladder_battle() && (gamedata['matchmaking']['ladder_win_condition']||'base_damage')=='base_damage') ? SPUI.error_text_color : SPUI.default_text_color);
        if(session.is_ladder_battle() && (gamedata['matchmaking']['ladder_win_condition']||'base_damage') == 'base_damage') {
            var ticks = [];
            ticks.push({'progress':gamedata['matchmaking']['ladder_win_damage']});
            dialog.widgets['damage_prog_win'].show = true;
            dialog.widgets['damage_prog_win'].xy = [dialog.widgets['damage_prog'].xy[0]+Math.floor(gamedata['matchmaking']['ladder_win_damage']*dialog.widgets['damage_prog'].wh[0]),
                                                    dialog.data['widgets']['damage_prog_win']['xy'][1]];
            if('ladder_bonus_damage' in gamedata['matchmaking']) {
                goog.array.forEach(gamedata['matchmaking']['ladder_bonus_damage'], function(entry, i) {
                    if(entry[0] > 0) {
                        var w = dialog.widgets['damage_prog_tick'+i.toString()];
                        w.show = true; w.str = (1+entry[1]).toFixed(1)+'x';
                        w.xy = [dialog.widgets['damage_prog'].xy[0]+Math.floor(entry[0]*dialog.widgets['damage_prog'].wh[0]),
                                dialog.data['widgets']['damage_prog_tick']['xy'][1]];
                        ticks.push({'progress':entry[0]});
                    }
                });
                dialog.widgets['damage_bar'].tooltip.str = dialog.data['widgets']['damage_bar']['ui_tooltip_bonus'].replace('%WIN', (100*gamedata['matchmaking']['ladder_win_damage']).toString()).replace('%BONUS', (100*ticks[ticks.length-1]['progress']).toString());
            }
            dialog.widgets['damage_prog'].ticks = ticks;
        }
    }

    // reconcile base damage (and ladder/protection/stars that result from it) with server
    if(session.has_deployed && !visit_base_pending &&
       (session.viewing_base.base_landlord_id != session.user_id) && (session.viewing_base.base_type == 'home')) {

        if('battle_stars' in gamedata) {
            var i = 0;
            for(var name in gamedata['battle_stars']) {
                // these are confirmed by the server via session.loot, not the damage ping response

                // if we haven't received confirmation, and we think we deserve the star, ask server for it
                if(!session.loot['battle_stars'] || !session.loot['battle_stars'][name]) {
                    if(!dialog.user_data['battle_star_'+name+'_pending'] && read_predicate(gamedata['battle_stars'][name]).is_satisfied(player, null)) {
                        dialog.user_data['battle_star_'+name+'_pending'] = 1;
                        flush_dirty_objects({buildings_only:true, skip_check:true});
                        send_to_server.func(["CLAIM_BATTLE_STAR", name]);
                    }
                } else {
                    // server says we have it now, announce it if we haven't announced it yet
                    if(!dialog.user_data['battle_star_'+name+'_announced']) {
                        dialog.user_data['battle_star_'+name+'_announced'] = client_time;
                        // no longer need the awkward text
                        /*
                        SPFX.add_ui(new SPFX.CombatText(vec_add(vec_add(dialog.xy, dialog.widgets['damage_prog'].xy), dialog.data['widgets']['damage_prog']['battle_stars_text_offset']), 0,
                                                        '\u2605 '+ gamedata['battle_stars'][name]['ui_name'],
                                                        [1,1,0], client_time, client_time + 3.0,
                                                        {drop_shadow: true, font_size: 19, text_style: "thick", is_ui: true}));
                        */
                        do_sound = true;
                    }
                    // apply animation to the battle star
                    if(i < dialog.data['widgets']['battle_stars_star']['array'][0]) {
                        if(dialog.user_data['battle_star_'+name+'_announced']) {
                            var t = client_time - dialog.user_data['battle_star_'+name+'_announced'];
                            var duration = dialog.data['widgets']['battle_stars_star']['anim_time'];
                            var s = clamp(t/duration, 0, 1);
                            s = 1-Math.pow(1-s, 2);
                            var w = dialog.widgets['battle_stars_star'+i.toString()];
                            // fade in
                            w.alpha = clamp(s, 0, 1);
                            // size down and move into place
                            var scale = s*1+(1-s)*dialog.data['widgets']['battle_stars_star']['start_scale'];
                            var origin = dialog.data['widgets']['battle_stars_star']['zoom_origin'];
                            if(scale != 1) {
                                w.transform = [scale,0,
                                               0,scale,
                                               origin[0]+scale*(-origin[0]),
                                               origin[1]+scale*(-origin[1])];
                            } else {
                                w.transform = null;
                            }
                        }
                    }
                }
                i += 1;
            }
        }

        // figure out if we want to do a base damage ping
        // note: assumes ladder_win_damage is <= lowest ladder_protection threshold
        if((FORCE_BASE_DAMAGE_PING || (session.is_ladder_battle() && base_damage >= gamedata['matchmaking']['ladder_win_damage'])) &&
           !dialog.user_data['base_damage_ping_pending'] &&
           (client_time - dialog.user_data['base_damage_ping_time']) > gamedata['client']['base_damage_ping_interval']) {

            if(FORCE_BASE_DAMAGE_PING || Math.abs(base_damage-dialog.user_data['base_damage_server']) > 0.0001) {
                // send ping request
                dialog.user_data['base_damage_ping_pending'] = true;
                flush_dirty_objects({buildings_only:true, skip_check:true});
                var damaged_objects = null;
                if(gamedata['client']['base_damage_ping_detail']) {
                    damaged_objects = do_calc_base_damage({detail:true})[1];
                }
                send_to_server.func(["PING_BASE_DAMAGE", session.viewing_base.base_id, base_damage, damaged_objects, session.viewing_base.power_state]);
            }

        }

        // show new base-damage-related state
        if(dialog.user_data['base_damage_server_flags']['is_ladder_win'] && !dialog.user_data['base_damage_client_flags']['is_ladder_win']) {
            dialog.user_data['base_damage_client_flags']['is_ladder_win'] = dialog.user_data['base_damage_server_flags']['is_ladder_win'];
            var points = dialog.user_data['base_damage_client_flags']['ladder_win_points'] = dialog.user_data['base_damage_server_flags']['ladder_win_points'];
            SPFX.add_ui(new SPFX.CombatText(vec_add(vec_add(dialog.xy, dialog.widgets['damage_prog'].xy), transform_text_offset(dialog.data['widgets']['damage_prog']['victory_text_offset'])), 0,
                                            gamedata['strings']['combat_messages']['ladder_victory'+(points==1 ? '':'_plural')].replace('%d', points.toString()),
                                            [1,1,0], client_time, client_time + 3.0,
                                            {drop_shadow: true, font_size: 21, text_style: "thick", is_ui: true}));
            do_sound = true;
        } else if((dialog.user_data['base_damage_server_flags']['ladder_win_points']||0) >
                  (dialog.user_data['base_damage_client_flags']['ladder_win_points']||0)) {
            var points = dialog.user_data['base_damage_server_flags']['ladder_win_points'] - (dialog.user_data['base_damage_client_flags']['ladder_win_points']||0);
            dialog.user_data['base_damage_client_flags']['ladder_win_points'] = dialog.user_data['base_damage_server_flags']['ladder_win_points'];
            SPFX.add_ui(new SPFX.CombatText(vec_add(vec_add(dialog.xy, dialog.widgets['damage_prog'].xy), transform_text_offset(dialog.data['widgets']['damage_prog']['victory_text_offset'])), 0,
                                            gamedata['strings']['combat_messages']['ladder_victory_bonus'+(points==1 ? '':'_plural')].replace('%d', points.toString()),
                                            [1,1,0], client_time, client_time + 3.0,
                                            {drop_shadow: true, font_size: 21, text_style: "thick", is_ui: true}));
            do_sound = true;
        }

        if((dialog.user_data['base_damage_server_flags']['ladder_protection']||0) >
           (dialog.user_data['base_damage_client_flags']['ladder_protection']||0)) {
            dialog.user_data['base_damage_client_flags']['ladder_protection'] = dialog.user_data['base_damage_server_flags']['ladder_protection'];
            var hours = dialog.user_data['base_damage_server_flags']['ladder_protection']/3600;
            SPFX.add_ui(new SPFX.CombatText(vec_add(vec_add(dialog.xy, dialog.widgets['damage_prog'].xy), transform_text_offset(dialog.data['widgets']['damage_prog']['protection_text_offset'])), 0,
                                            gamedata['strings']['combat_messages']['ladder_protection_granted'].replace('%s', hours.toFixed(0)),
                                            [1,1,0], client_time, client_time + 3.0,
                                            {drop_shadow: true, font_size: 19, text_style: "thick", is_ui: true}));
            do_sound = true;
        }
    }
    dialog.user_data['base_damage'] = base_damage; // XXXXXX nasty hack - save for later use by combat_resource_bars
    if(do_sound) { GameArt.assets["success_playful_22"].states['normal'].audio.play(client_time); }
}

function invoke_combat_resource_bars() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['combat_resource_bars']);
    dialog.transparent_to_mouse = true;
    dialog.ondraw = update_combat_resource_bars;
    return dialog;
}

var FORCE_BASE_DAMAGE_PING = false; // for debugging/profiling

function update_combat_resource_bars(dialog) {
    dialog.xy = dialog.data[(gamedata['client']['combat_damage_bar_placement']||'top_left') != 'top_left' ? 'xy_no_damage' : 'xy'];
    update_resource_bars(dialog, true, !!session.res_looter, true);

    var is_nosql = session.region.data && (session.region.data['storage'] == 'nosql');

    for(var res in gamedata['resources']) {
        goog.array.forEach(['resource_bar_'+res+'_amount',
                            'resource_bar_'+res+'_icon',
                            'resource_bar_'+res+'_prog',
                            'resource_bar_'+res+'_glow',
                            'resource_bar_'+res], function(wname) {
                                if(wname in dialog.widgets) {
                                    if(gamedata['client']['combat_resource_bars_transparent'] && goog.array.contains(['resource_bar_'+res,'resource_bar_'+res+'_prog'], wname)) {
                                        dialog.widgets[wname].show = false;
                                    } else if(session.viewing_base.base_landlord_id == session.user_id ||
                                              session.viewing_base.base_type == 'squad') {
                                        // hide at friendly bases and any squad
                                        dialog.widgets[wname].show = false;
                                    }
                                }
                            });
    }

    // trophy widgets
    var trophy_mode = null, trophy_type = null;
    if(session.is_ladder_battle() && gamedata['client']['combat_resource_bars_show_trophies']) {
        trophy_mode = (session.has_attacked ? 'current' : 'possible');
        trophy_type = (player.is_ladder_player() || player.current_trophy_pvp_challenge_name() ? 'pvp' : 'pve');
        dialog.widgets['trophies_current_icon'].state =
            dialog.widgets['trophies_victory_icon'].state =
            dialog.widgets['trophies_defeat_icon'].state = trophy_type;
        // figure out the trophy amounts to display
        var max_win = 0, max_loss = 0, win_scale_by = null, loss_scale_by = null;;
        goog.array.forEach(player.player_auras, function(aura) {
            var spec = gamedata['auras'][aura['spec']];
            var cons = spec['on_battle_end_victory'] || spec['on_battle_end_defeat'] || null;
            if(cons && cons['consequent'] == 'GIVE_TROPHIES' && cons['trophy_kind'] == trophy_type) {
                var method = cons['method'] || '+';
                var stack = ('stack' in aura ? aura['stack'] : 1);
                if(method == '+') {
                    max_win += stack;
                    win_scale_by = cons['scale_by'] || null;
                } else {
                    max_loss += stack;
                    loss_scale_by = cons['scale_by'] || null;
                }
            }
        });
        //console.log('here max_win '+max_win.toString()+' max_loss '+max_loss.toString());
        if(trophy_mode == 'possible') {
            dialog.widgets['trophies_victory_amount'].str = display_trophy_count(max_win, trophy_type).toFixed(0);
            dialog.widgets['trophies_defeat_amount'].str = display_trophy_count(-1*max_loss, trophy_type).toFixed(0);
        } else if(trophy_mode == 'current') {
            var outcome;
            if(gamedata['matchmaking']['ladder_win_condition']=='battle_stars') {
                // base_damage_server_flags cannot be used reliably here because we don't ping for base damage until >threshold
                outcome = (goog.object.getCount(session.loot['battle_stars']||{}) >= 1 ? 'victory' : 'defeat');
            } else {
                // XXXXXX nasty hack - reach over into the combat damage bar
                var flags = desktop_dialogs['combat_damage_bar'].user_data['base_damage_server_flags'];
                outcome = (flags['is_ladder_win'] ? 'victory' : 'defeat');
            }
            var current = 0;
            if(outcome == 'victory') {
                // scale_by base_damage, deployed_unit_space
                current = max_win;
                if(win_scale_by == 'base_damage') {
                    // XXXXXX nasty hack
                    var base_damage = desktop_dialogs['combat_damage_bar'].user_data['base_damage'];
                    current = Math.floor(current * base_damage + 0.5);
                }
            } else {
                current = max_loss;
                if(loss_scale_by = 'deployed_unit_space') {
                    var deployment_limit = get_player_stat(player.stattab, 'deployable_unit_space');
                    current = Math.floor(current * session.deployed_unit_space / (1.0*deployment_limit) + 0.5);
                }
                current *= -1; // show loss as negative
            }
            dialog.widgets['trophies_current_amount'].str = display_trophy_count(current, trophy_type).toFixed(0);
            dialog.widgets['trophies_current_amount'].text_color = SPUI.make_colorv(dialog.data['widgets']['trophies_current_amount']['text_color_'+outcome]);
        }
    }

    dialog.widgets['trophies_current_icon'].show = dialog.widgets['trophies_current_amount'].show = (trophy_mode == 'current');
    dialog.widgets['trophies_victory_icon'].show = dialog.widgets['trophies_victory_amount'].show =
        dialog.widgets['trophies_defeat_label'].show =
        dialog.widgets['trophies_defeat_icon'].show = dialog.widgets['trophies_defeat_amount'].show = (trophy_mode == 'possible');

    // attack timer bar
    dialog.widgets['attack_time_icon'].show =
        dialog.widgets['attack_time_amount'].show = (session.has_attacked && gamedata['client']['combat_resource_bars_show_time']);
    dialog.widgets['attack_time_bar'].show = (dialog.widgets['attack_time_icon'].show && !gamedata['client']['combat_resource_bars_transparent']);

    if(dialog.widgets['attack_time_amount'].show) {
        dialog.widgets['attack_time_amount'].str = pretty_print_time(session.ui_attack_time_togo());
    }

    // unit space deployed/deployable
    dialog.widgets['unit_space_icon'].show =
        dialog.widgets['unit_space_amount'].show = (gamedata['client']['combat_resource_bars_show_space'] &&
                                                    session.has_attacked &&
                                                    (session.viewing_base.base_landlord_id != session.user_id ||
                                                     (!is_nosql && session.viewing_base.base_type == 'quarry')));
    dialog.widgets['unit_space_bar'].show =
        dialog.widgets['unit_space_prog'].show = (dialog.widgets['unit_space_amount'].show && !gamedata['client']['combat_resource_bars_transparent']);

    // decide whether to show "out of space" message
    var out_of_space = false;

    if(dialog.widgets['unit_space_prog'].show && session.has_attacked) {
        var deployable_space = get_player_stat(player.stattab,'deployable_unit_space');
        var str = pretty_print_number(session.deployed_unit_space);
        str += ' / ';
        str += pretty_print_number(deployable_space);
        dialog.widgets['unit_space_amount'].str = str;
        dialog.widgets['unit_space_prog'].progress = session.deployed_unit_space/deployable_space;
        dialog.widgets['unit_space_bar'].tooltip.str = dialog.data['widgets']['unit_space_bar']['ui_tooltip'].replace('%ATTACK_SPACE_BUILDING', gamedata['buildings'][attack_space_building()]['ui_name']);

        // is deploy cursor active?
        if(selection.ui && selection.ui.user_data && selection.ui.user_data['cursor'] == 'DeployUICursor') {
            // are any deployment buttons grayed out?
            var btm = desktop_dialogs['desktop_bottom'];
            if(btm && btm.mouse_enter_time > 0) {
                var ulist = btm.user_data['deploy_button_specs'];
                if(ulist) {
                    for(var i = 0; i < ulist.length; i++) {
                        var specname = ulist[i];
                        var d = btm.widgets['unit_deployment_bar'].widgets['unit'+i.toString()];
                        var btn = d.widgets[(gamedata['unit_deploy_style'] == 'drip' ? 'frame' : 'plus_one')];
                        var hovering = false;
                        goog.object.forEach(d.widgets, function(w) { if(w.mouse_enter_time && w.mouse_enter_time > 0) { hovering = true; } });

                        if(btn.show && btn.state == 'disabled' && // yes, button is grayed out
                           // reason for gray-out is capacity limit (not lack of units at home)
                           (session.count_pre_deploy_units_of_spec(specname) < session.count_deployable_units_of_spec(specname)) &&
                           // mouse is hovering over the grayed-out unit
                           hovering) {
                            out_of_space = true;
                            break;
                        }
                    }
                }
            }
        }
    }

    dialog.widgets['unit_space_message_bg'].show =
        dialog.widgets['unit_space_message_line'].show =
        dialog.widgets['unit_space_message_rect'].show =
        dialog.widgets['unit_space_message'].show = out_of_space;
    if(dialog.widgets['unit_space_message'].show) {
        dialog.widgets['unit_space_message'].str = dialog.data['widgets']['unit_space_message']['ui_name'].replace('%ATTACK_SPACE_BUILDING', gamedata['buildings'][attack_space_building()]['ui_name']);
    }
}

function update_aura_bar(dialog) {
    dialog.show = (player.tutorial_state == "COMPLETE") && desktop_dialogs['player_portrait_dialog'].show;

    // position relative to player
    dialog.xy = vec_add([desktop_dialogs['player_portrait_dialog'].xy[0], 0], [9,64]);

    // fill in aura icons
    var first_aura = 0;

    // DUMMY AURA FOR DAMAGE PROTECTION
    if(player.resource_state["protection_end_time"] > server_time) {
        dialog.widgets['aura_slot'+first_aura].show = false;
        dialog.widgets['aura_icon'+first_aura].show = true;
        dialog.widgets['aura_icon'+first_aura].asset = gamedata['auras']['damage_protection']['icon'];
        dialog.widgets['aura_stack'+first_aura].show = false;
        dialog.widgets['aura_frame'+first_aura].show = true;
        dialog.widgets['aura_frame'+first_aura].state = (dialog.user_data['aura_context'] && dialog.user_data['aura_context'].user_data['slot'] == first_aura ? 'active' : 'buff');
        var aura = {"spec":"damage_protection", "end_time": player.resource_state["protection_end_time"]};
        dialog.widgets['aura_frame'+first_aura].onenter = (function (_i, _aura) { return function(w) {
            var dialog = w.parent;
            if(dialog.user_data['aura_context'] &&
               dialog.user_data['aura_context'].user_data['slot'] == _i) { return; }
            invoke_aura_context(dialog, w.xy, _i, _aura, false);
        }; })(first_aura, aura);
        dialog.widgets['aura_frame'+first_aura].onclick = (function (_i, _aura) { return function(w) {
            var dialog = w.parent;
            if(dialog.user_data['aura_context'] &&
               dialog.user_data['aura_context'].user_data['slot'] == _i) {
                invoke_aura_context(dialog, w.xy, _i, _aura, true);
            }
        }; })(first_aura, aura);
        dialog.widgets['aura_frame'+first_aura].onleave_cb = (function (_i) { return function(w) {
            var dialog = w.parent;
            if(dialog.user_data['aura_context'] &&
               dialog.user_data['aura_context'].user_data['slot'] == _i &&
               (1 || !dialog.user_data['aura_context'].user_data['show_dropdown'])) {
                invoke_aura_context(dialog, w.xy, -1, null, false);
            }
        }; })(first_aura);

        dialog.widgets['aura_timer'+first_aura].show = true;
        dialog.widgets['aura_timer'+first_aura].str = pretty_print_time_brief(player.resource_state["protection_end_time"] - server_time);

        if(dialog.user_data['protection_time_glow']) {
            dialog.widgets['aura_glow'+first_aura].show = true;
            dialog.widgets['aura_glow'+first_aura].alpha = dialog.data['widgets']['aura_glow']['alpha'] * (0.5*Math.sin(dialog.data['widgets']['aura_glow']['pulse_frequency']*client_time/(2*Math.PI))+0.5);
        } else {
            dialog.widgets['aura_glow'+first_aura].show = false;
        }

        first_aura += 1;
    }

    // DUMMY AURA FOR DONATED UNITS
    if(player.unit_donation_enabled() && player.has_donated_units()) {
        dialog.widgets['aura_slot'+first_aura].show = true;
        dialog.widgets['aura_icon'+first_aura].show = true;
        dialog.widgets['aura_icon'+first_aura].asset = player.donated_units_icon();

        dialog.widgets['aura_stack'+first_aura].show = false;
        dialog.widgets['aura_frame'+first_aura].show = true;
        dialog.widgets['aura_frame'+first_aura].state = (dialog.user_data['aura_context'] && dialog.user_data['aura_context'].user_data['slot'] == first_aura ? 'active' : 'buff');

        var aura = {"spec":"donated_units",
                    "extra_ui_description": player.donated_units_description(', ') + '\n' + gamedata['auras']['donated_units']['ui_space'].replace('%cur',player.donated_units_space().toFixed(0)).replace('%max',player.donated_units_max_space().toFixed(0))
                   };

        dialog.widgets['aura_frame'+first_aura].onenter = (function (_i, _aura) { return function(w) {
            var dialog = w.parent;
            if(dialog.user_data['aura_context'] &&
               dialog.user_data['aura_context'].user_data['slot'] == _i) { return; }
            invoke_aura_context(dialog, w.xy, _i, _aura, false);
        }; })(first_aura, aura);
        dialog.widgets['aura_frame'+first_aura].onclick = (function (_i, _aura) { return function(w) {
            var dialog = w.parent;
            if(dialog.user_data['aura_context'] &&
               dialog.user_data['aura_context'].user_data['slot'] == _i) {
                invoke_aura_context(dialog, w.xy, _i, _aura, true);
            }
        }; })(first_aura, aura);
        dialog.widgets['aura_frame'+first_aura].onleave_cb = (function (_i) { return function(w) {
            var dialog = w.parent;
            if(dialog.user_data['aura_context'] &&
               dialog.user_data['aura_context'].user_data['slot'] == _i &&
               (1 || !dialog.user_data['aura_context'].user_data['show_dropdown'])) {
                invoke_aura_context(dialog, w.xy, -1, null, false);
            }
        }; })(first_aura);

        dialog.widgets['aura_timer'+first_aura].show = false;

        first_aura += 1;
    }

    var aura_index = 0;
    for(var i = first_aura; i < dialog.data['widgets']['aura_icon']['array'][0]; i++) {
        // skip expired/hidden auras
        while((aura_index < player.player_auras.length) &&
              ((player.player_auras[aura_index]['end_time'] &&
                player.player_auras[aura_index]['end_time'] > 0 &&
                player.player_auras[aura_index]['end_time'] < server_time) ||
               (('show' in gamedata['auras'][player.player_auras[aura_index]['spec']]) &&
                !gamedata['auras'][player.player_auras[aura_index]['spec']]['show']) ||
               (('show_if' in gamedata['auras'][player.player_auras[aura_index]['spec']]) &&
                !read_predicate(gamedata['auras'][player.player_auras[aura_index]['spec']]['show_if']).is_satisfied(player, null)))) {
                  aura_index += 1;
        }

        if(aura_index < player.player_auras.length) {
            var aura = player.player_auras[aura_index];
            var aura_spec = gamedata['auras'][aura['spec']];
            // show aura
            dialog.widgets['aura_glow'+i].show = false;
            dialog.widgets['aura_slot'+i].show = false;
            dialog.widgets['aura_icon'+i].show = true;
            dialog.widgets['aura_icon'+i].asset = aura_spec['icon'] || 'inventory_unknown';
            dialog.widgets['aura_stack'+i].str = ('stack' in aura ? (('stack_prefix' in aura_spec) ? aura_spec['stack_prefix'] : '') + pretty_print_number(aura['stack']) : null);
            dialog.widgets['aura_stack'+i].show = ('stack' in aura) && (aura['stack'] != 1) && (!('show_stack' in aura_spec) || aura_spec['show_stack']);
            if(dialog.widgets['aura_stack'+i].show) {
                dialog.widgets['aura_stack'+i].text_color = ('stack_font_color' in aura_spec ? SPUI.make_colorv(aura_spec['stack_font_color']) : SPUI.default_text_color);
                var font_size = dialog.data['widgets']['aura_stack']['text_size'];
                dialog.widgets['aura_stack'+i].font = ItemDisplay.get_font_for_stack(dialog.widgets['aura_stack'+i], false, ('stack' in aura ? aura['stack'] : 1));
            }
            dialog.widgets['aura_frame'+i].show = true;
            dialog.widgets['aura_frame'+i].state = (dialog.user_data['aura_context'] && dialog.user_data['aura_context'].user_data['slot'] == i ? 'active' : (aura_spec['harm'] ? 'debuff' : 'buff'));

            dialog.widgets['aura_frame'+i].onenter = (function (_i, _aura) { return function(w) {
                var dialog = w.parent;
                if(dialog.user_data['aura_context'] &&
                   dialog.user_data['aura_context'].user_data['slot'] == _i) { return; }
                invoke_aura_context(dialog, w.xy, _i, _aura, false);
            }; })(i, aura);
            dialog.widgets['aura_frame'+i].onclick = (function (_i, _aura) { return function(w) {
                var dialog = w.parent;
                if(dialog.user_data['aura_context'] &&
                   dialog.user_data['aura_context'].user_data['slot'] == _i) {
                    invoke_aura_context(dialog, w.xy, _i, _aura, true);
                }
            }; })(i, aura);
            dialog.widgets['aura_frame'+i].onleave_cb = (function (_i) { return function(w) {
                var dialog = w.parent;
                var c = dialog.user_data['aura_context'];
                var out_of_bounds = true;
                if(c) {
                    var abs_xy = c.get_absolute_xy();
                    if((mouse_state.last_raw_x >= abs_xy[0]) && (mouse_state.last_raw_x < (abs_xy[0]+c.wh[0])) &&
                       (mouse_state.last_raw_y >= abs_xy[1])) { // note: no check on Y max
                            out_of_bounds = false;
                    }
                }

                if(dialog.user_data['aura_context'] &&
                   dialog.user_data['aura_context'].user_data['slot'] == _i &&
                   (out_of_bounds || !dialog.user_data['aura_context'].user_data['show_dropdown'])) {
                    invoke_aura_context(dialog, w.xy, -1, null, false);
                }
            }; })(i);

            if(('end_time' in aura) && (aura['end_time'] > 0)) {
                dialog.widgets['aura_timer'+i].show = true;
                dialog.widgets['aura_timer'+i].str = pretty_print_time_brief(aura['end_time']-server_time);
            } else {
                dialog.widgets['aura_timer'+i].show = false;
            }

            aura_index += 1;
        } else {
            dialog.widgets['aura_glow'+i].show =
                dialog.widgets['aura_slot'+i].show =
                dialog.widgets['aura_icon'+i].show =
                dialog.widgets['aura_stack'+i].show =
                dialog.widgets['aura_frame'+i].show =
                dialog.widgets['aura_timer'+i].show = false;
        }
    }
}

// call an AI attack. If there is an on_visit message associated with
// the attack, display that and allow player to cancel out before launching
// the attack.
function start_ai_attack(uid) {
    // catch-all for leaving home when there is something in the loot buffer
    if(session.home_base && !session.has_attacked && (player.loot_buffer.length > 0)) {
        invoke_loot_dialog();
        return;
    }

    // function to actually start the AI attack
    var attack_func = (function (_uid) { return function() {
        send_to_server.func(["START_AI_ATTACK", _uid.toString()]);
        invoke_ui_locker();
    }; })(uid);

    // fire on_visit predicate, if there is one
    if(uid.toString() in gamedata['ai_bases_client']['bases']) {
        var base = gamedata['ai_bases_client']['bases'][uid.toString()];

        // hack - only works with DISPLAY_MESSAGE consequents
        if('on_visit' in base && base['on_visit']['consequent'] == 'DISPLAY_MESSAGE' &&
           (!base['on_visit']['tag'] || !(base['on_visit']['tag'] in DisplayMessageConsequent_seen)) ) {
            if(base['on_visit']['tag'] && base['on_visit']['frequency'] == 'session') {
                //DisplayMessageConsequent_seen[base['on_visit']['tag']] = 1;
            }
            var dialog = create_splash_message(base['on_visit']);
            install_child_dialog(dialog);
            dialog.modal = true;
            dialog.auto_center();
            dialog.widgets['ok_button'].onclick = attack_func;
            return;
        }
    }

    // fallback - just call the attack immediately
    attack_func();
}

function event_time_togo(event_data) {
    var ret;
    if('time_period' in event_data) {
        ret = event_data['time_period'] - ((player.get_absolute_time() - event_data['time_origin']) % event_data['time_period']);
    } else {
        ret = -player.get_event_time('current_event', event_data['name'], 'end');
    }
    if(typeof ret === 'undefined') {
        throw Error('cannot determine time_to_go for '+event_data['name']);
    }
    return ret;
}

function get_event_evil_valentina_props(event_data) {
    // did player already finish event?
    if(('goal' in event_data) && read_predicate(event_data['goal']).is_satisfied(player, null)) { return null; }
    // is player ineligible for event?
    if(('activation' in event_data) && !read_predicate(event_data['activation']).is_satisfied(player, null)) { return null; }

    var props = {};
    props['time_to_go'] = event_time_togo(event_data);
    props['portrait_asset'] = event_data['console_portrait'] || null;
    props['stat'] = event_data['stat'] || null;
    props['prizes_ui_name'] = event_data['prizes_ui_name'] || null;
    props['fight_button_ui_name'] = event_data['fight_button_ui_name'] || null;
    props['fight_button_ui_tooltip'] = event_data['fight_button_ui_tooltip'] || null;
    props['ui_description'] = event_data['ui_description'] || null;

    var gui_mode = 'legacy';
    // ui strings
    var ui_title = null, speech_str = null;
    // action that triggers the next fight
    var action = null, act_pred = null;
    var token_item = null;
    var info_action = null, prizes_action = null, portrait_action = null, portrait_tooltip = null;
    var cooldown = -1;
    var map_battle_action = null, map_battle_ui_name = null, map_battle_pred = null;

    if(event_data['info_url']) {
        var url = eval_cond_or_literal(event_data['info_url'], player, null);
        if(url) {
            info_action = (function (_url) { return function() {
                var handle = window.open(_url, '_blank');
                if(handle) { handle.focus(); }
            }; })(url);
        }
    }

    if(event_data['portrait_action']) {
        var cons = eval_cond_or_literal(event_data['portrait_action'], player, null);
        if(cons) {
            portrait_action = (function(_cons) { return function() { _cons.execute(); }; })(read_consequent(cons));
        }
    }
    portrait_tooltip = event_data['ui_portrait_tooltip'] || null;

    if('chain' in event_data) {
        // new-style "cond" based action determination

        if(event_data['gui_mode'] == 'map_and_base_event') {
            gui_mode = 'map_and_base_event';
            token_item = event_data['token_item'] || null;
            if('map_battle_button_action' in event_data) {
                map_battle_action = (function(_cons) { return function() { _cons.execute(); }; })(read_consequent(event_data['map_battle_button_action']));
                if('activation' in event_data['map_battle_button_action']) {
                    map_battle_pred = read_predicate(event_data['map_battle_button_action']['activation']);
                }
            }
            map_battle_ui_name = event_data['ui_map_battle_button'] || null;
        }

        var chain = null;
        for(var i = 0; i < event_data['chain'].length; i++) {
            if(read_predicate(event_data['chain'][i][0]).is_satisfied(player, null)) {
                chain = event_data['chain'][i];
                break;
            }
        }
        if(!chain) { return null; }
        ui_title = chain[1]['ui_title'];
        speech_str = chain[1]['ui_speech'];
        if('console_portrait' in chain[1]) { props['portrait_asset'] = chain[1]['console_portrait']; }
        action = chain[1]['fight_button_action'];
        if('activation' in chain[1]) {
            act_pred = read_predicate(chain[1]['activation']);
        }

        if(!act_pred) {
            var base;
            if(action['visit_base']) {
                base = gamedata['ai_bases_client']['bases'][action['visit_base'].toString()];
            } else if(action['call_attack']) {
                base = gamedata['ai_bases_client']['bases'][action['call_attack'].toString()];
            }
            if('activation' in base) {
                act_pred = read_predicate(base['activation']);
            }
        }

    } else if(event_data['gui_mode'] == 'map_event' || event_data['gui_mode'] == 'stat_tournament' || event_data['token_item']) {
        gui_mode = 'map_event';
        token_item = event_data['token_item'] || null;
        ui_title = event_data['ui_title'];
        speech_str = event_data['ui_subtitle'].replace('%togo', pretty_print_time_brief(props['time_to_go']));
        action = event_data['fight_button_action'];
        if('activation' in action) {
            act_pred = read_predicate(action['activation']);
        }
        if(event_data['prizes_action']) {
            prizes_action = (function(_cons) { return function() { _cons.execute(); }; })(read_consequent(event_data['prizes_action']));
        }
    } else if(event_data['gui_mode'] == 'event_preview') {
        gui_mode = 'event_preview';
        ui_title = event_data['ui_title'];
        speech_str = event_data['ui_subtitle'].replace('%togo', pretty_print_time_brief(props['time_to_go']));

    } else {
        // old-style events
        ui_title = event_data['ui_title'];
        speech_str = event_data['ui_speech'];

        if('fight_button_ai_progress_key' in event_data) {
            var key = event_data['fight_button_ai_progress_key'];
            var cur = player.history[key] || 0;
            if('fight_button_actions' in event_data) {
                action = event_data['fight_button_actions'][cur];
            } else {
                throw Error('cannot determine action');
            }
        }
    }

    var fight_action = null;
    if(action) {
    if(action['visit_base']) {
        fight_action = (function (_num) { return function() { visit_base(_num); }; })(action['visit_base']);
    } else if(action['call_attack']) {
        if(!act_pred) {
            var pred_src = { "predicate": "OBJECT_UNDAMAGED", "spec": gamedata['townhall'] };
            if(pred_src) { act_pred = read_predicate(pred_src); }
        }

        fight_action = (function (_type) { return function() { start_ai_attack(_type); }; })(action['call_attack']);
    } else if(action['visit_ladder_rival']) {
        fight_action = function() { do_visit_base(-1, {ladder_battle:1}); };
        cooldown = player.cooldown_togo('VISIT_LADDER_RIVAL');
        if('activation' in action) {
            act_pred = read_predicate(action['activation']);
        }
    } else if(action['region_map']) {
        fight_action = function() {
            invoke_region_map();
        };
        if('activation' in action) {
            act_pred = read_predicate(action['activation']);
        }
    } else if(action['consequent']) {
        fight_action = (function (_cons) { return function() { _cons.execute(); }; })(read_consequent(action));
        if('activation' in action) {
            act_pred = read_predicate(action['activation']);
        }
    } else {
        throw Error('cannot parse fight_button_action: '+action.toString());
    }
    }

    if('ui_speech_key' in event_data && 'ui_speech_key_goal' in event_data) {
        var goal = event_data['ui_speech_key_goal'];
        var cur = player.history[event_data['ui_speech_key']] || 0;
        var delta = goal-cur;
        speech_str = speech_str.replace('%goal_minus_key', delta.toString());
        speech_str = speech_str.replace('%bases', (delta == 1 ? 'base' : 'bases')); // user-visible, but obsolete
        speech_str = speech_str.replace('%attacks', (delta == 1 ? 'attack' : 'attacks')); // user-visible, but obsolete
    }

    props['ui_title'] = ui_title;
    props['speech_str'] = speech_str;
    props['act_pred'] = act_pred;
    props['fight_action'] = fight_action;
    props['cooldown'] = cooldown;
    props['info_action'] = info_action;
    props['prizes_action'] = prizes_action;
    props['portrait_action'] = portrait_action;
    props['portrait_tooltip'] = portrait_tooltip;
    props['token_item'] = token_item;
    props['map_battle_action'] = map_battle_action;
    props['map_battle_pred'] = map_battle_pred;
    props['map_battle_ui_name'] = map_battle_ui_name;
    props['gui_mode'] = gui_mode;
    return props;
}

function get_event_evil_valentina() {
    if(player.tutorial_state !== "COMPLETE" || player.is_cheater) { return null; }

    var props = null;

    // is any global event currently going on?
    if(read_predicate({'predicate':'LIBRARY', 'name': 'hide_event_info_until'}).is_satisfied(player, null)) {
        if(player.get_event_time('current_event', null, 'inprogress')) {
            props = get_event_evil_valentina_props(gamedata['events'][player.get_event('current_event', null, player.get_absolute_time())['name']]);
        }
    }
    // global events take priority over tutorial event
    if(props) { return props; }

    // tutorial event
    if(read_predicate({'predicate':'LIBRARY', 'name': 'enable_tutorial_event'}).is_satisfied(player, null)) {
        var tutorial_event_name = player.get_any_abtest_value('tutorial_event', gamedata['tutorial_event']);
        if(tutorial_event_name) {
            props = get_event_evil_valentina_props(gamedata['events'][tutorial_event_name]);
        }
    }

    return props;
}

function get_console_shift() { return ((global_chat_frame && global_chat_frame.is_visible()) ? global_chat_frame.user_data['console_shift'] : 0); };

// return the current x,y coordinates for the top-left corner of the desktop_top dialog (shifted when chat is maximized)
function get_shifted_console_position() {
    var console_shift = get_console_shift();

    // center in game window (region to right of console_shift)
    var xy = [0,0];
    var wh = gamedata['dialogs']['desktop_top']['dimensions'];
    xy[0] = Math.floor(console_shift + (canvas_width - console_shift)/2 - wh[0]/2);
    if(xy[0] < 0) {
        xy[0] = 0;
    } else if(xy[0]+wh[0] > canvas_width) {
        xy[0] = canvas_width - wh[0];
    }
    return xy;
}

// update data fields and centering of desktop dialogs
function update_desktop_dialogs() {
    var droid_factory = null, robotics_lab = null;

    var basic_manuf_category = goog.object.getKeys(gamedata['strings']['manufacture_categories'])[0]; // most basic manufacture category
    var basic_research_category = gamedata['strings']['research_categories']['army'][0]['name']; // most basic army reserach category

    if(session.home_base) {
        // scan player's buildings to find a few things

        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.is_building() && obj.is_manufacturer() && obj.spec['manufacture_category'] === basic_manuf_category) { droid_factory = obj; }
            if(obj.is_building() && obj.is_researcher() && obj.spec['research_categories'][0] === basic_research_category) { robotics_lab = obj; }
        }
    }

    // during tutorial, restrict access to non-applicable dialogs
    var enable_missions = (player.tutorial_state === "COMPLETE" ||
                           player.tutorial_state === "open_missions_dialog");
    var enable_map = (player.tutorial_state === "COMPLETE" ||
                      player.tutorial_state === "open_map_dialog" ||
                      player.tutorial_state === "spy_on_ai");
    var enable_store = (player.tutorial_state === "COMPLETE");
    var enable_buildings =  (player.tutorial_state === "COMPLETE" ||
                             player.tutorial_state === "open_buildings_dialog" ||
                             player.tutorial_state === "go_to_defense_tab" ||
                             player.tutorial_state === "choose_defensive_cannon" //||
//                           player.tutorial_state === "place_defensive_cannon"
                            );
    var enable_produce = (player.tutorial_state === "COMPLETE");
    var enable_friends = (player.tutorial_state === "COMPLETE");

    var flashy_loot = player.flashy_loot();

    // disable changing the session before or during an attack
    if(session.incoming_attack_pending() || session.has_attacked) {
        enable_map = false;
        enable_friends = false;
    }

    // process top dialog
    var dialog = desktop_dialogs['desktop_top'];

    // shift console horizontally to make room for chat and
    // center in game window (region to right of console_shift)
    dialog.xy = get_shifted_console_position();

    // player protection/attack timer and "Evil Valentina" (non-tutorial version)
    var show_evil_valentina = false;
    var show_regional_event_info = false;

    if(session.home_base) {
        dialog.widgets['battle_history_jewel'].user_data['count'] = player.new_battle_histories;
        dialog.widgets['keyboard_shortcuts_jewel'].user_data['count'] = player.check_feature_use('keyboard_shortcuts_list') ? 0 : 1;

        update_resource_bars(dialog, true, false, false);

        dialog.widgets['low_power_bg'].show =
            dialog.widgets['low_power_message'].show = (gamedata['enable_power'] && player.tutorial_state == "COMPLETE" && session.viewing_base.power_factor() < 1);
        if(dialog.widgets['low_power_message'].show) {
            dialog.widgets['low_power_message'].str = dialog.data['widgets']['low_power_message']['ui_name'].replace('%d', Math.min(99, 100.0*session.viewing_base.power_factor()).toFixed(0)).replace('%POWERPLANTS',gamedata['buildings'][gamedata['strings']['modstats']['stats']['limit:energy']['check_spec']]['ui_name_plural']);
        }

        dialog.widgets['user_abtest_message'].show = (player.tutorial_state == "COMPLETE" &&
                                                      !(player.quest_tracked && player.quest_tracked['ui_step']) &&
                                                      !session.has_attacked &&
                                                      !session.incoming_attack_pending());
        dialog.widgets['user_abtest_message'].str = player.get_any_abtest_value('ui_user_abtest_message', null);

        dialog.widgets['edit_mode_message'].show = !!player.is_cheater;

        // check for excessive scenery sprites
        var inert_count = 0;
        if(player.is_cheater) {
            goog.object.forEach(session.cur_objects.objects, function(obj) { if(obj.is_inert()) { inert_count += 1; } });
        }
        dialog.widgets['excessive_sprite_message'].show = player.is_cheater && (inert_count > gamedata['client']['inert_warn_count']);
        if(dialog.widgets['excessive_sprite_message'].show) {
            dialog.widgets['excessive_sprite_message'].str = dialog.data['widgets']['excessive_sprite_message']['ui_name'].replace('%cur', inert_count.toString()).replace('%max', gamedata['client']['inert_warn_count'].toString());
        }

    } else { // NOT home base

        dialog.widgets['edit_mode_micro_message'].show = !!player.is_cheater && ('enable_unit_micro' in gamedata) && !gamedata['enable_unit_micro'];

        dialog.widgets['protection_message'].show =
            dialog.widgets['protection_defended'].show = false;

        desktop_dialogs['combat_resource_bars'].show = session.enable_combat_resource_bars && (session.has_attacked || (session.is_ladder_battle() && gamedata['client']['combat_resource_bars_show_trophies']));
        desktop_dialogs['combat_damage_bar'].show =  desktop_dialogs['combat_resource_bars'].show && session.has_attacked;

        if(session.viewing_base.base_type == 'quarry' && session.viewing_base.base_landlord_id == session.user_id) {
            dialog.widgets['abandon_button'].show = true;

            var actual_cb = (function (_w) { return function() {
                var dialog = _w.parent;
                dialog.widgets['abandon_button'].str = dialog.data['widgets']['abandon_button']['ui_name_pending'];
                dialog.widgets['abandon_button'].state = 'disabled';
                send_to_server.func(["QUARRY_ABANDON", session.viewing_base.base_id]);
            }; })(dialog.widgets['abandon_button']);

            var state, tip, msg;

            if(session.region.data && session.region.data['storage'] == 'nosql') {
                if(session.defending_squads.length > 0) {
                    dialog.widgets['abandon_button'].state = 'disabled';
                    msg = null;
                    state = 'disabled';
                    tip = '_nosql_guarded';
                } else {
                    msg = gamedata['strings']['abandon_quarry_confirm_nosql'];
                    state = 'attack';
                    tip = '_nosql';
                }
            } else {
                msg = gamedata['strings']['abandon_quarry_confirm'];
                state = 'attack';
                tip = '';
            }

            if(dialog.widgets['abandon_button'].state == 'disabled') { state = 'disabled'; } // already pending

            dialog.widgets['abandon_button'].state = state;
            dialog.widgets['abandon_button'].tooltip.str = dialog.data['widgets']['abandon_button']['ui_tooltip'+tip];
            dialog.widgets['abandon_button'].onclick = (function (_msg, _actual_cb) { return function(w) {
                if(_msg) {
                    invoke_child_message_dialog(_msg['ui_title'], _msg['ui_description'],
                                                {'cancel_button':true,
                                                 'ok_button_ui_name': _msg['ui_button'],
                                                 'dialog': 'message_dialog_big',
                                                 'on_ok': _actual_cb});
                }
            }; })(msg, actual_cb);
        }

        // enemy protection timer

        // note: as a special case, do NOT show the protection
        // timer if the opponent seems to be currently logged
        // in. They are not attackable anyway, and this avoids
        // complaints by players who get attacked, visit their
        // attacker (who is still logged in), and see an
        // out-of-date protection timer that seems to be still active.
        //
        // UPDATE: no, never show protection time bar EVER.
        // This is just a source of endless confusion and complaints.

        if(1) {
            dialog.widgets['protection_time_bar'].show =
                dialog.widgets['protection_time_icon'].show =
                dialog.widgets['protection_time_amount'].show = false;
        }

        // instance reset timer
        if((!session.has_deployed) && enemy.instance_expiration_time > server_time &&
           player.get_abtest_value('T011_ai_bases', 'timer', 0)) {
            dialog.widgets['reset_time_bar'].show =
                dialog.widgets['reset_time_icon'].show =
                dialog.widgets['reset_time_amount'].show = true;
            var str = pretty_print_time(enemy.instance_expiration_time - server_time);
            dialog.widgets['reset_time_amount'].str = str;
            dialog.widgets['reset_time_bar'].tooltip.str = dialog.widgets['reset_time_bar'].tooltip.data['ui_name'].replace('%s', str)
        } else {
            dialog.widgets['reset_time_bar'].show =
                dialog.widgets['reset_time_icon'].show =
                dialog.widgets['reset_time_amount'].show = false;
        }

        dialog.widgets['attack_time_label'].show = dialog.widgets['attack_time_amount'].show = (session.has_attacked && gamedata['client']['desktop_top_show_attack_time']);
        if(dialog.widgets['attack_time_amount'].show) {
            var togo = session.ui_attack_time_togo();
            var s;
            if(togo <= 0) {
                s = '--:--';
            } else {
                var ui_mins = (togo < 60 ? '0' : Math.floor(togo/60.0).toFixed(0));
                var ui_sec = pad_with_zeros(Math.floor(togo%60.0).toFixed(0), 2);
                s = ui_mins + ':' + ui_sec;
            }
            dialog.widgets['attack_time_amount'].str = s;
        }

    } // end NOT session.home_base

    if(session.home_base) {
        dialog.widgets['question_button'].show = (player.tutorial_state == "COMPLETE" &&
                                                  !session.has_attacked && !session.incoming_attack_pending() &&
                                                  player.get_any_abtest_value('skip_tutorial_button', gamedata['client']['skip_tutorial_button']));
        // only disable "?" button if there are live "click here" tips going on
        dialog.widgets['question_button'].state = (player.quest_tracked && ('tips' in player.quest_tracked) && !player.quest_tracked['ui_instructions'] ? 'disabled' : 'normal');


        if(player.tutorial_state == "COMPLETE" &&
           player.get_any_abtest_value('skip_tutorial_button', gamedata['client']['skip_tutorial_button']) &&
           player.quest_tracked && ('tips' in player.quest_tracked) && (player.quest_tracked['ui_step']) && (player.quest_tracked['ui_category']) &&
           !session.has_attacked && !session.incoming_attack_pending()) {
            // new-style mission progress indicator
            dialog.widgets['skip_tutorial_bg'].show =
                dialog.widgets['skip_tutorial_prog'].show =
                dialog.widgets['skip_tutorial_label'].show =
                dialog.widgets['skip_tutorial_button'].show = true;
            dialog.widgets['quest_tracker_bg'].show =
                dialog.widgets['quest_tracker_title'].show =
                dialog.widgets['quest_tracker_descr'].show = false;

            var cur_step = player.quest_tracked['ui_step'];
            var last_step = player.quest_chain_lengths[player.quest_tracked['ui_category']];

            var s = dialog.widgets['skip_tutorial_label'].data['ui_name'].replace('%s', player.quest_tracked['ui_category']).replace('%d1', cur_step.toString()).replace('%d2', last_step.toString());
            dialog.widgets['skip_tutorial_prog'].progress = (cur_step + (player.can_complete_quest(player.quest_tracked) ? 1.0 : 0.5))/(last_step+1);
            dialog.widgets['skip_tutorial_label'].str = s;

        } else {
            // new-style quest does NOT have ui_step/ui_category
            // OR it's an old-style quest
            dialog.widgets['skip_tutorial_bg'].show =
                dialog.widgets['skip_tutorial_prog'].show =
                dialog.widgets['skip_tutorial_label'].show =
                dialog.widgets['skip_tutorial_button'].show = false;

            if(player.tutorial_state == "COMPLETE" && player.quest_tracked && !session.has_attacked &&
               (player.get_any_abtest_value('skip_tutorial_button', gamedata['client']['skip_tutorial_button']) ||
                !('tips' in player.quest_tracked))) {
                var quest = player.quest_tracked;
                dialog.widgets['quest_tracker_bg'].show =
                    dialog.widgets['quest_tracker_title'].show =
                    dialog.widgets['quest_tracker_descr'].show = true;

                dialog.widgets['skip_tutorial_button'].show = player.get_any_abtest_value('skip_tutorial_button', gamedata['client']['skip_tutorial_button']);

                var can_complete = player.can_complete_quest(player.quest_tracked);
                if(can_complete) {
                    dialog.widgets['quest_tracker_title'].str = dialog.data['widgets']['quest_tracker_title']['ui_name_complete'];
                    dialog.widgets['quest_tracker_descr'].set_text_with_linebreaking(quest['ui_name']);
                } else {
                    if(quest['ui_instructions']) {
                        dialog.widgets['quest_tracker_title'].str = dialog.data['widgets']['quest_tracker_title']['ui_name'];
                        dialog.widgets['quest_tracker_descr'].set_text_with_linebreaking(quest['ui_instructions']);
                    } else {
                        dialog.widgets['quest_tracker_title'].str = dialog.data['widgets']['quest_tracker_title']['ui_name'];
                        dialog.widgets['quest_tracker_descr'].set_text_with_linebreaking(dialog.data['widgets']['quest_tracker_descr']['ui_name']); // this only happens if skip_tutorial_button=0
                    }
                }
                // resize quest_tracker_bg to fit description text
                var n_lines = 1;
                if(dialog.widgets['quest_tracker_descr'].str) {
                    n_lines = dialog.widgets['quest_tracker_descr'].str.split('\n').length;
                }
                dialog.widgets['quest_tracker_bg'].xy = vec_copy(dialog.data['widgets']['quest_tracker_bg']['xy'+(can_complete ? '_complete' : '')]);
                dialog.widgets['quest_tracker_bg'].wh = vec_add(dialog.data['widgets']['quest_tracker_bg']['dimensions'+(can_complete ? '_complete' : '')],
                                                                [0, n_lines * dialog.widgets['quest_tracker_descr'].font.leading + dialog.widgets['quest_tracker_descr'].font.size]);
            } else {
            dialog.widgets['quest_tracker_bg'].show =
                    dialog.widgets['quest_tracker_title'].show =
                    dialog.widgets['quest_tracker_descr'].show = false;
            }
        }
    }

    // bottom dialog

    dialog = desktop_dialogs['desktop_bottom'];

    if(session.home_base) {

        if(session.has_attacked) {
            // nothing to update
        } else {

        dialog.widgets['missions_button'].state = enable_missions ? 'normal':'disabled';

        // "Reward Waiting" indicator on Missions button
        var num_waiting = player.has_unread_mail();

        // see if there is a gamebucks gift waiting
        var gifts_waiting = player.has_uncollected_gift_mail();
        if(gifts_waiting) {
            // always show "1" when an unopened gift is waiting
            num_waiting = Math.max(num_waiting, 1);
        }

        if(gifts_waiting && !selection.ui) {
            // show bigass "click-me" arrow
            if(!dialog.user_data['you_have_gift_arrow'] && tutorial_root.children.length==0) {
                dialog.user_data['you_have_gift_arrow'] = make_tutorial_arrow_for_button('desktop_bottom', 'missions_button', 'down');
            }
        } else {
            if(dialog.user_data['you_have_gift_arrow'] && dialog.user_data['you_have_gift_arrow'].parent) {
                tutorial_root.remove(dialog.user_data['you_have_gift_arrow']);
                dialog.user_data['you_have_gift_arrow'] = null;
            }
        }

        if(num_waiting > 0 && enable_missions) {
            dialog.widgets['you_have_mail'].show = dialog.widgets['you_have_mail_glow'].show = true;
            dialog.widgets['you_have_mail_glow'].alpha = gamedata['client']['notification_icon_glow_intensity']*(0.5 + 0.5 * Math.sin(2*Math.PI*(client_time*gamedata['client']['notification_icon_glow_freq'])));
            if(player.get_any_abtest_value('show_notification_counter', gamedata['client']['show_notification_counter'])) {
                dialog.widgets['you_have_mail_jewel'].show = true;
                dialog.widgets['you_have_mail_jewel'].user_data['count'] = num_waiting;
            } else {
                dialog.widgets['you_have_mail_jewel'].show = false;
            }
        } else {
            dialog.widgets['you_have_mail'].show =
                dialog.widgets['you_have_mail_jewel'].show =
                dialog.widgets['you_have_mail_glow'].show = false;
        }

        var building_jewels = get_building_jewels();
        dialog.widgets['buildings_jewel'].user_data['count'] = building_jewels['ALL'];

        if(player.get_any_abtest_value('enable_store_jewel', gamedata['store']['enable_store_jewel']) &&
           read_predicate(gamedata['store']['activate_store_jewel']).is_satisfied(player, null)) {
            var count = 0;

            // count up jewel triggers from all store categories
            for(var icat = 0; icat < gamedata['store']['catalog'].length; icat++) {
                var catdata = gamedata['store']['catalog'][icat];
                if('jewel' in catdata && read_predicate(catdata['jewel']).is_satisfied(player, null)) { // jewel on category itself - this is not usual
                    count += 1;
                }
                for(var isku = 0; isku < gamedata['store']['catalog'][icat]['skus'].length; isku++) {
                    var skudata = gamedata['store']['catalog'][icat]['skus'][isku];
                    if(new_store_allow_sku(skudata)) {
                        if('jewel' in skudata) {
                            if(read_predicate(skudata['jewel']).is_satisfied(player, null)) {
                                count += 1;
                            }
                        }
                    }
                }
            }

            dialog.widgets['store_jewel'].user_data['count'] = count;
        }

        // map button
        dialog.widgets['map_button'].state = (enable_map? 'normal' : 'disabled');
        dialog.widgets['store_button'].state = (enable_store ? 'normal':'disabled');

        // friend bar
        for(var i = 0; i < dialog.widgets['friend_bar'].data['widgets']['friend_icon']['array'][0]; i++) {
            dialog.widgets['friend_bar'].widgets['friend_icon'+i.toString()].state =
                dialog.widgets['friend_bar'].widgets['add_friend_button'+i.toString()].state = (enable_friends? 'normal' : 'disabled');
        }

        // robots button
        if(droid_factory != null || player.is_cheater) {
            dialog.widgets['robots_button'].state = enable_produce ? 'normal':'disabled';
            dialog.widgets['robots_button'].onclick = (function (fact) {
                return function() { change_selection(fact);
                                    invoke_manufacture_dialog('robots_button');
                                  };
            })(droid_factory);
        } else {
            dialog.widgets['robots_button'].state = 'disabled';
        }

        // buildings button
        dialog.widgets['buildings_button'].state = enable_buildings ? 'normal':'disabled';
        dialog.widgets['buildings_button'].onclick = function(w) { invoke_build_dialog(); };

        // research button
        if(enable_produce || robotics_lab != null) {
            dialog.widgets['research_button'].state = 'normal';
            dialog.widgets['research_button'].onclick = (function (fact) {
                return function() {
                                    if(0 && fact && fact.research_item) { // no point prompting for speedup since you might want to start research on a different category
                                        change_selection(fact);
                                        invoke_speedup_dialog('speedup');
                                    } else {
                                        invoke_research_dialog('army');
                                    } };
            })(robotics_lab);
        } else {
            dialog.widgets['research_button'].state = 'disabled';
        }

        // unit space / power displays
        {
            var space_usage = player.get_army_space_usage_by_squad();
            dialog.widgets['resource_space_amount'].str = pretty_print_number(space_usage['ALL']) + ' / ' + pretty_print_number(player.stattab['total_space']);

            dialog.widgets['resource_power_amount'].show = dialog.widgets['resource_power_icon'].show = gamedata['enable_power'];
            if(gamedata['enable_power']) {
                dialog.widgets['resource_power_amount'].str = pretty_print_number(session.viewing_base.power_state[1]) + ' / ' + pretty_print_number(session.viewing_base.power_state[0]);
                if(session.viewing_base.power_state[1] > session.viewing_base.power_state[0]) {
                    dialog.widgets['resource_power_amount'].text_color = SPUI.error_text_color;
                } else {
                    dialog.widgets['resource_power_amount'].text_color = SPUI.default_text_color;
                }
            }

            dialog.widgets['resource_foreman_amount'].show =
                dialog.widgets['resource_foreman_icon'].show =
                dialog.widgets['resource_foreman_button'].show = gamedata['enable_multiple_foremen'];

            if(gamedata['enable_multiple_foremen']) {
                var in_use = player.foremen_in_use();

                dialog.widgets['resource_foreman_amount'].str = pretty_print_number(in_use) + ' / ' + pretty_print_number(player.stattab['total_foremen']);

                if(in_use >= player.stattab['total_foremen']) {
                    dialog.widgets['resource_foreman_amount'].text_color = SPUI.error_text_color;
                } else {
                    dialog.widgets['resource_foreman_amount'].text_color = SPUI.default_text_color;
                }
                dialog.widgets['resource_foreman_button'].onclick = function() {
                    var helper = get_requirements_help('foreman', null, {short_circuit:true});
                    if(helper) { helper(); }
                };
            }
        }


        // "EVIL VALENTINA" AI character in lower-right corner

        // initialize the evil-valentina widgets that are part of desktop_bottom to hidden, then show selectively below
        dialog.widgets['event_preview_info'].show =
                dialog.widgets['map_event_info'].show =
                dialog.widgets['attacker_info_button'].show =
                dialog.widgets['map_battle_bg'].show =
                dialog.widgets['map_battle_button'].show =
                dialog.widgets['resource_bar_tokens'].show =
                dialog.widgets['resource_bar_tokens_icon'].show =
                dialog.widgets['resource_bar_tokens_amount'].show = false;

        // info about incoming AI attack the player is about to suffer
        // WAS: session.incoming_attack_pending() && (!selection.ui || !selection.ui.user_data || selection.ui.user_data['dialog'] != 'daily_attack_dialog')
        if(show_evil_valentina) {
            dialog.widgets['attacker_timer'].str = pretty_print_time(session.incoming_attack_time - server_time);
            dialog.widgets['attacker_fight_button'].onclick = start_incoming_attack;
            dialog.widgets['attacker_portrait'].onclick =
                dialog.widgets['attacker_speech_bg'].onclick = null;

        } else {
            // check for ongoing event info
            var props = get_event_evil_valentina();
            if(props !== null) {
                var fight_button = null, d = null;

                if(props['gui_mode'] == 'event_preview') {
                    // preannouncement only
                    dialog.widgets['event_preview_info'].show = true;
                    d = dialog.widgets['event_preview_info'];
                    d.widgets['title'].str = props['ui_title'];

                    d.widgets['time_amount'].str = props['speech_str'];
                    d.widgets['info_button'].onclick = props['info_action'] || null;
                    d.widgets['info_button'].show = !!props['info_action'];
                } else {
                    // live event
                    if(props['gui_mode'] == 'map_event') {
                        // new-style map event info
                        dialog.widgets['map_event_info'].show = true;
                        d = dialog.widgets['map_event_info'];
                        fight_button = d.widgets['fight_button'];
                        d.widgets['title'].str = props['ui_title'];
                        d.widgets['title'].tooltip.str = props['ui_description'];
                        d.widgets['subtitle'].str = props['speech_str'];
                        d.widgets['info_button'].onclick = props['info_action'] || null;
                        d.widgets['info_button'].show = !!props['info_action'];

                        if(props['token_item']) {
                            var ispec = ItemDisplay.get_inventory_item_spec(props['token_item']);
                            d.widgets['resource_bar_tokens'].tooltip.str = d.widgets['resource_bar_tokens'].data['ui_tooltip'].replace('%s', ispec['ui_name_plural']);
                            d.widgets['resource_bar_tokens_icon'].asset = ispec['store_icon'];
                            d.widgets['resource_bar_tokens_icon'].state = 'normal';
                            d.widgets['resource_bar_tokens_amount'].str = pretty_print_number(player.inventory_item_quantity_and_expiration(props['token_item'])[0]);
                        } else if(props['stat']) {
                            var stat_data = gamedata['strings']['leaderboard']['categories'][props['stat']['name']];
                            d.widgets['resource_bar_tokens'].tooltip.str = stat_data['title'] + ':\n' + stat_data['description'];
                            d.widgets['resource_bar_tokens_icon'].asset = props['portrait_asset'];
                            d.widgets['resource_bar_tokens_icon'].state = 'resource_icon';

                            d.widgets['resource_bar_tokens_amount'].show = false;

                            if(!('point_count' in d.user_data)) {
                                d.user_data['point_count'] = null; // mark pending
                                d.widgets['resource_bar_tokens_spinner'].show = true;
                                query_player_scores([session.user_id], [[props['stat']['name'], props['stat']['time_scope']]],
                                                    (function (_d) { return function(ids, results) {
                                                        if(!_d.is_visible()) { return; }
                                                        _d.widgets['resource_bar_tokens_spinner'].show = false;
                                                        _d.user_data['point_count'] = results[0][0] ? results[0][0]['absolute'] : 0;
                                                    }; })(d));
                            } else if(d.user_data['point_count'] !== null) {
                                d.widgets['resource_bar_tokens_amount'].show = true;
                                d.widgets['resource_bar_tokens_amount'].str = pretty_print_number(d.user_data['point_count']);
                            }
                        }

                        d.widgets['resource_bar_tokens'].onclick = props['prizes_action'];

                    } else {
                        // old-style predicate event info
                        dialog.widgets['map_event_info'].show = false;

                        // add "Map Battle" button and token counter to legacy guy-in-corner if the event is specified as a "map_and_base_event"
                        if(props['gui_mode'] == 'map_and_base_event' && !player.is_cheater) { // turn off if player is using dev edit mode
                            dialog.widgets['map_battle_bg'].show =
                                dialog.widgets['resource_bar_tokens'].show =
                                dialog.widgets['resource_bar_tokens_icon'].show =
                                dialog.widgets['resource_bar_tokens_amount'].show = true;

                            var ispec = ItemDisplay.get_inventory_item_spec(props['token_item']);
                            dialog.widgets['resource_bar_tokens'].tooltip.str = dialog.widgets['resource_bar_tokens'].data['ui_tooltip'].replace('%s', ispec['ui_name_plural']);
                            dialog.widgets['resource_bar_tokens_icon'].asset = ispec['store_icon'];
                            dialog.widgets['resource_bar_tokens_amount'].str = pretty_print_number(player.inventory_item_quantity_and_expiration(props['token_item'])[0]);
                            dialog.widgets['map_battle_button'].show = !!props['map_battle_action'];
                            dialog.widgets['map_battle_button'].str = (props['map_battle_ui_name'] || dialog.data['widgets']['map_battle_button']['ui_name']);
                            if(props['map_battle_pred'] && !props['map_battle_pred'].is_satisfied(player, null)) {
                                dialog.widgets['map_battle_button'].tooltip.str = dialog.data['widgets']['map_battle_button']['ui_tooltip_locked'].replace('%s', props['map_battle_pred'].ui_describe(player));
                                var helper = get_requirements_help(props['map_battle_pred'], null);
                                if(helper) {
                                    dialog.widgets['map_battle_button'].onclick = helper;
                                    dialog.widgets['map_battle_button'].state = 'disabled_clickable';
                                } else {
                                    dialog.widgets['map_battle_button'].state = 'disabled';
                                }
                            } else {
                                dialog.widgets['map_battle_button'].tooltip.str = null;
                                dialog.widgets['map_battle_button'].onclick = props['map_battle_action'];
                                dialog.widgets['map_battle_button'].state = 'normal';
                            }
                        }

                        show_evil_valentina = true;
                        fight_button = dialog.widgets['attacker_fight_button'];
                        dialog.widgets['attacker_timer'].str = pretty_print_time_brief(props['time_to_go']);
                        dialog.widgets['attacker_portrait'].bg_image = props['portrait_asset'];
                        dialog.widgets['attacker_speech_title'].str = props['ui_title'];
                        dialog.widgets['attacker_prepare'].str = props['speech_str'];

                        dialog.widgets['attacker_info_button'].show = !!props['info_action'];
                        dialog.widgets['attacker_prepare'].text_hjustify = (props['info_action'] ? 'left' : 'center');
                        dialog.widgets['attacker_info_button'].onclick = props['info_action'] || null;
                    }

                    // common event info
                    if(props['act_pred'] && !props['act_pred'].is_satisfied(player, null)) {
                        // player does NOT meet requirement to Fight stage
                        var helper = get_requirements_help(props['act_pred'], null);
                        fight_button.str = fight_button.data['ui_name_locked'];
                        fight_button.onclick = (helper ? helper : null);
                        fight_button.text_color = SPUI.disabled_text_color;
                        fight_button.fixed_tooltip_offset = fight_button.data['fixed_tooltip_offset'];
                        fight_button.tooltip.str = fight_button.data['ui_tooltip_locked'].replace('%s', props['act_pred'].ui_describe(player));
                        fight_button.tooltip.text_color = SPUI.error_text_color;
                    } else if(props['cooldown'] > 0) {
                        // player meets requirements, but it's on cooldown
                        fight_button.str = props['fight_button_ui_name'] || fight_button.data['ui_name'];
                        fight_button.onclick = null;
                        fight_button.text_color = SPUI.disabled_text_color;
                        fight_button.fixed_tooltip_offset = fight_button.data['fixed_tooltip_offset_cooldown'];
                        fight_button.tooltip.str = fight_button.data['ui_tooltip_cooldown'].replace('%s', pretty_print_time_brief(props['cooldown']));
                        fight_button.tooltip.text_color = SPUI.default_text_color;
                    } else {
                        // player DOES meet requirement to Fight next stage
                        fight_button.str = props['fight_button_ui_name'] || fight_button.data['ui_name'];
                        fight_button.onclick = props['fight_action'];
                        fight_button.text_color = SPUI.black_color;
                        fight_button.fixed_tooltip_offset = null; // fight_button.data['fixed_tooltip_offset'];
                        fight_button.tooltip.str = props['fight_button_ui_tooltip'] || null;
                        fight_button.tooltip.text_color = SPUI.default_text_color;
                    }
                }

                if(d && d.widgets['prizes_button']) {
                    d.widgets['prizes_button'].onclick = props['prizes_action'];
                    d.widgets['prizes_button'].str = props['prizes_ui_name'] || d.data['widgets']['prizes_button']['ui_name'];
                }

                if(d && d.widgets['enemy_portrait']) {
                    d.widgets['enemy_portrait'].bg_image = props['portrait_asset'];
                    d.widgets['enemy_portrait'].onclick = props['portrait_action']||null;
                    d.widgets['enemy_portrait'].tooltip.str = props['portrait_tooltip']||null;
                    d.widgets['enemy_portrait'].state = (props['portrait_action'] || !('disabled' in GameArt.assets[props['portrait_asset']].states) ? 'normal' : 'disabled');
                    if(d.widgets['enemy_portrait_bg_highlight']) {
                        d.widgets['enemy_portrait_bg_highlight'].show = !!props['portrait_action'];
                        var spring_up = (!!props['portrait_action']) && d.widgets['enemy_portrait'].detect_hit([mouse_state.last_raw_x,mouse_state.last_raw_y], d.widgets['enemy_portrait'].parent.get_absolute_xy());
                        goog.array.forEach(['enemy_portrait_bg', 'enemy_portrait_bg_highlight', 'enemy_portrait'], function(name) {
                            d.widgets[name].xy = vec_add(d.data['widgets'][name]['xy'], spring_up ? [0,-1] : [0,0]);
                        });
                    }
                }
            }
        }

        // regional event info display
        if(player.tutorial_state == "COMPLETE" &&
           read_predicate({'predicate':'LIBRARY', 'name': 'hide_event_info_until'}).is_satisfied(player, null) &&
           !(global_chat_frame && global_chat_frame.user_data['size'] === 'big')) {
            var quarry_event = player.get_event('current_event', 'event_quarry_contest', player.get_absolute_time());
            if(quarry_event && player.get_event_time('current_event', 'event_quarry_contest', 'inprogress')) {
                show_regional_event_info = true;
                dialog.widgets['regional_title'].str = quarry_event['ui_title'];
                dialog.widgets['regional_descr'].str = quarry_event['ui_description'];
                dialog.widgets['regional_timer'].str = pretty_print_time_brief(-player.get_event_time('current_event', 'event_quarry_contest', 'end'));
                var rank_str = null;
                if(session.region.contest_rank) {
                    rank_str = pretty_print_number(session.region.contest_rank['rank']+1);
                }
                dialog.widgets['regional_rank'].str = (rank_str ? quarry_event['ui_rank'].replace('%d', rank_str) : dialog.widgets['regional_rank'].data['ui_name']);
                dialog.widgets['regional_leaderboard_button'].onclick = function() {
                    invoke_leaderboard('week', 'all', 'quarry_resources');
                };
            }
        }

        dialog.widgets['regional_bg'].show =
        dialog.widgets['regional_sunken'].show =
        dialog.widgets['regional_bg_point'].show =
        dialog.widgets['regional_rect'].show =
        dialog.widgets['regional_title'].show =
        dialog.widgets['regional_rank'].show =
        dialog.widgets['regional_descr'].show =
        dialog.widgets['regional_timer'].show =
        dialog.widgets['regional_leaderboard_button'].show = show_regional_event_info;

        dialog.widgets['attacker_portrait'].show =
            dialog.widgets['attacker_speech_bg'].show =
            dialog.widgets['attacker_speech_title'].show =
            dialog.widgets['attacker_prepare'].show =
            dialog.widgets['attacker_timer'].show =
            dialog.widgets['attacker_fight_button'].show = show_evil_valentina;

        } // END not defending an attack

    } else { // END home_base

        // update desktop_bottom_visitor

        dialog.widgets['climate_restrictions'].show = session.viewing_base.has_climate_restrictions();
        if(dialog.widgets['climate_restrictions'].show) {
            dialog.widgets['climate_restrictions'].str = dialog.data['widgets']['climate_restrictions']['ui_name'].replace('%name', session.viewing_base.base_climate_data['ui_name']).replace('%s', session.viewing_base.describe_climate_restrictions());
        }

        dialog.widgets['deployable_squads'].show = player.squads_enabled() && session.deployable_squads.length > 0 && session.viewing_base.base_landlord_id != session.user_id &&
            session.region.data && session.region.data['storage'] == 'nosql';
        if(dialog.widgets['deployable_squads'].show) {
                var ui_list = [];
                goog.array.forEach(session.deployable_squads, function(squad_id) {
                    if(squad_id.toString() in player.squads) {
                        ui_list.push('['+player.squads[squad_id.toString()]['ui_name']+']');
                    }
                });
                dialog.widgets['deployable_squads'].str = dialog.data['widgets']['deployable_squads']['ui_name'].replace('%s', ui_list.join(', '));
            }

        var ROWS = dialog.widgets['unit_deployment_bar'].data['widgets']['unit']['array'][0];

        if(!session.has_attacked || (session.viewing_base.base_landlord_id == session.user_id &&
                                     session.region.data && session.region.data['storage'] == 'nosql')) {
            // show "Return Home" button, hide combat unit deployment
            dialog.widgets['bg_blanker'].show = true;
            dialog.widgets['bg_blanker'].xy = dialog.data['widgets']['bg_blanker']['xy' + (session.is_ladder_battle() ? '_ladder' : '')];

            dialog.widgets['ladder_switch_price_icon'].show =
                dialog.widgets['ladder_switch_price'].show =
                dialog.widgets['ladder_switch_button'].show = session.is_ladder_battle() && player.is_ladder_player();
            var cost = eval_cond_or_literal(gamedata['matchmaking']['ladder_match_switch_cost'], player, null);
            for(var res in cost) {
                // note: can't display multiple resources
                dialog.widgets['ladder_switch_price_icon'].asset = gamedata['resources'][res]['icon_small'];
                dialog.widgets['ladder_switch_price'].str = pretty_print_number(cost[res]);
            }
            var res_ok = true;
            for(var res in cost) {
                if(player.resource_state[res][1] < cost[res]) {
                    res_ok = false; break;
                }
            }
            if(visit_base_pending || !res_ok || !player.is_ladder_player()) {
                dialog.widgets['ladder_switch_price'].onclick = dialog.widgets['ladder_switch_button'].onclick = null;
                dialog.widgets['ladder_switch_button'].state = 'disabled';
            } else {
                dialog.widgets['ladder_switch_price'].onclick =
                    dialog.widgets['ladder_switch_button'].onclick = function(w) {
                        var dialog = w.parent;
                        var cost = eval_cond_or_literal(gamedata['matchmaking']['ladder_match_switch_cost'], player, null);
                        var res_ok = true;
                        for(var res in cost) {
                            if(player.resource_state[res][1] < cost[res]) {
                                res_ok = false; break;
                            }
                        }

                        if(!visit_base_pending && res_ok) {
                            do_visit_base(-1, {ladder_battle:1, ladder_switch:1});
                        }
                    };
            }

            dialog.widgets['home_button'].show = true;
            dialog.widgets['home_button'].state = (player.tutorial_state === "COMPLETE") ? 'normal':'disabled';

            for(var i = 0; i < ROWS; i++) {
                dialog.widgets['unit_deployment_bar'].widgets['unit'+i.toString()].show = false;
            }

            // reset dialog to normal dimensions
            dialog.wh = [dialog.data['dimensions'][0],
                         dialog.data['dimensions'][1]];

            dialog.widgets['deployable_squads'].xy = dialog.data['widgets']['deployable_squads']['xy'];
            dialog.widgets['climate_restrictions'].xy = dialog.data['widgets']['climate_restrictions']['xy'];

        } else {
            // hide "Return Home" button, show combat unit deployment
            dialog.widgets['bg_blanker'].show = (gamedata['unit_deploy_style'] == 'drip');
            dialog.widgets['bg_blanker'].xy = dialog.data['widgets']['bg_blanker']['xy'];
            dialog.widgets['bg_blanker'].color = SPUI.make_colorv(dialog.data['widgets']['bg_blanker']['color_combat']);

            dialog.widgets['ladder_switch_price_icon'].show =
                dialog.widgets['ladder_switch_price'].show =
                dialog.widgets['ladder_switch_button'].show =
                dialog.widgets['home_button'].show = false;
            var i = 0;

            // first see how many we need to skip, in order to show the most powerful units
            var unique_specs = {};
            session.foreach_deployable_unit(function(obj) {
                unique_specs[obj['spec']] = 1;
            });
            var uniques = goog.object.getCount(unique_specs);

            if(player.unit_donation_enabled() && player.has_donated_units()) { uniques += 1; }

            var skip = 0;
            if(uniques > ROWS) {
                skip = uniques - ROWS;
            }

            dialog.user_data['deploy_button_specs'] = [];
            var any_can_deploy = false;

            for(var specname in gamedata['units']) {
                var spec = gamedata['units'][specname];

                if(!(specname in unique_specs)) { continue; }
                if(!session.viewing_base.can_deploy_unit(spec)) { continue; }
                if(skip > 0) { skip--; continue; }
                var home_qty = session.count_deployable_units_of_spec(specname);
                var in_battle_qty = session.count_post_deploy_units_of_spec(specname);
                var deploy_qty = session.count_pre_deploy_units_of_spec(specname);

                dialog.user_data['deploy_button_specs'].push(specname);

                var d = dialog.widgets['unit_deployment_bar'].widgets['unit'+i.toString()];
                d.show = true;

                // set up callbacks
                var incr_callback = function (name, incr) { return function() {
                    // check quantity limit
                    incr = Math.min(incr, session.count_deployable_units_of_spec(name) - session.count_pre_deploy_units_of_spec(name));

                    // check deployment space limit
                    var space = gamedata['units'][name]['consumes_space'];
                    var limit = get_player_stat(player.stattab, 'deployable_unit_space');
                    incr = Math.min(incr, Math.floor((limit - session.deployed_unit_space)/space));

                    if(incr < 1) { return false; }

                    // set up deployment cursor.
                    // for tutorial, hold off until all units are readied for deployment
                    if(player.tutorial_state != "COMPLETE" && gamedata['tutorial'][player.tutorial_state]['next'] != 'place_robots_message') {
                    } else if(selection.spellname != "DEPLOY_UNITS") {
                        change_selection(player.virtual_units["DEPLOYER"]);
                        selection.spellname = "DEPLOY_UNITS";
                        var cursor = new DeployUICursor();
                        change_selection_ui_under(cursor);
                    }

                    var is_zombie = false;
                    for(var i = 0; i < incr; i++) {
                        var obj_zomb = session.get_next_deployable_unit(name);
                        var obj = obj_zomb[0]; is_zombie |= obj_zomb[1];
                        session.pre_deploy_units[obj['obj_id']] = obj;
                        if(gamedata['unit_deploy_style'] != 'drip') {
                            // batch-style unit deployment predicts deployed_unit_space as the cursor fills up, drip-style does not
                            session.deployed_unit_space += space;
                        }
                    }

                    if(!session.weak_zombie_warned &&
                       (player.tutorial_state == "COMPLETE") &&
                       is_zombie) {
                        session.weak_zombie_warned = true;
                        var dialog = invoke_ingame_tip('weak_zombie_tip', {force:true,
                                                                           dialog:'message_dialog_weak_zombie',
                                                                           dialog_options: {parentless:true}
                                                                          });
                        if(dialog) {
                            SPUI.root.add(dialog);
                            dialog.auto_center();
                            console.log(dialog); console.log(dialog.widgets);
                            var unit_ui_name = gamedata['units'][name]['ui_name'];
                            dialog.widgets['title'].set_text_with_linebreaking(gamedata['strings']['weak_zombie_tip']['ui_title'].replace('%s', unit_ui_name));
                            dialog.widgets['description'].set_text_with_linebreaking(gamedata['strings']['weak_zombie_tip']['ui_description'].replace('%s', unit_ui_name).replace('%one_minus_threshold', (100.0*(1.0-player.get_any_abtest_value('zombie_debuff_threshold', gamedata['zombie_debuff_threshold']))).toFixed(0)));
                            dialog.widgets['ok_button'].onclick = close_parent_dialog;
                            dialog.widgets['unit_icon'].show = dialog.widgets['unit_wrench_icon'].show = true;
                            dialog.widgets['unit_icon'].asset = get_leveled_quantity(gamedata['units'][name]['art_asset'], 1);
                        }
                    }

                    player.quest_tracked_dirty = true;
                    if(player.tutorial_state.indexOf('deploy_robots_action') != -1) { advance_tutorial(); }
                    return true;
                }; };


                var tip = spec['ui_name']+'\n'+spec['ui_tip'];
                if('ui_tip2' in spec) { tip += '\n'+spec['ui_tip2']; }
                var can_deploy;

                if(gamedata['unit_deploy_style'] == 'drip') {
                    can_deploy = (session.deployed_unit_space+spec['consumes_space'] <= get_player_stat(player.stattab, 'deployable_unit_space'));

                    var init_deployer = (function(_incr_callback) { return function(_specname) {
                        if(selection.ui && selection.ui.user_data && selection.ui.user_data['cursor'] == 'DeployUICursor') { return; }
                        change_selection(player.virtual_units["DEPLOYER"]);
                        selection.spellname = "DEPLOY_UNITS";
                        var cursor = new DeployUICursor();
                        change_selection_ui_under(cursor);

                        while(true) {
                            if(!_incr_callback(_specname, 1)()) { break; }
                        }

                    };})(incr_callback);

                    // initialize drip_unit
                    if(d.parent.user_data['drip_unit'] === null && can_deploy) {
                        d.parent.user_data['drip_unit'] = specname;
                        d.parent.user_data['drip_unit_push_time'] = -1;
                        init_deployer(specname);
                    }
                    d.user_data['specname'] = specname;
                    if('icon' in spec) {
                        d.widgets['item'].asset = get_leveled_quantity(spec['icon'],1);
                    } else {
                        d.widgets['item'].asset = get_leveled_quantity(spec['art_asset'],1);
                    }
                    d.widgets['item'].state = GameArt.assets[d.widgets['item'].asset].has_state('icon') ? 'icon' : 'normal';
                    d.widgets['stack'].str = home_qty.toString();
                    d.widgets['frame'].state = (d.parent.user_data['drip_unit'] == specname ? 'active': (can_deploy ? 'normal' : 'disabled'));
                    d.widgets['frame'].tooltip.str = tip;
                    d.widgets['frame'].tooltip.delay = 0.25;

                    d.widgets['frame'].onclick = (function (_init_deployer) { return function(w) {
                        var _d = w.parent;
                        _d.parent.user_data['drip_unit'] = _d.user_data['specname'];
                        change_selection_ui(null);
                        _init_deployer(_d.user_data['specname']);
                    }; })(init_deployer);

                } else {
                    can_deploy = (deploy_qty < home_qty) &&
                        (session.deployed_unit_space+spec['consumes_space'] <= get_player_stat(player.stattab, 'deployable_unit_space'));

                    d.widgets['plus_all'].str = d.data['widgets']['plus_all']['ui_name'];
                    d.widgets['plus_one'].show = true;

                    d.widgets['cancel'].show = (deploy_qty > 0);
                    d.widgets['plus_one'].state = d.widgets['plus_all'].state = (can_deploy ? 'normal' : 'disabled');

                    d.widgets['bg'].tooltip.str = tip;
                    d.widgets['unit'].bg_image = get_leveled_quantity(spec['art_asset'],1);
                    d.widgets['unit'].state = 'icon';
                    d.widgets['unit'].alpha = (spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1);
                    d.widgets['counter'].str = deploy_qty.toString()+'/'+home_qty.toString();

                    d.widgets['unit'].onclick = d.widgets['plus_one'].onclick = incr_callback(specname, 1);
                    d.widgets['plus_all'].onclick = incr_callback(specname, 10);

                    d.widgets['cancel'].onclick = (function (name) { return function() {
                        // un-pre-deploy the weakest unit
                        var weakest = session.get_weakest_pre_deploy_unit(name);

                        if(weakest) {
                            delete session.pre_deploy_units[weakest['obj_id']];
                            session.deployed_unit_space -= get_leveled_quantity(gamedata['units'][weakest['spec']]['consumes_space'], weakest['level']||1);
                        }

                        // if in combat, and no more units are left in session.pre_deploy_units, kill the cursor
                        if(session.has_deployed) {
                            var any_left = goog.object.getCount(session.pre_deploy_units) > 0;
                            if(!any_left) {
                                change_selection(null);
                            }
                        }
                    }; })(specname);

                    // disable non-applicable buttons in tutorial
                    if(player.tutorial_state != "COMPLETE") {
                        d.widgets['unit'].onclick = null;
                        d.widgets['plus_one'].state = 'disabled';
                        d.widgets['cancel'].show = false;
                        if('button' in gamedata['tutorial'][player.tutorial_state] &&
                           gamedata['tutorial'][player.tutorial_state]['button'].indexOf('DEPLOY_UNIT:') == 0 &&
                           gamedata['tutorial'][player.tutorial_state]['button'].split(':')[1] != specname) {
                            d.widgets['plus_all'].state = 'disabled';
                        }
                    }
                }

                any_can_deploy |= can_deploy;

                i += 1;
                if(i >= ROWS) {
                    //console.log('Ran out of space to display deployable units!');
                    break;
                }
            }

            // DONATED UNITS
            if(player.unit_donation_enabled() && player.has_donated_units() &&
               !session.viewing_base.has_climate_unit_restrictions()) {

                var specname = 'DONATED_UNITS';
                dialog.user_data['deploy_button_specs'].push(specname);
                var deploy_qty = session.count_pre_deploy_donated_units();
                var home_qty = player.count_donated_units();
                var consumes_space = (gamedata['donated_units_take_space'] ? player.donated_units_space() : 0);
                if(consumes_space) { throw Error('this case not handled'); }
                var can_deploy = (deploy_qty < home_qty);

                // set up callbacks
                var add_donated_units = function() {
                    // set up deployment cursor
                    if(selection.spellname != "DEPLOY_UNITS") {
                        change_selection(player.virtual_units["DEPLOYER"]);
                        selection.spellname = "DEPLOY_UNITS";
                        var cursor = new DeployUICursor();
                        change_selection_ui_under(cursor);
                    }
                    // queue the units
                    goog.object.forEach(player.donated_units, function(entry) {
                        // note that we could just do one at a time now!
                        // note: "spec" is not required for the server protocol, but we need it to simplify do_deploy() FX and DeployUICursor.destroy()
                        var new_entry = {'obj_id': entry['obj_id'], 'spec': entry['spec'], 'source': 'donated'};
                        session.pre_deploy_units[new_entry['obj_id']] = new_entry;
                        // (note: would add deployed_unit_space requirement here, in non-drip mode, if we wanted to track it)
                    });

                    player.quest_tracked_dirty = true;
                };

                var d = dialog.widgets['unit_deployment_bar'].widgets['unit'+i.toString()];
                d.show = true;

                if(gamedata['unit_deploy_style'] == 'drip') {

                    var init_deployer = (function(_add_donated_units) { return function() {
                        if(selection.ui && selection.ui.user_data && selection.ui.user_data['cursor'] == 'DeployUICursor') { return; }
                        change_selection(player.virtual_units["DEPLOYER"]);
                        selection.spellname = "DEPLOY_UNITS";
                        var cursor = new DeployUICursor();
                        change_selection_ui_under(cursor);
                        _add_donated_units();
                    };})(add_donated_units);

                    // initialize drip_unit
                    if(d.parent.user_data['drip_unit'] === null && can_deploy) {
                        d.parent.user_data['drip_unit'] = specname;
                        d.parent.user_data['drip_unit_push_time'] = -1;
                        init_deployer();
                    }
                    d.user_data['specname'] = specname;
                    d.widgets['item'].asset = player.donated_units_icon();

                    d.widgets['stack'].str = home_qty.toString();
                    d.widgets['frame'].state = (d.parent.user_data['drip_unit'] == specname ? 'active': (can_deploy ? 'normal' : 'disabled'));
                    d.widgets['frame'].tooltip.str = gamedata['auras']['donated_units']['ui_description'] + '\n' + player.donated_units_description('\n');
                    d.widgets['frame'].tooltip.delay = 0.25;

                    d.widgets['frame'].onclick = (function (_init_deployer) { return function(w) {
                        var _d = w.parent;
                        _d.parent.user_data['drip_unit'] = _d.user_data['specname'];
                        change_selection_ui(null);
                        _init_deployer();
                    }; })(init_deployer);

                } else {
                    d.widgets['bg'].tooltip.str = gamedata['auras']['donated_units']['ui_description'] + '\n' + player.donated_units_description('\n');
                    d.widgets['unit'].bg_image = player.donated_units_icon();
                    d.widgets['unit'].state = 'normal';
                    d.widgets['counter'].str = deploy_qty+'/'+home_qty;

                    d.widgets['plus_one'].state = d.widgets['plus_all'].state = (can_deploy ? 'normal' : 'disabled');
                    d.widgets['plus_all'].str = d.data['widgets']['plus_all']['ui_name_donated_units'];

                    d.widgets['unit'].onclick = d.widgets['plus_one'].onclick = d.widgets['plus_all'].onclick = add_donated_units;
                    d.widgets['plus_one'].show = false;

                    d.widgets['cancel'].show = (deploy_qty > 0);
                    d.widgets['cancel'].onclick = (function (name, _consumes_space) { return function() {
                        // remove all donations from pre_deploy_units
                        session.pre_deploy_units = goog.object.filter(session.pre_deploy_units, function(entry) { return entry['source'] !== 'donated'; });
                        // note: deployed_unit_space tracking would go here

                        // if in combat, and no more units are left in session.pre_deploy_units, kill the cursor
                        if(session.has_deployed) {
                            var any_left = goog.object.getCount(session.pre_deploy_units) > 0;
                            if(!any_left) {
                                change_selection(null);
                            }
                        }

                    }; })(specname, consumes_space);
                }

                i += 1;
            }

            if(gamedata['unit_deploy_style'] == 'drip' && !any_can_deploy &&
               selection.ui && selection.ui.user_data && selection.ui.user_data['cursor'] == 'DeployUICursor') {
                // cannot drip-deploy any more units
                change_selection_ui(null);
            }

            var ONEROW = 11;
            var show_rows = Math.max(i, ONEROW); // always show at least one full row
            var show_cols = Math.floor((i+ONEROW-1)/ONEROW);
            var vpad = dialog.widgets['unit_deployment_bar'].data['dimensions'][1] - (dialog.widgets['unit_deployment_bar'].data['widgets']['unit']['xy'][1] + dialog.widgets['unit_deployment_bar'].data['widgets']['unit']['dimensions'][1]);
            var col_height = (vpad+dialog.widgets['unit_deployment_bar'].data['widgets']['unit']['dimensions'][1]);

            for(var k = 0; k < i; k++) {
                // position widgets into columns
                var col = Math.floor(k/ONEROW);
                var wdat = dialog.widgets['unit_deployment_bar'].data['widgets']['unit'];
                var d = dialog.widgets['unit_deployment_bar'].widgets['unit'+k.toString()];
                d.xy = [wdat['xy'][0]+(k%ONEROW)*wdat['array_offset'][0],
                        wdat['xy'][1]+(show_cols-col-1)*col_height];
                var tipwidget = (gamedata['unit_deploy_style'] == 'drip' ? 'frame' : 'bg');
                if(d.widgets[tipwidget].fixed_tooltip_offset) {
                    // reposition donated units tooltip so it does not obscure the button
                    if(dialog.user_data['deploy_button_specs'][k] == 'DONATED_UNITS' &&
                       d.widgets[tipwidget].tooltip.str) {
                        d.widgets[tipwidget].fixed_tooltip_offset = vec_add(d.data['widgets'][tipwidget]['fixed_tooltip_offset'],
                                                                            [0, -Math.floor((d.widgets[tipwidget].tooltip.str.split('\n').length-1.5)*SPUI.desktop_font.leading)]);
                    }
                }
            }

            // set .wh of dialog so that dialog is the right size, and mouse clicks will always be trapped
            dialog.wh = dialog.widgets['unit_deployment_bar'].wh = [ONEROW * dialog.widgets['unit_deployment_bar'].data['widgets']['unit']['array_offset'][0],
                                                                    show_cols * col_height + dialog.widgets['unit_deployment_bar'].data['widgets']['unit']['xy'][1]];

            while(i < ROWS) {
                dialog.widgets['unit_deployment_bar'].widgets['unit'+i.toString()].show = (i < show_rows);
                goog.object.forEach(dialog.widgets['unit_deployment_bar'].widgets['unit'+i.toString()].widgets, function(w, wname) {
                    if(wname != 'bg') {
                        w.show = false;
                    }
                });
                i += 1;
            }

            if(dialog.widgets['deployable_squads'].show) {
                dialog.widgets['deployable_squads'].xy = vec_add(dialog.data['widgets']['deployable_squads']['xy'],
                                                                 vec_scale(show_cols-1, dialog.data['widgets']['deployable_squads']['xy_per_col']));
            }

            if(dialog.widgets['climate_restrictions'].show) {
                dialog.widgets['climate_restrictions'].xy = vec_add(dialog.data['widgets']['climate_restrictions']['xy'],
                                                                    vec_scale(show_cols-1, dialog.data['widgets']['climate_restrictions']['xy_per_col']));
            }

        } // END session HAS attacked
    } // END not home base

    // center at bottom of game window
    dialog.xy = [desktop_dialogs['desktop_top'].xy[0], // Math.max(0, Math.floor(canvas_width/2 - dialog.wh[0]/2)),
                 canvas_height - dialog.wh[1]];

    if(global_spell_icon) {
        var namsp = null;
        if(selection.unit && selection.unit.is_mobile()) {
            namsp = selection.unit.get_special_ability_spell();
        }
        global_spell_icon.set_spell(selection.unit, namsp ? namsp[0] : null, namsp ? namsp[1] : null);
        global_spell_icon.xy = [dialog.xy[0]+60, dialog.xy[1]-40];
    }
}

function init_combat_item_bar() {
    if(!('combat_item_bar' in desktop_dialogs)) {
        var dialog = invoke_combat_item_bar();
        if(dialog) {
            desktop_dialogs['combat_item_bar'] = dialog;
            SPUI.root.add_under(dialog);
        }
    }
}

function invoke_combat_item_bar() {
    var dialog_data = gamedata['dialogs']['combat_item_bar'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'combat_item_bar';
    dialog.user_data['context'] = null;
    dialog.transparent_to_mouse = true;
    dialog.ondraw = update_combat_item_bar;
    return dialog;
}

// Determine if an item of this spec can be used during the current
// combat session. Does not check the "requires" predicate - returns
// true if item could potentially be used as long as "requires" is
// also satisfied.
function inventory_item_is_usable_in_combat(spec, session) {
    if(!('use' in spec)) { return false; } // item does not have a "use" action

    // case 1) - recursively search "requires" predicate for HAS_ATTACKED and HOME_BASE predicates
    if('requires' in spec) {

        // recursively look for a "target" predicate. Return null if
        // not found, true if target must be TRUE to satisfy, or false
        // if target must be FALSE to satisfy.
        var has_predicate = function(pred, target) {
            if(pred['predicate'] == target) {
                return true;
            } else if(pred['predicate'] == 'NOT') {
                var ret = has_predicate(pred['subpredicates'][0], target);
                if(ret !== null) { return !ret; } // negate the child predicate
            } else if('subpredicates' in pred) {
                var ret = null;
                for(var i = 0; i < pred['subpredicates'].length; i++) {
                    ret = has_predicate(pred['subpredicates'][i], target);
                    if(ret !== null) { return ret; }
                }
            }
            return null;
        };

        var requires_has_attacked = has_predicate(spec['requires'], 'HAS_ATTACKED');
        var requires_home_base = has_predicate(spec['requires'], 'HOME_BASE');

        // item has HAS_ATTACKED predicate, and either does NOT have a HOME_BASE predicate, or session.home_base satisfies it
        // actually, let's show the item in this case, but have the red requirement tooltip to teach player that it can only be used offensively
        if(requires_has_attacked === true /* && (requires_home_base === null || requires_home_base === !!session.home_base) */) {
            return true;
        }
    }

    // case 2) - search for a "use" spellname associated with missiles or instant repair items
    var uselist = get_as_array(spec['use']);
    for(var m = 0; m < uselist.length; m++) {
        var use = uselist[m];
        if('spellname' in use) {
            var spell = gamedata['spells'][use['spellname']];
            if(goog.array.contains(['projectile_attack','instant_repair','instant_combat_repair'], spell['code'])) {
                // hide projectile_attack items if the current climate has an exclude_missiles flag
                if(spell['code'] == 'projectile_attack' && session.viewing_base.base_climate_data['exclude_missiles']) { continue; }
                return true;
            }
        }
    }

    return false;
}

function update_combat_item_bar(dialog) {
    var indices_by_spec = {};
    var item_list = [], slot_list = [], stack_count_list = [];

    var add_item = function(item, i) { // "i" is integer for ordinary inventory items, and {'obj_id':..., 'slot_type':..., 'slot_index':...} for equipped items
        if(item_list.length >=
           gamedata['dialogs']['combat_item_bar']['widgets']['item']['array'][0]*gamedata['dialogs']['combat_item_bar']['widgets']['item']['array'][1]) {
            //console.log("not enough combat_item_bar slots!");
            return;
        }

        if(inventory_item_is_usable_in_combat(ItemDisplay.get_inventory_item_spec(item['spec']), session)) {
            if(item['spec'] in indices_by_spec) {
                // group with items of identical specs
                // note: the 'pending'/'pending_time' flags will only be taken from the first item
                // this assumes that items get "used" in the order they are listed in player.inventory
                var index = indices_by_spec[item['spec']];
                stack_count_list[index] += (item['stack']||1);
            } else {
                indices_by_spec[item['spec']] = item_list.length;
                item_list.push(item);
                slot_list.push(i);
                stack_count_list.push(item['stack']||1);
            }
        }
    }
    goog.array.forEach(player.inventory, add_item);
    goog.array.forEach(session.home_equip_items, function(entry) {
        // note: because the "entry" itself is used as the "slot" below, and is checked for identity
        // against any existing inventory_context dialog, we have to use the "entry" object itself
        add_item(entry['item'], entry);
    });

    dialog.user_data['item_list'] = item_list;
    dialog.user_data['slot_list'] = slot_list;
    dialog.user_data['stack_count_list'] = stack_count_list;

    if(item_list.length < 1) { // no combat items
        dialog.show = false;
        return;
    } else {
        dialog.show = true;
    }

    dialog.xy = dialog.data['xy'];
    //canvas_height_half - Math.floor(dialog.wh[1]/2)];
    dialog.wh[1] = dialog.data['widgets']['item']['array_offset'][1] * item_list.length;
    dialog.widgets['bgrect'].wh[1] = dialog.wh[1];

    for(var y = 0; y < dialog.data['widgets']['item']['array'][1]; y++) {
        for(var x = 0; x < dialog.data['widgets']['item']['array'][0]; x++) {
            var i = y * dialog.data['widgets']['item']['array'][0] + x;

            if(i < dialog.user_data['item_list'].length) {
                dialog.widgets['item'+i].show =
                    dialog.widgets['stack'+i].show =
                    dialog.widgets['frame'+i].show =
                    dialog.widgets['clock'+i].show = true;

                dialog.widgets['frame'+i].tooltip.str = null;
                var item = dialog.user_data['item_list'][i];
                var slot = dialog.user_data['slot_list'][i];
                var stack_count = dialog.user_data['stack_count_list'][i];
                var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
                dialog.widgets['item'+i].show = true;
                ItemDisplay.set_inventory_item_asset(dialog.widgets['item'+i], spec);
                ItemDisplay._set_inventory_item_stack(dialog.widgets['stack'+i], spec, stack_count); // note: use combined stack count here
                var can_activate = false;

                if(item['pending_time']) {
                    // flash frame on activation
                    dialog.widgets['clock'+i].flash_time = item['pending_time'];
                }

                var gcd = player.cooldown_togo('GCD');
                if(gcd > 0) {
                    // show gcd clock hands
                    dialog.widgets['clock'+i].cooldown_start = player.global_cooldown['start'];
                    dialog.widgets['clock'+i].cooldown_end = player.global_cooldown['end'];
                }

                if(!item['pending']) {
                    if('requires' in spec && !read_predicate(spec['requires']).is_satisfied(player,null)) {
                        dialog.widgets['frame'+i].tooltip.str = read_predicate(spec['requires']).ui_describe(player);
                        dialog.widgets['frame'+i].tooltip.text_color = SPUI.error_text_color;
                    } else if('use' in spec) {
                        var uselist = get_as_array(spec['use']);
                        can_activate = true;
                        for(var m = 0; m < uselist.length; m++) { // ALL conditions must be true
                            var use = uselist[m];
                            if('spellname' in use) {
                                var spellname = use['spellname'];
                                var spellarg = use['spellarg'] || null;
                                var spell = gamedata['spells'][spellname];
                                var temp_arg;
                                if(spell['activation'] && spell['activation'].indexOf('targeted') == 0) {
                                    temp_arg = [spellarg,null];
                                } else {
                                    temp_arg = spellarg;
                                }
                                can_activate = can_cast_spell(GameObject.VIRTUAL_ID, spellname, temp_arg);
                            } else if('consequent' in use) {
                                can_activate = true;
                            } else {
                                can_activate = false;
                            }
                            if(!can_activate) {
                                break;
                            }
                        }
                    } else if('consequent' in spec) {
                        can_activate = true;
                    }
                }

                if(can_activate) {
                    if(player.warehouse_is_busy()) { // XXX what to check for equip items?
                        can_activate = false;
                        dialog.widgets['frame'+i].tooltip.str = dialog.data['widgets']['frame']['ui_tooltip_warehouse_offline'];
                        dialog.widgets['frame'+i].tooltip.text_color = SPUI.error_text_color;
                    }
                }

                dialog.widgets['clock'+i].disabled = !can_activate;

                if(!can_activate || gcd > 0) {
                    dialog.widgets['frame'+i].state = 'disabled';
                } else if((dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === slot) ||
                          (selection.spellname && (selection.item === item))) {
                    // highlight if context menu is up OR a targeted spell cursor for this item is active
                    dialog.widgets['frame'+i].state = 'active';
                } else {
                    dialog.widgets['frame'+i].state = 'normal';
                }

                dialog.widgets['frame'+i].onenter = (function (_slot, _item) { return function(w) {
                    var inv_dialog = w.parent;
                    if(inv_dialog.user_data['context'] &&
                       inv_dialog.user_data['context'].user_data['slot'] === _slot &&
                       inv_dialog.user_data['context'].user_data['item'] === _item) { return; }
                    if(w.tooltip.str) { return; } // don't pop up context menu if there is already an error tooltip
                    invoke_inventory_context(w.parent, w, _slot, _item, false, {'position':'right'});
                }; })(slot, item);

                dialog.widgets['frame'+i].onclick = (function (_i, _slot, _item) { return function(w) {
                    if(inventory_action(_item, _slot, "INVENTORY_USE", true)) {
                        // clear the tooltip if activation succeeds
                        invoke_inventory_context(w.parent, w, -1, null, false);
                    }
                }; })(i, slot, item);
                dialog.widgets['frame'+i].onleave_cb = (function (_slot, _item) { return function(w) {
                    var inv_dialog = w.parent;
                    if(inv_dialog.user_data['context'] &&
                       inv_dialog.user_data['context'].user_data['slot'] === _slot &&
                       inv_dialog.user_data['context'].user_data['item'] === _item &&
                       (true || !inv_dialog.user_data['context'].user_data['show_dropdown'])) {
                        invoke_inventory_context(w.parent, w, -1, null, false);
                    }
                }; })(slot, item);
            } else {
                dialog.widgets['item'+i].show =
                    dialog.widgets['stack'+i].show =
                    dialog.widgets['frame'+i].show =
                    dialog.widgets['clock'+i].show = false;
            }
        }
    }
}

/** UI element that displays an outline where building would be built or moved if you clicked now
 * @constructor
 * @extends SPUI.Element
 */
var BuildUICursor = function(obj, spec) {
    goog.base(this);
    this.user_data = {'cursor':'BuildUICursor'};
    this.obj = obj; // building to move (null for new construction)
    this.spec = spec;
};
goog.inherits(BuildUICursor, SPUI.Element);

function shade_quad(v) {
    SPUI.ctx.beginPath();
    SPUI.add_quad_to_path(v);
    SPUI.ctx.fill();
}

// 'xy' in screen coordinates, 'range' nad 'min_range' in map cell units
function draw_weapon_range(xy, range, friend, aoe, min_range) {
    if(!friend) { return; } // no range on enemy turrets

    ctx.save();

    var radius = 10*Math.sqrt(2)*range;
    var min_radius = (min_range > 0 ? 10*Math.sqrt(2)*min_range : -1);
    var color;
    if(friend) {
        color = new SPUI.Color(0.4, 0.7, 1.0);
    } else {
        color = new SPUI.Color(1.0, 0.25, 0.1);
    }

    ctx.transform(1, 0, 0, 0.5, xy[0], xy[1]);

    if(aoe) {
        // draw "clock ticks"
        color.a = 1;
        ctx.fillStyle = color.str();
        ctx.lineWidth = 4;
        ctx.beginPath();
        var NOTCHES = 48;
        var DELTA = 0.015;
        for(var i = 0; i < NOTCHES; i++) {
            var notch_rad = radius - 18;
            var angle = 2*Math.PI*(i/NOTCHES);
            var nx_l = Math.cos(angle-DELTA), ny_l = Math.sin(angle-DELTA);
            var nx_c = Math.cos(angle), ny_c = Math.sin(angle);
            var nx_r = Math.cos(angle+DELTA), ny_r = Math.sin(angle+DELTA);
            ctx.moveTo(radius*nx_l, radius*ny_l);
            ctx.lineTo(radius*nx_r, radius*ny_r);
            ctx.lineTo(notch_rad*nx_c, notch_rad*ny_c);
        }
        ctx.fill();
    }
    if(1) {
        // draw filled circle
        color.a = 0.07;
        ctx.fillStyle = color.str();
        color.a = 0.9;
        ctx.strokeStyle = color.str();
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, 2*Math.PI, false);
        if(min_radius > 0) {
            ctx.arc(0, 0, min_radius, 0, 2*Math.PI, true);
        }
        ctx.fill();
        ctx.stroke();
    }

    ctx.restore();
}

function draw_turret_ranges(ignore_obj) {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj === ignore_obj) { continue; }
        if(obj.is_building()) {
            var ran = obj.weapon_range();
            var spell = ran[0], range = (ran[3] > 0 ? ran[3] : ran[1]), aoe = ran[2], min_range = ran[4];
            if(range > 0) {
                var pos = obj.interpolate_pos();
                draw_weapon_range(ortho_to_draw(pos), range, obj.team === 'player', aoe, min_range);
            }
        }
    }
}

BuildUICursor.prototype.draw = function(offset) {
    SPUI.ctx.save();

    SPUI.ctx.save();
    set_playfield_draw_transform(SPUI.ctx);

    // draw base perimeter
    session.viewing_base.draw_base_perimeter(player.is_cheater ? 'dev_edit' : (!!this.spec['ignore_perimeter']) ? 'build_ignore_perimeter' : 'build');

    // draw blocked building locations
    SPUI.ctx.fillStyle = 'rgba(255,0,0,0.25)';
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj != selection.unit && obj.is_building() || (obj.is_inert() && obj.spec['unit_collision_gridsize'][0] != 0)) {
            var bound = get_grid_bounds([obj.x,obj.y], obj.spec['gridsize']);
            shade_quad([ortho_to_draw([bound[0][0], bound[1][0]]),
                        ortho_to_draw([bound[0][1], bound[1][0]]),
                        ortho_to_draw([bound[0][1], bound[1][1]]),
                        ortho_to_draw([bound[0][0], bound[1][1]])]);
        }
    }

    // always draw around mouse location
    var ji = screen_to_ortho([mouse_state.last_x, mouse_state.last_y]);
    ji = vec_floor(player.quantize_building_location(ji, this.spec));

    // color cursor depending on whether the location is valid
    var valid = player.is_building_location_valid_detailed(ji, this.spec, this.obj, {ignore_perimeter: !!this.spec['ignore_perimeter']});
    var location_valid = valid[0], reason = valid[1];

    var xy = ortho_to_draw(ji);

    SPUI.ctx.strokeStyle = (location_valid ? '#FFFFFF' : '#FF0000');
    SPUI.ctx.fillStyle = (location_valid ? 'rgba(255,255,255,0.25)' : 'rgba(255,0,0,0.25)');
    var bound = get_grid_bounds(ji, this.spec['gridsize']);
    SPUI.ctx.beginPath();
    SPUI.add_quad_to_path([ortho_to_draw([bound[0][0], bound[1][0]]),
                           ortho_to_draw([bound[0][1], bound[1][0]]),
                           ortho_to_draw([bound[0][1], bound[1][1]]),
                           ortho_to_draw([bound[0][0], bound[1][1]])]);
    SPUI.ctx.fill();
    SPUI.ctx.stroke();

    // draw exclusion zone
    if(this.spec['exclusion_zone']) {
        var zone = this.spec['exclusion_zone'];
        SPUI.ctx.strokeStyle = SPUI.ctx.fillStyle = 'rgba(255,255,0,0.25)';
        SPUI.ctx.beginPath();
        SPUI.add_quad_to_path([ortho_to_draw([bound[0][0]-zone[0], bound[1][0]-zone[1]]),
                               ortho_to_draw([bound[0][1]+zone[0], bound[1][0]-zone[1]]),
                               ortho_to_draw([bound[0][1]+zone[0], bound[1][1]+zone[1]]),
                               ortho_to_draw([bound[0][0]-zone[0], bound[1][1]+zone[1]])]);
        // exclude inner area (backwards winding order to create a hole)
        SPUI.add_quad_to_path([ortho_to_draw([bound[0][0], bound[1][1]]),
                               ortho_to_draw([bound[0][1], bound[1][1]]),
                               ortho_to_draw([bound[0][1], bound[1][0]]),
                               ortho_to_draw([bound[0][0], bound[1][0]])]);
        SPUI.ctx.fill();
        SPUI.ctx.stroke();
    }

    var spell_range_aoe = [null,-1,false];
    if(this.obj) {
        spell_range_aoe = this.obj.weapon_range();
    } else if(selection.spellkind && (selection.spellkind in gamedata['buildings'])) {
        spell_range_aoe = get_weapon_range(null, 1, get_auto_spell_raw(gamedata['buildings'][selection.spellkind])); // assume level 1 spell for newly-constructed buildings
    }
    var spell = spell_range_aoe[0], range = (spell_range_aoe[3] > 0 ? spell_range_aoe[3] : spell_range_aoe[1]), aoe = spell_range_aoe[2], min_range = spell_range_aoe[4];
    if(range > 0 || (this.obj && this.obj.is_building() && this.obj.is_minefield())) {
        // manually draw prospective range at new location
        if(range > 0) {
            draw_weapon_range(xy, range, true, aoe, min_range);
        }
        draw_turret_ranges(this.obj);
    }

    SPUI.ctx.restore(); // pop playfield transform

    // draw text at cursor

    var text;
    if(reason == 'perimeter') {
        text = gamedata['strings']['cursors']['outside_perimeter'];
    } else if(reason == 'overlap') {
        text = gamedata['strings']['cursors']['location_blocked'];
    } else {
        if(this.obj) {
            text = gamedata['strings']['cursors']['click_to_move'].replace('%s', this.spec['ui_name'] || this.spec['name']);
        } else {
            text = gamedata['strings']['cursors']['click_to_build'].replace('%s', this.spec['ui_name_indefinite'] || this.spec['ui_name'] || this.spec['name']);
        }
    }
    if(!text) {
        SPUI.ctx.restore();
        throw Error('bad string spellname '+(selection.spellname ? selection.spellname : 'null')+' spellkind '+(selection.spellkind ? selection.spellkind : 'null')+' spec ' + (this.spec && this.spec['name'] ? this.spec['name'] : 'BAD'));
    }

    var text_pos = [-1,-1], text_style = 'BAD';
    try {
        text_pos = [mouse_state.last_x+10, mouse_state.last_y+25];
        SPUI.ctx.fillStyle = 'rgba(0,0,0,1)';
        SPUI.ctx.fillText(text, text_pos[0]+1, text_pos[1]+1);
        SPUI.ctx.fillStyle = text_style = (location_valid ? SPUI.default_text_color : SPUI.error_text_color).str();
        SPUI.ctx.fillText(text, text_pos[0], text_pos[1]);
    } catch(e) {
        log_exception(e, 'BuildUICursor.draw(): text_pos = '+text_pos[0].toString()+','+text_pos[1].toString()+' text_style '+text_style+' text '+text);
    }

    SPUI.ctx.restore();
};

// try to find coordinates near "loc" to place a building of kind "specname"
// returns null if we can't find one
function find_valid_building_location(loc, specname) {
    var spec = get_spec(specname);
    var gridsize = spec['gridsize'];
    var options = {ignore_perimeter: !!spec['ignore_perimeter']};
    if(player.is_building_location_valid(loc, spec, null, options)) { return loc; }
    var maxshift = session.viewing_base.get_base_radius();
    for(var shiftx = 0; shiftx < 2*maxshift; shiftx += 1) {
        var sx = Math.floor(shiftx/2) * ((shiftx & 1 ? -1 : 1));
        for(var shifty = 0; shifty < 2*maxshift; shifty += 1) {
            var sy = Math.floor(shifty/2) * ((shifty & 1 ? -1 : 1));
            var newloc = [loc[0]+sx, loc[1]+sy];
            if(player.is_building_location_valid(newloc, spec, null, options)) {
                return newloc;
            }
        }
    }
    return null;
};

// fire a BUILD spell

function do_build(ji) {
    if(selection.spellkind in gamedata['buildings']) {
        var spec = gamedata['buildings'][selection.spellkind];

        var proceed = true;
        var helper = null;

        if(!player.is_cheater) { // check resources
            var res_needed = {};
            for(var res in gamedata['resources']) {
                var cost = get_leveled_quantity(spec['build_cost_'+res]||0,1);
                if(cost > player.resource_state[res][1]) {
                    res_needed[res] = cost - player.resource_state[res][1];
                    proceed = false;
                }
            }
            if(goog.object.getCount(res_needed) > 0) {
                var cb = (function (_spec) { return function() {
                    // get us back in action
                    selection.spellname = "BUILD";
                    selection.spellkind = _spec['name'];
                    change_selection_ui_under(new BuildUICursor(null, _spec));
                }; })(spec);
                helper = get_requirements_help('resources', res_needed, {continuation:cb});
            }
        }

        if(!proceed) {
            change_selection(null);
            if(helper) { helper(); }
            return;
        }

        ji = player.quantize_building_location(ji, spec);
        if(player.is_building_location_valid(ji, spec, null, {ignore_perimeter: !!spec['ignore_perimeter']})) {
            if(selection.item) {
                inventory_send_request(selection.item, selection.slot, "INVENTORY_USE", [ji], false);
            } else {
                send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID,
                                     selection.spellname,
                                     selection.spellkind,
                                     ji]);
            }

            // trigger visual effect
            var fx_data = ('upgrade_start_effect' in spec ?
                           spec['upgrade_start_effect'] :
                           gamedata['client']['vfx']['building_upgrade_start']);
            if(fx_data) {
                SPFX.add_visual_effect(ji, 0, [0,1,0], client_time, fx_data,
                                       true, // !spec['worth_less_xp'], // no sound for barrier upgrades?
                                       { '%OBJECT_SPRITE': get_leveled_quantity(spec['art_asset'], 1)});
            }

            if(player.tutorial_state === 'place_defensive_cannon' && selection.spellkind === gamedata['tutorial'][player.tutorial_state]['target']) {
                advance_tutorial();
                last_build_dialog_category = 'resources'; // flip back to 'resources' for after the tutorial
            }

            // keep build cursor if it's a barrier or minefield and the current # is less than the limit
            var current = count_objects_by_type(spec['name']);
            if((spec['worth_less_xp'] || (spec['equip_slots'] && spec['equip_slots']['mine'])) &&
               (player.is_cheater || (current+1) < get_leveled_quantity(spec['limit'], player.get_townhall_level())) &&
               (player.is_cheater || !('limit_requires' in spec) || (current+1 < spec['limit_requires'].length && read_predicate(spec['limit_requires'][current+1]).is_satisfied(player,null))) &&
               (player.is_cheater || (player.foremen_in_use() < player.stattab['total_foremen']))) {

            } else {
                change_selection(null);
                var after_build_cb = null;

                if(0 && ('limit_requires' in spec) && (current+1 < spec['limit_requires'].length && !read_predicate(spec['limit_requires'][current+1]).is_satisfied(player,null))) {
                    // instruct player what to do in order to build more
                    after_build_cb = (function (_spec, _current) { return function() {
                        var helper = get_requirements_help(read_predicate(_spec['limit_requires'][_current+1]));
                        if(helper) { helper(); }
                    }; })(spec, current);
                }

                invoke_ui_locker(synchronizer.request_sync(), after_build_cb);
            }
        } else {
            if(player.tutorial_state === 'place_defensive_cannon') {
                // allow more attempts
            } else {
                // invalid location
                change_selection(null);
            }
        }
    } else if(player.is_cheater && selection.spellkind in gamedata['inert']) {
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, selection.spellname, selection.spellkind, ji]);
    } else {
        throw Error('unhandled BUILD spellkind '+selection.spellkind.toString());
    }
};

/**
 * @constructor
 * @extends SPUI.Element
 */
var DeployUICursor = function() {
    goog.base(this);
    this.user_data = {'cursor':'DeployUICursor'};
    this.size = gamedata['client']['deploy_ui_cursor_size'] || 4; // (half) size of cursor, in map-cell units
};
goog.inherits(DeployUICursor, SPUI.Element);

DeployUICursor.prototype.destroy = function() {
    // subtract from session.deployed_unit_space
    goog.object.forEach(session.pre_deploy_units, function(obj, obj_id) {
        var space = get_leveled_quantity(gamedata['units'][obj['spec']]['consumes_space'] || 0, obj['level'] || 1);
        if(gamedata['unit_deploy_style'] != 'drip') {
            // batch-style unit deployment predicts deployed_unit_space as the cursor fills up, drip-style does not
            session.deployed_unit_space -= space;
        }
    }, this);
    session.pre_deploy_units = {};
};

DeployUICursor.prototype.draw = function(offset) {
    var has_state = true;
    SPUI.ctx.save();
    set_playfield_draw_transform(SPUI.ctx);

    session.viewing_base.draw_deployable_area();

    // do not draw deployment box if no units are ready for deployment
    var any_selected = goog.object.getCount(session.pre_deploy_units) > 0;
    if(any_selected) {
        var ji = screen_to_ortho([mouse_state.last_x, mouse_state.last_y]);
        var location_valid = session.viewing_base.is_deployment_location_valid(ji);
        SPUI.ctx.strokeStyle = (location_valid ? '#00FF00' : '#FF0000');
        SPUI.ctx.fillStyle = (location_valid ? 'rgba(0,255,0,0.25)' : 'rgba(255,0,0,0.25)');

        // rectangle
        SPUI.ctx.beginPath();
        SPUI.add_quad_to_path([vec_floor(ortho_to_draw([ji[0]-this.size, ji[1]-this.size])),
                               vec_floor(ortho_to_draw([ji[0]+this.size, ji[1]-this.size])),
                               vec_floor(ortho_to_draw([ji[0]+this.size, ji[1]+this.size])),
                               vec_floor(ortho_to_draw([ji[0]-this.size, ji[1]+this.size]))]);
        SPUI.ctx.fill();
        SPUI.ctx.stroke();

        // lines off the edges
        SPUI.ctx.beginPath();
        var line = function(v0, v1) { SPUI.ctx.moveTo(Math.floor(v0[0]), Math.floor(v0[1]));
                                      SPUI.ctx.lineTo(Math.floor(v1[0]), Math.floor(v1[1])); };

        // left
        line(ortho_to_draw([ji[0]-2*this.size, ji[1]]), ortho_to_draw([ji[0]-this.size, ji[1]]));
        // right
        line(ortho_to_draw([ji[0]+this.size, ji[1]]), ortho_to_draw([ji[0]+2*this.size, ji[1]]));
        // top
        line(ortho_to_draw([ji[0], ji[1]-2*this.size]), ortho_to_draw([ji[0], ji[1]-this.size]));
        // bottom
        line(ortho_to_draw([ji[0], ji[1]+this.size]), ortho_to_draw([ji[0], ji[1]+2*this.size]));

        SPUI.ctx.stroke();

        // pop playfield transform
        has_state = false;
        SPUI.ctx.restore();

        var text_pos = [mouse_state.last_x+10, mouse_state.last_y+25];
        if(player.is_cheater) {
            SPUI.ctx.fillStyle = 'rgba(255,255,255,1)';
            SPUI.ctx.fillText(ji[0].toString()+','+ji[1].toString(), text_pos[0], text_pos[1]);
            text_pos[1] += 20;
        }

        var text = null;
        if(location_valid && 'click_to_deploy' in gamedata['strings']['cursors']) {
            // grab any unit spec
            for(var army_id in session.pre_deploy_units) {
                var spec = gamedata['units'][session.pre_deploy_units[army_id]['spec']];
                if(spec) {
                    text = gamedata['strings']['cursors']['click_to_deploy'].replace('%s', spec['ui_name_plural'] || spec['ui_name']);
                    break;
                }
            }
        } else if(!location_valid && 'location_blocked' in gamedata['strings']['cursors']) {
            text = gamedata['strings']['cursors']['location_blocked'];
        }

        if(text) {
            SPUI.ctx.fillStyle = 'rgba(0,0,0,1)';
            SPUI.ctx.fillText(text, text_pos[0]+1, text_pos[1]+1);
            SPUI.ctx.fillStyle = (location_valid ? SPUI.default_text_color : SPUI.error_text_color).str();
            SPUI.ctx.fillText(text, text_pos[0], text_pos[1]);
        }
    }
    if(has_state) {
        SPUI.ctx.restore();
    }
};

function add_unit_deployment_vfx(kind, ji, spec, level, time_spread) {
    var vfx;

    if(kind+'_effect' in spec) { // is there a per-unit override?
        vfx = spec[kind+'_effect'];
    } else { // use default effect
        vfx = gamedata['client']['vfx'][kind] || null;
    }
    if(!vfx) { return; }

    // base some characteristics of the pre_deploy effect on the first unit that is being deployed
    var height = spec['flying'] ? spec['altitude'] : 0;
    var instance_data = { '%OBJECT_SPRITE': get_leveled_quantity(spec['art_asset'], level) };
    SPFX.add_visual_effect(ji, height, [0,0,0],
                           // spread out the effect time
                           client_time + Math.random() * time_spread,
                           vfx, true, instance_data);
}

function unit_deployment_latency_high() { return (-2*server_time_offset) > gamedata['client']['unit_deployment_effect_latency_threshold']; };

/** @param {Array.<number>} ji
    @param {Array.<Object>} objs_to_deploy (list of values in same format as values of session.pre_deploy_units) */
function do_deploy(ji, objs_to_deploy) {
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "DEPLOY_UNITS", ji, objs_to_deploy]);

    if(1) {
        // for the visual effect, just grab the first unit's spec
        var army_unit = objs_to_deploy[0];
        var fx_specname = army_unit['spec'];
        var fx_level = ('level' in army_unit ? army_unit['level'] : 1);
        // this is evaluated at high frequency, so only spread by TICK_INTERVAL
        add_unit_deployment_vfx(
            // only use pre_deploy effect in high-latency environment - otherwise skip right to post_deploy
            unit_deployment_latency_high() ? 'pre_deploy' : 'post_deploy',
            ji, gamedata['units'][fx_specname], fx_level, TICK_INTERVAL);
    }

    // transfer from pre- to post-deploy
    goog.array.forEach(objs_to_deploy, function(obj) {
        var id = obj['obj_id'];
        if(!(id in session.pre_deploy_units)) { throw Error('obj_id '+id+' not in pre_deploy_units'); }
        session.post_deploy_units[id] = session.pre_deploy_units[id];
        delete session.pre_deploy_units[id];
    });

    if(player.tutorial_state === 'place_robots_action') {
        // once robots are deployed, set short battle end time
        session.set_attack_finish_time(Math.min(session.attack_finish_time, server_time + gamedata['tutorial_post_deploy_attack_time']));
        advance_tutorial();
    }
    player.quest_tracked_dirty = true;
};

/**
 * @constructor
 * @extends SPUI.Element
 */
var CommandUICursor = function(col) {
    goog.base(this);
    this.color_str = new SPUI.Color(col[0], col[1], col[2], col[3]).str();
};
goog.inherits(CommandUICursor, SPUI.Element);
CommandUICursor.prototype.draw = function(offset) {
    var x = mouse_state.last_x, y = mouse_state.last_y;
    var inner = 7, len = 11;
    SPUI.ctx.save();
    SPUI.ctx.strokeStyle = this.color_str;
    SPUI.ctx.lineWidth = 3;
    SPUI.ctx.beginPath();
    SPUI.ctx.moveTo(x, y-inner); SPUI.ctx.lineTo(x, y-inner-len);
    SPUI.ctx.moveTo(x, y+inner); SPUI.ctx.lineTo(x, y+inner+len);
    SPUI.ctx.moveTo(x-inner, y); SPUI.ctx.lineTo(x-inner-len, y);
    SPUI.ctx.moveTo(x+inner, y); SPUI.ctx.lineTo(x+inner+len, y);
    SPUI.ctx.stroke();
    SPUI.ctx.restore();
};
function make_shoot_cursor() { return new CommandUICursor([1,0.05,0.05,0.7]); }
function make_move_cursor() { return new CommandUICursor([0.25,1,0.25,0.7]); }
function make_patrol_cursor() { return new CommandUICursor([0.25,0.5,1,0.7]); }

/**
 * @constructor
 * @extends SPUI.Element
 */
var AOEUICursor = function(origin_unit, range, radius) {
    goog.base(this);
    this.origin_unit = origin_unit;
    this.range = range;
    this.radius = radius;
    this.stroke_color_str = new SPUI.Color(0.05, 1, 0.05, 1.0).str();
    this.fill_color_str = new SPUI.Color(0.05, 1, 0.05, 0.3).str();
};
goog.inherits(AOEUICursor, SPUI.Element);
AOEUICursor.prototype.draw = function(offset) {
    ctx.save();
    ctx.lineWidth = 2;

    ctx.save();
    set_playfield_draw_transform(ctx);

    // draw range circle
    if(this.origin_unit && this.range > 0) {
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.beginPath();
        var pos = this.origin_unit.interpolate_pos();
        var xy = ortho_to_draw(pos);
        ctx.save();
        ctx.transform(1, 0, 0, 0.5, xy[0], xy[1]);
        ctx.arc(0, 0, 10*Math.sqrt(2.0)*this.range, 0, 2*Math.PI, false);
        ctx.stroke();
        ctx.restore();
    }
    ctx.restore(); // pop playfield transform

    // draw targeting cursor
    var x = mouse_state.last_x, y = mouse_state.last_y;

    ctx.strokeStyle = this.stroke_color_str;
    ctx.fillStyle = this.fill_color_str;
    ctx.beginPath();
    ctx.transform(1, 0, 0, 0.5, x, y);
    ctx.arc(0, 0, 10*view_zoom*Math.sqrt(2.0)*this.radius, 0, 2*Math.PI, false);
    ctx.fill();
    ctx.stroke();

    ctx.restore();
};

function reload_game() {
    if(false /*spin_facebook_enabled || spin_kongregate_enabled*/) {
        // running inside of the real frame
        // XXX this doesn't work due to browser restrictions :(
        if(top.location.href == spin_game_container_url) {
            top.location.reload(true);
        } else {
            top.location.href = spin_game_container_url;
        }
    } else {
        // running outside the frame
        // XXX this may have problems if spin_page_url points to the Facebook root and there is no valid signed request
        if(location.href == spin_page_url) {
            location.reload(true);
        } else {
            location.href = spin_page_url;
        }
    }
}

function invoke_cheat_menu() {
    change_selection(player.virtual_units["CHEATMENU"]);
    var win = new SPUI.Window();
    win.xy = [150,100];
    var layout = new SPUI.VLayout();

    layout.add(new SPUI.Text("Developer Tools"));

    var closure = function(spellname) { return function() {
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, spellname]);
        change_selection(null);
    }; };


    layout.add(new SPUI.Button("Toggle Edit Mode", function() {
        change_selection_ui(null);
        player.is_cheater = !player.is_cheater;
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_REMOVE_LIMITS", player.is_cheater]);
    }));

    layout.add(new SPUI.Button("Save AI base to /var/tmp", function() {
        change_selection_ui(null);
        var timestamp = server_time.toFixed(0);
        var filename = '/var/tmp/'+gamedata['game_id']+'_saved_ai_base_'+timestamp+'.json';
        save_ai_base(filename);
    }));

    layout.add(new SPUI.Button("Clear", function() { change_selection_ui(null); destroy_all_enemies(); }));

    if(player.is_cheater) {
        layout.add(new SPUI.Button("Remove All Barriers", function() { remove_all_barriers(); change_selection(null); }));
        layout.add(new SPUI.Button("Upgrade All Barriers", function() { upgrade_all_barriers(); change_selection(null); }));
        layout.add(new SPUI.Button("Give 10,000 Gamebucks", function() { change_selection_ui(null); send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_GIVE_GAMEBUCKS", 10000]); }));
        layout.add(new SPUI.Button("Drain Resources", function() { change_selection_ui(null); send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_DRAIN_RESOURCES"]); }));
        layout.add(new SPUI.Button("Clear Cooldowns/Auras", function() {
            change_selection_ui(null);
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_CLEAR_COOLDOWNS"]);
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_CLEAR_PLAYER_AURAS"]);
        }));
        layout.add(new SPUI.Button("Get Donated Units", function() { change_selection_ui(null); send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_GET_DONATED_UNITS"]); }));
    }
    //layout.add(new SPUI.Button("Clear Hostile Units", function() { destroy_all_enemies(); change_selection(null); }));
    //layout.add(new SPUI.Button("Earn Credits Offerwall", Store.earn_fbcredits_with_offers));
    //layout.add(new SPUI.Button("Assign A/B Cohort", invoke_abtest_dialog ));
    //layout.add(new SPUI.Button("Test Video Widget", function() { change_selection(null); SPVideoWidget.init(SPVideoWidget.make_youtube_url('Icf6YiXV08Q'), null); } ));



    //layout.add(new SPUI.Button("Simulate Chargeback", function() { change_selection_ui(null); send_to_server.func(["FBPAYMENT_SIMULATE_REFUND"]); }));

    layout.add(new SPUI.Button("Reset Game", function() {
        change_selection_ui(null);
        var msg = gamedata['strings']['reset_game_confirm'];
        invoke_child_message_dialog(msg['ui_title'], msg['ui_description'],
                                    {'cancel_button':true,
                                     'ok_button_ui_name': msg['ui_button'],
                                     //'dialog': 'message_dialog_big',
                                     'on_ok': function() {
                                         send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_RESET_GAME"]);
                                         inject_lag = 0;
                                         SPINPUNCHGAME.shutdown();
                                         // force refresh
                                         window.setTimeout(function() { reload_game(); }, 500);
                                     }});
    }));

    layout.add(new SPUI.Button("Log Out", function() { change_selection_ui(null); SPINPUNCHGAME.shutdown(); }));

    win.add(layout);
    selection.ui = win;
    SPUI.root.add(win);
};

function give_me_item(item) {
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_GIVE_ITEMS", item]);
}

function manipulate_ai_base(base, spellname, ui_name) {
    if(visit_base_pending) { return; }
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, spellname, base]);
    visit_base_pending = true;
    if(!loading_base_dialog_timer) {
        var dialog = invoke_loading_base_dialog('loading_base_dialog');
        dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name_'+ui_name];
    }
}

function load_ai_base(base) { manipulate_ai_base(base, "LOAD_AI_BASE", "loading"); }
function save_ai_base(base) { flush_dirty_objects({}); manipulate_ai_base(base, "SAVE_AI_BASE", "saving"); }
function publish_ai_base(base) { manipulate_ai_base(base, "PUBLISH_AI_BASE", "publishing"); }

function change_chat_tab(dialog, new_tab) {
    if(!new_tab) {
        // pick a default
        new_tab = eval_cond_or_literal(gamedata['client']['default_chat_tab'], player, null);
    }

    var index = dialog.user_data['channel_to_tab'][new_tab];
    for(var i = 0; i < Math.min(dialog.data['widgets']['tab_button']['array'][0], dialog.user_data['channel_names'].length); i++) {
        // note: .show of the button is set by chat_frame_size(). Here we set only .state and .tooltip.str
        var w = dialog.widgets['tab_button'+i.toString()];
        w.tooltip.str = null;
        var channel = dialog.user_data['channel_names'][i];
        w.state = (new_tab == channel ? 'pressed' : 'normal');
        if(channel == 'ALLIANCE') {
            if(!session.is_in_alliance()) {
                // player is NOT in an alliance - gray out the button
                w.state = 'disabled';
                w.tooltip.str = dialog.data['widgets']['tab_button']['channels']['ALLIANCE']['ui_tooltip'];
            }
        } else if(channel == 'REGION') {
            if(!session.region || !session.region.data) {
                // player is NOT on the regional map - gray out the button
                w.state = 'disabled';

                // try to get a tooltip explaining what the player needs to do to get on the regional map
                var pred = read_predicate({"predicate": "LIBRARY", "name": "quarry_requirement"});
                if(pred.is_satisfied(player, null)) {
                    // player does fulfill predicate but is not on the map - this is a rare corner case - ignore it
                    w.tooltip.str = null; // remove the tooltip
                } else {
                    // player does not fulfill predicate - create a tooltip explaining why
                    w.tooltip.str = dialog.data['widgets']['tab_button']['channels']['REGION']['ui_tooltip'].replace('%s', pred.ui_describe(player));
                }
            }
        }
    }

    dialog.user_data['cur_tab'] = index;
    for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
        var tab = dialog.widgets['tabs'+i];
        tab.show = (i == dialog.user_data['cur_tab']);
    }
}

var user_chat_bbcode_click_handlers = {
    'map_coords': { 'onclick': function(_srxy) {
        return function(w, mloc) {
            if(!_srxy) { return; }
            var params = _srxy.split(',');
            var region = params[0], x = parseInt(params[1],10), y = parseInt(params[2],10);
            invoke_find_on_map(region, [x,y]);
        }; } }
};

// Convert body string of user chat message to SPText.ABlock array.
// Applies profanity filter and map coordinate detection.
// Does NOT otherwise allow BBCode, to prevent injection attacks.
function display_user_chat_body(body, base_props, home_region) {
    // profanity filter
    var do_filter = get_preference_setting(player.preferences, 'chat_filter');
    var disp_body = (do_filter ? ChatFilter.censor(body) : body);

    // escape out any special BBCode characters to avoid injection attacks
    var disp_body_safe = SPText.bbcode_quote(disp_body);
    var disp_body_final = '';

    // perform final BBCode substitution, eating head of disp_body_safe and appending to tail of disp_body_final
    if(gamedata['strings']['chat_map_coords_regex'] && home_region) {
        var map_coords_re = new RegExp(gamedata['strings']['chat_map_coords_regex'], 'g');
        while(true) {
            var result = map_coords_re.exec(disp_body_safe);
            if(result === null) { break; }
            // transfer the part of the string before the match
            disp_body_final += disp_body_safe.slice(0, result.index);
            disp_body_safe = disp_body_safe.slice(result.index + result[0].length, disp_body_safe.length);
            var x = parseInt(result[1],10).toString();
            var y = parseInt(result[2],10).toString();
            // sanity check - do not send bad coordinates
            if(!(home_region in gamedata['regions']) ||
               x < 0 || x >= gamedata['regions'][home_region]['dimensions'][0] ||
               y < 0 || y >= gamedata['regions'][home_region]['dimensions'][1]) {
                disp_body_final += result[0];
            } else {
                // add in the templated version of the match
                disp_body_final += gamedata['strings']['chat_templates']['map_coords'].replace('%region',home_region).replace('%x',x.toString()).replace('%x',x.toString()).replace('%y',y.toString()).replace('%y',y.toString());
            }
        }
    }
    // add last bit of input
    disp_body_final += disp_body_safe;
    var blocks = SPText.cstring_to_ablocks_bbcode(disp_body_final, base_props, user_chat_bbcode_click_handlers);
    if(blocks.length > 0) {
        return blocks[0];
    } else {
        return [];
    }
}

// Inject user-provided "body" string into %body contained in the SPText.ABlock array original_text.
// This is done as a later step after the initial BBCode parse, to avoid malicious injection attacks.
// Also, store a copy of the ABlocks before %body replacement, to allow toggling censorship later.
function display_user_chat_body_nodes(user_data) {
    var text = user_data['prebody'];
    var body = user_data['unfiltered_body'];
    var disp_text = [];
    // reconstruct disp_text from text, performing %body replacement
    for(var i = 0; i < text.length; i++) {
        disp_text.push([]);
        for(var j = 0; j < text[i].length; j++) {
            var idx = text[i][j].str.indexOf('%body');
            if(idx >= 0) {
                // break into 3 parts: before body, body, after body
                var before_body_str = text[i][j].str.slice(0,idx);
                var after_body_str = text[i][j].str.slice(idx+('%body'.length), text[i][j].length);
                if(before_body_str) { disp_text[i].push(new SPText.ABlock(before_body_str, text[i][j].props)); }
                // create BBCode blocks for %body
                var body_blocks = display_user_chat_body(body, text[i][j].props, user_data['home_region']||null);
                disp_text[i] = disp_text[i].concat(body_blocks);
                if(after_body_str) { disp_text[i].push(new SPText.ABlock(after_body_str, text[i][j].props)); }
            } else {
                disp_text[i].push(new SPText.ABlock(text[i][j].str, text[i][j].props));
            }
        }
    }
    return disp_text;
}

function recensor_chat_frame(dialog) {
    for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
        var tab = dialog.widgets['tabs'+i];
        tab.widgets['output'].revise_all_text(function(original_text, user_data) {
            if(!user_data) { return original_text; } // probably a non-standard template - no need to alter it
            return display_user_chat_body_nodes(user_data);
        });
    }
}

function update_chat_frame(dialog) {
    // check for unseen chat messages, and set jewel states appropriately
    var any_unseen = false;
    for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
        var tab = dialog.widgets['tabs'+i];
        var channel_name = tab.user_data['channel_name'];
        var unseen = false;
        if(dialog.user_data['size'] == 'big' && tab.show) {
            player.chat_seen[channel_name] = Math.ceil(server_time);
        } else if(tab.user_data['last_timestamp'] > (player.chat_seen[channel_name] || 0)) {
            unseen = true;
        }
        dialog.widgets['tab_jewel'+i].user_data['text'] = (unseen ? '!' : null);
        any_unseen |= unseen;

        // update state of Reinforcements button
        tab.widgets['request_donation_button'].show = ((dialog.user_data['size'] == 'big') && (channel_name=='ALLIANCE') && player.unit_donation_enabled());

        var spell = gamedata['spells']['REQUEST_UNIT_DONATION'];
        var togo = player.cooldown_togo(spell['cooldown_name']);
        if(player.donated_units_space() >= player.donated_units_max_space()) {
            tab.widgets['request_donation_button'].state = 'disabled';
            tab.widgets['request_donation_button'].tooltip.str = tab.data['widgets']['request_donation_button']['ui_tooltip_space_limit'].replace('%s', gamedata['buildings'][gamedata['alliance_building']]['ui_name']);
        } else if(togo > 0) {
            tab.widgets['request_donation_button'].state = 'disabled';
            tab.widgets['request_donation_button'].tooltip.str = tab.data['widgets']['request_donation_button']['ui_tooltip_cooldown'].replace('%s', pretty_print_time(togo));
        } else {
            tab.widgets['request_donation_button'].state = (player.alliance_building_is_busy() ? 'disabled_clickable' : 'normal');
            tab.widgets['request_donation_button'].tooltip.str = tab.data['widgets']['request_donation_button']['ui_tooltip'];
        }
    }
    dialog.widgets['all_jewel'].user_data['text'] = (any_unseen ? '!' : null);

    // adjust size/position of NEW chat frame
    if(1) {

        var t = clamp((client_time - dialog.user_data['transition_start_time']) / dialog.data['transition_time'], 0, 1);
        dialog.xy = vec_floor(vec_lerp(dialog.data['xy'+(dialog.user_data['size']=='big'?'_minimized':'')],
                                                  dialog.data['xy'+(dialog.user_data['size']=='small'?'_minimized':'')], t));
        // crowd out the top/bottom consoles by this many pixels horizontally
        dialog.user_data['console_shift'] = lerp(dialog.data['console_shift'+(dialog.user_data['size']=='big'?'_minimized':'')],
                                                            dialog.data['console_shift'+(dialog.user_data['size']=='small'?'_minimized':'')], t);

        dialog.wh = [dialog.wh[0], canvas_height];
        dialog.widgets['bg_frame'].wh[1] = dialog.wh[1];
        dialog.widgets['grow_down'].xy = [dialog.data['widgets']['grow_down']['xy'][0],
                                                     Math.floor(dialog.wh[1]/2 - dialog.widgets['grow_down'].wh[1]/2)];
        dialog.widgets['grow_up'].xy = [dialog.data['widgets']['grow_up']['xy'][0],
                                                   dialog.widgets['grow_down'].xy[1]];
        dialog.widgets['grow_bg'].xy[1] = dialog.widgets['grow_down'].xy[1];
        dialog.widgets['all_jewel'].xy = [dialog.data['widgets']['all_jewel']['xy'][0],
                                                     dialog.widgets['grow_down'].xy[1] + (dialog.data['widgets']['all_jewel']['xy'][1] - dialog.data['widgets']['grow_down']['xy'][1])];

        for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
            var tab = dialog.widgets['tabs'+i.toString()];
            tab.wh = [tab.wh[0], dialog.wh[1]];
            tab.user_data['last_output_h'] = tab.widgets['output'].wh[1];
            tab.widgets['output_bg'].wh = [tab.data['widgets']['output_bg']['dimensions'][0], tab.wh[1] - (tab.data['dimensions'][1] - (tab.data['widgets']['output_bg']['xy'][1] + tab.data['widgets']['output_bg']['dimensions'][1]))];
            tab.widgets['output'].wh = [tab.data['widgets']['output']['dimensions'][0], tab.wh[1] - (tab.data['dimensions'][1] - (tab.data['widgets']['output']['xy'][1]+ tab.data['widgets']['output']['dimensions'][1]))];
            if(tab.widgets['output'].wh[1] != tab.user_data['last_output_h']) {
                tab.widgets['output'].update_text();
            }
        }

        // adjust Z order
        if(dialog.parent === SPUI.root && ('desktop_top' in desktop_dialogs) && ('desktop_bottom' in desktop_dialogs)) {
            SPUI.root.unparent(dialog);
            if(vec_equals(dialog.xy, dialog.data['xy_minimized'])) {
                SPUI.root.add_before(desktop_dialogs['desktop_top'], dialog);
            } else {
                SPUI.root.add_after(desktop_dialogs['desktop_bottom'], dialog);
            }
        }
    }
}

function init_chat_frame() {
    var dialog_data = gamedata['dialogs']['chat_frame2'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'chat_frame';
    dialog.user_data['size'] = 'uninitialized';
    dialog.user_data['console_shift'] = 0;
    dialog.user_data['transition_start_time'] = -1;
    dialog.user_data['cur_tab'] = -1;
    dialog.user_data['channel_to_tab'] = {};
    //dialog.ondraw = update_chat_frame; this is now called from the master do_draw() because it can change Z order of chat frame and desktop dialogs
    dialog.user_data['channel_names'] = [];
    if(gamedata['enable_region_map']) {
        dialog.user_data['channel_names'].push('REGION');
    }
    dialog.user_data['channel_names'].push('GLOBAL');
    if(player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) {
        dialog.user_data['channel_names'].push('ALLIANCE');
    }
    if(player.is_developer()) {
        dialog.user_data['channel_names'].push('DEVELOPER');
    }

    change_chat_tab(dialog, null);

    for(var i = 0; i < dialog.data['widgets']['tab_button']['array'][0]; i++) {
        var w = dialog.widgets['tab_button'+i.toString()];
        if(i < dialog.user_data['channel_names'].length) {
            var channel_name = dialog.user_data['channel_names'][i];
            w.str = dialog.data['widgets']['tab_button']['channels'][channel_name]['ui_name'];
            w.onclick = (function (_channel_name) { return function(w) {
                change_chat_tab(w.parent, _channel_name);
            }; })(channel_name);
        }
    }

    for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
        var tab = dialog.widgets['tabs'+i];
        dialog.widgets['tab_jewel'+i].user_data['text'] = null;
        dialog.widgets['tab_jewel'+i].ondraw = update_notification_jewel;

        if(i >= dialog.user_data['channel_names'].length) { tab.show = false; continue; }
        tab.transparent_to_mouse = true;
        tab.user_data['channel_name'] = dialog.user_data['channel_names'][i];
        dialog.user_data['channel_to_tab'][dialog.user_data['channel_names'][i]] = i;
        tab.user_data['last_timestamp'] = 0;
        tab.user_data['unit_donation_requests'] = {};
        var invert = !!tab.data['widgets']['output']['invert'];
        tab.widgets['output'].scroll_up_button = tab.widgets[(invert ? 'scroll_down' : 'scroll_up')];
        tab.widgets['output'].scroll_down_button = tab.widgets[(invert ? 'scroll_up' : 'scroll_down')];
        tab.widgets['output'].update_text();
        tab.widgets[(invert ? 'scroll_down' : 'scroll_up')].onclick = function(w) { w.parent.widgets['output'].scroll_up(); };
        tab.widgets[(invert ? 'scroll_up' : 'scroll_down')].onclick = function(w) { w.parent.widgets['output'].scroll_down(); };
        tab.widgets['request_donation_button'].onclick = function(w) {
            if(resolve_unit_donation_problem()) { return; }
            request_unit_donation(find_object_by_type(gamedata['alliance_building']));
            GameArt.assets["request_unit_donation_sound"].states['normal'].audio.play(client_time);
        };
    }

    dialog.widgets['all_jewel'].user_data['text'] = null;
    dialog.widgets['all_jewel'].ondraw = update_notification_jewel;

    if('fullscreen_button' in dialog.widgets) { dialog.widgets['fullscreen_button'].onclick = toggle_true_fullscreen; }

    var grow_func = function (big) { return function(w) {
        chat_frame_size(w.parent, big, false);
        player.preferences['chat_frame_minimized'] = !big;
        send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
    }; };
    dialog.widgets['grow_up'].onclick = grow_func(true);
    dialog.widgets['grow_down'].onclick = grow_func(false);

    dialog.widgets['input'].max_chars = gamedata['chat_length_limit'];
    dialog.widgets['input'].onfocus =
        dialog.widgets['input'].ontype =
        function(w) {
            //change_selection_ui(null);
            chat_frame_size(w.parent, true, false);
        };
    dialog.widgets['input'].onunfocus = function(w) {
        if(!w.str) {
            // reset "type here to chat" text
            w.str = w.data['ui_name'];
            w.has_typed = false;
        }
    };
    dialog.widgets['input'].ontextready = function(w, str) {
        if(!str) { return; }

        var encoded_str = SPHTTP.wrap_string(str);
        send_to_server.func(["CHAT_SEND", dialog.widgets['tabs'+dialog.user_data['cur_tab']].user_data['channel_name'], encoded_str]);
        dialog.widgets['tabs'+dialog.user_data['cur_tab']].widgets['output'].scroll_to_bottom();

        // play a click effect
        var state = GameArt.assets['action_button_134px'].states['normal'];
        if(state.audio) { state.audio.play(client_time); }
    };
    chat_frame_size(dialog, false, false);
    return dialog;
};

function chat_frame_size(dialog, big, forced) {
    var newsize = (big ? 'big' : 'small');
    if(dialog.user_data['size'] === newsize) { return; }
    dialog.user_data['size'] = newsize;
    dialog.user_data['transition_start_time'] = client_time;

    for(var i = 0; i < dialog.data['widgets']['tabs']['array'][0]; i++) {
        var tab = dialog.widgets['tabs'+i];
        tab.widgets['output_bg'].show =
            tab.widgets['output'].show =
            tab.widgets['scroll_up'].show =
            tab.widgets['scroll_down'].show =
            dialog.widgets['tab_jewel'+i].show = (!!big);
    }

    for(var i = 0; i < dialog.data['widgets']['tab_button']['array'][0]; i++) {
        dialog.widgets['tab_button'+i.toString()].show = !!big && (i < dialog.user_data['channel_names'].length);
    }

    dialog.widgets['grow_up'].show = !big; dialog.widgets['grow_down'].show = !!big;
    dialog.widgets['all_jewel'].show = !big;

    dialog.widgets['input_bg'].show = dialog.widgets['input'].show = !!big;
    dialog.widgets['fullscreen_button'].show = !!big && has_true_fullscreen();

    if(big) {
        dialog.widgets['bg_frame'].fade_unless_hover =
            dialog.widgets['input_bg'].fade_unless_hover =
            dialog.widgets['input'].fade_unless_hover = false;
        dialog.widgets['grow_bg'].fade_unless_hover = false;
    } else {
        dialog.widgets['bg_frame'].fade_unless_hover = dialog.data['widgets']['bg_frame']['fade_unless_hover'];
        dialog.widgets['input_bg'].fade_unless_hover = dialog.data['widgets']['input_bg']['fade_unless_hover'];
        dialog.widgets['input'].fade_unless_hover = dialog.data['widgets']['input']['fade_unless_hover'];
        dialog.widgets['grow_bg'].fade_unless_hover = dialog.data['widgets']['grow_bg']['fade_unless_hover'];
    }
};

function invoke_damage_protection_notice() {
    var dsk = desktop_dialogs['aura_bar'];

    if(!player.get_any_abtest_value('enable_damage_protection_notice', gamedata['client']['enable_damage_protection_notice']) ||
       player.resource_state['protection_end_time'] < server_time ||
       !dsk || !dsk.widgets['aura_glow0'] ||
       dsk.widgets['aura_icon0'].asset != 'inventory_protection') {
        return;
    }

    dsk.user_data['protection_time_glow'] = 1;
    var stop_glowing = (function (_dsk) { return function() {
        _dsk.user_data['protection_time_glow'] = 0;
    }; })(dsk);

    var msg = gamedata['strings']['damage_protection_notice'];

    var dialog = invoke_message_dialog(msg['ui_title'], msg['ui_description'],
                                       {'dialog': msg['dialog'],
                                        'on_ok': stop_glowing
                                       });
    dialog.modal = 0.33; // make background less dark
    return dialog;
};

/** Base damage calculator. Follows the base_damage_skip_partial setting unless count_partial option overrides it.
 * @param {{detail:(boolean|undefined),
 *          count_partial:(boolean|undefined)}=} options
 */
function do_calc_base_damage(options) {
    var damaged_objects = {};
    var base_hp_total = 0, base_hp_max = 0.1, barriers_damaged = 0;
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.is_building()) {
            if(obj.spec['worth_less_xp']) {
                // handle barriers separately
                if(obj.is_damaged() && obj.spec['name'] == 'barrier') {
                    barriers_damaged += 1;
                }
            } else {
                base_hp_max += obj.max_hp;

                if(!obj.is_destroyed() && gamedata['base_damage_skip_partial'] && !(options && options.count_partial)) {
                    // do not count damage from partially-damaged-but-not-destroyed objects
                    base_hp_total += obj.max_hp;
                } else {
                    base_hp_total += obj.hp;
                }

                if(options && options.detail && obj.is_damaged()) {
                    damaged_objects[obj.id] = {'spec':obj.spec['name'], 'hp':obj.hp, 'max_hp':obj.max_hp};
                    if(obj.is_producer()) {
                        damaged_objects[obj.id]['repair_finish_time'] = obj.repair_finish_time;
                        damaged_objects[obj.id]['produce_rate'] = obj.produce_rate;
                        damaged_objects[obj.id]['contents'] = obj.contents;
                    }
                }
            }
        }
    }
    base_hp_total = Math.floor(base_hp_total);
    base_hp_max = Math.floor(base_hp_max);
    var base_damage = (base_hp_max - base_hp_total) / Math.max(1,base_hp_max);

    // increment so that the repair dialog will fire even if only barriers are damaged
    if(barriers_damaged > 0) { base_damage += 0.0001; }
    base_damage = Math.min(Math.max(base_damage, 0), 1);

    return [base_damage, damaged_objects];
};

/** @param {{detail:(boolean|undefined),
             count_partial:(boolean|undefined)}=} options */
function calc_base_damage(options) { return do_calc_base_damage(options)[0]; }

function invoke_you_were_attacked_dialog(recent_attacks) {
    if(recent_attacks.length < 1) { return; }
    change_selection(null);

    var dialog_data = gamedata['dialogs']['you_were_attacked_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'you_were_attacked_dialog';

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    if('close_button' in dialog.widgets) { dialog.widgets['close_button'].onclick = function() { change_selection(null); }; }

    // calculate statistics
    var current_base_damage = calc_base_damage();
    var displayed_base_damage = current_base_damage;

    var lost_res = {}, lost_units = 0, killed_units = 0, killed_units_res = {}, bonus_xp = 0;
    var trophy_delta = 0;
    var last_attack_time = 0, last_attacker_name = '';
    var prot_expire_time = 0;
    var attacker_ids = {};
    var num_unique_attackers = 0;
    var row = 0; // friend icon

    var show_attrition = false;

    for(var i = 0; i < recent_attacks.length; i++) {
        var a = recent_attacks[i];
        lost_units += a['lost_units'];
        for(var res in gamedata['resources']) {
            if('lost_'+res in a) {
                lost_res[res] = (lost_res[res]||0) + a['lost_'+res];
            }
            if('killed_units_'+res in a) {
                killed_units_res[res] = (killed_units_res[res]||0) + a['killed_units_'+res];
                if(killed_units_res[res] > 0) {
                    show_attrition = true;
                }
            }
        }
        if('defender_protection_expired_at' in a) {
            prot_expire_time = Math.max(prot_expire_time, a['defender_protection_expired_at']);
        }
        if('killed_units' in a) { killed_units += a['killed_units']; }
        if('defender_xp' in a) { bonus_xp += a['defender_xp']; }
        if('viewing_trophies_pvp' in a) { trophy_delta += a['viewing_trophies_pvp']; }
        if('base_damage' in a && a['base_damage'] > displayed_base_damage) {
            displayed_base_damage = a['base_damage'];
        }
        if(last_attack_time < a['time']) {
            last_attack_time = a['time'];
            last_attacker_name = a['attacker_name'];
        }
        if(a['attacker_user_id'] in attacker_ids) {
            // not unique
            continue;
        }

        attacker_ids[a['attacker_user_id']] = 1;
        num_unique_attackers += 1;
        if(row < 3) {
            dialog.widgets['friend_icon'+row].set_user(a['attacker_user_id']);
            dialog.widgets['friend_icon'+row].set_user_level(a['attacker_level']);
            row += 1;
        }
    }

    // clear remaining friend icons
    while(row < 3) {
        dialog.widgets['friend_icon'+row].show = 0;
        row += 1;
    }

    dialog.widgets['base_damage'].str = Math.floor(100*displayed_base_damage).toFixed(0) + '%';

    var attack_time_str = dialog.data['widgets']['attack_time']['ui_name'].replace('%s', pretty_print_time_brief(server_time - last_attack_time));
    if(prot_expire_time > 0) {
        attack_time_str += dialog.data['widgets']['attack_time']['ui_name_prot'].replace('%prot', pretty_print_time_brief(server_time - prot_expire_time));
    }
    dialog.widgets['attack_time'].str = attack_time_str;

    var str = dialog.data['widgets']['attacked_by']['ui_name'+ (num_unique_attackers > 2 ? '_many_others': (num_unique_attackers > 1 ? '_one_other' : ''))];
    dialog.widgets['attacked_by'].str = str.replace('%s',last_attacker_name).replace('%d',(num_unique_attackers-1).toString());

    for(var res in gamedata['resources']) {
        if(res+'_amount' in dialog.widgets) {
            dialog.widgets[res+'_amount'].show = dialog.widgets[res+'_icon'].show = !!(lost_res[res]||0);
            dialog.widgets[res+'_icon'].asset = gamedata['resources'][res]['icon_small'];
            dialog.widgets[res+'_amount'].str = pretty_print_number(lost_res[res]||0);
        }
    }

    dialog.widgets['you_endured'].str = dialog.data['widgets']['you_endured']['ui_name'].replace('%d', pretty_print_number(recent_attacks.length));

    dialog.widgets['you_destroyed'].show = (killed_units>0);
    dialog.widgets['you_destroyed'].str = dialog.data['widgets']['you_destroyed']['ui_name'].replace('%d', pretty_print_number(killed_units));


    if(show_attrition) {
        var att_list = [];
        for(var res in gamedata['resources']) {
            if(killed_units_res[res]) {
                att_list.push(pretty_print_number(killed_units_res[res]) + ' ' + gamedata['resources'][res]['ui_name']);
            }
        }
        var att_str = att_list.join(', ');
        dialog.widgets['attrition'].str = dialog.data['widgets']['attrition']['ui_name'].replace('%COST', att_str);
    }

    dialog.widgets['attrition'].show = show_attrition;

    if(trophy_delta != 0) {
        dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_label'].show =
            dialog.widgets['trophy_sunken'].show =
            dialog.widgets['trophy_shine'].show =
            dialog.widgets['trophy_amount'].show = true;
        var sign = (trophy_delta > 0 ? 'plus' : 'minus');
        dialog.widgets['trophy_amount'].str = dialog.data['widgets']['trophy_amount']['ui_name_'+sign].replace('%d', pretty_print_number(Math.abs(trophy_delta)));
        dialog.widgets['trophy_amount'].text_color = SPUI.make_colorv(dialog.data['widgets']['trophy_amount']['text_color_'+sign]);
        dialog.widgets['trophy_label'].str = dialog.data['widgets']['trophy_label']['ui_name'].replace('%s', gamedata['events']['challenge_pvp_ladder']['ui_name']);
    }

    // check base for building action interrupts
    var interrupts = [];
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.is_building() && obj.team === 'player' && obj.is_damaged()) {
            if(obj.is_manufacturing() && obj.manuf_start_time <= 0) {
                interrupts.push(dialog.data['widgets']['halt_message']['ui_name_production'].replace('%s',obj.spec['ui_name']).replace('%INTERRUPTED',gamedata['spells']['MAKE_DROIDS']['ui_name_interrupted']));
            } else if(obj.is_researching() && obj.research_start_time <= 0) {
                interrupts.push(dialog.data['widgets']['halt_message']['ui_name_research'].replace('%s',obj.spec['ui_name']));
            } else if(obj.is_crafting()) {
                var craft_queue = obj.get_crafting_queue();
                for(var i = 0; i < craft_queue.length; i++) {
                    if(craft_queue[i]['start_time'] <= 0) {
                        var cat = gamedata['crafting']['categories'][gamedata['crafting']['recipes'][craft_queue[i]['craft']['recipe']]['crafting_category']];
                        if(('haltable' in cat) && !cat['haltable']) {
                            // not haltable
                        } else {
                            interrupts.push(dialog.data['widgets']['halt_message']['ui_name_crafting'].replace('%s',obj.spec['ui_name']));
                            break;
                        }
                    }
                }
            } else if(obj.is_upgrading() && obj.upgrade_start_time <= 0) {
                interrupts.push(dialog.data['widgets']['halt_message']['ui_name_upgrade'].replace('%s',obj.spec['ui_name']));
            }
        }
    }

    dialog.widgets['halt_bg'].show = dialog.widgets['halt_message'].show = (interrupts.length > 0);

    if(interrupts.length > 0) {
        dialog.widgets['halt_bg'].wh[1] = dialog.widgets['halt_message'].wh[1] = interrupts.length*(dialog.widgets['halt_message'].font.leading)+10;
        dialog.widgets['halt_message'].str = interrupts.join('\n');
    }

    init_dialog_repair_buttons(dialog, current_base_damage);

    notification_queue.push(invoke_damage_protection_notice);

    if(gamedata['client']['auto_show_battle_log']) {
        notification_queue.push(function() { invoke_battle_history_dialog(session.user_id, -1, '', -1); });
    }
};

function test_you_were_attacked_dialog() {
    var at = {'lost_iron':100, 'lost_water':200, 'lost_units':5, 'defender_protection_expired_at':server_time-60, 'killed_units':5, 'killed_units_water':300, 'killed_units_iron':400, 'defender_xp': 123, 'time': server_time-30, 'attacker_name': 'FOO', 'attacker_user_id':1112, 'attacker_facebook_id':'example1', 'attacker_level':5, 'viewing_trophies_pvp':20};
    invoke_you_were_attacked_dialog([at,at]);
}

// hack - make sure repairs are only started once on login
var repairs_started = false;

function init_dialog_repair_buttons(dialog, base_damage) {
    var cost_res = {};
    var do_units = true;
    var any_unit_damage = false;

    if(do_units) {
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.team === 'player' && obj.is_mobile() && obj.is_damaged() && !obj.is_under_repair() && player.can_repair_unit(obj)) {
                any_unit_damage = true;
                var obj_cost = obj.cost_to_repair(player);
                for(var res in obj_cost) {
                    if(res == 'time') { continue; }
                    cost_res[res] = (cost_res[res]||0) + obj_cost[res];
                }
            }
        }
    }
    dialog.user_data['repair_cost_res'] = cost_res;

    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();

    var start_slow_repair = function(w) {
        var dialog = w.parent;
        close_parent_dialog(w);

        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "REPAIR", session.viewing_base.base_id]);

        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.is_building() && obj.is_damaged() && !obj.is_repairing()) {
                // client-side predict
                var health = (obj.hp) / (1.0*obj.max_hp);
                health = Math.max(0.0, Math.min(health, 1.0))
                var repair_time = Math.max(1, Math.floor((1.0-health)*obj.get_leveled_quantity(obj.spec['repair_time'])));
                obj.repair_finish_time = server_time + repair_time;
                obj.update_all_actions(server_time);
            }
        }
    };

    if(base_damage > 0 || (player.unit_speedups_enabled() && any_unit_damage)) { // also check for unit repair cost?
        var instant_price = Store.get_user_currency_price(0, gamedata['spells']['REPAIR_ALL_FOR_MONEY'], session.viewing_base.base_id);
        dialog.widgets['price_display'].str = Store.display_user_currency_price(instant_price); // PRICE
        dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(instant_price);

        if(instant_price < 1) {
            dialog.widgets['price_display'].onclick =
                dialog.widgets['repair_instant_button'].onclick = function(w) {
                // manually send REPAIR followed by SPEEDUP_FOR_FREE on each damaged building
                close_parent_dialog(w);
                send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "REPAIR", session.viewing_base.base_id]);

                for(var id in session.cur_objects.objects) {
                    var obj = session.cur_objects.objects[id];
                    if(obj.is_building() && obj.is_damaged()) {
                        send_to_server.func(["CAST_SPELL", obj.id, "SPEEDUP_FOR_FREE"]);
                        obj.hp = obj.max_hp; obj.repair_finish_time = -1; // client-side predict
                        obj.update_all_actions(server_time);
                    }
                }
                // no such thing as free unit repairs
                //send_to_server.func(["UNIT_REPAIR_SPEEDUP_FOR_FREE"]);
            };
        } else {
            dialog.widgets['price_display'].onclick =
                dialog.widgets['repair_instant_button'].onclick = function(w) {
                    var dialog = w.parent;

                    if(Store.place_user_currency_order(GameObject.VIRTUAL_ID, "REPAIR_ALL_FOR_MONEY",
                                                       session.viewing_base.base_id,
                                                       (function (_w) { return function() {
                                                           close_parent_dialog(_w);
                                                           for(var id in session.cur_objects.objects) {
                                                               var obj = session.cur_objects.objects[id];
                                                               if(obj.is_building() && obj.is_damaged()) {
                                                                   obj.hp = obj.max_hp; obj.repair_finish_time = -1; // client-side predict
                                                                   obj.update_all_actions(server_time);
                                                               }
                                                           }
                                                       }; })(w)
                                                      )) {
                        dialog.widgets['repair_instant_button'].str = dialog.data['widgets']['repair_instant_button']['ui_name_pending'];
                        dialog.widgets['repair_instant_button'].state = 'disabled'; dialog.widgets['price_display'].onclick = null;
                    }
            };
        }

        dialog.widgets['repair_slow_button'].onclick = start_slow_repair;

    } else {
        // base is not damaged
        dialog.widgets['price_display'].show =
        dialog.widgets['repair_slow_button'].show =
            dialog.widgets['repair_instant_button'].show = false;
        dialog.widgets['repair_not_necessary_button'].show = true;
        dialog.widgets['repair_not_necessary_button'].onclick = (any_unit_damage ? start_slow_repair : close_parent_dialog);
        dialog.default_button = dialog.widgets['repair_not_necessary_button'];
    }
};

function do_invoke_repair_dialog() {
    var dialog_data = gamedata['dialogs']['repair_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'repair_dialog';
    dialog.modal = true;
    init_dialog_repair_buttons(dialog, calc_base_damage({count_partial:true}));
    // count # of things needing repair, for UI only
    var buildings = 0, units = 0, barriers = 0, beyond_tech = 0, beyond_tech_types = {};
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.team === 'player' && obj.is_damaged()) {
            if(obj.is_building()) {
                if(obj.spec['name'] == 'barrier') {
                    barriers += 1;
                } else {
                    buildings += 1;
                }
            } else if(obj.is_mobile()) {
                if(player.can_repair_unit(obj)) {
                    units += 1;
                } else {
                    beyond_tech += 1;
                    if(!(obj.spec['name'] in beyond_tech_types)) {
                        beyond_tech_types[obj.spec['name']] = 0;
                    }
                    beyond_tech_types[obj.spec['name']] += 1;
                }
            }
        }
    }

    var txt = '';
    if(buildings > 0) {
        txt += buildings.toString()+' '+gamedata['strings']['object_kinds']['buildings'][((buildings!=1)?'plural':'singular')].toLowerCase();
    }

    if(barriers > 0) {
        if(txt.length > 0) { txt += ', '; }
        txt += barriers.toString()+' '+gamedata['buildings']['barrier']['ui_name'+((barriers!=1)?'_plural':'')].toLowerCase();
    }

    var do_units = true;
    if(do_units && units > 0 && !session.is_quarry()) {
        if(txt.length > 0) { txt += ', '; }
        txt += units.toString()+' '+gamedata['strings']['object_kinds']['units'][((units!=1)?'plural':'singular')].toLowerCase();
    }

    var extra = '';
    if(beyond_tech > 0) {
        extra += '\n\n'+beyond_tech.toString()+' '+gamedata['strings']['object_kinds']['units'][((beyond_tech!=1)?'plural':'singular')].toLowerCase();
        extra += ' '+dialog.data['widgets']['description']['ui_name_need_research_'+((beyond_tech>1)?'many':'one')];

        var typelist = [];
        for(var specname in beyond_tech_types) {
            typelist.push(beyond_tech_types[specname].toString()+'x '+gamedata['units'][specname]['ui_name']);
        }
        extra += ' ('+typelist.join(', ')+')';
    }

    if(goog.object.getCount(dialog.user_data['repair_cost_res']) > 0) {
        extra += '\n\n';
        var ls = [];
        for(var res in dialog.user_data['repair_cost_res']) {
            if(dialog.user_data['repair_cost_res'][res] > 0) {
                ls.push(pretty_print_number(dialog.user_data['repair_cost_res'][res]) + ' ' + gamedata['resources'][res]['ui_name']);
            }
        }
        extra += dialog.data['widgets']['description']['ui_name_resources'].replace('%s', ls.join(', '));
    }

    dialog.widgets['description'].set_text_with_linebreaking(dialog.data['widgets']['description']['ui_name'].replace('%s', txt).replace('%extra',extra));
    return dialog;
};

function invoke_repair_dialog() {
    change_selection(null);
    var dialog = do_invoke_repair_dialog();
    change_selection_ui(dialog);
    dialog.auto_center();
    return dialog;
};

function invoke_repair_dialog_conditional() {
    var needs_rep = false;

    if(!repairs_started) {
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.team === 'player' && obj.is_building() && obj.is_damaged() && (session.is_quarry() || !obj.is_repairing())) {
                needs_rep = true;
                break;
            }
            if(obj.is_mobile() && obj.is_damaged() && !obj.is_under_repair() && obj.team === 'player' && !session.is_quarry() && player.can_repair_unit(obj)) {
                needs_rep = true;
                break;
            }
        }
    }
    if(needs_rep) {
        invoke_repair_dialog();
    }
};

function invoke_child_repair_dialog() {
    if(!selection.ui) {
        return invoke_repair_dialog();
    }
    var dialog = do_invoke_repair_dialog();
    install_child_dialog(dialog);
    dialog.auto_center();
    //dialog.xy[0] = Math.floor((selection.ui.wh[0]-dialog.wh[0])/2);
    ///dialog.xy[1] = Math.floor((selection.ui.wh[1]-dialog.wh[1])/2);
    //selection.ui.add(dialog);
    //var closure = function(w) { var dialog = w.parent; if(dialog && dialog.parent) { dialog.parent.remove(dialog); } };
    return dialog;
};

function invoke_recycle_dialog(obj) {
    // NOTE! with squads, or no defending units, "obj" will be the entry in player.my_army, NOT a GameObject
    var dialog = new SPUI.Dialog(gamedata['dialogs']['recycle_message']);
    dialog.user_data['dialog'] = 'recycle_message';
    dialog.user_data['is_army'] = (player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units']));

    dialog.modal = true;
    if(selection.ui) {
        selection.ui.add(dialog);
        dialog.xy[0] = Math.floor((selection.ui.wh[0]-dialog.wh[0])/2);
        dialog.xy[1] = Math.floor((selection.ui.wh[1]-dialog.wh[1])/2);
    } else {
        change_selection_ui(dialog);
        dialog.auto_center();
    }

    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['ok_button'].onclick = (function(_obj) { return function(w) {
        var dialog = w.parent;
        close_parent_dialog(w);
        if(dialog.user_data['is_army']) {
            if(_obj['obj_id'] in player.my_army) {
                send_to_server.func(["RECYCLE_UNIT", _obj['obj_id']]);
                // snoop update into my_army
                if(_obj['obj_id'] in player.my_army) {
                    delete player.my_army[_obj['obj_id']];
                    session.lazy_update_citizens();
                }
                if(_obj['obj_id'] in session.cur_objects.objects) {
                    remove_object(session.cur_objects.objects[_obj['obj_id']]);
                }
            }
        } else {
            if(_obj.id && _obj.id !== GameObject.DEAD_ID) { // check obj.id rather than is_destroyed() because you CAN recycle destroyed units
                send_to_server.func(["RECYCLE_UNIT", _obj.id]);
                unit_repair_sync_marker = synchronizer.request_sync();
                // snoop update into my_army
                if(_obj.id in player.my_army) {
                    delete player.my_army[_obj.id];
                    session.lazy_update_citizens();
                }
                remove_object(_obj);
            }
        }
    }; })(obj);

    var spec, level, hp, max_hp;
    if(dialog.user_data['is_army']) {
        spec = gamedata['units'][obj['spec']]; level = obj['level'] || 1;
        var cur_max = army_unit_hp(obj); hp = cur_max[0]; max_hp = cur_max[1];
    } else {
        spec = obj.spec; level = obj.level; hp = obj.hp; max_hp = obj.max_hp;
    }

    dialog.widgets['title'].str = gamedata['spells']['RECYCLE_UNIT']['ui_prompt'].replace('%d', spec['ui_name']);
    dialog.widgets['ok_button'].str = gamedata['spells']['RECYCLE_UNIT']['ui_name'];
    dialog.widgets['tip_text'].str = dialog.data['widgets']['tip_text']['ui_name'].replace('%s', gamedata['spells']['RECYCLE_UNIT']['ui_name']);

    // compute and display refund amounts
    var recycle_ratio = player.get_any_abtest_value('unit_recycle_resources', gamedata['unit_recycle_resources']);
    var health_ratio = (1.0*hp)/max_hp;
    for(var res in gamedata['resources']) {
        var cost = get_leveled_quantity(spec['build_cost_'+res]||0, level);
        var refund = Math.max(0, Math.floor(recycle_ratio * health_ratio * cost));
        if('resource_bar_'+res+'_amount' in dialog.widgets) {
            dialog.widgets['resource_bar_'+res+'_amount'].str = pretty_print_number(refund);
        }
    }
    return dialog;
};

/** invoke the "Buy Resources" dialog
 * @param {Object} amounts - dictionary of {res:amount}
 * @param {?} continuation - optional callback to call after the purchase
 */
function invoke_buy_resources_dialog(amounts, continuation) {
    if(!('BUY_RESOURCES_TOPUP' in gamedata['spells'])) {
        throw Error('game has no BUY_RESOURCES_TOPUP spell');
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['buy_resources_dialog']);
    dialog.user_data['dialog'] = 'buy_resources_dialog';
    dialog.user_data['amounts'] = amounts;
    dialog.user_data['continuation'] = (continuation || null);
    dialog.modal = true;
    install_child_dialog(dialog);
    dialog.auto_center();

    dialog.widgets['close_button'].onclick = close_parent_dialog;

    var n_resources = 0;
    for(var res in gamedata['resources']) {
        var cost = amounts[res] || 0;
        if('resource_bar_'+res+'_amount' in dialog.widgets) {
            dialog.widgets['resource_bar_'+res+'_amount'].str = pretty_print_number(cost);
        }
        if(cost > 0) { n_resources++; }
    }

    // piece together the GUI sentence
    var ui_res = dialog.data['widgets']['description']['ui_name_res'+n_resources.toString()];
    var n = 0;
    for(var res in gamedata['resources']) {
        var cost = amounts[res] || 0;
        if(cost > 0) {
            ui_res = ui_res.replace('%d'+n.toString(), pretty_print_number(cost)).replace('%s'+n.toString(), gamedata['resources'][res]['ui_name']);
            n += 1;
        }
    }

    var price = Store.get_user_currency_price(0, gamedata['spells']['BUY_RESOURCES_TOPUP'], dialog.user_data['amounts']);

    dialog.widgets['description'].set_text_with_linebreaking(ui_res.replace('%GAMEBUCKS_QTY', Store.display_user_currency_price(price)).replace('%GAMEBUCKS_NAME', Store.gamebucks_ui_name()));

    var closure = function(w) {
        var dialog = w.parent;
        if(Store.place_user_currency_order(GameObject.VIRTUAL_ID, "BUY_RESOURCES_TOPUP", dialog.user_data['amounts'],
                                           (function (_dialog) { return function() {
                                               var cb = _dialog.user_data['continuation'] || null;
                                               close_dialog(_dialog);
                                               if(cb) { cb(); }
                                           }; })(dialog)
                                          )) {
            if(true && dialog.user_data['continuation']) {
                var cb = dialog.user_data['continuation'];
                dialog.user_data['continuation'] = null;
                cb();
            } else {
                invoke_ui_locker();
            }
            dialog.widgets['ok_button'].str = dialog.data['widgets']['ok_button']['ui_name_pending'];
            dialog.widgets['ok_button'].state = 'disabled';
            dialog.widgets['price_display'].onclick = null;
        }

        if(gamedata['client']['log_insufficient_resources']) {
            metric_event('5203_insufficient_resources_topup_buy_now', {});
        }
    }

    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
    dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);

    dialog.widgets['ok_button'].onclick =
        dialog.widgets['price_display'].onclick = closure;

    if(gamedata['client']['log_insufficient_resources']) {
        metric_event('5202_insufficient_resources_topup_dialog', {});
    }

    return dialog;
};

var idle_check_state = {
    timer: null,
    start_time: -1
};

function invoke_idle_check_dialog(play_time) {
    if(idle_check_state.timer) { return; }
    idle_check_state.start_time = client_time;

    var dialog = new SPUI.Dialog(gamedata['dialogs']['icheck_dialog']);
    dialog.modal = true;
    dialog.default_button = null; // do not allow Enter keypress to trigger
    if('close_button' in dialog.widgets) { dialog.widgets['close_button'].show = false; } // do not allow Escape keypress to trigger

    if(0 && selection.ui) {
        selection.ui.add(dialog);
    } else {
        change_selection_ui(dialog);
    }

    dialog.xy[0] = Math.floor((dialog.parent.wh[0]-dialog.wh[0])/2);
    dialog.xy[1] = Math.floor((dialog.parent.wh[1]-dialog.wh[1])/2);
    // randomize position
    dialog.xy[0] += Math.floor(Math.random()*200-100);
    dialog.xy[1] += Math.floor(Math.random()*200-100);

    var go_away = function(w) {
        if(idle_check_state.start_time > 0) {
            send_to_server.func(["IDLE_CHECK_RESPONSE", client_time - idle_check_state.start_time]);
            idle_check_state.start_time = -1;
        }
        if(idle_check_state.timer) {
            window.clearTimeout(idle_check_state.timer);
            idle_check_state.timer = null;
        }
        close_parent_dialog(w);
    };

    dialog.widgets['ok_button'].onclick = go_away;
    var str = dialog.data['widgets']['description']['ui_name'].replace('%s', pretty_print_time(play_time));
    dialog.widgets['description'].set_text_with_linebreaking(str);
    //idle_check_state.timer = window.setTimeout(function() { SPINPUNCHGAME.shutdown(); }, 15000);
}

function invoke_gift_received_dialog(fbid, userid, name, loot) {
    change_selection(null);

    var dialog_data = gamedata['dialogs']['gift_received_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'gift_received_dialog';

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['close_button'].onclick = function() { change_selection(null); };

    // try to figure out the friend's level
    var level = -1;
    for(var i = 0; i < player.friends.length; i++) {
        if(player.friends[i].user_id === userid) {
            level = player.friends[i].get_player_level();
            break;
        }
    }
    dialog.widgets['friend_icon'].set_user(userid);

    var asset = null, amount = 0;
    for(var res in gamedata['resources']) {
        if(res in loot && loot[res] > 0) {
            asset = 'resource_icon_'+res; amount = loot[res];
            break;
        }
    }

    if(asset) { dialog.widgets['resource_icon'].asset = asset; }
    if(amount) { dialog.widgets['resource_amount'].str = pretty_print_number(amount); }

    if(get_facebook_viral('say_thanks')) {
        dialog.widgets['say_thanks_button'].onclick = (function (a, b, c, d) { return function() {
            change_selection(null);
            invoke_say_thanks(a, b, c, d);
        }; })(fbid, userid, name, loot);
    } else {
        dialog.widgets['say_thanks_button'].show = false;
    }

    dialog.widgets['send_button'].show = player.resource_gifts_enabled();
    dialog.widgets['send_button'].onclick = function() {
        change_selection(null);
        FBSendRequests.invoke_send_gifts_dialog(null);
    };
};

function invoke_say_thanks(recipient_fb_id, recipient_user_id, recipient_fb_name, loot) {
    var viral = get_facebook_viral('say_thanks');
    if(!viral) { return; }
    if(!spin_facebook_enabled) { console.log('invoke_say_thanks'); return; }
    call_with_facebook_permissions('publish_actions', (function (_viral, _recipient_fb_id, _recipient_user_id, _recipient_fb_name, _loot) {
        return function() { invoke_say_thanks_with_permissions(_viral, _recipient_fb_id, _recipient_user_id, _recipient_fb_name, _loot); }; })(viral, recipient_fb_id, recipient_user_id, recipient_fb_name, loot));
}

function invoke_say_thanks_with_permissions(viral, recipient_fb_id, recipient_user_id, recipient_fb_name, loot) {
    var loot_text = '';
    for(var res in gamedata['resources']) {
        if((res in loot) && loot[res] > 0) {
            loot_text += pretty_print_number(loot[res])+' '+gamedata['resources'][res]['ui_name'];
        }
    }
    if(loot_text === '') {
        loot_text += viral['ui_generic_loot'];
    }

    var cb = (function (_recipient_user_id, _recipient_fb_id, _loot_text) { return function(response) {
        if(!response) {
            // user cancelled
            return true;
        }
        if('post_id' in response) {
            if(LOTS_OF_METRICS) {
                metric_event('4090_say_thanks_post_completed',
                             {'recipient_fb_id':_recipient_fb_id,
                              'recipient_user_id':_recipient_user_id,
                              'facebook_post_id':response['post_id']});
            }
            if(gamedata['enable_fb_open_graph'] &&
               (!gamedata['fb_open_graph']['developer_only'] || player.is_developer()) &&
               gamedata['fb_open_graph']['thank']['enable']) {
                SPFB.api('/me/'+spin_app_namespace+':thank', 'post', {'profile': _recipient_fb_id, 'loot': _loot_text}); // say thanks
            }
        }
        return true;
    }; })(recipient_user_id, recipient_fb_id, loot_text);

    if(LOTS_OF_METRICS) {
        metric_event('4080_say_thanks_post_attempted', {'recipient_fb_id':recipient_fb_id, 'recipient_user_id':recipient_user_id});
    }

    var link_url = 'http://apps.facebook.com/'+spin_app_namespace+'/';
    // add acquisition tracking info
    link_url += '?spin_ref=feed_thanks&spin_ref_user_id='+session.user_id.toString()+'&spin_gift_id=1111'; // XXX

    SPFB.ui({'method':'feed', // say thanks
             'message':viral['ui_post_message'].replace('%THANKEE', recipient_fb_name),
             'name':viral['ui_post_headline'].replace('%LOOT', loot_text),
             //'caption':viral['ui_post_text'].replace('%THANKEE', recipient_fb_name), // obsolete
             'description':gamedata['virals']['ui_post_description'],
             'link':link_url,
             'picture': gamedata['virals']['common_image_path'] + (('image' in viral) ? viral['image'] : gamedata['virals']['default_image']),
             'ref':'feed_thanks',
             'show_error': !spin_secure_mode
            }, cb);
};

function invoke_invite_friends_dialog(reason) {
    if(spin_frame_platform == 'kg') {
        if(!spin_kongregate_enabled) { console.log('invoke_invite_friends_dialog('+reason+')'); return; }
        SPKongregate.showInvitationBox({'content': gamedata['virals']['invite_friends']['ui_post_message'],
                                        'filter': 'not_played',
                                        'kv_params': {'kv_spin_referer': session.user_id}});
    } else if(spin_frame_platform == 'fb') {
        if(!spin_facebook_enabled) { console.log('invoke_invite_friends_dialog('+reason+')'); return; }
        call_with_facebook_permissions('user_friends', (function (_reason) { return function() {
            FBInviteFriends.invoke_fb_invite_friends_dialog(reason);
        }; })(reason));
    } else {
        throw Error('unhandled frame_platform '+spin_frame_platform);
    }
}

function invoke_gift_prompt_dialog(fbid, userid, name, loot) {
    if(player.tutorial_state != "COMPLETE") { return; }

    if(player.get_giftable_friend_info_list().length < 1) {
        console.log('invoke_gift_prompt_dialog: no giftable friends');
        return;
    }

    change_selection(null);
    if(LOTS_OF_METRICS) {
        metric_event('4100_send_gifts_popup_shown', {'sum': player.get_denormalized_summary_props('brief')});
    }

    var dialog_data = gamedata['dialogs']['gift_prompt_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'gift_prompt_dialog';

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['close_button'].onclick = function() { change_selection(null); };

    dialog.widgets['send_button'].onclick = function() {
        change_selection(null);
        FBSendRequests.invoke_send_gifts_dialog(null);
    };
};

function invoke_motd_dialog(motd) {
    if(player.tutorial_state != "COMPLETE") { return; }

    change_selection(null);

    var dialog_data = gamedata['dialogs']['motd_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'motd_dialog';
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['close_button'].onclick =
        dialog.widgets['ok_button'].onclick =
        function() { change_selection(null); };

    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name'].replace('%GAME', gamedata['strings']['game_name']);
    dialog.widgets['subtitle'].str = motd['date'];
    dialog.widgets['description'].set_text_with_linebreaking(motd['text']);
};

function invoke_level_up_dialog() {
    if(player.tutorial_state != "COMPLETE") { return; }

    var next_level = player.can_level_up();
    if(!next_level) { return; }

    // try to get unit damage in sync so the "repair all" reward is less likely to fail due to a race condition
    flush_dirty_objects({});

    // just ask the server to level us up asynchronously
    send_to_server.func(["LEVEL_ME_UP", next_level]);
    SPFB.AppEvents.logEvent('ACHIEVED_LEVEL', null, {'LEVEL': next_level.toString()});

    if('level_up_notify' in gamedata['player_xp'] &&
       next_level < gamedata['player_xp']['level_up_notify'].length &&
       !gamedata['player_xp']['level_up_notify'][next_level]) {
        invoke_ui_locker();
        return;
    }

    change_selection(null);

    var dialog_data = gamedata['dialogs']['level_up_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'level_up_dialog';

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name'].replace('%d', next_level);
    //dialog.widgets['description'].str = gamedata['player_xp']['level_up_text'];

    // display reward consequent
    var level_up_rewards = player.get_any_abtest_value('level_up_reward', gamedata['player_xp']['level_up_reward'] || []);
    var reward_cons = level_up_rewards[Math.min(next_level, level_up_rewards.length-1)];

    if(reward_cons && reward_cons['consequent'] == 'GIVE_LOOT') {
        dialog.widgets['your_level_bonus'].str = dialog.data['widgets']['your_level_bonus']['ui_name_messages'];
        goog.array.forEach(['item_glow','slot','item','stack','frame'], function(n) { dialog.widgets['reward_'+n].show = true; });
        var item = reward_cons['loot'][0];
        var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
        ItemDisplay.set_inventory_item_asset(dialog.widgets['reward_item'], spec);
        ItemDisplay.set_inventory_item_stack(dialog.widgets['reward_stack'], spec, item);
        dialog.widgets['reward_frame'].onenter = (function (_slot, _item) { return function(w) {
            var inv_dialog = w.parent;
            if(inv_dialog.user_data['context']) {
                // do not switch if context for this item is already up
                if(inv_dialog.user_data['context'].user_data['slot'] === _slot &&
                   inv_dialog.user_data['context'].user_data['item'] === _item) {
                    return;
                }
            }
            invoke_inventory_context(w.parent, w, _slot, _item, false);
        }; })('reward_item', item);
        dialog.widgets['reward_frame'].onleave_cb = (function (_slot, _item) { return function(w) {
            var inv_dialog = w.parent;
            if(inv_dialog.user_data['context'] &&
               inv_dialog.user_data['context'].user_data['slot'] === _slot &&
               inv_dialog.user_data['context'].user_data['item'] === _item) {
                invoke_inventory_context(w.parent, w, -1, null, false);
            }
        }; })('reward_item', item);
    } else if(reward_cons && reward_cons['consequent'] == 'HEAL_ALL_UNITS') {
        dialog.widgets['your_level_bonus'].str = dialog.data['widgets']['your_level_bonus']['ui_name_heal_all_units'];
        dialog.widgets['repair_all_icon'].show = dialog.widgets['all_units_repaired'].show = true;
    } else if(reward_cons === null) {
        dialog.widgets['your_level_bonus'].show = false;
    } else {
        throw Error('cannot parse level_up_reward consequent: '+JSON.stringify(reward_cons));
    }

    if(friend_invites_enabled()) {
        dialog.widgets['spam_button_invite'].onclick = function() {
            change_selection(null);
            invoke_invite_friends_dialog('level_up_dialog');
        };

        // show "Inform Earth" for level 2 (on Facebook), and "Invite Friends" for level 3 and beyond
        if(next_level <= 2 && get_facebook_viral('level_advancement')) {
            dialog.widgets['spam_button_inform'].show = true;
            dialog.widgets['spam_button_invite'].show = false;
            dialog.widgets['spam_button_inform'].str = gamedata['virals']['level_advancement']['ui_button_text'];
            dialog.widgets['spam_button_inform'].onclick = (function (_next_level) {
                return function() { invoke_facebook_viral('level_advancement', {'%LEVEL': _next_level.toString()}); };
            })(next_level);
            dialog.default_button = dialog.widgets['spam_button_inform'];
        } else {
            dialog.widgets['spam_button_inform'].show = false;
            dialog.widgets['spam_button_invite'].show = true;
            dialog.default_button = dialog.widgets['spam_button_invite'];
        }
    } else {
        dialog.widgets['spam_button_invite'].show = false;
        dialog.widgets['spam_button_inform'].show = false;
        dialog.default_button = null;
    }

    dialog.widgets['glow'].show =
    dialog.widgets['screen_flash'].show =
    dialog.widgets['prog_bar_bg'].show =
    dialog.widgets['prog_bar1'].show =
    dialog.widgets['prog_bar2'].show =
    dialog.widgets['prog_bar3'].show =
        dialog.widgets['new_achievement'].show = true;

    play_level_up_sound(null);
    invoke_ui_locker();
};

// don't spam the player with multiple loud level-up sounds if they cross multiple levels/get multiple upgrades at once
var last_level_up_sound_time = -1;
function play_level_up_sound(sound_asset) {
    if(!sound_asset) { sound_asset = 'level_up_sound'; }

    if(client_time - last_level_up_sound_time < 10.0) {
        sound_asset = 'menu_button_134px';
    } else {
        // play big sound
        last_level_up_sound_time = client_time;
    }

    GameArt.assets[sound_asset].states['normal'].audio.play(client_time);
}

// NEW metrics codes:
// 7270_feed_post_attempted
// 7271_feed_post_completed

function viral_string_subst(source, props) {
    var p = {'%NAME': player.facebook_name,
             '%FIRSTNAME': player.get_ui_name()
            };
    var ret = source;
    for(var key in p) {
        ret = ret.replace(key, p[key]);
    }
    if(props) {
        for(var key in props) {
            ret = ret.replace(key, props[key]);
        }
    }
    return ret;
}

function get_facebook_viral(vname) {
    if(spin_frame_platform != 'fb') { return null; }
    if('enable_if' in gamedata['virals'] && !read_predicate(gamedata['virals']['enable_if']).is_satisfied(player, null)) { return null; }
    if(!vname) { return null; }
    if(!(vname in gamedata['virals'])) { console.log('invalid viral '+vname); return null; }
    var viral = gamedata['virals'][vname];
    if('show_if' in viral && !read_predicate(viral['show_if']).is_satisfied(player, null)) { return null; }
    return viral;
}

function invoke_facebook_viral(vname, props) {
    var viral = get_facebook_viral(vname);
    if(!viral) { return; }
    if(!spin_facebook_enabled) { console.log('invoke_facebook_viral: '+vname); return; }
    call_with_facebook_permissions('publish_actions', (function (_vname, _viral, _props) { return function() { invoke_facebook_viral_with_permissions(_vname, _viral, _props); }; })(vname, viral, props));
};

function invoke_facebook_viral_with_permissions(vname, viral, props) {
    metric_event('7270_feed_post_attempted', {'method':vname});

    var link_url = 'http://apps.facebook.com/'+spin_app_namespace+'/';

    // add acquisition tracking info
    var ref_type = 'viral_' + vname;

    link_url += '?spin_ref=' + ref_type + '&spin_ref_user_id='+session.user_id.toString();

    var post_headline = viral_string_subst(viral['ui_post_headline'], props);
    var post_text = viral_string_subst(viral['ui_post_text'], props);

    var params = {'method':'feed',
                  'name': post_headline,
                  //'caption': post_text, // obsolete
                  'link': link_url,
                  'description': viral_string_subst(gamedata['virals']['ui_post_description'], props),
                  'picture': gamedata['virals']['common_image_path'] + (('image' in viral) ? viral['image'] : gamedata['virals']['default_image']),
                  'ref': 'sp_game_viral', // can't use full ref_type here, there's a 15-char limit
                  'show_error': !spin_secure_mode
                 };

    if(!spin_facebook_enabled) { console.log('FACEBOOK FEED POST: '); console.log(params); return; }

    var cb = (function (_vname) { return function(response) {
        if(!response) {
            // user cancelled
            return true;
        }
        if('post_id' in response) {
            metric_event('7271_feed_post_completed',
                         {'method': _vname,
                          'facebook_post_id':response['post_id']});
            player.record_client_history('virals_sent', 1);
            player.record_client_history('viral:'+_vname+':sent', 1);
        }
        return true;
    }; })(vname);

    SPFB.ui(params, cb); // generic viral
}

function invoke_leaderboard_brag(rank, pct, ui_reason) {
    var viral = get_facebook_viral('leaderboard_brag');
    if(!viral) { return; }
    if(!spin_facebook_enabled) { console.log('invoke_leaderboard_brag: '+ui_reason); return; }
    call_with_facebook_permissions('publish_actions', (function (_viral, _rank, _pct, _ui_reason) { return function() { invoke_leaderboard_brag_with_permissions(_viral, _rank, _pct, _ui_reason); }; })(viral, rank, pct, ui_reason));
}

function invoke_leaderboard_brag_with_permissions(viral, rank, pct, ui_reason) {
    var cb = (function () { return function(response) {
        if(!response) {
            // user cancelled
            return true;
        }
        if('post_id' in response) {
            metric_event('7230_leaderboard_brag_post_completed',
                         {'facebook_post_id':response['post_id']});
        }
        return true;
    }; })();

    metric_event('7220_leaderboard_brag_post_attempted', {});

    var ui_rank = percentile_ui_status(rank+1, pct, true);
    var link_url = 'http://apps.facebook.com/'+spin_app_namespace+'/';
    // add acquisition tracking info
    link_url += '?spin_ref=feed_leaderboard_brag&spin_ref_user_id='+session.user_id.toString();

    var props = {'method':'feed',
                 'name':viral['ui_post_headline'].replace('%PLAYER',player.facebook_name).replace('%RANK',ui_rank).replace('%REASON',ui_reason),
                 'link':link_url,
                 // needs to be permanent because it goes on FB feeds
                 'picture': gamedata['virals']['common_image_path'] + (('image' in viral) ? viral['image'] : gamedata['virals']['default_image']),
                 'ref':'leaderboard',
                 'show_error': !spin_secure_mode
                };

    // do not show "superior to 100.0%" if rank is not actually #1
    if(rank != 0) {
        pct = Math.min(pct, 0.999);
    }
    var superior_to = (100.0*pct).toFixed(1);
    // props['caption'] = viral['ui_post_text'].replace('%PCT',superior_to); // obsolete

    SPFB.ui(props, cb); // leaderboard brag
}

function invoke_facebook_message_dialog(recipient_fbid, recipient_uid) {
    var props = { 'recipient_fb_id': recipient_fbid, 'recipient_user_id': recipient_uid };
    var viral = gamedata['virals']['facebook_message'];

    var cb = (function (pp) { return function(response) {
        // unreliable, but as good as we can do
        if(response !== null) {
            metric_event('7260_facebook_message_completed', pp);
        }
    }; })(props);

    metric_event('7250_facebook_message_attempted', props);

    var link_url = 'http://apps.facebook.com/'+spin_app_namespace+'/';
    // add acquisition tracking info
    link_url += '?spin_ref=facebook_message&spin_ref_user_id='+session.user_id.toString();

    var descr_list = viral['random_text'];
    var descr = descr_list[Math.floor(Math.random()*(descr_list.length))];

    if(!spin_facebook_enabled) {
        console.log('invoke_facebook_message_dialog('+recipient_fbid+','+recipient_uid+')');
        console.log(descr);
        return;
    }

    SPFB.ui({'method':'send', // send message
             'to': recipient_fbid,
             'link': link_url,
             'name': viral['ui_post_headline'],
             'picture': gamedata['virals']['common_image_path'] + (('image' in viral) ? viral['image'] : gamedata['virals']['default_image']),
             'description': descr
            }, cb);
}

function surrender_to_ai_attack() {
    if(session.surrender_pending) { return; }
    session.surrender_pending = true;

    // change the appearance of the surrender button
    desktop_dialogs['desktop_top'].widgets['surrender_button'].state = 'attack';
    desktop_dialogs['desktop_top'].widgets['surrender_button'].str =  desktop_dialogs['desktop_top'].data['widgets']['surrender_button']['ui_name_pending'];

    // blow up the central computer and energy plants
    // (visually - the actual HP damage is done server-side, because otherwise you could just close
    // the browser window to avoid it!)

    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.team != 'player') { continue; }
        if(obj.spec['name'] == gamedata['townhall']) {
            if(!obj.is_destroyed()) {

                //hurt_object(obj, Math.floor(0.5*obj.hp), {}, null);

                // chagne HP immediately just for visual effect - will get overriden by the upcoming OBJECT_STATE_UPDATE
                obj.hp = Math.max(1, Math.floor(0.5*obj.hp));

                if('explosion_effect' in obj.spec) {
                    SPFX.add_visual_effect(obj.interpolate_pos(), 0, [0,1,0], client_time, obj.spec['explosion_effect'], true, null);
                }
            }
        }
    }


    // queue a session change after a few seconds
    window.setTimeout(visit_base_after_attack, 1000.0 * gamedata['client']['surrender_delay']);
};

function retreat_from_attack() {
    var retreat_time_table = player.get_any_abtest_value('retreat_time_table', gamedata['retreat_time_table']);
    var retreat_time = 0;

    if(session.has_deployed && session.deploy_time > 0 && retreat_time_table && player.tutorial_state == "COMPLETE" && session.viewing_user_id != session.user_id) {
        var attack_length = server_time - session.deploy_time;
        retreat_time = retreat_time_table[0][1];
        for(var i = 0; i < retreat_time_table.length; i++) {
            var entry = retreat_time_table[i];
            if(attack_length < entry[0]) {
                break;
            }
            retreat_time = entry[1];
        }
        //console.log('RETREAT attack '+attack_length.toString()+' = '+retreat_time.toString());
    }

    // cancel retreat timer if no friendly units are left
    if(retreat_time > 0) {
        var found = false;
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.team === 'player') {
                found = true;
                break;
            }
        }
        if(!found) {
            retreat_time = 0;
        }
    }

    // no retreat timer if battle outcome is decided
    if(retreat_time > 0) {
        if(calculate_battle_outcome() != 'undecided') {
            retreat_time = 0;
        }
    }

    // no retreat timer if attacking an AI and the CC is dead
    if(retreat_time > 0) {
        if(!session.home_base && session.viewing_ai && session.viewing_base.base_type === 'home') {
            var cc = find_object_by_type(gamedata['townhall']);
            if(cc && cc.team === 'enemy' && cc.hp <= 0) {
                retreat_time = 0;
            }
        }
    }

    if(retreat_time <= 0) {
        // instant retreat
        visit_base_after_attack();
        return;
    }

    if(session.retreat_pending > 0) { return; }
    session.retreat_pending = client_time + retreat_time;

    // can't do it from ondraw since the UI may go away!
    window.setTimeout(visit_base_after_attack, 1000.0*retreat_time);
}

function update_attack_button_dialog(dialog) {
    var top = desktop_dialogs['desktop_top']; // since we need to adjust some widgets on there
    var placement = (session.has_attacked ? gamedata['client']['end_attack_button_placement'] || 'top_center' : 'top_center');

    // to avoid dependency cycle, manually compute the display coordinates from raw data rather than looking at the other dialogs
    if(placement == 'top_center') {
        dialog.xy = [canvas_width/2 - gamedata['dialogs']['desktop_top_visitor']['dimensions'][0]/2 + dialog.data['top_center_offset'][0],
                     dialog.data['top_center_offset'][1]];
    } else if(placement == 'bottom_left') {
        if(!session.enable_combat_resource_bars) {
            // when tutorial quests disable resource bars, this should go away too
            dialog.widgets['attack_button'].show = false;
            return;
        }
        dialog.xy = [dialog.data['bottom_left_offset'][0],
                     canvas_height + dialog.data['bottom_left_offset'][1]];
    } else {
        throw Error('unhandled placement '+placement);
    }

    dialog.widgets['attack_button'].show = true; // XXX hide when not applicable?
    //dialog.widgets['attack_button'].xy = dialog.data['widgets']['attack_button']['xy'+(canvas_is_fullscreen ? '_fullscreen' : '')];

    if(session.has_attacked) {
        if(session.retreat_pending > 0) {
            var str;
            dialog.widgets['attack_button'].state = 'disabled';
            var time_left = session.retreat_pending - client_time;
            if(time_left >= 1.0) {
                str = gamedata['dialogs']['retreating_dialog']['widgets']['loading_text']['ui_name'].replace('%d', time_left.toFixed(0));
            } else {
                str = gamedata['dialogs']['retreating_dialog']['widgets']['loading_text']['ui_name_now'];
            }
            dialog.widgets['attack_button'].str = str;
        } else { // retreat not pending
            dialog.widgets['attack_button'].state = 'end';
            if(player.tutorial_state != "COMPLETE" && player.tutorial_state != 'wait_battle_finish2') {
                dialog.widgets['attack_button'].state = 'disabled';
            }
            dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_'+ (session.viewing_user_id == session.user_id ? 'stop_reinforcing' : 'stop_attack')];
            dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_'+ (session.viewing_user_id == session.user_id ? 'stop_reinforcing' : 'stop_attack')];
            dialog.widgets['attack_button'].onclick = retreat_from_attack;
        }

    } else { // has_attacked is FALSE

        var is_under_protection = (session.viewing_player_home_base_id === session.viewing_base.base_id &&
                                   (enemy.resource_state["protection_end_time"] > server_time ||
                                    enemy.resource_state["protection_end_time"] == 1));
        var i_am_isolated = (player.isolate_pvp && !session.viewing_isolate_pvp && !session.viewing_ai);
        var they_are_isolated = (!player.isolate_pvp && session.viewing_isolate_pvp && !session.viewing_ai);

        var nopvp_violation = null;
        if(session.viewing_user_id != session.user_id && !session.is_remote_base() && !session.viewing_ai &&
           !session.using_squad_deployment() && !session.is_ladder_battle()) {
            if(!player.is_pvp_player()) {
                nopvp_violation = 'YOU';
            } else if(!enemy.is_pvp_player()) {
                nopvp_violation = 'THEM';
            }
        }

        var ladder_violation = null;
        if(session.viewing_user_id != session.user_id && !session.is_remote_base() && !session.viewing_ai &&
           !session.using_squad_deployment()) {
            if(player.is_ladder_player()) {
                if(!enemy.is_ladder_player()) {
                    ladder_violation = 'YOU';
                } else if(!session.is_ladder_battle()) {
                    ladder_violation = 'YOU';
                }
            } else {
                if(enemy.is_ladder_player()) {
                    ladder_violation = 'THEM';
                }
            }
        }

        var map_violation = null;
        if(session.viewing_user_id != session.user_id && !session.is_remote_base() && !session.viewing_ai && !session.using_squad_deployment() && !session.is_ladder_battle()) {
            if(!enemy.is_legacy_pvp_player()) {
                if(!player.is_legacy_pvp_player()) {
                    if(session.region.data && session.region.data['id'] == session.viewing_player_home_region) {
                        map_violation = 'BOTH_SAME_REGION';
                    } else if(!session.viewing_player_home_region) {
                        map_violation = 'YOU'; // they haven't been placed yet
                    } else {
                        map_violation = 'BOTH_DIFFERENT_REGION';
                    }
                } else {
                    map_violation = 'THEM';
                }
            } else if(!player.is_legacy_pvp_player()) {
                map_violation = 'YOU';
            }
        }

        var is_sandstorm = 0, is_sandstorm_max = false;
        for(var i = 0; i < player.player_auras.length; i++) {
            var code = gamedata['auras'][player.player_auras[i]['spec']]['code'];
            if(code == 'sandstorm_max') {
                is_sandstorm_max = true;
                break;
            } else if(code == 'sandstorm') {
                is_sandstorm = player.player_auras[i]['strength'] || 1;
                break;
            }
        }

        var limit_quarry_control = !(session.region.data && ('limit_quarry_control' in session.region.data) && !session.region.data['limit_quarry_control']);

        if(0 && session.viewing_base.base_type == 'quarry' && session.viewing_base.base_landlord_id == session.user_id) {
            // friendly quarry
            var togo = Math.max(player.cooldown_togo('quarry_collect'), player.cooldown_togo('quarry_collect_'+session.viewing_base.base_id));

            dialog.widgets['attack_button'].state = (togo > 0 ? 'disabled' : 'attack');
            dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_collect' + (togo > 0 ? '_cooldown' : '')].replace('%s', pretty_print_time_brief(togo));
            dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_collect' + (togo > 0 ? '_cooldown' : '')];
            dialog.widgets['attack_button'].onclick = function() {
                send_to_server.func(["QUARRY_COLLECT", session.viewing_base.base_id, true]);
            };

        } else if(is_under_protection ||
                  (session.pvp_balance === 'player') ||
                  (session.pvp_balance === 'enemy_strict') ||
                  (session.pvp_balance === 'same_alliance') ||
                  (session.viewing_lock_state != 0 && session.viewing_base.base_landlord_id != session.user_id) ||
                  (session.count_deployable_units() < 1 && (session.viewing_base.base_landlord_id != session.user_id || !session.region.data || session.region.data['storage'] != 'nosql')) ||
                  session.repeat_attack_cooldown_expire > server_time ||
                  i_am_isolated || they_are_isolated || is_sandstorm_max || nopvp_violation || ladder_violation || map_violation ||
                  (session.is_alt_account && gamedata['prevent_alt_attacks']) ||
                  (session.viewing_base.base_type == 'quarry' && session.viewing_base.base_landlord_id != session.user_id && limit_quarry_control && session.region.num_quarries_owned() >= player.stattab['quarry_control_limit'])) {
            // unable to attack
            dialog.widgets['attack_button'].state = 'disabled';
            dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name'];
            dialog.widgets['attack_button'].onclick = null;

            if(i_am_isolated) {
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_you_are_isolated'];
            } else if(they_are_isolated) {
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_they_are_isolated'];
            } else if(session.is_alt_account && gamedata['prevent_alt_attacks']) {
                dialog.widgets['attack_button'].tooltip.str = gamedata['errors']['CANNOT_ATTACK_ALT_ACCOUNT']['ui_name'];
            } else if(nopvp_violation) {
                top.widgets['violation_message'].show = true;
                //var ui_req = read_predicate({'predicate':'LIBRARY', 'name':'pvp_requirement'}).ui_describe(player);
                var ui_req = gamedata['predicate_library']['pvp_requirement']['ui_name'];
                top.widgets['violation_message'].str = gamedata['errors']['CANNOT_ATTACK_NOPVP_'+nopvp_violation]['ui_name'];
                if(ui_req) { top.widgets['violation_message'].str += '\n'+gamedata['strings']['unmet_requirements'].replace('%s', ui_req); }
                dialog.widgets['attack_button'].tooltip.str = gamedata['errors']['CANNOT_ATTACK_NOPVP_'+nopvp_violation]['ui_name'];
            } else if(ladder_violation) {
                top.widgets['violation_message'].show = true;
                top.widgets['violation_message'].str = gamedata['errors']['CANNOT_ATTACK_LADDER_'+ladder_violation]['ui_instructions'];
                dialog.widgets['attack_button'].tooltip.str = gamedata['errors']['CANNOT_ATTACK_LADDER_'+ladder_violation]['ui_name'];
                // for games with no regions, don't even show the attack button here (not sure if this is right - check gamedata['ladder_pvp']?)
                if(goog.object.getCount(gamedata['regions']) < 1) {
                    top.widgets['violation_message'].show = false;
                    dialog.widgets['attack_button'].show = false;
                }
            } else if(map_violation) {
                top.widgets['violation_message'].show = true;
                var viewing_region = (session.viewing_player_home_region && session.viewing_player_home_region in gamedata['regions'] ? gamedata['regions'][session.viewing_player_home_region]['ui_name'] : gamedata['strings']['regional_map']['unknown_name']);
                var xs = '', ys = '';
                if(session.viewing_base.base_map_loc) { xs = session.viewing_base.base_map_loc[0].toString(); ys = session.viewing_base.base_map_loc[1].toString(); }
                top.widgets['violation_message'].str = gamedata['errors']['CANNOT_ATTACK_MAP_'+map_violation]['ui_instructions'].replace('%VIEWING_REGION', viewing_region).replace('%X',xs).replace('%Y',ys).replace('%TOWNHALL',gamedata['buildings'][gamedata['townhall']]['ui_name']);
                dialog.widgets['attack_button'].tooltip.str = gamedata['errors']['CANNOT_ATTACK_MAP_'+map_violation]['ui_name'];
                // for games with no regions, don't even show the attack button here (not sure if this is right - check gamedata['ladder_pvp']?)
                if(goog.object.getCount(gamedata['regions']) < 1) {
                    top.widgets['violation_message'].show = false;
                    dialog.widgets['attack_button'].show = false;
                }
            } else if(is_sandstorm_max) {
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['sandstorm_max_message']['ui_name'];
                top.widgets['sandstorm_max_message'].show = true;
                if(session.viewing_base.base_last_attack_time > 0) {
                    top.widgets['protection_defended'].show = true;
                    top.widgets['protection_defended'].str = top.widgets['protection_defended'].data['ui_name'].replace('%s', pretty_print_time_brief(server_time - session.viewing_base.base_last_attack_time));
                }
            } else if(session.pvp_balance === 'player') {
                dialog.widgets['attack_button'].state = 'looks_disabled';
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_lowlevel_rival'];
                dialog.widgets['attack_button'].onclick = invoke_attack_weaker_message;
                top.widgets['weaker_message'].show = true;
                if(session.viewing_base.base_last_attack_time > 0) {
                    top.widgets['protection_defended'].show = true;
                    top.widgets['protection_defended'].str = top.widgets['protection_defended'].data['ui_name'].replace('%s', pretty_print_time_brief(server_time - session.viewing_base.base_last_attack_time));
                }
            } else if(session.pvp_balance === 'enemy_strict') {
                dialog.widgets['attack_button'].state = 'looks_disabled';
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_highlevel_rival'];
                dialog.widgets['attack_button'].onclick = invoke_attack_stronger_strict_message;
                top.widgets['stronger_message'].show = true;
                if(session.viewing_base.base_last_attack_time > 0) {
                    top.widgets['protection_defended'].show = true;
                    top.widgets['protection_defended'].str = top.widgets['protection_defended'].data['ui_name'].replace('%s', pretty_print_time_brief(server_time - session.viewing_base.base_last_attack_time));
                }
            } else if(session.pvp_balance === 'same_alliance') {
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_same_alliance'];
            } else if((session.viewing_lock_state != 0 && session.viewing_base.base_landlord_id != session.user_id) || is_under_protection) {
                var str;
                if(session.is_remote_base()) {
                    str = dialog.data['widgets']['attack_button']['ui_tooltip_base_locked'];
                } else {
                    // not actually accurate since lock_state==2 implies under attack, but don't tell players that
                    str = dialog.data['widgets']['attack_button']['ui_tooltip_home_protection'];
                    top.widgets['protection_message'].show = true;
                    if(session.viewing_base.base_last_attack_time > 0) {
                        top.widgets['protection_defended'].show = true;
                        top.widgets['protection_defended'].str = top.widgets['protection_defended'].data['ui_name'].replace('%s', pretty_print_time_brief(server_time - session.viewing_base.base_last_attack_time));
                    }
                }
                dialog.widgets['attack_button'].tooltip.str = str;
            } else if(is_under_protection) {
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_protection'];
            } else if(session.count_deployable_units() < 1 && (session.viewing_base.base_landlord_id != session.user_id || !session.region.data || session.region.data['storage'] != 'nosql')) {
                if(session.deployable_squads.length < 1) {
                    if(session.viewing_base.base_landlord_id == session.user_id) {
                        // friendly base - no attack button
                        dialog.widgets['attack_button'].show = false;
                    } else {
                        // shouldn't get here - enemy base but no squad within range
                        dialog.widgets['attack_button'].show = false;
                    }
                } else if(!player.has_any_units()) {
                    dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_no_units'].replace('%MENU', gamedata['dialogs']['desktop_bottom']['widgets']['robots_button']['ui_name']).replace('%VERB', gamedata['spells']['MAKE_DROIDS']['ui_name'].toLowerCase());
                } else {
                    dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_no_units_for_climate'].replace('%name',session.viewing_base.base_climate_data['ui_name']).replace('%descr',session.viewing_base.describe_climate_unit_restrictions());
                }
            } else if(session.repeat_attack_cooldown_expire > server_time) {
                dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_cooldown'].replace('%s', pretty_print_time_brief(session.repeat_attack_cooldown_expire-server_time));
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_cooldown'];
            } else if(session.viewing_base.base_type == 'quarry' && session.viewing_base.base_landlord_id != session.user_id && limit_quarry_control && session.region.num_quarries_owned() >= player.stattab['quarry_control_limit']) {
                var can_improve = get_next_level_with_stat_increase(gamedata['buildings'][gamedata['region_map_building']], 'provides_quarry_control', player.history[gamedata['region_map_building']+'_level']||1) > 0;
                top.widgets['violation_message'].show = true;
                top.widgets['violation_message'].str = gamedata['errors'][can_improve ? 'CANNOT_ATTACK_QUARRY_LIMIT_REACHED' : 'CANNOT_ATTACK_QUARRY_MAX_LIMIT_REACHED']['ui_name'];
                dialog.widgets['attack_button'].tooltip.str = top.widgets['violation_message'].str;
            }

        } else { // you CAN attack - no reason to prevent an attack right now
            if(!session.using_squad_deployment() &&
               session.is_remote_base() &&
               !player.travel_satisfied(session.viewing_base.base_map_loc)) {

                if(player.travel_state['dest_loc'] && vec_equals(player.travel_state['dest_loc'], session.viewing_base.base_map_loc)) {
                    // on the way
                    var to_go = player.travel_state['end_time'] - server_time;
                    var str_to_go = pretty_print_time_brief(to_go);
                    dialog.widgets['attack_button'].state = 'disabled';
                    dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_reinforce_pending'].replace('%s',str_to_go);
                    dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_reinforce_pending'].replace('%s',str_to_go);
                    dialog.widgets['attack_button'].onclick = function() { send_to_server.func(["TRAVEL_BEGIN", session.viewing_base.base_map_loc,
                                                                                                player.travel_time_to(session.viewing_base.base_map_loc)]); };
                } else {
                    // not on the way
                    dialog.widgets['attack_button'].state = 'end';
                    dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_reinforce'].replace('%s',pretty_print_time_brief(player.travel_time_to(session.viewing_base.base_map_loc)));
                    dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_reinforce'];
                    dialog.widgets['attack_button'].onclick = function() { send_to_server.func(["TRAVEL_BEGIN", session.viewing_base.base_map_loc,
                                                                                                player.travel_time_to(session.viewing_base.base_map_loc)]); };
                }
            } else if(session.using_squad_deployment() && (session.viewing_user_id == session.user_id)) {
                // disable reinforcement option when squad-spying on friendly stuff
                dialog.widgets['attack_button'].show = false;
            } else {
                dialog.widgets['attack_button'].state = (session.viewing_user_id == session.user_id ? 'end' : 'attack');
                dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name'+(session.viewing_user_id == session.user_id ? '_reinforce_now' : '')];
                dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip'+(session.viewing_user_id == session.user_id ? '_reinforce_now' : '')];

                if(session.is_ladder_battle() && !session.using_squad_deployment()) {
                    dialog.widgets['attack_button'].state = 'attack_once';
                    dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_attack_ladder'];
                    dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_attack_ladder'].replace('%s', gamedata['events']['challenge_pvp_ladder']['ui_name']);

                } else if((session.viewing_user_id != session.user_id) &&
                          !session.viewing_ai &&
                          !session.is_remote_base() &&
                          (!in_attackable_level_range(player.level(), enemy.resource_state['player_level'], player.is_ladder_player() ? 'ladder' : 'default')) &&
                          player.cooldown_active('revenge_defender:'+session.viewing_user_id.toString()) &&
                          session.region.pvp_level_gap_enabled() &&
                          (player.is_ladder_player() || player.is_legacy_pvp_player()) &&
                          !session.is_ladder_battle()) {
                    dialog.widgets['attack_button'].state = 'attack_once';
                    dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_attack_revenge'];
                    dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_attack_revenge'];
                } else if(session.viewing_ai && session.viewing_base.base_type == 'home') {
                    var base = gamedata['ai_bases_client']['bases'][session.viewing_user_id.toString()];
                    if(base && ('persistent' in base) && !base['persistent']) {
                        dialog.widgets['attack_button'].state = 'attack_once';
                        dialog.widgets['attack_button'].str = dialog.data['widgets']['attack_button']['ui_name_attack_hitlist'];
                        dialog.widgets['attack_button'].tooltip.str = dialog.data['widgets']['attack_button']['ui_tooltip_attack_hitlist'];
                    }
                }

                var attack_cb = function() {
                    session.has_attacked = true;
                    player.quest_tracked_dirty = true;

                    if(player.tutorial_state === 'click_attack') { advance_tutorial(); }

                    // send an empty deployment request to get the write lock
                    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "DEPLOY_UNITS", [0,0], {}]);

                    // turn on combat item bar
                    if(!session.home_base) {
                        init_combat_item_bar();
                    }

                    // automatically pan to centroid of polygonal deployment zone
                    if(session.viewing_base.has_deployment_zone()) {
                        var centroid = session.viewing_base.deployment_zone_centroid();
                        if(centroid) {
                            force_scroll(null, centroid, "on_attack");
                        }
                    }

                    // set up deployment cursor AFTER ui_locker goes away
                    // for tutorial, hold off until all units are readied for deployment
                    var setup_deployment_cursor = function() {
                        if(player.tutorial_state != "COMPLETE" && gamedata['tutorial'][player.tutorial_state]['next'] != 'place_robots_message') {
                        } else if(selection.spellname != "DEPLOY_UNITS") {
                            change_selection(player.virtual_units["DEPLOYER"]);
                            selection.spellname = "DEPLOY_UNITS";
                            var cursor = new DeployUICursor();
                            change_selection_ui_under(cursor);
                        }
                    };
                    invoke_ui_locker(null, setup_deployment_cursor);
                };

                if(is_sandstorm) {
                    top.widgets['sandstorm_message'].show = true;
                    top.widgets['sandstorm_message'].str = top.data['widgets']['sandstorm_message']['ui_name'].replace('%pct', (is_sandstorm*100.0).toFixed(0));
                }

                dialog.widgets['attack_button'].onclick = (function (cb) { return function() {
                    if(session.is_ladder_battle()) {
                        if(player.resource_state['protection_end_time'] > server_time) {
                            invoke_attack_through_protection_message(cb);
                        } else {
                            cb();
                        }
                    } else if(session.pvp_balance === 'player') {
                        // warn player that he is not allowed to prey on a weak enemy
                        invoke_attack_weaker_message();
                    } else if(session.pvp_balance === 'enemy_strict') {
                        // warn player that he is not allowed to touch a strong enemy
                        invoke_attack_stronger_strict_message();
                    } else if(session.pvp_balance === 'enemy') {
                        // warn player that he's about to attack a strong enemy, who can retaliate
                        invoke_attack_stronger_message(cb);
                    } else if(player.resource_state['protection_end_time'] > server_time &&
                              session.viewing_user_id != session.user_id &&
                              !session.viewing_ai &&
                              (!session.is_squad() || gamedata['territory']['squads_affect_protection']) &&
                              (!session.is_quarry() || gamedata['territory']['quarries_affect_protection'])) {
                        // warn player that attacking another human will disable your own protection timer
                        invoke_attack_through_protection_message(cb);
                    } else if(session.viewing_friend != null &&
                              !session.viewing_friend.is_ai() &&
                              session.viewing_friend.is_real_friend &&
                              session.viewing_user_id != session.user_id &&
                              session.viewing_base.base_type == 'home' &&
                              session.viewing_friend.battle_count < 1) {
                        // warn player about to attack a Facebook friend for the first time
                        invoke_attack_friend_message(cb);
                    } else if(session.viewing_user_id == session.user_id) {
                        // warn player that donated units are given permanently
                        invoke_attack_reinforce_message(cb);
                    } else if((session.viewing_user_id != session.user_id) &&
                              !session.viewing_ai &&
                              (!in_attackable_level_range(player.level(), enemy.resource_state['player_level'], player.is_ladder_player() ? 'ladder' : 'default')) &&
                              player.cooldown_active('revenge_defender:'+session.viewing_user_id.toString()) &&
                              session.region.pvp_level_gap_enabled() &&
                              (player.is_ladder_player() || player.is_legacy_pvp_player()) &&
                              !session.is_ladder_battle() &&
                              !session.using_squad_deployment() &&
                              !session.is_remote_base() &&
                              ('attack_revenge_lower_level_message' in gamedata['dialogs'])) {
                        // warn player that revenge is once-only now
                        invoke_attack_revenge_lower_level_message(cb);
                    } else {
                        // just do the attack
                        cb();
                    }
                }; })(attack_cb);
            } // attack_button is clickable with callback
        } // END you CAN attack
    } // END session.has_attacked is FALSE

}

function update_retreating_dialog(dialog) {
    var str;
    if(session.retreat_pending < 0 || client_time >= session.retreat_pending) {
        str = dialog.data['widgets']['loading_text']['ui_name_now'];
    } else {
        var time_left = session.retreat_pending - client_time;
        if(time_left >= 1.0) {
            str = dialog.data['widgets']['loading_text']['ui_name'].replace('%d', time_left.toFixed(0));
        } else {
            str = dialog.data['widgets']['loading_text']['ui_name_now'];
        }
    }
    dialog.widgets['loading_text'].str = str;
}

function invoke_defense_end_dialog(battle_type, battle_base, battle_opponent_user_id, battle_opponent_fbid, battle_opponent_level, battle_opponent_friend,
                                  battle_opponent_name,
                                   outcome, loot, battle_summary, ladder_state) {
    if(outcome == 'victory' &&
       player.get_any_abtest_value('fancy_victory_dialog', gamedata['client']['fancy_victory_dialog'])) {
        return invoke_fancy_victory_dialog(battle_type, battle_base, battle_opponent_user_id, battle_opponent_fbid, battle_opponent_level, battle_opponent_friend,
                                           battle_opponent_name,
                                           outcome, loot, battle_summary, ladder_state);
    }

    change_selection(null);

    var dialog_data = gamedata['dialogs']['defense_end_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'defense_end_dialog';

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    if(outcome != 'defeat') {
        outcome = 'victory';
    }

    dialog.widgets['title_'+outcome].show =
        dialog.widgets['subtitle_'+outcome].show = true;
    dialog.widgets['subtitle_'+outcome].str = dialog_data['widgets']['subtitle_'+outcome]['ui_name'].replace('%s', battle_opponent_name);

    // calculate statistics
    var base_damage = calc_base_damage({count_partial:true});
    dialog.widgets['base_damage'].str = Math.floor(100*base_damage).toFixed(0) + '%';

    var gained_xp = loot['xp'] || 0;
    if(player.get_any_abtest_value('show_xp_gains', gamedata['client']['show_xp_gains'])) {
        dialog.widgets['xp_amount'].str = pretty_print_number(gained_xp);
    } else {
        dialog.widgets['you_gained'].show =
            dialog.widgets['xp_amount'].show =
            dialog.widgets['xp_icon'].show = false;
    }

    dialog.widgets['units_destroyed'].str = get_loot_kills_list(loot, '\n', 5);
    for(var res in gamedata['resources']) {
        var lost = loot[res] || 0;
        if(res+'_amount' in dialog.widgets) {
            dialog.widgets[res+'_amount'].show = dialog.widgets[res+'_icon'].show = true;
            dialog.widgets[res+'_icon'].asset = gamedata['resources'][res]['icon_small'];
            dialog.widgets[res+'_amount'].str = pretty_print_number(lost);
        }
    }
    init_dialog_repair_buttons(dialog, base_damage);
};

// tutorial UI elements don't use selection.ui because we need to
// ensure that they don't get closed accidentally
var tutorial_root = new SPUI.Container();
tutorial_root.xy = [0,0]; tutorial_root.wh = [99999,99999];
tutorial_root.transparent_to_mouse = true;
var tutorial_ui = null;
var tutorial_nonmodal_ui = null;

function tutorial_step(clear_nonmodal_ui) {
    if(tutorial_ui && tutorial_ui.parent) {
        tutorial_root.remove(tutorial_ui);
        tutorial_ui = null;
    }

    if(clear_nonmodal_ui) {
        if(tutorial_nonmodal_ui && tutorial_nonmodal_ui.parent) {
            tutorial_root.remove(tutorial_nonmodal_ui);
            tutorial_nonmodal_ui = null;
        }
    }

    console.log('Tutorial step '+player.tutorial_state);

    if(gamedata['client']['instrument_tutorial'] ||
       goog.array.contains(["COMPLETE","congratulations_message"], player.tutorial_state)) {
        send_to_server.func(["TUTORIAL_STATE_UPDATE", player.tutorial_state]);
    }

    if(player.tutorial_state === "COMPLETE") {
        global_chat_frame.show = true;
        return;
    }

    if(!(player.tutorial_state in gamedata['tutorial'])) {
        throw Error('invalid tutorial state '+player.tutorial_state);
    }
    var data = gamedata['tutorial'][player.tutorial_state];

    if('metric' in data) {
        var metric = data['metric'];
        metric_event(metric, {'sum': player.get_denormalized_summary_props('brief')});
    }

    if('force_scroll' in data) {
        var obj_type = (typeof(data['force_scroll'])=="string" ? data['force_scroll'] : null);
        var pos = (obj_type ? null : data['force_scroll']);
        force_scroll(obj_type, pos, player.tutorial_state);
    }

    if(data['kind'] === 'slideshow') {
        tutorial_step_slideshow(data);
    } else if(data['kind'] === 'valentina_help_message') {
        tutorial_step_valentina_help_message(data);
    } else if(data['kind'] === 'valentina_nonmodal_message') {
        tutorial_step_valentina_nonmodal_message(data);
    } else if(data['kind'] === 'click_on_rover_action') {
        make_tutorial_arrow_for_landscape(data['unit_type'], null, 'down');
    } else if(data['kind'] === 'move_rover_action') {
        make_tutorial_arrow_for_landscape(null, gamedata['tutorial']['move_rover_action']['coords'], 'down');
    } else if(data['kind'] === 'wait_for_battle_finish') {
        // no UI
    } else if(data['kind'] === 'repair_message') {
        tutorial_step_repair_message(data);
    } else if(data['kind'] === 'wait_for_repairs') {
        // no UI
    } else if(data['kind'] === 'open_buildings_dialog') {
        var arrow = make_tutorial_arrow_for_button('desktop_bottom', 'buildings_button', 'down');
        arrow.user_data['wave_amplitude'] = gamedata['tutorial']['open_buildings_dialog']['arrow_wave_amplitude'] || 25;
        arrow.user_data['scroll_down_hack'] = !!gamedata['tutorial']['open_buildings_dialog']['scroll_down_hack'];
    } else if(data['kind'] === 'go_to_defense_tab') {
        make_tutorial_arrow_for_button('build_dialog', 'defense_button', gamedata['tutorial']['go_to_defense_tab']['arrow_direction'] || 'down');
    } else if(data['kind'] === 'choose_defensive_cannon') {
        make_tutorial_arrow_for_button('build_dialog', 'grid1,0', 'down');
    } else if(data['kind'] === 'place_defensive_cannon') {
        make_tutorial_arrow_for_landscape(null, data['location'], 'down');
    } else if(data['kind'] === 'speedup_open_context_menu') {
        make_tutorial_arrow_for_landscape(data['target'], null, 'up');
    } else if(data['kind'] === 'speedup_open_speedup_menu') {
        make_tutorial_arrow_for_button('context_menu', 'button0', 'up');
    } else if(data['kind'] === 'speedup_click_finish') {
        make_tutorial_arrow_for_button('speedup_dialog', 'ok_button', 'down');
    } else if(data['kind'] === 'defensive_cannon_complete') {
        // no UI
    } else if(data['kind'] === 'ai_attack') {
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "TUTORIAL_AI_ATTACK"]);
        //player.tutorial_state = data['next'];
    } else if(data['kind'] === 'ai_attack_end') {
        make_tutorial_arrow_for_button('ai_attack_finish_dialog', 'ok_button', 'up');
    } else if(data['kind'] === 'open_map_dialog') {
        make_tutorial_arrow_for_button('desktop_bottom', 'map_button', 'down');
    } else if(data['kind'] === 'spy_on_ai') {
        make_tutorial_arrow_for_button('map_dialog', 'row_button0', 'down');
    } else if(data['kind'] === 'click_attack') {
        make_tutorial_arrow_for_button('attack_button_dialog', 'attack_button', 'up');
    } else if(data['kind'] === 'deploy_robots_action') {
        make_tutorial_arrow_for_button('desktop_bottom', data['button'], 'down'); // this really gets desktop_bottom_visitor
    } else if(data['kind'] === 'place_robots_action') {
        make_tutorial_arrow_for_landscape(null, gamedata['tutorial']['place_robots_action']['coords'], 'down');
    } else if(data['kind'] === 'wait_battle_finish2') {
        // no UI
    } else if(data['kind'] === 'battle_end_message') {
        make_tutorial_arrow_for_button('battle_dialog', 'ok_button', 'down');
    } else if(data['kind'] === 'congratulations_message') {
        tutorial_step_congratulations(data);
    } else if(data['kind'] === 'invite_friends') {
        tutorial_step_invite_friends(data);
    } else if(data['kind'] === 'open_missions_dialog') {
        make_tutorial_arrow_for_button('desktop_bottom', 'missions_button', 'down');
    } else if(data['kind'] === 'null') {
    } else {
        throw Error('unhandled tutorial kind '+data['kind']);
    }
}

function advance_tutorial() {
    player.tutorial_state = gamedata['tutorial'][player.tutorial_state]['next'];
    tutorial_step(true);
}

function tutorial_step_slideshow(data) {
    var dialog_data = gamedata['dialogs']['tutorial_slideshow_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'tutorial_slideshow_dialog';
    tutorial_ui = dialog;
    tutorial_root.add(dialog);

    dialog.auto_center();

    dialog.widgets['image'].asset = data['asset'];
    dialog.widgets['description'].str = data['ui_description'];

    dialog.widgets['next_button'].onclick = (function (next) { return function() {
        player.tutorial_state = next;
        tutorial_step(true);
    }; })(data['next']);

    if(!spin_secure_mode && player.is_developer()) {
        // developer-mode-only button that skips the entire tutorial
        dialog.widgets['skip_button'].onclick = function() {
            var s = gamedata['strings']['dev_skip_rails_tutorial_confirm'];
            player.tutorial_state = "COMPLETE";
            tutorial_root.clear();
            invoke_child_message_dialog(s['ui_title'], s['ui_description'],
                                        {'dialog': 'message_dialog_big',
                                         'ok_button_ui_name': s['ui_button'],
                                         'on_ok': function() {
                                             destroy_all_enemies();
                                             init_desktop_dialogs();
                                             tutorial_step(true);
                                             player.quest_tracked_dirty = true;
                                         }});
        };
    } else {
        dialog.widgets['skip_button'].show = false;
    }

    if(data['next_button_arrow']) {
        var dir = 'down';
        var arrow = make_ui_arrow(dir);
        dialog.add(arrow);
        arrow.ondraw = update_tutorial_arrow_for_button(arrow, 'tutorial_slideshow_dialog', 'next_button', dir);
    }
}

function destroy_all_enemies() {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.team === 'enemy' && !obj.is_destroyed()) {
            if(obj.is_mobile()) {
                send_and_destroy_object(obj, null);
            } else if(obj.is_building()) {
                obj.hp = 0;
                obj.state_dirty |= obj_state_flags.HP;
            }
        }
    }
    flush_dirty_objects({});
}

function tutorial_step_valentina_help_message(data) {
    var dialog_data = gamedata['dialogs']['tutorial_valentina_help_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'tutorial_valentina_help_message';
    tutorial_ui = dialog;
    tutorial_root.add(dialog);

    dialog.auto_center();

    dialog.widgets['title'].str = data['ui_name'];
    dialog.widgets['description'].str = data['ui_description'];
    dialog.widgets['ok_button'].str = data['ui_button'];

    dialog.widgets['ok_button'].onclick = (function (next) { return function() {
        // switch to combat music (use "recon" if "combat" not available)
        change_backdrop_music(GameArt.assets['background_music'].states[(GameArt.assets['background_music'].has_state('combat') ? 'combat' : 'recon')].audio);
        player.tutorial_state = next;
        tutorial_step(true);
    }; })(data['next']);

    if(data['ok_button_arrow']) {
        var dir = 'up';
        var arrow = make_ui_arrow(dir);
        dialog.add(arrow);
        arrow.ondraw = update_tutorial_arrow_for_button(arrow, 'tutorial_valentina_help_message', 'ok_button', dir);
    }
}

function update_valentina_nonmodal_message(dialog) {
    if(dialog.user_data['show_if']) {
        dialog.show = dialog.user_data['show_if'].is_satisfied(player, null);
    }

    // put in top third of screen
    dialog.xy = [Math.floor(canvas_width/2 - dialog.data['dimensions'][0]/2),
                 Math.floor(dialog.user_data['y_position']*canvas_height)];
    if(dialog.parent) { // might be ok to do this unconditionally
        dialog.xy = vec_sub(dialog.xy, dialog.parent.get_absolute_xy());
    }

    // make sure dialog does not actually go off screen
    var corner = dialog.get_absolute_xy();
    if(corner[1] < 0) {
        dialog.xy[1] += -corner[1];
    } else if(corner[1] + dialog.wh[1] >= canvas_height) {
        dialog.xy[1] -= (corner[1]+dialog.wh[1])-canvas_height;
    }

    goog.array.forEach(['enemy', 'player'], function(team) {
        goog.array.forEach(['rovers', 'townhall'], function(kind) {
            if(dialog.user_data[team+'_'+kind] ||
               (dialog.user_data['boxes'] && dialog.user_data['boxes'][team+'_'+kind])) {
                var ui_text, box_color, grid_pad = 1, opacity = 0.25;
                if(dialog.user_data['boxes']) {
                    ui_text = dialog.user_data['boxes'][team+'_'+kind]['ui_name'];
                    box_color = dialog.user_data['boxes'][team+'_'+kind]['color'];
                    grid_pad = (dialog.user_data['boxes'][team+'_'+kind]['grid_pad'] || 1);
                    if('opacity' in dialog.user_data['boxes'][team+'_'+kind]) {
                        opacity = dialog.user_data['boxes'][team+'_'+kind]['opacity'];
                    }
                } else {
                    ui_text = gamedata['tutorial']['click_on_rover_message'][team+'_'+kind+'_ui_name'];
                    box_color = gamedata['tutorial']['click_on_rover_message'][team+'_'+kind+'_color'] || 'rgba(60,255,150,';
                    if(team+'_'+kind+'_opacity' in gamedata['tutorial']['click_on_rover_message']) {
                        opacity = gamedata['tutorial']['click_on_rover_message'][team+'_'+kind+'_opacity'];
                    }
                }

                // draw transparent highlight box around enemy or friendly units
                var bounds = null;
                for(var id in session.cur_objects.objects) {
                    var obj = session.cur_objects.objects[id];
                    if(obj.team == team &&
                       ((kind=='rovers' && obj.is_mobile()) ||
                        (kind=='townhall' && obj.spec['name'] == gamedata['townhall']))) {

                        var points = [];
                        if(obj.is_building()) {
                            var gs = obj.spec['gridsize'];
                            goog.array.forEach([[-gs[0]/2,-gs[1]/2], // NW
                                                [gs[0]/2,-gs[1]/2], // NE
                                                [gs[0]/2,gs[1]/2], // SE
                                                [-gs[0]/2,gs[1]/2]], // SW
                                               function(offset) {
                                                   points.push(ortho_to_draw(vec_add(vec_scale(grid_pad, offset), obj.interpolate_pos())));
                                               });
                        } else {
                            points.push(ortho_to_draw(obj.interpolate_pos())); // center point
                        }

                        goog.array.forEach(points, function(xy) {
                            var pad = 25;
                            if(bounds === null) {
                                bounds = [[xy[0],xy[0]],[xy[1],xy[1]]];
                            } else {
                                bounds[0][0] = Math.min(bounds[0][0], xy[0]-pad);
                                bounds[0][1] = Math.max(bounds[0][1], xy[0]+pad);
                                bounds[1][0] = Math.min(bounds[1][0], xy[1]-pad);
                                bounds[1][1] = Math.max(bounds[1][1], xy[1]+pad);
                            }
                        });
                    }
                }

                if(bounds) {
                    var pad = 15;
                    bounds[0][0] -= pad; bounds[1][0] -= pad;
                    bounds[0][1] += pad; bounds[1][1] += pad;
                    bounds[0][0] -= 20; // addl left pad
                    bounds[1][0] -= 40; // addl top pad
                    bounds[0][1] += 30; // addl right pad

                    ctx.save();
                    set_playfield_draw_transform(ctx);
                    var c = box_color;
                    ctx.strokeStyle = c+(1-(1-opacity)*(1-opacity)).toString()+')';
                    ctx.fillStyle = c+opacity.toString()+')';
                    ctx.fillRect(Math.floor(bounds[0][0]), Math.floor(bounds[1][0]),
                                 Math.floor(bounds[0][1]-bounds[0][0]),
                                 Math.floor(bounds[1][1]-bounds[1][0]));
                    ctx.strokeRect(Math.floor(bounds[0][0]), Math.floor(bounds[1][0]),
                                   Math.floor(bounds[0][1]-bounds[0][0]),
                                   Math.floor(bounds[1][1]-bounds[1][0]));
                    if(ui_text) {
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText(ui_text, bounds[0][0]+pad, bounds[1][1]-pad);
                    }
                    ctx.restore();
                }
            }
        });
    });

    if(dialog.user_data['black_bar']) {
        // draw horizontal black bar behind Valentina dialog
        if(typeof dialog.user_data['black_bar'] == 'object') {
            var bar = dialog.user_data['black_bar'];
            if(bar['top']) {
                var h = Math.floor(bar['top']*canvas_height);
                dialog.widgets['black_bar_top'].show = true;
                dialog.widgets['black_bar_top'].xy = vec_scale(-1, dialog.get_absolute_xy());
                dialog.widgets['black_bar_top'].wh = [canvas_width, h];
                //ctx.fillRect(0, 0, canvas_width, h);
            }
            if(bar['bottom']) {
                var h = Math.floor(bar['bottom']*canvas_height);
                //ctx.fillRect(0, canvas_height - h, canvas_width, h);
                dialog.widgets['black_bar_bottom'].show = true;
                dialog.widgets['black_bar_bottom'].xy = vec_add([0, canvas_height-h], vec_scale(-1, dialog.get_absolute_xy()));
                dialog.widgets['black_bar_bottom'].wh = [canvas_width, h];
            }

        } else {
            ctx.save();
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas_width, dialog.xy[1] + dialog.wh[1] + 7);
            ctx.restore();
        }
    }
};

function tutorial_step_valentina_nonmodal_message(data) {
    var dialog_data = gamedata['dialogs']['tutorial_valentina_nonmodal_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    tutorial_nonmodal_ui = dialog;
    tutorial_root.add(dialog);

    dialog.ondraw = update_valentina_nonmodal_message;
    dialog.widgets['description'].str = eval_cond_or_literal(data['ui_description'], player, null);
    dialog.user_data['y_position'] = data['y_position'] || 0.3;
    dialog.user_data['black_bar'] = data['black_bar'] || false;
    dialog.user_data['enemy_rovers'] = data['enemy_rovers'] || false;
    dialog.user_data['player_rovers'] = data['player_rovers'] || false;
    if(data['bg_emphasis']) {
        dialog.widgets['bg'].widgets['bg'].asset = dialog.widgets['bg'].data['widgets']['bg']['asset_emphasis'];
    }
    if(dialog.user_data['enemy_rovers']) { session.has_attacked = true; }
    dialog.user_data['boxes'] = data['boxes'] || null;

    dialog.user_data['show_if'] = data['show_if'] ? read_predicate(data['show_if']) : null;

    // immediately proceed to next step, but don't clear the UI
    player.tutorial_state = data['next'];
    tutorial_step(false);
}

// maintain a tutorial arrow pointing to a button on a specific UI dialog
function update_tutorial_arrow_for_button(_dialog, _parent_path, _widget_name, _direction) {
    return (function (dialog, parent_path, widget_name, direction) { return function() {
        var parent = null;
        var parent_offset = [0,0];
        var found_widget_name = widget_name;

        if(parent_path.indexOf("desktop_") === 0 || parent_path == 'attack_button_dialog') {
            // pick desktop dialog directly
            parent = desktop_dialogs[parent_path] || null;

            // handle entries in desktop_dialogs that are nested below other dialogs
            if(parent && parent.parent && parent.parent !== SPUI.root) {
                parent_offset = vec_add(parent_offset, parent.parent.get_absolute_xy());
            }

        } else if(parent_path.indexOf("_dialog") != -1 ||
                  parent_path.indexOf("context_menu") != -1 ||
                  parent_path.indexOf("tutorial") != -1) {

            // search for parent dialog by name
            var roots = [selection.ui, tutorial_root];

            for(var i = 0; i < roots.length && !parent; i++) {
                parent_offset = [0,0]; // reset offset
                var p = roots[i];

                while(p) {
                    if(p.user_data && ('dialog' in p.user_data) && match_dialog_name(parent_path, p.user_data['dialog'])) {
                        parent = p;
                        break; // found!
                    } else if(p.children && p.children.length > 0) {
                        parent_offset = vec_add(parent_offset, p.xy);
                        p = p.children[p.children.length-1]; // search final child
                    } else {
                        break; // dead end
                    }
                }
            }
        }

        if(!parent) {
            dialog.show = false;
            return;
        }

        // special-case hack to point at specific unit deployment
        // buttons when the order might change depending on what units
        // the player has and their damage state.
        if(widget_name && widget_name.indexOf('DEPLOY_UNIT:') == 0) {
            var spec_name = widget_name.split(':')[1];
            var ulist = desktop_dialogs['desktop_bottom'].user_data['deploy_button_specs'];
            found_widget_name = null;
            if(ulist) {
                for(var i = 0; i < ulist.length; i++) {
                    if(ulist[i] === spec_name) {
                        parent = desktop_dialogs['desktop_bottom'].widgets['unit_deployment_bar'].widgets['unit'+i.toString()];
                        parent_offset = desktop_dialogs['desktop_bottom'].widgets['unit_deployment_bar'].get_absolute_xy();
                        found_widget_name = 'plus_all';
                        break;
                    }
                }
            }
            if(!found_widget_name) {
                dialog.show = false; return;
            }

        } else if(widget_name && widget_name.indexOf('BUILD:') == 0) {
            // similar special-case hack for Build dialog
            var spec_name = widget_name.split(':')[1];
            var slots = parent.user_data['slots_this_page'];
            found_widget_name = null;
            for(var i = 0; i < slots.length; i++) {
                if(slots[i][0] == spec_name) {
                    found_widget_name = 'grid'+(slots[i][1].toString())+','+(slots[i][2].toString());
                    break;
                }
            }
        }



        var btn = parent.widgets[found_widget_name];
        if(!btn) {
            dialog.show = false;
            return;
        }

        dialog.show = true;

        // copy any animation the parent dialog is doing
        dialog.transform = parent.transform;

        // hack - remove then add it back to make it on top (of the tutorial UI)
        var root = dialog.parent;
        if(root === tutorial_root) {
            root.unparent(dialog);
            root.add(dialog);
        }

        var arrow_dims = dialog.data['widgets']['arrow']['dimensions'];

        var xy = vec_add(vec_add(parent.xy, parent_offset), btn.xy);
        xy[0] += Math.floor(btn.wh[0]/2);
        if(direction == 'down') {
            xy[1] -= arrow_dims[1]; // move the dialog up so that the tip of the downward arrow is pointing at the target
        } else {
            xy[1] += Math.floor(0.3*arrow_dims[1]); // move the dialog down to leave a little space between the arrow tip and target
        }

        dialog.xy = [xy[0] - Math.floor(arrow_dims[0]/2), xy[1]];
        if(dialog.parent) { // might be ok to do this unconditionally
            dialog.xy = vec_sub(dialog.xy, dialog.parent.get_absolute_xy());
        }

        // animate the arrow moving up and down
        var wave = Math.floor((dialog.user_data['wave_amplitude']||10)*(Math.sin(4*client_time)+(direction=='down'?-0.25:0.25)));

        var tip_y_canvas = dialog.get_absolute_xy()[1] + (direction == 'down' ? dialog.wh[1] + 10 : 10);
        var tip_y_client = canvas_div_offsetTop + tip_y_canvas;
        var client_height;

        if(fb_iframe_dims !== null && fb_iframe_offset !== null && fb_iframe_scroll !== null) {
            // use FB API-provided info about the iframe container to transform to browser-window coordinates
            client_height = fb_iframe_dims[1] - fb_iframe_offset[1] + fb_iframe_scroll[1];
        } else {
            // use natural window height (DOES NOT WORK WHEN IFRAMED!)
            client_height = window.innerHeight;
        }

        if(spin_frame_platform == 'kg' && dialog.user_data['scroll_down_hack']) {
            // KG leaves us with no choice to figure out if the arrow is off screen, so use this ugly hack
            dialog.widgets['arrow'].show = true;
            dialog.widgets['scroll'].show = dialog.widgets['scroll_bg'].show = false;
            if('scroll_arrow' in dialog.widgets) { dialog.widgets['scroll_arrow'].show = false; }
            if('scroll_down_hack' in dialog.data['widgets']) {
                for(var i = 0; i < dialog.data['widgets']['scroll_down_hack']['array'][1]; i++) {
                    dialog.widgets['scroll_down_hack'+i.toString()].show = true;
                    dialog.widgets['scroll_down_hack'+i.toString()].alpha = dialog.data['widgets']['scroll_down_hack']['alpha'] * Math.pow(i, -1.25);
                }
            }

        } else if((tip_y_client + 10 >= client_height)) {
            // check for case where the bottom of the arrow would be below the visible window area
            dialog.widgets['scroll'].show = dialog.widgets['scroll_bg'].show = true;
            if('scroll_arrow' in dialog.widgets) {
                dialog.widgets['scroll_arrow'].show = true;
                dialog.widgets['arrow'].show = false;
            } else {
                dialog.widgets['arrow'].show = true;
            }
            dialog.xy[1] -= (tip_y_client - client_height) - 10;
            wave *= 0.25; // less motion
        } else {
            dialog.widgets['scroll'].show = dialog.widgets['scroll_bg'].show = false;
            if('scroll_arrow' in dialog.widgets) { dialog.widgets['scroll_arrow'].show = false; }
            dialog.widgets['arrow'].show = true;
        }

        dialog.xy[1] = Math.floor(dialog.xy[1] + wave);

    }; })(_dialog, _parent_path, _widget_name, _direction);
}

// maintain a tutorial arrow pointing to a place on the landscape
// if unit_name is non-null, the arrow points to the unit with that name
// otherwise, it points to grid location 'loc'
function update_tutorial_arrow_for_landscape(_dialog, _unit_name, _loc, _direction, _buildable) {
    return (function (dialog, unit_name, loc, direction, buildable) { return function() {
        dialog.show = true;
        dialog.user_data['reticle_loc'] = null;
        dialog.user_data['reticle_pos'] = null;
        dialog.user_data['reticle_size'] = null;

        var unit = null;
        if(unit_name) {
            unit = find_object_by_type(unit_name);
            if(unit) {
                var effsize = ('unit_collision_gridsize' in unit.spec && unit.spec['unit_collision_gridsize'][0] > 0 ? unit.spec['unit_collision_gridsize'] : unit.spec['gridsize'])[0];
                dialog.user_data['reticle_size'] = 10 * effsize;
            } else {
                dialog.show = false;
            }
        }

        var xy;
        if(unit_name && unit) {
            var myloc = unit.interpolate_pos();
            dialog.user_data['reticle_loc'] = myloc;
            xy = ortho_to_screen(myloc);
            xy[0] -= 4; xy[1] -= 4;
            dialog.user_data['reticle_pos'] = [xy[0],xy[1]];
        } else if(loc != null) {
            if(buildable) {
                // shift location if necessary to find space to build a building
                var original_loc = loc;
                loc = find_valid_building_location(loc, buildable);
                if(!loc) { loc = original_loc; } // give up
            }
            dialog.user_data['reticle_loc'] = loc;
            xy = ortho_to_screen(loc);
            dialog.user_data['reticle_pos'] = [xy[0],xy[1]];
            dialog.user_data['reticle_size'] = 50;
        } else {
            xy = [0,0];
        }

        var arrow_dims = dialog.data['widgets']['arrow']['dimensions'];
        var wave = Math.floor(8*Math.sin(4*client_time));
        if(direction == 'down') {
            xy[1] -= arrow_dims[1] + 40;
        } else {
            xy[1] += Math.floor(arrow_dims[1]/2) - 10;
        }
        dialog.xy = [xy[0] - Math.floor(arrow_dims[0]/2),
                     xy[1] - 0];
        dialog.widgets['arrow'].xy = [0, wave];
    }; })(_dialog, _unit_name, _loc, _direction, _buildable);
}

function tutorial_arrow_draw_reticle(dialog, offset) {
    if(!dialog.user_data['reticle_pos'] || !dialog.user_data['reticle_size']) { return; }
    var xy = dialog.user_data['reticle_pos'];
    var size = view_zoom*dialog.user_data['reticle_size'];
    ctx.save();
    ctx.strokeStyle = 'rgba(0,255,255,1.0)';
    ctx.beginPath();
    ctx.arc(Math.floor(xy[0]), Math.floor(xy[1]), size, 0, 2*Math.PI, false);
    ctx.moveTo(Math.floor(xy[0]-size), Math.floor(xy[1]));
    ctx.lineTo(Math.floor(xy[0]-1.8*size), Math.floor(xy[1]));
    ctx.moveTo(Math.floor(xy[0]+size), Math.floor(xy[1]));
    ctx.lineTo(Math.floor(xy[0]+1.8*size), Math.floor(xy[1]));
    ctx.stroke();
    ctx.restore();
}

function make_ui_arrow(direction) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['tutorial_arrow_'+direction]);
    dialog.transparent_to_mouse = true;
    return dialog;
}

function make_tutorial_arrow_for_button(parent_path, widget_name, direction) {
    var dialog = make_ui_arrow(direction);
    tutorial_ui = dialog;
    tutorial_root.add(dialog);
    dialog.ondraw = update_tutorial_arrow_for_button(dialog, parent_path, widget_name, direction);
    return dialog;
}

function make_tutorial_arrow_for_landscape(unit_name, loc, direction) {
    var dialog = make_ui_arrow(direction);
    tutorial_ui = dialog;
    tutorial_root.add(dialog);
    dialog.ondraw = update_tutorial_arrow_for_landscape(dialog, unit_name, loc, direction, null);
    dialog.afterdraw = tutorial_arrow_draw_reticle;
    return dialog;
}

function tutorial_step_move_rover_action_command() {
    // called when player issues any command to a rover
    // put all friendly rovers into AI_ATTACK_ANY state so they fire as soon as enemies are in range
    if(player.get_any_abtest_value('tut_battle_interact', gamedata['client']['tut_battle_interact']) != 'manual') {
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.is_mobile() && obj.team === 'player') {
                var order = {'state': ai_states.AI_ATTACK_ANY};
                obj.new_order(order, true);
            }
        }
    }
    advance_tutorial();
}

function tutorial_step_repair_message(data) {

    // switch back to calm bg music
    change_backdrop_music(GameArt.assets['background_music'].states['normal'].audio);

    var dialog_data = gamedata['dialogs']['tutorial_repair_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'tutorial_repair_message';
    tutorial_ui = dialog;
    tutorial_root.add(dialog);

    dialog.auto_center();

    dialog.widgets['description'].str = data['ui_description'];

    var closure = (function (next) { return function() {
        var cc = find_object_by_type(gamedata['townhall']);
        if(!cc) { throw Error('townhall not found!'); }
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "REPAIR", session.viewing_base.base_id]);
        player.tutorial_state = next;
        if(!cc.is_damaged()) {
            // if player somehow repaired already, skip the wait_for_repairs step
            player.tutorial_state = gamedata['tutorial'][next]['next'];
        }
        tutorial_step(true);
    }; })(data['next']);

    dialog.widgets['use_resources_button'].onclick = (function (cl) { return function() {
        metric_event('0190_tutorial_start_repairs', {});
        cl();
    }; })(closure);
    dialog.widgets['instant_button'].onclick = (function (cl) { return function() {
        metric_event('0200_tutorial_instant_repair', {});
        cl();
    }; })(closure);

    if(data['use_resources_button_arrow']) {
        var dir = 'down';
        var arrow = make_ui_arrow(dir);
        dialog.add(arrow);
        arrow.ondraw = update_tutorial_arrow_for_button(arrow, 'tutorial_repair_message', 'use_resources_button', dir);
    }
}


// note: this is used for both the tutorial step and the on-login invite friends prompt
function setup_invite_friends_prompt(dialog, reason) {
    var tut_data = gamedata['tutorial']['congratulations_message'];

    dialog.widgets['title'].str = tut_data['ui_viral_title'];
    dialog.user_data['invite_friends_reason'] = reason;

    var num_friends = 0;
    var friend_name = null;

    for(var i = 0; i < player.friends.length; i++) {
        var friend = player.friends[i];
        if(!friend.is_ai() && friend.is_real_friend) {
            num_friends += 1;
            if(!friend_name) {
                friend_name = friend.get_ui_name();
            }
        }
    }

    var descr = '';
    if(num_friends < 1) {
        descr += tut_data['ui_description_has_no_friends'];
    } else if(num_friends < 2) {
        descr += tut_data['ui_description_has_one_friend'].replace('%s', friend_name);
    } else if(num_friends < 3) {
        descr += tut_data['ui_description_has_two_friends'].replace('%s', friend_name).replace('%d', (num_friends-1).toFixed(0));
    } else {
        descr += tut_data['ui_description_has_many_friends'].replace('%s', friend_name).replace('%d', (num_friends-1).toFixed(0));
    }

    dialog.widgets['description'].str += descr;

    // fill in friend widgets
    var row = 0;
    var n_widgets = 5;
    for(i = 0; i < player.friends.length && row < n_widgets; i++) {
        var friend = player.friends[i];
        if(friend.is_ai() || !friend.is_real_friend) { continue; }
        dialog.widgets['friend_icon'+row].set_user(friend.user_id);
        row++;
    }

    dialog.widgets['ok_button'].onclick = function(w) {
        var reason = w.parent.user_data['invite_friends_reason'];
        change_selection(null);
        if(player.tutorial_state === 'congratulations_message' || !friend_invites_enabled()) {
            advance_tutorial();
        } else {
            invoke_invite_friends_dialog(reason);
        }
   };
}

function invoke_invite_friends_prompt() {
    if(!friend_invites_enabled()) { return null; }

    change_selection(null);

    var dialog_data = gamedata['dialogs']['tutorial_congratulations'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'tutorial_congratulations';
    change_selection_ui(dialog);

    dialog.modal = true;
    dialog.auto_center();

    setup_invite_friends_prompt(dialog, 'invite_friends_prompt');

    dialog.widgets['close_button'].show = true;
    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    return dialog;
}

function tutorial_step_congratulations(data) {
    change_selection(null);

    if(player.get_any_abtest_value('tutorial_delay_invite', true)) { advance_tutorial(); advance_tutorial(); return; }

    var dialog_data = gamedata['dialogs']['tutorial_congratulations'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'tutorial_congratulations';
    tutorial_nonmodal_ui = dialog;
    tutorial_root.add(dialog);

    dialog.auto_center();

    dialog.widgets['title'].str = data['ui_name'];
    dialog.widgets['description'].str = data['ui_description'];

    setup_invite_friends_prompt(dialog, 'tutorial_step_congratulations');

    dialog.widgets['close_button'].show = false;

    // have to set a timer in case dialog goes away without clicking 'OK'
    window.setTimeout(function() {
        if(player.tutorial_state === 'congratulations_message') {
            advance_tutorial();
        }
    }, 20000);

    make_tutorial_arrow_for_button('tutorial_congratulations', 'ok_button', 'up');

    GameArt.assets['conquer_sound'].states['normal'].audio.play(client_time);
}

function tutorial_step_invite_friends(data) {
    change_selection(null);
    if(!friend_invites_enabled()) { advance_tutorial(); return; }
    invoke_invite_friends_dialog('tutorial_step_invite_friends');
    if(player.tutorial_state === 'invite_friends') {
        advance_tutorial();
    }
}

/** @param {string} title_text
    @param {string} body_text
    @param {Object=} props */
function invoke_message_dialog(title_text, body_text, props) {
    if(typeof props == 'undefined') { props = {}; }

    var dialog_data = gamedata['dialogs'][props['dialog'] || 'message_dialog'];

    // instantiate the dialog
    var dialog = new SPUI.Dialog(dialog_data);

    // make the dialog modal and add it to the "desktop"
    if(!props.parentless) {
        change_selection_ui(dialog);
        dialog.auto_center();
        dialog.modal = true;
    }

    dialog.widgets['title'].str = title_text;
    if('title_text_color' in props) {
        dialog.widgets['title'].text_color = SPUI.make_colorv(props['title_text_color']);
    }

    dialog.widgets['description'].set_text_with_linebreaking(body_text);
    if('close_button' in props && !props['close_button']) {
        dialog.widgets['close_button'].show = false;
    }
    if('cancel_button' in props && props['cancel_button']) {
        dialog.widgets['cancel_button'].show = true;
    }

    var make_go_away = function (_action) { return function() { change_selection(null); if(_action) { _action(); } }; };
    if('close_button' in dialog.widgets) { dialog.widgets['close_button'].onclick = make_go_away(null); }
    dialog.widgets['ok_button'].onclick = make_go_away(props['on_ok'] || null);
    if('ok_button_ui_name' in props) { dialog.widgets['ok_button'].str = props['ok_button_ui_name']; }
    if('ok_button_state' in props) { dialog.widgets['ok_button'].state = props['ok_button_state']; }
    if('ok_button_tooltip' in props) { dialog.widgets['ok_button'].tooltip.str = props['ok_button_tooltip']; }
    if('cancel_button' in dialog.widgets) { dialog.widgets['cancel_button'].onclick = dialog.widgets['close_button'].onclick; }
    return dialog;
}

// same as above but presents message as a child of the current selection.ui
/** @param {string} title_text
    @param {string} body_text
    @param {Object=} props */
function invoke_child_message_dialog(title_text, body_text, props) {
    if(typeof props == 'undefined') { props = {}; }

    // note: this should ideally be a check to make sure selection.ui inherits from SPUI.Container
    if(!selection.ui || !selection.ui.add) {
        return invoke_message_dialog(title_text, body_text, props);
    }

    var dialog_data = gamedata['dialogs'][props['dialog'] || 'message_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);

    if(!props.parentless) {
        if(0) { // XXXXXX this code is actually more correct - try it sometime
            dialog.modal = true;
            install_child_dialog(dialog);
            dialog.auto_center();
        } else {
            dialog.xy[0] = Math.floor((selection.ui.wh[0]-dialog.wh[0])/2);
            dialog.xy[1] = Math.floor((selection.ui.wh[1]-dialog.wh[1])/2);
            dialog.modal = true;
            selection.ui.add(dialog);
        }
    }

    dialog.widgets['title'].str = title_text;
    if('title_text_color' in props) {
        dialog.widgets['title'].text_color = SPUI.make_colorv(props['title_text_color']);
    }

    dialog.widgets['description'].set_text_with_linebreaking(body_text);

    if('close_button' in props && !props['close_button']) {
        dialog.widgets['close_button'].show = false;
    }
    if('cancel_button' in props && props['cancel_button']) {
        dialog.widgets['cancel_button'].show = true;
    }

    var make_go_away = function (_action) { return function(w) {
        close_parent_dialog(w);
        if(_action) { _action(); }
    }; };
    if('close_button' in dialog.widgets) { dialog.widgets['close_button'].onclick = make_go_away(null); }
    if('cancel_button' in dialog.widgets) { dialog.widgets['cancel_button'].onclick = dialog.widgets['close_button'].onclick; }

    dialog.widgets['ok_button'].onclick = make_go_away(props['on_ok'] || null);
    if('ok_button_ui_name' in props) { dialog.widgets['ok_button'].str = props['ok_button_ui_name']; }
    if('ok_button_state' in props) { dialog.widgets['ok_button'].state = props['ok_button_state']; }
    if('ok_button_tooltip' in props) { dialog.widgets['ok_button'].tooltip.str = props['ok_button_tooltip']; }
    return dialog;
}

function invoke_insufficient_alloy_message(reason, amount, order) {
    if(player.get_any_abtest_value('skip_insufficient_gamebucks', gamedata['store']['skip_insufficient_gamebucks'])) {
        return invoke_buy_gamebucks_dialog(reason, amount, order);
    }

    var dialog_data = gamedata['dialogs']['insufficient_alloy_message'];
    var dialog = new SPUI.Dialog(dialog_data);

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var ui_alloy = Store.gamebucks_ui_name();
    dialog.widgets['title'].str = dialog.widgets['title'].data['ui_name'].replace('%s', ui_alloy);
    dialog.widgets['ok_button'].str = dialog.widgets['ok_button'].data['ui_name'].replace('%s', ui_alloy);

    var text = SPText.cstring_to_ablocks_bbcode(dialog.data['widgets']['description']['ui_name'].replace('%cur', Store.display_user_currency_amount(player.resource_state['gamebucks'], 'compact')).replace('%gamebucks1',ui_alloy).replace('%gamebucks2',ui_alloy).replace('%need', Store.display_user_currency_amount(amount, 'compact')));
    dialog.widgets['description'].append_text(text);

    dialog.widgets['alloy_icon'].bg_image = player.get_any_abtest_value('gamebucks_icon_med', gamedata['store']['gamebucks_icon_med']);

    dialog.widgets['alloy_icon'].onclick =
        dialog.widgets['ok_button'].onclick = (function (_dialog, _reason, _amount, _order) { return function(w) {
            close_parent_dialog(w);
            invoke_buy_gamebucks_dialog(_reason, -1, _order); // raw dialog
        }; })(dialog, reason, amount, order);
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    metric_event('4400_insufficient_gamebucks_message', {'purchase_ui_event': true, 'client_time': Math.floor(client_time), 'method': reason});
    return dialog;
}

/** @param {Object.<string,number>} cost
    @param {string} headline
    @param {string=} extra */
function invoke_insufficient_resources_message(cost, headline, extra) {
    if(!extra) { extra = ''; }
    var ls = [];
    for(var res in cost) {
        // cost sometimes includes "time" so check if it's actually a resource
        if(res in gamedata['resources'] && player.resource_state[res][1] < cost[res]) {
            ls.push(gamedata['resources'][res]['ui_name']);
        }
    }
    var resname = ls.join('/');
    invoke_child_message_dialog(headline, gamedata['strings']['more_resources_needed'].replace('%res',resname) + ' '+extra);
}

/** @param {Object.<string,number>} cost
    @param {number=} squad_id */
function invoke_insufficient_resources_for_repair_message(cost, squad_id) {
    var helper;
    var options = {};

    // continuation callback to start squad repair
    var cbmaker = function (_squad_id) { return function() {
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_REPAIR_QUEUE", _squad_id]);
    }; };

    if(player.squads_enabled() && (squad_id || squad_id===0) && player.squads && (squad_id.toString() in player.squads)) {
        cost['squad_id'] = squad_id;
        helper = get_requirements_help('insufficient_resources_to_repair_squad', cost, {continuation:cbmaker(squad_id)});
    } else {
        helper = get_requirements_help('insufficient_resources_to_repair_units', cost, {continuation:cbmaker(SQUAD_IDS.BASE_DEFENDERS)});
    }

    if(helper) {
        helper();
    } else {
        invoke_insufficient_resources_message(cost, gamedata['errors']['INSUFFICIENT_RESOURCES_TO_REPAIR']['ui_name']);
    }
}

function invoke_speedup_dialog(kind) {
    var dialog = do_invoke_speedup_dialog(kind);
    if(!dialog) { return null; }
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.widgets['close_button'].onclick = (player.tutorial_state == "COMPLETE" ? function() { change_selection(null); } : null);
    if(player.tutorial_state == 'speedup_click_finish') { dialog.widgets['close_button'].show = false; }
    return dialog;
}

function invoke_child_speedup_dialog(kind) {
    if(!selection.ui || !selection.ui.add) {
        return invoke_speedup_dialog(kind);
    }
    var dialog = do_invoke_speedup_dialog(kind);
    if(!dialog) { return null; }
    dialog.modal = true;
    //selection.ui.add(dialog);
    //dialog.xy[0] = Math.floor((selection.ui.wh[0]-dialog.wh[0])/2);
    //dialog.xy[1] = Math.floor((selection.ui.wh[1]-dialog.wh[1])/2);
    install_child_dialog(dialog);
    dialog.auto_center();

    dialog.widgets['close_button'].onclick = (player.tutorial_state == "COMPLETE" ? close_parent_dialog : null);
    if(player.tutorial_state == 'speedup_click_finish') { dialog.widgets['close_button'].show = false; }

    return dialog;
}

// note: 'kind' must be 'speedup' (for a manual speedup) or 'busy'
// (for the error you get when attempting an action that requires the
// foreman to be free, and the foreman isn't free)
function do_invoke_speedup_dialog(kind) {
    var dialog_data = gamedata['dialogs']['speedup_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'speedup_dialog';

    dialog.modal = true;

    // show the title and description corresponding to the kind of speedup

    dialog.widgets['title_'+kind].show = true;

    var time_left = selection.unit.time_until_finish();
    var min_left = Math.floor(time_left/60);
    if(min_left < 1) { min_left = 1; }

    var description_finish;
    if(selection.unit.is_repairing()) {
        description_finish = gamedata['strings']['speedup']['finish_repairing'].replace('%s', selection.unit.spec['ui_name']);
    } else if(selection.unit.is_under_construction()) {
        description_finish = gamedata['strings']['speedup']['finish_building'].replace('%s', selection.unit.spec['ui_name']);
    } else if(selection.unit.is_upgrading()) {
        description_finish = gamedata['strings']['speedup']['finish_upgrading'].replace('%s', selection.unit.spec['ui_name']);
    } else if(selection.unit.is_researching()) {
        var techname = selection.unit.research_item;
        if(techname in player.tech) {
            description_finish = gamedata['strings']['speedup']['finish_tech_upgrade'].replace('%s', gamedata['tech'][selection.unit.research_item]['ui_name']);
        } else {
            description_finish = gamedata['strings']['speedup']['finish_tech_unlock'].replace('%s', gamedata['tech'][selection.unit.research_item]['ui_name']);
        }
    } else if(selection.unit.is_crafting()) {
        if(selection.unit.is_emplacement()) {
            var ui_name = ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(selection.unit.turret_head_inprogress_item()));
            description_finish = gamedata['strings']['speedup']['finish_turret_head'].replace('%s', ui_name);
        } else {
            description_finish = gamedata['strings']['speedup']['finish_crafting'].replace('%s', selection.unit.spec['ui_name']);
        }
    } else if(selection.unit.is_manufacturing()) {
        description_finish = gamedata['strings']['speedup']['finish_manufacturing'].replace('%s', selection.unit.spec['ui_name']);
    } else {
        console.log('Unhandled case in invoke_speedup_dialog()');
        change_selection_ui(null);
        return null;
    }

    var description_before;
    if(kind === 'busy') {
        description_before = gamedata['strings']['speedup']['before_building'];
    } else if(kind === 'production') {
        description_before = gamedata['strings']['speedup']['before_manufacturing'];
    } else if(kind === 'research') {
        description_before = gamedata['strings']['speedup']['before_research'];
    } else if(kind === 'crafting') {
        description_before = gamedata['strings']['speedup']['before_crafting'];
    } else {
        description_before = gamedata['strings']['speedup']['before_generic'];
    }

    var description = gamedata['strings']['speedup']['template'].replace('%TIME',pretty_print_time(time_left)).replace('%FINISH', description_finish).replace('%BEFORE', description_before);
    dialog.widgets['description'].set_text_with_linebreaking(description);

    var price, closure;
    price = Store.get_user_currency_price(selection.unit.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null);
    if(price == 0) {
        closure = (function (unit) {
            return function(w) {
                send_to_server.func(["CAST_SPELL", unit.id, "SPEEDUP_FOR_FREE"]);
                invoke_ui_locker(unit.request_sync(), (function (_w) { return function() { close_parent_dialog(_w); }; })(w));
            };
        })(selection.unit);
    } else {
        closure = (function (unit) {
            return function(w) {
                var dialog = w.parent;

                // update price since time may have passed
                var new_price = Store.get_user_currency_price(unit.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null);
                if(new_price === 0) {
                    // convert to free speedup
                    send_to_server.func(["CAST_SPELL", unit.id, "SPEEDUP_FOR_FREE"]);
                    invoke_ui_locker(unit.request_sync(), (function (_w) { return function() { close_parent_dialog(_w); }; })(w));
                } else if(new_price < 0) {
                    // order became invalid, maybe the building finished what it was doing
                    close_parent_dialog(w);
                } else {
                    if(Store.place_user_currency_order(unit.id, "SPEEDUP_FOR_MONEY", null,
                                                       (function (_w) { return function() { close_parent_dialog(_w); }; })(w)
                                                      )) {
                        invoke_ui_locker(unit.request_sync());
                        dialog.widgets['ok_button'].str = dialog.data['widgets']['ok_button']['ui_name_pending'];
                        dialog.widgets['ok_button'].state = 'disabled'; dialog.widgets['price_display'].onclick = null;
                    }
                }
            };
        })(selection.unit);
    }

    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
    dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);

    dialog.widgets['ok_button'].onclick =
        dialog.widgets['price_display'].onclick = closure;

    if(player.tutorial_state === 'speedup_open_speedup_menu' &&
       selection.unit.spec['name'] === gamedata['tutorial'][player.tutorial_state]['target'] &&
       selection.unit.is_under_construction()) {
        advance_tutorial();
    }

    return dialog;
}

function invoke_confirm_cancel_message(type, cancel_cb) {
    var dialog_data = gamedata['dialogs']['confirm_cancel_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['description'].set_text_with_linebreaking(dialog.data['widgets']['description']['ui_name_'+type]);
    dialog.widgets['ok_button'].str = dialog.data['widgets']['ok_button']['ui_name_'+type];
    dialog.widgets['ok_button'].onclick = (function (_cancel_cb) { return function(w) { close_parent_dialog(w); cancel_cb(); }; })(cancel_cb);
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    return dialog;
}

function invoke_attack_through_protection_message(do_attack_cb) {
    var dialog_data = gamedata['dialogs']['attack_through_protection_message'];
    var dialog = new SPUI.Dialog(dialog_data);

    dialog.auto_center();
    dialog.modal = true;
    install_child_dialog(dialog);

    dialog.widgets['yes_button'].onclick = (function (cb) { return function() { change_selection(null); cb(); }; })(do_attack_cb);
    dialog.widgets['no_button'].onclick = function(w) { close_parent_dialog(w); visit_base_home(); };
    return dialog;
}

function invoke_attack_friend_message(do_attack_cb) {
    var dialog_data = gamedata['dialogs']['attack_friend_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    change_selection_ui(dialog);
    dialog.auto_center();

    dialog.widgets['description'].str = dialog_data['widgets']['description']['ui_name'].replace('%s', session.viewing_friend.get_ui_name());
    dialog.widgets['yes_button'].onclick = (function (cb) { return function() { change_selection(null); cb(); }; })(do_attack_cb);
    dialog.widgets['no_button'].onclick = function() { visit_base_home(); };
    return dialog;
}

function invoke_attack_reinforce_message(do_attack_cb) {
    var dialog_data = gamedata['dialogs']['attack_reinforce_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    change_selection_ui(dialog);
    dialog.auto_center();

    dialog.widgets['yes_button'].onclick = (function (cb) { return function() { change_selection(null); cb(); }; })(do_attack_cb);
    dialog.widgets['no_button'].onclick = function() { change_selection(null); };
    return dialog;
}

function invoke_attack_revenge_lower_level_message(do_attack_cb) {
    var dialog_data = gamedata['dialogs']['attack_revenge_lower_level_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    change_selection_ui(dialog);
    dialog.auto_center();

    dialog.widgets['yes_button'].onclick = (function (cb) { return function() { change_selection(null); cb(); }; })(do_attack_cb);
    dialog.widgets['no_button'].onclick = function() { change_selection(null); };
    return dialog;
}

function invoke_attack_stronger_message(do_attack_cb) {
    var dialog_data = gamedata['dialogs']['attack_stronger_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    change_selection_ui(dialog);
    dialog.auto_center();

    dialog.widgets['description'].str = dialog_data['widgets']['description']['ui_name'].replace('%s', session.ui_name);
    dialog.widgets['yes_button'].onclick = (function (cb) { return function() { change_selection(null); cb(); }; })(do_attack_cb);
    dialog.widgets['no_button'].onclick = function() { change_selection(null); };
    return dialog;
}

function invoke_attack_stronger_strict_message() { return invoke_attack_level_range_message('stronger_strict'); };
function invoke_attack_weaker_message() { return invoke_attack_level_range_message('weaker'); };
function invoke_attack_level_range_message(mode) {
    var dialog_data = gamedata['dialogs']['attack_level_range_message'];
    var dialog = new SPUI.Dialog(dialog_data);
    change_selection_ui(dialog);
    dialog.auto_center();
    var level = Math.max(1, attackable_level_range(player.level(), (player.is_ladder_player() ? 'ladder' : 'default'))[(mode == 'stronger_strict' ? 1 : 0)]);
    dialog.widgets['description'].str = dialog_data['widgets']['description']['ui_name_'+mode].replace('%s', session.ui_name).replace('%d', level.toString());
    dialog.widgets['return_button'].onclick = visit_base_home;
    return dialog;
}


/** @param {Object} data
    @param {Object=} context */
function create_splash_message(data, context) {
    var dialog = new SPUI.Dialog(gamedata['dialogs'][data['dialog']]);
    if(data['ui_title']) {
        dialog.widgets['title'].set_text_with_linebreaking(data['ui_title']);
    } else {
        if('title' in dialog.widgets) { dialog.widgets['title'].show = 0; }
    }
    dialog.widgets['ok_button'].onclick = close_parent_dialog;
    if('close_button' in dialog.widgets) {
        dialog.widgets['close_button'].onclick = dialog.widgets['ok_button'].onclick;
    }
    if(('ai_name' in dialog.widgets) && ('ai_name' in data)) {
        dialog.widgets['ai_name'].str = data['ai_name'];
    }
    if('picture' in data) {
        dialog.widgets['picture'].asset = data['picture'];
    }
    if('sound' in data) {
        GameArt.assets[data['sound']].states['normal'].audio.play(client_time);
    }
    apply_dialog_hacks(dialog, data, context);
    return dialog;
}

// "data" = JSON spec for the dialog
// "context" = argument to pass to any consequents invoked by this dialog
function invoke_splash_message(data, context) {
    var dialog = create_splash_message(data, context);
    change_selection_ui(dialog);
    dialog.modal = true;
    dialog.auto_center();
}

function invoke_flash_offer(data) {
    var sku_name = data['spell'];
    var sku = gamedata['spells'][sku_name];

    // make sure the offer can take effect
    var spellname = sku['effect']['spellname'];
    var spellarg = sku['effect']['spellarg'];
    if(!can_cast_spell(GameObject.VIRTUAL_ID, spellname, spellarg)) {
        console.log('cannot accept flash offer! '+data['name']);
        return;
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs'][data['dialog'] || 'flash_offer_dialog']);
    change_selection_ui(dialog);
    dialog.modal = true;
    dialog.auto_center();

    if('picture' in data) {
        dialog.widgets['picture'].asset = data['picture'];
    }
    dialog.widgets['close_button'].onclick = function() { change_selection(null); };

    var price = Store.get_user_currency_price(0, sku, null);
    var closure = (function (_sku_name) {
        return function(w) {
            var dialog = w.parent;

            if(Store.place_user_currency_order(GameObject.VIRTUAL_ID, sku_name, null, function() { change_selection(null); })) {
                dialog.widgets['ok_button'].str = dialog.data['widgets']['ok_button']['ui_name_pending'];
                dialog.widgets['ok_button'].state = 'disabled'; dialog.widgets['price_display'].onclick = null;
            }
        }; })(sku_name);

    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
    dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);

    dialog.widgets['ok_button'].onclick =
        dialog.widgets['price_display'].onclick = closure;

    apply_dialog_hacks(dialog, data);
    return dialog;
}

function test_flash_offer(offer) {
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_EXECUTE_CONSEQUENT", {'consequent':'FLASH_OFFER','offer':offer}]);
}

function invoke_battle_end_dialog(battle_type, battle_base, battle_opponent_user_id, battle_opponent_fbid, battle_opponent_level, battle_opponent_friend,
                                  battle_opponent_name,
                                  outcome, loot, battle_summary, ladder_state)
{
    if(outcome == 'victory' &&
       player.tutorial_state == "COMPLETE" &&
       (battle_base.base_type == 'home' || battle_base.base_type == 'hive' || !battle_base.base_type) &&
       player.get_any_abtest_value('fancy_victory_dialog', gamedata['client']['fancy_victory_dialog'])) {
        return invoke_fancy_victory_dialog(battle_type, battle_base, battle_opponent_user_id, battle_opponent_fbid, battle_opponent_level, battle_opponent_friend,
                                           battle_opponent_name,
                                           outcome, loot, battle_summary, ladder_state);
    }

    // do this first so it pops under
    if(player.tutorial_state === 'wait_battle_finish2') {
        metric_event('0330_tutorial_battle_ended', {});
        advance_tutorial();
    }

    var dialog_data = gamedata['dialogs']['battle_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'battle_dialog';

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['title'].str = gamedata['strings']['battle_end'][battle_type][outcome]['ui_title'];
    dialog.widgets['description'].set_text_with_linebreaking(gamedata['strings']['battle_end'][battle_type][outcome]['ui_description'].replace('%LADDER_WIN_DAMAGE',
                                                                                                                                               Math.floor(100.0*gamedata['matchmaking']['ladder_win_damage']).toFixed(0)));

    if(outcome === 'defeat') {
    } else {
        if(player.tutorial_state == "COMPLETE") {
            var viral_name = null;
            var viral_props = {'%ENEMY': battle_opponent_name, '%ENEMY_LEVEL': battle_opponent_level.toString()};
            if(is_ai_user_id_range(battle_opponent_user_id)) {
                viral_name = 'defeat_computer';
            } else if(battle_opponent_friend && battle_opponent_friend.is_real_friend) {
                viral_name = 'defeat_facebook_friend';
            }
            if(viral_name) {
                var viral = get_facebook_viral(viral_name);
                if(viral) {
                    dialog.widgets['viral_button'].show = true;
                    dialog.widgets['viral_button'].str = viral['ui_button_text'];
                    dialog.widgets['viral_button'].onclick = (function (_vname, _vprops) { return function() {
                        invoke_facebook_viral(_vname, _vprops);
                    }; })(viral_name, viral_props);
                }
            }
        }
    }

    if(outcome === 'defeat') {
        dialog.widgets['splash_image'].asset = 'splash_defeat';
        dialog.widgets['bg'].sound = null;
    } else {
        dialog.widgets['splash_image'].asset = 'splash_victory';
    }

    for(var res in gamedata['resources']) {
        if('loot_'+res+'_amount' in dialog.widgets) {
            var amount;
            if(gamedata['show_uncapped_loot']) {
                amount = loot['looted_uncapped_'+res] || 0;
            } else {
                amount = loot[res] || 0;
            }
            dialog.widgets['loot_'+res+'_amount'].str = pretty_print_number(amount);
            dialog.widgets['loot_'+res+'_icon'].asset = gamedata['resources'][res]['icon_small'];
            if(amount) {
                dialog.widgets['loot_'+res+'_amount'].show = dialog.widgets['loot_'+res+'_icon'].show = true;
            }
        }
    }
    dialog.widgets['loot_xp_amount'].str = pretty_print_number(loot['xp'] || 0);

    var trophy_delta = 0, trophy_type = null;
    goog.array.forEach(['pvp','pvv'], function(t) {
        if((loot['trophies_'+t] || 0)) {
            trophy_delta = loot['trophies_'+t];
            trophy_type = t;
        }
    });
    if(trophy_delta != 0) {
        dialog.widgets['trophy_sunken'].show =
            dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_amount'].show =
            dialog.widgets['trophy_shine'].show = true;
        dialog.widgets['trophy_icon'].state = trophy_type;

        var sign = (trophy_delta > 0 ? 'plus' : 'minus');
        dialog.widgets['trophy_amount'].str = dialog.data['widgets']['trophy_amount']['ui_name_'+sign].replace('%d', pretty_print_number(Math.abs(trophy_delta)));
        dialog.widgets['trophy_amount'].text_color = SPUI.make_colorv(dialog.data['widgets']['trophy_amount']['text_color_'+sign]);
        dialog.widgets['trophy_sunken'].tooltip.str = dialog.data['widgets']['trophy_sunken']['ui_tooltip'].replace('%s', gamedata['strings']['leaderboard']['categories']['trophies_'+trophy_type]['short_title']);
    }

    dialog.widgets['ok_button'].onclick = (function (_outcome, _base) { return function() {
        change_selection(null);
        if(player.tutorial_state === 'battle_end_message') {
            advance_tutorial();
        }
        if(_base.base_type == 'quarry' && outcome === 'victory') {
            invoke_ingame_tip((session.region.data['storage'] == 'nosql') ? 'quarry_conquer_tip2_nosql' : 'quarry_conquer_tip2');
        } else if(_base.base_type == 'hive') {
            var tipname = 'hive_battle_'+outcome+'_tip';
            var options = {force:1};
            invoke_ingame_tip(tipname, options);
        }
    }; })(outcome, battle_base);

    // have to set a timer in case dialog goes away without clicking 'OK'
    window.setTimeout(function() {
        if(player.tutorial_state === 'battle_end_message') {
            advance_tutorial();
        }
    }, 15000);

    return dialog;
}

function test_fancy_victory_dialog(ai_id, kind, has_trophies, has_item_loot) { // kind should be "home"/"away"/"ladder"
    var ladder_state = {'points':{'victory':{},'defeat':{}}};
    ladder_state['points']['victory'][session.user_id.toString()] = 30;
    ladder_state['points']['victory'][ai_id.toString()] = 30;
    ladder_state['points']['defeat'][session.user_id.toString()] = -30;
    ladder_state['points']['defeat'][ai_id.toString()] = -30;
    var units = {};
    for(var n in gamedata['units']) {
        units[n] = 999;
    }
    invoke_fancy_victory_dialog(kind, {base_type:'home'}, ai_id, '-1', 10, null,
                                'Test AI', 'victory',
                                {'iron':12345, 'looted_uncapped_iron':12345,
                                 'water':5432, 'looted_uncapped_water':12345,
                                 'units_killed':units,
                                 'units_lost':units,
                                 'battle_stars':{'foo':1,'bar':2,'baz':3},
                                 'trophies_pvp': (has_trophies ? 30 : null),
                                 'items': (has_item_loot ? [{'spec':'inventory_unknown','stack':5}] : [])},
                                {'base_damage': 0.51,
                                 'deployed_units':units},
                                (kind == 'ladder' ? ladder_state : null));
}

// get a string representing the units you killed in battle
function get_loot_kills_list(loot, separator, max_count) {
    var units_destroyed = [];
    if('units_killed' in loot) {
        for(var specname in loot['units_killed']) {
            var qty = loot['units_killed'][specname];
            var spec = gamedata['units'][specname];
            units_destroyed.push(qty.toString() + ' ' + (qty>1 && spec['ui_name_plural'] ? spec['ui_name_plural'] : spec['ui_name']));
        }
    }

    // if the list is too long to fit the dialog area, list by category instead
    if(units_destroyed.length > max_count) {
        var cat_list = goog.object.getKeys(gamedata['strings']['manufacture_categories']);
        var cat_kills = {};
        goog.array.forEach(cat_list, function(cat) { cat_kills[cat] = 0; });
        for(var specname in loot['units_killed']) {
            var qty = loot['units_killed'][specname];
            cat_kills[gamedata['units'][specname]['manufacture_category']] += qty;
        }
        units_destroyed = [];
        for(var i = 0; i < cat_list.length; i++) {
            var cat = cat_list[i];
            if(cat_kills[cat] > 0) {
                units_destroyed.push(cat_kills[cat].toString() + ' ' + gamedata['strings']['manufacture_categories'][cat][(cat_kills[cat] == 1 ? 'singular' : 'plural')]);
            }
        }
    }
    return units_destroyed.join(separator);
}

function invoke_fancy_victory_dialog(battle_type, battle_base, battle_opponent_user_id, battle_opponent_fbid, battle_opponent_level, battle_opponent_friend,
                                     battle_opponent_name,
                                     outcome, loot, battle_summary, ladder_state) {
    // do this first so it pops under
    if(player.tutorial_state === 'wait_battle_finish2') {
        metric_event('0330_tutorial_battle_ended', {});
        advance_tutorial();
    }

    var dialog_data = gamedata['dialogs']['fancy_victory_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'fancy_victory_dialog';
    dialog.user_data['context'] = null;
    dialog.user_data['anim_start_time'] = client_time;
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['winner_name'].str = player.get_ui_name();
    dialog.widgets['loser_name'].str = battle_opponent_name;

    dialog.widgets['winner_portrait'].set_user(session.user_id);
    if(battle_opponent_user_id === null) {
        // for defenses, we don't get the user_id yet
        dialog.widgets['loser_portrait'].show = false;
    } else {
        dialog.widgets['loser_portrait'].set_user(battle_opponent_user_id);
    }

    var units_killed = 0, units_lost = 0;

    if(gamedata['client']['enable_defending_units']) {
        if('units_killed' in loot) {
            for(var specname in loot['units_killed']) {
                var qty = loot['units_killed'][specname];
                units_killed += qty;
            }
        }
        if('units_lost' in loot) {
            for(var specname in loot['units_lost']) {
                var qty = loot['units_lost'][specname];
                units_lost += qty;
            }
        }
        dialog.widgets['units_killed'].str = pretty_print_number(units_killed);
        dialog.widgets['units_lost'].str = pretty_print_number(units_lost);
    } else{
        // hide the units killed and units lost counters when we don't have defending units enabled
        dialog.widgets['units_killed'].show = false;
        dialog.widgets['units_killed_label'].show = false;
        dialog.widgets['units_lost'].show = false;
        dialog.widgets['units_lost_label'].show = false;
    }

    // scale loser_inner bar width according to how well the loser did in terms of kills vs. losses
    var loser_width; // 84-259
    if(units_lost < 1) {
        loser_width = 0;
    } else if(units_lost >= units_killed) {
        loser_width = 1;
    } else {
        loser_width = units_lost/(units_killed+1);
    }
    // set .data to a modified copy of the original so that the size_change animation picks up the new final "dimensions"
    dialog.widgets['loser_inner'].data = goog.object.clone(dialog.widgets['loser_inner'].data);
    dialog.widgets['loser_inner'].wh[0] = dialog.widgets['loser_inner'].data['dimensions'][0] = Math.floor(84 + loser_width*(259-84));

    if(player.get_any_abtest_value('show_xp_gains', gamedata['client']['show_xp_gains'])) {
        dialog.widgets['loot_xp_amount'].num_val = loot['xp'] || 0;
        dialog.widgets['loot_xp_amount'].str = pretty_print_number(loot['xp'] || 0);
    } else {
        dialog.widgets['loot_xp_icon'].show =
            dialog.widgets['loot_xp_amount'].show = false;
    }

    var looted_res = {};
    for(var res in gamedata['resources']) {
        if(battle_type !== 'home') {
            if(gamedata['show_uncapped_loot']) {
                looted_res[res] = loot['looted_uncapped_'+res] || 0;
            } else {
                looted_res[res] = loot[res] || 0;
            }
        } else {
            looted_res[res] = 0;
        }
    }

    var trophies = (loot['trophies_pvp'] || 0) + (loot['trophies_pve'] || 0) + (loot['trophies_pvv'] || 0);
    dialog.user_data['trophy_type'] = ((loot['trophies_pvv'] || 0) != 0 ? 'pvv' : ((loot['trophies_pvp'] || 0) != 0 ? 'pvp' : 'pve'));

    if(battle_type !== 'home') {
        for(var res in gamedata['resources']) {
            if('row_'+res+'_amount' in dialog.widgets) {
                /* dialog.widgets['total_'+res+'_amount'].num_val = */ dialog.widgets['row_'+res+'_amount'].num_val = looted_res[res];
                /* dialog.widgets['total_'+res+'_amount'].str = */ dialog.widgets['row_'+res+'_amount'].str = pretty_print_number(looted_res[res]);
            }
            if(looted_res[res]) {
                goog.array.forEach(['row_%s_icon', 'row_%s_amount', 'total_%s_icon', 'total_%s_amount'], function(s) {
                    var wname = s.replace('%s', res);
                    if(wname in dialog.widgets) {
                        dialog.widgets[wname].show = true;
                    }
                });
            }
        }
    } else {
        dialog.widgets['separator_top'].xy = vec_copy(dialog.data['widgets']['separator_top']['xy_home']);
        // print list of units you destroyed
        if(!trophies) {
            dialog.widgets['you_gained'].show = false; // nothing "gained", so don't show it
        }
        dialog.widgets['row_name'].show =
            dialog.widgets['row_bullet'].show = false;
        for(var res in gamedata['resources']) {
            goog.array.forEach(['row_%s_icon', 'row_%s_amount', 'total_%s_icon', 'total_%s_amount'], function(s) {
                var wname = s.replace('%s', res);
                if(wname in dialog.widgets) {
                    dialog.widgets[wname].show = false;
                }
            });
        }
        dialog.widgets['row_defense'].show = true;
        dialog.widgets['row_defense'].set_text_with_linebreaking(dialog.data['widgets']['row_defense']['ui_name'] + '\n' + get_loot_kills_list(loot, '\n', dialog.widgets['row_defense'].data['max_lines']));
        // so that typewriter animation will work
        dialog.widgets['row_defense'].data = goog.object.clone(dialog.widgets['row_defense'].data);
        dialog.widgets['row_defense'].data['ui_name'] = dialog.widgets['row_defense'].str;
    }

    if(battle_type !== 'home' && gamedata['client']['battle_end_dialog_show_units_deployed'] && ('deployed_units' in battle_summary)) {
        dialog.widgets['you_spent'].show = true;
        var i = 0, j = 0;
        for(var specname in gamedata['units']) {
            if(specname in battle_summary['deployed_units']) {
                var spec = gamedata['units'][specname];
                var qty = battle_summary['deployed_units'][specname];

                var d = dialog.widgets[SPUI.get_array_widget_name('spent_unit', dialog.data['widgets']['spent_unit']['array'], [i,j])];
                d.show = true;
                d.user_data['specname'] = specname;
                if('icon' in spec) {
                    d.widgets['item'].asset = get_leveled_quantity(spec['icon'],1);
                } else {
                    d.widgets['item'].asset = get_leveled_quantity(spec['art_asset'],1);
                }
                d.widgets['item'].state = GameArt.assets[d.widgets['item'].asset].has_state('icon') ? 'icon' : 'normal';
                d.widgets['stack'].str = pretty_print_number(qty);
                d.widgets['frame'].state = 'normal_nohighlight'; // 'disabled' use grayed-out frame
                d.widgets['frame'].tooltip.str = pretty_print_number(qty)+'x '+((spec['ui_name_plural'] && qty != 1) ? spec['ui_name_plural'] : spec['ui_name']);
                i += 1;
                if(i >= dialog.data['widgets']['spent_unit']['array'][0]) {
                    i = 0;
                    j += 1;
                    if(j >= dialog.data['widgets']['spent_unit']['array'][1]) {
                        console.log('ran out of space to display units!');
                        break;
                    }
                }
            }
        }
    }

    if(trophies > 0) {
        dialog.widgets['trophy_label'].show =
            dialog.widgets['trophy_bg'].show =
            dialog.widgets['trophy_shine'].show =
            dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_amount'].show = true;
        dialog.widgets['trophy_expires'].show = (gamedata['matchmaking']['ladder_point_frequency'] !== 'season');
        dialog.widgets['trophy_icon'].state = dialog.user_data['trophy_type'];
        dialog.widgets['trophy_label'].str = dialog.data['widgets']['trophy_label']['ui_name'].replace('%d', pretty_print_number(current_pvp_week()));
        dialog.widgets['trophy_amount'].num_val = trophies;
        dialog.widgets['trophy_amount'].str = pretty_print_number(trophies);
    }

    if('battle_stars' in loot && 'base_damage' in battle_summary) {
        dialog.widgets['battle_stars_bg'].show =
            dialog.widgets['battle_stars_base_damage'].show = true;
        var pct = Math.floor(100*battle_summary['base_damage']).toFixed(0);
        dialog.widgets['battle_stars_base_damage'].str = dialog.data['widgets']['battle_stars_base_damage']['ui_name'].replace('%d', pct);
        var count = goog.object.getCount(loot['battle_stars']);
        for(var i = 0; i < dialog.data['widgets']['battle_stars_hole']['array'][0]; i++) {
            dialog.widgets['battle_stars_hole'+i.toString()].show = true;
            dialog.widgets['battle_stars_star'+i.toString()].show = (i < count);
        }
    }

    for(var i = 0; i < dialog.data['widgets']['itemrow_bg']['array'][1]; i++) {
        dialog.widgets['itemrow_bg_highlight'+i].show =
            dialog.widgets['itemrow_bg'+i].show = false;
    }

    var token_qty = 0, token_spec = null;

    if('items' in loot && loot['items'].length > 0) {

        dialog.widgets['splash_image'].show = dialog.widgets['splash_image_frame'].show = false;
        dialog.widgets['items_found'].show = true;

        for(var i = 0; i < dialog.data['widgets']['itemrow_bg']['array'][1]; i++) {
            if(loot['items'].length > i*dialog.data['widgets']['slot']['array'][0]) {
                dialog.widgets['itemrow_bg'+i].show = true;
            }
        }

        for(var i = 0; i < loot['items'].length; i++) {
            var item = loot['items'][i];

            if(item['spec'] == 'token') {
                token_spec = ItemDisplay.get_inventory_item_spec(item['spec']);
                token_qty = (('stack' in item) ? item['stack'] : 1);
            }

            // if only one item, center it
            if(loot['items'].length == 1 && i == 0) {
                i = 1;
            }

            var x = i % dialog.data['widgets']['slot']['array'][0];
            var y = Math.floor(i / dialog.data['widgets']['slot']['array'][0]);
            if(y >= dialog.data['widgets']['slot']['array'][1]) {
                break;
            }
            var xy = x.toString()+','+y.toString();
            dialog.widgets['slot_bg'+xy].show =
                dialog.widgets['slot'+xy].show =
                dialog.widgets['item_icon'+xy].show =
                dialog.widgets['item_stack'+xy].show =
                dialog.widgets['item_frame'+xy].show = true;


            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            ItemDisplay.set_inventory_item_asset(dialog.widgets['item_icon'+xy], spec);
            ItemDisplay.set_inventory_item_stack(dialog.widgets['item_stack'+xy], spec, item);
            dialog.widgets['item_frame'+xy].onclick = null;
            dialog.widgets['item_frame'+xy].state = (player.get_any_abtest_value('modal_looting', gamedata['modal_looting']) ? 'normal_nohighlight' : 'normal');

            dialog.widgets['item_frame'+xy].onenter = (function (_i, _item) { return function(w) {
                var dialog = w.parent;
                if(dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === _i) { return; }

                // only show tooltip when modal looting is off
                if(!player.get_any_abtest_value('modal_looting', gamedata['modal_looting'])) {
                    w.state = 'active_nopushed';
                    invoke_inventory_context(w.parent, w, _i, _item, false);
                }

                // set transparent so that onleave is always called reliably
                if(dialog.user_data['context']) { dialog.user_data['context'].transparent_to_mouse = true; }
            }; })(i, item);

            dialog.widgets['item_frame'+xy].onleave_cb = (function (_i, _item) { return function(w) {
                w.state = (player.get_any_abtest_value('modal_looting', gamedata['modal_looting']) ? 'normal_nohighlight' : 'normal');
                if(dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === _i) {
                    invoke_inventory_context(w.parent, w, -1, null, false);
                }
            }; })(i, item);
        }
    }

    // make a private copy of widget.data here so the animation will work, since it repeatedly pulls .str from from widget.data
    if(1) {
        dialog.widgets['valentina_says'].data = goog.object.clone(dialog.widgets['valentina_says'].data);

        /** @type {string} template for what she says (random alternatives separated by "|") */
        var valentina_says;
        /** @type {Object.<string, string>} substrings to replace inside the template*/
        var replacements = {};

        if(is_ai_user_id_range(battle_opponent_user_id) && battle_opponent_user_id.toString() in gamedata['ai_bases_client']['bases'] &&
           'ui_fancy_victory_text' in gamedata['ai_bases_client']['bases'][battle_opponent_user_id.toString()]) {
            valentina_says = gamedata['ai_bases_client']['bases'][battle_opponent_user_id.toString()]['ui_fancy_victory_text'];
        } else if(trophies > 0) {
            valentina_says = dialog.widgets['valentina_says'].data['ui_name_trophies_'+dialog.user_data['trophy_type']] || dialog.widgets['valentina_says'].data['ui_name_trophies'];
            replacements['%d'] = pretty_print_number(trophies);
        } else {
            var win_type = (gamedata['common_win_condition'] == 'battle_stars' ? battle_type+'_battle_stars' : battle_type);
            if(!('ui_name_'+win_type in dialog.widgets['valentina_says'].data)) {
                throw Error('no ui_name_'+win_type+' in valentina_says');
            }
            valentina_says = dialog.widgets['valentina_says'].data['ui_name_'+win_type];
            replacements['%LADDER_WIN_DAMAGE'] = (100.0*gamedata['matchmaking']['ladder_win_damage']).toFixed(0);
            replacements['%TOWNHALL'] = gamedata['buildings'][gamedata['townhall']]['ui_name'];
        }
        var alternatives = valentina_says.split('|');
        var idx = Math.floor(Math.random() * alternatives.length);
        valentina_says = alternatives[idx];
        for(var k in replacements) { valentina_says = valentina_says.replace(k, replacements[k]); }
        dialog.widgets['valentina_says'].data['ui_name'] = valentina_says;
    }

    if(battle_type == 'home') {
        // defensive battle
        var damage = calc_base_damage({count_partial:true});
        dialog.widgets['base_damage'].str = dialog.widgets['base_damage'].data['ui_name'].replace('%pct', Math.floor(100*damage).toFixed(0) + '%');
        init_dialog_repair_buttons(dialog, damage);
        dialog.default_button = dialog.widgets[(damage > 0 ? 'repair_instant_button' : 'repair_not_necessary_button')];
        dialog.widgets['close_button'].show = false;
        dialog.widgets['close_button'].onclick = null; // prevent ESC from working
        dialog.widgets['ok_button'].show = false;
    } else {
        dialog.widgets['base_damage'].show =
            dialog.widgets['price_display'].show =
            dialog.widgets['repair_instant_button'].show =
            dialog.widgets['repair_slow_button'].show =
            dialog.widgets['repair_not_necessary_button'].show = false;

    dialog.widgets['close_button'].onclick =
        dialog.widgets['ok_button'].onclick = (function (_outcome, _base) { return function() {
            change_selection(null);
            if(player.tutorial_state === 'battle_end_message') {
                advance_tutorial();
            }
            if(_base.base_type == 'quarry' && outcome === 'victory') {
                invoke_ingame_tip((session.region.data['storage'] == 'nosql') ? 'quarry_conquer_tip2_nosql' : 'quarry_conquer_tip2');
            } else if(_base.base_type == 'hive') {
                var tipname = 'hive_battle_'+outcome+'_tip';
                var options = {force:1};
                if(outcome === 'victory' && token_qty > 0) {
                    tipname += '_with_tokens';
                    options.replacements = {'%d': pretty_print_number(token_qty), '%s': token_spec['ui_name']};
                } else if(outcome === 'victory' && loot['hive_kill_points']) {
                    tipname += '_with_kill_points';
                    options.replacements = {'%s': loot['hive_kill_points'].toString()};
                }
                invoke_ingame_tip(tipname, options);
            }
        }; })(outcome, battle_base);

    // have to set a timer in case dialog goes away without clicking 'OK'
    window.setTimeout(function() {
        if(player.tutorial_state === 'battle_end_message') {
            advance_tutorial();
        }
    }, 15000);
    }

    dialog.ondraw = update_fancy_victory_dialog;
    return dialog;
}

function apply_animation(dialog, wname, widget, anim_data, anim_time, anim) {
    if(!widget.show) { return; }

    if(0 in anim) {
        // it's an array
        for(var i = 0; i < anim.length; i++) {
            apply_animation(dialog, wname, widget, anim_data, anim_time, anim[i]);
        }
        return;
    }

    if(anim['type'] == 'same_as') {
        if('delay' in anim) { anim_time -= anim['delay']; }
        return apply_animation(dialog, wname, widget, anim_data, anim_time, anim_data[anim['ref']]);
    }

    var t = (anim_time - dialog.user_data['anim_start_time'] - anim['start_time'])/(anim['end_time']-anim['start_time']);
    t = clamp(t, 0, 1);
    if(anim['type'] == 'translate') {
        var start_pos = ('start_pos' in anim ? anim['start_pos'] : widget.data['xy']);
        var end_pos = ('end_pos' in anim ? anim['end_pos'] : widget.data['xy']);
        widget.xy = vec_add(start_pos, vec_scale(t, vec_sub(end_pos, start_pos)));
    } else if(anim['type'] == 'fadein') {
        widget.alpha = t;
    } else if(anim['type'] == 'size_change') {
        var start_dimensions = ('start_dimensions' in anim ? anim['start_dimensions'] : widget.data['dimensions']);
        var end_dimensions = ('end_dimensions' in anim ? anim['end_dimensions'] : widget.data['dimensions']);
        widget.wh = vec_floor(vec_add(start_dimensions, vec_scale(t, vec_sub(end_dimensions, start_dimensions))));
    } else if(anim['type'] == 'transform') {
        var start_xform = ('start_transform' in anim ? anim['start_transform'] : [1,0,0,1,0,0]);
        var end_xform = ('end_transform' in anim ? anim['end_transform'] : [1,0,0,1,0,0]);
        var xform = [0,0,0,0,0,0];
        for(var i = 0; i < 6; i++) {
            xform[i] = start_xform[i] + t*(end_xform[i]-start_xform[i]);
        }
        widget.transform = xform;
    } else if(anim['type'] == 'count_up') {
        if(t <= 0) {
            widget.str = '';
        } else {
            var val = Math.floor(widget.num_val * t);
            widget.str = pretty_print_number(val);
        }
    } else if(anim['type'] == 'typewriter') {
        var source = widget.data['ui_name'];
        var s = '';
        if(t >= 1) {
            s += source;
        } else {
            var last_char = t * source.length;
            for(var i = 0; i < last_char; i++) {
                s += source.charAt(i);
            }
        }
        if(anim['cursor'] && (client_time % 1.0) > 0.5) {
            s += '|';
        }
        widget.str = s;
    } else if(anim['type'] == 'SPFX') {
        if(!('spfx' in dialog.user_data)) { dialog.user_data['spfx'] = {}; }
        var offset = ('offset' in anim ? anim['offset'] : [0,0]);
        var widget_xy = widget.data['xy'];
        if('array_offset' in widget.data) {
            widget_xy = vec_add(widget_xy, vec_mul(widget.array_pos, widget.data['array_offset']));
        }
        var pos = vec_add(vec_add(vec_add(dialog.xy, widget_xy), vec_scale(0.5, widget.data['dimensions'])), offset);
        if(!(wname in dialog.user_data['spfx'])) {
            // SPFX wants time in terms of "start time", not "time relative to start", so invert the sense of time delays
            var spfx_start_time = client_time + (client_time-anim_time);
            dialog.user_data['spfx'][wname] = SPFX.add_visual_effect(pos, 0, [0,1,0], spfx_start_time, anim['effect'], true, {is_ui:true});
        }
        //dialog.user_data['spfx'][wname].where = pos; // XXX how to track moving UI objects?
    } else {
        throw Error('unknown animation type '+anim['type']);
    }
}

function update_fancy_victory_dialog(dialog) {
    if(dialog.widgets['trophy_expires'].show) {
        var togo = player.current_trophy_challenge_togo();
        dialog.widgets['trophy_expires'].str = (togo > 0 ? dialog.data['widgets']['trophy_expires']['ui_name'].replace('%expiry',gamedata['strings']['trophies_expire_in']).replace('%s', pretty_print_time_brief(togo)) : null);
    }

    var anim_data = dialog.data['animation'];
    for(var wname in anim_data) {
        apply_animation(dialog, wname, dialog.widgets[wname], anim_data, client_time, anim_data[wname]);
    }
}

function start_incoming_attack() {
    if(session.incoming_attack_time > 0) {
        // tell server to spawn units
        send_to_server.func(["BEGIN_AI_ATTACK"]);
        session.incoming_attack_time = -1;

        // under automatic unit control, set "relentless" mode on all defending units that don't have "hold position" or "patrol" orders
        var use_auto_aggressive = get_preference_setting(player.preferences, 'auto_unit_control');

        if(use_auto_aggressive && (player.tutorial_state == "COMPLETE" || gamedata['tutorial'][player.tutorial_state]['make_units_aggressive'])) {
            for(var id in session.cur_objects.objects) {
                var obj = session.cur_objects.objects[id];

                if(obj.is_mobile() && obj.team == 'player') {
                    if(obj.patrol || (obj.orders && obj.orders.length == 1 && obj.orders[0]['state'] == ai_states.AI_ATTACK_STATIONARY)) {
                        // don't make aggressive
                    } else {
                        var order = {'state': ai_states.AI_ATTACK_ANY, 'aggressive': true};
                        obj.new_order(order, true);
                    }
                }
            }
        }
    }
    change_selection(null);
}

function invoke_ai_attack_warning_dialog(text) {
    var template = (player.tutorial_state === "COMPLETE" ? 'daily_attack_dialog' : 'ai_attack_warning_dialog');

    var dialog_data = gamedata['dialogs'][template];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = template;

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var attacker_name = session.incoming_attacker_name;

    if(template === 'ai_attack_warning_dialog') {
        dialog.widgets['description'].str = gamedata['tutorial']['ai_attack_begin']['ui_warning'].replace('%d',
                                                                                                          pretty_print_time(session.incoming_attack_time - server_time)).replace('%s', attacker_name);

        dialog.widgets['ai_name'].str = attacker_name;
        dialog.widgets['ok_button'].onclick = start_incoming_attack;
    } else {
        dialog.widgets['title'].str = dialog_data['widgets']['title']['ui_name'].replace('%s', attacker_name);
        dialog.widgets['description'].str = text;
        // show the icon of the most expensive unit
        var icon_asset = 'inventory_unknown';
        var max_cost = 0;
        var unit_list = [];

        // collapse all waves into one dictionary
        var waves = {};
        for(var i = 0; i < session.incoming_attack_units.length; i++) {
            var thiswave = session.incoming_attack_units[i];
            for(var specname in thiswave) {
                if(specname == 'direction') { continue; }
                waves[specname] = (waves[specname] || 0) + thiswave[specname];
            }
        }

        for(var specname in waves) {
            var qty = waves[specname];
            var cost = get_leveled_quantity(gamedata['units'][specname]['max_hp'],1);
            if(cost > max_cost) {
                max_cost = cost;
                icon_asset = get_leveled_quantity(gamedata['units'][specname]['art_asset'],1);
            }
            unit_list.push(qty+'x '+gamedata['units'][specname]['ui_name']);
        }
        dialog.widgets['unit_icon'].asset = icon_asset;
        dialog.widgets['unit_list'].str = unit_list.join('\n');
        dialog.widgets['delay_button'].onclick = function() { change_selection(null); }
        dialog.widgets['fight_button'].onclick = start_incoming_attack;
    }
    return dialog;
}

function invoke_ai_attack_finish_dialog(loot) {
    // do this first so it pops under
    if(player.tutorial_state === 'ai_attack_during') {
        metric_event('0270_tutorial_ai_attack_end', {});
        advance_tutorial(); // to ai_attack_end
    }

    var dialog_data = gamedata['dialogs']['ai_attack_finish_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'ai_attack_finish_dialog';

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var attacker_name = session.incoming_attacker_name;
    dialog.widgets['ai_name'].str = attacker_name;
    dialog.widgets['description'].str = gamedata['tutorial']['ai_attack_end']['ui_message'];

    dialog.widgets['ok_button'].onclick = function() {
        change_selection(null);
        if(player.tutorial_state === 'ai_attack_end') {
            advance_tutorial();
        }
    };

    // have to set a timer in case dialog goes away without clicking 'OK'
    window.setTimeout(function() {
        if(player.tutorial_state === 'ai_attack_end') {
            advance_tutorial();
        }
    }, 15000);

    return dialog;
}

// check whether player has unlocked unit whose spec name is 'name'
// returns 0 if not unlocked, otherwise returns the level of unit the player can build
function unit_unlock_level(name) {
    var spec = gamedata['units'][name];
    if(('requires' in spec) && !player.is_cheater) {
        var pred = read_predicate(get_leveled_quantity(spec['requires'], 1));
        if(!pred.is_satisfied(player, null)) {
            return 0;
        }
    }
    var level = 1;
    if('level_determined_by_tech' in spec) {
        level = 0; // not unlocked unless this tech is at L1 or higher
        var techname = spec['level_determined_by_tech'];
        if(techname in player.tech) {
            level = player.tech[techname];
        }
    }
    return level;
}

function do_harvest(all) {
    if(!selection.unit || !selection.unit.is_producer()) { return; }

    // check if storage is full

    // if doing a single collection on a harvester whose resource is full, show message and abort
    // if doing a collect-all, and one (but not all) resources are full, show message but continue collection
    // if doing a collect-all, and all resources are full, show message and abort

    var full = [], damaged = false;
    var doit = true;
    var num_resources = 0;

    // check for fullness
    for(var rsrc in gamedata['resources']) {
        var resdata = gamedata['resources'][rsrc];
        if(all) {
            if(!find_object_by_type(resdata['harvester_building'])) { // player has no harvesters that yield this resource
                // note: this won't catch remote quarries that yield the resource
                // but, the plan is to have an unlock requirement that prevents you from
                // attacking a quarry until you have a storage for the contained resources.
                continue;
            }
        } else if(!(('produces_'+rsrc) in selection.unit.spec)) {
            continue; // for single-harvester collect, skip resources other than the one this harvester produces
        }

        if(('loot_storage_warning_if' in resdata) && !read_predicate(resdata['loot_storage_warning_if']).is_satisfied(player,null)) { continue; }

        num_resources += 1;
        if(player.resource_state[rsrc][1] >= player.resource_state[rsrc][0]) {
            full.push(rsrc);
        }
    }

    if(num_resources > 0 && full.length >= num_resources) {
        // only prevent collection when ALL affected resource storages are full
        doit = false;
    }

    if(doit) {
        if(all) {
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "HARVEST_ALL2"]);

            // set sync marker on all harvesters
            var marker = synchronizer.request_sync();
            for(var id in session.cur_objects.objects) {
                var obj = session.cur_objects.objects[id];
                if(obj.is_building() && obj.is_producer()) {
                    obj.sync_marker = Math.max(obj.sync_marker, marker);
                }
            }

            // collect from quarries
            do_harvest_quarries();

        } else {
            if(selection.unit.is_in_sync()) {
                send_to_server.func(["CAST_SPELL", selection.unit.id, "HARVEST"]);
                selection.unit.request_sync();
            }
        }
    }

    change_selection(null);

    if(full.length > 0) {
        var rsrc = full[0];

        // first try to use the "plus button" helper before resorting to a normal error message
        var helper = get_requirements_help('storages_full', rsrc);
        if(helper) {
            return helper();
        }

        var data = gamedata['strings']['storages_full'];

        // if any storage buildings are damaged, tell the player to repair them rather than construct/upgrade
        // disabled for now, since we changed destroyed storages to still count towards your capacity
        /*
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.is_building() && obj.is_storage() && obj.is_damaged()) {
                title = "Storage buildings are damaged";
                msg = "Repair your storage buildings to make room\nbefore collecting resources.";
                break;
            }
        }
        */
        var ui_rsrc = gamedata['resources'][rsrc]['ui_name'];
        var title = data['ui_title'].replace('%s', ui_rsrc);
        var descr = data['ui_description'].replace('%s1', ui_rsrc).replace('%s2', ui_rsrc);

        invoke_message_dialog(title, descr);
        GameArt.assets['error_sound'].states['normal'].audio.play(client_time);
    }
}

// to reduce player confusion, do not show "Quarries: 59s" cooldown message unless we've actually seen a quarry harvest in this session.
var seen_quarry_harvest = false;

function do_harvest_quarries() {
    if(!session.region.map_enabled()) { return; }

    var needs_poll = false;
    var togo = player.cooldown_togo('quarry_collect');
    if(togo > 0) {
        if(seen_quarry_harvest) {
            // send a fake on-cooldown response so we don't spam the server
            handle_server_message(["HARVESTED_RESOURCES", {'cooldown':server_time+togo+1}, -1, null, 'quarry', null]);
        }
        return;
    }

    send_to_server.func(["QUARRY_COLLECT"]);

    session.quarry_harvest_sync_marker = synchronizer.request_sync();
    if(gamedata['client']['quarry_collect_poll_interval'] > 0 && !player.cooldown_active('quarry_collect_poll')) {
        player.cooldown_client_trigger('quarry_collect_poll', gamedata['client']['quarry_collect_poll_interval']);
        window.setTimeout(function() {
            send_to_server.func(["PING_CHAT", player.chat_seen]);
            session.region.ping_contest_rank();
        }, gamedata['client']['quarry_collect_poll_interval']*1000);
    }
}

/** Collect a deposit, but if storage is full, tell player to add storage instead.
    @param {Inert} deposit */
function do_collect_deposit(deposit) {
    if(deposit.metadata) {
        for(var res in gamedata['resources']) {
            if(res in deposit.metadata && (deposit.metadata[res] > (player.resource_state[res][0]-player.resource_state[res][1]))) {
                var s = gamedata['strings']['requirements_help']['storages_full']['trying_to_collect_deposit'];
                invoke_message_dialog(s['ui_title'], s['ui_description']);
                return;
            }
        }
    }
    if(deposit.collect_sent) { return; }
    deposit.collect_sent = true;
    send_to_server.func(["CAST_SPELL", deposit.id, "COLLECT_DEPOSIT"]);
    change_selection_unit(null);
}

/** @param {Array.<ContextMenuButton>} buttons */
function add_change_region_button(buttons) {
    if(gamedata['enable_region_map'] && player.get_any_abtest_value('change_region_requirement', gamedata['territory']['change_region_requirement'])['predicate'] != 'ALWAYS_FALSE') {
        var pred = read_predicate(player.get_any_abtest_value('change_region_requirement', gamedata['territory']['change_region_requirement']));
        var spell = gamedata['spells']['CHANGE_REGION'];
        var ui_name = spell['ui_name'];
        var togo = player.cooldown_togo(spell['cooldown_name']);
        if(!pred.is_satisfied(player, null)) {
            buttons.push(new ContextMenuButton(ui_name, get_requirements_help(pred), 'disabled_clickable', spell['ui_tooltip_unmet'].replace('%s',pred.ui_describe(player))));
        } else if(0 && player.region_map_building_is_busy()) {
            buttons.push(new ContextMenuButton(ui_name, null, 'disabled', spell['ui_tooltip_busy']));
        } else if(togo > 0) {
            if(player.squads_enabled() || player.get_any_abtest_value('show_base_relocation_in_store', gamedata['store']['show_base_relocation_in_store'])) {
                buttons.push(new ContextMenuButton(ui_name, function() { change_selection_ui(null); invoke_change_region_offer_dialog(); }, 'normal', spell['ui_tooltip_cooldown'].replace('%s', pretty_print_time(togo))));
            } else {
                buttons.push(new ContextMenuButton(ui_name, null, 'disabled', spell['ui_tooltip_cooldown'].replace('%s', pretty_print_time(togo))));
            }
        } else {
            buttons.push(new ContextMenuButton(ui_name, function() { change_selection_ui(null); invoke_change_region_dialog(null, 'CHANGE_REGION'); }, 'normal', spell['ui_tooltip']));
        }
    }
}

/** @param {Array.<ContextMenuButton>} buttons */
function add_regional_map_button(buttons) {
    var pred = read_predicate({'predicate':'LIBRARY', 'name':'quarry_play_requirement'});
    var can_view_quarries = pred.is_satisfied(player, null);
    if(can_view_quarries) {
        buttons.push(new ContextMenuButton(gamedata['spells']['SHOW_REGIONAL_MAP']['ui_name'], function() { change_selection_ui(null); invoke_region_map(); }));
    } else {
        buttons.push(new ContextMenuButton(gamedata['spells']['SHOW_REGIONAL_MAP']['ui_name'], get_requirements_help(pred), 'disabled_clickable',
                                           gamedata['spells']['SHOW_REGIONAL_MAP']['ui_tooltip_unmet'].replace('%s',pred.ui_describe(player))));
    }
}

/** @param {Array.<ContextMenuButton>} buttons */
function add_migrate_turret_heads_button(buttons) {
    var spell = gamedata['spells']['MIGRATE_TURRET_HEADS'];
    buttons.push(new ContextMenuButton(spell['ui_name'], (function (_spell) { return function() {
        invoke_child_message_dialog(_spell['ui_title'],
                                    _spell['ui_description'],
                                    {'dialog': 'message_dialog_big',
                                     'title_text_color': _spell['title_text_color'],
                                     'cancel_button': true,
                                     'ok_button_ui_name': _spell['ui_button'],
                                     'on_ok': function() {
                                         send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "MIGRATE_TURRET_HEADS"]);
                                         invoke_ui_locker();
                                     } });
    }; })(spell)));
}

/** @param {Array.<ContextMenuButton>} buttons */
function add_deploy_squads_button(buttons) {
    var pred = read_predicate({'predicate': 'AND', 'subpredicates':[
        {'predicate':'LIBRARY', 'name':'quarry_play_requirement'},
        {'predicate':'LIBRARY', 'name':'squad_play_requirement'},
        {'predicate':'LIBRARY', 'name':'in_nosql_region'}
    ]});
    var can_view_quarries = pred.is_satisfied(player, null);
    if(can_view_quarries) {
        buttons.push(new ContextMenuButton(gamedata['spells']['DEPLOY_SQUADS']['ui_name'],
                                           function() {
                                               change_selection_ui(null);
                                               var map = invoke_region_map();
                                               if(map) {
                                                   var sq = do_invoke_squad_control('deploy', {'deploy_from':player.home_base_loc});
                                               }
                                           }));
    } else {
        buttons.push(new ContextMenuButton(gamedata['spells']['DEPLOY_SQUADS']['ui_name'], get_requirements_help(pred), 'disabled_clickable',
                                           gamedata['spells']['DEPLOY_SQUADS']['ui_tooltip_unmet'].replace('%s',pred.ui_describe(player))));
    }
}

function invoke_building_context_menu(mouse_xy) {
    // assumes relevant building is already selected
    change_selection_ui(null);

    var obj = selection.unit;
    var spec = obj.spec;

    if(!(obj.is_building() || (obj.is_inert() && obj.team == 'player') || player.is_cheater)) {
        throw Error('context menu invoked without a building or player-owned inert object selected');
    }

    var quarry_movable = (session.is_quarry() && obj.spec['quarry_movable'] && session.viewing_base.base_landlord_id == session.user_id && session.region.data && session.region.data['storage'] == 'nosql');
    var quarry_buildable = (session.is_quarry() && obj.spec['quarry_buildable'] && session.viewing_base.base_landlord_id == session.user_id && session.region.data && session.region.data['storage'] == 'nosql');

    var dialog_name = 'building_context_menu';

    // need to figure out how many and what buttons to display first,
    // because there are different dialog templates depending on the
    // number of buttons.

    /** @type {Array.<ContextMenuButton>} */
    var buttons = [];

    /** @type {Object.<string, Array.<ContextMenuButton> >} */
    var special_buttons = {}; // for turret heads etc

    if(obj.is_building()) {

        if(session.home_base && obj.is_warehouse() && !obj.is_under_construction()) {
            if(player.warehouse_is_busy()) {
                buttons.push(new ContextMenuButton(gamedata['spells']['SHOW_INVENTORY']['ui_name'], null, 'disabled', gamedata['spells']['SHOW_INVENTORY']['ui_name_busy']));
            } else {
                buttons.push(new ContextMenuButton(gamedata['spells']['SHOW_INVENTORY']['ui_name'], function(w) { invoke_inventory_dialog(); }));
            }
        }

        if(session.home_base && obj.spec['name'] == gamedata['squad_building'] && !obj.is_under_construction()) {
            if(0 && player.squad_bay_is_busy()) {
                buttons.push(new ContextMenuButton(gamedata['spells']['MANAGE_SQUADS']['ui_name'], null, 'disabled', gamedata['spells']['MANAGE_SQUADS']['ui_name_busy']));
            } else if(player.squads_enabled()) {
                // MANAGE SQUADS button
                buttons.push(new ContextMenuButton(gamedata['spells']['MANAGE_SQUADS']['ui_name'], function() { change_selection_ui(null); invoke_squad_control(); }));
                add_deploy_squads_button(buttons);
            }
        }

        if(session.home_base && obj.spec['name'] === gamedata['alliance_building'] && !obj.is_under_construction()) {
            // TRANSMITTER

            // REINFORCEMENTS button
            if(player.unit_donation_enabled()) {
                var spell = gamedata['spells']['REQUEST_UNIT_DONATION'];
                var togo = player.cooldown_togo(spell['cooldown_name']);
                if(!session.is_in_alliance()) {
                    buttons.push(new ContextMenuButton(spell['ui_name'], null, 'disabled', spell['ui_tooltip_no_alliance']));
                } else if(player.alliance_building_is_busy()) {
                    buttons.push(new ContextMenuButton(spell['ui_name'], null, 'disabled', spell['ui_tooltip_busy']));
                } else if(player.donated_units_space() >= player.donated_units_max_space()) {
                    buttons.push(new ContextMenuButton(spell['ui_name'], null, 'disabled', spell['ui_tooltip_no_space']));
                } else if(togo > 0) {
                    buttons.push(new ContextMenuButton(spell['ui_name'], null, 'disabled', spell['ui_tooltip_cooldown'].replace('%s',pretty_print_time(togo))));
                } else {
                    buttons.push(new ContextMenuButton(spell['ui_name'], (function(_obj) { return function() {
                        request_unit_donation(_obj);
                        GameArt.assets["request_unit_donation_sound"].states['normal'].audio.play(client_time);
                        change_selection_ui(null);

                        if(gamedata['client']['unit_donation_request_maximize_chat']) {
                            // pop up Alliance chat
                            if(global_chat_frame) {
                                change_chat_tab(global_chat_frame, 'ALLIANCE');
                                chat_frame_size(global_chat_frame, true, true);
                            }
                        }
                        if(1) {
                            // show rising "Reinforcements Requested" text message
                            SPFX.add(new SPFX.CombatText([_obj.x,_obj.y], 0,
                                                         gamedata['strings']['combat_messages']['reinforcement_request_sent'],
                                                         [1,1,0.3],
                                                         client_time, client_time + 3.0,
                                                         { drop_shadow: true, font_size: 20, text_style: 'thick' }));
                        }
                    }; })(obj)));
                }
            }

            // ALLIANCES button
            if(1) {
                var pred = read_predicate({'predicate':'LIBRARY','name':'alliance_join_requirement'});
                if(!pred.is_satisfied(player, null)) {
                    buttons.push(new ContextMenuButton(gamedata['spells']['SHOW_ALLIANCES']['ui_name'], get_requirements_help(pred,null), 'disabled_clickable', gamedata['spells']['SHOW_ALLIANCES']['ui_name_unmet'].replace('%s',pred.ui_describe(player))));
                } else {
                    buttons.push(new ContextMenuButton(gamedata['spells']['SHOW_ALLIANCES']['ui_name'], invoke_alliance_dialog));
                }
            }
        }

        if(session.home_base && obj.spec['name'] === gamedata['region_map_building'] && !obj.is_under_construction()) {
            // SHOW MAP button
            //add_regional_map_button(buttons);

            // CHANGE REGION button
            add_change_region_button(buttons);
        }

        if(session.home_base && obj.is_lottery_building() && !obj.is_under_construction()) {
            if(player.lottery_is_busy()) {
                buttons.push(new ContextMenuButton(gamedata['spells']['LOTTERY_SCAN']['ui_name'], null, 'disabled', gamedata['spells']['LOTTERY_SCAN']['ui_tooltip_busy']));
            } else {
                buttons.push(new ContextMenuButton(gamedata['spells']['LOTTERY_SCAN']['ui_name'], invoke_lottery_dialog));
            }
        }

        if(obj.is_damaged() && (!session.home_base || !obj.is_repairing())) {
            buttons.push(new ContextMenuButton(gamedata['spells']['REPAIR']['ui_name'], invoke_repair_dialog));
        } else if((session.home_base || quarry_buildable) && (obj.is_repairing() || obj.is_under_construction())) {
            // offer to speed up repairs or construction
            buttons.push(new ContextMenuButton(gamedata['spells']['SPEEDUP_FOR_MONEY']['ui_name'],
                                               function() {invoke_speedup_dialog('speedup');}));
        } else if((session.home_base || quarry_buildable) && obj.is_upgrading()) {
            // if upgrading, then just show speedup and cancel
            buttons.push(new ContextMenuButton(gamedata['spells']['SPEEDUP_FOR_MONEY']['ui_name'],
                                               function() {invoke_speedup_dialog('speedup');}));
            buttons.push(new ContextMenuButton(gamedata['spells']['CANCEL_UPGRADE']['ui_name'],
                          (function (_id) { return function() {
                              change_selection_ui(null);
                              invoke_confirm_cancel_message('upgrade', (function (__id) { return function() { send_to_server.func(["CAST_SPELL", __id, "CANCEL_UPGRADE"]); }; })(_id));
                          }; })(selection.unit.id)));
        } else {
            // not damaged and not upgrading

            if(obj.is_producer()) {
                if(!session.home_base && gamedata['client']['quarry_collect_poll_interval'] < 0) {
                    // placeholder that tells you to go back home and collect all
                    buttons.push(new ContextMenuButton(gamedata['spells']['HARVEST']['ui_name'], null, 'disabled', gamedata['spells']['HARVEST']['ui_name_quarry']));
                } else if(session.home_base) {
                    if(obj.interpolate_contents() >= 1) {
                        buttons.push(new ContextMenuButton(gamedata['spells']['HARVEST']['ui_name'], function() { do_harvest(false); }));
                    } else {
                        buttons.push(new ContextMenuButton(gamedata['spells']['HARVEST']['ui_name'], null, 'disabled', gamedata['errors']['CANNOT_COLLECT_INSUFFICIENT_CONTENTS']['ui_name'].replace('%s', gamedata['resources'][obj.produces_res()]['ui_name'])));
                    }

                    if(player.get_any_abtest_value('enable_harvest_all', gamedata['enable_harvest_all'])) {
                        buttons.push(new ContextMenuButton(gamedata['spells']['HARVEST_ALL2']['ui_name'], function() { do_harvest(true); }));
                    }
                }
            }

            if(session.home_base && obj.is_factory()) {
                if(obj.is_manufacturing() && player.unit_speedups_enabled()) {
                    buttons.push(new ContextMenuButton(gamedata['spells']['SPEEDUP_FOR_MONEY']['ui_name'], function() {invoke_speedup_dialog('speedup'); }));
                }
                buttons.push(new ContextMenuButton(gamedata['spells']['MAKE_DROIDS']['ui_name'],
                                                   (function (_obj) { return function() {
                                                       invoke_manufacture_dialog('building_context', _obj.spec['manufacture_category'], null, _obj);
                                                   }; })(obj)));
            }

            if(session.home_base && obj.is_researcher()) {
                if(obj.is_researching()) {
                    buttons.push(new ContextMenuButton(gamedata['spells']['SPEEDUP_FOR_MONEY']['ui_name'], function() {invoke_speedup_dialog('speedup'); }));
                    buttons.push(new ContextMenuButton(gamedata['spells']['CANCEL_RESEARCH']['ui_name'],
                                  (function (_id) { return function() {
                                      change_selection_ui(null);
                                      invoke_confirm_cancel_message('research', (function (__id) { return function() { send_to_server.func(["CAST_SPELL", __id, "CANCEL_RESEARCH"]); }; })(_id));
                                  }; })(selection.unit.id)));
                } else {
                    buttons.push(new ContextMenuButton(gamedata['spells']['RESEARCH_FOR_FREE']['ui_name'],
                                  (function (_obj) { return function() {
                                      var category = _obj.spec['research_categories'][0];
                                      invoke_research_dialog(null, category);
                                  }; })(obj)));
                }
            }

            if(session.home_base && obj.is_crafter()) {
                var cat = gamedata['crafting']['categories'][obj.spec['crafting_categories'][0]];

                if(!obj.is_emplacement()) { // turret emplacements have special case, see below
                    buttons.push(new ContextMenuButton(cat['ui_verb'] || gamedata['spells']['CRAFT_FOR_FREE']['ui_name'],
                                                       (function (_cat) { return function() {
                                                           if(_cat['dialog'] == 'fishing_dialog') {
                                                               invoke_fishing_dialog();
                                                           } else if(_cat['table_of_contents']) {
                                                               invoke_crafting_table_of_contents_dialog(_cat['name']);
                                                           } else {
                                                               invoke_crafting_dialog(_cat['name']);
                                                           }
                                                       }; })(cat)));
                }

                if(obj.is_crafting()) {
                    // for turret emplacements, add the speedup/cancel buttons above the divider
                    var which_buttons;
                    if(obj.is_emplacement()) {
                        if(!('head' in special_buttons)) { special_buttons['head'] = []; }
                        which_buttons = special_buttons['head'];
                    } else {
                        which_buttons = buttons;
                    }

                    cat = gamedata['crafting']['categories'][gamedata['crafting']['recipes'][obj.is_crafting()]['crafting_category']];
                    if(player.crafting_speedups_enabled() && obj.crafting_progress_one() >= 0) {
                        if(('speedupable' in cat) && !cat['speedupable']) {
                            // cannot be sped up
                        } else {
                            which_buttons.push(new ContextMenuButton(gamedata['spells']['SPEEDUP_FOR_MONEY']['ui_name'], function() {invoke_speedup_dialog('speedup'); }));
                        }
                    }
                    if(('cancelable' in cat) && !cat['cancelable']) {
                        // not cancelable
                    } else if(obj.crafting_progress_one() >= 0) {
                        which_buttons.push(new ContextMenuButton(cat['ui_cancel_verb'] || gamedata['spells']['CANCEL_CRAFT']['ui_name'],
                                                                 (function (_unit, _cat) { return function() {
                                                                     change_selection_ui(null);
                                                                     invoke_confirm_cancel_message(cat['confirm_cancel_kind'] || 'crafting', (function (__unit) {
                                                                         return function() {
                                                                             cancel_unfinished_crafting(__unit);
                                                                         }; })(_unit));
                                                                 }; })(selection.unit, cat)));
                    }
                }
            }

            if(session.home_base && obj.is_minefield()) {
                buttons.push(new ContextMenuButton(gamedata['spells']['CRAFT_FOR_FREE']['ui_name_building_context_minefield'],
                              (function (_obj) { return function() {
                                  invoke_crafting_dialog('mines');
                              }; })(obj)));

                var mine_item_name = obj.minefield_item();
                if(mine_item_name) {
                    var mine_item = ItemDisplay.get_inventory_item_spec(mine_item_name);
                    if(mine_item && mine_item['associated_tech']) {
                        buttons.push(new ContextMenuButton(gamedata['spells']['UPGRADE_FOR_FREE']['ui_name'],
                                      (function (_techname) { return function() {
                                          invoke_upgrade_tech_dialog(_techname, null);
                                      }; })(mine_item['associated_tech'])));
                    }
                }
            }

            if(session.home_base && obj.is_emplacement()) { // special case for emplacements
                dialog_name = 'emplacement_context_menu';
                if(obj.time_until_finish() <= 0) {
                    var spell = gamedata['spells']['CRAFT_FOR_FREE'];
                    special_buttons['head'] = [];
                    special_buttons['head'].push(new ContextMenuButton(spell['ui_name_building_context_emplacement'],
                                                                       (function (_obj) { return function(w) { TurretHeadDialog.invoke(_obj); }; })(obj)));
                }

                var cur_item_name = obj.turret_head_item();
                if(cur_item_name) {
                    var item_spec = ItemDisplay.get_inventory_item_spec(cur_item_name);
                    if(item_spec && item_spec['associated_tech']) {
                        var upgr_spell = gamedata['spells']['RESEARCH_FOR_FREE'];
                        special_buttons['head'].push(new ContextMenuButton(upgr_spell['ui_name_building_context_emplacement'],
                                                                           (function (_techname) { return function() {
                                                                               invoke_upgrade_tech_dialog(_techname, null);
                                                                           }; })(item_spec['associated_tech'])));
                    }
                }
            }

            // can building be upgraded further?

            if(obj.time_until_finish() > 0) {
                // object is busy with something, cannot upgrade
            } else if((session.home_base || quarry_buildable) && (obj.get_max_ui_level() > 1 || obj.is_storage() || (('equip_slots' in obj.spec) && !obj.is_minefield()))) {
                var spell = gamedata['spells']['SHOW_UPGRADE'];
                if(obj.level < obj.get_max_ui_level()) {
                    if(gamedata['store']['enable_upgrade_all_barriers'] && (obj.spec['name'] === 'barrier')) {
                        buttons.push(new ContextMenuButton(spell['ui_name_all'],
                                                           function() {
                                                               change_selection_ui(null);
                                                               invoke_store('barriers');
                                                           }));
                    }
                }

                var migrate_spell = gamedata['spells']['MIGRATE_TURRET_HEADS'];
                if(migrate_spell && obj.spec['history_category'] == 'turrets' && read_predicate(migrate_spell['requires']).is_satisfied(player, null)) {
                    add_migrate_turret_heads_button(buttons);
                } else {
                    buttons.push(new ContextMenuButton(spell['ui_name'+ (obj.level < obj.get_max_ui_level() ? (obj.is_emplacement() ? '_emplacement' : '') : '_maxlevel')],
                                                       (function (_obj) { return function() { invoke_upgrade_building_dialog(_obj); }; })(obj)));
                }
            }

            if(session.home_base && obj.spec['name'] == gamedata['townhall']) {
                add_change_region_button(buttons);
            }

        } // END not damaged and not upgrading

    // END is_building()
    } else if(obj.is_inert() && session.home_base && ('spells' in obj.spec)) {
        if(goog.array.contains(obj.spec['spells'], "COLLECT_DEPOSIT")) {
            var collect_func = (function (_obj) { return function() { do_collect_deposit(_obj); }; })(obj);
            if(gamedata['enable_oneclick_harvest']) {
                collect_func();
            } else {
                var spell = gamedata['spells']['COLLECT_DEPOSIT'];
                buttons.push(new ContextMenuButton(spell['ui_name'], collect_func));
            }
        }
    }

    if((obj.is_building() ||
        (obj.is_inert() && player.is_cheater)) &&
       (session.home_base ||
        (quarry_movable &&
         (!(session.viewing_base.base_climate in gamedata['climates']) || !gamedata['climates'][session.viewing_base.base_climate]['exclude_ground_units']))
       )) {
        // "Move" is always the last button
        if(obj.is_building() && (obj.is_repairing() || obj.is_under_construction() || obj.is_upgrading())) {
            // moves are not allowed while repairing, constructing, or upgrading
        } else {
            buttons.push(new ContextMenuButton(gamedata['spells']['MOVE_BUILDING']['ui_name'],
                                               (function (_obj) { return function() {
                                                   selection.spellname = "MOVE_BUILDING";
                                                   change_selection_ui_under(new BuildUICursor(_obj, _obj.spec));
                                               }; })(obj)));
        }
    }

    if(player.is_cheater) {
        // DEV Delete button
        buttons.push(new ContextMenuButton(gamedata['spells']['REMOVE_OBJECT']['ui_name'], function() { send_and_remove_object(selection.unit); }));
    }

    if(buttons.length < 1) { return; }

    var dialog = invoke_generic_context_menu(mouse_xy, buttons, dialog_name, special_buttons);

    dialog.widgets['bg_close_button'].show = false;

    // fill in building name and level text
    dialog.widgets['title'].str = spec['ui_name'] || spec['name'];

    if(obj.is_building() && obj.get_max_ui_level() > 1) {
        var cur_level = obj.level;
        if(obj.is_upgrading()) {
            cur_level = cur_level.toString() + '->' + (cur_level+1).toString();
        } else {
            cur_level = cur_level.toString();
        }
        var max_level = obj.get_max_ui_level().toString();
        dialog.widgets['level'].str = dialog.data['widgets']['level']['ui_name'].replace('%d0', cur_level).replace('%d1', max_level);
    } else if(obj.is_building() && obj.is_minefield() && (obj.id in session.minefield_tags_by_obj_id)) {
        dialog.widgets['level'].str = session.minefield_tags_by_obj_id[obj.id];

        dialog.widgets['level'].str += ' ('+gamedata['strings'][obj.is_minefield_armed() ? 'minefield_armed' : 'minefield_not_armed']+')';
    } else if(obj.is_inert() && obj.metadata && ('ui_description' in spec)) {
        dialog.widgets['level'].str = spec['ui_description'].replace('%d', '??');
    } else {
        dialog.widgets['level'].str = '';
    }

    if(dialog_name == 'emplacement_context_menu') {
        var cur_item_name = obj.turret_head_item() || obj.turret_head_inprogress_item();

        if(cur_item_name) {
            var item_spec = ItemDisplay.get_inventory_item_spec(cur_item_name);
            if(item_spec) {
                dialog.widgets['head_title'].str = ItemDisplay.strip_inventory_item_ui_name_level_suffix(ItemDisplay.get_inventory_item_ui_name(item_spec));
                if(item_spec['associated_tech']) {
                    var item_cur_level = item_spec['level']; // note: level of item itself, NOT the tech
                    var tech_max_level = get_max_level(gamedata['tech'][item_spec['associated_tech']]);
                    dialog.widgets['head_level'].show = true;
                    dialog.widgets['head_level'].str = dialog.data['widgets']['level']['ui_name'].replace('%d0', item_cur_level).replace('%d1', tech_max_level);
                }
            }
        } else {
            dialog.widgets['head_title'].str = dialog.data['widgets']['head_title']['ui_name_empty'];
            dialog.widgets['head_level'].show = false;
        }
    }

    if(player.tutorial_state === 'speedup_open_context_menu') {
        // hide all buttons except first
        for(var i = 1; i < buttons.length; i++) {
            dialog.widgets['button'+i.toString()].state = 'disabled';
        }
        if(obj.spec['name'] === gamedata['tutorial'][player.tutorial_state]['target']) {
            advance_tutorial();
        }
    }

    return dialog;
}

/** button description for generic context menu
    @constructor
    @struct
    @param {string} ui_name
    @param {function(SPUI.DialogWidget)|null} onclick
    @param {string|null=} state
    @param {string|null=} ui_tooltip */
function ContextMenuButton(ui_name, onclick, state, ui_tooltip) {
    this.ui_name = ui_name;
    this.onclick = onclick;
    this.state = state || null;
    this.ui_tooltip = ui_tooltip || null;
};

/** @param {!Array.<number>} xy position at which to pop up (screen coordinates)
    @param {Array.<ContextMenuButton>} buttons
    @param {string=} dialog_name from gamedata['dialogs']
    @param {Object.<string, Array.<ContextMenuButton> >=} special_buttons that go in a separately-named widget array, e.g. for turret heads
    @return {SPUI.Dialog} */
function invoke_generic_context_menu(xy, buttons, dialog_name, special_buttons) {
    dialog_name = dialog_name || 'generic_context_menu';
    if(buttons.length < 1 || buttons.length > gamedata['dialogs'][dialog_name]['widgets']['button']['array'][1]) {
        throw Error('bad number of buttons for '+dialog_name+': '+buttons.length.toString());
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs'][dialog_name]);
    dialog.user_data['dialog'] = 'context_menu';
    install_child_dialog(dialog);

    // center the dialog horizontally on xy, and shift it upwards so
    // that the first button is directly underneath the cursor
    var default_button = ('default_button' in dialog.data ? dialog.widgets[dialog.data['default_button']] : dialog.widgets['button0']);
    xy = vec_add(xy, [-Math.floor(dialog.wh[0]/2),Math.floor(-(default_button.xy[1] + default_button.wh[1]/2 + 7))]);
    xy = vec_sub(xy, dialog.get_absolute_xy());

    // resize dialog to fit the proper number of buttons
    var wh = [dialog.wh[0], dialog.data['dimensions'][1] + buttons.length * dialog.data['widgets']['button']['array_offset'][1]];

    // but don't let it go off screen
    if(xy[0] < 0) { xy[0] = 0; }
    if(xy[0] + wh[0] >= canvas_width) { xy[0] = canvas_width - wh[0]; }
    if(xy[1] < 0) { xy[1] = 0; }
    if(xy[1] + wh[1] >= canvas_height) { xy[1] = canvas_height - wh[1]; }
    dialog.xy = xy;
    dialog.wh = wh;
    dialog.widgets['bg'].wh = wh;

    dialog.widgets['bg_close_button'].onclick = close_parent_dialog;

    // play a "click" sound effect
    if(1) {
        var state = GameArt.assets['action_button_resizable'].states['normal'];
        if(state.audio) { state.audio.play(client_time); }
    }

    // fill in buttons
    var button_dict = {'': buttons};
    if(special_buttons) { for(var k in special_buttons) { button_dict[k] = special_buttons[k]; } };

    goog.object.forEach(button_dict, function(buttons, prefix) {
        var i;
        for(i = 0; i < buttons.length; i++) {
            var but = buttons[i];
            var wname = (prefix ? prefix+'_' : '')+'button'+i.toString();
            if(!wname in dialog.widgets) { throw Error('bad wname '+wname); }
            var widget = dialog.widgets[wname];
            if(!but.ui_name) { throw Error('blank ui_name for button on '+dialog_name); }
            widget.str = but.ui_name;
            widget.onclick = (function (_cb) { return function(w) {
                close_parent_dialog(w);
                if(_cb) { _cb(w); }
            }; })(but.onclick);
            widget.state = but.state || 'normal';
            widget.tooltip.str = but.ui_tooltip || null;
        }
        for(; i < dialog.data['widgets'][(prefix ? prefix+'_' : '')+'button']['array'][1]; i++) {
            dialog.widgets[(prefix ? prefix+'_' : '')+'button'+i.toString()].show = false;
        }
    });

    return dialog;
}

/** @constructor */
function Region(data) {
    this.data = data;
    this.dirty = true;
    this.refresh_time = -1;
    this.features = [];

    var terrain_func = (function (_this) { return function(xy) { return _this.obstructs_squads(xy); }; })(this);

    /** @type {?AStar.AStarHexMap} used for pathfinding and collision detection */
    this.occupancy = (data ? new AStar.AStarHexMap(data['dimensions'], terrain_func) : null);
    /** @type {?AStar.AStarContext} used for pathfinding and collision detection */
    this.hstar_context = (data ? new AStar.AStarContext(this.occupancy, {heuristic_name:'manhattan'}) : null);

    /** @type {?RegionMapIndex.RegionMapIndex} used for feature queries */
    this.map_index = (data ? new RegionMapIndex.RegionMapIndex(data['dimensions']) : null);

    this.fresh_cbs = [];
    /** @type {?AJAXMessageQueue} for last server query */
    this.refresh_msg = null;
    this.terrain = (data ? gamedata['region_terrain'][data['terrain']] : null);
    this.contest_rank = null;
}

Region.prototype.map_enabled = function() {
    return this.data && (!('enable_map' in this.data) || this.data['enable_map']);
};

Region.prototype.pvp_level_gap_enabled = function() {
    if(this.data && ('enable_pvp_level_gap' in this.data) && !this.data['enable_pvp_level_gap']) { return false; }
    return true;
};

Region.prototype.turf_points_to_win = function() {
    var total_turf_points = 0;
    this.for_each_feature(function(feature) {
        if(feature['base_type'] == 'quarry') {
            var template = gamedata['quarries_client']['templates'][feature['base_template']];
            if(template && template['turf_points']) {
                total_turf_points += template['turf_points'];
            }
        }
    }, this);
    if(total_turf_points < 1) { // no strongpoints
        return -1;
    }
    return Math.floor(total_turf_points/2.0)+1;
};

Region.prototype.display_turf_standings = function(ui_data) {
    var total_turf_points = 0;
    var points_by_alliance = {};
    var has_all_alliances = true;
    this.for_each_feature(function(feature) {
        if(feature['base_type'] == 'quarry') {
            var template = gamedata['quarries_client']['templates'][feature['base_template']];
            if(template && template['turf_points']) {
                total_turf_points += template['turf_points'];
                if(feature['base_landlord_id'] > 0 && !is_ai_user_id_range(feature['base_landlord_id'])) {
                    var info = PlayerCache.query_sync_fetch(feature['base_landlord_id']);
                    if(info) {
                        if (('alliance_id' in info) && info['alliance_id'] >= 0) {
                            points_by_alliance[info['alliance_id']] = (points_by_alliance[info['alliance_id']]||0) + template['turf_points'];
                        }
                    } else {
                        has_all_alliances = false; // still querying players
                    }
                }
            }
        }
    }, this);
    if(total_turf_points < 1) { return null; }
    if(!has_all_alliances) {
        return ui_data['ui_name_loading'];
    }

    // Google Closure is too smart for its own good, and assumes the return value from getKeys() is always an array of strings
    var alliance_id_list = /** @type {Array.<number>} */ (goog.object.getKeys(points_by_alliance));

    alliance_id_list.sort(function(a,b) {
        var a_rank = points_by_alliance[a], b_rank = points_by_alliance[b];
        if(a_rank > b_rank) {
            return -1;
        } else if(a_rank < b_rank) {
            return 1;
        } else {
            return 0;
        }
    });

    var my_alliance_seen = false;
    var display_list = [];
    var cur_rank = -1, last_points = -1;
    for(var i = 0; i < Math.min(3, alliance_id_list.length); i++) {
        var alliance_id = alliance_id_list[i];
        var points = points_by_alliance[alliance_id];
        var tied = false;
        if(points != last_points) {
            cur_rank += 1;
        } else {
            tied = true;
        }
        if(i < (Math.min(3, alliance_id_list.length) - 1) && points_by_alliance[alliance_id_list[i+1]] == points) {
            tied = true;
        }
        if(alliance_id == session.alliance_id) { my_alliance_seen = true; }
        var alliance_info = AllianceCache.query_info(alliance_id, null);
        if(!alliance_info) { return ui_data['ui_name_loading']; }
        display_list.push(ui_data['ui_name'].replace('%rank', (cur_rank+1).toString()).replace('%tied', (tied ? ui_data['ui_name_tie'] : '')).replace('%alliance', alliance_display_name(alliance_info)).replace('%cur', points.toString()).replace('%max', total_turf_points.toString()));
        last_points = points;
    }

    if(!my_alliance_seen && session.is_in_alliance()) {
        var my_points = points_by_alliance[session.alliance_id] || 0;
        var alliance_info = AllianceCache.query_info_sync(session.alliance_id);
        if(alliance_info) {
            display_list.push(ui_data['ui_name_separator']);
            display_list.push(ui_data['ui_name'].replace('%rank','-').replace('%tied','').replace('%alliance', alliance_display_name(alliance_info)).replace('%cur',my_points.toString()).replace('%max', total_turf_points.toString()));
        }
    }
    return display_list.join('\n');
};

Region.prototype.ping_contest_rank = function() {
    if(!this.data) { return; }
    if(!player.get_event_time('current_event', 'event_quarry_contest', 'inprogress')) { return; }

    query_player_scores([session.user_id], [['quarry_resources','week']],
                        (function (_region) { return function(ids, results) {
                            var result = results[0];
                            if(result) {
                                _region.contest_rank = result[0];
                            }
                        }; })(this), {get_rank:1});
};

Region.prototype.read_terrain = function(xy) {
    var index = xy[1]*this.data['dimensions'][0] + xy[0];
    var enc = this.terrain.charCodeAt(index);
    var raw = enc - 65;
    return raw;
};
Region.prototype.read_climate = function(xy) {
    return gamedata['climates'][gamedata['territory']['tiles'][this.read_terrain(xy)]['climate']];
};
Region.prototype.obstructs_squads = function(xy) {
    return !!this.read_climate(xy)['obstructs_squads'];
};

Region.prototype.in_bounds = function(xy) {
    var dimensions = this.data['dimensions'];
    return (xy[0] >= 0 && xy[0] < dimensions[0] &&
            xy[1] >= 0 && xy[1] < dimensions[1]);
};
Region.prototype.get_neighbors = function(xy) {
    var odd = (xy[1]%2) > 0;
    var ret = [];
    goog.array.forEach([[xy[0]-1,xy[1]], // left
                        [xy[0]+1,xy[1]], // right
                        [xy[0]+odd-1,xy[1]-1], // upper-left
                        [xy[0]+odd,xy[1]-1], // upper-right
                        [xy[0]+odd-1,xy[1]+1], // lower-left
                        [xy[0]+odd,xy[1]+1]],
                       function(loc) {
                           if(this.in_bounds(loc)) {
                               ret.push(loc);
                           }
                       }, this);
    return ret;
};

/** @param {function(Object)} cb
    @param {?=} cb_this */
Region.prototype.for_each_feature = function(cb, cb_this) {
    if(!this.features) { return; }
    goog.array.forEach(this.features, cb, cb_this);
};

Region.prototype.feature_shown = function(feature) {
    if(!('base_map_loc' in feature)) { return false; }
    if(feature['base_type'] == 'hive' && ('base_template' in feature) && (feature['base_template'] in gamedata['hives_client']['templates']) &&
       ('show_if' in gamedata['hives_client']['templates'][feature['base_template']]) &&
       !read_predicate(gamedata['hives_client']['templates'][feature['base_template']]['show_if']).is_satisfied(player,null)) {
        return false;
    }
    return true;
};

// note: just checking for presence of base_map_path is not correct, because sometimes squads
// get to where they're going, and the base_map_path on the server side disappears, but that
// deletion does not make it out to the client, so we may see a stale value.
Region.prototype.feature_is_moving = function(feature) {
    return (('base_map_path' in feature) && feature['base_map_path'] && (feature['base_map_path'][feature['base_map_path'].length-1]['eta'] > server_time));
};

// returns [last_pos, next_pos, alpha] where "alpha" is the fraction of the way from last_pos to next_pos you've traveled
Region.prototype.feature_interpolate_pos = function(feature) {
    if(this.feature_is_moving(feature)) {
        var path = feature['base_map_path'];
        var last_waypoint = path[0];
        for(var i = 1; i < path.length; i++) {
            var waypoint = path[i];
            if(waypoint['eta'] > server_time) {
                var delta = vec_sub(waypoint['xy'], last_waypoint['xy']);
                return [last_waypoint['xy'], waypoint['xy'], (server_time-last_waypoint['eta'])/(waypoint['eta']-last_waypoint['eta'])];
            }
            last_waypoint = waypoint;
        }
    } else {
        return [feature['base_map_loc'], feature['base_map_loc'], 0];
    }
};

Region.prototype.find_own_features_by_type = function(want_type) {
    var ret = [];
    goog.array.forEach(this.features, function(feature) {
        if(feature['base_landlord_id'] == session.user_id && feature['base_type'] == want_type) {
            ret.push(feature);
        }
    }, this);
    return ret;
};

Region.prototype.find_feature_by_id = function(base_id) {
    return this.map_index.get_by_base_id(base_id);
};
Region.prototype.find_home_feature = function() { return this.find_feature_by_id(player.home_base_id); };
Region.prototype.num_quarries_owned = function() {
    return this.find_own_features_by_type('quarry').length;
};

// heuristic only - looks for a feature with same ID and name
Region.prototype.feature_exists = function(base_id, base_ui_name) {
    var feature = this.find_feature_by_id(base_id);
    if(feature && feature['base_ui_name'] == base_ui_name) { return feature; }
    return null;
};
Region.prototype.feature_exists_at = function(base_id, base_ui_name, loc) {
    var feature = this.feature_exists(base_id, base_ui_name);
    if(feature && 'base_map_loc' in feature && feature['base_map_loc'][0] == loc[0] && feature['base_map_loc'][1] == loc[1]) { return feature; }
    return null;
}

/** @param {Array.<number>} cell
  * @param {{include_moving_squads:(boolean|undefined)}} options */
Region.prototype.find_features_at_coords = function(cell, options) {
    var feature_list = [];
    if(cell) {
        /*
        for(var i = 0; i < this.features.length; i++) {
            var f = this.features[i];
            if(!this.feature_shown(f)) { continue; }
            if(!f['base_map_loc']) { continue; }
            if(f['base_map_loc'][0] == cell[0] && f['base_map_loc'][1] == cell[1]) {
                feature_list.push(f);
            }
        }
        */
        feature_list = goog.array.filter(this.map_index.get_by_loc(cell), this.feature_shown, this);
    }

    // special case for player's own moving squads
    if(options && options.include_moving_squads) {
        goog.object.forEach(player.squads, function(squad_data) {
            if(player.squad_is_moving(squad_data['id'])) {
                var feature = this.find_feature_by_id(player.squad_base_id(squad_data['id']));
                if(feature) {
                    var last_next_progress = this.feature_interpolate_pos(feature);
                    // check "last" and "next"
                    for(var i = 0; i < 2; i++) {
                        if(last_next_progress[i][0] == cell[0] && last_next_progress[i][1] == cell[1]) {
                            feature_list.push(feature);
                            break;
                        }
                    }
                }
            }
        }, this);
    }

    return feature_list;
};

// find the "primary" feature at this cell
/** @param {Array.<number>} cell
  * @param {{include_moving_squads:(boolean|undefined)}} options */

Region.prototype.find_feature_at_coords = function(cell, options) {
    var ls = this.find_features_at_coords(cell, options);
    if(ls.length < 1) {
        return null;
    } else if(ls.length == 1) {
        return ls[0];
    } else {
        // prefer anything (quarries) over squads
        var ret = ls[0];
        for(var i = 1; i < ls.length; i++) {
            if(ls[i]['base_type'] != 'squad') {
                ret = ls[i];
            }
        }
        return ret;
    }
};

Region.prototype.squads_nearby = function(cell) {
    var ok = false;

    // next to home base is always OK
    if(hex_distance(player.home_base_loc, cell) == 1) { return true; }

    goog.object.forEach(player.squads, function(squad) {
        if(('map_loc' in squad) && hex_distance(squad['map_loc'], cell) == 1 && !player.squad_is_moving(squad['id'])) {
            ok = true;
        }
    });
    return ok;
};

/** Make sure all features are blocking map properly
 * @param {string} where this was called from */
Region.prototype.check_map_integrity = function(where) {
    var error_count = 0;
    var report_err = function(s, cell, feature) {
        error_count += 1;
        console.log('Map integrity problem ('+where+'): '+s+' : '+
                    ' cell '+(cell ? cell.pos[0].toString()+','+cell.pos[1].toString() : 'null')+
                    ' feature '+(feature ? feature['base_id']+':'+(feature['base_map_loc'] ? feature['base_map_loc'][0].toString()+','+feature['base_map_loc'][1].toString() : 'null') : 'null'));
    };

    this.for_each_feature((function (_this) { return function(feature) {
        if(feature['base_map_loc']) {
            if(_this.feature_is_moving(feature)) {
                var last_waypoint = feature['base_map_path'][feature['base_map_path'].length-1];
                if(!vec_equals(last_waypoint['xy'], feature['base_map_loc'])) {
                    report_err('feature base_map_path endpoint '+last_waypoint['xy'][0].toString()+','+last_waypoint['xy'][1].toString()+' does not match location', null, feature);
                }
            }
            var cell = _this.occupancy.cell(feature['base_map_loc']);
            if(cell.block_count < 1) {
                report_err('feature present but cell.block_count < 1', cell, feature);
            }
            if(!cell.blockers || !goog.array.contains(cell.blockers, feature)) {
                report_err('feature present but cell.blockers does not contain it', cell, feature);
            }
        }
    }; })(this));
    var seen = {};

    this.occupancy.for_each_cell((function (_this) { return function(cell) {
        if(cell.block_count != (cell.blockers ? cell.blockers.length : 0)) {
            report_err('cell block_count '+cell.block_count.toString()+' does not match blockers.length '+cell.blockers.length.toString(), cell, null);
        }
        if(cell.blockers) {
            for(var b = 0; b < cell.blockers.length; b++) {
                var feature = cell.blockers[b];
                if(feature['base_id'] in seen) {
                    var other = seen[feature['base_id']];
                    report_err('feature appears twice in occupancy (also cell '+other.pos[0].toString()+','+other.pos[1].toString()+')', cell, feature);
                    continue;
                }
                seen[feature['base_id']] = cell;
                if(feature != _this.map_index.get_by_base_id(feature['base_id'])) {
                    report_err('feature listed as blocker but not found in index!', cell, feature);
                }
                if(!goog.array.contains(_this.features, feature)) {
                    report_err('feature listed as blocker but not found in this.features!', cell, feature);
                }
            }
        }
    }; })(this));

    if(!error_count) { console.log('integrity check OK! ('+where+')'); }
};

Region.prototype.receive_feature_update = function(res) {
    var feature = this.map_index.get_by_base_id(res['base_id']);

    if(feature) {
        // update or delete
        if(res['DELETED']) {
            if(gamedata['territory']['check_map_integrity'] >= 2) { this.check_map_integrity('receive_feature_update, existing, DELETED, enter'); }

            if(feature['base_map_loc']) {
                // unblock, but do so carefully, because it may never have been blocked in the first place
                this.occupancy.unblock_hex_maybe(feature['base_map_loc'], feature);
            }
            this.map_index.remove(feature['base_id'], feature['base_map_loc']||null, feature);
            goog.array.remove(this.features, feature);

            if(gamedata['territory']['check_map_integrity'] >= 2) { this.check_map_integrity('receive_feature_update, existing, DELETED, exit'); }

        } else {
            if(gamedata['territory']['check_map_integrity'] >= 2) { this.check_map_integrity('receive_feature_update, existing, update, enter'); }

            // for incremental updates, a missing
            // LOCK_STATE or protection timer means that it was dropped
            if('LOCK_STATE' in feature) { delete feature['LOCK_STATE']; }
            if('LOCK_OWNER' in feature) { delete feature['LOCK_OWNER']; }
            if('protection_end_time' in feature) { delete feature['protection_end_time']; }

            var cur_loc = feature['base_map_loc'] || null, new_loc = ('base_map_loc' in res ? res['base_map_loc'] : cur_loc);
            if((!cur_loc && new_loc) ||
               (cur_loc && (!new_loc || cur_loc[0] != new_loc[0] || cur_loc[1] != new_loc[1]))) {

                // XXXXXX check if block_hex assumed invariant still fails sometimes
                if(cur_loc) {
                    this.occupancy.unblock_hex_maybe(cur_loc, feature);
                    //this.occupancy.block_hex(cur_loc, -1, feature);
                }
                this.map_index.remove(feature['base_id'], cur_loc||null, feature);

                if(new_loc) {
                    this.occupancy.block_hex(new_loc, 1, feature);
                }
                this.map_index.insert(feature['base_id'], new_loc||null, feature);
            }

            for(var propname in res) {
                feature[propname] = res[propname]; // might want to delete if null
            }

            if(gamedata['territory']['check_map_integrity'] >= 2) { this.check_map_integrity('receive_feature_update, existing, update, exit'); }
        }
    } else {
        if(res['DELETED']) {
            // could be due to a base that is added and removed before we see it the first time
            if(gamedata['territory']['check_map_integrity'] >= 2) { this.check_map_integrity('receive_feature_update, new, DELETED'); }
        } else {
            if(gamedata['territory']['check_map_integrity'] >= 2) { this.check_map_integrity('receive_feature_update, new, enter'); }
            this.features.push(res);
            if(res['base_map_loc']) {
                this.occupancy.block_hex(res['base_map_loc'],1,res);
            } else {
                //throw Error('received a feature update without base_map_loc! region '+(this.data ? this.data['id'] : 'NULL!')+' base_id '+res['base_id'].toString());
            }
            this.map_index.insert(res['base_id'], res['base_map_loc']||null,res);
            if(gamedata['territory']['check_map_integrity'] >= 2) { this.check_map_integrity('receive_feature_update, new, exit'); }
        }
    }
};

// receive QUARRY_QUERY_RESULT
Region.prototype.receive_update = function(db_time, result, last_db_time) {
    this.dirty = false;
    this.refresh_time = db_time;
    this.refresh_msg = null;

    if(last_db_time > 0) { // incremental result
        for(var i = 0; i < result.length; i++) {
            this.receive_feature_update(result[i]);
        }
        if(gamedata['territory']['check_map_integrity'] >= 1) { this.check_map_integrity('receive_update incremental'); }
    } else {
        this.features = result;
        this.occupancy.clear();
        this.map_index.clear();
        this.for_each_feature((function (_this) { return function(feature) {
            if(feature['base_map_loc']) {
                _this.occupancy.block_hex(feature['base_map_loc'],1,feature);

            } else {
                throw Error('received a feature without base_map_loc! region '+(_this.data ? _this.data['id'] : 'NULL')+' base_id '+feature['base_id'].toString());
            }
            _this.map_index.insert(feature['base_id'], feature['base_map_loc']||null, feature);
        }; })(this));
        if(gamedata['territory']['check_map_integrity'] >= 1) { this.check_map_integrity('receive_update full'); }
    }

    var cblist = this.fresh_cbs;
    this.fresh_cbs = [];
    for(var i = 0; i < cblist.length; i++) {
        cblist[i](this);
    }
};

Region.prototype.refresh = function() {
    if(!this.dirty) { return; }
    if(!this.data) { return; }
    if(query_quarries(null, this.refresh_time)) {
        this.refresh_msg = message_queue; // store reference to the outgoing AJAX message
    }
};
Region.prototype.refresh_progress = function() {
    if(this.refresh_msg) {
        return this.refresh_msg.recv_progress;
    }
    return -1;
};
Region.prototype.call_when_fresh = function(cb) {
    if(!this.dirty) {
        cb(this);
        return true;
    } else {
        this.fresh_cbs.push(cb);
        this.refresh();
        return false;
    }
};

// mode is "squads" or "quarries"
function setup_region_map_feature_list_header(dialog, mode) {
    dialog.user_data['mode'] = mode;
    dialog.user_data['expanded'] = false;
    dialog.user_data['expand_time'] = -1;
    dialog.widgets['label'].str = dialog.data['widgets']['label']['ui_name_'+mode];
    dialog.widgets['bgrect'].onclick = function(w) {
        w.parent.user_data['expanded'] = !w.parent.user_data['expanded'];
        if(w.parent.user_data['expanded']) {
            w.parent.user_data['expand_time'] = client_time;
            // contract other lists
            for(var wname in w.parent.parent.widgets) {
                if(wname.indexOf("_list") != -1) {
                    var v = w.parent.parent.widgets[wname];
                    if(v.user_data['expanded'] && v.user_data['mode'] != w.parent.user_data['mode']) {
                        v.user_data['expanded'] = false;
                    }
                }
            }
        }
    };
    dialog.ondraw = update_region_map_feature_list_header;
}
function update_region_map_feature_list_header(dialog) {
    var mode = dialog.user_data['mode'];
    var feature_list = dialog.user_data['feature_list'] = session.region.find_own_features_by_type((mode == 'squads' ? 'squad' : 'quarry'));
    dialog.widgets['number'].str = feature_list.length.toString();
    for(var i = 0; i < dialog.data['widgets']['element']['array'][1]; i++) {
        var ft = (i < feature_list.length && dialog.user_data['expanded'] ? feature_list[i] : null);
        update_region_map_feature_list_element(dialog.widgets['element'+i.toString()], i, ft);
    }
    dialog.widgets['expand'].show = !dialog.user_data['expanded'];
    dialog.widgets['contract'].show = dialog.user_data['expanded'];
}
function update_region_map_feature_list_element(dialog, i, feature) {
    dialog.user_data['feature'] = feature;
    dialog.show = !!feature;
    if(!feature) { return; }

    if(dialog.parent.user_data['expanded']) {
        var expand_time = dialog.parent.user_data['expand_time'];
        var total_time = dialog.parent.data['widgets']['element']['expand_time']; //  * dialog.parent.user_data['feature_list'].length;
        var progress = clamp((client_time-expand_time)/total_time, 0, 1);
        var end_pos = dialog.parent.data['widgets']['element']['xy'][1] + i*dialog.parent.data['widgets']['element']['array_offset'][1];
        var start_pos = dialog.parent.data['widgets']['element']['xy'][1] - (dialog.parent.user_data['feature_list'].length-i)*dialog.parent.data['widgets']['element']['array_offset'][1];
        dialog.xy = [dialog.xy[0],
                     Math.floor(start_pos + progress*(end_pos-start_pos))];
    }

    dialog.widgets['squad_hp_bar'].show = dialog.widgets['squad_space_bar'].show = (feature['base_type']=='squad');
    dialog.widgets['qicon'].show = dialog.widgets['qsize'].show = (feature['base_type']=='quarry');

    var coords = (feature['base_map_loc'] ? session.region.feature_interpolate_pos(feature)[0] : null);
    dialog.user_data['coords'] = coords;

    dialog.widgets['coords'].str = (coords ? dialog.data['widgets']['coords']['ui_name'].replace('%x', coords[0].toString()).replace('%y', coords[1].toString()) : dialog.data['widgets']['coords']['ui_name_unknown']);

    var onclick = (function (_dialog) { return function(w) {
        var feature = _dialog.user_data['feature'];
        var coords = _dialog.user_data['coords'];
        var mapwidget = _dialog.parent.parent.widgets['map'];
        mapwidget.follow_travel = false;
        if(coords) {
            mapwidget.pan_to_cell(coords, {slowly:true, with_zoom:true});
            // note: re-find the feature here, in case it's a squad stationed at a quarry
            mapwidget.select_feature_at(coords);
        }
    }; })(dialog);

    dialog.widgets['bgrect'].onclick = onclick;

    if(feature['base_type'] == 'squad') {
        var squad_id = parseInt(feature['base_id'].split('_')[1],10);
        var squad_data = player.squads[squad_id.toString()] || {};
        var stats = player.get_squad_hp_and_space(squad_id);
        dialog.widgets['name'].str = (squad_data['ui_name'] ? squad_data['ui_name'] : gamedata['strings']['regional_map']['unknown_name']);

        dialog.widgets['icon'].widgets['icon'].transform = null;
        unit_icon_set(dialog.widgets['icon'], feature['base_icon'], 1, null, onclick, null);
        dialog.widgets['icon'].widgets['frame'].tooltip.str = null; // don't want a tooltip

        dialog.widgets['squad_space_bar'].progress = stats['cur_space'] / Math.max(stats['max_space'],1);
        dialog.widgets['squad_hp_bar'].progress = (stats['max_hp'] > 0 ? (stats['cur_hp']/stats['max_hp']) : 0);
    } else if(feature['base_type'] == 'quarry') {
        unit_icon_set(dialog.widgets['icon'], null, -1, null, null, 'normal');
        dialog.widgets['icon'].widgets['icon'].show = dialog.widgets['icon'].widgets['frame'].show = true;
        dialog.widgets['icon'].widgets['icon'].asset = 'region_tiles';
        dialog.widgets['icon'].widgets['icon'].state = 'quarry_'+feature['base_icon'];
        // hack - shrink the icon to fit
        dialog.widgets['icon'].widgets['icon'].transform = [0.66,0,0,0.66,8,10];

        dialog.widgets['icon'].widgets['frame'].onclick = onclick;
        dialog.widgets['name'].str = (feature['base_ui_name'] ? feature['base_ui_name'] : gamedata['strings']['regional_map']['unknown_base']);
        dialog.widgets['qicon'].bg_image = 'resource_icon_'+feature['base_icon'];
        var RICHNESS = gamedata['strings']['regional_map']['richness'];
        var rich_str = '?';
        for(var r = 0; r < RICHNESS.length; r++) {
            if(feature['base_richness'] >= RICHNESS[r][0]) {
                rich_str = RICHNESS[r][1];
            } else { break; }
        }
        dialog.widgets['qsize'].str = rich_str;
    } else {
        throw Error('unhandled base_type '+feature['base_type']);
    }
}

/** @param {Array.<number>=} target_loc */
function invoke_region_map(target_loc) {
    change_selection_ui(null);
    if(!player.get_any_abtest_value('enable_region_map', gamedata['enable_region_map'])) { return null; }
    if(!read_predicate(player.get_any_abtest_value('quarry_requirement', gamedata['territory']['quarry_requirement'])).is_satisfied(player, null)) { return null; }
    if(!session.home_base) { return null; }
    if(!session.region.data) { return null; }
    if(!session.region.map_enabled()) { return null; }
    if(resolve_region_map_building_problem()) { return null; }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['region_map_dialog']);
    dialog.user_data['dialog'] = 'region_map_dialog';
    dialog.user_data['first_fetch'] = false;
    dialog.user_data['last_map_ping_time'] = -1;
    dialog.user_data['hive_finder_state'] = region_map_finder_state_init();
    dialog.user_data['strongpoint_finder_state'] = region_map_finder_state_init();
    dialog.user_data['attacker_finder_state'] = region_map_finder_state_init();
    dialog.user_data['recent_attacker_ids'] = null; // for attacker finder

    dialog.user_data['refresh_text_start_time'] = -1;
    dialog.user_data['refresh_text_start_step'] = 0;

    change_selection_ui(dialog);
//    dialog.auto_center();
    dialog.modal = false; // !
    dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };
    dialog.widgets['map'].set_region(session.region);
    dialog.widgets['map'].gfx_detail = SPFX.detail;
    dialog.widgets['refresh_button'].state = 'disabled';
    dialog.widgets['refresh_button'].onclick = function(w) {
        session.region.dirty = true;
        w.parent.user_data['refresh_text_start_time'] = -1;

        session.region.call_when_fresh((function (_w) { return function() {
            var dialog = _w.parent;
            if(dialog) {
                if(!dialog.user_data['first_fetch']) {
                    // on manual clicks of refresh button, clear the PlayerCache (except for yourself) to get rid of stale info
                    PlayerCache.clear_all_except(session.user_id);
                    PlayerCache.force_fetch(session.user_id); // request fresh update of yourself immediately
                }

                // need this to snap to home location on first open of the Regional Map
                if(!dialog.user_data['first_fetch'] &&
                   dialog.widgets['map'].follow_travel) {
                    dialog.widgets['map'].go_home();
                    dialog.user_data['first_fetch'] = true;
                }
                dialog.user_data['refresh_text_start_time'] = client_time;
                dialog.user_data['refresh_text_start_step'] = 0;
            }
        }; })(w));
    }
    dialog.widgets['home_button'].onclick = function(w) {
        var dialog = w.parent;
        dialog.widgets['map'].follow_travel = false;
        dialog.widgets['map'].go_home({do_select:true, slowly:true, with_zoom:true});
    }
    dialog.widgets['manage_squads_button'].onclick = function(w) {
        do_invoke_squad_control('manage', null);
    };
    dialog.widgets['bookmarks_button'].onclick = function(w) {
        var dialog = w.parent;
        invoke_map_bookmarks_dialog(dialog.widgets['map']);
    };
    dialog.widgets['map'].set_zoom_buttons(dialog.widgets['zoom_in_button'], dialog.widgets['zoom_out_button']);

    if(session.region.data['storage'] == 'nosql') {
        setup_region_map_feature_list_header(dialog.widgets['squad_list'], 'squads');
    } else {
        dialog.widgets['squad_list'].show =
            dialog.widgets['help_button'].show =
            dialog.widgets['help_jewel'].show =
            dialog.widgets['manage_squads_button'].show = false;
    }
    setup_region_map_feature_list_header(dialog.widgets['quarry_list'], 'quarries');

    dialog.widgets['battle_history_button'].onclick = function(w) { invoke_battle_history_dialog(session.user_id, -1, '', -1, w); };
    dialog.widgets['battle_history_jewel'].ondraw = update_notification_jewel;
    dialog.widgets['help_button'].onclick = function(w) { invoke_region_map_help(); };
    dialog.widgets['help_jewel'].ondraw = update_notification_jewel;

    dialog.ondraw = update_region_map;
    map_dialog_default_page = 'quarries';

    if(target_loc) {
        dialog.widgets['map'].follow_travel = false;
        dialog.widgets['map'].pan_to_cell(target_loc);
    }

    // check for token event
    var sched = player.get_event('current_event', null, player.get_absolute_time(), true);
    if(sched) {
        var event = gamedata['events'][sched['name']];
        if('token_item' in event) {
            dialog.widgets['map'].token_icon = gamedata['items'][event['token_item']]['store_icon'];
        }
    }

    if(player.get_any_abtest_value('region_map_scroll_help', gamedata['territory']['scroll_help']) &&
       !player.check_feature_use('region_map_scroll_help_closed')) {
        invoke_region_map_scroll_help(dialog);
    }
    return dialog;
}

function invoke_region_map_scroll_help(parent) {
    player.record_feature_use('region_map_scroll_help');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['region_map_scroll_help']);
    dialog.user_data['dialog'] = 'region_map_scroll_help';
    dialog.user_data['map_widget'] = parent.widgets['map'];
    dialog.modal = false;
    install_child_dialog(dialog);
    dialog.ondraw = update_region_map_scroll_help;
    dialog.widgets['close_button'].onclick = function(w) {
        close_parent_dialog(w);
        player.record_feature_use('region_map_scroll_help_closed');
    }
    return dialog;
}
function update_region_map_scroll_help(dialog) {
    if(dialog.user_data['map_widget'].parent) {
        // center on parent dialog's map widget
        dialog.xy = vec_add(dialog.user_data['map_widget'].xy,
                            vec_floor(vec_scale(0.5, vec_sub(vec_mul([1,0.66], dialog.user_data['map_widget'].wh), dialog.wh))));
    }
}

// if a home_base_relocator_anywhere item is availble, return a function that will open the Store to it, otherwise null
/** @param {Array.<Object>=} skulist
    @param {Array.<Object>=} path */
function continent_bridge_available(skulist, path) {
    if(!skulist) { skulist = gamedata['store']['catalog']; }
    if(!path) { path = []; }

    for(var i = 0; i < skulist.length; i++) {
        var entry = skulist[i];
        if('skus' in entry) {
            var b = continent_bridge_available(entry['skus'], path.concat(entry));
            if(b) { return b; }
        } else if('item' in entry && entry['item'] == 'home_base_relocator_anywhere') {
            // found it
            console.log("HERE"); console.log(entry);
            return (function (_path) { return function() { invoke_new_store_category(_path[_path.length-1], (_path.length>1 ? _path.slice(0,_path.length-1) : null)); }; })(path);
        }
    }
    return null;
}

function invoke_find_on_map(region_id, target_loc) {
    if(!(region_id in gamedata['regions'])) { return; }
    if(session.region.data && session.region.data['id'] == region_id) {
        // in same region
        if(target_loc[0] >= 0 && target_loc[0] < session.region.data['dimensions'][0] &&
           target_loc[1] >= 0 && target_loc[1] < session.region.data['dimensions'][1]) {
            if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] === 'region_map_dialog') {
                // map dialog up, just move it there
                selection.ui.widgets['map'].pan_to_cell(target_loc, {slowly:1});
            } else {
                // map dialog not up
                invoke_region_map(target_loc);
            }
        }
    } else {
        // not in same region, prompt to relocate.
        var reg = gamedata['regions'][region_id];
        var pred_ok = ((!('show_if' in reg) || read_predicate(reg['show_if']).is_satisfied(player,null)) &&
                       (!('requires' in reg) || read_predicate(reg['requires']).is_satisfied(player,null)));
        if(pred_ok) {
            // reuse the code from the building context menu
            var btn = [];
            add_change_region_button(btn);
            var s = gamedata['strings']['find_in_different_region'];
            invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%region', gamedata['regions'][region_id]['ui_name']),
                                        {'dialog': 'message_dialog_big',
                                         'cancel_button':true, 'close_button':true,
                                         'ok_button_ui_name': s['ui_button'],
                                         'on_ok': btn[0].onclick,
                                         'ok_button_state': btn[0].state || 'normal',
                                         'ok_button_tooltip':btn[0].ui_tooltip});
        } else {
            // different continent
            var bridge = continent_bridge_available();
            if(bridge) {
                var s = gamedata['strings']['find_in_different_region_locked_bridge'];
                invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%region', gamedata['regions'][region_id]['ui_name']),
                                            {'dialog': 'message_dialog_big'});
                // link to store:
//                                            {'dialog': 'message_dialog_big', 'close_button':true, 'cancel_button': true,
//                                             'ok_button_ui_name': s['ui_button'], 'on_ok': bridge});
            } else {
                var s = gamedata['strings']['find_in_different_region_locked'];
                invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%region', gamedata['regions'][region_id]['ui_name']),
                                            {'dialog': 'message_dialog_big'});
            }
        }
    }
}

function toggle_region_map() {
    if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] === 'region_map_dialog') {
        change_selection_ui(null);
    } else {
        invoke_region_map();
    }
}

function update_region_map(dialog) {
    update_map_dialog_header_buttons(dialog);
    dialog.widgets['battle_history_jewel'].user_data['count'] = player.new_battle_histories;
    dialog.widgets['help_jewel'].user_data['count'] = (player.check_feature_use('region_map_help') ? 0 : 1);

    var ok_to_send_query = (last_quarry_query_time == -1 ||
                            (last_quarry_query_time > 0 && client_time > (last_quarry_query_time+gamedata['rival_query_cooldown'])));

    dialog.widgets['refresh_button'].state = ok_to_send_query ? 'normal' : 'disabled';

    if(last_quarry_query_time == -1 || session.region.dirty) {
        // start initial refresh
        dialog.widgets['refresh_button'].onclick(dialog.widgets['refresh_button']);
    }

    if(!gamedata['client']['enable_ajax_longpoll'] && last_quarry_query_time > 0 && ok_to_send_query && gamedata['client']['map_ping_interval'] > 0) {
        if(client_time - dialog.user_data['last_map_ping_time'] >= gamedata['client']['map_ping_interval']) {
            dialog.user_data['last_map_ping_time'] = client_time;
            send_to_server.func(["PING_MAP"]);
        }
    }

    // show "Loading..." only during true query latency
    dialog.widgets['loading_rect'].show =
        dialog.widgets['loading_text'].show =
        dialog.widgets['loading_spinner'].show = (last_quarry_query_time == 0);

    if(dialog.widgets['loading_text'].show) {
        var prog = session.region.refresh_progress();
        if(prog >= 0) {
            prog = Math.min(prog, 0.99);
            dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name_progress'].replace('%pct', (100.0*prog).toFixed(0));
        } else {
            dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name'];
        }
    }

    dialog.widgets['refresh_text'].show = !dialog.widgets['loading_rect'].show;
    if(dialog.widgets['refresh_text'].show) {
        if(dialog.user_data['refresh_text_start_time'] < 0) {
            dialog.user_data['refresh_text_start_time'] = client_time;
            dialog.user_data['refresh_text_start_step'] = 0;
        }
        var t = client_time - dialog.user_data['refresh_text_start_time'];
        var step = Math.floor(t / dialog.data['widgets']['refresh_text']['update_interval']) + dialog.user_data['refresh_text_start_step'];
        var words = dialog.data['widgets']['refresh_text']['ui_name_anim'].split('|');
        if(step < 0 || step >= words.length) {
            dialog.user_data['refresh_text_start_time'] = client_time;
            dialog.user_data['refresh_text_start_step'] = Math.floor(Math.random()*dialog.data['widgets']['refresh_text']['random_skip']);
            step = 0;
        }
        dialog.widgets['refresh_text'].str = words[step];
    }

    // update header/footer
    var region_name = session.region.data['ui_name'];
    var cursor_coords = (dialog.widgets['map'].hovercell ? '('+dialog.widgets['map'].hovercell[0].toString()+','+dialog.widgets['map'].hovercell[1].toString()+')' : '');
    goog.array.forEach(['region_name','cursor_coords'], function(wname) {
        dialog.widgets[wname].str = dialog.data['widgets'][wname]['ui_name'].replace('%REGION', region_name).replace('%CURSOR', cursor_coords);
    });

    if(session.region.data['enable_turf_control']) {
        var points_to_win = session.region.turf_points_to_win();
        if(points_to_win > 0) {
        // find last turf winner
        var turf_leader = AllianceCache.turf_get_leader_by_region(session.region.data['id']);
        var turf_leader_info = null;
        if(turf_leader && turf_leader['alliance_id'] >= 0) {
            turf_leader_info = AllianceCache.query_info(turf_leader['alliance_id'], null);
        }
        dialog.widgets['turf_winner'].show = true; // !!turf_winner_alliance;
        if(dialog.widgets['turf_winner'].show) {
            if(turf_leader_info && turf_leader['points'] >= points_to_win) {
                // clear winner
                dialog.widgets['turf_winner'].str = dialog.data['widgets']['turf_winner']['ui_name'].replace('%s', alliance_display_name(turf_leader_info));
                dialog.widgets['turf_winner'].text_color = SPUI.make_colorv(dialog.data['widgets']['turf_winner']['text_color']);
                dialog.widgets['turf_winner'].onclick = (function (_id) { return function() { invoke_alliance_info(_id); }; })(turf_leader['alliance_id']);
            } else if(turf_leader && turf_leader['points'] >= points_to_win) {
                // tie
                dialog.widgets['turf_winner'].str = dialog.data['widgets']['turf_winner']['ui_name_tie'].replace('%d', turf_leader['points'].toString());
                dialog.widgets['turf_winner'].text_color = SPUI.make_colorv(dialog.data['widgets']['turf_winner']['text_color_tie']);
                dialog.widgets['turf_winner'].onclick = null;
            } else {
                // nobody crossed the threshold
                dialog.widgets['turf_winner'].str = dialog.data['widgets']['turf_winner']['ui_name_insufficient_points'].replace('%d', points_to_win.toString());
                dialog.widgets['turf_winner'].text_color = SPUI.make_colorv(dialog.data['widgets']['turf_winner']['text_color_insufficient_points']);
                dialog.widgets['turf_winner'].onclick = null;
            }
        }

        var next_check = AllianceCache.turf_get_next_check_by_region(session.region.data['id']);
        dialog.widgets['turf_standings_label'].show = (next_check > 0);
        if(next_check > 0) {
            var soon_minutes = dialog.data['widgets']['turf_standings_label']['soon_minutes'];
            var togo_min = Math.ceil((next_check - server_time)/60.0);
            togo_min = Math.max(togo_min, soon_minutes);
            if(togo_min <= soon_minutes) {
                dialog.widgets['turf_standings_label'].str = dialog.data['widgets']['turf_standings_label']['ui_name_soon'].replace('%d', soon_minutes.toFixed(0));
            } else {
                dialog.widgets['turf_standings_label'].str = dialog.data['widgets']['turf_standings_label']['ui_name'].replace('%d', togo_min.toFixed(0));
            }

            dialog.widgets['turf_standings'].show = true;
            dialog.widgets['turf_standings'].str = session.region.display_turf_standings(dialog.data['widgets']['turf_standings']);
        }
    } }

    dialog.widgets['hover_alliance'].show = (dialog.widgets['map'].hover_alliance >= 0 && dialog.widgets['map'].zoom < gamedata['territory']['tile_fade_zoom'][0]);
    if(dialog.widgets['hover_alliance'].show) {
        var alinfo = AllianceCache.query_info(dialog.widgets['map'].hover_alliance);
        var name = (alinfo && ('ui_name' in alinfo)) ? alliance_display_name(alinfo) : '';
        dialog.widgets['hover_alliance'].str = dialog.data['widgets']['hover_alliance']['ui_name'].replace('%ALLIANCE', name);
        dialog.widgets['hover_alliance'].text_color = SPUI.make_colorv(gamedata['territory']['influence']['hover_alliance_'+(dialog.widgets['map'].hover_alliance == session.alliance_id ? 'friendly' : 'hostile')]['label_color']);
    }

    // update bookmarks state
    dialog.widgets['bookmarks_button'].state = ((dialog.widgets['map'].region && (dialog.widgets['map'].region.data['id'] in player.map_bookmarks) && (player.map_bookmarks[dialog.widgets['map'].region.data['id']].length >= 1)) ? 'normal' : 'disabled');

    region_map_finder_update(dialog, 'hive_finder', dialog.user_data['hive_finder_state']);
    region_map_finder_update(dialog, 'strongpoint_finder', dialog.user_data['strongpoint_finder_state']);
    region_map_finder_update(dialog, 'attacker_finder', dialog.user_data['attacker_finder_state']);

    // dynamic resizing, making room for chat
    var console_shift = get_console_shift();
    dialog.wh = vec_max(vec_floor(vec_scale(0.9, [canvas_width-console_shift, canvas_height])), dialog.data['min_dimensions']);
    dialog.widgets['bg'].wh = dialog.wh;
    dialog.apply_layout();
//    dialog.auto_center();
    dialog.xy = vec_floor(vec_add(vec_scale(0.05, [canvas_width,canvas_height]), [Math.floor(console_shift),0]));
    dialog.on_resize();
}

function region_map_finder_state_init() { return {'time':-1, 'found':null, 'index':-1, 'pred':null}; };
function region_map_finder_update(dialog, kind, state) {
    // hive/attacker finder button
    if(!player.get_any_abtest_value('region_map_'+kind, gamedata['territory'][kind])) { return; }

    if(kind == 'attacker_finder') {
        // send battle history query
        if(dialog.user_data['recent_attacker_ids'] === null ||
           dialog.user_data['recent_attacker_ids']['pending']) {
            dialog.widgets[kind+'_spinner'].show = true;
            if(dialog.user_data['recent_attacker_ids'] === null) {
                dialog.user_data['recent_attacker_ids'] = {'pending':1};
                query_battle_history(null, session.user_id, (function (_dialog) { return function(sumlist) {
                    _dialog.user_data['recent_attacker_ids'] = {};
                    goog.array.forEach(sumlist, function(summary) {
                        var other_id = ((summary['attacker_id'] == session.user_id) ? summary['defender_id'] : summary['attacker_id']);
                        if(other_id && !is_ai_user_id_range(other_id)) {
                            _dialog.user_data['recent_attacker_ids'][other_id] = 1;
                        }
                    });
                }; })(dialog));
            }
            return;
        } else {
            dialog.widgets[kind+'_spinner'].show = false;
        }
    }

    // clear state if enough time has passed
    if(client_time - state['time'] >= gamedata['territory']['finder_reset_time']) {
        state['time'] = -1;
        state['index'] = -1;
//        state['found'] = null; // rescan?
//        state['pred'] = null;
    }

    if(state['found'] === null && !session.region.dirty) {
        state['found'] = [];

        dialog.widgets['map'].region.for_each_feature(function(f) {
            var found = null;

            // hive: attackable hive with ui_tokens
            if(kind == 'hive_finder') {
                if(f['base_type'] == 'hive' && ('base_template' in f) && (f['base_template'] in gamedata['hives_client']['templates']) &&
                   gamedata['hives_client']['templates'][f['base_template']]['ui_tokens']) {
                    var pred = (!player.is_cheater && ('activation' in gamedata['hives_client']['templates'][f['base_template']]) ? read_predicate(gamedata['hives_client']['templates'][f['base_template']]['activation']) : null);
                    if(pred && !pred.is_satisfied(player, null)) {
                        // locked
                        state['pred'] = pred;
                        return;
                    }
                    // unlocked
                    found = f;
                }
            } else if(kind == 'strongpoint_finder') {
                if(f['base_landlord_id'] != session.user_id &&
                   f['base_type'] == 'quarry' && ('base_template' in f) && (f['base_template'] in gamedata['quarries_client']['templates']) &&
                   gamedata['quarries_client']['templates'][f['base_template']]['turf_points']) {

                    if(session.is_in_alliance()) {
                        var info = PlayerCache.query_sync_fetch(f['base_landlord_id']);
                        if(info && ('alliance_id' in info) && info['alliance_id'] == session.alliance_id) {
                            return; // owned by alliancemate
                        }
                    }

                    var pred = (!player.is_cheater && ('activation' in gamedata['quarries_client']['templates'][f['base_template']]) ? read_predicate(gamedata['quarries_client']['templates'][f['base_template']]['activation']) : null);
                    if(pred && !pred.is_satisfied(player, null)) {
                        // locked
                        state['pred'] = pred;
                        return;
                    }
                    // unlocked
                    found = f;
                }
            } else if(kind == 'attacker_finder') {
                // attacker: someone who attacked us recently
                if(f['base_type'] == 'home' && f['base_landlord_id'] && (f['base_landlord_id'] in dialog.user_data['recent_attacker_ids'])) {
                    found = f;
                }
            }

            if(found) {
                state['found'].push(f);
            }
        });

        // sort in order of distance to home base
        state['found'].sort(function(a, b) {
            var da = vec_length2(vec_sub(a['base_map_loc'], player.home_base_loc));
            var db = vec_length2(vec_sub(b['base_map_loc'], player.home_base_loc));
            if(da < db) {
                return -1;
            } else if(da > db) {
                return 1;
            } else {
                return 0;
            }
        });
    }

    dialog.widgets[kind].show = ((state['found'] !== null && state['found'].length > 0) || !!state['pred']);
    if(dialog.widgets[kind].show) {
        if(state['found'] !== null && state['found'].length > 0) {
            // valid base
            dialog.widgets[kind].state = (kind == 'attacker_finder' ? dialog.data['widgets'][kind]['state'] : 'normal');
            dialog.widgets[kind].tooltip.str = dialog.data['widgets'][kind]['ui_tooltip'];
            player.record_feature_use(kind+'_seen');
            dialog.widgets[kind].onclick = (function (_kind, _state) { return function(w) {
                player.record_feature_use(_kind+'_used');
                var dialog = w.parent;
                var idx = (_state['index']+1) % _state['found'].length;
                var feature = _state['found'][idx];
                // record state so we don't find it again for a while
                _state['time'] = client_time;
                _state['index'] = idx;
                dialog.widgets['map'].follow_travel = false;
                dialog.widgets['map'].pan_to_cell(feature['base_map_loc'], {slowly:true, with_zoom:false});
                dialog.widgets['map'].select_feature_at(feature['base_map_loc']);
            }; })(kind, state);
        } else {
            // all locked
            dialog.widgets[kind].tooltip.str = dialog.data['widgets'][kind]['ui_tooltip_locked'].replace('%s', state['pred'].ui_describe(player, null));
            var helper = get_requirements_help(state['pred'], null);
            if(helper) {
                dialog.widgets[kind].state = 'disabled_clickable';
                dialog.widgets[kind].onclick = (function (_helper) { return function(w) { _helper(); }; })(helper);
            } else {
                dialog.widgets[kind].state = 'disabled';
            }
        }
    }
}

function update_map_dialog_header_buttons(dialog) {
    dialog.widgets['computers_button'].onclick = function(w) {
        if(w.parent && w.parent.user_data['dialog'] == 'map_dialog') {
            if(w.parent.user_data['chapter'] != 'computers') { map_dialog_change_page(w.parent, 'computers', 0); }
        } else {
            invoke_map_dialog('computers');
        }
    };
    dialog.widgets['computers_button'].state = ((dialog.user_data['dialog'] == 'map_dialog' && dialog.user_data['chapter'] == 'computers') ? 'active' : 'normal');

    // RIVALS button
    var pvp_pred = read_predicate({'predicate':'LIBRARY', 'name':'pvp_requirement'});
    if(!pvp_pred.is_satisfied(player,null)) {
        dialog.widgets['rivals_button'].show = true;
        dialog.widgets['rivals_button'].state = 'disabled_clickable';
        var ui_req = pvp_pred.ui_describe(player);
        dialog.widgets['rivals_button'].tooltip.str = (ui_req ? gamedata['strings']['unmet_requirements'].replace('%s', ui_req) : null);
        dialog.widgets['rivals_button'].tooltip.text_color = SPUI.error_text_color;
        dialog.widgets['rivals_button'].onclick = get_requirements_help(pvp_pred);
    } else {
        dialog.widgets['rivals_button'].show = (player.is_legacy_pvp_player() || player.is_ladder_player());
        if(dialog.widgets['rivals_button'].show) {
            dialog.widgets['rivals_button'].state = (dialog.user_data['dialog'] == 'map_ladder_pvp_dialog' || (dialog.user_data['dialog'] == 'map_dialog' && dialog.user_data['chapter'] == 'rivals') ? 'active' : 'normal');
            dialog.widgets['rivals_button'].onclick = function(w) {
                if(w.parent.user_data['dialog'] == 'map_ladder_pvp_dialog') {
                    return;
                } else if(player.is_ladder_player()) {
                    invoke_map_ladder_pvp();
                } else if(w.parent.user_data['dialog'] != 'map_dialog') {
                    invoke_map_dialog('rivals');
                } else if(w.parent.user_data['dialog']['chapter'] != 'rivals') {
                    map_dialog_change_page(w.parent, 'rivals', 0);
                }
            }
        }
    }

    // REGIONAL MAP button
    dialog.widgets['quarries_button'].show = !!(player.get_any_abtest_value('enable_region_map', gamedata['enable_region_map']) && !dialog.widgets['rivals_button'].show);
    if(dialog.widgets['quarries_button'].show) {
        var quarry_pred = read_predicate(player.get_any_abtest_value('quarry_play_requirement', gamedata['territory']['quarry_play_requirement']));
        var can_view_quarries = quarry_pred.is_satisfied(player, null);

        dialog.widgets['quarries_button'].state = (dialog.user_data['dialog'] == 'region_map_dialog' ? 'active' : (can_view_quarries ? 'normal' : 'disabled_clickable'));
        if(dialog.user_data['dialog'] == 'region_map_dialog') {
            dialog.widgets['quarries_button'].onclick = null;
            dialog.widgets['quarries_button'].tooltip.str = null;
        } else if(can_view_quarries) {
            dialog.widgets['quarries_button'].onclick = function() { invoke_region_map(); };
            dialog.widgets['quarries_button'].tooltip.str = null;
        } else {
            dialog.widgets['quarries_button'].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['quarries_button'].tooltip.str = gamedata['spells']['SHOW_REGIONAL_MAP']['ui_tooltip_unmet'].replace('%s', quarry_pred.ui_describe(player));
            dialog.widgets['quarries_button'].onclick = get_requirements_help(quarry_pred);
        }
    }

    if(dialog.widgets['rivals_button'].show == dialog.widgets['quarries_button'].show) {
        log_exception(null, 'quarries/rivals buttons not mutually exclusive! shown: '+dialog.widgets['rivals_button'].show.toString()+' legacy: '+player.is_legacy_pvp_player().toString()+' ladder: '+player.is_ladder_player().toString()+' map_enabled: '+session.region.map_enabled().toString());
    }

    // HITLIST button
    if(('hitlist_show_if' in gamedata['predicate_library']) &&
       read_predicate({'predicate':'LIBRARY', 'name':'hitlist_show_if'}).is_satisfied(player, null)) {
        dialog.widgets['hitlist_button'].show = dialog.widgets['hitlist_warning_text'].show = true;
        var hitlist_pred = ('hitlist_requirement' in gamedata['predicate_library'] ? read_predicate({'predicate':'LIBRARY', 'name':'hitlist_requirement'}) : null);
        if(hitlist_pred && !hitlist_pred.is_satisfied(player,null)) {
            dialog.widgets['hitlist_button'].state = 'disabled_clickable';
            dialog.widgets['hitlist_button'].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['hitlist_button'].tooltip.str = dialog.data['widgets']['hitlist_button']['ui_tooltip_unmet'].replace('%s', hitlist_pred.ui_describe(player));
            dialog.widgets['hitlist_button'].onclick = get_requirements_help(hitlist_pred);
        } else {
            dialog.widgets['hitlist_button'].state = ((dialog.user_data['dialog'] == 'map_dialog' && dialog.user_data['chapter'] == 'hitlist') ? 'active' : 'normal');
            dialog.widgets['hitlist_button'].tooltip.text_color = SPUI.default_text_color;
            dialog.widgets['hitlist_button'].tooltip.str = dialog.data['widgets']['hitlist_button']['ui_tooltip'];
            dialog.widgets['hitlist_button'].onclick = function(w) {
                if(w.parent && w.parent.user_data['dialog'] == 'map_dialog') {
                    if(w.parent.user_data['chapter'] != 'hitlist') { map_dialog_change_page(w.parent, 'hitlist', 0); }
                } else {
                    invoke_map_dialog('hitlist');
                }
            };
        }
    } else {
        dialog.widgets['hitlist_button'].show = dialog.widgets['hitlist_warning_text'].show = false;
    }

    // disable irrelevant buttons during tutorial
    if(player.tutorial_state != "COMPLETE") {
        dialog.widgets['hitlist_button'].state =
            dialog.widgets['quarries_button'].state =
            dialog.widgets['rivals_button'].state = 'disabled';
    }
}

function invoke_map_ladder_pvp() {
    var template = 'map_ladder_pvp_dialog';
    var transition = false;
    if((template+'_'+gamedata['game_id']) in gamedata['dialogs']) {
        template = template+'_'+gamedata['game_id'];
        transition = true;
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs'][template]);
    dialog.user_data['dialog'] = 'map_ladder_pvp_dialog';
    dialog.user_data['transition'] = transition;
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };

    dialog.widgets['text1a'].str = dialog.data['widgets']['text1a']['ui_name'].replace('%GAME', gamedata['strings']['game_name']);
    map_dialog_default_page = 'rivals';
    dialog.ondraw = update_map_ladder_pvp_dialog;
    return dialog;
}

function update_map_ladder_pvp_dialog(dialog) {
    update_map_dialog_header_buttons(dialog);
    if(dialog.user_data['transition']) {
        // TEMPORARY TR ladder->map transition version
        var btn = [];
        add_change_region_button(btn); // reuse the code from the building context menu
        dialog.widgets['relocate_button'].onclick = btn[0].onclick;
        dialog.widgets['relocate_button'].state = btn[0].state || 'normal';
        dialog.widgets['relocate_button'].tooltip.str = btn[0].ui_tooltip;
    }

    // update fight button based on how many resources the user now has and their army size
    var has_cost = (gamedata['matchmaking']['ladder_match_life'] < 0);
    // show price when rival querying is mandatory (SG)

    var missing_res = null, missing_res_amount = 0;
    if(has_cost) {
        dialog.widgets['fight_button'].xy = dialog.data['widgets']['fight_button']['xy_priced'];

        var cost = eval_cond_or_literal(gamedata['matchmaking']['ladder_match_switch_cost'], player, null);
        for(var res in cost) {
            // note: can't display multiple resources
            dialog.widgets['ladder_switch_price_icon'].asset = gamedata['resources'][res]['icon_small'];
            dialog.widgets['ladder_switch_price'].str = pretty_print_number(cost[res]);
        }
        for(var res in cost) {
            if(player.resource_state[res][1] < cost[res]) {
                missing_res = res;
                missing_res_amount = cost[res] - player.resource_state[res][1];
                break;
            }
        }
    }

    if(has_cost && goog.object.getCount(player.my_army) < 1) {
        dialog.widgets['fight_button'].state = 'disabled_clickable';
        dialog.widgets['fight_button'].onclick = function() {
            var s = gamedata['strings']['ladder_switch_no_army'];
            invoke_message_dialog(s['ui_title'], s['ui_description'], {'dialog':'message_dialog_big'});
        };
    } else if(!missing_res) {
        dialog.widgets['fight_button'].state = 'normal';
        dialog.widgets['fight_button'].onclick = function() { do_visit_base(-1, {ladder_battle:1}); };
    } else {
        dialog.widgets['fight_button'].state = 'disabled_clickable';
        dialog.widgets['fight_button'].onclick = get_requirements_help(missing_res, missing_res_amount);
    }

    if('ladder_switch_price' in dialog.widgets) {
        dialog.widgets['ladder_switch_price_icon'].show =
            dialog.widgets['ladder_switch_price'].show = has_cost;
        dialog.widgets['ladder_switch_price'].onclick = dialog.widgets['fight_button'].onclick;
    }
}

function invoke_change_region_offer_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['change_region_offer_dialog']);
    dialog.user_data['dialog'] = 'change_region_offer_dialog';

    dialog.modal = true;
    install_child_dialog(dialog);
    dialog.auto_center();

    var time_left = player.cooldown_togo(gamedata['spells']['CHANGE_REGION']['cooldown_name']);
    var last_relocate = server_time - player.cooldowns[gamedata['spells']['CHANGE_REGION']['cooldown_name']]['start'];
    dialog.widgets['description'].set_text_with_linebreaking(dialog.data['widgets']['description']['ui_name'].replace('%last',pretty_print_time(last_relocate)).replace('%s', pretty_print_time(time_left)).replace('%currency', Store.gamebucks_ui_name()));

    var price = Store.get_user_currency_price(0, gamedata['spells']['CHANGE_REGION_INSTANTLY'], null);

    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
    dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    dialog.widgets['ok_button'].onclick =
        dialog.widgets['price_display'].onclick = function(w) {
            change_selection_ui(null);
            var order_cb = function(override_spellarg) {
                if(Store.place_order(Store.get_user_currency(), GameObject.VIRTUAL_ID, 'CHANGE_REGION_INSTANTLY', override_spellarg, null)) {
                    player.cooldown_client_trigger(gamedata['spells']['CHANGE_REGION']['cooldown_name'], gamedata['spells']['CHANGE_REGION']['cooldown']);
                    return true;
                }
                return false;
            };
            invoke_change_region_dialog(order_cb, 'CHANGE_REGION_INSTANTLY');
        };

    return dialog;
}

// if "callback" is null, this tries to use the free relocation.
// otherwise, callback should be a function that accepts the spellargs for a paid or item-based CHANGE_REGION
// and returns 'true' if the order has been placed

function change_region_for_free(spellarg) {
    change_region(spellarg[0], spellarg[1]);
    return true;
}

function invoke_change_region_dialog(callback, spellname) {
    if(0) {
        // check if squads are deployed
        var any_deployed = false;
        goog.object.forEach(player.squads, function(squad_data) {
            if(player.squad_is_deployed(squad_data['id'])) {
                any_deployed = true;
            }
        });
        if(any_deployed) {
            var s = gamedata['errors']['CANNOT_CHANGE_REGION_SQUAD_DEPLOYED'];
            invoke_child_message_dialog(s['ui_title'], s['ui_name'], {'dialog':'message_dialog_big'});
            return;
        }
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['change_region_dialog']);
    dialog.user_data['dialog'] = 'change_region_dialog';
    dialog.user_data['spellname'] = spellname;

    // note: if the free region change is not on cooldown, and we're doing a plain (non-anywhere) change, then ignore the provided callback and use the free path instead
    if(!callback || ((spellname == 'CHANGE_REGION_INSTANTLY') && !player.cooldown_active(gamedata['spells']['CHANGE_REGION']['cooldown_name']))) {
        dialog.user_data['callback'] = change_region_for_free;
    } else {
        dialog.user_data['callback'] = callback;
    }

    dialog.user_data['alliancemates_by_region'] = {};
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['region_name']['array'][1];
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.user_data['region_button_states'] = {};
    dialog.user_data['region_button_strs'] = {};
    dialog.user_data['region_button_tooltips'] = {};

    dialog.ondraw = update_change_region_dialog;
    dialog.user_data['rowdata'] = []; // wait until query completes
    dialog.user_data['populations'] = null;
    query_region_pop((function (_dialog) { return function(pops) { change_region_dialog_pop_results(_dialog, pops); } })(dialog));
    dialog.widgets['loading_spinner'].show = true;
    dialog.user_data['rowfunc'] = change_region_dialog_setup_row;
    scrollable_dialog_change_page(dialog, 0);
    return dialog;
}

function change_region_dialog_pop_results(dialog, populations) {
    if(!dialog.is_visible()) { return; }
    dialog.widgets['loading_spinner'].show = false;
    dialog.user_data['populations'] = populations;
    dialog.user_data['rowdata'] = [];
    var ignore_pred = (dialog.user_data['spellname'] == 'CHANGE_REGION_INSTANTLY_ANYWHERE');

    for(var id in gamedata['regions']) {
        if(!player.is_developer() && gamedata['regions'][id]['developer_only']) { continue; }
        if(('show_if' in gamedata['regions'][id]) && !read_predicate(gamedata['regions'][id]['show_if']).is_satisfied(player, null)) { continue; }
        dialog.user_data['rowdata'].push(id);
    }

    dialog.user_data['rowdata'].sort(function (a,b) {
        // sort by ui_priority, then predicate, then fullness (low to high), then name
        var ra = gamedata['regions'][a], rb = gamedata['regions'][b];
        var pa = ra['ui_priority'] || 0, pb = rb['ui_priority'] || 0;
        var pred_oka = ignore_pred || (!('requires' in ra) || read_predicate(ra['requires']).is_satisfied(player, null));
        var pred_okb = ignore_pred || (!('requires' in rb) || read_predicate(rb['requires']).is_satisfied(player, null));
        var popa = (ra['open_join'] && pred_oka && populations[a] ? populations[a] : {'state':'full','rank':99999});
        var popb = (rb['open_join'] && pred_okb && populations[b] ? populations[b] : {'state':'full','rank':99999});
        if(pa > pb) {
            return -1;
        } else if(pa < pb) {
            return 1;
        } else if(popa['state'] != 'full' && popb['state'] == 'full') {
            return -1;
        } else if(popa['state'] == 'full' && popb['state'] != 'full') {
            return 1;
        } else if(popa['rank'] > popb['rank']) {
            return -1;
        } else if(popa['rank'] < popb['rank']) {
            return 1;
        } else if(ra['ui_name'] < rb['ui_name']) {
            return -1;
        } else if(ra['ui_name'] > rb['ui_name']) {
            return 1;
        } else {
            return 0;
        }
    });

    scrollable_dialog_change_page(dialog, dialog.user_data['page']); // update the dialog

    // kick off query for alliancemates
    if(session.is_in_alliance()) {
        dialog.widgets['loading_spinner'].show = true;
        AllianceCache.query_members(session.alliance_id, false, null, (function (_dialog) { return function(info) {
            dialog.widgets['loading_spinner'].show = false;
            if(!info || !info['members']) { return; }
            goog.array.forEach(info['members'], function(member_info) {
                var member_id = member_info['user_id'];
                if(member_id == session.user_id) { return; }
                var player_info = PlayerCache.query_sync(member_id);
                if(player_info && player_info['home_region'] && player_info['home_base_loc']) {
                    var reg = player_info['home_region'];
                    if(!(reg in dialog.user_data['alliancemates_by_region'])) { dialog.user_data['alliancemates_by_region'][reg] = []; }
                    dialog.user_data['alliancemates_by_region'][reg].push(member_id);
                }
            });
            scrollable_dialog_change_page(dialog, dialog.user_data['page']); // update the dialog
        }; })(dialog));
    }
}

function update_change_region_dialog(dialog) {
    for(var row = 0; row < dialog.data['widgets']['region_button']['array'][1]; row++) {
        var w = dialog.widgets['region_button'+row];
        if(w.show && (row in dialog.user_data['region_button_states'])) {
            if(change_region_pending) {
                w.state = 'disabled';
                w.str = dialog.data['widgets']['region_button']['ui_name_processing'];
                w.tooltip.str = null;
            } else {
                w.state = dialog.user_data['region_button_states'][row];
                w.str = dialog.user_data['region_button_strs'][row];
                w.tooltip.str = dialog.user_data['region_button_tooltips'][row] || null;
            }
        }
    }
}

function change_region_dialog_setup_row(dialog, row, rowdata) {
    var present = (rowdata !== null && dialog.user_data['populations'] !== null);

    dialog.widgets['separator'+(row+1)].show =
        dialog.widgets['region_name'+row].show =
        dialog.widgets['region_status'+row].show =
        dialog.widgets['region_alliancemates'+row].show =
        dialog.widgets['region_info'+row].show =
        dialog.widgets['region_button'+row].show = present;

    if(present) {
        var ignore_pred = (dialog.user_data['spellname'] == 'CHANGE_REGION_INSTANTLY_ANYWHERE');
        var data = gamedata['regions'][rowdata];
        var already_here = (session.region.data === data);
        var open = data['open_join'] && (rowdata in dialog.user_data['populations']) && (dialog.user_data['populations'][rowdata]['state'] != 'full');

        var pred = ('requires' in data ? read_predicate(data['requires']) : null);
        var pred_ok = ignore_pred || (pred ? pred.is_satisfied(player, null) : true);

        dialog.widgets['region_name'+row].str = data['ui_name'].toUpperCase();
        dialog.widgets['region_name'+row].text_color = (!pred_ok ? SPUI.warning_text_color : (('text_color' in data) ? SPUI.make_colorv(data['text_color']) : SPUI.default_text_color));

        dialog.widgets['region_status'+row].str = dialog.data['widgets']['region_status']['ui_name_'+(already_here ? 'here' : (!open ? 'full' : (!pred_ok ? 'locked' : 'open')))];
        dialog.widgets['region_status'+row].text_color = (already_here ? dialog.widgets['region_name'+row].text_color : ((open && pred_ok) ? (('text_color' in data) ? SPUI.make_colorv(data['text_color']) : SPUI.good_text_color) : SPUI.error_text_color));
        dialog.widgets['region_info'+row].str = data['ui_description_short'];
        dialog.widgets['region_info'+row].text_color = SPUI.make_colorv(('info_color' in data) ? data['info_color'] : dialog.data['widgets']['region_info']['text_color']);
        dialog.widgets['region_info'+row].tooltip.str = data['ui_description_long'];


        // remember state/str since update_change_region_dialog may want to override it
        // allow relocation within region (session.region.data === data);
        dialog.user_data['region_button_states'][row] = (already_here ? 'normal' : (!open ? 'disabled' : (!pred_ok ? 'disabled_clickable' : 'normal')));
        dialog.user_data['region_button_strs'][row] = dialog.data['widgets']['region_button']['ui_name'+((open&&!pred_ok&&!already_here) ? '_locked' : (already_here?'_here':''))];
        dialog.user_data['region_button_tooltips'][row] = (open&&!pred_ok&&!already_here ? dialog.data['widgets']['region_button']['ui_tooltip_unmet'].replace('%s',pred.ui_describe(player)) : null);

        var mate_count = 0;
        if(data['id'] in dialog.user_data['alliancemates_by_region']) {
            mate_count = dialog.user_data['alliancemates_by_region'][data['id']].length;
        }
        dialog.widgets['region_alliancemates'+row].show = (mate_count > 0);
        if(dialog.widgets['region_alliancemates'+row].show) {
            dialog.widgets['region_alliancemates'+row].str = dialog.data['widgets']['region_alliancemates']['ui_name'].replace('%d', mate_count.toString());
            dialog.widgets['region_alliancemates'+row].text_color = dialog.widgets['region_info'+row].text_color;
        }
        if(!pred_ok) {
            dialog.widgets['region_button'+row].onclick = get_requirements_help(pred);

        } else {
            dialog.widgets['region_button'+row].onclick = (function (_id) { return function(w) {
                var start_execute_cb = (function (__id, _w) { return function() {
                    var _dialog = _w.parent;

                    var callback = _dialog.user_data['callback'];
                    var finish_execute_cb = (function (___id, _callback) { return function(dest_coords) {
                        if(_callback([___id, dest_coords])) {
                            change_region_pending = (_callback === change_region_for_free ? 'free' : 'paid');
                            invoke_ui_locker(synchronizer.request_sync());
                        }
                    }; })(__id, callback);

                    if((_id in dialog.user_data['alliancemates_by_region']) && dialog.user_data['alliancemates_by_region'][_id].length >= 1) {
                        // player has alliancemates in region - ask which one to move near
                        invoke_change_region_mates_dialog(_id, dialog.user_data['alliancemates_by_region'][_id], finish_execute_cb);
                    } else {
                        // no alliancemates in region - execute now
                        finish_execute_cb(null);
                    }

                }; })(_id, w);

                var within_region = (session.region.data && session.region.data['id'] == _id);
                var old_is_ladder = (session.region.data && session.region.data['ladder_pvp']);
                var new_is_ladder = !!(gamedata['regions'][_id]['ladder_pvp']);
                var ladder_reset = (old_is_ladder && !new_is_ladder) && gamedata['matchmaking']['zero_points_on_ladder_exit'];

                var msg = gamedata['strings']['change_region_confirm' + (within_region ? '_within_region' : (ladder_reset ? '_ladder_reset': '' ))];
                invoke_child_message_dialog(msg['ui_title'].replace('%s', gamedata['regions'][_id]['ui_name']),
                                            msg['ui_description'].replace('%s', gamedata['regions'][_id]['ui_name'])+'\n\n'+gamedata['strings']['regional_map']['change_region_feature_info'].replace('%NAME',gamedata['regions'][_id]['ui_name']).replace('%DESCR',gamedata['regions'][_id]['ui_description_long']),
                                            {'cancel_button': true,
                                             'ok_button_ui_name': msg['ui_button'],
                                             'dialog': 'message_dialog_big',
                                             'on_ok': start_execute_cb});
            }; })(rowdata);
        }
    }
}

function invoke_change_region_mates_dialog(region_id, id_list, callback) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['change_region_mates_dialog']);
    dialog.user_data['dialog'] = 'change_region_mates_dialog';
    dialog.user_data['callback'] = callback;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['portrait']['array'][1];
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    // build list of alliancemates in the region
    dialog.user_data['rowdata'] = [];
    goog.array.forEach(id_list, function(id) {
        var info = PlayerCache.query_sync(id);
        if(info && info['home_region'] == region_id && info['home_base_loc']) {
            dialog.user_data['rowdata'].push(id);
        }
    });

    if(dialog.user_data['rowdata'].length < 1) {
        // no friends - skip!
        callback(null);
        return;
    }

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    // sort alphabetically
    dialog.user_data['rowdata'].sort(function (a,b) {
        var na = PlayerCache.get_ui_name(PlayerCache.query_sync(a));
        var nb = PlayerCache.get_ui_name(PlayerCache.query_sync(b));
        if(na < nb) {
            return -1;
        } else if(na > nb) {
            return 1;
        } else {
            return 0;
        }
    });

    // prepend -1 for "random"
    dialog.user_data['rowdata'] = [-1].concat(dialog.user_data['rowdata']);

    dialog.user_data['rowfunc'] = change_region_mates_dialog_setup_row;
    scrollable_dialog_change_page(dialog, 0);
    return dialog;
}

function change_region_mates_dialog_setup_row(dialog, row, rowdata) {
    dialog.widgets['separator'+(row+1)].show =
        dialog.widgets['portrait'+row].show =
        dialog.widgets['portrait_random'+row].show =
        dialog.widgets['name'+row].show =
        dialog.widgets['button'+row].show = (rowdata !== null);

    if(rowdata !== null) {
        var id = rowdata;
        var coords;
        if(id < 0) {
            // random location
            coords = null;
            dialog.widgets['portrait'+row].show = false;
            dialog.widgets['portrait_random'+row].show = true;
            dialog.widgets['name'+row].str = dialog.data['widgets']['name']['ui_name_random'];
        } else {
            dialog.widgets['portrait'+row].show = true;
            dialog.widgets['portrait_random'+row].show = false;

            var info = PlayerCache.query_sync(id);
            coords = info['home_base_loc']; // guaranteed to exist by invoke_change_region_mates_dialog()
            dialog.widgets['portrait'+row].set_user(id);

            dialog.widgets['name'+row].str = dialog.data['widgets']['name']['ui_name_mate'].replace('%s', PlayerCache.get_ui_name(info) + ' (L'+(info['player_level']||1).toString()+')');
        }

        dialog.widgets['button'+row].onclick = (function (_id) { return function(w) {
            var _cb = w.parent.user_data['callback'];
            close_parent_dialog(w);
            _cb(_id < 0 ? null : PlayerCache.query_sync(_id)['home_base_loc']);
        }; })(id);
    }
}

function invoke_map_bookmarks_dialog(mapwidget) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['map_bookmarks_dialog']);
    dialog.user_data['dialog'] = 'map_bookmarks_dialog';
    dialog.user_data['mapwidget'] = mapwidget;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['name']['array'][1];
    dialog.user_data['rowdata'] = [];
    dialog.user_data['rowfunc'] = map_bookmarks_dialog_setup_row;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    refresh_map_bookmarks_dialog(dialog);
    return dialog;
}
function refresh_map_bookmarks_dialog(dialog) {
    var mapwidget = dialog.user_data['mapwidget'];
    var region = mapwidget.region.data['id'];
    if(!(region in player.map_bookmarks)) {
        player.map_bookmarks[region] = [];
    }
    dialog.user_data['rowdata'] = player.map_bookmarks[region];
    scrollable_dialog_change_page(dialog, (dialog.user_data['page'] >= 0 ? dialog.user_data['page'] : 0));
    return dialog;
}
function map_bookmarks_dialog_setup_row(dialog, row, rowdata) {
    dialog.widgets['separator'+(row+1)].show =
        dialog.widgets['icon'+row].show =
        dialog.widgets['name'+row].show =
        dialog.widgets['coords'+row].show =
        dialog.widgets['delete_button'+row].show =
        dialog.widgets['rename_button'+row].show =
        dialog.widgets['go_button'+row].show = (rowdata !== null);

    if(rowdata !== null) {
        dialog.widgets['name'+row].str = rowdata['ui_name'];
        dialog.widgets['coords'+row].str = dialog.data['widgets']['coords']['ui_name'].replace('%x', rowdata['coords'][0].toString()).replace('%y', rowdata['coords'][1].toString());
        dialog.widgets['delete_button'+row].onclick = (function (_rowdata) { return function(w) {
            var _dialog = w.parent;
            var msg = gamedata['strings']['map_bookmark_delete_confirm'];
            invoke_child_message_dialog(msg['ui_title'],
                                        msg['ui_description'].replace('%s', _rowdata['ui_name']),
                                        {'cancel_button': true,
                                         'ok_button_ui_name': msg['ui_button'],
                                         'dialog': 'message_dialog',
                                         'on_ok': (function (__dialog, __rowdata) { return function() {
                                             player.map_bookmark_delete(__dialog.user_data['mapwidget'].region.data['id'], __rowdata['coords']);
                                             refresh_map_bookmarks_dialog(__dialog);
                                         }; })(_dialog, _rowdata)});
        }; })(rowdata);
        dialog.widgets['rename_button'+row].onclick = (function (_rowdata) { return function(w) {
            invoke_map_bookmark_rename_dialog(w.parent, _rowdata);
        }; })(rowdata);

        dialog.widgets['go_button'+row].onclick = (function (_rowdata) { return function(w) {
            var coords = _rowdata['coords'];
            var mapwidget = w.parent.user_data['mapwidget'];
            close_parent_dialog(w);
            mapwidget.pan_to_cell(coords, {slowly:true, with_zoom:true});
        }; })(rowdata);
    }
}
function invoke_map_bookmark_rename_dialog(bookmarks_dialog, bookmark) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['map_bookmark_rename_dialog']);
    dialog.user_data['dialog'] = 'map_bookmark_rename_dialog';
    dialog.user_data['bookmarks_dialog'] = bookmarks_dialog;
    dialog.user_data['bookmark'] = bookmark;
    dialog.widgets['close_button'].onclick =  dialog.widgets['cancel_button'].onclick = close_parent_dialog;
    dialog.widgets['rename_button'].onclick = dialog.widgets['input'].ontextready = function(w) {
        var _dialog = w.parent;
        var bookmark = _dialog.user_data['bookmark'];
        var new_name = _dialog.widgets['input'].str;
        if(new_name) {
            if(new_name != bookmark['ui_name']) {
                player.map_bookmark_rename(bookmark['region'], new_name, bookmark['coords']);
                refresh_map_bookmarks_dialog(_dialog.user_data['bookmarks_dialog']);
            }
            close_parent_dialog(w);
        }
    };
    dialog.widgets['input'].str = bookmark['ui_name'];
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    SPUI.set_keyboard_focus(dialog.widgets['input']);

    return dialog;
}

function scrollable_dialog_change_page(dialog, page) {
    var rows_per_page = dialog.user_data['rows_per_page'];
    var cols_per_page = dialog.user_data['cols_per_page'] || 1;
    var rowfunc = dialog.user_data['rowfunc'];
    var roworder = dialog.user_data['roworder'] || 'top_bottom_left_right';
    var chapter_items = dialog.user_data['rowdata'].length;
    var items_per_page = rows_per_page * cols_per_page;
    var chapter_pages = Math.floor((chapter_items+items_per_page-1)/items_per_page);
    dialog.user_data['page'] = page = (chapter_items == 0 ? 0 : clamp(page, 0, chapter_pages-1));

    var item_num = 0, row = 0, col = 0;
    if(chapter_items > 0) {
        var first_on_page = page * items_per_page;
        var last_on_page = (page+1)*items_per_page - 1;
        last_on_page = Math.max(0, Math.min(last_on_page, chapter_items-1));
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_on_page+1).toString()).replace('%d2',(last_on_page+1).toString()).replace('%d3',chapter_items.toString());
        for(var i = first_on_page; i <= last_on_page; i++) {
            var coord = (cols_per_page == 1 ? row : [col,row]);
            rowfunc(dialog, coord, dialog.user_data['rowdata'][i]);
            item_num += 1;
            if(roworder == 'left_right_top_bottom') {
               col += 1;
                if(col >= cols_per_page) {
                    col = 0;
                    row += 1;
                }
            } else {
                row += 1;
                if(row >= rows_per_page) {
                    row = 0;
                    col += 1;
                }
            }
        }
    } else {
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(0).toString()).replace('%d2',(0).toString()).replace('%d3',(0).toString());
    }

    while(item_num < items_per_page) { // hide remaining rows
        var coord = (cols_per_page == 1 ? row : [col,row]);
        rowfunc(dialog, coord, null);
        item_num += 1;
        if(roworder == 'left_right_top_bottom') {
            col += 1;
            if(col >= cols_per_page) {
                col = 0;
                row += 1;
            }
        } else {
            row += 1;
            if(row >= rows_per_page) {
                row = 0;
                col += 1;
            }
        }
    }

    // set clickability of scroll arrows
    dialog.widgets['scroll_left'].state = (page != 0 ? 'normal' : 'disabled');
    dialog.widgets['scroll_right'].state = (page < (chapter_pages-1) ? 'normal' : 'disabled');

    dialog.widgets['scroll_left'].onclick =  (function (_dialog) { return function() { scrollable_dialog_change_page(_dialog, _dialog.user_data['page']-1); }; })(dialog);
    dialog.widgets['scroll_right'].onclick = (function (_dialog) { return function() { scrollable_dialog_change_page(_dialog, _dialog.user_data['page']+1); }; })(dialog);
}

function invoke_mail_dialog(do_animation) {
    if(!player.get_any_abtest_value('enable_inventory', gamedata['enable_inventory'])) { return null; }
    var dialog = new SPUI.Dialog(gamedata['dialogs']['mail_dialog']);
    dialog.user_data['dialog'] = 'mail_dialog';
    dialog.user_data['anim_start_time'] = (do_animation ? client_time : -1);
    dialog.user_data['selected_row'] = -1; // index of selected row in UI
    dialog.user_data['visible_rows'] = dialog.data['widgets']['row']['array'][1]; // # visible rows in UI
    dialog.user_data['first_row'] = 0; // index of top row that appears in UI
    dialog.user_data['attach_page'] = 0; // scroll page for list of attachments
    dialog.user_data['context'] = null; // context-tooltop Dialog for attachment items

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['missions_button'].onclick = function() { invoke_missions_dialog(false); };
    dialog.widgets['messages_button'].onclick = null;
    dialog.widgets['scroll_left'].onclick = function(w) { var dialog = w.parent; mail_dialog_scroll(dialog, dialog.user_data['first_row']-dialog.user_data['visible_rows']); };
    dialog.widgets['scroll_right'].onclick = function(w) { var dialog = w.parent; mail_dialog_scroll(dialog, dialog.user_data['first_row']+dialog.user_data['visible_rows']); };

    dialog.ondraw = animate_valentina_dialog;
    dialog.ondraw = frame_update_mail_dialog;
    update_mail_dialog(dialog);

    return dialog;
}

function update_mail_dialog(dialog) {
    player.prune_expired_mail();

    dialog.widgets['pending_missions_icon'].show =
        dialog.widgets['pending_missions_icon_glow'].show = (player.claimable_quests > 0);
    dialog.widgets['pending_messages_icon'].show =
        dialog.widgets['pending_messages_icon_glow'].show = player.has_unread_mail();

    var pre_select = -1;
    // first look for uncollected important attachments
    player.mailbox_iter(function(mail, i) {
        if(player.mail_message_has_money(mail)) {
            pre_select = i;
            return true;
        }
    });

    if(pre_select === -1) {
        player.mailbox_iter(function(mail, i) {
            if(!mail['read']) {
                pre_select = i;
                return true;
            }
        });
    }

    var first_row = 0;
    if(pre_select != -1) {
        // adjust scroll position up or down to make sure the pre-selected mail is visible
        if(pre_select < first_row) { first_row = pre_select; }
        else if(pre_select >= first_row + dialog.user_data['visible_rows']) { first_row = pre_select; }
    } else {
        // no pre-selection yet - just use row 0
        pre_select = first_row;
    }
    dialog.user_data['selected_row'] = pre_select;
    dialog.user_data['first_row'] = first_row;
    mail_dialog_scroll(dialog, dialog.user_data['first_row']);
}

function mail_dialog_scroll(dialog, first_row) {
    var count = player.mailbox_count();

    // constrain first_row to valid range
    first_row = Math.max(Math.min(first_row, count - 1), 0);
    // quantize first_row to pages
    first_row = Math.floor(first_row/dialog.user_data['visible_rows'])*dialog.user_data['visible_rows'];
    dialog.user_data['first_row'] = first_row;

    // fill in UI quest list at left-hand side of dialog
    var ui_row = 0;
    for(var i = first_row; i < count; i++) {
        var mail = player.mailbox_nth(i);
        var rowname = 'row'+ui_row.toString();
        dialog.widgets[rowname].show = true;
        var subj = mail['subject'];
        var max_len = dialog.data['widgets']['row']['max_len'];
        if(subj.length >= max_len) {
            subj = subj.slice(0,max_len) + '...';
        }
        dialog.widgets[rowname].str = subj;
        dialog.widgets[rowname].onclick = (function (rownum) { return function (w) {
            mail_dialog_select_mail(w.parent, rownum); }; })(i);
        dialog.widgets['row_icon'+ui_row.toString()].show = !mail['read'];
        dialog.widgets['row_attachment_icon'+ui_row.toString()].show = (('attachments' in mail) && (mail['attachments'].length > 0));
        ui_row += 1;
        if(ui_row >= dialog.user_data['visible_rows']) {
            break;
        }
    }
    // hide remaining rows
    while(ui_row < dialog.user_data['visible_rows']) {
        dialog.widgets['row'+ui_row.toString()].show =
            dialog.widgets['row_icon'+ui_row.toString()].show =
            dialog.widgets['row_attachment_icon'+ui_row.toString()].show = false;
        ui_row += 1;
    }

    // set scroll widget clickability
    dialog.widgets['scroll_left'].state = (first_row > 0 ? 'normal':'disabled');
    dialog.widgets['scroll_left'].text_color = (first_row > 0 ? SPUI.default_text_color : SPUI.disabled_text_color);
    dialog.widgets['scroll_right'].state = (count > first_row+dialog.user_data['visible_rows'] ? 'normal':'disabled');
    dialog.widgets['scroll_right'].text_color = (count > first_row+dialog.user_data['visible_rows'] ? SPUI.default_text_color : SPUI.disabled_text_color);

    dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1', count > 0 ? first_row+1 : 0).replace('%d2', Math.min(first_row+dialog.user_data['visible_rows'], count)).replace('%d3', count);

    // get rid of attachment context dialog, if any
    mail_dialog_invoke_context(dialog, -1, null);

    // select the pre-selection, or any row that's visible
    mail_dialog_select_mail(dialog, dialog.user_data['selected_row']);
}

function frame_update_mail_dialog(dialog) {
    if(dialog.user_data['selected_row'] < 0 || dialog.user_data['selected_row'] >= player.mailbox_count()) {
        return;
    }

    var mail = player.mailbox_nth(dialog.user_data['selected_row']);
    dialog.widgets['expiration'].show = (('expire_time' in mail) && mail['expire_time'] > 0);
    if(dialog.widgets['expiration'].show) {
        dialog.widgets['expiration'].str = dialog.data['widgets']['expiration']['ui_name'].replace('%s', pretty_print_time_brief(mail['expire_time']-server_time));
    }
}

function mail_dialog_select_mail(dialog, row) {
    dialog.user_data['selected_row'] = row;
    dialog.user_data['selected_row'] = Math.min(Math.max(dialog.user_data['selected_row'], dialog.user_data['first_row']), Math.min(dialog.user_data['first_row']+dialog.user_data['visible_rows']-1, player.mailbox_count()-1));

    //dialog.widgets['attach_take'].show =
        dialog.widgets['attach_scroll_left'].show =
        dialog.widgets['attach_scroll_right'].show =
        dialog.widgets['attach_taken'].show =
        dialog.widgets['attach_label'].show =
        dialog.widgets['attach_label2'].show =
        dialog.widgets['attach_label3'].show = false;
    //dialog.widgets['attach_more'].show = false;
    for(var i = 0; i < dialog.data['widgets']['attach_icon']['array'][0]; i++) {
        dialog.widgets['attach_slot'+i.toString()].show =
            dialog.widgets['attach_icon'+i.toString()].show =
            dialog.widgets['attach_stack'+i.toString()].show =
            dialog.widgets['attach_timer'+i.toString()].show =
            dialog.widgets['attach_timer_icon'+i.toString()].show =
            dialog.widgets['attach_frame'+i.toString()].show = false;
    }

    dialog.widgets['from_subj_rect'].show =
        dialog.widgets['body_rect'].show =
        dialog.widgets['attach_rect'].show =
        dialog.widgets['from_label'].show =
        dialog.widgets['from_name'].show =
        dialog.widgets['subj_label'].show =
        dialog.widgets['subj_name'].show =
        dialog.widgets['delete_button'].show =
        dialog.widgets['body'].show =
        dialog.widgets['expiration'].show = (dialog.user_data['selected_row'] >= 0);

    dialog.widgets['nomail'].show = !dialog.widgets['body'].show;
    if(dialog.user_data['selected_row'] < 0) { // no mail
        dialog.widgets['selected_row'].show = false;
        return;
    }

    var mail = player.mailbox_nth(dialog.user_data['selected_row']);

    dialog.widgets['delete_button'].show = dialog.widgets['body'].show && player.mail_message_is_discardable(mail);

    if('expire_time' in mail && mail['expire_time'] > 0 && server_time >= mail['expire_time']) {
        update_mail_dialog(dialog);
        return;
    }

    // update highlight on left-hand display
    var highlight_color = new SPUI.Color(0.75,0.75,0.75,1);
    var white = new SPUI.Color(1,1,1,1);
    for(var i = 0; i < dialog.user_data['visible_rows']; i++) {
        var select_this = (i+dialog.user_data['first_row'] == dialog.user_data['selected_row']);
        var rowname = 'row'+i.toString();
        dialog.widgets[rowname].text_color = (select_this ? white : SPUI.disabled_text_color);
        dialog.widgets[rowname].text_style = (select_this ? 'bold' : 'normal');
        dialog.widgets[rowname].highlight_text_color = (select_this ? white : highlight_color);
        if(select_this) {
            var spacing = dialog.data['widgets']['row']['array_offset'][1];
            dialog.widgets['selected_row'].xy[1] = dialog.data['widgets']['row']['xy'][1]+i*spacing-2;
            dialog.widgets['selected_row'].show = true;
        }
    }

    // update info at right
    dialog.widgets['from_name'].str = mail['from_name'];
    dialog.widgets['subj_name'].str = mail['subject'];
    dialog.widgets['body'].set_text_with_linebreaking(mail['body']);

    dialog.widgets['delete_button'].onclick = (function (_mail) { return function(w) {
        var deleter = (function(__mail) { return function() {
            player.mailbox_remove(__mail);
            send_to_server.func(["MAIL_DELETE", __mail['msg_id']]);
            update_mail_dialog(w.parent);
        }; })(_mail);

        // only ask for confirmation if it has attachments
        if('attachments' in _mail) {
            var s = gamedata['strings']['mail_confirm_delete'];
            invoke_child_message_dialog(s['ui_title'],
                                        s['ui_description'],
                                        {'cancel_button': true,
                                         'ok_button_ui_name': s['ui_button'],
                                         'on_ok': deleter});
        } else {
            deleter();
        }

    }; })(mail);

    if('attachments' in mail) {
        dialog.widgets['attach_label'].show =
            dialog.widgets['attach_label2'].show =
            dialog.widgets['attach_label3'].show =
            dialog.widgets['attach_scroll_left'].show =
            dialog.widgets['attach_scroll_right'].show = true;
        /*
        if(mail['pending']) {
            dialog.widgets['attach_take'].str = dialog.widgets['attach_take'].data['ui_name_pending'];
            dialog.widgets['attach_take'].state = 'disabled';
        } else {
            dialog.widgets['attach_take'].str = dialog.widgets['attach_take'].data['ui_name'];
            dialog.widgets['attach_take'].state = 'normal';
        }
        dialog.widgets['attach_take'].show = true;
        dialog.widgets['attach_take'].onclick = (function (_mail) { return function(w) {
            if(!_mail['pending']) {
                _mail['pending'] = 1;
                w.state = 'disabled';
                w.str = w.data['ui_name_pending'];
                send_to_server.func(["MAIL_TAKE_ATTACHMENTS", _mail['msg_id'], -1, null, null]);
            }
        }; })(mail);
        */
        mail_dialog_attach_scroll(dialog, 0);
    } else if('attachments_ghost' in mail) {
        for(var i = 0; i < mail['attachments_ghost'].length; i++) {
            var ghost = mail['attachments_ghost'][i];
            if(ghost && ghost['collected_at']) {
                dialog.widgets['attach_taken'].show = true;
                dialog.widgets['attach_taken'].str = dialog.data['widgets']['attach_taken']['ui_name'].replace('%s', pretty_print_date(ghost['collected_at']));
                break;
            }
        }
    }

    // mark the mail as read
    if(!mail['read']) {
        mail['read'] = 1;
        send_to_server.func(["MAIL_READ", mail['msg_id']]);
        dialog.widgets['pending_messages_icon'].show =
            dialog.widgets['pending_messages_icon_glow'].show = player.has_unread_mail();
        dialog.widgets['row_icon'+(dialog.user_data['selected_row']-dialog.user_data['first_row']).toString()].show = false;
    }
}

function mail_dialog_attach_scroll(dialog, page) {
    // clear out context menu
    mail_dialog_invoke_context(dialog, -1, null);
    var any_expiring = false;
    var count = player.mailbox_count();

    if(dialog.user_data['selected_row'] < 0 || dialog.user_data['selected_row'] >= count) { return; }
    dialog.user_data['attach_page'] = page;
    var mail = player.mailbox_nth(dialog.user_data['selected_row']);
    if(!('attachments' in mail) || mail['attachments'].length < 1) { return; }
    var row = 0;
    var rows_per_page = dialog.data['widgets']['attach_icon']['array'][0];
    var chapter_items = mail['attachments'].length;
    var chapter_pages = Math.floor((chapter_items+rows_per_page-1)/rows_per_page);
    dialog.user_data['attach_page'] = page = (chapter_pages === 0 ? 0 : clamp(page, 0, chapter_pages-1));
    if(chapter_pages > 0) {
        var first_on_page = page * rows_per_page;
        var last_on_page = Math.min(Math.max((page+1)*rows_per_page - 1, 0), chapter_items-1);
        dialog.widgets['attach_label3'].str = dialog.data['widgets']['attach_label3']['ui_name'].replace('%d1',(first_on_page+1).toString()).replace('%d2',(last_on_page+1).toString()).replace('%d3',chapter_items.toString());
        for(var i = first_on_page; i <= last_on_page; i++) {
            var at = mail['attachments'][i];
            var spec = ItemDisplay.get_inventory_item_spec(at['spec']);
            dialog.widgets['attach_slot'+row.toString()].show = true;
            dialog.widgets['attach_icon'+row.toString()].show = true;
            ItemDisplay.set_inventory_item_asset(dialog.widgets['attach_icon'+row.toString()], spec);
            dialog.widgets['attach_icon'+row.toString()].bg_image_offset = [0,0];

            ItemDisplay.set_inventory_item_stack(dialog.widgets['attach_stack'+row.toString()], spec, at);

            dialog.widgets['attach_timer_icon'+row.toString()].show =
                dialog.widgets['attach_timer'+row.toString()].show = ('expire_time' in at);
            if('expire_time' in at) {
                any_expiring = true;
                dialog.widgets['attach_timer'+row.toString()].str = do_pretty_print_time(at['expire_time']-server_time,1,false);
            }

            dialog.widgets['attach_frame'+row.toString()].show = true;
            dialog.widgets['attach_frame'+row.toString()].state = (mail['pending'] ? 'cooldown' : 'normal');
            dialog.widgets['attach_frame'+row.toString()].bg_image_offset = [0,0];
            dialog.widgets['attach_frame'+row.toString()].onenter = (function (_mail, _row, _slot, _item) { return function (w) {
                w.state = (_mail['pending'] ? 'cooldown' : 'active');
                var stickout = [0,-1];
                w.bg_image_offset = stickout;
                w.parent.widgets['attach_icon'+_row.toString()].bg_image_offset = stickout;
                w.parent.widgets['attach_stack'+_row.toString()].text_offset = stickout;
                mail_dialog_invoke_context(w.parent, _slot, _item);
            }; })(mail, row, i, at);
            dialog.widgets['attach_frame'+row.toString()].onclick = (function (_mail, _row, _slot, _item) { return function (w) {
                if(!_mail['pending']) {
                    _mail['pending'] = 1;
                    for(var j = 0; j < w.parent.data['widgets']['attach_icon']['array'][0]; j++) {
                        if(w.parent.widgets['attach_frame'+j.toString()].show) {
                            w.parent.widgets['attach_frame'+j.toString()].state = 'cooldown';
                        }
                    }
                    w.state = 'cooldown';
                    send_to_server.func(["MAIL_TAKE_ATTACHMENTS", _mail['msg_id'], _slot, _item['spec'], _item['stack'] || 1]);
                }
            }; })(mail, row, i, at);
            dialog.widgets['attach_frame'+row.toString()].onleave_cb = (function (_mail, _row, _slot, _item) { return function (w) {
                var inv_dialog = w.parent;
                if(inv_dialog.user_data['context'] &&
                   inv_dialog.user_data['context'].user_data['slot'] === _slot &&
                   inv_dialog.user_data['context'].user_data['item'] === _item) {
                    mail_dialog_invoke_context(w.parent, -1, null);
                    w.state = (_mail['pending'] ? 'cooldown' : 'normal');
                    var stickout = [0,0];
                    w.bg_image_offset = stickout;
                    w.parent.widgets['attach_icon'+_row.toString()].bg_image_offset = stickout;
                    w.parent.widgets['attach_stack'+_row.toString()].text_offset = stickout;
                }
            }; })(mail, row, i, at);
            row += 1;
        }
    } else {
        // nothing to list
        dialog.widgets['attach_label3'].str = dialog.data['widgets']['attach_label3']['ui_name'].replace('%d1',0).replace('%d2',0).replace('%d3',0);
    }

    // clear out empty rows
    while(row < rows_per_page) {
        dialog.widgets['attach_slot'+row.toString()].show =
            dialog.widgets['attach_icon'+row.toString()].show =
            dialog.widgets['attach_stack'+row.toString()].show =
            dialog.widgets['attach_timer_icon'+row.toString()].show =
            dialog.widgets['attach_timer'+row.toString()].show =
            dialog.widgets['attach_frame'+row.toString()].show = false;
        row += 1;
    }

    // set clickability of scroll arrows
    if(page != 0) {
        dialog.widgets['attach_scroll_left'].state = 'normal';
    } else {
        dialog.widgets['attach_scroll_left'].state = 'disabled';
    }

    if(page < (chapter_pages-1)) {
        dialog.widgets['attach_scroll_right'].state = 'normal';
    } else {
        dialog.widgets['attach_scroll_right'].state = 'disabled';
    }

    dialog.widgets['attach_scroll_left'].onclick = function(w) { mail_dialog_attach_scroll(w.parent, w.parent.user_data['attach_page']-1); };
    dialog.widgets['attach_scroll_right'].onclick = function(w) { mail_dialog_attach_scroll(w.parent, w.parent.user_data['attach_page']+1); };

    dialog.widgets['instructions_expire'].show =
        dialog.widgets['instructions_expire_icon'].show = any_expiring;
}

function mail_dialog_invoke_context(inv_dialog, slot, item) {
    var show_dropdown = false;
    if(inv_dialog.user_data['context']) {
        var dialog = inv_dialog.user_data['context'];
        if(dialog.user_data['slot'] === slot && dialog.user_data['item'] === item &&
           dialog.user_data['show_dropdown'] === show_dropdown) {
            return;
        }
        inv_dialog.widgets['attach_frame'+dialog.user_data['x'].toString()].state = 'normal';
        inv_dialog.remove(dialog);
        inv_dialog.user_data['context'] = null;
    }
    if(slot < 0) { return null; }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['inventory_context']);
    var cols = inv_dialog.data['widgets']['attach_frame']['array'][0];
    var x = (slot % cols), y = Math.floor(slot / cols);
    dialog.user_data['slot'] = slot;
    dialog.user_data['item'] = item;
    dialog.user_data['show_dropdown'] = show_dropdown;
    dialog.user_data['x'] = x; dialog.user_data['y'] = y;

    var spec = ItemDisplay.get_inventory_item_spec(item['spec']);


    dialog.widgets['title'].str = ItemDisplay.get_inventory_item_ui_name_long(spec);
    dialog.widgets['title'].text_color = ItemDisplay.get_inventory_item_color(spec);

    // resize width of tooltip area to fit name text
    var name_wh = dialog.widgets['title'].font.measure_string(dialog.widgets['title'].str);
    if(name_wh[0] > dialog.data['dimensions'][0]) {
        dialog.wh = [name_wh[0] + 2 * dialog.data['widgets']['title']['xy'][0], dialog.wh[1]];
        dialog.widgets['bgrect'].wh = vec_copy(dialog.wh); // note: height is reset down below
        dialog.widgets['description'].wh = vec_sub(dialog.widgets['bgrect'].wh, [2 * dialog.data['widgets']['description']['xy'][0],0]);
    }

    // resize height to fit description text
    dialog.widgets['description'].set_text_bbcode(ItemDisplay.get_inventory_item_ui_description(spec, ('stack' in item ? item['stack'] : 1), item['item_duration']));
    dialog.widgets['description'].update_dims(); // force immediate text layout so we can determine how much space it takes up
    dialog.widgets['bgrect'].wh[1] = dialog.widgets['title'].wh[1] + dialog.widgets['description'].wh[1];

    var slot_xy = inv_dialog.widgets['attach_frame'+x.toString()].xy;
    var slot_wh = inv_dialog.data['widgets']['attach_frame']['dimensions'];
    dialog.xy = [Math.floor(slot_xy[0]+slot_wh[0]/2 - dialog.wh[0]/2),
                 Math.floor(slot_xy[1]+slot_wh[1]+1)];

    if('expire_time' in item) {
        dialog.widgets['expires'].show = true;
        dialog.widgets['expires'].xy[1] = dialog.widgets['description'].xy[1] + dialog.widgets['description'].wh[1] - dialog.widgets['description'].font.size;
        dialog.widgets['bgrect'].wh[1] += dialog.widgets['expires'].wh[1];
    }
    dialog.widgets['bgrect'].wh[1] += 2;
    dialog.ondraw = update_mail_dialog_context;
    inv_dialog.user_data['context'] = dialog;
    inv_dialog.add(dialog);
    return dialog;
}

function update_mail_dialog_context(dialog) {
    var item = dialog.user_data['item'];
    if('expire_time' in item) {
        dialog.widgets['expires'].str = dialog.widgets['expires'].data['ui_name_item'].replace('%s', pretty_print_time_brief(item['expire_time']-server_time));
    }
}

/** @param {string=} msg */
function invoke_loot_dialog(msg) {
    if(player.loot_buffer.length < 1) { return null; }
    /*
    if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] === 'loot_dialog') {
        // update rather than refreshing
        if(selection.ui.user_data['pending'] > 0) { selection.ui.user_data['pending'] = 0; }
        return selection.ui;
    }
    */

    var dialog = new SPUI.Dialog(gamedata['dialogs']['loot_dialog']);
    dialog.user_data['dialog'] = 'loot_dialog';
    dialog.user_data['context'] = null;
    dialog.user_data['pending'] = 0;
    dialog.user_data['anim_data'] = {};
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['help_button'].onclick = function(w) {
        invoke_ingame_tip_force('loot_help_tip');
    };

    dialog.widgets['close_button'].onclick = function(w) {
        var _dialog = w.parent;
        if(player.loot_buffer.length < 1) {
            close_parent_dialog(w); return;
        }
        invoke_inventory_context(_dialog, null, -1, null, false);
        var s = gamedata['strings']['loot_abandon_confirm'];
        invoke_child_message_dialog(s['ui_title'], s['ui_description'],
                                    {'cancel_button': true,
                                     'ok_button_ui_name': s['ui_button'],
                                     'on_ok': (function (_w) { return function() {
                                         send_to_server.func(["LOOT_BUFFER_RELEASE", player.loot_buffer]);
                                         player.loot_buffer = [];
                                         close_parent_dialog(_w);
                                     }; })(w)});
    };
    dialog.ondraw = update_loot_dialog;

    var warehouse = find_object_by_type(gamedata['inventory_building']);
    if(!warehouse) { throw Error('player has no warehouse'); }
    dialog.user_data['warehouse'] = warehouse;
    change_selection_unit(warehouse);

    if(msg) {
        ItemDisplay.add_inventory_item_effect(dialog.widgets['loot_item0,0'], msg, [1,1,0.3]);
    }

    dialog.ondraw(dialog);

    // auto-click the helper if warehouse is inoperative
    if(dialog.widgets['coverup_button'].show) {
        dialog.widgets['coverup_button'].onclick(dialog.widgets['coverup_button']);
    }

    return dialog;
}

function find_dialog(name) {
    var d = selection.ui;
    while(d) {
        if(d.user_data && d.user_data['dialog'] === name) {
            return d;
        } else if(d.children && d.children.length > 0) {
            d = d.children[d.children.length-1];
        } else {
            d = null;
        }
    }
    return d;
}

// match against dialogs that have substitute names
function match_dialog_name(dialog_name, n) {
    if(n === dialog_name) { return true; }
    if(dialog_name === 'map_dialog') {
        if(n === 'map_ladder_pvp_dialog') { return true; }
        if(n === 'region_map_dialog') { return true; }
    }
    return false;
}

function refresh_loot_dialog() {
    var dialog = find_dialog('loot_dialog');
    //console.log('refresh_loot_dialog '+(dialog ? 'found' : 'NOT found'));
    if(dialog) {
        dialog.user_data['pending'] = 0;
    }
}

var loot_dialog_fast_anim = false;
function make_loot_dialog_anim_data(dialog, w, asset) {
    var ret = {'start_time': client_time,
               'end_time': client_time + dialog.data['widgets']['loot_anim']['anim_time' + (loot_dialog_fast_anim ? '_fast':'')],
               'orig_pos': vec_copy(w.xy),
               'asset': asset};
    // after first execution, make all future animations fast
    loot_dialog_fast_anim = true;
    return ret;
}

function warehouse_busy_helper(warehouse) {
    change_selection_unit(warehouse);
    if(warehouse.is_damaged() && !warehouse.is_repairing()) {
        invoke_child_repair_dialog();
    } else {
        invoke_child_speedup_dialog('speedup');
    }
}

function update_loot_dialog(dialog) {
    // reuse inventory code
    update_inventory_dialog(dialog);

    var warehouse = dialog.user_data['warehouse'];
    var warehouse_busy = player.warehouse_is_busy();
    var busy_reason = null;
    if(warehouse_busy) {
        if(warehouse && warehouse.is_damaged()) {
            if(warehouse.is_repairing()) {
                busy_reason = 'repair_speedup';
            } else {
                busy_reason = 'repair';
            }
        } else if(warehouse && warehouse.is_upgrading()) {
            busy_reason = 'upgrade_speedup';
        } else {
            throw Error("cannot determine warehouse busy reason");
        }
    }

    var can_fit_all = inventory_items_can_all_fit(player.loot_buffer, player.inventory, player.max_usable_inventory());
    var can_fit_item = [];
    var need_storage_for_resource = null;
    for(var i = 0; i < player.loot_buffer.length; i++) {
        var item = player.loot_buffer[i];
        var can_fit = inventory_item_can_fit(item, player.inventory, player.max_usable_inventory());
        can_fit_item.push(can_fit ? 1 : 0);
        if(!can_fit) {
            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            if(spec['fungible'] && spec['resource'] in gamedata['resources']) {
                need_storage_for_resource = [spec['resource'], ('stack' in item ? item['stack'] : 1)];
            }
        }
    }

    // help prompt for warehouse space
    var helper = null;
    if(warehouse_busy) {
        helper = (function(_warehouse) { return function() {
            warehouse_busy_helper(_warehouse);
        }; })(dialog.user_data['warehouse']);
    } else if(need_storage_for_resource) {
        var res = need_storage_for_resource[0], amt = need_storage_for_resource[1];
        helper = get_requirements_help('storages_full', res);
    } else {
        helper = get_requirements_help('inventory_space_need',null);
    }


    // update loot items on left-hand side
   for(var y = 0; y < dialog.data['widgets']['loot_slot']['array'][1]; y++) {
        for(var x = 0; x < dialog.data['widgets']['loot_slot']['array'][0]; x++) {
            var wname = x.toString()+','+y.toString();

            // update animation
            if(wname in dialog.user_data['anim_data']) {
                var data = dialog.user_data['anim_data'][wname];
                var t = (client_time - data['start_time']) / (data['end_time'] - data['start_time']);
                if(t >= 1) {
                    delete dialog.user_data['anim_data'][wname];
                } else {
                    var orig_pos = data['orig_pos'];
                    var targ_pos = dialog.data['widgets']['loot_anim']['target_xy'];
                    var bounce = (1 - (2*t-1)*(2*t-1)) * dialog.data['widgets']['loot_anim']['bounce'];
                    dialog.widgets['loot_anim'+wname].xy = vec_add(vec_add(orig_pos, vec_scale(t, vec_sub(targ_pos, orig_pos))),
                                                                   [0, -bounce]);
                    dialog.widgets['loot_anim'+wname].asset = data['asset'];
                    dialog.widgets['loot_anim'+wname].alpha = dialog.data['widgets']['loot_anim']['alpha'] * Math.min(Math.max(1-t+0.2,0,1));
                }
            }
            dialog.widgets['loot_anim'+wname].show = (wname in dialog.user_data['anim_data']);

            var slot = y * dialog.data['widgets']['loot_slot']['array'][0] + x;
            dialog.widgets['loot_slot'+wname].show =
                dialog.widgets['loot_item'+wname].show =
                dialog.widgets['loot_stack'+wname].show =
                dialog.widgets['loot_pending'+wname].show =
                dialog.widgets['loot_frame'+wname].show = (slot < player.loot_buffer.length);
            if(slot >= player.loot_buffer.length) {
                continue;
            }
            var context_slot = 999 + slot; // distinguish these slots from the ones on the right-hand side

            var item = player.loot_buffer[slot];
            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            ItemDisplay.set_inventory_item_asset(dialog.widgets['loot_item'+wname], spec);
            ItemDisplay.set_inventory_item_stack(dialog.widgets['loot_stack'+wname], spec, item);

            dialog.widgets['loot_pending'+wname].show = !!item['pending'];
            dialog.widgets['loot_frame'+wname].state = ((dialog.user_data['pending'] || item['pending']) ? 'disabled' : (can_fit_item[slot] ? (dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === context_slot ? 'active' : 'normal') : 'disabled_clickable'));

            dialog.widgets['loot_frame'+wname].onenter = (function (_slot, _item) { return function(w) {
                var inv_dialog = w.parent;
                if(inv_dialog.user_data['context'] &&
                   inv_dialog.user_data['context'].user_data['item'] === _item) { return; }
                invoke_inventory_context(w.parent, w, _slot, _item, false);
            }; })(context_slot, item);

            dialog.widgets['loot_frame'+wname].onclick = (function (_wname, _asset, _slot, _item, _can_fit_this, _helper) { return function(w) {
                if(player.warehouse_is_busy() || !_can_fit_this) {
                    if(_helper) { _helper(); }
                } else {
                    // take one item
                    invoke_inventory_context(w.parent, w, -1, null, false);
                    var _d = w.parent;
                    _d.user_data['pending'] = 1;
                    _d.widgets['glow'].show = true;
                    _d.widgets['glow'].reset_fx();
                    send_to_server.func(["LOOT_BUFFER_TAKE", player.loot_buffer, _slot]);
                    _item['pending'] = 1;
                    if(ItemDisplay.get_inventory_item_spec(item['spec'])['fungible']) {
                        ItemDisplay.add_inventory_item_effect(w, gamedata['strings']['combat_messages']["collected"], [1,1,0.3,1]);
                    } else {
                        _d.user_data['anim_data'][wname] = make_loot_dialog_anim_data(_d, w, _asset);
                    }
                }
            }; })(wname, dialog.widgets['loot_item'+wname].asset, slot, item, can_fit_item[slot], helper);

            dialog.widgets['loot_frame'+wname].onleave_cb = (function (_slot, _item) { return function(w) {
                var inv_dialog = w.parent;
                if(inv_dialog.user_data['context'] &&
                   inv_dialog.user_data['context'].user_data['item'] === _item) {
                    invoke_inventory_context(w.parent, w, -1, null, false);
                }
            }; })(slot, item);

            // make item/frame stick out a little bit on mouseover to look more "clickable"
            var stickout = [0,0];
            if(dialog.user_data['context'] && dialog.user_data['context'].user_data['item'] == item) {
                if(!dialog.widgets['loot_frame'+wname].pushed) { stickout = [0,-1]; }
            }
            dialog.widgets['loot_item'+wname].bg_image_offset = stickout;
            dialog.widgets['loot_stack'+wname].text_offset = stickout;
            dialog.widgets['loot_frame'+wname].bg_image_offset = stickout;
        }
   }

    dialog.widgets['store_all_button'].state = ((dialog.user_data['pending'] == 0 && player.loot_buffer.length > 0) ? ((can_fit_all && !warehouse_busy) ? 'normal' : 'disabled_clickable') : 'disabled');
    dialog.widgets['store_all_button'].tooltip.str = null;
    dialog.widgets['warehouse_busy'].show = false; // warehouse_busy;
    dialog.widgets['warehouse_full'].show = (!warehouse_busy && !can_fit_all);
    if(dialog.widgets['warehouse_full'].show) {
        dialog.widgets['warehouse_full'].str = dialog.data['widgets']['warehouse_full'][need_storage_for_resource ? 'ui_name_resource' : 'ui_name'];
    }

    dialog.widgets['coverup_all'].show =
        dialog.widgets['coverup_icon'].show =
        dialog.widgets['coverup_text'].show =
        dialog.widgets['coverup_button'].show = warehouse_busy;
    dialog.widgets['loot_arrow'].show = !warehouse_busy;

    if(warehouse_busy) {
        dialog.widgets['coverup_icon'].asset = get_leveled_quantity(gamedata['buildings'][gamedata['inventory_building']]['art_asset'], 1);
        dialog.widgets['coverup_text'].str = dialog.data['widgets']['coverup_text']['ui_name_'+busy_reason];
        dialog.widgets['coverup_button'].str = dialog.data['widgets']['coverup_button']['ui_name_'+busy_reason];
        dialog.widgets['coverup_button'].onclick = (function(_helper) { return function(w) {
            var dialog = w.parent;
            if(dialog.children[dialog.children.length-1].user_data) {
                // already has a child window
                return;
            } else {
                helper();
            }
        }; })(helper);
        dialog.default_button = dialog.widgets['coverup_button'];
    } else {
        dialog.default_button = dialog.widgets['store_all_button'];
    }

    if(dialog.widgets['store_all_button'].state == 'disabled_clickable') {
        // help prompt for warehouse space
        if(helper) {
            dialog.widgets['store_all_button'].onclick = helper;
            dialog.widgets['store_all_button'].tooltip.str = dialog.data['widgets']['store_all_button']['ui_tooltip_' + (warehouse_busy ? 'warehouse_busy' : (need_storage_for_resource  ? 'need_storage ' : 'need_space'))];
            dialog.widgets['store_all_button'].tooltip.text_color = SPUI.error_text_color;
        } else {
            dialog.widgets['store_all_button'].state = 'disabled';
        }
    } else {
        dialog.widgets['store_all_button'].onclick = function(clicked_widget) {
            var _dialog = clicked_widget.parent;
            _dialog.user_data['pending'] = -1;
            _dialog.widgets['glow'].show = true;
            _dialog.widgets['glow'].reset_fx();
            send_to_server.func(["LOOT_BUFFER_TAKE", player.loot_buffer, -1]);
            for(var i = 0; i < player.loot_buffer.length; i++) {
                player.loot_buffer[i]['pending'] = 1;
            }

            for(var y = 0; y < _dialog.data['widgets']['loot_slot']['array'][1]; y++) {
                for(var x = 0; x < _dialog.data['widgets']['loot_slot']['array'][0]; x++) {
                    var wname = x.toString()+','+y.toString();
                    var w = _dialog.widgets['loot_item'+wname];
                    if(w.show) {
                        var slot = y * _dialog.data['widgets']['loot_slot']['array'][0] + x;
                        var item = player.loot_buffer[slot];

                        if(ItemDisplay.get_inventory_item_spec(item['spec'])['fungible']) {
                            ItemDisplay.add_inventory_item_effect(w, gamedata['strings']['combat_messages']["collected"], [1,1,0.3,1]);
                        } else {
                            _dialog.user_data['anim_data'][wname] = make_loot_dialog_anim_data(_dialog, w, w.asset);
                        }
                    }
                }
            }
        };
    }

    if(player.loot_buffer.length < 1 &&
       (!dialog.user_data['pending'] && dialog.widgets['glow'].fx_time_remaining() <= 0)) {
        close_parent_dialog(dialog.widgets['store_all_button']);
    }
}

/** @param {boolean=} force it to open even away from home */
function invoke_inventory_dialog(force) {
    if(!player.get_any_abtest_value('enable_inventory', gamedata['enable_inventory'])) { return null; }
    if(!session.home_base && !force) { return null; }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['inventory_dialog']);
    dialog.user_data['dialog'] = 'inventory_dialog';
    dialog.user_data['context'] = null;
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };
    dialog.ondraw = update_inventory_dialog;
    return dialog;
}
function update_inventory_dialog(dialog) {
    var any_expiring = false;

    var provides = gamedata['buildings'][gamedata['inventory_building']]['provides_inventory'];
    var max_possible_slots = provides[provides.length-1];
    var warehouse_busy = player.warehouse_is_busy();

    var craft_products = [], craft_product_i = 0;
    if(player.max_usable_inventory() < player.max_inventory && false /*gamedata['crafting_delivery_method'] == 'reserve_slot_on_start'*/) {
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.is_building() && obj.is_crafting() && (obj.team === 'player')) {
                goog.array.forEach(obj.get_crafting_queue(), function(bus) {
                    var recipe = gamedata['crafting']['recipes'][bus['craft']['recipe']];
                    craft_products = craft_products.concat(recipe['product']);
                });
            }
        }
    }

    var cols = dialog.data['widgets']['slot']['array'][0];
    for(var y = 0; y < dialog.data['widgets']['slot']['array'][1]; y++) {
        for(var x = 0; x < cols; x++) {
            var wname = x.toString()+','+y.toString();
            var slot = y*cols + x;
            dialog.widgets['item'+wname].show =
                dialog.widgets['slot'+wname].show =
                dialog.widgets['stack'+wname].show =
                dialog.widgets['timer_icon'+wname].show =
                dialog.widgets['timer'+wname].show =
                dialog.widgets['pending'+wname].show =
                dialog.widgets['frame'+wname].show = false;

            if(slot < player.max_usable_inventory()) {
                dialog.widgets['slot'+wname].show = true;
                dialog.widgets['slot'+wname].state = 'normal';
                if(slot < player.inventory.length) {
                    var item = player.inventory[slot];
                    var spec = ItemDisplay.get_inventory_item_spec(item['spec']);

                    dialog.widgets['item'+wname].show = true;
                    ItemDisplay.set_inventory_item_asset(dialog.widgets['item'+wname], spec);
                    ItemDisplay.set_inventory_item_stack(dialog.widgets['stack'+wname], spec, item);

                    dialog.widgets['frame'+wname].show = true;

                    if('expire_time' in item) {
                        any_expiring = true;
                        dialog.widgets['timer_icon'+wname].show = true;
                        dialog.widgets['timer'+wname].show = true;
                        dialog.widgets['timer'+wname].str = do_pretty_print_time(item['expire_time']-server_time, 1, false);
                    }

                    var can_activate;
                    if('fungible' in spec) {
                        can_activate = true;
                    } else if('use' in spec) {
                        can_activate = true;
                        if('requires' in spec && !read_predicate(spec['requires']).is_satisfied(player,null)) {
                            can_activate = false;
                        }
                        if(can_activate) {
                            var uselist = get_as_array(spec['use']);
                            for(var m = 0; m < uselist.length; m++) {
                                var use = uselist[m];
                                if('spellname' in use) {
                                    var spellname = use['spellname'];
                                    var spellarg = use['spellarg'] || null;
                                    var spell = gamedata['spells'][spellname];
                                    var temp_arg;
                                    if(spell['activation'] && spell['activation'].indexOf('targeted') == 0) {
                                        temp_arg = [spellarg,null];
                                    } else {
                                        temp_arg = spellarg;
                                    }
                                    can_activate = can_cast_spell(GameObject.VIRTUAL_ID, spellname, temp_arg);
                                } else if('consequent' in use) {
                                    can_activate = true;
                                } else {
                                    can_activate = false;
                                }
                                if(!can_activate) { break; }
                            }
                        }
                    } else if('equip' in spec && (spec['equip']['kind'] == 'mobile' && 'name' in spec['equip'])) {
                        can_activate = true; // unit equips pop up upgrade dialog
                    } else {
                        can_activate = false;
                    }

                    if(item['pending']) { can_activate = false; }
                    if(warehouse_busy) { can_activate = false; }

                    dialog.widgets['frame'+wname].state = (!can_activate ? 'cooldown' : (dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === slot ? 'active' : 'normal'));

                    dialog.widgets['frame'+wname].onenter = (function (_slot, _item) { return function(w) {
                        var inv_dialog = w.parent;
                        if(inv_dialog.user_data['context']) {
                            // do not switch if context for this item is already up
                            if(inv_dialog.user_data['context'].user_data['slot'] === _slot &&
                               inv_dialog.user_data['context'].user_data['item'] === _item) {
                                return;
                            }
                            if(inv_dialog.user_data['context'].user_data['show_dropdown']) {
                                // do not switch if mouse is still somewhat within bounds of current context
                                var c = inv_dialog.user_data['context'];
                                var abs_xy = c.get_absolute_xy();
                                if((mouse_state.last_raw_x >= abs_xy[0]) && (mouse_state.last_raw_x < (abs_xy[0]+c.wh[0])) &&
                                   (mouse_state.last_raw_y >= abs_xy[1])) { // note: no check on Y max
                                    return;
                                }
                            }
                        }
                        invoke_inventory_context(w.parent, w, _slot, _item, false);
                    }; })(slot, item);
                    dialog.widgets['frame'+wname].onclick = (function (_slot, _item) { return function(w) {
                        var inv_dialog = w.parent;
                        if(inv_dialog.user_data['context'] &&
                           inv_dialog.user_data['context'].user_data['slot'] === _slot &&
                           inv_dialog.user_data['context'].user_data['item'] === _item &&
                           inv_dialog.user_data['context'].user_data['show_dropdown']) {
                            // if context menu is already up for this item, simulate a click on "Activate"

                            // pop up helper when item can't be used
                            if(player.warehouse_is_busy()) {
                                warehouse_busy_helper(find_object_by_type(gamedata['inventory_building']));
                                return;
                            }

                            var spec = ItemDisplay.get_inventory_item_spec(_item['spec']);

                            if('requires' in spec && !read_predicate(spec['requires']).is_satisfied(player,null)) { return; } // cannot use
                            if('use' in spec) {
                                var uselist = get_as_array(spec['use']);
                                for(var m = 0; m < uselist.length; m++) {
                                    var use = uselist[m];
                                    if('spellname' in use) {
                                        var spellname = use['spellname'];
                                        var spellarg = use['spellarg'] || null;
                                        var spell = gamedata['spells'][spellname];
                                        var temp_arg;
                                        if(spell['activation'] && spell['activation'].indexOf('targeted') == 0) {
                                            temp_arg = [spellarg,null];
                                        } else {
                                            temp_arg = spellarg;
                                        }
                                        var can_cast_detailed = (_item['pending'] ? [false, gamedata['strings']['inventory']['pending'], null] :
                                                                 can_cast_spell_detailed(GameObject.VIRTUAL_ID, spellname, temp_arg));
                                        if(!can_cast_detailed[0] && can_cast_detailed[2]) {
                                            // cannot cast
                                            var helper = get_requirements_help(can_cast_detailed[2][0], can_cast_detailed[2][1], can_cast_detailed[2][2] || null);
                                            if(helper) { helper(); }
                                            return;
                                        }
                                    }
                                }
                            }

                            if(inv_dialog.user_data['context'].widgets['button0'].state != 'disabled') {
                                inv_dialog.user_data['context'].widgets['button0'].onclick(inv_dialog.user_data['context'].widgets['button0']);
                            }

                        } else {
                            invoke_inventory_context(w.parent, w, _slot, _item, true);
                        }
                    }; })(slot, item);
                    dialog.widgets['frame'+wname].onleave_cb = (function (_slot, _item) { return function(w) {
                        var inv_dialog = w.parent;
                        if(inv_dialog.user_data['context'] &&
                           inv_dialog.user_data['context'].user_data['slot'] === _slot &&
                           inv_dialog.user_data['context'].user_data['item'] === _item &&
                           !inv_dialog.user_data['context'].user_data['show_dropdown']) {
                            invoke_inventory_context(w.parent, w, -1, null, false);
                        }
                    }; })(slot, item);
                    // make item/frame stick out a little bit on mouseover to look more "clickable"
                    var stickout = [0,0];
                    if(dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] == slot && dialog.user_data['context'].user_data['item'] == item) {
                        if(!dialog.widgets['frame'+wname].pushed) { stickout = [0,-1]; }
                    }
                    dialog.widgets['item'+wname].bg_image_offset = stickout;
                    dialog.widgets['stack'+wname].text_offset = stickout;
                    dialog.widgets['frame'+wname].bg_image_offset = stickout;
                }
            } else if(slot < player.max_inventory) {
                // it's a reserved slot for crafting
                dialog.widgets['slot'+wname].show = true;
                dialog.widgets['frame'+wname].show = true;
                dialog.widgets['frame'+wname].state = 'disabled';
                dialog.widgets['pending'+wname].show = true;
                if(craft_product_i < craft_products.length) {
                    var item = craft_products[craft_product_i];
                    var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
                    dialog.widgets['item'+wname].show = true;
                    ItemDisplay.set_inventory_item_asset(dialog.widgets['item'+wname], spec);
                    ItemDisplay.set_inventory_item_stack(dialog.widgets['stack'+wname], spec, item);
                    craft_product_i++;
                } else {
                    // unknown
                }
            } else if(slot < max_possible_slots) {
                dialog.widgets['slot'+wname].show = true;
                dialog.widgets['slot'+wname].state = 'locked';
                dialog.widgets['slot'+wname].onclick = function(w) {
                    var helper = get_requirements_help('inventory_space_offer', null);
                    if(helper) { helper(); }
                };
            } else {
                // do not show even a padlock
            }
        }
    }
    if('instructions_expire' in dialog.widgets) {
        dialog.widgets['instructions_expire'].show =
            dialog.widgets['instructions_expire_icon'].show = any_expiring;
    }

    if('upgrade_level' in dialog.widgets) {
        dialog.widgets['upgrade_level'].show = dialog.widgets['upgrade_button'].show = false;
        var warehouse = find_object_by_type(gamedata['inventory_building']);
        if('warehouse_label' in dialog.widgets) {
            dialog.widgets['warehouse_label'].show = !!warehouse;
            dialog.widgets['warehouse_label'].str = dialog.data['widgets']['warehouse_label']['ui_name'].replace('%d', (warehouse ? warehouse.level.toString() : 'unknown'));
        }

        if(warehouse) {
            var max_level = warehouse.get_max_ui_level();
            if(warehouse.level < max_level) {
                dialog.widgets['upgrade_level'].show = dialog.widgets['upgrade_button'].show = true;
                var cur_slots = get_leveled_quantity(provides, warehouse.level);
                var next_slots = get_leveled_quantity(provides, Math.min(max_level, warehouse.level+1));
                var add_slots = next_slots - cur_slots;

                for(var w in {'upgrade_level':1,'upgrade_button':1}) {
                    dialog.widgets[w].str = dialog.data['widgets'][w]['ui_name'].replace('%CUR', warehouse.level.toString()).replace('%NEXT', (warehouse.level+1).toString()).replace('%SLOT', add_slots.toString()).replace('%plural', (add_slots == 1 ? '' : 's'));
                }

                dialog.widgets['upgrade_button'].onclick = (function (_warehouse) { return function(w) {
                    change_selection_unit(_warehouse);
                    invoke_upgrade_building_dialog();
                }; })(warehouse);
            }
        }
    }
};

/** @param {SPUI.Dialog} inv_dialog
    @param {SPUI.DialogWidget} parent_widget
    @param {?} slot
    @param {Object} item
    @param {boolean} show_dropdown
    @param {Object=} props */
function invoke_inventory_context(inv_dialog, parent_widget, slot, item, show_dropdown, props) {

    if(inv_dialog.user_data['context']) {
        var dialog = inv_dialog.user_data['context'];
        if(dialog.user_data['slot'] === slot && dialog.user_data['item'] === item &&
           dialog.user_data['show_dropdown'] === show_dropdown) {
            return dialog;
        }
        if(dialog.parent) { dialog.parent.remove(dialog); }
        //inv_dialog.remove(dialog);
        inv_dialog.user_data['context'] = null;
    }
    if(slot < 0) { return null; }

    // SPUI.Container to which this widget will be parented (usually inv_dialog, but may be overridden)
    var parent_dialog = (props && props['parent_dialog'] ? props['parent_dialog'] : inv_dialog);

    var dialog = new SPUI.Dialog(gamedata['dialogs']['inventory_context']);
    dialog.user_data['props'] = props || null;
    dialog.user_data['parent_widget'] = parent_widget;
    dialog.user_data['parent_dialog'] = parent_dialog;
    dialog.user_data['slot'] = slot;
    dialog.user_data['item'] = item;
    if('expire_time' in item) { dialog.user_data['expire_time'] = item['expire_time']; }
    if('melt_duration' in item) { dialog.user_data['melt_duration'] = item['melt_duration']; }
    dialog.user_data['show_dropdown'] = show_dropdown;


    var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
    var can_cast_detailed = null;
    if('fungible' in spec) {
        can_cast_detailed = [true,null,null];
    } else if('use' in spec) {
        if('requires' in spec && !read_predicate(spec['requires']).is_satisfied(player,null)) {
            var pred = read_predicate(spec['requires']);
            can_cast_detailed = [false, pred.ui_describe(player), [pred, null]];
        } else {
            var uselist = get_as_array(spec['use']);
            for(var m = 0; m < uselist.length; m++) {
                var use = uselist[m];
                if('spellname' in use) {
                    var spellname = use['spellname'];
                    var spellarg = use['spellarg'] || null;
                    var spell = gamedata['spells'][spellname];
                    var temp_arg;
                    if(spell['activation'] && spell['activation'].indexOf('targeted') == 0) {
                        temp_arg = [spellarg,null];
                    } else {
                        temp_arg = spellarg;
                    }
                    can_cast_detailed = (item['pending'] ? [false, gamedata['strings']['inventory']['pending'], null] :
                                         can_cast_spell_detailed(GameObject.VIRTUAL_ID, spellname, temp_arg));
                } else if('consequent' in use) {
                    can_cast_detailed = [true,null,null];
                }
                if(!can_cast_detailed[0]) {
                    // stop at first false condition
                    break;
                }
            }
        }
    } else if('equip' in spec && spec['equip']['kind'] == 'building') {
        can_cast_detailed = [false, gamedata['strings']['inventory']['building_equip_tooltip'], null];
    } else if('equip' in spec && spec['equip']['kind'] == 'mobile') {
        if('name' in spec['equip']) {
            can_cast_detailed = [true,null,null];
        } else {
            can_cast_detailed = [false, gamedata['strings']['inventory']['unit_equip_tooltip'], null];
        }
    } else {
        can_cast_detailed = [false,null,null];
    }

    if(can_cast_detailed === null) { throw Error('cannot determine usability of item '+spec['name']); }
    var can_cast = can_cast_detailed[0];


    dialog.widgets['title'].str = ItemDisplay.get_inventory_item_ui_name_long(spec);
    dialog.widgets['title'].text_color = ItemDisplay.get_inventory_item_color(spec);

    // add optional subtitle and move description downward
    var subtitle = ItemDisplay.get_inventory_item_ui_subtitle(spec);
    if(subtitle) {
        dialog.widgets['subtitle'].wh = [dialog.data['widgets']['subtitle']['dimensions'][0], dialog.data['widgets']['description']['dimensions'][1]];
        dialog.widgets['subtitle'].str = subtitle;
        dialog.widgets['subtitle'].show = true;
        dialog.widgets['description'].xy = vec_add(dialog.data['widgets']['description']['xy'], [0,dialog.widgets['subtitle'].wh[1]]);
    }

    // enlarge width of tooltip area to fit name text, if necessary
    var name_w = Math.max(dialog.widgets['title'].font.measure_string(dialog.widgets['title'].str)[0],
                          dialog.widgets['subtitle'].font.measure_string(dialog.widgets['subtitle'].str)[0]);

    // add extra padding for set-bonus items to help avoid extra line breaks in the set-bonus tooltip
    if(spec['item_set']) {
        name_w += dialog.widgets['subtitle'].font.measure_string('(0/0):')[0]; // My Item set (0/0):
        // max() of sibling item name lengths
        var item_set = gamedata['item_sets'][spec['item_set']];
        goog.array.forEach(item_set['members'], function(sibling) {
            var sibling_name = gamedata['items'][sibling]['ui_name'];
            name_w = Math.max(name_w, dialog.widgets['subtitle'].font.measure_string(sibling_name)[0]);
        });
    }

    if((name_w + 2 * dialog.data['widgets']['title']['xy'][0]) > dialog.data['dimensions'][0]) {
        dialog.wh = [name_w + 2 * dialog.data['widgets']['title']['xy'][0], dialog.wh[1]];
        dialog.widgets['bgrect'].wh = vec_copy(dialog.wh); // note: height is reset down below
        dialog.widgets['description'].wh = vec_sub(dialog.widgets['bgrect'].wh, [2 * dialog.data['widgets']['description']['xy'][0],0]);

        // recenter buttons
        dialog.widgets['buttonbg'].xy = [Math.floor((dialog.wh[0] - dialog.data['widgets']['buttonbg']['dimensions'][0])/2), dialog.widgets['buttonbg'].xy[1]];
        for(var i = 0; i < dialog.data['widgets']['button']['array'][1]; i++) {
            dialog.widgets['button'+i].xy = [Math.floor((dialog.wh[0]-dialog.data['widgets']['button']['dimensions'][0])/2),
                                             dialog.widgets['button'+i].xy[1]];
        }
    }

    // enlarge height to fit description text
    dialog.widgets['description'].set_text_bbcode(ItemDisplay.get_inventory_item_ui_description(spec, ('stack' in item ? item['stack'] : 1), item['item_duration']));
    dialog.widgets['description'].update_dims(); // force immediate text layout so we can determine how much space it takes up
    dialog.widgets['bgrect'].wh[1] = dialog.widgets['title'].wh[1] + dialog.widgets['subtitle'].wh[1] + dialog.widgets['description'].wh[1];

    // optionally add expiration timer
    if(('expire_time' in item) || ('melt_duration' in item) || (props && props['error_text'])) {
        dialog.widgets['expires'].show = true;
        dialog.widgets['expires'].xy[1] = dialog.widgets['description'].xy[1] + dialog.widgets['description'].wh[1] - dialog.widgets['description'].font.size;
        if(props && props['error_text']) {
            dialog.widgets['expires'].set_text_with_linebreaking(props['error_text']);
            // have to pre-measure here since setting xy requires a correct value for this.wh[0]
            dialog.widgets['expires'].wh = dialog.widgets['expires'].font.measure_string(dialog.widgets['expires'].str);
        }

        dialog.widgets['bgrect'].wh[1] += dialog.widgets['expires'].wh[1];
    }
    dialog.widgets['bgrect'].wh[1] += 4;

    // position relative to parent
    var slot_xy = vec_sub(parent_widget.get_absolute_xy(), parent_dialog.get_absolute_xy()); // parent_widget.xy;
    var slot_wh = parent_widget.wh;
    if(props && props['position'] == 'top_or_bottom') {
        if(parent_widget.get_absolute_xy()[1] + slot_wh[1] + dialog.widgets['bgrect'].wh[1] >= canvas_height) {
            props['position'] = 'top';
        } else {
            props['position'] = 'bottom';
        }
    }
    if(props && props['position'] == 'right') {
        dialog.xy = [slot_xy[0] + slot_wh[0] + 1,
                     slot_xy[1]];
    } else if(props && props['position'] == 'top') {
        dialog.xy = [Math.floor(slot_xy[0]+slot_wh[0]/2 - dialog.wh[0]/2),
                     slot_xy[1] - dialog.widgets['bgrect'].wh[1] - 2];
    } else {
        dialog.xy = [Math.floor(slot_xy[0]+slot_wh[0]/2 - dialog.wh[0]/2),
                     Math.floor(slot_xy[1]+slot_wh[1]+1)];
    }

    dialog.user_data['base_xy'] = dialog.xy;

    // initialize button drop-down
    dialog.user_data['anim_start'] = (show_dropdown ? client_time : -1);

    var make_button_cb = function (_slot, _item, _i) { return function(w) {
        if(!w.parent) { return; }
        var butt = w.parent.user_data['buttons'][_i];

        if(butt[3] === "SPEEDUP") {
            warehouse_busy_helper(find_object_by_type(gamedata['inventory_building']));
        } else if(butt[3] === "EQUIP_UNIT") {
            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            var unit_name = spec['equip']['name'];
            var d = invoke_upgrade_tech_dialog(gamedata['units'][unit_name]['level_determined_by_tech'], null);
            if(d && d.user_data['dialog'] == 'upgrade_dialog') {
                // pop up chooser
                // is item already equipped?
                var identical_found = false, any_found = false;
                var eq = player.unit_equipment;
                if(unit_name in eq) {
                    if(spec['equip']['slot_type'] in eq[unit_name]) {
                        for(var i = 0; i < eq[unit_name][spec['equip']['slot_type']].length; i++) {
                            any_found = true;
                            if(eq[unit_name][spec['equip']['slot_type']][i] === item['spec']) {
                                identical_found = true; break;
                            }
                        }
                    }
                }
                if(!identical_found && (spec['equip']['slot_type'] in d.user_data['equip_slots_by_type'])) {
                    var slot_i = d.user_data['equip_slots_by_type'][spec['equip']['slot_type']];
                    d.widgets['equip_frame'+slot_i].mouse_enter_time = client_time; //state = 'active';
                    var chooser = invoke_equip_chooser(d, d.widgets['equip_frame'+slot_i], d.user_data['tech'], d.user_data['unit'], spec['equip']['slot_type'], 0, slot_i);
                    // if there are two possibilities, and the slot is empty, just do the equip immediately
                    if(!any_found && chooser.widgets['equip_frame0'].show && !chooser.widgets['equip_frame1'].show && chooser.widgets['equip_frame0'].state != 'disabled') {
                        chooser.widgets['equip_frame0'].onclick(chooser.widgets['equip_frame0']);
                    }
                }
            }

        } else if(inventory_action(_item, _slot, butt[3], session.has_deployed)) { // trigger GCD during combat only
            w.str = butt[1];
            w.state = 'disabled';

            // disable all other buttons
            if(w.parent) {
                for(var j = 0; j < w.parent.user_data['buttons'].length; j++) {
                    w.parent.widgets['button'+j.toString()].state = 'disabled';
                }
            }
        }
    }; };

    if(player.warehouse_is_busy()) {
        dialog.user_data['buttons'] = [[gamedata['strings']['inventory']['warehouse_busy'],"",1,"SPEEDUP"]];
    } else {
        dialog.user_data['buttons'] = [];
        if('equip' in spec && spec['equip']['kind'] == 'mobile' && ('name' in spec['equip'])) {
            dialog.user_data['buttons'].push([gamedata['strings']['inventory']['equip_button'],
                                              gamedata['strings']['inventory']['equip_button_pending'],
                                              1,"EQUIP_UNIT"]);
        } else {
            var name = spec['ui_activate_button'] || gamedata['strings']['inventory']['activate_button'];
            var name_pending = spec['ui_activate_button_pending'] || gamedata['strings']['inventory']['activate_button_pending'];
            dialog.user_data['buttons'].push([name, name_pending,
                                              1,"INVENTORY_USE"]);
        }

        // show refund button when a refund exists and show_refundable_when is true
        if(spec['refund'] && (('refundable_when' in spec) ? read_predicate(spec['refundable_when']).is_satisfied(player, null) : true)) {
            dialog.user_data['buttons'].push([gamedata['strings']['inventory']['refund_button'],
                                              gamedata['strings']['inventory']['refund_button_pending'],
                                              0,"INVENTORY_REFUND_ALL"]);
        }

        dialog.user_data['buttons'].push([gamedata['strings']['inventory']['discard_button'],
                                          gamedata['strings']['inventory']['discard_button_pending'],
                                          0,"INVENTORY_TRASH"]);
        if(item['stack'] && item['stack'] > 1) {
            dialog.user_data['buttons'].push([gamedata['strings']['inventory']['discard_all_button'],
                                              gamedata['strings']['inventory']['discard_all_button_pending'],
                                              0,"INVENTORY_TRASH_ALL"]);
        }
    }

    dialog.widgets['buttonbg'].wh[1] = 6 + 36 * dialog.user_data['buttons'].length;

    // figure out pop-out animation
    var anim_dir = ((parent_dialog.get_absolute_xy()[1]+dialog.user_data['base_xy'][1]+dialog.widgets['bgrect'].wh[1]+dialog.widgets['buttonbg'].wh[1]) > canvas_height ? 'right' : 'down');
    var start_pos, final_pos; // final position of dropdown's buttonbg
    if(anim_dir == 'down') {
        start_pos = [dialog.widgets['buttonbg'].xy[0], 0];
        final_pos = [dialog.widgets['buttonbg'].xy[0], dialog.widgets['bgrect'].wh[1]];
        dialog.wh[1] = (show_dropdown ? (dialog.widgets['buttonbg'].xy[1] + dialog.widgets['buttonbg'].wh[1]) : dialog.widgets['bgrect'].wh[1]);
    } else if(anim_dir == 'right') {
        start_pos = [dialog.widgets['buttonbg'].xy[0], 0];
        final_pos = [dialog.widgets['bgrect'].wh[0], 0];
        dialog.wh[0] = (show_dropdown ? (dialog.widgets['bgrect'].wh[0] + dialog.widgets['buttonbg'].wh[0]) : dialog.widgets['bgrect'].wh[0]);
    } else {
        throw Error('bad anim_dir '+anim_dir.toString());
    }
    dialog.widgets['buttonbg'].xy = final_pos;

    // anim_data has start and end XY coordinates for bgrect and each button
    dialog.user_data['anim_data'] = {'buttonbg': [start_pos, final_pos]};

    for(var i = 0; i < dialog.data['widgets']['button']['array'][1]; i++) {
        var widget = dialog.widgets['button'+i.toString()];
        // offset relative to upper-left corner of bgrect
        var offset = [(dialog.data['widgets']['button']['xy'][0]-dialog.data['widgets']['buttonbg']['xy'][0]),
                      (dialog.data['widgets']['button']['xy'][1]-dialog.data['widgets']['buttonbg']['xy'][1]) + i * dialog.data['widgets']['button']['array_offset'][1]];

        widget.xy = vec_add(final_pos, offset);
        dialog.user_data['anim_data']['button'+i.toString()] = [vec_add(start_pos, offset), vec_add(final_pos, offset)];

        if(i >= dialog.user_data['buttons'].length) {
            widget.show = 0;
        } else {
            var butt = dialog.user_data['buttons'][i];
            widget.show = 1;
            widget.str = (item['pending'] && item['pending_action'] == butt[3] ? butt[1] : butt[0]);
            widget.state = ((item['pending'] || (butt[3]=="INVENTORY_USE"&&!can_cast)) ? 'disabled' : 'normal');
            widget.bg_image = dialog.data['widgets']['button']['bg_image_'+(butt[2] ? 'active':'passive')];
            var cb = make_button_cb(slot, item, i);
            if(butt[3] == "INVENTORY_USE" && !can_cast) { // add tooltip
                var tooltip_str = SPUI.break_lines(can_cast_detailed[1], SPUI.desktop_font, widget.data['max_tooltip_dimensions'])[0];
                widget.tooltip.str = tooltip_str;
                widget.tooltip.text_color = SPUI.error_text_color;
                if(!can_cast_detailed[0] && can_cast_detailed[2]) {
                    var helper = get_requirements_help(can_cast_detailed[2][0], can_cast_detailed[2][1], can_cast_detailed[2][2] || null);
                    if(helper) {
                        widget.onclick = helper;
                        widget.state = 'disabled_clickable';
                    }
                }
            } else if(butt[3].indexOf("INVENTORY_TRASH") == 0 || butt[3].indexOf("INVENTORY_REFUND") == 0) { // add confirmation prompt
                var want_refund = (butt[3].indexOf("INVENTORY_REFUND") == 0);
                if(item['undiscardable']) { // really for tutorial only
                    widget.state = 'disabled';
                    widget.tooltip.str = gamedata['strings']['inventory']['undiscardable_tooltip'];
                } else if(want_refund) {
                    var pred = ('refundable_when' in spec) ? read_predicate(spec['refundable_when']) : null;
                    if(pred && !pred.is_satisfied(player, null)) {
                        widget.state = 'disabled';
                        widget.tooltip.str = gamedata['strings']['inventory']['unrefundable_tooltip'].replace('%s', pred.ui_describe(player));
                    }
                }

                widget.onclick = (function (_cb, _item, _i, _want_refund) { return function (w) {
                    var butt = w.parent.user_data['buttons'][_i];
                    var s;
                    if(_want_refund) {
                        s = gamedata['strings']['inventory_confirm_refund'];
                    } else {
                        s = gamedata['strings']['inventory_confirm_discard_'+(butt[3] == "INVENTORY_TRASH_ALL" ? 'all':'one')];
                    }
                    var spec = ItemDisplay.get_inventory_item_spec(_item['spec']);
                    var ui_name = ItemDisplay.get_inventory_item_ui_name(spec);
                    var descr = s['ui_description'].replace('%s', ui_name).replace('%d', ('stack' in _item ? ItemDisplay.get_inventory_item_stack_prefix(spec, _item['stack']) : ''));
                    if(_want_refund) {
                        descr = descr.replace('%refund', ItemDisplay.get_inventory_item_refund_str(spec, _item['stack'] || 1));
                    }
                    invoke_child_message_dialog(s['ui_title'].replace('%s', ui_name), descr,
                                                {'cancel_button': true,
                                                 'ok_button_ui_name': s['ui_button'],
                                                 'on_ok': (function (__cb, _w) { return function() { __cb(_w); }; })(_cb, w)});
                }; })(cb, item, i, want_refund);
            } else {
                widget.onclick = cb;
            }
        }
    }

    dialog.ondraw = update_inventory_context;

    inv_dialog.user_data['context'] = dialog;
    parent_dialog.add(dialog);
    return dialog;
}

function update_inventory_context(dialog) {
    var props = dialog.user_data['props'];
    var parent_dialog = dialog.user_data['parent_dialog'];

    if(props && ('parent_offset' in props)) {
        dialog.xy = vec_add(dialog.user_data['base_xy'], props['parent_offset']);
    }

    // don't let it get cut off the left edge of the screen
    if(parent_dialog.xy[0]+dialog.xy[0] < 0) {
        dialog.xy[0] = -parent_dialog.xy[0];
    }

    var anim_progress = Math.min((client_time - dialog.user_data['anim_start'])/0.2, 1);
    for(var name in dialog.widgets) {
        if(name in dialog.user_data['anim_data']) {
            dialog.widgets[name].show = dialog.user_data['show_dropdown'] && (dialog.user_data['buttons'].length > 0);
            var start = dialog.user_data['anim_data'][name][0], end = dialog.user_data['anim_data'][name][1];
            dialog.widgets[name].xy = vec_floor(vec_add(start, vec_scale(anim_progress, vec_sub(end,start))));
        }
    }
    if('expire_time' in dialog.user_data) {
        var kind = ('aura' in dialog.user_data ? 'aura' : 'item');
        var template = dialog.widgets['expires'].data['ui_name_'+kind];
        if(kind === 'aura') {
            // optional override for the wording of the expiration message
            var aura_spec = gamedata['auras'][dialog.user_data['aura']['spec']];
            if('ui_expires' in aura_spec) {
                template = aura_spec['ui_expires'];
            }
        }
        dialog.widgets['expires'].str = template.replace('%s', pretty_print_time(dialog.user_data['expire_time']-server_time));
    } else if('melt_duration' in dialog.user_data) {
        dialog.widgets['expires'].str = dialog.widgets['expires'].data['ui_name_melt_duration'].replace('%s', pretty_print_time(dialog.user_data['melt_duration']));
    }
}

function inventory_action(item, slot, action, trigger_gcd) {
    if(('pending' in item) || player.cooldown_active('GCD')) { return false; }

    if(action == "INVENTORY_USE") {
        // see if we need to do a targeted activation
        var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
        if('use' in spec) {
            var uselist = get_as_array(spec['use']);
            for(var m = 0; m < uselist.length; m++) {
                var use = uselist[m];
                if('spellname' in use) {
                    var spellname = use['spellname'];
                    var spellarg = use['spellarg'] || null;
                    var spell = gamedata['spells'][spellname];
                    if(spellname === "SHOW_STORE") {
                        change_selection_ui(null);
                        invoke_store();
                        return true;
                    } else if(spellname === "CLIENT_CONSEQUENT") {
                        read_consequent(spellarg).execute();
                        return true;
                    } else if(spellname.indexOf("CHANGE_REGION_INSTANTLY") == 0) {
                        invoke_change_region_dialog((function (_item, _slot, _action, _trigger_gcd) { return function(spellarg) {
                            inventory_send_request(_item, _slot, _action, spellarg, _trigger_gcd);
                            return true;
                        }; })(item, slot, action, trigger_gcd), spellname);
                        return true;
                    } else if(spellname === "APPLY_AURA") {
                        var aura_name = spellarg[1];
                        var overlap = null;
                        for(var i = 0; i < player.player_auras.length; i++) {
                            if(player.player_auras[i]['spec'] == aura_name) {
                                overlap = aura_name;
                                break;
                            }
                        }
                        if(overlap) {
                            // warn player that this will overwrite instead of stacking on top of the current aura
                            var do_it = (function (_item, _slot, _action, _trigger_gcd) { return function(spellarg) {
                                inventory_send_request(_item, _slot, _action, spellarg, _trigger_gcd);
                                return true;
                            }; })(item, slot, action, trigger_gcd);
                            var msg = gamedata['strings']['player_aura_confirm_overwrite'];
                            invoke_child_message_dialog(msg['ui_title'],
                                                        msg['ui_description'].replace('%item', spec['ui_name']).replace('%existing', gamedata['auras'][aura_name]['ui_name']),
                                                        {'cancel_button':true,
                                                         'ok_button_ui_name': msg['ui_button'],
                                                         'dialog': 'message_dialog_big',
                                                         'on_ok': do_it});
                            return false;
                        } else {
                            continue; // no problem
                        }
                    } else if(spell['activation'] == 'instant') {
                        // fall through; this just sends it with no further UI
                        continue;
                    } else if(spell['activation'] == 'targeted_build') {
                        change_selection(null);
                        selection.spellname = "BUILD";
                        selection.spellkind = spellarg;
                        selection.slot = slot;
                        selection.item = item;
                        change_selection_ui_under(new BuildUICursor(null, gamedata['buildings'][spellarg]));
                        return true;
                    } else if(spell['activation'] == 'targeted_area') {
                        change_selection(null);
                        selection.spellname = spellname;
                        selection.spellkind = null;
                        selection.slot = slot;
                        selection.item = item;
                        var splash = gamedata['map']['splash_range_conversion'] * get_leveled_quantity(spell['splash_range'] || 0, 1);
                        change_selection_ui_under(new AOEUICursor(null, -1, splash));
                        return true;
                    } else if(spell['activation'] == 'targeted_alliance_mate') {
                        invoke_alliance_mate_gift_dialog((function (_item, _slot, _action, _trigger_gcd) { return function(recipient_id) {
                            inventory_send_request(_item, _slot, _action, [recipient_id], _trigger_gcd);
                            return true;
                        }; })(item, slot, action, trigger_gcd));
                        return false;
                    } else if(spell['activation'] == 'targeted_friend') {
                        invoke_friend_gift_dialog((function (_item, _slot, _action, _trigger_gcd) { return function(recipient_id) {
                            inventory_send_request(_item, _slot, _action, [recipient_id], _trigger_gcd);
                            return true;
                        }; })(item, slot, action, trigger_gcd),
                                                  spec['pre_use'] || spell['pre_activation'] || null);
                        return false;
                    } else {
                        throw Error('unhandled inventory item spell activation type '+spell['activation'].toString()+' for '+spec['name']);
                    }
                }
            }
        }
    }
    inventory_send_request(item, slot, action, null, trigger_gcd);
    return true;
}

function inventory_send_request(item, slot, action, spellargs, trigger_gcd) {
    item['pending'] = 1;
    item['pending_time'] = client_time;
    item['pending_action'] = action;
    if(trigger_gcd) { player.cooldown_client_trigger('GCD', gamedata['client']['global_cooldown']); }
    if(!spellargs) { spellargs = null; }
    send_to_server.func([action, slot, item['spec'], spellargs]);

    if(action == 'INVENTORY_USE' && typeof(slot) == 'object') {
        // for equip items, remove from home_equip_items here
        // note, if the USE fails, then we'll be missing the item!
        goog.array.remove(session.home_equip_items, slot);
    }
}

function invoke_alliance_mate_gift_dialog(callback) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['alliance_mate_gift_dialog']);
    dialog.user_data['dialog'] = 'alliance_mate_gift_dialog';
    dialog.user_data['callback'] = callback;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['portrait']['array'][1];
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    // list of pcache data for alliancemates
    dialog.user_data['rowdata'] = [];

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    AllianceCache.query_members(session.alliance_id, false, null, (function (_dialog) { return function(info) {
        invoke_alliance_mate_gift_dialog_members(_dialog, info);
    }; })(dialog));
    invoke_ui_locker();
    return dialog;
}

function invoke_alliance_mate_gift_dialog_members(dialog, info) {
    goog.array.forEach(['scroll_left','scroll_right','scroll_text'], function(wname) {
        dialog.widgets[wname].show = true;
    });

    if(info && info['members']) {
        goog.array.forEach(info['members'], function(member_info) {
            var member_id = member_info['user_id'];
            if(member_id == session.user_id) { return; }
            var player_info = PlayerCache.query_sync(member_id);
            if(player_info && player_info['player_level']) {
                dialog.user_data['rowdata'].push(player_info);
            }
        });
    }

    if(dialog.user_data['rowdata'].length < 1) {
        // no friends - skip!
        dialog.widgets['close_button'].onclick(dialog.widgets['close_button']);
        var s = gamedata['strings']['requirements_help']['alliance']['need_mates'];
        invoke_child_message_dialog(s['ui_title'], s['ui_description'], {'dialog':'message_dialog_big'});
        return;
    }

    // sort alphabetically
    dialog.user_data['rowdata'].sort(function (a,b) {
        var na = PlayerCache.get_ui_name(a);
        var nb = PlayerCache.get_ui_name(b);
        if(na < nb) {
            return -1;
        } else if(na > nb) {
            return 1;
        } else {
            return 0;
        }
    });
    dialog.user_data['rowfunc'] = alliance_mate_gift_dialog_setup_row;
    scrollable_dialog_change_page(dialog, 0);
    return dialog;
}

function alliance_mate_gift_dialog_setup_row(dialog, row, rowdata) {
    dialog.widgets['separator'+(row+1)].show =
        dialog.widgets['portrait'+row].show =
        dialog.widgets['name'+row].show =
        dialog.widgets['button'+row].show = (rowdata !== null);

    if(rowdata !== null) {
        var info = rowdata;
        dialog.widgets['portrait'+row].set_user(info['user_id']);
        dialog.widgets['name'+row].str = dialog.data['widgets']['name']['ui_name'].replace('%s', PlayerCache.get_ui_name(info) + ' (L'+(info['player_level']||1).toString()+')');

        dialog.widgets['button'+row].onclick = (function (_id) { return function(w) {
            var _cb = w.parent.user_data['callback'];
            close_parent_dialog(w);
            if(_id > 0) {
                _cb(_id);
                invoke_ui_locker();
            }
        }; })(rowdata['user_id']);
    }
}

// this is for giving in-game items via FRIEND_GIFT_LOOT spells. NOT for social-network gifting.
function invoke_friend_gift_dialog(callback, pre_use_consequent) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['alliance_mate_gift_dialog']);
    dialog.user_data['dialog'] = 'alliance_mate_gift_dialog';
    dialog.user_data['callback'] = callback;
    dialog.user_data['pre_use_consequent'] = pre_use_consequent;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['portrait']['array'][1];
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    // list of pcache data for friends
    dialog.user_data['rowdata'] = [];
    goog.array.forEach(player.friends, function(friend) {
        if(friend.is_real_friend) {
            dialog.user_data['rowdata'].push(PlayerCache.query_sync(friend.user_id));
        }
    });
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

//    AllianceCache.query_members(session.alliance_id, false, null, (function (_dialog) { return function(info) {
    invoke_friend_gift_dialog_members(dialog, null);
//    }; })(dialog));
//    invoke_ui_locker();
    return dialog;
}

function invoke_friend_gift_dialog_members(dialog, info) {
    goog.array.forEach(['scroll_left','scroll_right','scroll_text'], function(wname) {
        dialog.widgets[wname].show = true;
    });

    if(dialog.user_data['pre_use_consequent']) {
        read_consequent(dialog.user_data['pre_use_consequent']).execute({'num_friends': dialog.user_data['rowdata'].length});
    }

    if(dialog.user_data['rowdata'].length < 1) {
        // no friends - skip!
        dialog.widgets['close_button'].onclick(dialog.widgets['close_button']);
        var helper = get_requirements_help('friends', 'invite_for_gift');
        if(helper) { helper(); }
        return;
    }

    // sort alphabetically
    dialog.user_data['rowdata'].sort(function (a,b) {
        var na = PlayerCache.get_ui_name(a);
        var nb = PlayerCache.get_ui_name(b);
        if(na < nb) {
            return -1;
        } else if(na > nb) {
            return 1;
        } else {
            return 0;
        }
    });
    dialog.user_data['rowfunc'] = friend_gift_dialog_setup_row;
    scrollable_dialog_change_page(dialog, 0);
    return dialog;
}

function friend_gift_dialog_setup_row(dialog, row, rowdata) {
    dialog.widgets['separator'+(row+1)].show =
        dialog.widgets['portrait'+row].show =
        dialog.widgets['name'+row].show =
        dialog.widgets['button'+row].show = (rowdata !== null);

    if(rowdata !== null) {
        var info = rowdata;
        dialog.widgets['portrait'+row].set_user(info['user_id']);
        dialog.widgets['name'+row].str = dialog.data['widgets']['name']['ui_name'].replace('%s', PlayerCache.get_ui_name(info) + ' (L'+(info['player_level']||1).toString()+')');

        dialog.widgets['button'+row].onclick = (function (_id) { return function(w) {
            var _cb = w.parent.user_data['callback'];
            close_parent_dialog(w);
            if(_id > 0) {
                _cb(_id);
                invoke_ui_locker();
            }
        }; })(rowdata['user_id']);
    }
}

function invoke_equip_chooser(inv_dialog, parent_widget, tech, unit, slot_type, slot_n, ui_slot) {
    var equip = null, host_spec = null;
    if(tech && ('associated_unit' in tech)) {
        // unit equipment
        host_spec = gamedata['units'][tech['associated_unit']];
        equip = player.unit_equipment[tech['associated_unit']] || {};
    } else if(!tech && unit) {
        // building equipment
        host_spec = unit.spec;
        equip = unit.equipment;
    }

    // see what is equipped already, if anything
    var equipped_now = null;
    if(equip && (slot_type in equip) && (slot_n < equip[slot_type].length)) {
        equipped_now = equip[slot_type][slot_n];
    }

    var items = [];
    var seen_specs = {};
    for(var i = 0; i < player.inventory.length; i++) {
        var item = player.inventory[i];
        if(item['spec'] == equipped_now) { continue; } // don't list items the same type as what is already equipped
        if(item['spec'] in seen_specs) { continue; } // don't list duplicates
        seen_specs[item['spec']] = 1;
        var espec = ItemDisplay.get_inventory_item_spec(item['spec']);
        if('equip' in espec) {
            var can_equip_at_any_level, can_equip_now;
            var min_level = -1; // only >0 if we don't meet the requirement right now
            if(tech) {
                var crit = equip_is_compatible_with_unit(tech['name'], tech['associated_unit'], slot_type, espec, true);
                can_equip_at_any_level = !!crit;
                can_equip_now = can_equip_at_any_level && !!equip_is_compatible_with_unit(tech['name'], tech['associated_unit'], slot_type, espec, false);
                if(can_equip_at_any_level && !can_equip_now && crit['min_level']) { min_level = crit['min_level']; }
            } else {
                var crit = equip_is_compatible_with_building(unit, slot_type, espec, true);
                can_equip_at_any_level = !!crit;
                can_equip_now = can_equip_at_any_level && !!equip_is_compatible_with_building(unit, slot_type, espec, false);
                if(can_equip_at_any_level && !can_equip_now && crit['min_level']) { min_level = crit['min_level']; }
            }
            if(!can_equip_at_any_level) { continue; }

            // note: still show items that don't fit the level or uniqueness requirement

            var unique_conflict = null;
            if('unique_equipped' in espec) {
                var func = function(other_item) {
                    var other_name = other_item['spec'];
                    var other_spec = ItemDisplay.get_inventory_item_spec(other_name);
                    if(other_spec && other_spec['unique_equipped']==espec['unique_equipped'] &&
                       ((!equipped_now) || (gamedata['items'][equipped_now]||{})['unique_equipped'] != other_spec['unique_equipped'])) {
                        unique_conflict = other_name;
                        return true;
                    }
                }
                player.equipped_item_iter(func);
            }

            items.push([i, item, min_level, unique_conflict]);
        }
    }

    // if no applicable equipment is available, give a help dialog
    if(items.length < 1 && !equipped_now) {
        invoke_ingame_tip('no_equipment_tip', {force:true});
        return null;
    }

    // sort items by rarity
    items.sort(function(a, b) {
        var aspec = ItemDisplay.get_inventory_item_spec(a[1]['spec']), bspec = ItemDisplay.get_inventory_item_spec(b[1]['spec']);
        var ar = aspec['rarity'] || 0, br = bspec['rarity'] || 0;
        if(ar > br) {
            return 1;
        } else if(ar < br) {
            return -1;
        } else {
            return 0;
        }
    });

    var dialog = new SPUI.Dialog(gamedata['dialogs']['equip_chooser']);
    dialog.user_data['dialog'] = 'equip_chooser';
    dialog.xy = [parent_widget.xy[0] + parent_widget.wh[0] + 10, parent_widget.xy[1] + parent_widget.wh[1] - dialog.wh[1]]; // - 60];
    var extend = Math.max(items.length * dialog.data['widgets']['equip_item']['array_offset'][0], dialog.data['widgets']['bg']['min_extend']);
    dialog.wh = [dialog.data['dimensions'][0] + extend, dialog.data['dimensions'][1]];
    dialog.widgets['bg'].wh = vec_copy(dialog.wh);
    dialog.widgets['close_button'].xy = vec_add(dialog.data['widgets']['close_button']['xy'], [extend,0]);
    dialog.user_data['context'] = null;
    dialog.modal = 0.5;

    var go_away = (function(_inv_dialog) { return function(w) {
        close_parent_dialog(w);
    }; })(inv_dialog);

    dialog.widgets['bg_close_button'].onclick =
        dialog.widgets['close_button'].onclick = go_away;

    // handlers for the "equip nothing" button
    if(equipped_now) {
        // check for full warehouse
        var full = (player.inventory.length >= player.max_usable_inventory());
        dialog.widgets['equip_nothing_frame'].tooltip.str = dialog.data['widgets']['equip_nothing_frame']['ui_tooltip_'+(full?'full':'remove')].replace('%s', ItemDisplay.get_inventory_item_spec(equipped_now)['ui_name']);
        if(full) {
            dialog.widgets['equip_nothing_frame'].state = 'disabled';
        } else {
            // clicking on the "nothing" item removes whatever was equipped
            dialog.widgets['equip_nothing_frame'].onclick = (function (_equipped_now, _tech, _unit, _slot_type, _slot_n, _ui_slot) { return function(w) {
                if(_tech) {
                    // unit equipment
                    if(!(_tech['associated_unit'] in player.unit_equipment)) { player.unit_equipment[tech['associated_unit']] = {}; }
                    player.unit_equipment[tech['associated_unit']]['equip_pending'] = 1;
                    send_to_server.func(["EQUIP_UNIT", tech['associated_unit'], [_slot_type, _slot_n], -1, null, _equipped_now, _ui_slot]);
                } else {
                    _unit.equip_pending = true;
                    send_to_server.func(["EQUIP_BUILDING", _unit.id, [_slot_type, _slot_n], -1, null, _equipped_now, _ui_slot]);
                }
                close_parent_dialog(w);
            }; })(equipped_now, tech, unit, slot_type, slot_n, ui_slot);
        }
    } else {
        dialog.widgets['equip_nothing_frame'].onclick = go_away;
    }

    for(var i = 0; i < items.length; i++) {
        if(i >= dialog.data['widgets']['equip_item']['array'][0]) { break; }
        var inv_slot = items[i][0], item = items[i][1], min_level = items[i][2], unique_conflict = items[i][3];
        var spec = ItemDisplay.get_inventory_item_spec(item['spec']);

        dialog.widgets['equip_frame'+i].show =
            dialog.widgets['equip_stack'+i].show =
            dialog.widgets['equip_item'+i].show = true;
        ItemDisplay.set_inventory_item_asset(dialog.widgets['equip_item'+i], spec);
        ItemDisplay.set_inventory_item_stack(dialog.widgets['equip_stack'+i], spec, item);

        //dialog.widgets['equip_frame'+i].state = (spec['name'] === equipped_now ? 'active' : 'normal');
        var context_props = {};

        if(min_level > 0) {
            // show red text saying that player needs to upgrade the building
            dialog.widgets['equip_frame'+i].state = 'disabled_clickable';
            context_props['error_text'] = gamedata['errors'][(tech ? 'EQUIP_TECH_LEVEL_TOO_LOW' : 'EQUIP_BUILDING_LEVEL_TOO_LOW')]['ui_name'].replace('%s', min_level.toString());
            var helper = get_requirements_help(read_predicate(tech ? {'predicate': 'TECH_LEVEL', 'tech': tech['name'], 'min_level': min_level} :
                                                {'predicate': 'BUILDING_LEVEL', 'building_type': unit.spec['name'], 'trigger_level': min_level}), null);
            dialog.widgets['equip_frame'+i].onclick = (function (_helper) { return function(w) {
                if(helper) {
                    w.parent.widgets['close_button'].onclick(w.parent.widgets['close_button']);
                    helper();
                }
            }; })(helper);
        } else if(unique_conflict) {
            dialog.widgets['equip_frame'+i].state = 'disabled';
            dialog.widgets['equip_frame'+i].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['equip_frame'+i].tooltip.str = gamedata['errors']['EQUIP_INVALID_UNIQUE']['ui_name'].replace('%s', ItemDisplay.get_inventory_item_spec(unique_conflict)['ui_name']);
        } else {
            dialog.widgets['equip_frame'+i].onclick = (function (_inv_slot, _item, _tech, _unit, _slot_type, _slot_n, _ui_slot, _equipped_now) { return function(w) {
                if(_tech) {
                    // unit equipment
                    if(!(_tech['associated_unit'] in player.unit_equipment)) { player.unit_equipment[tech['associated_unit']] = {}; }
                    player.unit_equipment[tech['associated_unit']]['equip_pending'] = 1;
                    send_to_server.func(["EQUIP_UNIT", tech['associated_unit'], [_slot_type, _slot_n], _inv_slot, _item['spec'], _equipped_now, _ui_slot]);
                } else {
                    _unit.equip_pending = true;
                    send_to_server.func(["EQUIP_BUILDING", _unit.id, [_slot_type, _slot_n], _inv_slot, _item['spec'], _equipped_now, _ui_slot]);
                }

                close_parent_dialog(w);
            }; })(inv_slot, item, tech, unit, slot_type, slot_n, ui_slot, equipped_now);
        }

        if(!unique_conflict) {
            dialog.widgets['equip_frame'+i].onenter = (function (_inv_slot, _item, _context_props) { return function(w) {
                var dialog = w.parent;
                if(dialog.user_data['context'] &&
                   dialog.user_data['context'].user_data['slot'] === _inv_slot) { return; }
                _context_props['position'] = 'top_or_bottom';
                invoke_inventory_context(w.parent, w, _inv_slot, _item, false, _context_props);
            }; })(inv_slot, item, context_props);

            dialog.widgets['equip_frame'+i].onleave_cb = (function (_inv_slot, _item) { return function(w) {
                if(dialog.user_data['context'] &&
                   dialog.user_data['context'].user_data['slot'] === _inv_slot) {
                    invoke_inventory_context(w.parent, w, -1, null, false);
                }
            }; })(inv_slot, item);
        }
    }

    inv_dialog.user_data['equip_chooser'] = dialog;
    inv_dialog.add(dialog);
    return dialog;
}

function invoke_aura_context(inv_dialog, slot_xy, slot, aura, show_dropdown) {

    if(inv_dialog.user_data['aura_context']) {
        var dialog = inv_dialog.user_data['aura_context'];
        if(dialog.user_data['slot'] === slot && dialog.user_data['aura'] === aura &&
           dialog.user_data['show_dropdown'] === show_dropdown) {
            return;
        }
        inv_dialog.remove(dialog);
        inv_dialog.user_data['aura_context'] = null;
    }
    if(slot < 0) { return null; }

    var spec = gamedata['auras'][aura['spec']];
    var dialog = new SPUI.Dialog(gamedata['dialogs']['inventory_context']);
    var cols = inv_dialog.data['widgets']['aura_frame']['array'][0];
    var x = (slot % cols), y = Math.floor(slot / cols);
    dialog.user_data['parent_dialog'] = inv_dialog;
    dialog.user_data['props'] = null;
    dialog.user_data['slot'] = slot;
    dialog.user_data['aura'] = aura;
    if(('end_time' in aura) && (aura['end_time'] > 0)) { dialog.user_data['expire_time'] = aura['end_time']; }
    dialog.user_data['show_dropdown'] = show_dropdown;
    var slot_wh = [50,50]; // hard-coded icon size

    dialog.xy = [Math.floor(slot_xy[0]+slot_wh[0]/2 - dialog.wh[0]/2),
                 Math.floor(slot_xy[1]+slot_wh[1]+0)]; // note: no gap, so mouseover does not kill the popup

    // don't let it get cut off the left edge of the screen
    if(inv_dialog.xy[0]+dialog.xy[0] < 0) {
        dialog.xy[0] = -inv_dialog.xy[0];
    }
    dialog.user_data['base_xy'] = dialog.xy;

    /////////////////////////////

    // TITLE
    dialog.widgets['title'].str = spec['ui_name'];
    dialog.widgets['title'].text_color = ('name_color' in spec ? SPUI.make_colorv(spec['name_color']) : SPUI.default_text_color);

    // DESCRIPTION
    var descr = spec['ui_description' + (('stack' in aura) && (aura['stack'] > 1) && ('ui_description_plural' in spec) ? '_plural' : '')];
    if('strength' in aura) {
        descr = descr.replace('%abspct', ((1.0+aura['strength'])*100.0).toFixed(0));
        descr = descr.replace('%pct', ((aura['strength'])*100.0).toFixed(0));
        descr = descr.replace('%oneminuspct', ((1.0-aura['strength'])*100.0).toFixed(0));
        if(descr.indexOf("%price") != -1) {
            descr = descr.replace("%price", Store.display_user_currency_amount(Store.convert_credit_price_to_user_currency(aura['strength']), 'full'));
        }
        if(descr.indexOf("%secteam") != -1) {
            var unit_dic = aura['strength'][0]['units'];
            var ls = [];
            goog.object.forEach(unit_dic, function(qty, specname) {
                ls.push(qty.toString()+'x '+gamedata['units'][specname]['ui_name']);
            });
            descr = descr.replace("%secteam", ls.join(', '));
        }
    }
    if('stack' in aura) {
        descr = descr.replace('%stack', pretty_print_number(aura['stack']));
    }
    if('extra_ui_description' in aura) {
        descr += aura['extra_ui_description'];
    }

    //dialog.widgets['description'].set_text_with_linebreaking(descr);
    //dialog.widgets['description'].wh[1] = dialog.widgets['description'].str.split('\n').length * dialog.widgets['description'].font.leading + dialog.widgets['description'].font.size;
    dialog.widgets['description'].set_text_bbcode(descr);
    dialog.widgets['description'].update_dims(); // force immediate text layout so we can determine how much space it takes up
    dialog.widgets['bgrect'].wh[1] = dialog.widgets['title'].wh[1] + dialog.widgets['description'].wh[1];

    // EXPIRES
    if(('end_time' in aura) && (aura['end_time'] > 0)) {
        dialog.widgets['expires'].show = true;
        dialog.widgets['expires'].xy[1] = dialog.widgets['description'].xy[1] + dialog.widgets['description'].wh[1] - dialog.widgets['description'].font.size;
        dialog.widgets['bgrect'].wh[1] += dialog.widgets['expires'].wh[1];
    }

    /////////////////////////////////////////////


    dialog.widgets['bgrect'].wh[1] += 2;

    // initialize button drop-down
    dialog.user_data['anim_start'] = (show_dropdown ? client_time : -1);

    dialog.widgets['buttonbg'].xy[1] = dialog.widgets['bgrect'].wh[1];
    // anim_data has start and end Y coordinates for bgrect and each button
    var start_pos = [dialog.widgets['buttonbg'].xy[0],0];
    var final_pos = vec_copy(dialog.widgets['buttonbg'].xy);
    dialog.user_data['anim_data'] = {'buttonbg': [start_pos, final_pos] };

    var make_button_cb = function (_slot, _aura, _parent, _butt) { return function(w) {
        if(!('pending' in _aura)) {
            _aura['pending'] = 1;
            _aura['pending_action'] = _butt[3];
            w.str = _butt[1];
            w.state = 'disabled';

            send_to_server.func([_butt[3], _aura['spec']]);
            // disable all other buttons
            for(var j = 0; j < _parent.user_data['buttons'].length; j++) {
                _parent.widgets['button'+j.toString()].state = 'disabled';
            }

        }
    }; };

    dialog.user_data['buttons'] = [];
    var removable = (('cancelable' in spec && !spec['cancelable']) ? false : true);
    if(removable) {
        dialog.user_data['buttons'].push([gamedata['strings']['auras']['remove_button'],
                                          gamedata['strings']['auras']['remove_button_pending'],
                                          1,"CANCEL_PLAYER_AURA"]);
    }

    //if(dialog.user_data['buttons'].length < 1) { dialog.user_data['show_dropdown'] = false; }

    for(var i = 0; i < dialog.data['widgets']['button']['array'][1]; i++) {
        var widget = dialog.widgets['button'+i.toString()];
        // offset relative to upper-left corner of bgrect
        var offset = [(dialog.data['widgets']['button']['xy'][0]-dialog.data['widgets']['buttonbg']['xy'][0]),
                      (dialog.data['widgets']['button']['xy'][1]-dialog.data['widgets']['buttonbg']['xy'][1]) + i * dialog.data['widgets']['button']['array_offset'][1]];

        widget.xy = vec_add(final_pos, offset);
        dialog.user_data['anim_data']['button'+i.toString()] = [vec_add(start_pos, offset), vec_add(final_pos, offset)];

        if(i >= dialog.user_data['buttons'].length) {
            widget.show = 0;
        } else {
            var butt = dialog.user_data['buttons'][i];
            widget.show = 1;
            widget.str = (aura['pending'] && aura['pending_action'] == butt[3] ? butt[1] : butt[0]);
            widget.state = (aura['pending']  ? 'disabled' : 'normal');
            widget.bg_image = dialog.data['widgets']['button']['bg_image_'+(butt[2] ? 'active':'passive')];
            var cb = make_button_cb(slot, aura, dialog, butt);
            if(butt[3].indexOf("CANCEL_PLAYER_AURA") == 0) { // add confirmation prompt
                widget.onclick = (function (_cb, _aura, _i) { return function (w) {
                    var butt = w.parent.user_data['buttons'][_i];
                    var s = gamedata['strings']['player_aura_confirm_cancel'];
                    var spec = gamedata['auras'][_aura['spec']];
                    invoke_child_message_dialog(s['ui_title'].replace('%s', spec['ui_name']),
                                                s['ui_description'].replace('%s', spec['ui_name']),
                                                {'cancel_button': true,
                                                 'ok_button_ui_name': s['ui_button'],
                                                 'on_ok': (function (__cb, _w) { return function() { __cb(_w); }; })(_cb, w)});
                }; })(cb, aura, i);
            } else {
                widget.onclick = cb;
            }
        }
    }
    dialog.widgets['buttonbg'].wh[1] = 6 + 36 * dialog.user_data['buttons'].length;
    dialog.wh[1] = dialog.widgets['buttonbg'].xy[1] + dialog.widgets['buttonbg'].wh[1];
    dialog.ondraw = update_inventory_context; // reused

    inv_dialog.user_data['aura_context'] = dialog;
    inv_dialog.add(dialog);
    return dialog;
}

function request_unit_donation(alliance_building) {
    var spell = gamedata['spells']['REQUEST_UNIT_DONATION'];
    player.cooldown_client_trigger(spell['cooldown_name'], spell['cooldown']);
    send_to_server.func(["CAST_SPELL", alliance_building.id, 'REQUEST_UNIT_DONATION']);
    session.clear_building_idle_state_caches(); // for ALL buildings
}

function resolve_region_map_building_problem() { return resolve_building_problem(gamedata['region_map_building']); };
function resolve_alliance_building_problem() { return resolve_building_problem(gamedata['alliance_building']); };
function resolve_building_problem(specname) {
    var building = find_object_by_type(specname);
    if(!building) {
        var helper = get_requirements_help(read_predicate({'predicate': 'BUILDING_LEVEL', 'building_type': specname, 'trigger_level':1}), null);
        if(helper) { helper(); }
        return true;
    } else if(building.is_under_construction() || building.is_damaged() || building.is_upgrading()) {
        change_selection_unit(building);
        if(building.is_damaged() && !building.is_repairing()) {
            invoke_repair_dialog();
        } else {
            invoke_speedup_dialog('speedup');
        }
        return true;
    }
    return false;
}

// if player is limited from deploying an additional squad, get a predicate that explains why
function get_squad_deployment_predicate() {
    if(player.num_deployed_squads() >= player.stattab['max_deployed_squads']) {
        var cur_level = player.history[gamedata['squad_building']+'_level']||1;
        var next_level = get_next_level_with_stat_increase(gamedata['buildings'][gamedata['squad_building']], 'provides_deployed_squads', cur_level);
        if(next_level < 0) {
            return {'predicate': 'ALWAYS_FALSE',
                    'ui_title': gamedata['errors']['CANNOT_DEPLOY_SQUAD_MAX_LIMIT_REACHED']['ui_title'],
                    'ui_name': gamedata['errors']['CANNOT_DEPLOY_SQUAD_MAX_LIMIT_REACHED']['ui_name']};
        } else {
            return {'predicate': 'BUILDING_LEVEL', 'building_type': gamedata['squad_building'], 'trigger_level': next_level,
                    'ui_title': gamedata['errors']['CANNOT_DEPLOY_SQUAD_LIMIT_REACHED']['ui_title'],
                    'ui_name': gamedata['errors']['CANNOT_DEPLOY_SQUAD_LIMIT_REACHED']['ui_name']};
        }
    }
    return {'predicate':'ALWAYS_TRUE'};
}
function resolve_squad_deployment_problem() {
    var rpred = read_predicate(get_squad_deployment_predicate());
    if(!rpred.is_satisfied(player,null)) {
        var helper = get_requirements_help(rpred);
        if(helper) { helper(); }
        return true;
    }
    return false;
}

// check for conditions that prevent requesting or making unit donations
// and pop up some UI to deal with them. Return true if there was a problem.
function resolve_unit_donation_problem() {
    if(!session.is_in_alliance()) { return true; }
    return resolve_alliance_building_problem();
}

function invoke_unit_donation_dialog(req) {
    if(resolve_unit_donation_problem()) { return null; }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['unit_donation_dialog']);
    dialog.user_data['dialog'] = 'unit_donation_dialog';
    dialog.user_data['req'] = req;
    dialog.user_data['donation'] = [];
    dialog.user_data['pending'] = false;
    dialog.user_data['alliance_building'] = find_object_by_type(gamedata['alliance_building']);

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['cancel_button'].onclick = dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['recipient_portrait'].set_user(req['recipient_id']);

    var alliance_info = AllianceCache.query_info_sync(session.alliance_id);
    var player_info = PlayerCache.query_sync(req['recipient_id']);

    dialog.widgets['alliance_logo'].asset = (alliance_info['logo'] ? 'alicon_'+alliance_info['logo'] : 'inventory_unknown');
    dialog.widgets['donate_label'].str = dialog.data['widgets']['donate_label']['ui_name'].replace('%recipient', req['recipient_name']);

    dialog.widgets['donate_button'].onclick = function(w) {
        var _dialog = w.parent;
        if(!_dialog || _dialog.user_data['pending']) { return; }
        var alliance_building = find_object_by_type(gamedata['alliance_building']);
        if(alliance_building) {
            send_to_server.func(["CAST_SPELL", alliance_building.id, 'DONATE_UNITS', _dialog.user_data['req']['recipient_id'],
                                 _dialog.user_data['req']['tag'], _dialog.user_data['donation']]);

            // client-side prediction
            if(gamedata['client']['predict_donated_units']) {
                _dialog.user_data['pending'] = true;
                goog.array.forEach(_dialog.user_data['donation'], function(obj_id) {
                    // snoop update into my_army
                    if(obj_id in player.my_army) {
                        delete player.my_army[obj_id];
                        session.lazy_update_citizens();
                    }
                    // remove from session
                    if(obj_id in session.cur_objects.objects) {
                        remove_object(session.cur_objects.objects[obj_id]);
                    }
                });
            } else {
                invoke_ui_locker();
            }
        }
    };

    dialog.ondraw = update_unit_donation_dialog;
    return dialog;
}
function update_unit_donation_dialog(dialog) {
    var req = dialog.user_data['req'];
    var donation = dialog.user_data['donation'];
    var pending = dialog.user_data['pending'];
    var alliance_building = dialog.user_data['alliance_building'];
    var proposed_space = 0;

    /** @type {Object.<string,number>} specname -> number proposed for donation */
    var donation_by_type = {};

    var max_individual_space = (alliance_building ? alliance_building.get_leveled_quantity(alliance_building.spec['max_individual_donation_space']) : 0);

    // "army" or "session"
    var source = gamedata['donated_units_source'] || 'session';
    if(!goog.array.contains(['army','session'], source)) { throw Error('bad donated_units_source '+source); }

    // trim nonexistent, damaged, or too-big units out of proposed donation
    for(var i = 0; i < donation.length; i++) {
        if((source == 'session' && !(donation[i] in session.cur_objects.objects)) ||
           (source == 'army' && !(donation[i] in player.my_army))) {
            donation.splice(i,1); continue;
        }

        var obj_spec, obj_level, hp_ratio;
        if(source == 'session') {
            var obj = session.cur_objects.objects[donation[i]];
            obj_spec = obj.spec;
            obj_level = obj.level;
            hp_ratio = obj.hp / obj.max_hp;
        } else if(source == 'army') {
            var unit = player.my_army[donation[i]];
            if(SQUAD_IDS.is_mobile_squad_id(unit['squad_id']||0)) { // can't donate units in mobile squads
                donation.splice(i,1); continue;
            }
            obj_spec = gamedata['units'][unit['spec']];
            obj_level = ('level' in unit ? unit['level'] : 1);
            hp_ratio = ('hp_ratio' in unit ? unit['hp_ratio'] : 1);
        }
        var space = get_leveled_quantity(obj_spec['consumes_space'], obj_level);
        proposed_space += space;

        if((hp_ratio < 1) || (proposed_space + req['cur_space'] > req['max_space'])) {
            // damaged, or won't fit
            proposed_space -= space;
            donation.splice(i,1); continue;
        }
        if(!(obj_spec['name'] in donation_by_type)) { donation_by_type[obj_spec['name']] = 0; }
        donation_by_type[obj_spec['name']] += 1;
    }

    var cur_plus_proposed_space = req['cur_space']+proposed_space;

    /** @type {Array.<{obj_id:string, spec:string, level:number}>} */
    var available_unit_list = [];

    if(source == 'session') {
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.is_mobile() && (obj.team === 'player') && (obj.hp >= obj.max_hp)) {
                available_unit_list.push({obj_id: obj.id, spec: obj.spec['name'], level:obj.level});
            }
        }
    } else if(source == 'army') {
        goog.object.forEach(player.my_army, function(unit) {
            if(!('hp_ratio' in unit) || unit['hp_ratio'] >= 1 &&
               !SQUAD_IDS.is_mobile_squad_id(unit['squad_id']||0)) {
                available_unit_list.push({obj_id: unit['obj_id'], spec: unit['spec'], level: ('level' in unit ? unit['level'] : 1)});
            }
        });
    }

    /** @type {Object.<string,number>} specname -> number available */
    var available_units_by_type = {};
    for(var i = 0; i < available_unit_list.length; i++) {
        var unit = available_unit_list[i];
        if(!(unit.spec in available_units_by_type)) {
            available_units_by_type[unit.spec] = 0;
        }
        available_units_by_type[unit.spec] += 1;
    }

    // iterate in order found in units.json

    /** @type {Array.<string>} list of specnames */
    var available_unit_types = [];
    /** @type {Array.<string>} list of specnames */
    var donation_unit_types = [];

    for(var specname in gamedata['units']) {
        if(specname in available_units_by_type) {
            available_unit_types.push(specname);
        }
        if(specname in donation_by_type) {
            donation_unit_types.push(specname);
        }
    }

    var my_unit_slot = 0;
    while((my_unit_slot < available_unit_types.length) && (my_unit_slot < dialog.data['widgets']['my_slot']['array'][0]*dialog.data['widgets']['my_slot']['array'][1])) {
        var x = my_unit_slot % dialog.data['widgets']['my_slot']['array'][0];
        var y = Math.floor(my_unit_slot / dialog.data['widgets']['my_slot']['array'][0]);
        var wname = x.toFixed(0)+','+y.toFixed(0);

        var specname = available_unit_types[my_unit_slot];
        var qty = available_units_by_type[specname] - (donation_by_type[specname] || 0);
        var space = get_leveled_quantity(gamedata['units'][specname]['consumes_space'],1);

        dialog.widgets['my_slot'+wname].show =
            dialog.widgets['my_item'+wname].show =
            dialog.widgets['my_stack'+wname].show =
            dialog.widgets['my_frame'+wname].show = true;
        var asset_name = get_leveled_quantity(gamedata['units'][specname]['icon'] || gamedata['units'][specname]['art_asset'],1);
        dialog.widgets['my_item'+wname].asset = asset_name;
        dialog.widgets['my_item'+wname].state = GameArt.assets[asset_name].has_state('icon') ? 'icon' : 'normal';
        dialog.widgets['my_stack'+wname].str = pretty_print_number(qty);

        var ttip, ttip_s = '', ttip_bldg = '', ttip_col = SPUI.default_text_color, upgrade_alliance_building_level = -1;
        if(space > max_individual_space) {
            var level;
            for(level = alliance_building.level; level <= alliance_building.get_max_ui_level(); level++) {
                if(get_leveled_quantity(alliance_building.spec['max_individual_donation_space'], level) >= space) {
                    break;
                }
            }
            if(level > alliance_building.get_max_ui_level()) {
                ttip = 'ui_tooltip_unit_too_big';
            } else {
                ttip = 'ui_tooltip_upgrade_transmitter';
                ttip_bldg = alliance_building.spec['ui_name'];
                ttip_s = level.toFixed(0);
                upgrade_alliance_building_level = level;
            }
            ttip_col = SPUI.error_text_color;
        } else if(cur_plus_proposed_space+space > req['max_space']) {
            ttip = 'ui_tooltip_no_space';
        } else {
            ttip = 'ui_tooltip';
        }

        dialog.widgets['my_frame'+wname].state = (upgrade_alliance_building_level > 0 ? 'disabled_clickable' : ((space <= max_individual_space) && (qty > 0) && (cur_plus_proposed_space+space <= req['max_space']) ? 'normal' : 'disabled'));
        dialog.widgets['my_frame'+wname].tooltip.str = dialog.data['widgets']['my_frame'][ttip].replace('%s', ttip_s).replace('%BUILDING', ttip_bldg).replace('%UNITNAME',gamedata['units'][specname]['ui_name']);
        dialog.widgets['my_frame'+wname].tooltip.text_color = ttip_col;

        if(upgrade_alliance_building_level > 0) {
            dialog.widgets['my_frame'+wname].onclick = (function (_lvl) { return function(w) {
                var helper = get_requirements_help(read_predicate({'predicate': 'BUILDING_LEVEL', 'building_type': gamedata['alliance_building'], 'trigger_level':_lvl}),null);
                if(helper) { helper(); }
            }; })(upgrade_alliance_building_level);
        } else {
            dialog.widgets['my_frame'+wname].onclick = (function (_source, _specname) { return function(w) {
                var _dialog = w.parent;

                // find ID of next unit to donate
                var obj_id = null;

                // XXX really inefficient
                if(_source == 'session') {
                    for(var id in session.cur_objects.objects) {
                        var o = session.cur_objects.objects[id];
                        if((o.spec['name'] === _specname) && (o.team === 'player') && (o.hp >= o.max_hp)) {
                            if(!goog.array.contains(_dialog.user_data['donation'], o.id)) {
                                // found a new candidate
                                obj_id = o.id;
                                break;
                            }
                        }
                    }
                } else if(_source == 'army') {
                    for(var id in player.my_army) {
                        var o = player.my_army[id];
                        if(o['spec'] == _specname && (!('hp_ratio' in o) || o['hp_ratio'] >= 1)) {
                            if(!goog.array.contains(_dialog.user_data['donation'], id)) {
                                // found a new candidate
                                obj_id = id;
                                break;
                            }
                        }
                    }
                }

                if(obj_id) {
                    _dialog.user_data['donation'].push(obj_id);
                } else {
                    // dripper normally can get here, just pass silently
                    //console.log('could not find unit to donate of type '+_specname);
                    return;
                }
            }; })(source, specname);
        }
        if(!gamedata['client']['unit_manufacture_dripper']) {
            dialog.widgets['my_frame'+wname].dripper_cb = null; // disable dripper behavior
        }
        my_unit_slot += 1;
    }

    // clear remaining "my unit" spaces
    while(my_unit_slot < dialog.data['widgets']['my_slot']['array'][0]*dialog.data['widgets']['my_slot']['array'][1]) {
        var x = my_unit_slot % dialog.data['widgets']['my_slot']['array'][0];
        var y = Math.floor(my_unit_slot / dialog.data['widgets']['my_slot']['array'][0]);
        var wname = x.toFixed(0)+','+y.toFixed(0);
        dialog.widgets['my_slot'+wname].show =
            dialog.widgets['my_item'+wname].show =
            dialog.widgets['my_stack'+wname].show =
            dialog.widgets['my_frame'+wname].show = false;
        my_unit_slot += 1;
    }

    var donate_unit_slot = 0;
    while((donate_unit_slot < donation_unit_types.length) && (donate_unit_slot < dialog.data['widgets']['donate_slot']['array'][0]*dialog.data['widgets']['donate_slot']['array'][1])) {
        var x = donate_unit_slot % dialog.data['widgets']['donate_slot']['array'][0];
        var y = Math.floor(donate_unit_slot / dialog.data['widgets']['donate_slot']['array'][0]);
        var wname = x.toFixed(0)+','+y.toFixed(0);
        dialog.widgets['donate_slot'+wname].show =
            dialog.widgets['donate_item'+wname].show =
            dialog.widgets['donate_stack'+wname].show =
            dialog.widgets['donate_cancel'+wname].show =
            dialog.widgets['donate_frame'+wname].show = true;

        var specname = donation_unit_types[donate_unit_slot];
        var qty = (donation_by_type[specname] || 0);

        var asset_name = get_leveled_quantity(gamedata['units'][specname]['icon'] || gamedata['units'][specname]['art_asset'],1);

        dialog.widgets['donate_item'+wname].asset = asset_name;
        dialog.widgets['donate_item'+wname].state = GameArt.assets[asset_name].has_state('icon') ? 'icon' : 'normal';
        dialog.widgets['donate_stack'+wname].str = pretty_print_number(qty);
        dialog.widgets['donate_frame'+wname].tooltip.str = gamedata['units'][specname]['ui_name'];
        dialog.widgets['donate_frame'+wname].onclick =
            dialog.widgets['donate_cancel'+wname].onclick = (function (_source, _specname) { return function(w) {
                var _dialog = w.parent;
                // XXX really inefficient
                for(var i = 0; i < _dialog.user_data['donation'].length; i++) {
                    if(_source == 'session') {
                        var o = session.cur_objects.objects[_dialog.user_data['donation'][i]];
                        if(o && o.spec['name'] === _specname) {
                            _dialog.user_data['donation'].splice(i, 1);
                            break;
                        }
                    } else if(_source == 'army') {
                        var o = player.my_army[_dialog.user_data['donation'][i]];
                        if(o['spec'] == _specname) {
                            _dialog.user_data['donation'].splice(i, 1);
                            break;
                        }
                    }
                }
            }; })(source, specname);

        if(!gamedata['client']['unit_manufacture_dripper']) {
            dialog.widgets['donate_frame'+wname].dripper_cb =
                dialog.widgets['donate_cancel'+wname].dripper_cb = null; // disable dripper behavior
        }
        donate_unit_slot += 1;
    }
    while(donate_unit_slot < dialog.data['widgets']['donate_slot']['array'][0]*dialog.data['widgets']['donate_slot']['array'][1]) {
        var x = donate_unit_slot % dialog.data['widgets']['donate_slot']['array'][0];
        var y = Math.floor(donate_unit_slot / dialog.data['widgets']['donate_slot']['array'][0]);
        var wname = x.toFixed(0)+','+y.toFixed(0);
        dialog.widgets['donate_slot'+wname].show =
            dialog.widgets['donate_item'+wname].show =
            dialog.widgets['donate_stack'+wname].show =
            dialog.widgets['donate_cancel'+wname].show =
            dialog.widgets['donate_frame'+wname].show = false;
        donate_unit_slot += 1;
    }


    // fainter bar that covers cur_plus_proposed
    dialog.widgets['space_prog_bg'].progress = cur_plus_proposed_space/req['max_space'];
    // brighter bar that covers cur_space only
    dialog.widgets['space_prog_fg'].progress = req['cur_space']/req['max_space'];

    dialog.widgets['space_value'].str = dialog.data['widgets']['space_value']['ui_name'].replace('%cur', cur_plus_proposed_space.toString()).replace('%max', req['max_space'].toString());

    dialog.widgets['donate_button'].state = ((donation.length > 0 && !pending) ? 'normal' : 'disabled');
    dialog.widgets['close_button'].state = dialog.widgets['cancel_button'].state = (pending ? 'disabled' : 'normal');
    dialog.widgets['pending_rect'].show = dialog.widgets['pending_text'].show = dialog.widgets['pending_spinner'].show = pending;
}

function invoke_lottery_dialog() {
    // XXX for testing only
    var scanner = find_object_by_type('scanner');
    if(!scanner || !scanner.is_lottery_building() || scanner.team !== 'player') { return; }
    if(0 && scanner.contents >= 1) {
        return invoke_lottery_scan_dialog(scanner);
    } else {
        return invoke_lottery_more_dialog(scanner);
    }
}
function invoke_lottery_scan_dialog(scanner) {
    change_selection_ui(null);
    get_lottery_slate(scanner, function(result) { console.log(result); });
    //send_to_server.func(["CAST_SPELL", scanner.id, "LOTTERY_SCAN"]);
}

var lottery_slate_receivers = [];
function get_lottery_slate(scanner, callback) {
    lottery_slate_receivers.push(callback);
    send_to_server.func(["CAST_SPELL", scanner.id, "LOTTERY_GET_SLATE"]);
}

var lottery_scan_receivers = [];
function lottery_scan(scanner, callback) {
    lottery_scan_receivers.push(callback);
    send_to_server.func(["CAST_SPELL", scanner.id, "LOTTERY_SCAN"]);
}

function invoke_lottery_more_dialog(scanner) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['lottery_more_dialog']);
    dialog.user_data['dialog'] = 'lottery_more_dialog';
    dialog.user_data['scanner'] = scanner;
    dialog.user_data['last_contents'] = -1;
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();

    var price = Store.get_user_currency_price(0, gamedata['spells']['BUY_LOTTERY_TICKET'], null);
    dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
    dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price); // PRICE

    dialog.widgets['use_button'].state = (scanner.contents > 0 ? 'normal' : 'disabled');
    dialog.widgets['use_button'].tooltip.str = dialog.widgets['use_button'].data['ui_tooltip' + (scanner.contents>0 ? '' : '_empty')];
    dialog.widgets['use_button'].onclick = invoke_lottery_dialog;

    dialog.widgets['price_display'].onclick =
    dialog.widgets['buy_button'].onclick = function(w) {
        var dialog = w.parent;
        // in order to be robust against unreliable Facebook credit
        // order callbacks, detect the purchase by checking scanner.contents. Ugly :(
        dialog.user_data['last_contents'] = dialog.user_data['scanner'].contents;
        Store.place_user_currency_order(GameObject.VIRTUAL_ID, 'BUY_LOTTERY_TICKET', null, null);
        w.str = dialog.data['widgets']['buy_buton']['ui_name_pending'];
        w.state = 'disabled';
    };
    dialog.ondraw = update_lottery_more_dialog;
    return dialog;
}
function update_lottery_more_dialog(dialog) {
    var scanner = dialog.user_data['scanner'];
    dialog.widgets['charges'].str = dialog.widgets['charges'].data['ui_name'].replace('%d', pretty_print_number(scanner.contents));
    if(dialog.user_data['last_contents'] >= 0 && scanner.contents != dialog.user_data['last_contents']) {
        // order was completed, re-invoke dialog
        invoke_lottery_dialog();
    }
}

function invoke_abtest_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['abtest_dialog']);
    dialog.user_data['dialog'] = 'abtest_dialog';
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };
    dialog.ondraw = update_abtest_dialog;
    // make copy of player.abtests
    dialog.user_data['abtests'] = {};
    for(var name in player.abtests) {
        dialog.user_data['abtests'][name] = player.abtests[name];
    }
    dialog.widgets['ok_button'].onclick = function(w) {
        var data = w.parent.user_data['abtests'];
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_MODIFY_ABTESTS", data]);
        // force reload
        SPINPUNCHGAME.shutdown();

        change_selection(null);
        window.setTimeout(function() { reload_game(); }, 500);
    };
    return dialog;
}

function update_abtest_dialog(dialog) {
    var NUM = 6, CNUM = 2;
    var i = 0;
    for(var name in gamedata['abtests']) {
        if(!(name in gamedata['abtests']) ||
           !gamedata['abtests'][name]['active'] ||
           name.indexOf('offer_wall') != -1) {
            continue;
        }
        dialog.widgets['name'+i.toString()].show = true;
        dialog.widgets['name'+i.toString()].str = name;

        var j = 0;
        for(var group in gamedata['abtests'][name]['groups']) {
            dialog.widgets['btn'+i.toString()+','+j.toString()].show = true;
            dialog.widgets['btn'+i.toString()+','+j.toString()].str = group;
            dialog.widgets['btn'+i.toString()+','+j.toString()].state = (dialog.user_data['abtests'][name] == group ? 'active':'normal');
            dialog.widgets['btn'+i.toString()+','+j.toString()].onclick = (function(_dialog, _name, _group) { return function() {
                if(_dialog.user_data['abtests'][_name] == _group) {
                    _dialog.user_data['abtests'][_name] = null;
                } else {
                    _dialog.user_data['abtests'][_name] = _group;
                }
            }; })(dialog, name, group);

            j += 1;
            if(j >= CNUM) { break; }
        }
        i += 1;
        if(i >= NUM) { break; }
    }
};

/** @param {number} from_id
    @param {number} user_id
    @param {string} name
    @param {number} level
    @param {boolean=} zoom_from_widget */
function invoke_battle_history_dialog(from_id, user_id, name, level, zoom_from_widget) {
    player.record_feature_use('battle_history');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['battle_history_dialog']);
    dialog.user_data['dialog'] = 'battle_history_dialog';
    dialog.user_data['anim_start_time'] = client_time;
    dialog.user_data['zoom_from_widget'] = (zoom_from_widget ? zoom_from_widget : ((desktop_dialogs['desktop_top']&&session.home_base) ? desktop_dialogs['desktop_top'].widgets['battle_history_button'] : null));
    dialog.user_data['from_id'] = from_id;
    dialog.user_data['user_id'] = user_id;
    dialog.user_data['sumlist'] = null;
    dialog.user_data['sums_on_page'] = [];
    dialog.user_data['chapter'] = ((user_id > 0 && is_ai_user_id_range(user_id)) ? 'ai' : 'human');
    dialog.user_data['page'] = -1;

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['single_player_button'].show = (user_id <= 0);
    dialog.widgets['multiplayer_button'].show = (user_id <= 0);

    dialog.widgets['single_player_button'].onclick = function(w) { battle_history_change_page(w.parent, 'ai', 0); };
    dialog.widgets['multiplayer_button'].onclick = function(w) { battle_history_change_page(w.parent, 'human', 0); };

    dialog.widgets['close_button'].onclick = close_parent_dialog;
    var dev_str = (from_id != session.user_id ? ' (DEV As '+from_id.toString()+') ' : '');
    if(user_id > 0) {
        dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name_vs'].replace('%s', name.split(' ')[0] + ' (L'+ level.toString()+')') + dev_str;
    } else {
        dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name_all'] + dev_str;
    }
    battle_history_change_page(dialog, dialog.user_data['chapter'], 0);

    var recv_history_cb = (function (_dialog) { return function(data) { receive_battle_history_result(_dialog, data); }; })(dialog);
    var get_history_cb = (function (_user_id, _from_id, _cb) { return function() { query_battle_history(_user_id, _from_id, _cb); }; })(user_id, from_id, recv_history_cb);

    dialog.widgets['column_header_time'].show = !!gamedata['client']['battle_history_time_column'];
    dialog.widgets['column_header_location'].show = !!gamedata['client']['battle_history_location_column'];
    dialog.widgets['column_header_outcome'].show = !dialog.widgets['column_header_location'].show;
    dialog.widgets['column_header_status'].str = dialog.data['widgets']['column_header_status'][(gamedata['client']['battle_history_location_column'] ? 'ui_name' : 'ui_name_loot')];

    // if player is on the map, query quarries so that depletion status is accurate
    if(session.region.map_enabled()) {
        session.region.call_when_fresh(get_history_cb);
    } else {
        get_history_cb();
    }

    dialog.ondraw = update_battle_history_dialog;
    return dialog;
};

var battle_history_receivers = {};
function query_battle_history(target, source, callback) {
    last_query_tag += 1;
    var tag = 'qbh'+last_query_tag.toString();
    battle_history_receivers[tag] = callback;
    send_to_server.func(["QUERY_BATTLE_HISTORY", target, source, tag]);
}

function receive_battle_history_result(dialog, sumlist) {
    dialog.widgets['loading_rect'].show =
        dialog.widgets['loading_text'].show = false;
    dialog.widgets['scroll_text'].show = true;

    // sort summaries by age
    var compare_by_time = function (a,b) {
        if(a['time'] < b['time']) {
            return 1;
        } else if(a['time'] > b['time']) {
            return -1;
        } else {
            return 0;
        }
    };
    sumlist.sort(compare_by_time);
    dialog.user_data['sumlist'] = sumlist;
    battle_history_change_page(dialog, dialog.user_data['chapter'], 0);
};

function update_battle_history_dialog(dialog) {
    var row;
    for(row = 0; row < dialog.user_data['sums_on_page'].length; row++) {
        var summary = dialog.user_data['sums_on_page'][row];

        var user_id = summary[(summary['attacker_id'] == dialog.user_data['from_id'] ? 'defender' : 'attacker')+'_id'];
        var info = PlayerCache.query_sync(user_id) || {};
        var prot_end_time = (info && ('protection_end_time' in info) ? info['protection_end_time'] : -1);
        var is_protected = (prot_end_time == 1 || prot_end_time > server_time || (info && info['LOCK_STATE']));
        var on_cooldown = ('attack_cooldown_expire' in summary && summary['attack_cooldown_expire'] > server_time);

        if(gamedata['client']['battle_history_show_attackability']) {
            dialog.widgets['row_prot'+row].show = is_protected;
            dialog.widgets['row_cooldown'+row].show = (!is_protected && on_cooldown);
            if(dialog.widgets['row_cooldown'+row].show) {
                dialog.widgets['row_cooldown'+row].str = dialog.data['widgets']['row_cooldown']['ui_name'].replace('%s', pretty_print_time_brief(summary['attack_cooldown_expire'] - server_time));
            }
        } else {
            dialog.widgets['row_prot'+row].show = dialog.widgets['row_cooldown'+row].show = false;
        }

        // Revenge button
        if(!user_id || is_ai_user_id_range(user_id)) {
            dialog.widgets['row_revenge_button'+row].show = false;
        } else if(session.region && session.region.data && session.region.data['storage'] == 'nosql' && session.region.map_enabled()) {
            dialog.widgets['row_revenge_button'+row].show = false;
            if(info && info['home_region'] == session.region.data['id'] && info['home_base_loc']) {
                dialog.widgets['row_revenge_button'+row].show = true;
                dialog.widgets['row_revenge_button'+row].state = 'normal';
                dialog.widgets['row_revenge_button'+row].str = dialog.data['widgets']['row_revenge_button']['ui_name_find_on_map'];
                dialog.widgets['row_revenge_button'+row].onclick = (function (_loc) { return function(w) {
                    change_selection_ui(null);
                    invoke_region_map(_loc);
                }; })(info['home_base_loc']);
            }
        } else {

            // only say "Revenge" if we can actually do a revenge attack
            var can_revenge = (player.cooldown_active('revenge_defender:'+user_id.toString()) && !is_protected && !on_cooldown);
            if(can_revenge) {
                dialog.widgets['row_revenge_button'+row].show = true;
                dialog.widgets['row_revenge_button'+row].bg_image = dialog.data['widgets']['row_revenge_button']['bg_image'+(can_revenge?'':'_spy')];
                dialog.widgets['row_revenge_button'+row].str = dialog.data['widgets']['row_revenge_button']['ui_name'+(can_revenge?'':'_spy')];
                dialog.widgets['row_revenge_button'+row].state = (can_revenge ? 'attack' : 'normal');

                dialog.widgets['row_revenge_button'+row].onclick = (function (_uid) { return function(w) {
                    change_selection(null);
                    visit_base(_uid);
                }; })(user_id);
            } else {
                dialog.widgets['row_revenge_button'+row].show = false;
            }
        }
    }

    while(row < 5) {
        dialog.widgets['row_prot'+row].show =
            dialog.widgets['row_cooldown'+row].show =
            dialog.widgets['row_revenge_button'+row].show = false;
        row += 1;
    }

    // zoom effect
    animate_dialog_zoom_effect(dialog, dialog.user_data['zoom_from_widget']);
};

function battle_history_change_page(dialog, chapter, page) {
    dialog.user_data['chapter'] = chapter;

    dialog.widgets['single_player_button'].state = (chapter === 'ai' ? 'active' : 'normal');
    dialog.widgets['multiplayer_button'].state = (chapter === 'human' ? 'active' : 'normal');

    var sumlist = dialog.user_data['sumlist'];

    // sentinel
    if(sumlist === null) { sumlist = []; }

    var filtered_list = [];
    for(var i = 0; i < sumlist.length; i++) {
        var sum = sumlist[i];
        var battle_type = ((is_ai_user_id_range(sum['attacker_id']) || is_ai_user_id_range(sum['defender_id'])) ? 'ai' : 'human');
        if('ladder_state' in sum && sum['ladder_state']) { battle_type = 'human'; } // list ladder battles vs ai on Multiplayer
        if(battle_type == dialog.user_data['chapter']) {
            filtered_list.push(sum);
        }
    }

    // similar to Map dialog change page
    var row = 0;
    var rows_per_page = 5;
    var chapter_battles = filtered_list.length;
    var chapter_pages = Math.floor((chapter_battles+rows_per_page-1)/rows_per_page);
    dialog.user_data['page'] = page = (chapter_battles == 0 ? 0 : clamp(page, 0, chapter_pages-1));
    dialog.user_data['sums_on_page'] = [];

    if(chapter_battles > 0) {
        // show battles!
        var first_on_page = page * rows_per_page;
        var last_on_page = (page+1)*rows_per_page - 1;
        last_on_page = Math.max(0, Math.min(last_on_page, chapter_battles-1));
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_on_page+1).toString()).replace('%d2',(last_on_page+1).toString()).replace('%d3',chapter_battles.toString());

        for(var i = first_on_page; i <= last_on_page; i++) {
            var summary = filtered_list[i];
            dialog.user_data['sums_on_page'].push(summary);

            var myrole, opprole;
            if(summary['attacker_id'] == dialog.user_data['from_id']) {
                myrole = 'attacker';
                opprole = 'defender';
            } else if(summary['defender_id'] == dialog.user_data['from_id']) {
                myrole = 'defender';
                opprole = 'attacker';
            } else {
                console.log('battle history does not match from_id! att '+summary['attacker_id']+' def '+summary['defender_id']+' from '+dialog.user_data['from_id']); myrole = 'defender'; opprole = 'attacker';
            }
            var at_quarry = (summary['base_type'] == 'quarry');
            var at_hive = (summary['base_type'] == 'hive');
            var at_squad = (summary['base_type'] == 'squad');
            var at_my_home = (summary['base_type'] == 'home' && summary['base_id'] == ('h'+session.user_id.toString()));
            var ladder_state = summary['ladder_state'] || null;
            var user_id = summary[opprole+'_id'];
            var fbid = summary[opprole+'_facebook_id'];
            var time_ago = server_time - summary['time'];

            // portrait
            dialog.widgets['row_portrait'+row].show = true;
            dialog.widgets['row_portrait'+row].set_user(user_id);

            dialog.widgets['row_portrait'+row].onclick =
                dialog.widgets['row_name'+row].onclick =
                (function (_uid, _fbid, _name, _level) { return function() {
                    //visit_base(_uid);
                    invoke_player_info_dialog_unknown(_uid, _fbid, _name, _level);
                }; })(user_id, fbid, summary[opprole+'_name'], summary[opprole+'_level']);

            // name/level
            dialog.widgets['row_name'+row].show = true;
            var name_str = summary[opprole+'_name'];
            var max_len = dialog.data['widgets']['row_name']['max_len'];
            if(name_str.length >= max_len) {
                name_str = name_str.slice(0, max_len)+'...';
            }
            if(summary[opprole+'_alliance_chat_tag']) {
                name_str += ' ['+summary[opprole+'_alliance_chat_tag']+']';
            }
            name_str += ' (L'+summary[opprole+'_level']+')';
            dialog.widgets['row_name'+row].str = name_str;

            dialog.widgets['row_role'+row].show = true;

            var ui_role = dialog.data['widgets']['row_role']['ui_name_'+(opprole == 'defender' ? 'defender' : 'attacker')];
            var role_color = dialog.data['widgets']['row_role']['text_color'];

            // if no time column, the time goes into the "role" string
            if(!gamedata['client']['battle_history_time_column']) {
                ui_role = dialog.data['widgets']['row_role']['ui_name_time'].replace('%s', ui_role).replace('%d', pretty_print_time_very_brief(time_ago));
            } else {
                // if time column, color the role
                role_color = dialog.data['widgets']['row_role']['text_color_'+opprole];
            }

            dialog.widgets['row_role'+row].str = ui_role;
            dialog.widgets['row_role'+row].text_color = SPUI.make_colorv(role_color);

            var trophy_field = ('trophies_pve' in summary['loot'] ? 'trophies_pve' : (opprole == 'defender' ? 'trophies_pvp' : 'viewing_trophies_pvp'));

            dialog.widgets['row_location'+row].show = !!gamedata['client']['battle_history_location_column'];
            dialog.widgets['row_outcome'+row].show = !gamedata['client']['battle_history_location_column'];

            if(dialog.widgets['row_location'+row].show) {
                dialog.widgets['row_location'+row].onclick = null;

                var base_ui_name = summary['base_ui_name'];
                if(base_ui_name) {
                    if(at_squad) { base_ui_name = gamedata['strings']['squads']['squad']+' '+base_ui_name; }
                    if(at_quarry || at_hive || at_squad) {
                        if(summary['base_map_loc']) {
                            if((at_quarry || at_hive) && (!('base_id' in summary) || (session.region.data && !session.region.feature_exists_at(summary['base_id'], summary['base_ui_name'], summary['base_map_loc'])))) {
                                base_ui_name += '\n'+dialog.data['widgets']['row_location']['ui_name_'+(at_quarry ? 'quarry_depleted' : 'hive_destroyed')];
                            } else {
                                base_ui_name += '\n('+summary['base_map_loc'][0].toString()+','+summary['base_map_loc'][1].toString()+')';
                                dialog.widgets['row_location'+row].onclick = (function (_loc) { return function() {
                                    invoke_region_map(_loc);
                                }; })(summary['base_map_loc']);
                            }
                        }
                    }
                } else {
                    if(!at_quarry) {
                        base_ui_name = dialog.data['widgets']['row_location']['ui_name'];
                    } else {
                        base_ui_name = "?";
                    }
                }
                // add PvP point delta below location
                if(summary['loot'][trophy_field]) {
                    var count = summary['loot'][trophy_field];
                    base_ui_name += '\n'+dialog.data['widgets']['row_location']['ui_name_points'].replace('%d', (count > 0 ? '+' : '-')+pretty_print_number(Math.abs(count)));
                }

                dialog.widgets['row_location'+row].set_text_with_linebreaking(base_ui_name);
            }

            var myout = summary[myrole+'_outcome'];
            var ui_outcome = gamedata['strings']['battle_end'][(ladder_state ? 'ladder' : (at_squad ? 'squad' : (at_quarry ? 'quarry' : 'away')))][myout]['log_outcome'][myrole];

            // the "outcome" displayed here is the basic You Won/You Lost PLUS battle stars and PvP point delta
            if(dialog.widgets['row_outcome'+row].show) {
                var full_outcome = ui_outcome;
                if(summary['attacker_outcome'] == 'victory' && ('battle_stars' in summary['loot'])) {
                    var star_count = goog.object.getCount(summary['loot']['battle_stars']);
                    full_outcome += ' ('+gamedata['strings']['battle_end']['ladder'][(star_count == 1 ? 'stars_singular' : 'stars_plural')].replace('%s', star_count.toString())+')';
                }

                // add PvP point delta
                if(summary['loot'][trophy_field]) {
                    var count = summary['loot'][trophy_field];
                    full_outcome += '\n'+dialog.data['widgets']['row_outcome']['ui_name_points'].replace('%d', (count > 0 ? '+' : '-')+pretty_print_number(Math.abs(count)));
                }
                dialog.widgets['row_outcome'+row].str = full_outcome;
                dialog.widgets['row_outcome'+row].text_color = SPUI.make_colorv(dialog.data['widgets']['row_outcome']['text_color_'+(myout == 'victory' ? 'good' : 'bad')]);
            }


            summary['ui_outcome'] = ui_outcome; // save for later
            summary['at_quarry'] = at_quarry;
            summary['at_squad'] = at_squad;


            dialog.widgets['row_loot'+row].show = true;
            if(at_quarry || at_squad) {
                // show status instead of loot here
                dialog.widgets['row_loot'+row].str = ui_outcome;
                dialog.widgets['row_loot'+row].text_color = (myout === 'defeat' ? new SPUI.Color(1,0,0,1) : new SPUI.Color(0,0.8,0,1));
            } else {
                dialog.widgets['row_loot'+row].text_color = SPUI.default_text_color;
                var is_lost = false;
                if(session.user_id == summary['defender_id']) {
                    for(var res in gamedata['resources']) {
                        if(res+'_lost' in summary['loot']) {
                            is_lost = true;
                        }
                    }
                }
                var s = dialog.data['widgets']['row_loot']['ui_name'];

                for(var res in gamedata['resources']) {
                    var amount;
                    if(is_lost) {
                        amount = summary['loot'][res+'_lost']||0;
                    } else {
                        if(gamedata['show_uncapped_loot']) {
                            amount = summary['loot']['looted_uncapped_'+res] || 0;
                        } else {
                            amount = summary['loot'][res] || 0;
                        }
                    }
                    // rather complex string replacement to get this right. Note, we add the minus sign here for lost amounts.
                    s = s.replace('%'+res.toUpperCase(), gamedata['resources'][res]['ui_name']);
                    s = s.replace('%s'+res[0] /* first character */, ((is_lost && amount > 0) ? '-' : '') + pretty_print_number(amount));
                }
                dialog.widgets['row_loot'+row].str = s;
            }

            if(gamedata['client']['battle_history_time_column']) {
                dialog.widgets['row_time'+row].show = true;
                dialog.widgets['row_time'+row].str = dialog.data['widgets']['row_time']['ui_name'].replace('%s', pretty_print_time_brief(time_ago));
            }

            // View Log button
            var callback = (function (_from, _uid, _opprole, _summary) { return function() {
                player.record_feature_use('battle_log');
                invoke_battle_log_dialog(_from, _uid, _opprole, _summary);
            }; })(dialog.user_data['from_id'], user_id, opprole, summary);

            dialog.widgets['row_log_button'+row].show = (player.is_developer() || player.get_any_abtest_value('enable_battle_logs',true));
            dialog.widgets['row_log_button'+row].state = 'normal';
            dialog.widgets['row_log_button'+row].onclick = callback;

            row += 1;
        }

        dialog.widgets['loading_rect'].show =
            dialog.widgets['loading_text'].show = false;
    } else {
        // no battles to show
        dialog.widgets['loading_rect'].show =
            dialog.widgets['loading_text'].show = true;
        if(dialog.user_data['sumlist'] != null) {
            dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name_empty'];
        } else {
            dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name'];
        }

        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(0).toString()).replace('%d2',(0).toString()).replace('%d3',(0).toString());
    }

    // clear out empty rows
    while(row < rows_per_page) {
        dialog.widgets['row_portrait'+row].show =
            dialog.widgets['row_name'+row].show =
            dialog.widgets['row_role'+row].show =
            dialog.widgets['row_outcome'+row].show =
            dialog.widgets['row_location'+row].show =
            dialog.widgets['row_loot'+row].show =
            dialog.widgets['row_time'+row].show =
            dialog.widgets['row_revenge_button'+row].show =
            dialog.widgets['row_log_button'+row].show = false;
        row += 1;
    }

    // set clickability of scroll arrows
    if(page != 0) {
        dialog.widgets['scroll_left'].state = 'normal';
    } else {
        dialog.widgets['scroll_left'].state = 'disabled';
    }

    if(page < (chapter_pages-1)) {
        dialog.widgets['scroll_right'].state = 'normal';
    } else {
        dialog.widgets['scroll_right'].state = 'disabled';
    }

    dialog.widgets['scroll_left'].onclick = function(w) { var _dialog = w.parent; battle_history_change_page(_dialog, _dialog.user_data['chapter'], _dialog.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function(w) { var _dialog = w.parent; battle_history_change_page(_dialog, _dialog.user_data['chapter'], _dialog.user_data['page']+1); };

    return dialog;
};

function invoke_battle_log_dialog(from_id, user_id, opprole, summary) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['battle_log_dialog']);
    dialog.user_data['dialog'] = 'battle_log_dialog';
    dialog.user_data['from_id'] = from_id;
    dialog.user_data['user_id'] = user_id;
    dialog.user_data['time'] = summary['time'];
    dialog.user_data['summary'] = summary;
    dialog.user_data['log'] = null;
    dialog.user_data['page'] = -1;
    //change_selection_ui(dialog);
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    if(from_id != session.user_id) {
            // developer impersonation option
            dialog.widgets['title'].str += ' (DEV As '+from_id.toString()+')';
    }

    // pre-fill summary info
    dialog.widgets['base_damage'].show = dialog.widgets['base_damage_label'].show = (!summary['at_quarry'] && !summary['at_squad']);
    dialog.widgets['location'].show = ((summary['at_quarry'] || summary['at_squad']) && summary['base_ui_name']);
    if((summary['at_quarry'] || summary['at_squad']) && summary['base_ui_name']) {
        dialog.widgets['location'].set_text_with_linebreaking(summary['base_ui_name']);
    }

    dialog.widgets['base_damage'].str = Math.floor(100.0*summary['base_damage']).toFixed(0)+'%';
    dialog.widgets['outcome'].str = summary['ui_outcome'];
    if('battle_stars' in summary['loot']) {
        var star_count = goog.object.getCount(summary['loot']['battle_stars']);
        if(star_count > 0) {
            dialog.widgets['outcome'].str += '\n(' + gamedata['strings']['battle_end']['ladder'][(star_count==1? 'stars_singular':'stars_plural')].replace('%s', star_count.toString()) + ')';
        }
    }
    dialog.widgets['message_button'].show = (!!summary['facebook_friends'] && (spin_frame_platform == 'fb'));
    dialog.widgets['message_button'].onclick = (function(_uid, _fbid) { return function() {
        invoke_facebook_message_dialog(_fbid, _uid);
    } })(summary[opprole+'_id'], summary[opprole+'_facebook_id']);

    var is_lost = false;
    goog.object.forEach(gamedata['resources'], function(resdata, resname) {
        if(!('loot_'+resname in dialog.widgets)) { return; }
        var amount;
        if(session.user_id == summary['defender_id'] && (resname+'_lost' in summary['loot'])) {
            // display LOST, not LOOTED, if available
            amount = summary['loot'][resname+'_lost'];
            is_lost = true;
        } else {
            if(gamedata['show_uncapped_loot']) {
                amount = summary['loot']['looted_uncapped_'+resname] || 0;
            } else {
                amount = summary['loot'][resname] || 0;
            }
        }

        dialog.widgets['loot_'+resname+'_label'].show = dialog.widgets['loot_'+resname].show = !!amount;
        if(amount) {
            dialog.widgets['loot_'+resname].str = pretty_print_number(amount);
            dialog.widgets['loot_'+resname+'_label'].str = dialog.data['widgets']['loot_'+resname+'_label']['ui_name'+(is_lost?'_lost':'')].replace('%RES', resdata['ui_name']);
        }
    });

    var trophy_field = ('trophies_pve' in summary['loot'] ? 'trophies_pve' : (from_id == summary['defender_id'] ? 'viewing_trophies_pvp' : 'trophies_pvp'));
    var trophy_delta = summary['loot'][trophy_field] || 0;

    if(trophy_delta != 0) {
        dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_sunken'].show =
            dialog.widgets['trophy_shine'].show =
            dialog.widgets['trophy_amount'].show = true;
        var sign = (trophy_delta > 0 ? 'plus' : 'minus');
        dialog.widgets['trophy_icon'].state = ('trophies_pve' in summary['loot'] ? 'pve' : 'pvp');
        dialog.widgets['trophy_amount'].str = dialog.data['widgets']['trophy_amount']['ui_name_'+sign].replace('%d', pretty_print_number(Math.abs(trophy_delta)));
        dialog.widgets['trophy_amount'].text_color = SPUI.make_colorv(dialog.data['widgets']['trophy_amount']['text_color_'+sign]);
    }


    var roles = ['attacker', 'defender'];
    for(var i = 0; i < roles.length; i++) {
        var role = roles[i];
        dialog.widgets[role+'_portrait'].set_user(summary[role+'_id']);
        dialog.widgets[role+'_portrait'].set_user_level(summary[role+'_level']);

        dialog.widgets[role+'_portrait'].onclick = (function (_uid) { return function() {
            invoke_player_info_dialog_unknown(_uid);
        } })(summary[role+'_id']);

        var name_str = summary[role+'_name'];
        var max_len = dialog.data['widgets'][role+'_name']['max_len'];
        if(name_str.length > max_len) {
            name_str = name_str.slice(0, max_len)+'...';
        }
        dialog.widgets[role+'_name'].str = name_str;
    }
    dialog.widgets['time_since_battle'].str = dialog.data['widgets']['time_since_battle']['ui_name'].replace('%s', pretty_print_time_brief(server_time - summary['time']));
    dialog.widgets['battle_duration'].str = dialog.data['widgets']['battle_duration']['ui_name'].replace('%s', pretty_print_time(summary['duration']));

    dialog.widgets['scroll_left'].state = 'disabled';
    dialog.widgets['scroll_right'].state = 'disabled';

    battle_log_change_page(dialog, 0);

    get_battle_log(summary['time'], summary['attacker_id'], summary['defender_id'], summary['base_id'] || null,
                   (function (_dialog) { return function(result) { receive_battle_log_result(_dialog, result); }; })(dialog));

    return dialog;
};

var battle_log_receivers = {};
function get_battle_log(battle_time, attacker_id, defender_id, base_id, cb) {
    last_query_tag += 1;
    var tag = 'gbl'+last_query_tag.toString();
    battle_log_receivers[tag] = cb;
    send_to_server.func(["GET_BATTLE_LOG3", battle_time, attacker_id, defender_id, base_id, tag]);
};

function receive_battle_log_result(dialog, ret) {
    if(!ret) {
        dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name_unavailable'];
    }

    dialog.widgets['loading_rect'].show =
        dialog.widgets['loading_text'].show = false;
    dialog.widgets['scroll_text'].show = true;

    dialog.user_data['log'] = ret;

    if(!ret) {
        dialog.widgets['log'].append_text([[new SPText.ABlock(dialog.data['widgets']['loading_text']['ui_name_unavailable'], null)]]);
    } else {
        var parsed = BattleLog.parse(dialog.user_data['from_id'], dialog.user_data['summary'], dialog.user_data['log']);
        dialog.widgets['log'].max_lines = parsed.length+10;
        for(var line = 0; line < parsed.length; line++) {
            dialog.widgets['log'].append_text(parsed[line]);
        }
    }
    dialog.widgets['log'].scroll_to_top();

    battle_log_change_page(dialog, 0);
};

function battle_log_change_page(dialog, page) {
    // resize output area
    var show_ports;

    // XXX temp until scrolling gets better
    dialog.widgets['scroll_text'].show = 0;
    if(true ||
       !dialog.user_data['log'] || !dialog.widgets['log'].can_scroll_up()) {
        show_ports = true;
        dialog.widgets['log'].xy[1] = 172;
        dialog.widgets['log'].wh[1] = 221;
    } else {
        show_ports = false;
        dialog.widgets['log'].xy[1] = 80;
        dialog.widgets['log'].wh[1] = 313;
    }
    dialog.widgets['attacker_portrait'].show =
        dialog.widgets['attacker_name'].show =
        dialog.widgets['attacker_type'].show =
        dialog.widgets['time_since_battle'].show =
        dialog.widgets['defender_portrait'].show =
        dialog.widgets['defender_name'].show =
        dialog.widgets['defender_type'].show =
        dialog.widgets['battle_duration'].show = show_ports;

    // set clickability of scroll arrows
    if(dialog.user_data['log']) {
        if(dialog.widgets['log'].can_scroll_up()) {
            dialog.widgets['scroll_left'].state = 'normal';
        } else {
            dialog.widgets['scroll_left'].state = 'disabled';
        }

        if(dialog.widgets['log'].can_scroll_down()) {
            dialog.widgets['scroll_right'].state = 'normal';
        } else {
            dialog.widgets['scroll_right'].state = 'disabled';
        }

        dialog.widgets['scroll_left'].onclick = function(w) {
            var _dialog = w.parent;
            _dialog.widgets['log'].scroll_up();
            battle_log_change_page(_dialog, _dialog.user_data['page']-1);
        };
        dialog.widgets['scroll_right'].onclick = function(w) {
            var _dialog = w.parent;
            _dialog.widgets['log'].scroll_down();
            battle_log_change_page(_dialog, _dialog.user_data['page']+1);
        };
    }

    return dialog;
};


// keep a dictionary of callbacks awaiting query results for player scores and score leaders,
// indexed by tags so we can send the results to the right callback
var last_query_tag = 1234;
var score_leaders_receivers = {};
var search_player_cache_receivers = {};
var player_scores_receivers = {};
var rivals_receivers = {};
var last_rivals_query_time = -1;
var quarry_receivers = {};
var last_quarry_query_time = -1;
var region_pop_receivers = {};

function query_score_leaders(field, period, callback) {
    last_query_tag += 1;
    var tag = 'qsl'+last_query_tag.toString();
    score_leaders_receivers[tag] = callback;
    send_to_server.func(["QUERY_SCORE_LEADERS", field, period, tag]);
}
/** @param {Array.<number>} id_list
    @param {Array.<string>} fields
    @param {function(Array)} callback
    @param {Object=} props */
function query_player_scores(id_list, fields, callback, props) {
    var get_rank = !!(props && props.get_rank);
    last_query_tag += 1;
    var tag = 'qps'+last_query_tag.toString();
    player_scores_receivers[tag] = callback;
    send_to_server.func(["QUERY_PLAYER_SCORES", id_list, fields, tag, get_rank]);
}
function search_player_cache(terms, callback) {
    last_query_tag += 1; var tag = 'spc'+last_query_tag.toString();
    search_player_cache_receivers[tag] = callback;
    send_to_server.func(["SEARCH_PLAYER_CACHE", SPHTTP.wrap_string(terms), tag]);
}
function query_rivals(callback, include_battled) {
    if(last_rivals_query_time == 0 ||
       (last_rivals_query_time > 0 && client_time < (last_rivals_query_time + gamedata['rival_query_cooldown']))) { return; }
    last_rivals_query_time = 0;
    last_query_tag += 1;
    var tag = 'qr'+last_query_tag.toString();
    rivals_receivers[tag] = callback;
    send_to_server.func(["QUERY_RIVALS", include_battled, tag]);
}
function query_quarries(callback, updated_since) {
    if(last_quarry_query_time == 0 ||
       (last_quarry_query_time > 0 && client_time < (last_quarry_query_time + gamedata['rival_query_cooldown']))) { return false; }
    last_quarry_query_time = 0;
    last_query_tag += 1;
    var tag = 'quar'+last_query_tag.toString();
    if(callback) { quarry_receivers[tag] = callback; }
    send_to_server.func(["QUARRY_QUERY", tag, updated_since]);
    return true;
}
function query_region_pop(callback) {
    last_query_tag += 1;
    var tag = 'pop'+last_query_tag.toString();
    region_pop_receivers[tag] = callback;
    send_to_server.func(["REGION_POP_QUERY", tag]);
}

/** @param {string=} force_period
    @param {string=} force_mode
    @param {string=} force_chapter */
function invoke_leaderboard(force_period, force_mode, force_chapter) {
    player.record_feature_use('leaderboard');

    var dialog = new SPUI.Dialog(gamedata['dialogs']['leaderboard_dialog']);
    dialog.user_data['dialog'] = 'leaderboard_dialog';
    dialog.user_data['friend_id_list'] = null;
    dialog.user_data['enable_tokens'] = false;
    dialog.user_data['self'] = []; // score rows
    dialog.user_data['self_queries'] = {}; // field_freq -> 1(inflight),2(landed)
    dialog.user_data['chapter'] = null;
    dialog.user_data['period'] = gamedata['matchmaking']['ladder_point_frequency'];
    dialog.user_data['mode'] = 'all';
    dialog.user_data['page'] = -1;
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.ondraw = update_leaderboard_dialog;
    dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };

    // see if a token-based event is going on
    if(player.get_event_time('current_event', null, 'inprogress')) {
        var props = gamedata['events'][player.get_event('current_event', null, player.get_absolute_time())['name']];
        dialog.user_data['enable_tokens'] = !!props['enable_token_leaderboard'];
    }

    dialog.user_data['periods'] = ['week', 'season'];
    dialog.user_data['categories'] = [];

    goog.object.forEach(gamedata['strings']['leaderboard']['categories'], function(data, name) {
        var enabled = ('leaderboard_show_if' in data && read_predicate(data['leaderboard_show_if']).is_satisfied(player, null));
        if(name == 'money_spent' && player.enable_muffins) { enabled = true; }
        if(enabled) {
            dialog.user_data['categories'].push(name);
        }
    });
    dialog.user_data['categories'].reverse(); // make buttons match order in strings.json left-to-right

    for(var i = 0; i < dialog.data['widgets']['category_button']['array'][0]; i++) {
        if(i >= dialog.user_data['categories'].length) {
            dialog.widgets['category_button'+i.toString()].show = false;
            continue;
        }
        var data = gamedata['strings']['leaderboard']['categories'][dialog.user_data['categories'][i]];
        dialog.widgets['category_button'+i.toString()].show = true;
        dialog.widgets['category_button'+i.toString()].str = data['short_title'];
        dialog.widgets['category_button'+i.toString()].onclick = (function (_cat) { return function(w) { leaderboard_change_page(w.parent, null, null, _cat, 0); }; })(dialog.user_data['categories'][i]);
    }

    dialog.widgets['show_friends'].onclick = function(w) { leaderboard_change_page(w.parent, null, 'friends', null, 0); };
    dialog.widgets['show_all'].onclick = function(w) { leaderboard_change_page(w.parent, null, 'all', null, 0); };
    dialog.widgets['show_week'].onclick = function(w) { leaderboard_change_page(w.parent, 'week', null, null, 0); };
    dialog.widgets['show_season'].onclick = function(w) { leaderboard_change_page(w.parent, 'season', null, null, 0); };
    dialog.widgets['friend_icon'].set_user(session.user_id);
    dialog.widgets['friend_icon'].onclick = invoke_player_info_dialog_self;

    dialog.user_data['queries'] = []; // list of [category,period] pairs to send queries on
    dialog.user_data['data'] = {}; // indexed by [categotry][period]
    dialog.user_data['friend_data'] = {}; // indexed by [categotry][period]
    for(var i = 0; i < dialog.user_data['categories'].length; i++) {
        var cat = dialog.user_data['categories'][i];
        dialog.user_data['data'][cat] = {};
        dialog.user_data['friend_data'][cat] = {};
        for(var j = 0; j < dialog.user_data['periods'].length; j++) {
            var period = dialog.user_data['periods'][j];
            dialog.user_data['data'][cat][period] = null;
            dialog.user_data['friend_data'][cat][period] = null;
            dialog.user_data['queries'].push([cat, period]);
        }
    }

    var quarry_event = player.get_event('current_event', 'event_quarry_contest', player.get_absolute_time());
    if(quarry_event && player.get_event_time('current_event', 'event_quarry_contest', 'inprogress')) {
        dialog.widgets['footer_bg'].show =
            dialog.widgets['footer_message'].show = true;
        dialog.widgets['footer_message'].set_text_with_linebreaking(quarry_event['ui_leaderboard_footer_message'].replace('%d', pretty_print_time_brief(-player.get_event_time('current_event', 'event_quarry_contest','end'))));
    }

    var default_period = (force_period ? force_period : null);
    var default_mode = (force_mode ? force_mode : 'all');
    var trophy_type = (player.is_ladder_player() ? 'pvp' : player.current_trophy_type());

    var default_chapter = (force_chapter ? force_chapter : eval_cond_or_literal(gamedata['strings']['leaderboard']['default_category'], player, null));

    // if chapter doesn't exist, fall back to the first one displayed
    if(!goog.array.contains(dialog.user_data['categories'], default_chapter)) { default_chapter = dialog.user_data['categories'][0]; }

    leaderboard_change_page(dialog, default_period, default_mode, default_chapter, 0);
    return dialog;
}

function leaderboard_query_self(dialog, field, frequency) {
    var key = field+'_'+frequency;
    if(dialog.user_data['self_queries'][key] > 0) { return; } // already launched
    dialog.user_data['self_queries'][key] = 1; // mark launched
    // ask server for player's own standings
    var qls = [[field,frequency]];
    query_player_scores([session.user_id], qls, (function (_dialog, _key, _qls) { return function(user_ids, datas) {
        if(!_dialog.parent) { return; } // dialog died
        _dialog.user_data['self_queries'][key] = 2; // mark landed
        var data = datas[0][0];
        if(data && ('absolute' in data)) {
            data['field'] = _qls[0][0]; data['frequency'] = _qls[0][1];
            _dialog.user_data['self'].push(data);
        }
        leaderboard_change_page(_dialog, null, null, _dialog.user_data['chapter'], _dialog.user_data['page']);
    }; })(dialog, key, qls), {get_rank:1});
}

// return localized description of player's rank/percentile standing
function percentile_ui_status(rank, pct, allow_you) {
    var status = '';
    var s = gamedata['strings']['percentiles'];
    if(rank <= 3 && allow_you) {
        status = s['ranknum'].replace('%d',rank.toString());
    } else if(pct >= 0.999) {
        status = s['top_001'];
    } else if(pct >= 0.75) {
        var breaks = [0.99, 0.98, 0.97, 0.96, 0.95, 0.9, 0.8, 0.75];
        for(var j = 0; j < breaks.length; j++) {
            if(pct >= breaks[j]) {
                status = s['top_pct'].replace('%pct', (100.0*(1.0-breaks[j])).toFixed(0));
                break;
            }
        }
    } else if(pct >= 0.5) {
        status = s['top_half'];
    }
    return status;
}

function leaderboard_change_page(dialog, period, mode, chapter, page) {
    if(period) { dialog.user_data['period'] = period; } else { period = dialog.user_data['period']; }
    if(chapter) { dialog.user_data['chapter'] = chapter; } else { chapter = dialog.user_data['chapter']; }
    if(mode) { dialog.user_data['mode'] = mode; } else { mode = dialog.user_data['mode']; }
    dialog.user_data['page'] = page;

    var ui_data = gamedata['strings']['leaderboard']['categories'][chapter];

    // restrict period to one(s) that is/are applicable to this chapter
    if(goog.array.indexOf(['trophies_pvp','trophies_pvv'], chapter) != -1) {
        dialog.widgets['show_week'].show = (gamedata['matchmaking']['ladder_point_frequency'] === 'week');
        dialog.widgets['show_season'].show = (gamedata['matchmaking']['ladder_point_frequency'] === 'season');
    } else if('periods' in ui_data) {
        dialog.widgets['show_week'].show = goog.array.contains(ui_data['periods'], 'week');
        dialog.widgets['show_season'].show = goog.array.contains(ui_data['periods'], 'season');
    } else {
        dialog.widgets['show_week'].show = dialog.widgets['show_season'].show = true;
    }

    if(period == 'week' && !dialog.widgets['show_week'].show) {
        period = dialog.user_data['period'] = 'season';
    } else if(period == 'season' && !dialog.widgets['show_season'].show) {
        period = dialog.user_data['period'] = 'week';
    }

    if(mode == 'friends') {
        if(dialog.user_data['friend_data'][chapter][period] === null) {
            var id_list = [];
            for(var i = 0; i < player.friends.length; i++) {
                if(player.friends[i].is_real_friend) { id_list.push(player.friends[i].user_id); }
            }
            if(id_list.length > 0) {
                // also query self
                id_list.push(session.user_id);

                // stash id_list for receiving the response
                dialog.user_data['friend_id_list'] = id_list;

                var friend_scores_cb = (function (dlg) { return function(user_ids, datas) {
                    // friend query result
                    // we send an ordinary PLAYER_SCORES query for each friend, then munge the returned data into the
                    // same format that SCORE_LEADERS returns
                    var queries = dlg.user_data['queries'];

                    var friend_map = {}; // map from user_id to player.friend

                    for(var i = 0; i < queries.length; i++) {
                        var ranklist = [];
                        for(var f = 0; f < user_ids.length; f++) {
                            var data = datas[f][i];
                            if(!data) { continue; } // friend is not ranked

                            if(user_ids[f] == session.user_id) {
                                // one of the entries will be self
                                ranklist.push({'absolute':data['absolute'],
                                               'user_id':user_ids[f],
                                               'player_level':player.resource_state["player_level"],
                                               'facebook_id':spin_facebook_user,
                                               'ui_name':player.get_ui_name()});
                            } else {
                                if(!(user_ids[f] in friend_map)) {
                                    var j;
                                    for(j = 0; j < player.friends.length; j++) {
                                        if(player.friends[j].user_id == user_ids[f]) {
                                            friend_map[user_ids[f]] = player.friends[j];
                                            break;
                                        }
                                    }
                                    if(j >= player.friends.length) {
                                        // friend not found
                                        continue;
                                    }
                                }
                                var friend = friend_map[user_ids[f]];
                                ranklist.push({'absolute':data['absolute'],
                                               'user_id':user_ids[f],
                                               'player_level':friend.get_player_level(),
                                               'facebook_id':friend.get_facebook_id(),
                                               'social_id':friend.get_social_id(),
                                               'ui_name':friend.get_ui_name()});
                            }
                        }
                        var compare_by_abs = function(a,b) {
                            if(a['absolute'] > b['absolute']) {
                                return -1;
                            } else if(a['absolute'] < b['absolute']) {
                                return 1;
                            } else {
                                return 0;
                            }
                        };
                        ranklist.sort(compare_by_abs);
                        dlg.user_data['friend_data'][queries[i][0]][queries[i][1]]=ranklist;
                    }
                    dlg.widgets['leaderboard_loading'].show = false;
                    leaderboard_change_page(dlg, null, null, dlg.user_data['chapter'], 0);
                }; })(dialog);

                query_player_scores(id_list, dialog.user_data['queries'], friend_scores_cb);
                dialog.widgets['leaderboard_loading'].show = true;
            } else {
                // player has no friends!
                dialog.widgets['leaderboard_loading'].show = false;
            }
            for(var ch in dialog.user_data['friend_data']) {
                for(var p in dialog.user_data['friend_data'][ch]) {
                    dialog.user_data['friend_data'][ch][p] = (id_list.length > 0 ? 'PENDING' : []);
                }
            }
        } else if(dialog.user_data['friend_data'][chapter][period] === 'PENDING') {
            dialog.widgets['leaderboard_loading'].show = true;
        } else {
            dialog.widgets['leaderboard_loading'].show = false;
        }
    } else {
        if(dialog.user_data['data'][chapter][period] === null) {
            // ask server for top rankings
            dialog.widgets['leaderboard_loading'].show = true;
            dialog.user_data['data'][chapter][period] = 'PENDING';
            var cb = (function (dlg) { return function(cat, period, data) {
                dlg.user_data['data'][cat][period] = data;
                leaderboard_change_page(dlg, null, null, dlg.user_data['chapter'], 0);
            }; })(dialog);
            query_score_leaders(chapter, period, cb);
        } else if(dialog.user_data['data'][chapter][period] === 'PENDING') {
            dialog.widgets['leaderboard_loading'].show = true;
        } else {
            dialog.widgets['leaderboard_loading'].show = false;
        }
    }

    for(var i = 0; i < dialog.data['widgets']['category_button']['array'][0]; i++) {
        if(i < dialog.user_data['categories'].length) {
            dialog.widgets['category_button'+i.toString()].state = (chapter === dialog.user_data['categories'][i] ? 'pressed' : 'normal');
        }
    }

    dialog.widgets['show_friends'].state = (mode === 'friends' ? 'active' : 'normal');
    dialog.widgets['show_all'].state = (mode === 'all' ? 'active' : 'normal');
    var region_specific = (gamedata['strings']['leaderboard']['categories'][chapter]['description'].indexOf('%REGION') != -1);
    dialog.widgets['show_all'].str = dialog.data['widgets']['show_all']['ui_name'+(region_specific ? '_region': '')];
    dialog.widgets['show_week'].state = (period === 'week' ? 'active' : 'normal');
    dialog.widgets['show_season'].state = (period === 'season' ? 'active' : 'normal');

    var is_contest_page = false;
    if(mode === 'all' && period === 'week' && chapter === 'quarry_resources' && player.get_event_time('current_event', 'event_quarry_contest', 'inprogress')) {
        is_contest_page = true;
    }
    var is_first_contest_page = (is_contest_page && page == 0);

    dialog.widgets['contest_leader_label'].show =
        dialog.widgets['contest_leader_rect'].show = is_first_contest_page;
    dialog.widgets['standings_label'].show = !is_first_contest_page;

    var ui_tournament = '';
    var challenge_name = player.current_trophy_pve_challenge_name();
    var challenge = (challenge_name ? gamedata['events'][challenge_name] : null);
    if(challenge && period === 'week') {
        ui_tournament = challenge['ui_name'] + ' ';
    }

    dialog.widgets['rankings_label'].str = dialog.data['widgets']['rankings_label']['ui_name'].replace('%s', ui_data['title'].replace('%PVP_CHALLENGE_NAME',gamedata['events']['challenge_pvp_ladder']['ui_name'])).replace('%when', gamedata['strings']['leaderboard']['periods'][period]['title'].replace('%SEASON',(current_pvp_season()+gamedata['matchmaking']['season_ui_offset']).toString()));
    dialog.widgets['rankings_description'].str = dialog.data['widgets']['rankings_description']['ui_name'].replace('%s', ui_data['description'].replace('%REGION',(session.region.data?gamedata['regions'][session.region.data['id']]['ui_name']:'')).replace('%PVP_CHALLENGE_NAME',gamedata['events']['challenge_pvp_ladder']['ui_name']).replace('%PVE_CHALLENGE_NAME',ui_tournament));
    dialog.widgets['your_total_label'].str = dialog.data['widgets']['your_total_label']['ui_name'].replace('%s1', gamedata['strings']['leaderboard']['periods'][period]['short']).replace('%s2', ui_data['short_title']);

    dialog.widgets['stat_challenge_icon'].asset = ui_data['challenge_icon'] || null;

    // fill in your own standings
    if(true) {
        var data = null;
        for(var i = 0; i < dialog.user_data['self'].length; i++) {
            var s = dialog.user_data['self'][i];
            if(s['field'] === chapter && s['frequency'] === period && ('absolute' in s)) {
                data = s;
                break;
            }
        }
        if(!data) { leaderboard_query_self(dialog, chapter, period); }

        dialog.widgets['self_loading'].show = (dialog.user_data['self_queries'][chapter+'_'+period] < 2);

        var brag_reason = (gamedata['strings']['leaderboard']['categories'][chapter]['brag_reason'] || gamedata['strings']['leaderboard']['categories'][chapter]['title']).replace('%PVP_CHALLENGE_NAME', gamedata['events']['challenge_pvp_ladder']['ui_name']);
        if(brag_reason) {
            brag_reason += ' '+gamedata['strings']['leaderboard']['periods'][period]['brag'];
        }

        var rank = -1, pct = -1;
        if(mode == 'friends') {
            // compute rank/percentile among friends
            var ranklist = dialog.user_data['friend_data'][chapter][period];
            if(ranklist) {
                for(var i = 0; i < ranklist.length; i++) {
                    if(ranklist[i]['user_id'] == session.user_id) {
                        rank = i+1;
                        pct = 1.0-(i/ranklist.length);
                        break;
                    }
                }
            }
        } else {
            // use global rank/percentile
            if(data && ('rank' in data))  {
                rank = data['rank']+1;
                pct = 1.0-data['percentile'];
            }
        }
        var absolute = (data ? data['absolute'] : -1);
        var display_absolute = (data ? (dialog.user_data['chapter'].slice(0,8) === 'trophies' ? display_trophy_count(absolute, dialog.user_data['chapter'].slice(9)) : absolute) : -1);
        dialog.widgets['your_rank'].str = (rank >= 0 ? pretty_print_number(rank) : '-');
        dialog.widgets['your_pct'].str = (pct >= 0 && display_absolute > 0 ? (100.0*pct).toFixed(1)+'%' : '-');
        dialog.widgets['your_total'].str = (display_absolute > 0 ? pretty_print_number(display_absolute) : '-');
        dialog.widgets['your_rank_accent'].show = (pct >= 0.5);
        dialog.widgets['your_rank_accent'].state = (pct >= 0.99 ? 'top' : 'normal');
        dialog.widgets['your_status'].show = (pct >= 0.5);
        dialog.widgets['your_status'].str = percentile_ui_status(rank, pct, true);
        dialog.widgets['inform_button'].show = (pct >= 0.5) && (brag_reason != null) && (mode != 'friends') && get_facebook_viral('leaderboard_brag');
        dialog.widgets['inform_button'].state = 'normal';
        dialog.widgets['inform_button'].onclick = (function (_rank, _percentile, _reason) { return function() {
            invoke_leaderboard_brag(_rank-1, _percentile, _reason);
        }; })(rank, pct, brag_reason);
    }

    // fill in rankings
    var row = 0;
    var rows_per_page = 10;

    var data_source = dialog.user_data[(mode == 'friends' ? 'friend_data' : 'data')][chapter][period];
    var chapter_players;
    if(!data_source || data_source === 'PENDING') {
        chapter_players = 0;
    } else {
        chapter_players = data_source.length;
    }
    var chapter_pages = Math.floor((chapter_players+rows_per_page-1)/rows_per_page);
    dialog.user_data['page'] = page = (chapter_pages === 0 ? 0 : clamp(page, 0, chapter_pages-1));
    if(chapter_pages > 0) {
        var first_player_on_page = page * rows_per_page;
        var last_player_on_page = (page+1)*rows_per_page - 1;
        last_player_on_page = Math.max(0, Math.min(last_player_on_page, chapter_players-1));

        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(page+1).toString()).replace('%d2',chapter_pages.toString());

        for(var i = first_player_on_page; i <= last_player_on_page; i++) {
            var data = data_source[i];
            var x = Math.floor(row/5), y = row % 5;
            var index = x.toString()+','+y.toString();

            var long_name = PlayerCache.get_ui_name(data);

            dialog.widgets['player_portrait'+index].show =
                dialog.widgets['player_portrait_frame'+index].show = true;
            dialog.widgets['player_portrait'+index].set_user(data['user_id']);
            dialog.widgets['player_portrait'+index].onclick =
                dialog.widgets['player_portrait_frame'+index].onclick =
                dialog.widgets['player_name'+index].onclick =
                dialog.widgets['rank_numeral'+index].onclick =
                dialog.widgets['player_value'+index].onclick = (function (_uid, _fbid, _name, _level) { return function() {
                                        invoke_player_info_dialog_unknown(_uid, _fbid, _name, _level);
                                        // go directly to Spying rather than opening Player Info
                                        //if(_uid != session.user_id) { visit_base_with_loading_message(_uid); }
            }; })(data['user_id'], data['facebook_id'], long_name, data['player_level'] || 1);
            dialog.widgets['player_name'+index].show = true;
            var short_name = long_name;
            var max_len = 12;
            if(short_name.length > max_len) {
                short_name = short_name.slice(0,max_len);
            }
            dialog.widgets['player_name'+index].str = short_name+' (L'+(data['player_level'] || 1).toString()+')';
            dialog.widgets['player_value'+index].show = true;
            var display_absolute = (dialog.user_data['chapter'].slice(0,8) === 'trophies' ? display_trophy_count(data['absolute'], dialog.user_data['chapter'].slice(9)) : data['absolute']);
            dialog.widgets['player_value'+index].str = pretty_print_number(display_absolute);
            dialog.widgets['rank_accent'+index].show = true;
            dialog.widgets['rank_accent'+index].state = ((i+1) <= 3 ? 'top' : 'normal');
            dialog.widgets['rank_numeral'+index].show = true;
            dialog.widgets['rank_numeral'+index].str = (i+1).toString();
            dialog.widgets['rank_numeral'+index].font = ((i+1) <= 3 ? SPUI.make_font(22,25,'bold') : SPUI.make_font(19,25,'normal'));

            row += 1;
        }
    } else {
        // no players in the list
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(0).toString()).replace('%d2',(0).toString()).replace('%d3',(0).toString());
    }


    // clear out empty rows
    while(row < rows_per_page) {
        var x = Math.floor(row/5), y = row % 5;
        var index = x.toString()+','+y.toString();
        dialog.widgets['rank_accent'+index].show =
            dialog.widgets['rank_numeral'+index].show =
            dialog.widgets['player_portrait'+index].show =
            dialog.widgets['player_portrait_frame'+index].show =
            dialog.widgets['player_name'+index].show =
            dialog.widgets['player_value'+index].show = false;
        row += 1;
    }

    // set clickability of scroll arrows
    if(page != 0) {
        dialog.widgets['scroll_left'].state = 'normal';
    } else {
        dialog.widgets['scroll_left'].state = 'disabled';
    }

    if(page < (chapter_pages-1)) {
        dialog.widgets['scroll_right'].state = 'normal';
    } else {
        dialog.widgets['scroll_right'].state = 'disabled';
    }

    dialog.widgets['scroll_left'].onclick = function(w) { leaderboard_change_page(w.parent, null, null, selection.ui.user_data['chapter'], selection.ui.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function(w) { leaderboard_change_page(w.parent, null, null, selection.ui.user_data['chapter'], selection.ui.user_data['page']+1); };
}

function update_leaderboard_dialog(dialog) {
    if(dialog.widgets['contest_leader_rect'].show) {
        dialog.widgets['contest_leader_rect'].opacity = 0.5 + 0.5*(0.5*(1+Math.sin(client_time/0.25)));
    }
}

// we need to overhaul player identity management. Right now you have
// to pass in "knowledge" about the player obtained from other sources
// (friends list, chat window, etc), this is bad legacy code.

function invoke_player_info(user_id, knowledge) {
    if(!user_id) { user_id = session.user_id; }
    if(!knowledge) { knowledge = {}; }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['player_info_frame']);
    dialog.user_data['dialog'] = 'player_info_frame';
    dialog.user_data['user_id'] = user_id;
    dialog.user_data['knowledge'] = knowledge;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['statistics_button'].onclick = function(w) { invoke_statistics_tab(w.parent); };
    dialog.widgets['achievements_button'].onclick = invoke_achievements_tab;
    dialog.widgets['profile_button'].onclick = invoke_player_profile_tab;
    dialog.widgets['profile_button'].onclick(dialog.widgets['profile_button']);
    return dialog;
}

/** @param {SPUI.Dialog} parent
    @param {Object|null=} preselect */
function invoke_statistics_tab(parent, preselect) {
    var user_id = parent.user_data['user_id'];
    var knowledge = parent.user_data['knowledge'];

    player.record_feature_use(user_id === session.user_id ? 'own_statistics' : 'other_statistics');

    if('tab' in parent.widgets) {
        if(parent.widgets['tab'].user_data['dialog'] == 'player_info_statistics_tab') {
            // we're already up
            return;
        }
        parent.remove(parent.widgets['tab']);
        delete parent.widgets['tab'];
    }

    parent.widgets['statistics_button'].state = 'active';
    parent.widgets['profile_button'].state = 'normal';
    parent.widgets['achievements_button'].state = 'normal';

    var dialog = new SPUI.Dialog(gamedata['dialogs']['player_info_statistics_tab']);
    dialog.transparent_to_mouse = true;
    dialog.user_data['dialog'] = 'player_info_statistics_tab';
    dialog.user_data['user_id'] = user_id;

    dialog.widgets['player_name'].str = knowledge['name'] + ' L'+knowledge['level'].toString()+'';
    dialog.widgets['player_id'].str = dialog.data['widgets']['player_id']['ui_name'].replace('%d', user_id.toString());

    var url = player.get_any_abtest_value('score_history_show_other_url', gamedata['client']['score_history_show_other_url'] || null);
    if(url) {
        url = url_put_info(url, session.user_id, player.history['money_spent']||0);
        dialog.widgets['show_other_button'].show = true;
        dialog.widgets['show_other_button'].onclick = (function (_url) { return function(w) {
            if(w.parent) {
                var handle = window.open(_url, '_blank');
                if(handle) { handle.focus(); }
            }
        }; })(url);
    }

    parent.widgets['tab'] = dialog;
    parent.add(dialog);

    // which time scope to show - pretty much only works with "season"
    dialog.user_data['time_scope'] = 'season'; // gamedata['matchmaking']['ladder_point_frequency'];
    if(!goog.array.contains(['week','season'], dialog.user_data['time_scope'])) { throw Error('unknown time scope '+dialog.user_data['time_scope']); }

    // time_loc we're at right now
    dialog.user_data['time_cur'] = {'week': current_pvp_week(), 'season': current_pvp_season()}[dialog.user_data['time_scope']];

    // how far back in time we offer queries for
    if(dialog.user_data['time_scope'] == 'week') {
        dialog.user_data['time_limit'] = Math.max(1, dialog.user_data['time_cur']-5); // limit query to 5 historical entries
    } else if(dialog.user_data['time_scope'] == 'season') {
        dialog.user_data['time_limit'] = Math.min(dialog.user_data['time_cur'], Math.max(1, -(gamedata['matchmaking']['season_ui_offset']||0) + 1));
    }

    // which time_loc is actually displayed
    // -1 means "ignore time_scope, use ALL scope and 0 loc", i.e. All Time
    dialog.user_data['time_displayed'] = null;

    // since queries are asynchronous, make sure that only the last one to arrive actually updates the GUI
    dialog.user_data['query_gen'] = 0;

    dialog.user_data['show_rank'] = true;

    // show "all time" by default
    var default_loc = -1; // dialog.user_data['time_cur']);
    if(preselect && ('time' in preselect)) {
        if(preselect['time'][0] == 'ALL') {
            default_loc = -1;
        } else {
            default_loc = preselect['time'][1];
        }
    }

    player_info_statistics_tab_select(dialog, default_loc);
    return dialog;
}

// select a new time_loc
function player_info_statistics_tab_select(dialog, new_loc) {
    if(dialog.user_data['time_displayed'] == new_loc) {
        // nothing to do
        return;
    }
    if(dialog.widgets['loading_text'].show) { return; } // don't overlap

    dialog.user_data['time_displayed'] = new_loc;

    // update BBCode for time-loc selection bar
    var selector = [[]];
    selector[0] = selector[0].concat(SPText.cstring_to_ablocks_bbcode(dialog.data['widgets']['selector']['ui_name'])[0]);

    // ALL TIME
    var ui_current = dialog.data['widgets']['selector']['ui_name_alltime'].replace('%scope', gamedata['strings']['leaderboard']['periods'][dialog.user_data['time_scope']]['name']);
    var is_selected = (dialog.user_data['time_displayed'] == -1);
    ui_current = dialog.data['widgets']['selector'][(is_selected ? 'ui_format_selected' : 'ui_format_unselected')].replace('%thing', ui_current);
    selector[0] = selector[0].concat(SPText.cstring_to_ablocks_bbcode(ui_current, {onclick:
                                                                                   (function(_dialog) { return function() {
                                                                                       player_info_statistics_tab_select(_dialog, -1);
                                                                                   }; })(dialog)})[0]);

    // CURRENT LOC
    selector[0] = selector[0].concat(SPText.cstring_to_ablocks_bbcode(dialog.data['widgets']['selector']['ui_separator'])[0]);
    ui_current = dialog.data['widgets']['selector']['ui_name_current'].replace('%scope', gamedata['strings']['leaderboard']['periods'][dialog.user_data['time_scope']]['name']);
    is_selected = (dialog.user_data['time_displayed'] == dialog.user_data['time_cur']);
    ui_current = dialog.data['widgets']['selector'][(is_selected ? 'ui_format_selected' : 'ui_format_unselected')].replace('%thing', ui_current);
    selector[0] = selector[0].concat(SPText.cstring_to_ablocks_bbcode(ui_current, {onclick:
                                                                                   (function(_dialog) { return function() {
                                                                                       player_info_statistics_tab_select(_dialog, _dialog.user_data['time_cur']);
                                                                                   }; })(dialog)})[0]);
    // HISTORICAL LCOS
    for(var time_loc = dialog.user_data['time_cur'] - 1; time_loc >= dialog.user_data['time_limit']; time_loc -= 1) {
        selector[0] = selector[0].concat(SPText.cstring_to_ablocks_bbcode(dialog.data['widgets']['selector']['ui_separator'])[0]);
        var ui_prev = dialog.data['widgets']['selector']['ui_name_prev'].replace('%scope', gamedata['strings']['leaderboard']['periods'][dialog.user_data['time_scope']]['name']).replace('%loc', (time_loc + (dialog.user_data['time_scope'] == 'season' ? (gamedata['matchmaking']['season_ui_offset']||0) : 0)).toFixed(0));
        is_selected = (dialog.user_data['time_displayed'] == time_loc);
        ui_prev = dialog.data['widgets']['selector'][(is_selected ? 'ui_format_selected' : 'ui_format_unselected')].replace('%thing', ui_prev);
        selector[0] = selector[0].concat(SPText.cstring_to_ablocks_bbcode(ui_prev, {onclick:
                                                                                    (function(_dialog, _time_loc) { return function() {
                                                                                        player_info_statistics_tab_select(_dialog, _time_loc);
                                                                                    }; })(dialog, time_loc)})[0]);
    }

    dialog.widgets['selector'].clear_text();
    dialog.widgets['selector'].append_text(selector);

    // perform the query

    // which stats to query - for now, hard-coded to be a subset of the ones recorded in Scores2
    dialog.user_data['stats'] = goog.array.filter(['trophies_pvp','trophies_pvv','tokens_looted','resources_looted',
                                                   'damage_inflicted','havoc_caused','hive_kill_points','quarry_resources','strongpoint_resources'],
                                                  function(stat) { return (stat in gamedata['strings']['leaderboard']['categories']) &&
                                                                   ('group' in gamedata['strings']['leaderboard']['categories'][stat]) &&
                                                                   ('statistics_show_if' in gamedata['strings']['leaderboard']['categories'][stat]) &&
                                                                   read_predicate(gamedata['strings']['leaderboard']['categories'][stat]['statistics_show_if']).is_satisfied(player,null); });

    // list of queries to send
    var qls = [];
    var scope = (dialog.user_data['time_displayed'] == -1 ? 'ALL' : dialog.user_data['time_scope']);
    var loc = (dialog.user_data['time_displayed'] == -1 ? 0 : dialog.user_data['time_displayed']);
    goog.array.forEach(dialog.user_data['stats'], function(stat) {
        qls.push([stat, scope, loc]);
    });
    dialog.user_data['query_gen'] += 1;
    query_player_scores([dialog.user_data['user_id']], qls, (function(_dialog, _query_gen) { return function(user_ids, data, status_code) {
        player_info_statistics_tab_receive(_dialog, data, status_code, _query_gen);
    }; })(dialog, dialog.user_data['query_gen']), {get_rank:dialog.user_data['show_rank']});

    dialog.widgets['loading_rect'].show =
        dialog.widgets['loading_text'].show =
        dialog.widgets['loading_spinner'].show = true;
    dialog.widgets['share_button'].show = false;
    dialog.widgets['output'].clear_text();
    dialog.widgets['scroll_up'].onclick = function (w) { player_info_statistics_tab_scroll(w.parent, -1); };
    dialog.widgets['scroll_down'].onclick = function (w) { player_info_statistics_tab_scroll(w.parent, 1); };
    player_info_statistics_tab_scroll(dialog, 0);
    return dialog;
}

function player_info_statistics_tab_scroll(dialog, incr) {
    if(incr < 0) {
        dialog.widgets['output'].scroll_up();
    } else if(incr > 0) {
        dialog.widgets['output'].scroll_down();
    }

    // set clickability of scroll arrows
    dialog.widgets['scroll_up'].state = (dialog.widgets['output'].can_scroll_up() ? 'normal' : 'disabled');
    dialog.widgets['scroll_down'].state = (dialog.widgets['output'].can_scroll_down() ? 'normal' : 'disabled');
}

function player_info_statistics_tab_format_stat(dialog, stat, val, rank, by_group) {
    var catdata = gamedata['strings']['leaderboard']['categories'][stat];
    var display_mode = catdata['display'] || 'integer';
    var ui_val;
    if(display_mode == 'integer') {
        ui_val = pretty_print_number(val);
    } else if(display_mode == 'seconds') {
        ui_val = pretty_print_time_brief(val);
    } else if(display_mode == 'days') {
        ui_val = (val/86400).toFixed(0);
    } else {
        throw Error('unknown display_mode '+display_mode);
    }
    var ui_stat = dialog.data['widgets']['output'][(rank >= 0 ? 'ui_stat_ranked' : 'ui_stat')].replace('%stat', catdata['title']).replace('%val', ui_val);
    if(rank >= 0) { ui_stat = ui_stat.replace('%rank', pretty_print_number(rank+1)); }

    var result = SPText.cstring_to_ablocks_bbcode(ui_stat, {tooltip_func:
                                                            (function (_catdata) { return function() {
                                                                return _catdata['description'];
                                                            }; })(catdata)
                                                           });
    // append the result to the proper entry in by_group
    if(!(catdata['group'] in by_group)) {
        by_group[catdata['group']] = {};
    }
    by_group[catdata['group']][stat] = result;
}

function player_info_statistics_tab_receive(dialog, data, status_code, query_gen) {
    if(!dialog.parent) { return; } // dialog got closed asynchronously
    if(query_gen != dialog.user_data['query_gen']) { return; } // over-ridden by a later query

    var stats = dialog.user_data['stats'];

    if(data !== null && data.length == 1) {
        dialog.widgets['loading_rect'].show =
            dialog.widgets['loading_text'].show =
            dialog.widgets['loading_spinner'].show = false;

        dialog.widgets['output'].clear_text();

        if(status_code == 'SCORES_OFFLINE') {
            dialog.widgets['output'].append_text([]); // add a blank line
            dialog.widgets['output'].append_text(SPText.cstring_to_ablocks(gamedata['errors']['SCORES_OFFLINE']['ui_name']));
            dialog.widgets['output'].append_text([]); // add a blank line
        }

        var by_group = {}; // mapping from group name -> stat name -> string to display
        var player_data = data[0];

        goog.array.forEach(stats, function(stat, i) {
            if(player_data[i]) {
                var val = player_data[i]['absolute'] || 0;
                var rank = ('rank' in player_data[i] ? player_data[i]['rank'] : -1);
                player_info_statistics_tab_format_stat(dialog, stat, val, rank, by_group);
            }
        });

        // if looking at your own "all time" data, add some "fake" stats that are just player history keys
        if(dialog.user_data['user_id'] == session.user_id && dialog.user_data['time_displayed'] == -1) {
            goog.object.forEach({
                'resources_looted_from_human': player.history['resources_looted_from_human'] || 0,
                'resources_stolen_by_human': player.history['resources_stolen_by_human'] || 0,
                'attacks_launched_vs_human': player.history['attacks_launched_vs_human'] || 0,
                // time_in_game is updated on logout, so add current session time
                'time_in_game': player.history['time_in_game'] + (client_time - session.connect_time),
                'account_age': server_time - player.creation_time},
                                function(val, stat) {
                                    if((stat in gamedata['strings']['leaderboard']['categories']) &&
                                       ('group' in gamedata['strings']['leaderboard']['categories'][stat]) &&
                                       ('statistics_show_if' in gamedata['strings']['leaderboard']['categories'][stat]) &&
                                       read_predicate(gamedata['strings']['leaderboard']['categories'][stat]['statistics_show_if']).is_satisfied(player, null)) {
                                        player_info_statistics_tab_format_stat(dialog, stat, val, -1, by_group);
                                    }
                                });
        }

        if(goog.object.getCount(by_group) < 1) {
            dialog.widgets['output'].append_text([]); // add a blank line
            dialog.widgets['output'].append_text(SPText.cstring_to_ablocks_bbcode(dialog.data['widgets']['output']['ui_name_nostats']));
        } else {
            var delay_warn = null;
            if(dialog.user_data['time_displayed'] >= 0 && dialog.user_data['time_displayed'] < dialog.user_data['time_cur']-1) {
                // technically past-time queries are not "hot", but they can't be affected by players anymore, so don't show delay warning
                delay_warn = 'history';
            } else {
                // note: please keep in sync with gameserver/server.py: is_hot_point
                var is_hot = (dialog.user_data['time_displayed'] == dialog.user_data['time_cur'] ||
                              (dialog.user_data['time_displayed'] == -1 && gamedata['scores2_time_all_is_hot']));
                delay_warn = (is_hot ? 'hot' : 'cold');
            }
            if(delay_warn) {
                var s = dialog.data['widgets']['output']['ui_name_delay_'+delay_warn];
                if(s) {
                    dialog.widgets['output'].append_text(SPText.cstring_to_ablocks_bbcode(s));
                }
            }
            dialog.widgets['output'].append_text([]); // add a blank line

            // sort groups by priority, then alphabet
            var sort_by_priority = function (db) { return function(a,b) {
                var pa = db[a]['priority'] || 0, pb = db[b]['priority'] || 0;
                var na = db[a]['title'], nb = db[b]['title'];
                if(pa > pb) { return -1; }
                else if(pa < pb) { return 1; }
                else if(na > nb) { return 1; }
                else if(na < nb) { return -1; }
                else { return 0; }
            }; };

            var group_keys = goog.object.getKeys(by_group).sort(sort_by_priority(gamedata['strings']['leaderboard']['stat_groups']));
            goog.array.forEach(group_keys, function(group_name, i) {
                var group_data = gamedata['strings']['leaderboard']['stat_groups'][group_name];
                var ui_group = group_data['title'].toUpperCase();
                if(i > 0) { dialog.widgets['output'].append_text([]); } // add a blank line
                dialog.widgets['output'].append_text(SPText.cstring_to_ablocks_bbcode(dialog.data['widgets']['output']['ui_group_header'].replace('%group', ui_group)));

                // sort stats
                var stat_keys = goog.object.getKeys(by_group[group_name]).sort(sort_by_priority(gamedata['strings']['leaderboard']['categories']));
                goog.array.forEach(stat_keys, function(stat_name) {
                    dialog.widgets['output'].append_text(by_group[group_name][stat_name]);
                });
            });
        }
        dialog.widgets['output'].scroll_to_top();
        player_info_statistics_tab_scroll(dialog, 0);
        player_info_statistics_tab_setup_share_button(dialog);
    } else {
        dialog.widgets['share_button'].show = false;
        dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name_unavailable'];
        dialog.widgets['loading_spinner'].show = false;
    }
}

function player_info_statistics_tab_setup_share_button(dialog) {
    if(spin_frame_platform != 'fb' ||
       !player.get_any_abtest_value('enable_player_info_statistics_share_button',
                                    gamedata['client']['enable_player_info_statistics_share_button'])) {
        return;
    }
    dialog.widgets['share_button'].show = true;
    dialog.widgets['share_button'].onclick = function(w) {
        var dialog = w.parent;
        var val = {'user_id': dialog.user_data['user_id'],
                   'preselect': {'time': [dialog.user_data['time_displayed'] == -1 ? 'ALL' : dialog.user_data['time_scope'],
                                          dialog.user_data['time_displayed']]}};
        var url = 'https://apps.facebook.com/'+spin_app_namespace+'/';
        url += '?spin_campaign=feed_stats_share&spin_ref=feed_stats_share&spin_ref_user_id='+session.user_id.toString();
        url += '&player_info_statistics='+encodeURIComponent(JSON.stringify(val));
        if(!spin_facebook_enabled) { console.log('player_info_statistics_tab_share_button: '+url); return; }

        call_with_facebook_permissions('publish_actions', (function (_url) { return function() {
            var viral = gamedata['virals']['stats_share'];
            var props = {'method':'feed',
                         'name':viral['ui_post_headline'],
                         'link':_url,
                         'picture': gamedata['virals']['common_image_path'] + gamedata['virals']['default_image'],
                         'ref':'stats_share', // 15-char limit
                         'show_error': !spin_secure_mode
                        };
            metric_event('7270_feed_post_attempted', {'method':'stats_share'});

            SPFB.ui(props, function(response) { // statistics share
                if(!response) { return; } // cancelled
                if('post_id' in response) {
                   metric_event('7271_feed_post_completed', {'method':'stats_share', 'facebook_post_id':response['post_id']});
                } });

        }; }(url)));
    };
}

function invoke_achievements_tab(w, preselect_category, preselect_name) {
    var parent = w.parent;
    var user_id = parent.user_data['user_id'];
    var knowledge = parent.user_data['knowledge'];

    player.record_feature_use(user_id === session.user_id ? 'own_achievements' : 'other_achievements');

    if('tab' in parent.widgets) {
        if(parent.widgets['tab'].user_data['dialog'] == 'player_info_achievements_tab' && !preselect_category) {
            // we're already up
            return;
        }
        parent.remove(parent.widgets['tab']);
        delete parent.widgets['tab'];
    }

    parent.widgets['statistics_button'].state = 'normal';
    parent.widgets['statistics_button'].show = player.get_any_abtest_value('enable_score_history', gamedata['client']['enable_score_history']);
    parent.widgets['profile_button'].state = 'normal';
    parent.widgets['achievements_button'].state = 'active';

    var dialog = new SPUI.Dialog(gamedata['dialogs']['player_info_achievements_tab']);
    dialog.transparent_to_mouse = true;
    dialog.user_data['dialog'] = 'player_info_achievements_tab';
    dialog.user_data['user_id'] = user_id;

    dialog.widgets['cat_list'].user_data['page'] = -1;
    dialog.widgets['cat_list'].user_data['rows_per_page'] = dialog.widgets['cat_list'].data['widgets']['category']['array'][1];
    dialog.widgets['cat_list'].user_data['rowfunc'] = achievement_category_rowfunc;
    dialog.widgets['cat_list'].user_data['rowdata'] = [];

    dialog.widgets['ach_list'].user_data['page'] = -1;
    dialog.widgets['ach_list'].user_data['rows_per_page'] = dialog.widgets['ach_list'].data['widgets']['ach']['array'][1];
    dialog.widgets['ach_list'].user_data['rowfunc'] = achievement_rowfunc;
    dialog.widgets['ach_list'].user_data['rowdata'] = [];
    dialog.user_data['player_achievements'] = null;

    dialog.widgets['player_name'].str = knowledge['name'] + ' L'+knowledge['level'].toString()+'';
    dialog.widgets['lag_note'].show = (user_id != session.user_id);

    // create and sort cateory list
    var ach_cats = [];
    for(var name in gamedata['achievement_categories']) {
        var data = gamedata['achievement_categories'][name];
        if(('show_if' in data) && !read_predicate(data['show_if']).is_satisfied(player, null)) { continue; }
        if(('activation' in data) && !read_predicate(data['activation']).is_satisfied(player, null)) { continue; }
        ach_cats.push(name);
    }
    var compare_by_ui_priority = function(a,b) {
        var pa = gamedata['achievement_categories'][a]['ui_priority'] || 0;
        var pb = gamedata['achievement_categories'][b]['ui_priority'] || 0;
        if(pa > pb) {
            return -1;
        } else if(pa < pb) {
            return 1;
        } return 0;
    };
    ach_cats.sort(compare_by_ui_priority);

    dialog.widgets['cat_list'].user_data['rowdata'] = ach_cats;

    parent.widgets['tab'] = dialog;
    parent.add(dialog);

    dialog.user_data['category'] = (preselect_category || ach_cats[0]);
    dialog.user_data['preselect_name'] = preselect_name || null;
    achievements_tab_set_category(dialog, dialog.user_data['category']);

    if(user_id === session.user_id) {
        achievements_dialog_receive(dialog, player.achievements);
    } else {
        query_achievements(user_id, (function (_dialog) { return function(achdata) { achievements_dialog_receive(_dialog, achdata); }; })(dialog));
    }

    return dialog;
}

function achievements_tab_set_category(dialog, catname) {
    // update category list
    dialog.user_data['category'] = catname;
    scrollable_dialog_change_page(dialog.widgets['cat_list'], dialog.widgets['cat_list'].user_data['page']);

    // update achievement list
    var achdata = dialog.user_data['player_achievements'];
    var ach_list = [], total = 0, completed = 0;

    if(achdata !== null) {
        for(var name in gamedata['achievements']) {
            var data = gamedata['achievements'][name];
            if(data['category'] !== catname) { continue; }
            if(('show_if' in data) && !read_predicate(data['show_if']).is_satisfied(player, null)) { continue; }
            if(('activation' in data) && !read_predicate(data['activation']).is_satisfied(player, null)) { continue; }
            ach_list.push(data);
            total += 1;
            if(name in achdata) { completed += 1; }
        }
    }
    ach_list.sort(compare_achievements(achdata));

    if(total > 0) {
        dialog.widgets['cat_progress'].progress = completed / total;
        if(gamedata['client']['show_achievement_complete_pct']) {
            dialog.widgets['cat_progress_text'].str = dialog.data['widgets']['cat_progress_text']['ui_name'].replace('%cat', gamedata['achievement_categories'][catname]['ui_name']).replace('%pct', Math.floor(100.0*dialog.widgets['cat_progress'].progress+0.5).toFixed(0));
        }
    } else {
        dialog.widgets['cat_progress'].progress = 0;
        dialog.widgets['cat_progress_text'].str = null;
    }

    dialog.widgets['ach_list'].user_data['rowdata'] = ach_list;
    scrollable_dialog_change_page(dialog.widgets['ach_list'], 0);
}

// achievement sorting function
// put completed achievements first, then rank by display order
// for COMPLETED achievements, "awesomer" ones are ranked HIGHER
// for INCOMPLETE achievements, "awesomer" ones are ranked LOWER
function compare_achievements(_achdata) {
    return function(a,b) {
        var order = 1;
        var ap = (('ui_priority' in a) ? -a['ui_priority'] : (('fb_open_graph' in a) && ('display_order' in a['fb_open_graph']) ? -a['fb_open_graph']['display_order'] : 0));
        var bp = (('ui_priority' in b) ? -b['ui_priority'] : (('fb_open_graph' in b) && ('display_order' in b['fb_open_graph']) ? -b['fb_open_graph']['display_order'] : 0));

        if((a['name'] in _achdata) && !(b['name'] in _achdata)) {
            return -order;
        } else if(!(a['name'] in _achdata) && (b['name'] in _achdata)) {
            return order;
        } else if(ap > bp) {
            // if both achievements are complete, rank the "awesomer" one first
            return ((a['name'] in _achdata) && (b['name'] in _achdata) ? order : -order);
        } else if(ap < bp) {
            // if both achievements are complete, rank the "awesomer" one first
            return ((a['name'] in _achdata) && (b['name'] in _achdata) ? -order : order);
        } else {
            return 0;
        }
    };
}

var achievements_receivers = {};
function query_achievements(user_id, cb) {
    last_query_tag += 1;
    var tag = 'qa'+last_query_tag.toString();
    achievements_receivers[tag] = cb;
    send_to_server.func(["QUERY_ACHIEVEMENTS", user_id, tag]);
}

function achievements_dialog_receive(dialog, achdata) {
    if(!dialog.parent) { return; } // dialog got closed asynchronously

    dialog.user_data['player_achievements'] = achdata;

    dialog.widgets['cat_progress_bg'].show =
        dialog.widgets['cat_progress'].show =
        dialog.widgets['cat_progress_text'].show = (achdata !== null);

    if(achdata !== null) {
        dialog.widgets['loading_rect'].show =
            dialog.widgets['loading_text'].show =
            dialog.widgets['loading_spinner'].show = false;
        achievements_tab_set_category(dialog, dialog.user_data['category']);

        // show preselected achievement
        if(dialog.user_data['preselect_name']) {
            var idx = goog.array.findIndex(dialog.widgets['ach_list'].user_data['rowdata'], function(cheeve) { return cheeve['name'] == dialog.user_data['preselect_name']; });
            if(idx >= 0) {
                scrollable_dialog_change_page(dialog.widgets['ach_list'], Math.floor(idx / dialog.widgets['ach_list'].user_data['rows_per_page']));
            }
            dialog.user_data['preselect_name'] = null;
        }
    } else {
        dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name_unavailable'];
        dialog.widgets['loading_spinner'].show = false;
    }
}

function achievement_category_rowfunc(dialog, row, rowdata) {
    dialog.widgets['category'+row.toString()].show = (rowdata !== null);
    if(rowdata !== null) {
        dialog.widgets['category_status'+row.toString()].show = dialog.data['widgets']['category_status']['show'] &&
            (dialog.parent.user_data['player_achievements'] != null);
        if(dialog.widgets['category_status'+row.toString()].show) {
            var stat = dialog.data['widgets']['category_status']['ui_name'];
            var total = 0, complete = 0;
            for(var achname in gamedata['achievements']) {
                var data = gamedata['achievements'][achname];
                if(data['category'] != rowdata) { continue; }
                if(('show_if' in data) && !read_predicate(data['show_if']).is_satisfied(player, null)) { continue; }
                if(('activation' in data) && !read_predicate(data['activation']).is_satisfied(player, null)) { continue; }
                if(achname in dialog.parent.user_data['player_achievements']) {
                    complete += 1;
                }
                total += 1;
            }
            stat = stat.replace('%complete', complete.toString());
            stat = stat.replace('%total', total.toString());
            stat = stat.replace('%pct', (total <= 0 ? '-' : Math.floor((100.0*complete/total)+0.5).toFixed(0)));
            dialog.widgets['category_status'+row.toString()].str = stat;
            var clr = (complete >= total ? 'complete' : (complete > 0 ? 'inprogress' : 'zero'));
            dialog.widgets['category_status'+row.toString()].text_color = SPUI.make_colorv(dialog.data['widgets']['category_status']['text_color_'+clr]);
        }

        var white = new SPUI.Color(1,1,1,1), light_gray = new SPUI.Color(0.75, 0.75, 0.75, 1);
        if(rowdata == dialog.parent.user_data['category']) {
            dialog.widgets['category'+row.toString()].highlight_text_color = dialog.widgets['category'+row.toString()].text_color = white;
        } else {
            dialog.widgets['category'+row.toString()].highlight_text_color = light_gray;
            dialog.widgets['category'+row.toString()].text_color = SPUI.disabled_text_color;
        }

        dialog.widgets['category'+row.toString()].str = gamedata['achievement_categories'][rowdata]['ui_name'];
        dialog.widgets['category'+row.toString()].onclick = (function (_catname) { return function(w) {
            achievements_tab_set_category(dialog.parent, _catname);
        }; })(rowdata);
    } else {
        dialog.widgets['category_status'+row.toString()].show = false;
    }
}

function achievement_rowfunc(dialog, row, rowdata) {
    // blank out display if data has not been received yet
    if(dialog.parent.user_data['player_achievements'] === null) { rowdata = null; }

    dialog.widgets['ach'+row.toString()].show = (rowdata !== null);

    if(rowdata !== null) {
        achievement_widget_setup(dialog.widgets['ach'+row], rowdata, dialog.parent.user_data['player_achievements'],
                                 (dialog.parent.user_data['user_id'] == session.user_id ? player.history : null));
    }
}

function test_notify_achievements() {
    var name = null;
    for(var n in gamedata['achievements']) {
        name = n; break;
    }
    if(name) {
        notification_queue.achievements = [gamedata['achievements'][name]];
        notify_achievements();
    }
}

function notify_achievements() {
    var ach_list = notification_queue.achievements;
    if(ach_list.length < 1) { return; }
    notification_queue.achievements = [];

    ach_list.sort(compare_achievements(player.achievements));

    var dialog_data = gamedata['dialogs']['achievements_claimed'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'achievements_claimed';
    dialog.user_data['ach_list'] = ach_list;
    dialog.user_data['open_time'] = client_time;
    dialog.user_data['anim_start_time'] = -1;
    change_selection_ui(dialog); // install_child_dialog(dialog);

    dialog.widgets['close_button'].onclick =
        dialog.widgets['close_button2'].onclick = function(w) {
            var dialog = w.parent;
            if(dialog.user_data['anim_start_time'] < 0) {
                dialog.user_data['anim_start_time'] = client_time;
            }
        };

    if(get_facebook_viral('achievement_brag')) {
        dialog.widgets['inform_button'].onclick = (function (_ach) { return function(w) { invoke_achievement_brag(_ach); }; })(ach_list[0]);
    } else {
        dialog.widgets['inform_button'].show = false;
    }

    var height_bump = (ach_list.length - 1) * dialog.data['widgets']['ach']['array_offset'][1];
    dialog.widgets['inform_button'].xy = vec_add(dialog.widgets['inform_button'].xy, [0,height_bump]);
    dialog.widgets['close_button'].xy = vec_add(dialog.widgets['close_button'].xy, [0,height_bump]);
    dialog.wh = vec_add(dialog.wh, [0,height_bump]);

    dialog.ondraw = animate_notify_achievements;
    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name' + (ach_list.length > 1 ? '_multiple': '')];

    for(var i = 0; i < dialog.data['widgets']['ach']['array'][1]; i++) {
        var w = dialog.widgets['ach'+i];
        if(i < ach_list.length) {
            achievement_widget_setup(w, ach_list[i], player.achievements, null);
            SPFB.AppEvents.logEvent('UNLOCKED_ACHIEVEMENT', null, {'DESCRIPTION': ach_list[i]['name']});

        } else {
            w.show = false;
        }

        dialog.widgets['ach_glow'+i].show =
            dialog.widgets['prog_bar1'+i].show =
            dialog.widgets['prog_bar2'+i].show =
            dialog.widgets['prog_bar3'+i].show = (i < ach_list.length);

        if(i > 0) {
            // only play sounds on first widget
            dialog.widgets['prog_bar1'+i].sound_played =
                dialog.widgets['prog_bar2'+i].sound_played =
                dialog.widgets['prog_bar3'+i].sound_played = true;
        }
    }

    dialog.modal = true;
    dialog.auto_center();
    play_level_up_sound(null);
    return dialog;
}

/** @param {string} _scope to request (comma-separated list)
    @param {function()=} _cb callback to call after permissions granted */
function invoke_facebook_permissions_dialog(_scope, _cb) {
    var display_mode = gamedata['permissions_request_display']; // 'popup' or 'iframe' FB.ui mode - note that 'popup' must be triggered by a click to avoid popup blockers
    metric_event('0036_request_permission_add_scope_ingame', {'scope': _scope, 'method':'ingame', 'display':display_mode});
    SPFB.ui({'method':'permissions.request','perms':_scope, // request new permissions
             'display': display_mode},
            (function (__scope, __cb) { return function (bad_resp) {
                console.log("permissions.request returned"); console.log(bad_resp);

                // note: resp doesn't contain anything, you have to query it manually...
                SPFB.api('/me/permissions', (function (___scope, ___cb) { return function(resp) { // confirm new permissions
                    if(resp && ('data' in resp) && (resp['data'].length>=1)) {
                        var new_perms = [];
                        if('permission' in resp['data'][0]) {
                            goog.array.forEach(resp['data'], function(x) {
                                if(x['status'] == 'granted') {
                                    new_perms.push(x['permission']);
                                }
                            });
                        } else {
                            for(var n in resp['data'][0]) {
                                new_perms.push(n);
                            }
                        }
                        player.facebook_permissions = new_perms;
                        var success = player.has_facebook_permissions(___scope);
                        send_to_server.func(["INVOKE_FACEBOOK_AUTH_RESPONSE", ___scope, new_perms.join(','), success]);
                        if(success && ___cb) { ___cb(); }
                    }
                }; })(__scope, __cb));
            }; })(_scope, _cb));
}

function call_with_facebook_permissions(scope, cb) {
    if(!player.has_facebook_permissions(scope)) {
        invoke_facebook_permissions_dialog(scope, cb);
    } else {
        cb();
    }
}

function invoke_achievement_brag(ach) {
    var viral = get_facebook_viral('achievement_brag');
    if(!viral) { return; }
    if(!spin_facebook_enabled) { console.log('invoke_achievement_brag: '+ach['name']); return; }
    call_with_facebook_permissions('publish_actions', (function (_ach, _viral) { return function() { invoke_achievement_brag_with_permissions(_ach, _viral); }; })(ach, viral));
}

function invoke_achievement_brag_with_permissions(ach, viral) {
    var cb = (function () { return function(response) {
        if(!response) {
            // user cancelled
            return true;
        }
        if('post_id' in response) {
            metric_event('7290_achievement_brag_post_completed',
                         {'facebook_post_id':response['post_id']});
        }
        return true;
    }; })();

    metric_event('7280_achievement_brag_post_attempted', {'name': ach['name']});

    var link_url = 'http://apps.facebook.com/'+spin_app_namespace+'/';
    // add acquisition tracking info
    link_url += '?spin_ref=achievement_brag&spin_ref_user_id='+session.user_id.toString();

    var picture_url;
    if(('fb_open_graph' in ach) && ('s3_image' in ach['fb_open_graph'])) {
        picture_url = gamedata['virals']['common_image_path'] + ach['fb_open_graph']['s3_image'];
    } else {
        picture_url = gamedata['virals']['common_image_path'] + (('image' in viral) ? viral['image'] : gamedata['virals']['default_image']);
    }

    var props = {'method':'feed',
                 'name':viral['ui_post_headline'].replace('%PLAYER',player.facebook_name).replace('%ACHIEVEMENT',ach['ui_name']),
                 'link':link_url,
                 'picture': picture_url,
                 'ref':'cheeve',
                 'show_error': !spin_secure_mode
                };

    // props['caption'] = ach['ui_description']; // obsolete

    SPFB.ui(props, cb); // achievement brag
}

function animate_notify_achievements(dialog) {
    var ach_list = dialog.user_data['ach_list'];

    for(var i = 0; i < dialog.data['widgets']['ach']['array'][1]; i++) {
        if(i < ach_list.length) {
            for(var wtype in {'ach':1,'ach_glow':1}) {
                var fadein_time = dialog.data['widgets'][wtype]['fadein_time'];
                var fadein_start = dialog.data['widgets'][wtype]['fadein_start'];

                var t = client_time - dialog.user_data['open_time'] - fadein_start;
                var prog = clamp(t/fadein_time, 0, 1);
                if(prog >= 1 && wtype == 'ach_glow') {
                    dialog.widgets[wtype+i].alpha = dialog.data['widgets'][wtype]['alpha'] * (0.15*Math.sin(dialog.data['widgets'][wtype]['pulse_frequency']*(client_time+i*0.5)/(2*Math.PI))+0.85);
                } else {
                    dialog.widgets[wtype+i].alpha = prog * (dialog.data['widgets'][wtype]['alpha'] || 1);
                }
            }
        }
   }

    if(dialog.user_data['anim_start_time'] < 0) { return; }

    var ANIM_TIME = player.get_any_abtest_value('valentina_dialog_anim_time', gamedata['client']['valentina_dialog_anim_time']);

    var progress = clamp((client_time - dialog.user_data['anim_start_time'])/ANIM_TIME, 0, 1);
    if(ANIM_TIME < 0 || dialog.user_data['anim_start_time'] < 0) { progress = 1; }

    var bottom = desktop_dialogs['desktop_top'];
    var valentina = bottom.widgets['player_portrait'];
    if(!valentina) { progress = 1; }

    dialog.modal = 1-progress;

    if(progress >= 1) {
        close_parent_dialog(dialog.widgets['close_button']);
    } else if(progress > 0) {
        if('bg_blanker' in dialog.widgets) { dialog.widgets['bg_blanker'].show = false; }
        // zoom into valentina (actually player portrait XXX centralize this code)
        progress = 1 - progress;
        progress = Math.pow(progress,2.0);
        var scale = progress;
        // centerpoint of scale effect
        var pivot = vec_add(dialog.xy, vec_scale(0.5, dialog.wh));
        // where centerpoint is at start of animation
        var startpos = vec_add(vec_add(bottom.xy, valentina.xy), vec_scale(0.5, valentina.wh));
        // where centerpoint is at end of animation
        var endpos = pivot;
        //startpos = [0,0]; endpos = [0,0];
        var origin = vec_add(startpos, vec_scale(progress, vec_sub(endpos, startpos)));

        dialog.transform = [scale, 0,
                            0, scale,
                            origin[0] + scale*(-origin[0]), origin[1] + scale*(-origin[1])];
    }
}


function achievement_widget_setup(dialog, rowdata, player_achievements, player_history) {
    var gotten = (rowdata['name'] in player_achievements) && ('time' in player_achievements[rowdata['name']]);
    var unnerfed = gotten && ('nerf_date' in rowdata) && (player_achievements[rowdata['name']]['time'] < rowdata['nerf_date']);

    var stat_str = null, col = null;
    if(gotten) {
        var d = new Date(player_achievements[rowdata['name']]['time'] * 1000);
        var date_str = d.getUTCFullYear() + ' ' + gamedata['strings']['months_short'][d.getUTCMonth()] + ' ' + d.getUTCDate();

        stat_str = dialog.data['widgets']['achstat']['ui_name_complete'].replace('%s', date_str);
        col = dialog.data['widgets']['achstat']['text_color_complete' + (unnerfed ? '_unnerfed' : '')];
    } else if(player_history && ('ui_progress' in rowdata) && ('progress_key' in rowdata) && ('progress_goal' in rowdata)) {

        stat_str = rowdata['ui_progress'].replace('%cur', pretty_print_number(player_history[rowdata['progress_key']] || 0)).replace('%goal', pretty_print_number(rowdata['progress_goal']));
        col = dialog.data['widgets']['achstat']['text_color_progress'];
    } else if(player_history && rowdata['goal']['predicate'] == 'PLAYER_HISTORY' && rowdata['goal']['method'] == '>=' && rowdata['goal']['key'].indexOf('ai_') != 0) {
        // default parsing of PLAYER_HISTORY predicates (but not ai_xxx, since that doesn't always look good together with the ui_description)
        stat_str = dialog.data['widgets']['achstat']['ui_name_progress'].replace('%cur', pretty_print_number(player_history[rowdata['goal']['key']] || 0)).replace('%goal', pretty_print_number(rowdata['goal']['value']));
        col = dialog.data['widgets']['achstat']['text_color_progress'];
    } else {
        stat_str = dialog.data['widgets']['achstat']['ui_name_incomplete'];
        col = dialog.data['widgets']['achstat']['text_color_incomplete'];
    }

    dialog.widgets['achstat'].str = stat_str;
    if(stat_str && col) {
        dialog.widgets['achstat'].text_color = SPUI.make_colorv(col);
    }
    dialog.widgets['achname'].text_color = SPUI.make_colorv(dialog.data['widgets']['achname']['text_color' + (unnerfed ? '_complete_unnerfed' : '')]);
    dialog.widgets['achbg'].tooltip.str = rowdata['ui_tooltip'] || null;
    dialog.widgets['achname'].str = rowdata['ui_name'];
    dialog.widgets['achtext'].set_text_with_linebreaking(rowdata['ui_description']);
    dialog.widgets['achicon'].asset = rowdata['icon'];
    col = dialog.data['widgets']['achiconbg']['color_' + (gotten ? (unnerfed ? 'yes_unnerfed' : 'yes') : 'no')];
    dialog.widgets['achiconbg'].color = SPUI.make_colorv(col);
    if(('achhider') in dialog.widgets) { dialog.widgets['achhider'].show = !gotten; }
}

var ALLIANCE_LIST_SEPARATOR = 'SEPARATOR';

// here "rowdata" is just the raw alliance_id, or ALLIANCE_LIST_SEPARATOR
function alliance_list_lazy_rowfunc(dialog, row, rowdata) {
    // awkward - set visibility of header elements here
    // this should really be a sub-dialog
    for(var name in dialog.widgets) {
        if(name.indexOf("header_") === 0) {
            dialog.widgets[name].show = false;
            if(dialog.user_data['page'] === 0 && dialog.user_data['has_header']) {
                dialog.widgets[name].show = true;
                if(name.indexOf("header_expires") === 0 && !dialog.user_data['has_header_expires']) {
                    dialog.widgets[name].show = false;
                } else if(name.indexOf("header_season") === 0 && dialog.user_data['has_header_expires']) {
                    dialog.widgets[name].show = false;
                } else if(name.indexOf("header_prize") === 0 && !dialog.user_data['has_header_prize']) {
                    dialog.widgets[name].show = false;
                }
            }
        }
    }

    var d = dialog.widgets['alliances'+row];
    d.show = !!rowdata;
    d.ondraw = alliance_list_row_update;
    if(rowdata) {
        if(rowdata === ALLIANCE_LIST_SEPARATOR) {
            return alliance_list_rowfunc(dialog, row, rowdata);
        } else {
            d.user_data['alliance_id'] = rowdata;
            d.widgets['loading_spinner'].show = true;
            d.widgets['bg'].show = true;
            d.widgets['rank_bg'].show =
                d.widgets['rank_bg_shine'].show =
                d.widgets['rank'].show =
                d.widgets['name'].show =
                d.widgets['logo'].show =
                d.widgets['logo_frame'].show =
                d.widgets['join_type'].show =
                d.widgets['members'].show =
                d.widgets['separator'].show =
                d.widgets['trophy_bg'].show =
                d.widgets['trophy_shine'].show =
                d.widgets['trophy_icon'].show =
                d.widgets['trophy_amount'].show =
                d.widgets['button'].show = false;

            d.widgets['logo_frame'].onclick = d.widgets['button'].onclick = alliance_list_onclick;

            AllianceCache.query_info(rowdata, (function (_d) { return function(info) {

                if(info && (_d.user_data['alliance_id'] != info['id'])) { return; }

                _d.widgets['loading_spinner'].show = false;
                _d.widgets['name'].show =
                    _d.widgets['logo'].show =
                    _d.widgets['logo_frame'].show =
                    _d.widgets['join_type'].show =
                    _d.widgets['members'].show =
                    _d.widgets['button'].show = !!info;

                if(!info) {
                    _d.widgets['name'].show = true;
                    _d.widgets['name'].str = _d.data['widgets']['name']['ui_name_error'];
                } else {
                    var point_stat = (_d.parent ? _d.parent.user_data['point_stat'] : null);

                    _d.widgets['rank_bg'].show =
                        _d.widgets['rank_bg_shine'].show =
                        _d.widgets['rank'].show =
                        _d.widgets['trophy_bg'].show =
                        _d.widgets['trophy_shine'].show =
                        _d.widgets['trophy_icon'].show =
                        _d.widgets['trophy_amount'].show = !!point_stat;
                    if(point_stat) {
                        _d.widgets['trophy_icon'].asset = _d.parent.user_data['point_icon_asset'];
                        _d.widgets['trophy_icon'].state = _d.parent.user_data['point_icon_state'];
                        if((point_stat['name'] in info) && ((point_stat['name']+'_rank') in info)) {
                            set_rank_widget(_d, info[point_stat['name']+'_rank']+1);
                            _d.widgets['trophy_amount'].str = pretty_print_number(info[point_stat['name']]);
                        } else {
                            console.log("RANK INFO MISSING: "); console.log(info);
                        }
                    }

                    _d.widgets['name'].str = alliance_display_name(info);
                    _d.widgets['logo'].asset = get_alliance_logo_asset(info['logo'] || null);
                    _d.widgets['join_type'].str = gamedata['strings']['alliance_join_types'][info['join_type']];
                    _d.widgets['members'].str = d.data['widgets']['members']['ui_name'].replace('%d1', info['num_members'].toString()).replace('%d2', gamedata['alliances']['max_members'].toString());
                }

            }; })(d));
        }
    }
}

function alliance_display_name(info) {
    var ret = info['ui_name'];
    if(('chat_tag' in info) && info['chat_tag'].length > 0 && player.get_any_abtest_value('enable_alliance_chat_tags', gamedata['client']['enable_alliance_chat_tags'])) {
        ret += ' ['+info['chat_tag']+']';
    }
    return ret;
}

function alliance_list_onclick(w) {
    var _d = w.parent;
    alliance_list_change_tab(_d.parent.parent, 'info', _d.user_data['alliance_id']);
}

function alliance_list_row_update(dialog) {
    if(!dialog.show) { return; }
    var togo = player.current_trophy_challenge_togo();
    dialog.widgets['trophy_bg'].tooltip.str = dialog.data['widgets']['trophy_bg']['ui_tooltip' + (((togo > 0) && (togo < gamedata['client']['infinite_trophy_togo'])) ? '_togo' : '')].replace('%s', pretty_print_time_brief(togo));
    dialog.widgets['trophy_bg'].fixed_tooltip_offset = dialog.data['widgets']['trophy_bg']['fixed_tooltip_offset'+ (((togo > 0) && (togo < gamedata['client']['infinite_trophy_togo'])) ? '_togo' : '')];
}

// here "rowdata" is the full alliance info entry
function alliance_list_rowfunc(dialog, row, rowdata) {
    var d = dialog.widgets['alliances'+row];
    d.show = !!rowdata;
    d.ondraw = alliance_list_row_update;

    if(rowdata) {
        d.widgets['rank_bg'].show =
            d.widgets['rank_bg_shine'].show =
            d.widgets['rank'].show =
            d.widgets['trophy_bg'].show =
            d.widgets['trophy_shine'].show =
            d.widgets['trophy_icon'].show =
            d.widgets['trophy_amount'].show = false; // no rank display here

        d.widgets['bg'].show =
            d.widgets['name'].show =
            d.widgets['logo'].show =
            d.widgets['logo_frame'].show =
            d.widgets['join_type'].show =
            d.widgets['members'].show =
            d.widgets['button'].show = (rowdata !== ALLIANCE_LIST_SEPARATOR);

        d.widgets['separator'].show = (rowdata === ALLIANCE_LIST_SEPARATOR);

        if(rowdata === ALLIANCE_LIST_SEPARATOR) {
        } else {
            d.user_data['alliance_id'] = rowdata['id'];
            d.widgets['name'].str = alliance_display_name(rowdata);
            d.widgets['logo'].asset = get_alliance_logo_asset(rowdata['logo'] || null);
            d.widgets['join_type'].str = gamedata['strings']['alliance_join_types'][rowdata['join_type']];
            d.widgets['members'].str = d.data['widgets']['members']['ui_name'].replace('%d1', rowdata['num_members'].toString()).replace('%d2', gamedata['alliances']['max_members'].toString());
            d.widgets['logo_frame'].onclick = d.widgets['button'].onclick = alliance_list_onclick;
        }
    }
}

var tag_chars_ext =
    ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
     'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
     '0','1','2','3','4','5','6','7','8','9'];
var name_chars_ext = tag_chars_ext.concat([' ',"'"]);

/** @param {SPUI.Dialog} dialog
    @param {string} newtab
    @param {number=} info_id alliance we want to look at */
function alliance_list_change_tab(dialog, newtab, info_id) {
    if(newtab != dialog.user_data['tab']) {
        if(dialog.user_data['tab'] !== 'modify') {
            dialog.user_data['prev_tab'] = dialog.user_data['tab'];
        }
        dialog.user_data['tab'] = newtab;
    }

    var use_trophies = player.use_trophies(); // whether PvP points are enabled
    var event = player.current_alliance_stat_tournament_event(); // whether a stat tournament is going on
    var use_leaderboard = !!(use_trophies || event);

    dialog.widgets['top_tab'].show = (newtab == 'top');
    dialog.widgets['join_tab'].show = (newtab == 'join');
    dialog.widgets['create_tab'].show = (newtab == 'create' || newtab == 'modify');
    dialog.widgets['search_tab'].show = (newtab == 'search');
    dialog.widgets['search_player_tab'].show = (newtab == 'search_player');
    dialog.widgets['info_tab'].show = (newtab == 'info');
    dialog.widgets['your_tab'].show = (newtab == 'your');

    dialog.widgets['top_alliances_button'].state = (newtab == 'top' ? 'active' : 'normal');
    dialog.widgets['join_alliance_button'].state = (newtab == 'join' ? 'active' : 'normal');
    dialog.widgets['create_alliance_button'].state = (newtab == 'create' ? 'active' : 'normal');
    dialog.widgets['your_alliance_button'].state = (newtab == 'your' ? 'active' : 'normal');
    dialog.widgets['search_alliance_button'].state = (newtab == 'search' ? 'active' : 'normal');
    dialog.widgets['search_player_button'].state = (newtab == 'search_player' ? 'active' : 'normal');

    // set up back button
    dialog.widgets['back_button_bg'].show = dialog.widgets['back_button'].show = dialog.widgets['back_button_shine'].show = dialog.user_data['prev_tab'] && ((newtab == 'modify') || ((newtab == 'info')));
    if(dialog.widgets['back_button'].show) {
        dialog.widgets['back_button'].onclick = function(w) {
            var _dialog = w.parent;
            alliance_list_change_tab(_dialog, _dialog.user_data['prev_tab']);
        };
    }

    // Your Alliance/Create Alliance are mutually exclusive
    dialog.widgets['your_alliance_button'].show = session.is_in_alliance();
    dialog.widgets['create_alliance_button'].show = !dialog.widgets['your_alliance_button'].show;

    if(session.is_in_alliance()) {
        // Top Alliances/New Alliances mutually exclusive
        dialog.widgets['top_alliances_button'].show = use_leaderboard;
        dialog.widgets['join_alliance_button'].show = !use_leaderboard;
        dialog.widgets['top_alliances_button'].xy = dialog.data['widgets']['top_alliances_button']['xy'];
    } else {
        dialog.widgets['join_alliance_button'].show = true;
        // Awkwardly tack on Top Alliances at left for newbies
        dialog.widgets['top_alliances_button'].show = use_leaderboard && !dialog.widgets['back_button_bg'].show;
        dialog.widgets['top_alliances_button'].xy = dialog.data['widgets']['top_alliances_button']['xy_no_back'];
    }


    /*
    if(!session.is_in_alliance()) {
        // normal create button
        dialog.widgets['create_alliance_button'].show = true;
    } else {
        // diable create button when already in an alliance
        dialog.widgets['create_alliance_button'].state = 'disabled';
        dialog.widgets['create_alliance_button'].tooltip.str = dialog.data['widgets']['create_alliance_button']['ui_tooltip_leave_first'];
    }
    */

    if(newtab == 'top') {
        var d = dialog.widgets['top_tab'];
        d.user_data['page'] = -1;

        if((!d.user_data['rowdata'] || (d.user_data['rowdata'].length < 1)) && !d.user_data['pending']) {
            d.user_data['pending'] = true;
            d.widgets['loading_rect'].show = d.widgets['loading_text'].show = d.widgets['loading_spinner'].show = true;
            d.user_data['rows_per_page'] = d.data['widgets']['alliances']['array'][1];
            d.user_data['rowdata'] = []; // this holds the alliance ID list
            d.user_data['rowfunc'] = alliance_list_lazy_rowfunc;
            d.user_data['has_header'] = true;
            d.user_data['has_header_expires'] = false;
            d.user_data['has_header_prize'] = false;
            d.user_data['point_stat'] = null;

            var challenge, togo;
            if(event) { // stat tournament
                challenge = d.user_data['event'] = event;
                togo = player.current_alliance_stat_tournament()['end_time'] - player.get_absolute_time();
                d.user_data['point_stat'] = event['stat'];
                d.user_data['point_icon_asset'] = event['icon'];
                d.user_data['point_icon_state'] = 'icon_30x30';
                d.widgets['header_logo'].asset = event['icon'];
                d.widgets['header_logo'].state = 'normal';
            } else { // legacy PvP tournament
                var challenge_name = player.current_trophy_challenge_name();
                var trophy_type = player.current_trophy_type();
                if(!challenge_name) { throw Error('invoked alliances top_tab without a challenge or stat tournament active'); }

                challenge = d.user_data['event'] = gamedata['events'][challenge_name];
                togo = player.current_trophy_challenge_togo();
                d.user_data['point_stat'] = {'name': 'trophies_'+trophy_type,
                                             'time_scope': (trophy_type == 'pvp' ? gamedata['matchmaking']['ladder_point_frequency'] : 'week')};
                d.user_data['point_icon_asset'] = 'trophy_30x30';
                d.user_data['point_icon_state'] = trophy_type;
                d.widgets['header_logo'].state = trophy_type;
            }

            d.widgets['header_expires'].show = d.widgets['header_expires_label'].show = ((togo > 0) && (togo < gamedata['client']['infinite_trophy_togo']));
            if(d.widgets['header_expires'].show) {
                d.user_data['has_header_expires'] = true;
                d.widgets['header_expires'].str = d.data['widgets']['header_expires']['ui_name'].replace('%s', pretty_print_time_brief(togo));
            } else {
                d.widgets['header_season'].show = true;
                d.widgets['header_season'].str = d.data['widgets']['header_season']['ui_name'].replace('%s', (current_pvp_season()+gamedata['matchmaking']['season_ui_offset']).toString());
            }

            d.widgets['header_title'].str = (challenge['ui_top_alliances_header_title'] || d.data['widgets']['header_title']['ui_name']);
            d.widgets['header_title'].xy = d.data['widgets']['header_title']['xy' + (d.widgets['header_expires'].show ? '_togo' : '')];

            // PRICE
            d.widgets['header_prize_icon'].asset = player.get_any_abtest_value('gamebucks_icon_med', gamedata['store']['gamebucks_icon_med']);
            d.widgets['header_prize_icon'].tooltip.str = player.get_any_abtest_value('gamebucks_ui_name', gamedata['store']['gamebucks_ui_name']);
            d.widgets['header_img'].asset = challenge['logo'];
            var name = challenge[('ui_name_top_alliances' in challenge ? 'ui_name_top_alliances' : 'ui_name')];
            var descr;
            if(!player.is_ladder_player() && ('ui_description_nonladder' in challenge)) {
                descr = challenge['ui_description_nonladder'];
            } else {
                descr = challenge['ui_description'];
            }
            d.widgets['header_img'].tooltip.str = name + '\n\n' + descr;

            for(var i = 0; i < d.data['widgets']['header_prize_rank']['array'][1]; i++) {
                var font = SPUI.make_font(d.data['widgets']['header_prize_rank']['text_size'], d.data['widgets']['header_prize_rank']['text_size']+3, (i == 0 ? 'bold' : 'normal'));
                d.widgets['header_prize_rank'+i].font = d.widgets['header_prize_amount'+i].font = font;
                d.widgets['header_prize_rank'+i].str = d.data['widgets']['header_prize_rank']['ui_name'].replace('%d', (i+1).toString());
                d.widgets['header_prize_amount'+i].str = Store.display_user_currency_amount(Store.convert_credit_price_to_currency(challenge['prizes'][i], 'gamebucks'));
                if(challenge['prizes'][i] > 0) {
                    d.user_data['has_header_prize'] = true;
                }
                d.widgets['header_prize_rank'+i].show = d.widgets['header_prize_amount'+i].show = (challenge['prizes'][i]>0);
            }
            // hide prize-related widgets if there are no prizes
            d.widgets['header_prize_top'].show =
                d.widgets['header_prize_icon'].show = d.user_data['has_header_prize'];

            AllianceCache.query_score_leaders([d.user_data['point_stat']['name'], d.user_data['point_stat']['time_scope']], (session.alliance_id > 0), (function(_d) { return function(r) {
                var _dialog = _d.parent;
                _d.user_data['pending'] = false;
                _d.widgets['loading_rect'].show = _d.widgets['loading_text'].show = _d.widgets['loading_spinner'].show = false;

                if(!r || r.length < 1) {
                    _d.widgets['empty_results'].show = true;
                    return;
                }

                // insert a separator anywhere there is a gap in rank numbers
                for(var i = 0; i < r.length-1; i++) {
                    if(r[i+1]['rank'] > r[i]['rank']+1) {
                        r.splice(i+1, 0, ALLIANCE_LIST_SEPARATOR);
                        i++;
                    }
                }

                // insert two blanks at beginning for the header
                r.splice(0, 0, null);
                r.splice(0, 0, null);

                // insert separator at end
                if(r.length > 0 && r[r.length-1] !== ALLIANCE_LIST_SEPARATOR) {
                    r.push(ALLIANCE_LIST_SEPARATOR);
                }

                // insert ranks/scores into cache and build list for rowdata
                _d.user_data['rowdata'] = [];
                for(var i = 0; i < r.length; i++) {
                    if(r[i] === null || r[i] === ALLIANCE_LIST_SEPARATOR) {
                        _d.user_data['rowdata'].push(r[i]);
                        continue;
                    } else {
                        _d.user_data['rowdata'].push(r[i]['alliance_id']);
                        var props = {};
                        props[_d.user_data['point_stat']['name']] = r[i]['absolute'];
                        props[_d.user_data['point_stat']['name']+'_rank'] = r[i]['rank'];
                        AllianceCache.update(r[i]['alliance_id'], props);
                    }
                }

                scrollable_dialog_change_page(_d, 0);

            }; })(d));
        }

        scrollable_dialog_change_page(d, 0);
    } else if(newtab == 'join') {
        var d = dialog.widgets['join_tab'];
        d.user_data['page'] = -1;

        if((!d.user_data['rowdata'] || (d.user_data['rowdata'].length < 1)) && !d.user_data['pending']) {
            d.user_data['pending'] = true;
            d.widgets['loading_rect'].show = d.widgets['loading_text'].show = d.widgets['loading_spinner'].show = true;
            d.user_data['rows_per_page'] = d.data['widgets']['alliances']['array'][1];
            d.user_data['rowdata'] = []; // this holds the alliance ID list
            d.user_data['rowfunc'] = alliance_list_rowfunc;
            AllianceCache.query_list((function(_d) { return function(r) {
                var _dialog = _d.parent;
                _d.user_data['pending'] = false;
                _d.widgets['loading_rect'].show = _d.widgets['loading_text'].show = _d.widgets['loading_spinner'].show = false;

                // sort by open join first, then number of members (so alliances with *fewer* vacant spots appear first)
                var compare_for_list = function (a,b) {
                    if(a['join_type'] == 'anyone' && b['join_type'] != 'anyone') {
                        return -1;
                    } else if(a['join_type'] != 'anyone' && b['join_type'] == 'anyone') {
                        return 1;
                    } else if(a['num_members'] > b['num_members']) {
                        return -1;
                    } else if(a['num_members'] < b['num_members']) {
                        return 1;
                    } else {
                        return 0;
                    }
                };
                r.sort(compare_for_list);

                // add a separator on the end to emphasize that this is not a complete list
                r.push(ALLIANCE_LIST_SEPARATOR);

                // note: stashes full result, does NOT go through the global cache (should it?)
                _d.user_data['rowdata'] = r;
                scrollable_dialog_change_page(_d, 0);
            }; })(d));
        }

        scrollable_dialog_change_page(d, 0);
    } else if(newtab == 'search') {
        var d = dialog.widgets['search_tab'];
        if(!d.user_data['init']) {
            d.user_data['init'] = true;
            d.user_data['pending'] = false;
            d.user_data['page'] = -1;
            d.user_data['rows_per_page'] = d.data['widgets']['alliances']['array'][1];
            d.user_data['rowdata'] = []; // this holds the alliance ID list
            d.user_data['rowfunc'] = alliance_list_rowfunc;

            d.widgets['search_input'].allowed_chars = name_chars_ext;
            d.widgets['search_input'].ontype = function(w) {
                var _d = w.parent;
                _d.widgets['search_button'].state = (_d.user_data['pending'] || !_d.parent || !w.str || w.str.length < 1 ? 'disabled' : 'normal');
            };
            d.widgets['search_button'].state = 'disabled'; // until first character is typed
            d.widgets['likes_button'].show = (spin_frame_platform == 'fb');
            d.widgets['likes_button'].onclick = function(w) {
                w.state = (w.state == 'active' ? 'normal' : 'active');
            };

            d.widgets['search_input'].ontextready = d.widgets['search_button'].onclick = function(w) {
                var _d = w.parent;
                if(_d.user_data['pending'] || !_d.parent) { return; }
                var terms = _d.widgets['search_input'].str;
                if(!terms) {
                    return;
                    //terms = '';
                }
                _d.user_data['rowdata'] = [];
                _d.user_data['pending'] = true;
                _d.widgets['empty_results'].show = false;
                _d.widgets['search_button'].state = 'disabled';
                _d.widgets['search_input'].state = 'disabled';
                _d.widgets['search_button'].str = _d.data['widgets']['search_button']['ui_name_searching'];
                _d.widgets['loading_rect'].show = _d.widgets['loading_text'].show = _d.widgets['loading_spinner'].show = true;
                scrollable_dialog_change_page(_d, 0);

                AllianceCache.search_list(terms, (function(__d) { return function(r) {

                    // keep the dialog locked for a while longer to prevent ape-on-crack spam
                    window.setTimeout((function (___d, _r) { return function() {
                        // sort alphabetically
                        _r.sort(function (a,b) { return (a['ui_name'] > b['ui_name'] ? 1 : (a['ui_name'] < b['ui_name'] ? -1 : 0)) });
                        // note: stashes full result, does NOT go through the global cache (should it?)
                        ___d.user_data['rowdata'] = _r;

                        ___d.widgets['empty_results'].show = (_r.length < 1);

                        scrollable_dialog_change_page(___d, 0);

                        ___d.user_data['pending'] = false;
                        ___d.widgets['search_button'].state = 'normal';
                        ___d.widgets['search_input'].state = 'normal';
                        ___d.widgets['search_button'].str = ___d.data['widgets']['search_button']['ui_name'];
                        ___d.widgets['loading_rect'].show = ___d.widgets['loading_text'].show = ___d.widgets['loading_spinner'].show = false;
                    }; })(__d, r), 2000);

                }; })(_d));
            };
        }
        SPUI.set_keyboard_focus(d.widgets['search_input']);
        scrollable_dialog_change_page(d, 0);
    } else if(newtab == 'search_player') {
        var d = dialog.widgets['search_player_tab'];
        if(!d.user_data['init']) {
            d.user_data['init'] = true;
            d.user_data['pending'] = false;
            d.user_data['page'] = -1;
            d.user_data['rows_per_page'] = d.data['widgets']['players']['array'][1];
            d.user_data['rowdata'] = []; // this holds the player ID list
            d.user_data['point_stat'] = null;
            if(event) {
                d.user_data['event'] = event;
                d.user_data['event_end_time'] = player.current_alliance_stat_tournament()['end_time'];
                d.user_data['point_stat'] = event['stat'];
                d.user_data['point_icon_30x30_asset'] = dialog.user_data['point_icon_15x15_asset'] = event['icon'];
                d.user_data['point_icon_30x30_state'] = 'icon_30x30';
                d.user_data['point_icon_15x15_state'] = 'icon_15x15';
            } else {
                var trophy_type = player.current_trophy_type();
                if(trophy_type) {
                    var challenge_name = player.current_trophy_challenge_name();
                    d.user_data['event'] = gamedata['events'][challenge_name];
                    d.user_data['event_end_time'] = player.get_absolute_time() + player.current_trophy_challenge_togo();
                    d.user_data['point_stat'] = {'name': 'trophies_'+trophy_type,
                                                      'time_scope': (trophy_type == 'pvp' ? gamedata['matchmaking']['ladder_point_frequency'] : 'week')};
                    d.user_data['point_icon_30x30_asset'] = 'trophy_30x30';
                    d.user_data['point_icon_30x30_state'] = trophy_type;
                    d.user_data['point_icon_15x15_asset'] = 'trophy_15x15';
                    d.user_data['point_icon_15x15_state'] = trophy_type;
                }
            }

            d.user_data['rowfunc'] = function(dialog, row, rowdata) {
                var user_id = rowdata;
                var w = dialog.widgets['players'+row.toString()];
                w.user_data['user_id'] = user_id;
                if(user_id) {
                    w.show = true;
                    w.ondraw = alliance_info_member_row_update;

                    // hide unnecessary widgets
                    goog.array.forEach(['role_icon','manage_button'], function(wname) { w.widgets[wname].show = false; });

                    var r = w.user_data['user_info'] = PlayerCache.query_sync(user_id);
                    w.widgets['name'].str = PlayerCache.get_ui_name(r);
                    w.widgets['level'].str = w.data['widgets']['level']['ui_name'].replace('%d', (r['player_level'] || 1).toString());
                    w.widgets['portrait'].set_user(user_id);
                    w.widgets['info'].str = w.data['widgets']['info']['ui_player_id'].replace('%d', user_id.toString());
                    w.widgets['button'].show = (user_id != session.user_id); // no button for yourself
                    w.widgets['button'].str = w.data['widgets']['button']['ui_name_info'];

                    w.widgets['portrait'].onclick = w.widgets['button'].onclick = function(button) {
                        var _w = button.parent;
                        invoke_player_info_dialog_unknown(_w.user_data['user_id']);
                    };
                } else {
                    w.show = false;
                }
            };

            d.widgets['search_input'].ontype = function(w) {
                var _d = w.parent;
                _d.widgets['search_button'].state = (_d.user_data['pending'] || !_d.parent || !w.str || w.str.length < 1 ? 'disabled' : 'normal');
            };
            d.widgets['search_button'].state = 'disabled'; // until first character is typed

            d.widgets['search_input'].ontextready = d.widgets['search_button'].onclick = function(w) {
                var _d = w.parent;
                if(_d.user_data['pending'] || !_d.parent) { return; }
                var terms = _d.widgets['search_input'].str;
                if(!terms) {
                    return;
                }
                _d.user_data['rowdata'] = [];
                _d.user_data['pending'] = true;
                _d.widgets['empty_results'].show = false;
                _d.widgets['search_button'].state = 'disabled';
                _d.widgets['search_input'].state = 'disabled';
                _d.widgets['search_button'].str = _d.data['widgets']['search_button']['ui_name_searching'];
                _d.widgets['loading_rect'].show = _d.widgets['loading_text'].show = _d.widgets['loading_spinner'].show = true;
                scrollable_dialog_change_page(_d, 0);

                search_player_cache(terms, (function(__d) { return function(r) {

                    // keep the dialog locked for a while longer to prevent ape-on-crack spam
                    window.setTimeout((function (___d, _r) { return function() {
                        // sort by name (level?)
                        _r.sort(function (a,b) {
                            var na = PlayerCache.get_ui_name(PlayerCache.query_sync(a));
                            var nb = PlayerCache.get_ui_name(PlayerCache.query_sync(b));
                            if(na < nb) {
                                return -1;
                            } else if(na > nb) {
                                return 1;
                            } else {
                                return 0;
                            }
                        });

                        ___d.user_data['rowdata'] = _r;

                        ___d.widgets['empty_results'].show = (_r.length < 1);

                        scrollable_dialog_change_page(___d, 0);

                        ___d.user_data['pending'] = false;
                        ___d.widgets['search_button'].state = 'normal';
                        ___d.widgets['search_input'].state = 'normal';
                        ___d.widgets['search_button'].str = ___d.data['widgets']['search_button']['ui_name'];
                        ___d.widgets['loading_rect'].show = ___d.widgets['loading_text'].show = ___d.widgets['loading_spinner'].show = false;
                    }; })(__d, r), 2000);

                }; })(_d));
            };
        }
        SPUI.set_keyboard_focus(d.widgets['search_input']);
        scrollable_dialog_change_page(d, 0);
    } else if(newtab == 'create' || newtab == 'modify') {
        var d = dialog.widgets['create_tab'];
        if(!d.user_data['init']) {
            d.user_data['init'] = true;
            d.user_data['pending'] = false;
            d.user_data['join_type'] = 'anyone';
            d.user_data['logo'] = 'circstar'; // default alliance logo
            d.user_data['modify'] = false;
            d.user_data['changed'] = false;

            d.widgets['name_input'].allowed_chars = name_chars_ext;
            d.widgets['descr_input'].disallowed_chars =
                d.widgets['motd_input'].disallowed_chars = ['\n', '\t', '\r'];
            d.widgets['tag_input'].allowed_chars = tag_chars_ext;

            d.widgets['tag_label'].show =
                d.widgets['tag_input_bg'].show =
                d.widgets['tag_input'].show = player.get_any_abtest_value('enable_alliance_chat_tags', gamedata['client']['enable_alliance_chat_tags']);

            // pre-fill fields
            if(newtab == 'modify') {
                d.user_data['modify'] = true;
                var info = AllianceCache.query_info_sync(session.alliance_id);
                if(info) {
                    d.widgets['name_input'].str = info['ui_name'] || '';
                    d.widgets['tag_input'].str = info['chat_tag'] || '';
                    d.widgets['descr_input'].str = info['ui_description'] || '';
                    d.widgets['motd_input'].str = info['chat_motd'] || gamedata['strings']['alliance_default_chat_motd'];
                    d.user_data['logo'] = info['logo'] || null;
                    d.user_data['join_type'] = info['join_type'] || 'anyone';
                }
            } else if(newtab == 'create') {
                d.widgets['motd_input'].str = gamedata['strings']['alliance_default_chat_motd'];
            }

            d.widgets['name_input'].ontype =
                d.widgets['tag_input'].ontype =
                d.widgets['descr_input'].ontype =
                d.widgets['motd_input'].ontype =
                function(w) {
                    w.parent.user_data['changed'] = true;
                    // enable "edit/create" button
                    alliance_list_create_tab_update_create_button(d);
                };

            for(var i = 0; i < d.data['widgets']['join_type_choice']['array'][0]; i++) {
                var w = d.widgets['join_type_choice'+i.toString()];
                var mytype = d.data['widgets']['join_type_choice']['join_types'][i];
                w.str = gamedata['strings']['alliance_join_types'][mytype];
                w.tooltip.str = gamedata['strings']['alliance_join_type_tips'][mytype];
                w.state = (mytype==d.user_data['join_type'] ? 'active' : 'normal');
                w.onclick = (function (_i) { return function(_w) {
                    var d = _w.parent;
                    d.user_data['changed'] = true;
                    d.user_data['join_type'] = d.data['widgets']['join_type_choice']['join_types'][_i];
                    for(var j = 0; j < d.data['widgets']['join_type_choice']['array'][0]; j++) {
                        d.widgets['join_type_choice'+j.toString()].state = (d.data['widgets']['join_type_choice']['join_types'][j] == d.user_data['join_type'] ? 'active' : 'normal');
                    }
                    // enable "edit/create" button
                    alliance_list_create_tab_update_create_button(d);
                }; })(i);
            }

            d.widgets['logo_button'].onclick =
                d.widgets['logo_frame'].onclick =
                function(w) { invoke_alliance_logo_chooser(w.parent, w.parent.user_data['logo']); };
        }

        d.widgets['logo'].asset = get_alliance_logo_asset(d.user_data['logo'] || null);

        SPUI.set_keyboard_focus(d.widgets['name_input']);
        alliance_list_create_tab_update_create_button(d);

    } else if(newtab == 'info') {
        var d = dialog.widgets['info_tab'];
        if(info_id) {
            // the info_id passed in may be undefined if we are returning from a child tab
            init_alliance_info_tab(d, info_id);
        }
    } else if(newtab == 'your') {
        init_alliance_info_tab(dialog.widgets['your_tab'], session.alliance_id);
    }
}

// GUI code is annoying :P - this function exists only to update the state of the "Create" button and its price display
function alliance_list_create_tab_update_create_button(d) {
        var spell = gamedata['spells'][(d.user_data['modify'] ? 'ALLIANCE_MODIFY' : 'ALLIANCE_CREATE')];
        var res = null;
        for(var r in spell['price']) { res = r; } // XXX hard-coded for one resource
        d.widgets['price_display'].str = pretty_print_number(spell['price'][res]);

        var pred = read_predicate({'predicate':'LIBRARY','name':'alliance_create_requirement'});
        var pred_ok = pred.is_satisfied(player, null);

        d.widgets['create_button'].str = d.data['widgets']['create_button']['ui_name'+(d.user_data['modify'] ? '_modify' : '')];
        d.widgets['tag_instructions'].show = false;

        if(!pred_ok) {
            d.widgets['create_button'].state = 'disabled_clickable';
            d.widgets['create_button'].tooltip.str = d.data['widgets']['create_button']['ui_tooltip_unmet_requirement'].replace('%s',pred.ui_describe(player));
            d.widgets['create_button'].onclick = get_requirements_help(pred, null);
        } else if(!d.user_data['modify'] && gamedata['spells']['ALLIANCE_LEAVE']['cooldown'] > 0 && player.cooldown_active(gamedata['spells']['ALLIANCE_LEAVE']['cooldown_name'])) {
            d.widgets['create_button'].state = 'disabled';
            d.widgets['create_button'].tooltip.str = d.data['widgets']['create_button']['ui_tooltip_on_cooldown'].replace('%s', pretty_print_time(player.cooldown_togo(gamedata['spells']['ALLIANCE_LEAVE']['cooldown_name'])));
        } else if(d.widgets['tag_input'].show && d.widgets['tag_input'].str.length != 3) {
            d.widgets['create_button'].state = 'disabled';
            d.widgets['create_button'].tooltip.str = d.data['widgets']['create_button']['ui_tooltip_tag_missing'];
            d.widgets['tag_instructions'].show = true;
        } else if(player.resource_state[res][1] < spell['price'][res]) {
            d.widgets['create_button'].state = 'disabled_clickable';
            d.widgets['create_button'].tooltip.str = d.data['widgets']['create_button']['ui_tooltip_insuf'];
            d.widgets['create_button'].onclick = get_requirements_help(res, spell['price'][res] - player.resource_state[res][1]);
        } else {
            d.widgets['create_button'].state = 'normal';
            d.widgets['create_button'].tooltip.str = null;
                d.widgets['create_button'].onclick = function(w) {
                    var d = w.parent;
                    d.widgets['create_button'].state = 'disabled';
                    d.widgets['loading_rect'].show = d.widgets['loading_text'].show = d.widgets['loading_spinner'].show = true;
                    d.widgets['loading_text'].str = d.data['widgets']['loading_text']['ui_name'+(d.user_data['modify'] ? '_modify': '')];

                    var props = {'ui_name': d.widgets['name_input'].str,
                                 'chat_tag': d.widgets['tag_input'].str,
                                 'ui_descr': d.widgets['descr_input'].str,
                                 'chat_motd': d.widgets['motd_input'].str,
                                 'join_type': d.user_data['join_type'],
                                 'logo': d.user_data['logo'] };

                    var callback = (function (_d) { return function(new_id) {
                        _d.user_data['pending'] = false;
                        _d.widgets['loading_rect'].show = _d.widgets['loading_text'].show = _d.widgets['loading_spinner'].show = false;
                        if(new_id > 0) {
                            // creation/modification successful
                            change_selection_ui(null);
                            notification_queue.push_with_priority((function (_new_id) { return function() {
                                invoke_alliance_info(_new_id);
                            }; })(new_id), -3);
                        } else {
                            // failure, reinitialize dialog tab
                            if(_d.parent) {
                                alliance_list_change_tab(_d.parent, _d.parent.user_data['tab']);
                            }
                        }
                    }; })(d);

                    if(d.user_data['modify']) {
                        AllianceCache.send_modify(props, callback);
                    } else {
                        AllianceCache.send_create(props, callback);
                    }
                }
        }
}

function invoke_alliance_logo_chooser(parent, preselect) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['alliance_logo_chooser']);
    dialog.user_data['dialog'] = 'alliance_logo_chooser';
    dialog.user_data['logo'] = preselect;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['logo']['array'][0]*dialog.data['widgets']['logo']['array'][1];
    dialog.user_data['rowfunc'] = alliance_logo_chooser_rowfunc;
    dialog.user_data['rowdata'] = [];
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    for(var asset in GameArt.assets) {
        if(asset.indexOf('alicon_') !== 0) { continue; }
        var name = asset.slice('alicon_'.length);
        dialog.user_data['rowdata'].push(name);
    }
    scrollable_dialog_change_page(dialog, 0);
    return dialog;
}
function alliance_logo_chooser_rowfunc(dialog, row, name) {
    var x = row % dialog.data['widgets']['logo']['array'][0], y = Math.floor(row / dialog.data['widgets']['logo']['array'][0]);
    var wcoord = x.toString()+','+y.toString();
    var wname = 'logo'+wcoord;
    var w = dialog.widgets[wname];
    var fw = dialog.widgets['logo_frame'+wcoord];
    w.show = fw.show = !!name;

    if(w.show) {
        w.asset = get_alliance_logo_asset(name);
        fw.onclick = (function (_name) { return function(w) {
            var _dialog = w.parent;
            _dialog.user_data['logo'] = _name;
            if(_dialog.parent) {
                _dialog.parent.widgets['create_tab'].user_data['logo'] = _dialog.user_data['logo'];
                _dialog.parent.widgets['create_tab'].user_data['changed'] = true;
                alliance_list_change_tab(_dialog.parent, _dialog.parent.user_data['tab']);
            }
            close_parent_dialog(w);
        }; })(name);
    }
}

player.get_gift_order_candidates = function() {
    var ret = [];
    goog.array.forEach(player.friends, function(fr) {
        if(fr.is_real_friend) {
            ret.push({'user_id':fr.user_id,'facebook_id':fr.get_facebook_id(),'player_level':fr.get_player_level(),'ui_name':fr.get_ui_name()});
        }
    });
    return ret;
}

function invoke_choose_gift_order_dialog(parent, candidate_list) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['choose_gift_order_dialog']);
    dialog.user_data['dialog'] = 'choose_gift_order_dialog';
    dialog.user_data['parent'] = parent;
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['portrait']['array'][1];
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    // build list of friends/alliancemates
    dialog.user_data['rowdata'] = [];
    dialog.user_data['rowdata'] = dialog.user_data['rowdata'].concat(candidate_list);

    // sort alphabetically
    dialog.user_data['rowdata'].sort(function (a,b) {
        var na = a['ui_name'];
        var nb = b['ui_name'];
        if(na < nb) {
            return -1;
        } else if(na > nb) {
            return 1;
        } else {
            return 0;
        }
    });
    dialog.user_data['rowfunc'] = choose_gift_order_dialog_setup_row;
    scrollable_dialog_change_page(dialog, 0);
    return dialog;
}

function choose_gift_order_dialog_setup_row(dialog, row, rowdata) {
    dialog.widgets['separator'+(row+1)].show =
        dialog.widgets['portrait'+row].show =
        dialog.widgets['name'+row].show =
        dialog.widgets['button'+row].show = (rowdata !== null);
    if(rowdata !== null) {
        dialog.widgets['portrait'+row].set_user(rowdata['user_id']);

        dialog.widgets['name'+row].str = dialog.data['widgets']['name']['ui_name'].replace('%s', rowdata['ui_name']).replace('%d', rowdata['player_level'].toString());
        dialog.widgets['button'+row].onclick = (function (_rowdata) { return function(w) {
            var buy_dialog = w.parent.user_data['parent'];
            close_parent_dialog(w);
            buy_dialog.user_data['gift_order'] = {'gifts': [{'recipient_user_id':_rowdata['user_id'],
                                                             'recipient_facebook_id':_rowdata['facebook_id'],
                                                             'recipient_player_level':_rowdata['player_level'],
                                                             'recipient_ui_name':_rowdata['ui_name']}] };
        }; })(rowdata);
    }
}

function invoke_confirm_gift_order_dialog(gift_order, go_cb) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['confirm_gift_order_dialog']);
    dialog.user_data['dialog'] = 'you_sent_gift_order_dialog';
    dialog.user_data['go_cb'] = go_cb;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var entry = gift_order['gifts'][0];

    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name'].replace('%s', entry['recipient_ui_name']).replace('%GAMEBUCKS_NAME', player.get_any_abtest_value('gamebucks_ui_name', gamedata['store']['gamebucks_ui_name']));
    dialog.widgets['friend_icon'].set_user(entry['recipient_user_id']);
    dialog.widgets['player_id'].str = dialog.data['widgets']['player_id']['ui_name'].replace('%d',entry['recipient_user_id'].toString());
    dialog.widgets['gamebucks_icon'].asset = player.get_any_abtest_value('gamebucks_icon_med', gamedata['store']['gamebucks_icon_med']);
    dialog.widgets['gamebucks_amount'].str = Store.display_user_currency_amount(entry['gamebucks'], 'normal');
    dialog.widgets['cancel_button'].onclick = dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['ok_button'].onclick = function(w) { var cb = w.parent.user_data['go_cb']; close_parent_dialog(w); cb(); };
    return dialog;
}

function invoke_you_sent_gift_order_dialog(gift_order) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['you_sent_gift_order_dialog']);
    dialog.user_data['dialog'] = 'you_sent_gift_order_dialog';
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var entry = gift_order['gifts'][0];

    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name'].replace('%s', entry['recipient_ui_name']);
    dialog.widgets['friend_icon'].set_user(entry['recipient_user_id']);
    dialog.widgets['player_id'].str = dialog.data['widgets']['player_id']['ui_name'].replace('%d',entry['recipient_user_id'].toString());
    dialog.widgets['gamebucks_icon'].asset = player.get_any_abtest_value('gamebucks_icon_med', gamedata['store']['gamebucks_icon_med']);
    dialog.widgets['gamebucks_amount'].str = Store.display_user_currency_amount(entry['gamebucks'], 'normal');
    dialog.widgets['ok_button'].onclick = close_parent_dialog;
    return dialog;
}

function invoke_alliance_join_request(user_id) {
    var info = PlayerCache.query_sync(user_id);
    if(!info) { return null; }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['alliance_join_request_dialog']);
    dialog.user_data['dialog'] = 'alliance_join_request_dialog';
    dialog.user_data['user_id'] = user_id;
    dialog.user_data['user_info'] = info;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var ui_name = PlayerCache.get_ui_name(info);
    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name'].replace('%s', ui_name);
    dialog.widgets['description'].str = dialog.data['widgets']['description']['ui_name'].replace('%s', ui_name);
    dialog.widgets['friend_icon'].set_user(user_id);
    dialog.widgets['friend_icon'].onclick = (function (_user_id) { return function(w) { invoke_player_info_dialog_unknown(_user_id); }; })(user_id);

    // trophy query
    var trophy_type = player.current_trophy_type();
    if(trophy_type) {
        var trophy_freq = (trophy_type == 'pvp' ? gamedata['matchmaking']['ladder_point_frequency'] : 'week');
        dialog.widgets['trophy_icon'].show = dialog.widgets['trophy_spinner'].show = true;
        dialog.widgets['trophy_icon'].state = trophy_type;
        query_player_scores([user_id], [['trophies_'+trophy_type, trophy_freq]], (function (_dialog, _trophy_type) { return function(user_ids, data) {
            if(!_dialog.parent) { return; }
            _dialog.widgets['trophy_spinner'].show = false;
            _dialog.widgets['trophy_count'].show = true;
            var count = 0;
            if(data[0][0]) { count = data[0][0]['absolute']; }
            _dialog.widgets['trophy_count'].str = pretty_print_number(display_trophy_count(count, _trophy_type));
        }; })(dialog, trophy_type));
    }

    // tournament stat query
    var event = player.current_alliance_stat_tournament_event();
    if(event) {
        dialog.widgets['stat_icon'].asset = event['icon'];
        dialog.widgets['stat_icon'].show = dialog.widgets['stat_spinner'].show = true;
        query_player_scores([user_id], [[event['stat']['name'], event['stat']['time_scope']]], (function (_dialog) { return function(user_ids, data) {
            if(!_dialog.parent) { return; }
            _dialog.widgets['stat_spinner'].show = false;
            _dialog.widgets['stat_count'].show = true;
            var count = 0;
            if(data[0][0]) { count = data[0][0]['absolute']; }
            _dialog.widgets['stat_count'].str = pretty_print_qty_brief(count);
        }; })(dialog));
    }

    if(info['home_region'] && info['home_region'] in gamedata['regions'] && session.region.data &&
       session.region.data['id'] != info['home_region'] &&
       'requires' in gamedata['regions'][info['home_region']] &&
       !read_predicate(gamedata['regions'][info['home_region']]['requires']).is_satisfied(player, null)) {
        dialog.widgets['region_lock_warning'].show = true;
    }

    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['accept_button'].onclick = function(w) {
        AllianceCache.ack_join_request(session.alliance_id, w.parent.user_data['user_id'], true, function() {});
        GameArt.assets["success_playful_22"].states['normal'].audio.play(client_time);
        close_parent_dialog(w);
    };
    dialog.widgets['reject_button'].onclick = function(w) {
        AllianceCache.ack_join_request(session.alliance_id, w.parent.user_data['user_id'], false, function() {});
        close_parent_dialog(w);
    };
    return dialog;
}

function _invoke_alliance_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['alliance_list_dialog']);
    dialog.user_data['dialog'] = 'alliance_list_dialog';
    dialog.user_data['tab'] = null;
    dialog.user_data['prev_tab'] = null;
    //change_selection_ui(dialog);
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['top_alliances_button'].onclick = function (w) { alliance_list_change_tab(w.parent, 'top'); };
    dialog.widgets['join_alliance_button'].onclick = function (w) { alliance_list_change_tab(w.parent, 'join'); };
    dialog.widgets['join_alliance_button'].str = dialog.data['widgets']['join_alliance_button']['ui_name_'+(session.is_in_alliance() ? 'in_alliance':'no_alliance')];
    dialog.widgets['create_alliance_button'].onclick = function (w) { alliance_list_change_tab(w.parent, 'create'); };
    dialog.widgets['your_alliance_button'].onclick = function (w) { alliance_list_change_tab(w.parent, 'your'); };
    dialog.widgets['search_alliance_button'].onclick = function (w) { alliance_list_change_tab(w.parent, 'search'); };
    dialog.widgets['search_player_button'].onclick = function (w) { alliance_list_change_tab(w.parent, 'search_player'); };
    dialog.widgets['search_player_button'].show = player.get_any_abtest_value('enable_player_search', gamedata['enable_player_search'] || false);

    return dialog;
}

function invoke_alliance_dialog() {
    if(session.is_in_alliance()) {
        return invoke_alliance_info(session.alliance_id);
    } else {
        return invoke_alliance_list();
    }
}

function invoke_alliance_list() {
    var dialog = _invoke_alliance_dialog();
    var default_tab;
    if(session.is_in_alliance()) {
        default_tab = 'your';
    } else {
        if(player.use_trophies() || player.current_alliance_stat_tournament_event()) {
            default_tab = 'top';
        } else {
            default_tab = 'join';
        }
    }
    alliance_list_change_tab(dialog, default_tab);
    return dialog;
}

function invoke_alliance_info(alliance_id) {
    if(alliance_id <= 0) { return null; }
    var dialog = _invoke_alliance_dialog();
    alliance_list_change_tab(dialog, (alliance_id == session.alliance_id ? 'your' : 'info'), alliance_id);
    return dialog;
}

function init_alliance_info_tab(dialog, alliance_id) {
    dialog.user_data['alliance_id'] = alliance_id;
    dialog.user_data['rowdata'] = []; // this holds the alliance member list, sorted in display order
    dialog.user_data['rowdata_role_first'] = []; // this holds the alliance member list, sorted by rank then trophy count
    dialog.user_data['rowdata_overall'] = []; // this holds the alliance member list, sorted purely by trophy count
    dialog.user_data['page'] = -1;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['members']['array'][1];
    dialog.user_data['rowfunc'] = alliance_info_member_rowfunc;
    dialog.user_data['open_time'] = client_time;
    dialog.user_data['needs_sort'] = false;
    dialog.user_data['alliance_points'] = -1;
    dialog.user_data['event'] = null;
    dialog.user_data['point_stat'] = null;
    dialog.user_data['event_end_time'] = -1;

    var event = player.current_alliance_stat_tournament_event();
    if(event) {
        dialog.user_data['event'] = event;
        dialog.user_data['event_end_time'] = player.current_alliance_stat_tournament()['end_time'];
        dialog.user_data['point_stat'] = event['stat'];
        dialog.user_data['point_icon_30x30_asset'] = dialog.user_data['point_icon_15x15_asset'] = event['icon'];
        dialog.user_data['point_icon_30x30_state'] = 'icon_30x30';
        dialog.user_data['point_icon_15x15_state'] = 'icon_15x15';
    } else {
        var trophy_type = player.current_trophy_type();
        if(trophy_type) {
            var challenge_name = player.current_trophy_challenge_name();
            dialog.user_data['event'] = gamedata['events'][challenge_name];
            dialog.user_data['event_end_time'] = player.get_absolute_time() + player.current_trophy_challenge_togo();
            dialog.user_data['point_stat'] = {'name': 'trophies_'+trophy_type,
                                              'time_scope': (trophy_type == 'pvp' ? gamedata['matchmaking']['ladder_point_frequency'] : 'week')};
            dialog.user_data['point_icon_30x30_asset'] = 'trophy_30x30';
            dialog.user_data['point_icon_30x30_state'] = trophy_type;
            dialog.user_data['point_icon_15x15_asset'] = 'trophy_15x15';
            dialog.user_data['point_icon_15x15_state'] = trophy_type;
        }
    }

    dialog.ondraw = resort_alliance_info_tab;
    update_alliance_info_tab(dialog);
}

function resort_alliance_info_tab(dialog) {
    var trophy_type = dialog.user_data['trophy_type'];

    if(dialog.user_data['needs_sort']) {
        var alliance_info = AllianceCache.query_info_sync(dialog.user_data['alliance_id']);
        if(alliance_info) {
            dialog.user_data['needs_sort'] = false;

            // sort member list:
            // 0) if no cache entry, put player at bottom

            // IF NEW ROLE GUI IS ON:
            // 1) higher role first
            // 2) higher trophies first

            // IF NEW ROLE GUI IS OFF:
            // 1/2) by trophies, if enabled, otherwise higher role first

            // 3) higher level first
            // 4) alphabetical by name

            var compare_members = function (_stat_name, _by_role_first) { return function (a_mem,b_mem) {
                var a = a_mem['user_id'], b = b_mem['user_id'];
                var a_info = PlayerCache.query_sync(a), b_info = PlayerCache.query_sync(b);

                // sort by role BEFORE trophies if new GUI is enabled
                if(_by_role_first) {
                    var a_role = (a_mem['role']||0), b_role = (b_mem['role']||0);
                    if(a_role > b_role) {
                        return -1;
                    } else if(a_role < b_role) {
                        return 1;
                    }
                }

                if(!a_info && !b_info) {
                    return 0;
                }
                if(a_info && !b_info) {
                    return -1;
                } else if(!a_info && b_info) {
                    return 1;
                }

                if(_stat_name) {
                    var at = (_stat_name in a_info ? a_info[_stat_name] : 0), bt = (_stat_name in b_info ? b_info[_stat_name] : 0);
                    if(at > bt) {
                        return -1;
                    } else if(at < bt) {
                        return 1;
                    }
                } else {
                    var a_role = (a_mem['role']||0), b_role = (b_mem['role']||0);
                    if(a_role > b_role) {
                        return -1;
                    } else if(a_role < b_role) {
                        return 1;
                    }
                }

                var alvl = a_info['player_level'] || 1, blvl = b_info['player_level'] || 1;
                if(alvl > blvl) {
                    return -1;
                } else if(alvl < blvl) {
                    return 1;
                }

                var aname = PlayerCache.get_ui_name(a_info);
                var bname = PlayerCache.get_ui_name(b_info);
                if(aname > bname) {
                    return 1;
                } else if(aname < bname) {
                    return -1;
                }
                return 0;
            }; };

            // sort the member list TWICE!

            // first, sort a copy with role first, then trophy count
            dialog.user_data['rowdata_role_first'] = dialog.user_data['rowdata'].slice();
            dialog.user_data['rowdata_role_first'].sort(compare_members(dialog.user_data['point_stat'] ? dialog.user_data['point_stat']['name'] : null, true));

            // then, sort a copy purely with trophy count, disregarding roles
            // (we need this to determine overvall ranks)
            dialog.user_data['rowdata_overall'] = dialog.user_data['rowdata'].slice();
            dialog.user_data['rowdata_overall'].sort(compare_members(dialog.user_data['point_stat'] ? dialog.user_data['point_stat']['name'] : null, false));

            // which one to display depends on the alliance role GUI setting
            dialog.user_data['rowdata'] = dialog.user_data[(player.get_any_abtest_value('enable_alliance_role_gui', gamedata['client']['enable_alliance_role_gui']) ? 'rowdata_role_first' : 'rowdata_overall')];
        }
    }

    // stuff ranks into PlayerCache
    // also compute alliance trophy count
    if(dialog.user_data['point_stat'] && (dialog.user_data['rowdata'].length > 0)) {
        var total = 0;
        var table = gamedata['alliances']['trophy_weights'];

        for(var i = 0; i < dialog.user_data['rowdata_overall'].length; i++) {
            var user_id = dialog.user_data['rowdata_overall'][i]['user_id'];
            var info = PlayerCache.query_sync(user_id);
            var count = ((info && (dialog.user_data['point_stat']['name'] in info)) ? info[dialog.user_data['point_stat']['name']] : 0);
            if(i < table.length) {
                total += table[i] * (dialog.user_data['point_stat']['name'].indexOf('trophies_') == 0 ? display_trophy_count(count, dialog.user_data['point_stat']['name'].split('_')[1]) : count);
            }
            var props = {};
            props['_client_alliance_rank_'+dialog.user_data['point_stat']['name']] = i;
            PlayerCache.update(user_id, props);
        }
        total = Math.floor(total);
        dialog.user_data['alliance_points'] = total;

        // compute trophy ranks within roles
        var last_role = -1, last_count = 0, rank_within_role = 0;
        for(var i = 0; i < dialog.user_data['rowdata_role_first'].length; i++) {
            var mem = dialog.user_data['rowdata_role_first'][i];
            var user_id = mem['user_id'];
            var role = mem['role']||0;
            var props = {};
            var info = PlayerCache.query_sync(user_id);
            var count = ((info && (dialog.user_data['point_stat']['name'] in info)) ? info[dialog.user_data['point_stat']['name']] : 0);
            if(role != last_role) {
                rank_within_role = 0;
                last_count = 0;
            } else if(count == last_count) {
                // tie, do not increment rank_within_role
            } else {
                rank_within_role += 1;
            }
            // NOTE! rank_within_role can have duplicates due to the "tying" logic above!
            props['_client_alliance_rank_within_role_'+dialog.user_data['point_stat']['name']] = rank_within_role;
            PlayerCache.update(user_id, props);
            last_role = role;
            last_count = count;
        }

        dialog.widgets['points_label'].show = dialog.widgets['points_icon'].show = dialog.widgets['points'].show = true;
        dialog.widgets['points_icon'].asset = dialog.user_data['point_icon_15x15_asset'];
        dialog.widgets['points_icon'].state = dialog.user_data['point_icon_15x15_state'];
        dialog.widgets['points'].str = pretty_print_number(total);

        var togo = (dialog.user_data['event_end_time'] > 0 ? dialog.user_data['event_end_time'] - player.get_absolute_time() : -1);
        dialog.widgets['points_label'].tooltip.str = dialog.data['widgets']['points_label']['ui_tooltip'];
        if(togo > 0 && togo < gamedata['client']['infinite_trophy_togo']) {
            dialog.widgets['points_label'].tooltip.str += dialog.data['widgets']['points_label']['ui_tooltip_togo'].replace('%s', pretty_print_time_brief(togo));
        }
    }

    scrollable_dialog_change_page(dialog, dialog.user_data['page']);
}

function update_alliance_info_tab(dialog) {
    var alliance_id = dialog.user_data['alliance_id'];

    dialog.widgets['loading_rect'].show = dialog.widgets['loading_text'].show = dialog.widgets['loading_spinner'].show = true;
    dialog.widgets['join_button'].show = dialog.widgets['leave_button'].show = dialog.widgets['edit_button'].show = false;

    dialog.widgets['points_label'].show = dialog.widgets['points_icon'].show = dialog.widgets['points'].show = false;

    dialog.user_data['rowdata'] = []; // clear member list
    scrollable_dialog_change_page(dialog, 0);

    // force refresh on next query
    //AllianceCache.invalidate(alliance_id);

    AllianceCache.query_info(alliance_id, (function (_dialog) { return function(r) {
        if(!r || !('num_members' in r) || !('join_type' in r)) {
            // handle invalid alliance
            _dialog.widgets['alliance_name'].str = _dialog.data['widgets']['alliance_name']['ui_name_invalid'];
            _dialog.widgets['loading_rect'].show = _dialog.widgets['loading_text'].show = _dialog.widgets['loading_spinner'].show = false;
            return;
        }

        if('ui_name' in r) {
            _dialog.widgets['alliance_name'].str = alliance_display_name(r);
        }

        _dialog.widgets['alliance_logo'].asset = get_alliance_logo_asset(r['logo'] || null);
        if('ui_description' in r) { _dialog.widgets['alliance_description'].set_text_with_linebreaking(r['ui_description']); }
        if('num_members' in r) { _dialog.widgets['num_members'].str = r['num_members'].toString() + '/' + gamedata['alliances']['max_members'].toString(); }

        // start loading the alliance member info
        var join_type = r['join_type'];
        _dialog.user_data['join_type'] = join_type;
        var join_type_str = gamedata['strings']['alliance_join_types'][join_type];
        _dialog.widgets['join_type'].str = _dialog.data['widgets']['join_type']['ui_name'] + join_type_str;

        var check_for_invite = (!session.is_in_alliance() && join_type == 'invite_only');

        AllianceCache.query_members(_dialog.user_data['alliance_id'], check_for_invite,
                                    (_dialog.user_data['point_stat'] ? [[_dialog.user_data['point_stat']['name'],_dialog.user_data['point_stat']['time_scope']]] : null),
              (function (__dialog) { return function(info) {
                __dialog.widgets['loading_rect'].show = __dialog.widgets['loading_text'].show = __dialog.widgets['loading_spinner'].show = false;
                if(!info || !info['members']) { return; }

                // set up leave/join button
                if(session.alliance_id == alliance_id) {
                    __dialog.widgets['leave_button'].show = true;
                    var is_leader = session.check_alliance_perm('leader');
                    var is_last_member = (info['members'].length <= 1);
                    __dialog.widgets['leave_button'].str = __dialog.data['widgets']['leave_button']['ui_name'+(is_last_member ? '_disband':'')];
                    __dialog.widgets['leave_button'].onclick = (function (_alliance_id, _ui_name, _is_last_member, _is_leader) { return function(w) {
                        var s = gamedata['strings'][(_is_last_member ? 'disband_alliance_confirm' : (_is_leader ? 'leave_alliance_leader_confirm' : 'leave_alliance_confirm'))];
                        invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%s', _ui_name),
                                        {'dialog':'message_dialog_big',
                                         'cancel_button': true,
                                         'ok_button_ui_name': gamedata['dialogs']['alliance_info_tab']['widgets']['leave_button']['ui_name'+(_is_last_member ? '_disband':'')],
                                         'on_ok': (function (_w, __alliance_id) { return function() {
                                             _w.state = 'disabled';
                                             _w.parent.widgets['loading_text'].show = _w.parent.widgets['loading_rect'].show = _w.parent.widgets['loading_spinner'].show = true;
                                             send_to_server.func(["ALLIANCE_LEAVE", __alliance_id]);
                                         }; })(w, _alliance_id)
                                        }
                                                   );
                    }; })(info['id'], info['ui_name'], is_last_member, is_leader);

                    __dialog.widgets['edit_button'].show = true;
                    __dialog.widgets['edit_button'].state = (session.check_alliance_perm('admin') ? 'normal' : 'disabled');
                    __dialog.widgets['edit_button'].tooltip.str = (session.check_alliance_perm('admin') ? null : gamedata['dialogs']['alliance_member_row']['widgets']['manage_button']['ui_tooltip_no_permission']);

                    if(session.check_alliance_perm('admin')) {
                        __dialog.widgets['edit_button'].onclick = function(w) {
                            alliance_list_change_tab(w.parent.parent, 'modify');
                        };
                    }

                } else {
                    __dialog.widgets['join_button'].show = true;
                    __dialog.widgets['join_button'].state = 'normal';
                    __dialog.widgets['join_button'].onclick = null;
                    __dialog.widgets['join_button'].str = __dialog.data['widgets']['join_button']['ui_name'];
                    __dialog.widgets['join_button'].tooltip.str = __dialog.data['widgets']['join_button']['ui_tooltip'];

                    var join_cb = null;

                    if(info['num_members'] >= gamedata['alliances']['max_members']) {
                        __dialog.widgets['join_button'].state = 'disabled';
                        __dialog.widgets['join_button'].tooltip.str = __dialog.data['widgets']['join_button']['ui_tooltip_full'];
                    } else if(session.is_in_alliance()) {
                        __dialog.widgets['join_button'].state = 'disabled';
                        __dialog.widgets['join_button'].tooltip.str = _dialog.data['widgets']['join_button']['ui_tooltip_leave_first'];
                    } else if(!read_predicate({'predicate':'LIBRARY','name':'alliance_join_requirement'}).is_satisfied(player,null)) {
                        var pred = read_predicate({'predicate':'LIBRARY','name':'alliance_join_requirement'});
                        __dialog.widgets['join_button'].state = 'disabled_clickable';
                        __dialog.widgets['join_button'].tooltip.str = _dialog.data['widgets']['join_button']['ui_tooltip_unmet_requirement'].replace('%s', pred.ui_describe(player));
                        __dialog.widgets['join_button'].onclick = get_requirements_help(pred, null);
                    } else if(gamedata['spells']['ALLIANCE_LEAVE']['cooldown'] > 0 && player.cooldown_active(gamedata['spells']['ALLIANCE_LEAVE']['cooldown_name'])) {
                        __dialog.widgets['join_button'].state = 'disabled';
                        __dialog.widgets['join_button'].tooltip.str = _dialog.data['widgets']['join_button']['ui_tooltip_on_cooldown'].replace('%s', pretty_print_time(player.cooldown_togo(gamedata['spells']['ALLIANCE_LEAVE']['cooldown_name'])));
                    } else if(__dialog.user_data['join_type'] == 'anyone' || info['invite_status']) {
                        join_cb = (function (w, _alliance_id, _ui_name) { return function() {
                            var s = gamedata['strings']['join_alliance_confirm'];
                            invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%s', _ui_name),
                                                        {'cancel_button': true,
                                                         'ok_button_ui_name': gamedata['dialogs']['alliance_info_tab']['widgets']['join_button']['ui_name'],
                                                         'on_ok': (function (_w, __alliance_id) { return function() {
                                                             invoke_ui_locker();
                                                             send_to_server.func(["ALLIANCE_JOIN", __alliance_id]);
                                                         }; })(w, _alliance_id)
                                                        }
                                                       );
                        }; })(__dialog.widgets['join_button'], info['id'], info['ui_name']);
                    } else if(__dialog.user_data['join_type'] == 'invite_only' && player.cooldown_active('alliance_join_request:'+info['id'].toString())) {
                        __dialog.widgets['join_button'].state = 'disabled';
                        __dialog.widgets['join_button'].str = __dialog.data['widgets']['join_button']['ui_name_request_sent'];
                        __dialog.widgets['join_button'].tooltip.str = __dialog.data['widgets']['join_button']['ui_tooltip_request_sent'];
                    } else if(__dialog.user_data['join_type'] == 'invite_only') {
                        join_cb = (function (w, _alliance_id, _ui_name) { return function() {
                            var s = gamedata['strings']['send_alliance_join_request_confirm'];
                            invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%s', _ui_name),
                                                        {'cancel_button': true,
                                                         'ok_button_ui_name': s['ui_button'],
                                                         'on_ok': (function (_w, __alliance_id, __ui_name) { return function() {
                                                             invoke_ui_locker();

                                                             AllianceCache.send_join_request(__alliance_id, (function (__w, ___alliance_id, ___ui_name) { return function (success) {
                                                                 var s = gamedata['strings']['send_alliance_join_request_'+(success?'success':'failure')];
                                                                 invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%s', ___ui_name));
                                                                 if(__w.parent) {
                                                                     update_alliance_info_tab(__w.parent);
                                                                 }
                                                             }; })(_w, __alliance_id, __ui_name));

                                                         }; })(w, _alliance_id, _ui_name)
                                                        });
                        }; })(__dialog.widgets['join_button'], info['id'], info['ui_name']);
                        __dialog.widgets['join_button'].tooltip.str = _dialog.data['widgets']['join_button']['ui_tooltip_send_request'];
                    } else {
                        __dialog.widgets['join_button'].state = 'disabled';
                        __dialog.widgets['join_button'].tooltip.str = __dialog.data['widgets']['join_button']['ui_tooltip_no_invite'];
                    }

                    if(join_cb) {
                        // can send request or join, but first see if leader is in a different region
                        var alliance_in_different_continent = false, continent_info = null;
                        if(('continent' in info) && player.home_continent() != info['continent']) {
                            alliance_in_different_continent = true;
                            continent_info = gamedata['continents'][info['continent']];
                        }
                        if(alliance_in_different_continent) {
                            var bridge = continent_bridge_available();
                            if(bridge) {
                                join_cb = (function (___dialog, _continent_info, _join_cb) { return function() {
                                    var s = gamedata['strings']['join_alliance_different_continent_locked_bridge'];
                                    invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%continent', _continent_info['ui_name']),
                                                                {'dialog': 'message_dialog_big', 'close_button':true, 'cancel_button': true,
                                                                 'ok_button_ui_name': ___dialog.data['widgets']['join_button']['ui_name'], 'on_ok': _join_cb});
                                }; })(__dialog, continent_info, join_cb);
                            } else {
                                join_cb = (function (___dialog, _continent_info, _join_cb) { return function() {
                                    var s = gamedata['strings']['join_alliance_different_continent_locked'];
                                    invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%continent', _continent_info['ui_name']),
                                                                {'dialog': 'message_dialog_big', 'close_button': true, 'cancel_button': true,
                                                                 'ok_button_ui_name': ___dialog.data['widgets']['join_button']['ui_name'], 'on_ok': _join_cb});
                                }; })(dialog, continent_info, join_cb);
                            }
                        }
                        __dialog.widgets['join_button'].onclick = join_cb;
                    }
                }

                __dialog.user_data['rowdata'] = info['members'];
                __dialog.user_data['needs_sort'] = true;
                scrollable_dialog_change_page(__dialog, 0);
              }; })(_dialog));

    }; })(dialog), {force: true, get_private_fields: (session.alliance_id == alliance_id)} );
}

// set number and color of player/alliance ranking widget
function set_rank_widget(d, ui_rank) {
    d.widgets['rank'].str = pretty_print_number(ui_rank);
    var col_str = 'color_'+ui_rank.toString();
    var col = d.data['widgets']['rank_bg'][col_str] || d.data['widgets']['rank_bg']['color'];
    d.widgets['rank_bg'].color = new SPUI.Color(col[0], col[1], col[2], col[3]);
}

function alliance_info_member_row_update(dialog) {
    if(!dialog.show || !dialog.parent) { return; }
    // optional - may not be part of an alliance
    var alliance_info = (dialog.parent.user_data['alliance_id'] ? AllianceCache.query_info_sync(dialog.parent.user_data['alliance_id']) : null);
    var r = dialog.user_data['user_info'];

    // alternate between different lines of tip_info
    if(dialog.user_data['tip_info']) {
        var period = dialog.data['widgets']['info']['blink_period'];
        var index = Math.floor(((client_time - dialog.user_data['anim_start'])/period) % dialog.user_data['tip_info'].length);
        dialog.widgets['info'].str = dialog.user_data['tip_info'][index];
    }


    // trophy count
    var point_stat = dialog.parent.user_data['point_stat'];
    if(point_stat) {
        var count = ((point_stat['name'] in r) ? r[point_stat['name']] : 0);
        dialog.widgets['trophy_bg'].show =
            dialog.widgets['trophy_shine'].show =
            dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_amount'].show = true;
        dialog.widgets['trophy_icon'].asset = dialog.parent.user_data['point_icon_30x30_asset'];
        dialog.widgets['trophy_icon'].state = dialog.parent.user_data['point_icon_30x30_state'];
        dialog.widgets['trophy_amount'].str = pretty_print_number(point_stat['name'].indexOf('trophies_') ==  0 ? display_trophy_count(count, point_stat['name'].split('_')[1]) : count);
        if(('home_region' in r) && (r['home_region'] in gamedata['regions']) && alliance_info && (alliance_info['continent'] in gamedata['continents']) &&
           alliance_info['continent'] != gamedata['regions'][r['home_region']]['continent_id']) {
            dialog.widgets['trophy_amount'].text_color = dialog.widgets['trophy_bg'].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['trophy_bg'].tooltip.str = dialog.data['widgets']['trophy_bg']['ui_tooltip_different_continent'].replace('%player', gamedata['continents'][gamedata['regions'][r['home_region']]['continent_id']]['ui_name']).replace('%alliance', gamedata['continents'][alliance_info['continent']]['ui_name']);
            dialog.widgets['trophy_bg'].fixed_tooltip_offset = null;
        } else {
            dialog.widgets['trophy_amount'].text_color = dialog.widgets['trophy_bg'].tooltip.text_color = SPUI.default_text_color;
            //dialog.widgets['trophy_bg'].tooltip.str = dialog.data['widgets']['trophy_bg']['ui_tooltip'];

            var togo = player.current_trophy_challenge_togo();
            dialog.widgets['trophy_bg'].tooltip.str = dialog.data['widgets']['trophy_bg']['ui_tooltip' + (((togo > 0) && (togo < gamedata['client']['infinite_trophy_togo'])) ? '_togo' : '')].replace('%s', pretty_print_time_brief(togo));
            dialog.widgets['trophy_bg'].fixed_tooltip_offset = dialog.data['widgets']['trophy_bg']['fixed_tooltip_offset'+ (((togo > 0) && (togo < gamedata['client']['infinite_trophy_togo'])) ? '_togo' : '')];

        }
    } else {
        dialog.widgets['trophy_bg'].show =
            dialog.widgets['trophy_shine'].show =
            dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_amount'].show = false;
    }


}

function alliance_info_member_rowfunc(dialog, row, rowdata) {
    var alliance_info = AllianceCache.query_info_sync(dialog.user_data['alliance_id']);
    dialog.widgets['members'+row].user_data['user_id'] = (rowdata ? rowdata['user_id'] : -1);
    if(!('user_info' in dialog.widgets['members'+row].user_data)) { dialog.widgets['members'+row].user_data['user_info'] = null; }
    dialog.widgets['members'+row].show = (rowdata && rowdata['user_id'] > 0 && alliance_info && ('members' in alliance_info));

    dialog.widgets['members'+row].ondraw = alliance_info_member_row_update;

    if(dialog.widgets['members'+row].show) {

        // note: the query SHOULD always return synchronously, since the
        // alliance member list query also pre-fills PlayerCache with
        // entries for each member.

        var got_info = (function (d, _rownum, member) { return function (r) {
            if(!d.parent) { return; } // dialog went away
            var dialog = d.parent;

            var alliance_info = AllianceCache.query_info_sync(d.parent.user_data['alliance_id']);
            if(!alliance_info) { throw Error('no alliance_info for '+d.parent.user_data['alliance_id'].toString()); }

            var user_id = member['user_id'];

            // check user_id match, in case the query is stale
            if(d.user_data['user_id'] != user_id) { console.log("stale result"); return; }

            // bad player data
            if(!r) { d.show = false; return; }

            // force a re-sort on the next draw after NEW info comes in
            if(!d.user_data['user_info'] && d.parent) { d.parent.user_data['needs_sort'] = true; }

            d.user_data['user_info'] = r;

            // role info
            if(!('roles' in alliance_info)) { throw Error('alliance_info without roles for '+alliance_info['id'].toString()); }
            var myrole = member['role'] || 0;
            d.user_data['ui_role'] = d.data['widgets']['info']['ui_role'].replace('%s', alliance_info['roles'][myrole.toString()]['ui_name']);

            d.user_data['ui_home'] = (r['home_region'] && (r['home_region'] in gamedata['regions']) ? d.data['widgets']['info']['ui_home'].replace('%s', gamedata['regions'][r['home_region']]['ui_name']) : d.data['widgets']['info']['ui_home_unknown']);


            d.user_data['ui_donations'] = d.data['widgets']['info']['ui_donations'].replace('%d', pretty_print_number(r['units_donated_cur_alliance'] || 0));

            // last played
            if(gamedata['client']['show_alliance_mate_last_played_time'] && (session.alliance_id == d.parent.user_data['alliance_id'])) {
                var s;
                if('last_login_time' in r) {
                    var ago = server_time - r['last_login_time'];
                    if(ago < 24*60*60) {
                        s = d.data['widgets']['info']['ui_last_played_today'];
                    } else if(ago < 2*24*60*60) {
                        s = d.data['widgets']['info']['ui_last_played_day'];
                    } else if(ago >= 99*24*60*60) {
                        s = d.data['widgets']['info']['ui_last_played_99days'];
                    } else {
                        s = d.data['widgets']['info']['ui_last_played_days'].replace('%d', Math.floor(ago/(24*60*60)).toFixed(0));
                    }
                } else {
                    s = d.data['widgets']['info']['ui_last_played_unknown'];
                }
                d.user_data['ui_last_played'] = s;
            } else {
                d.user_data['ui_last_played'] = null;
            }

            // member since
            if('join_time' in member) {
                d.user_data['ui_member_since'] = d.data['widgets']['info']['ui_member_since'].replace('%s', pretty_print_date(member['join_time']));
            } else {
                d.user_data['ui_member_since'] = null;
            }

            // TOOLTIP: role, last played (if alliancemate), donations, member since
            d.user_data['tip_info'] = [];
            d.user_data['tip_info'].push(d.user_data['ui_role']);
            if(gamedata['enable_region_map']) { d.user_data['tip_info'].push(d.user_data['ui_home']); }
            if(gamedata['client']['show_alliance_mate_last_played_time'] && (session.alliance_id == d.parent.user_data['alliance_id'])) {
                d.user_data['tip_info'].push(d.user_data['ui_last_played'] || '');
            }
            if(gamedata['enable_unit_donation']) { d.user_data['tip_info'].push(d.user_data['ui_donations']); }
            d.user_data['tip_info'].push(d.user_data['ui_member_since'] || '');
            if(!d.user_data['anim_start']) {
                d.user_data['anim_start'] = d.parent.user_data['open_time'] + d.data['widgets']['info']['blink_offset']*_rownum;
            }

            d.show = true;

            d.widgets['name'].str = PlayerCache.get_ui_name(r);
            d.widgets['level'].str = d.data['widgets']['level']['ui_name'].replace('%d', (r['player_level'] || 1).toString());
            d.widgets['portrait'].set_user(user_id);

            d.widgets['info'].str = null; // set from the update function
            d.widgets['info'].tooltip.str = d.user_data['tip_info'].join('\n');

            d.widgets['portrait'].onclick = function(w) {
                var _d = w.parent;
                invoke_player_info_dialog_unknown(_d.user_data['user_id']);
            };

            var point_field = (dialog.user_data['point_stat'] ? dialog.user_data['point_stat']['name'] : '');
            setup_alliance_role_widget(d.widgets['role_icon'], alliance_info['roles'][(member['role']||0).toString()],
                                       ('_client_alliance_rank_'+point_field in r ? r['_client_alliance_rank_'+point_field] : -1),
                                       ('_client_alliance_rank_within_role_'+point_field in r ? r['_client_alliance_rank_within_role_'+point_field] : -1));

            // manage button
            if(session.alliance_id == dialog.user_data['alliance_id'] && user_id != session.user_id) {
                d.widgets['manage_button'].show = true;

                // INFO
                var buttons = [new ContextMenuButton(d.data['widgets']['manage_button']['ui_name_info'],
                                                     (function (_user_id) { return function(w) {
                                                         invoke_player_info_dialog_unknown(_user_id);
                                                     }; })(user_id),
                                                     null,
                                                     d.data['widgets']['manage_button']['ui_tooltip_info'])];

                // PROMOTE/DEMOTE
                if(user_id != session.user_id && player.get_any_abtest_value('enable_alliance_role_gui', gamedata['client']['enable_alliance_role_gui'])) {
                    goog.array.forEach([{'name':'promote','incr':1},{'name':'demote','incr':-1}], function(action) {
                        var cur_role = (member['role']||0), new_role = cur_role + action['incr'];

                        if(!(new_role.toString() in alliance_info['roles'])) { return; } // invalid new role

                        // can promote if you are leader or if you have "promote" permission and your role is higher than MAX(cur_role,new_role)
                        var perm_ok = session.check_alliance_perm('leader') ||
                            (session.check_alliance_perm('promote') && ((session.alliance_membership['role']||0) > Math.max(cur_role,new_role)));
                        if(!perm_ok) {
                            buttons.push(new ContextMenuButton(d.data['widgets']['manage_button']['ui_name_'+action['name']],
                                                               null, 'disabled',
                                                               d.data['widgets']['manage_button']['ui_tooltip_no_permission']));
                        } else {
                            buttons.push(new ContextMenuButton(d.data['widgets']['manage_button']['ui_name_'+action['name']],
                                                               (function (_d, _user_id, _cur_role, _new_role) { return function(w) {
                                                                   invoke_alliance_promote_dialog(_d.parent, _user_id, _cur_role, _new_role);
                                                               }; })(d, user_id, cur_role, new_role),
                                                               null, d.data['widgets']['manage_button']['ui_tooltip_'+action['name']]));
                        }
                    });
                }

                // KICK
                if(user_id == session.user_id) {
                    // no kick button on yourself
                } else if(session.check_alliance_perm('kick') && ((session.alliance_membership['role']||0) > (member['role']||0))) {
                    buttons.push(new ContextMenuButton(d.data['widgets']['manage_button']['ui_name_kick'],
                                                       (function (_d, _user_id, _ui_name) { return function(w) {
                                                           var s = gamedata['strings']['alliance_kick_confirm'];
                                                           invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%s', _ui_name),
                                                                                       {'cancel_button': true,
                                                                                        'ok_button_ui_name': s['ui_button'],
                                                                                        'on_ok': (function (__d, __user_id) { return function() {
                                                                                            __d.widgets['manage_button'].state = 'disabled';
                                                                                            invoke_ui_locker();
                                                                                            AllianceCache.send_kick(session.alliance_id, __user_id, (function (___d) { return function (success) {
                                                                                                ___d.widgets['manage_button'].state = 'normal';
                                                                                                if(!success) { return; }
                                                                                                // refresh the alliance info tab
                                                                                                if(___d.parent) { update_alliance_info_tab(___d.parent); }
                                                                                            }; })(__d));
                                                                                        }; })(_d, _user_id)
                                                                                       });
                                                       }; })(d, user_id, d.widgets['name'].str),
                                                       null, d.data['widgets']['manage_button']['ui_tooltip_kick']));
                } else {
                    buttons.push(new ContextMenuButton(d.data['widgets']['manage_button']['ui_name_kick'],
                                                       null, 'disabled',
                                                       d.data['widgets']['manage_button']['ui_tooltip_no_permission']));
                }

                d.widgets['manage_button'].onclick = (function (_buttons) { return function(w) {
                    invoke_generic_context_menu([mouse_state.last_raw_x, mouse_state.last_raw_y], _buttons);
                }; })(buttons);

            } else {
                d.widgets['manage_button'].show = false;
            }

            // Info or View button
            if(user_id == session.user_id) {
                // do not show on yourself
                d.widgets['button'].show = false;
            } else {
                d.widgets['button'].show = true;
                if(session.alliance_id == dialog.user_data['alliance_id']) {
                    // "view" for clanmates
                    d.widgets['button'].str = d.data['widgets']['button']['ui_name_view'];
                    d.widgets['button'].onclick = function(w) {
                        var _d = w.parent;
                        visit_base(_d.user_data['user_id']);
                    };
                } else {
                    // "info" for non-clanmates
                    d.widgets['button'].str = d.data['widgets']['button']['ui_name_info'];
                    d.widgets['button'].onclick = function(w) {
                        var _d = w.parent;
                        invoke_player_info_dialog_unknown(_d.user_data['user_id']);
                    };
                }

            }
        }; })(dialog.widgets['members'+row], row, rowdata);

        got_info(PlayerCache.query_sync_fetch(rowdata['user_id']));
    }
}

function setup_alliance_role_widget(dialog, role_info, points_rank_overall, points_rank_within_role) {
    var ckind;
    if(goog.array.contains(role_info['perms'], 'leader')) {
        ckind = 'color_leader';
    } else if(points_rank_within_role < 0) {
        ckind = 'color_generic';
    } else if(('color_points'+(points_rank_within_role+1).toString()) in dialog.data['widgets']['bg']) {
        ckind = 'color_points'+(points_rank_within_role+1).toString();
    } else {
        ckind = 'color_points_low';
    }

    dialog.widgets['bg'].color = SPUI.make_colorv(dialog.data['widgets']['bg'][ckind]);
    dialog.widgets['bg'].outline_width = dialog.data['widgets']['bg'][(ckind == 'color_leader' ? 'outline_width_leader' : 'outline_width')];
    dialog.widgets['bg'].outline_color = SPUI.make_colorv(dialog.data['widgets']['bg'][(ckind == 'color_leader' ? 'outline_color_leader' : 'outline_color')]);

    if(player.get_any_abtest_value('enable_alliance_role_gui', gamedata['client']['enable_alliance_role_gui'])) {
        dialog.widgets['numeral'].str = dialog.data['widgets']['numeral']['ui_name_role'+role_info['role'].toString()];
    } else {
        // legacy case
        dialog.widgets['numeral'].str = (points_rank_overall+1).toString();
        dialog.widgets['numeral'].tooltip.str = null;
    }
}

function invoke_alliance_promote_dialog(info_tab, promotee_id, cur_role, new_role) {
    var info = PlayerCache.query_sync(promotee_id);
    var roles = AllianceCache.query_info_sync(session.alliance_id)['roles'];
    var new_role_info = roles[new_role.toString()];

    var dialog = new SPUI.Dialog(gamedata['dialogs']['alliance_promote_dialog']);
    dialog.user_data['dialog'] = 'alliance_promote_dialog';
    dialog.user_data['info_tab'] = info_tab;
    dialog.user_data['promotee_id'] = promotee_id;
    dialog.user_data['cur_role'] = cur_role;
    dialog.user_data['new_role'] = new_role;

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name_'+(new_role>cur_role?'promote':'demote')].replace('%name', PlayerCache.get_ui_name(info)).replace('%role', new_role_info['ui_name']);

    goog.array.forEach(['new_role_rect', 'new_role_icon'], function(wname) {
        dialog.widgets[wname].xy = vec_add(dialog.data['widgets'][wname]['xy'], vec_scale(new_role, dialog.data['widgets']['role_list']['array_offset']));
    });

    setup_alliance_role_widget(dialog.widgets['new_role_icon'], new_role_info, -1, -1);

    goog.array.forEach(['arrow_promote', 'arrow_demote','portrait'], function(wname) {
        dialog.widgets[wname].xy = vec_add(dialog.data['widgets'][wname]['xy'], vec_scale(cur_role, dialog.data['widgets']['role_list']['array_offset']));
        if(dialog.data['widgets'][wname]['clip_to']) {
            var corner = vec_add([dialog.data['widgets'][wname]['clip_to'][0],dialog.data['widgets'][wname]['clip_to'][1]], vec_scale(cur_role, dialog.data['widgets']['role_list']['array_offset']));
            dialog.widgets[wname].clip_to = [corner[0],corner[1],
                                             dialog.data['widgets'][wname]['clip_to'][2],dialog.data['widgets'][wname]['clip_to'][3]];
        }
    });

    dialog.widgets['arrow_promote'].show = (new_role > cur_role);
    dialog.widgets['arrow_demote'].show = (new_role < cur_role);
    dialog.widgets['portrait'].set_user(promotee_id);

    for(var i = 0; i < dialog.data['widgets']['perm_list']['array'][1]; i++) {
        var perm = dialog.data['widgets']['perm_list']['perms'][i];
        dialog.widgets['perm_list'+i.toString()].str = dialog.data['widgets']['perm_list']['ui_name_'+perm];
    }

    for(var i = 0; i < dialog.data['widgets']['role_list']['array'][0]; i++) {
        dialog.widgets['role_list'+i.toString()].str = roles[i.toString()]['ui_name'];
    }

    for(var perm_num = 0; perm_num < dialog.data['widgets']['matrix']['array'][1]; perm_num++) {
        for(var role = 0; role < dialog.data['widgets']['matrix']['array'][0]; role++) {
            var w = dialog.widgets['matrix'+role.toString()+','+perm_num.toString()];
            var allowed = goog.array.contains(roles[role.toString()]['perms'], dialog.data['widgets']['perm_list']['perms'][perm_num]);
            w.str = dialog.data['widgets']['matrix']['ui_name_'+(allowed ? 'yes' : 'no')];
            w.text_color = SPUI.make_colorv(dialog.data['widgets']['matrix']['text_color_'+(allowed ? 'yes' : 'no')]);
        }
    }

    if(goog.array.contains(new_role_info['perms'], 'leader')) {
        dialog.widgets['succession_warning'].show = true;
        dialog.widgets['succession_warning'].str = dialog.data['widgets']['succession_warning']['ui_name'].replace('%name', PlayerCache.get_ui_name(info)).replace('%role', new_role_info['ui_name']).replace('%succession_role', roles[(session.alliance_membership['role']-1).toString()]['ui_name']);
    }

    dialog.widgets['close_button'].onclick = dialog.widgets['cancel_button'].onclick = close_parent_dialog;
    dialog.widgets['ok_button'].onclick = function(w) {
        var _dialog = w.parent;
        AllianceCache.send_promote(session.alliance_id, promotee_id, cur_role, new_role, (function (__dialog) { return function (success) {
            // refresh alliance info tab
            if(success) {
                if(__dialog.user_data['info_tab'].is_visible()) { update_alliance_info_tab(__dialog.user_data['info_tab']); }
                close_parent_dialog(__dialog.widgets['ok_button']);
            }
        }; })(_dialog));
        invoke_ui_locker();
    }
    return dialog;
}

function invoke_player_profile_tab(w) {
    var parent = w.parent;
    var user_id = parent.user_data['user_id'];
    var knowledge = parent.user_data['knowledge'];

    if(!('name' in knowledge) || !('level' in knowledge) || !('relationship' in knowledge)) {
        throw Error('insufficient knowledge for '+user_id+' (knowledge: '+knowledge.toString()+')');
    }

    var name = knowledge['name'] || 'Unknown';
    var level = knowledge['level'] || -1;

    if('tab' in parent.widgets) {
        if(parent.widgets['tab'].user_data['dialog'] == 'player_info_profile_tab') {
            // we're already up
            return;
        }
        parent.remove(parent.widgets['tab']);
        delete parent.widgets['tab'];
    }

    parent.widgets['profile_button'].state = 'active';
    parent.widgets['achievements_button'].state = (player.get_any_abtest_value('enable_ingame_achievements', gamedata['client']['enable_ingame_achievements']) ? 'normal' : 'disabled');
    parent.widgets['statistics_button'].state = 'normal';
    parent.widgets['statistics_button'].show = player.get_any_abtest_value('enable_score_history', gamedata['client']['enable_score_history']);

    var dialog = new SPUI.Dialog(gamedata['dialogs']['player_info_profile_tab']);
    dialog.transparent_to_mouse = true;
    dialog.user_data['dialog'] = 'player_info_profile_tab';
    dialog.user_data['user_id'] = user_id;
    dialog.user_data['alliance_query_sent'] = false;
    dialog.user_data['open_time'] = client_time;
    dialog.user_data['categories'] = goog.array.filter(['conquests', 'resources_looted', 'havoc_caused', 'damage_inflicted'],
                                                       function(stat) { return (stat in gamedata['strings']['leaderboard']['categories']) &&
                                                                        ('leaderboard_show_if' in gamedata['strings']['leaderboard']['categories'][stat]) &&
                                                                        read_predicate(gamedata['strings']['leaderboard']['categories'][stat]['leaderboard_show_if']).is_satisfied(player, null); });
    dialog.user_data['periods'] = ['week', 'season'];
    dialog.user_data['period'] = 'week';
    dialog.user_data['score_query_sent'] = {};
    dialog.user_data['tournament_end_time'] = -1;
    dialog.user_data['scores'] = [];
    dialog.user_data['cache'] = null; // stores result of player cache query
    parent.widgets['tab'] = dialog;
    parent.add(dialog);

    dialog.widgets['id_number'].str = user_id.toString();

    dialog.widgets['name'].str = name;
    dialog.widgets['level'].str = level.toString();
    dialog.widgets['friend_icon'].set_user(user_id);

    var show_coords = gamedata['enable_region_map'] && gamedata['territory']['show_coords_in_player_info'] && (session.region.data && session.region.data['storage'] == 'nosql' && session.region.map_enabled());
    dialog.widgets['battle_count_label'].show = dialog.widgets['battle_count'].show =
        dialog.widgets['battle_age_label'].show = dialog.widgets['battle_age'].show = !show_coords;
    dialog.widgets['home_region_label'].show = dialog.widgets['home_region_value'].show =
        dialog.widgets['home_base_loc_label'].show = dialog.widgets['home_base_loc_value'].show = show_coords;

    if(show_coords) {
        // these are set from update_player_info_profile_tab
        dialog.widgets['spy_button'].state = 'disabled';
    } else {
        dialog.widgets['battle_count'].str = (('battle_count' in knowledge) ? knowledge['battle_count'].toString() : '-');
        if(('last_battle_time' in knowledge) && (knowledge['last_battle_time'] > 0)) {
            dialog.widgets['battle_age'].str = dialog.data['widgets']['battle_age']['ui_name'].replace('%s', pretty_print_time(server_time - knowledge['last_battle_time']));
        } else {
            dialog.widgets['battle_age'].str = '-';
        }
    }

    dialog.widgets['alliance'].onclick = null;

    if(user_id == session.user_id) {
        // looking at yourself
        dialog.widgets['spy_button'].show = false;
        dialog.widgets['friend_icon'].state = 'disabled';
        dialog.widgets['battles_button'].onclick = function() { invoke_battle_history_dialog(session.user_id, -1, '', -1); };
    } else {
        dialog.widgets['spy_button'].onclick = (function(uid) { return function() {
            visit_base(uid);
        }; })(user_id);
        dialog.widgets['friend_icon'].state = 'normal';
        dialog.widgets['friend_icon'].onclick = function(w) {
            // same behavior as "Spy" button
            var spy = w.parent.widgets['spy_button'];
            if(spy.show && spy.state != 'disabled') { spy.onclick(spy); }
        };

        // see battles from MY perspective against this opponent
        dialog.widgets['battles_button'].onclick = (function(_uid, _name, _level) { return function() {
                                invoke_battle_history_dialog(session.user_id, _uid, _name, _level);
                        }; })(user_id, name, level);

        // see all battles from OPPONENT'S perspective (developer only)
        dialog.widgets['dev_battles_button'].show = (player.is_developer() && (session.viewing_user_id == user_id));
        dialog.widgets['dev_battles_button'].onclick = (function(_uid, _name, _level) { return function() {
                                invoke_battle_history_dialog(_uid, -1, '(DEV-ALL)', -1);
                        }; })(user_id, name, level);

    }

    update_player_info_dialog_blockstate(dialog);

    dialog.widgets['report_button'].onclick = (function(uid) { return function() {
        // come up with a fake chat name for the report confirmation
        var names = knowledge['name'].split(' ');
        var fake_chat_name = names[0];
        if(names.length > 1 && names[1].length > 0) { fake_chat_name += names[1][0]; }
        send_to_server.func(["CHAT_REPORT", uid, SPHTTP.wrap_string(fake_chat_name)]);
        player.block_user(uid);
        invoke_ui_locker(synchronizer.request_sync(), function() {
            change_selection(null);
            var s = gamedata['strings']['report_sent'];
            invoke_message_dialog(s['ui_title'], s['ui_description'], {'dialog':'message_dialog_big'});
        });
    }; })(user_id);

    if(knowledge['messageable'] && spin_frame_platform == 'fb' && knowledge['facebook_id']) {
        dialog.widgets['message_button'].show = true;
        dialog.widgets['message_button'].onclick = (function (_fbid, _uid) { return function() {
            change_selection(null);
            invoke_facebook_message_dialog(_fbid, _uid);
        } })(knowledge['facebook_id'], user_id);
    }

    if(player.resource_gifts_enabled() && knowledge['giftable'] && knowledge['friend_list_entry']) {
        var friend = knowledge['friend_list_entry'];
        if(spin_frame_platform == 'fb' && friend.get_facebook_id()) {
            dialog.widgets['gift_button'].show = true;
            dialog.widgets['gift_button'].state = friend.is_giftable() ? 'normal' : 'disabled';
            dialog.widgets['gift_button'].onclick = (function (_fr) { return function() { change_selection(null); FBSendRequests.invoke_send_gifts_dialog(_fr.get_facebook_id()); }; })(friend);
            dialog.widgets['gift_button'].tooltip.str = friend.is_giftable() ? null : dialog.data['widgets']['gift_button']['ui_tooltip_already_sent'];
        } else {
            dialog.widgets['gift_button'].show = false;
        }
    }

    // set up scores display
    var header_ui_names = dialog.data['widgets']['leaderboard_header']['ui_names'];
    for(var i = 0; i < header_ui_names.length; i++) {
        dialog.widgets['leaderboard_header'+i.toString()].str = header_ui_names[i];
    }

    dialog.widgets['show_week'].onclick = function(w) { var dlg = w.parent; if(dlg) { dlg.user_data['period']='week'; update_player_info_dialog_scores(dlg); } };
    dialog.widgets['show_season'].onclick = function(w) { var dlg = w.parent; if(dlg) { dlg.user_data['period']='season'; update_player_info_dialog_scores(dlg); } };
    update_player_info_dialog_scores(dialog);


    // send player score queries
    var qls = [];
    var qkinds = [];
    var event = player.current_stat_tournament_event();
    if(event) {
        // send tournament query
        qls.push([event['stat']['name'], event['stat']['time_scope']]);
        dialog.user_data['score_query_sent']['stat_tournament'] = 1;
        qkinds.push('stat_tournament');
    }

    // send trophy query
    var trophy_type = player.current_trophy_type();
    if(!trophy_type && player.is_ladder_player()) { trophy_type = 'pvp'; }
    if(trophy_type) {
        var trophy_freq = (trophy_type == 'pvp' ? gamedata['matchmaking']['ladder_point_frequency'] : 'week');
        qls.push(['trophies_'+trophy_type, trophy_freq]);
        dialog.user_data['score_query_sent']['trophies'] = 1;
        qkinds.push('trophies');
        if(event) {
            // this is going to the backup display instead of the primary display
            dialog.widgets['backup_trophy_spinner'].show = true;
        }
    }

    if(qls.length > 0) {
        query_player_scores([user_id], qls, (function (_dialog, _qls, _qkinds) { return function(user_ids, data) {
            player_info_scores_result(_dialog, _qls, _qkinds, data[0]);
        }; })(dialog, qls, qkinds));
    }


    dialog.ondraw = update_player_info_profile_tab;
    return dialog;
}

function update_player_info_profile_tab(dialog) {
    // update leaderboard display
    dialog.widgets['leaderboard_loading'].show = (dialog.user_data['score_query_sent'][dialog.user_data['period']]||0) < 2;
    if(!dialog.user_data['score_query_sent'][dialog.user_data['period']]) { player_info_scores_query(dialog, dialog.user_data['period']); }

    // update playercache info
    var user_id = dialog.user_data['user_id'];
    if(!is_ai_user_id_range(user_id)) {
        var r = PlayerCache.query_sync_fetch(user_id);
        if(r) {
            if('last_defense_time' in r) {
                dialog.widgets['defense_time'].str = pretty_print_time(server_time - r['last_defense_time']);
            }

            var region_ok = false, loc_ok = false;
            if(dialog.widgets['home_region_label'].show) {
                if('home_region' in r && r['home_region'] && r['home_region'] in gamedata['regions']) {
                    dialog.widgets['home_region_value'].str = gamedata['regions'][r['home_region']]['ui_name'];
                    region_ok = true;
                } else {
                    dialog.widgets['home_region_value'].str = dialog.data['widgets']['home_region_value']['ui_name_unknown'];
                }
                if('home_base_loc' in r && r['home_base_loc'] && r['home_base_loc'].length == 2 && region_ok) {
                    dialog.widgets['home_base_loc_value'].str = dialog.data['widgets']['home_base_loc_value']['ui_name_coords'].replace('%X',r['home_base_loc'][0].toString()).replace('%Y',r['home_base_loc'][1].toString());
                    dialog.widgets['home_base_loc_value'].text_color = SPUI.make_colorv(dialog.data['widgets']['home_base_loc_value']['text_color_link']);
                    dialog.widgets['home_base_loc_value'].onclick = (function (_region,_loc) { return function(w) { invoke_find_on_map(_region, _loc); }; })(r['home_region'], r['home_base_loc']);
                    loc_ok = true;
                } else {
                    dialog.widgets['home_base_loc_value'].str = dialog.data['widgets']['home_base_loc_value']['ui_name_unknown'];
                }

                if(user_id != session.user_id) {
                    // Facebook friend or alliancemate?
                    var friend = find_friend_by_user_id(user_id);
                    if((friend && friend.is_real_friend) || (session.is_in_alliance() && session.alliance_id == r['alliance_id'])) {
                        // direct spying is possible
                        dialog.widgets['spy_button'].state = 'normal';
                    } else if(region_ok && loc_ok && session.region.data && r['home_region'] == session.region.data['id'] && session.region.map_enabled()) {
                        // same region - change to Find button
                        dialog.widgets['spy_button'].state = 'normal';
                        dialog.widgets['spy_button'].str = dialog.data['widgets']['spy_button']['ui_name_find_on_map'];
                        dialog.widgets['spy_button'].onclick = (function (_loc) { return function(w) {
                            change_selection_ui(null);
                            invoke_region_map(_loc);
                        }; })(r['home_base_loc']);
                    } else {
                        // different region - leave button disabled, change tooltip
                        dialog.widgets['spy_button'].tooltip.str = dialog.data['widgets']['spy_button']['ui_tooltip_other_region'].replace('%REGION', dialog.widgets['home_region_value'].str);
                    }
                }
            }

            if(player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances']) && ('alliance_id' in r)) {
                if(r['alliance_id'] <= 0) {
                    // player is not currently in an alliance
                    dialog.widgets['alliance'].str = dialog.data['widgets']['alliance']['ui_name_none'];

                    // show "send invite" button
                    if(session.is_in_alliance() && user_id != session.user_id) {
                        dialog.widgets['alliance_invite_button'].show = true;
                        if(session.check_alliance_perm('invite')) {
                            if(player.cooldown_active('alliance_invite:'+user_id.toString())) {
                                dialog.widgets['alliance_invite_button'].state = 'disabled';
                                dialog.widgets['alliance_invite_button'].tooltip.str = dialog.data['widgets']['alliance_invite_button']['ui_tooltip_cooldown'].replace('%s', pretty_print_time(player.cooldown_togo('alliance_invite:'+user_id.toString())));
                            } else {
                                var invite_cb = (function (w) { return function() {
                                    var _dialog = w.parent;
                                    w.state = 'disabled';
                                    w.str = _dialog.data['widgets']['alliance_invite_button']['ui_name_sending'];
                                    var cb = (function (__dialog) { return function(success) {
                                        __dialog.widgets['alliance_invite_button'].str = __dialog.data['widgets']['alliance_invite_button']['ui_name_sent'];
                                    }; })(_dialog);
                                    AllianceCache.send_invite(session.alliance_id, _dialog.user_data['user_id'], cb);
                                }; })(dialog.widgets['alliance_invite_button']);

                                if(region_ok && session.region.data && r['home_region'] != session.region.data['id'] &&
                                   ('requires' in gamedata['regions'][r['home_region']]) && !read_predicate(gamedata['regions'][r['home_region']]['requires']).is_satisfied(player, null)) {
                                    // different continent
                                    var bridge = continent_bridge_available();
                                    if(bridge) {
                                        invite_cb = (function (_dialog, _r, _invite_cb) { return function() {
                                            var s = gamedata['strings']['find_in_different_region_locked_bridge'];
                                            invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%region', gamedata['regions'][_r['home_region']]['ui_name']),
                                                                        {'dialog': 'message_dialog_big', 'close_button':true, 'cancel_button': true,
                                                                         'ok_button_ui_name': _dialog.data['widgets']['alliance_invite_button']['ui_name'], 'on_ok': _invite_cb});
                                        }; })(dialog, r, invite_cb);
                                    } else {
                                        invite_cb = (function (_dialog, _r, _invite_cb) { return function() {
                                            var s = gamedata['strings']['find_in_different_region_locked'];
                                            invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%region', gamedata['regions'][_r['home_region']]['ui_name']),
                                                                        {'dialog': 'message_dialog_big', 'close_button': true, 'cancel_button': true,
                                                                         'ok_button_ui_name': _dialog.data['widgets']['alliance_invite_button']['ui_name'], 'on_ok': _invite_cb});
                                        }; })(dialog, r, invite_cb);
                                    }
                                }
                                dialog.widgets['alliance_invite_button'].onclick = invite_cb;
                            }
                        } else {
                            dialog.widgets['alliance_invite_button'].state = 'disabled';
                            dialog.widgets['alliance_invite_button'].tooltip.str = gamedata['dialogs']['alliance_member_row']['widgets']['manage_button']['ui_tooltip_no_permission'];
                        }
                    }

                } else {
                    // player is already in an alliance
                    dialog.widgets['alliance'].onclick = (function (_id) { return function(w) {
                        invoke_alliance_info(_id);
                    }; })(r['alliance_id']);

                    if(!dialog.user_data['alliance_query_sent']) {
                        dialog.user_data['alliance_query_sent'] = true;
                        AllianceCache.query_info(r['alliance_id'], (function (_dialog) { return function(r) {
                            if(r) {
                                if('ui_name' in r) {
                                    _dialog.widgets['alliance'].str = alliance_display_name(r);
                                    // XXX future: add "Manage" button here
                                }
                            }
                        }; })(dialog));
                    }
                }
            }
        }
        update_player_info_dialog_blockstate(dialog);
    }

    // update expiry timer
    if(dialog.widgets['trophy_expires'].show) {
        dialog.widgets['trophy_expires'].str = dialog.data['widgets']['trophy_expires']['ui_name'].replace('%expiry',gamedata['strings']['trophies_expire_in']).replace('%s', pretty_print_time_brief(dialog.user_data['tournament_end_time'] - player.get_absolute_time()));
    }
}

function player_info_scores_query(dialog, frequency) {
    if(is_ai_user_id_range(dialog.user_data['user_id'])) { return; } // no AIs
    if(dialog.user_data['score_query_sent'][frequency] > 0) { return; } // already in flight or landed
    dialog.user_data['score_query_sent'][frequency] = 1; // mark in flight
    var qls = [];
    for(var j = 0; j < dialog.user_data['categories'].length; j++) {
        qls.push([dialog.user_data['categories'][j], frequency]);
    }
    var cb = (function (_dialog, _qls, _frequency) { return function(user_ids, data) {
        player_info_scores_result(_dialog, _qls, [_frequency], data[0]);
    }; })(dialog, qls, frequency);
    query_player_scores([dialog.user_data['user_id']], qls, cb, {get_rank:1});
}

function player_info_scores_result(dialog, qls, kinds, data) {
    if(!dialog.parent) { return; } // dialog was destroyed
    goog.array.forEach(kinds, function(kind) {
        dialog.user_data['score_query_sent'][kind] = 2; // mark landed
        if(kind == 'trophies') {
            dialog.widgets['backup_trophy_spinner'].show = false;
        }
    });

    for(var i = 0 ; i < data.length; i++) {
        if(data[i] && ('absolute' in data[i])) {
            data[i]['field'] = qls[i][0]; data[i]['frequency'] = qls[i][1];
            dialog.user_data['scores'].push(data[i]);
        }
    }
    update_player_info_dialog_scores(dialog);
}

function update_player_info_dialog_scores(dialog) {
    var period = dialog.user_data['period'];
    dialog.widgets['show_week'].state = (period == 'week' ? 'active' : 'normal');
    dialog.widgets['show_season'].state = (period == 'season' ? 'active' : 'normal');

    var scores = dialog.user_data['scores']; // may be empty

    var trophy_type = player.current_trophy_type();
    var trophy_challenge_name = player.current_trophy_challenge_name();
    if(!trophy_type && player.is_ladder_player()) {
        trophy_type = 'pvp';
        trophy_challenge_name = 'challenge_pvp_ladder';
    }

    var point_stat = null, point_icon = null, point_time_scope = null, point_ui_name = null, point_icon_state = null;
    var event = player.current_stat_tournament_event();
    if(event) { // show stat tournament points on primary display
        point_stat = event['stat']['name'];
        point_ui_name = event['ui_name'];
        point_time_scope = event['stat']['time_scope'];
        point_icon = event['icon'];
        point_icon_state = 'icon_30x30';
        dialog.user_data['tournament_end_time'] = player.current_stat_tournament()['end_time'];
    } else if(trophy_type) { // show pvp points on primary display
        point_ui_name = gamedata['events'][trophy_challenge_name]['ui_name'];
        point_stat = 'trophies_'+trophy_type;
        point_icon = 'trophy_30x30';
        point_icon_state = trophy_type;
        point_time_scope = gamedata['matchmaking']['ladder_point_frequency'];
        dialog.user_data['tournament_end_time'] = player.get_absolute_time() + player.current_trophy_challenge_togo();
    }

    var point_count = null, trophy_count = 0;
    for(var i = 0; i < scores.length; i++) {
        if(scores[i]['field'] == point_stat && ('absolute' in scores[i])) {
            point_count = scores[i]['absolute'];
            if(!event) { // legacy
                var cur_trophy_type = player.current_trophy_type();
                if(cur_trophy_type) {
                    point_count = display_trophy_count(point_count, cur_trophy_type);
                }
            }
        }
        if(trophy_type && event && scores[i]['field'] == 'trophies_'+trophy_type && ('absolute' in scores[i])) {
            trophy_count = display_trophy_count(scores[i]['absolute'], trophy_type);
        }
    }

    if(point_stat !== null && point_count !== null) {
        //dialog.widgets['trophy_label'].show =
            dialog.widgets['trophy_bg'].show =
            dialog.widgets['trophy_shine'].show =
            dialog.widgets['trophy_icon'].show =
            dialog.widgets['trophy_amount'].show = true;
        dialog.widgets['trophy_expires'].show = (point_time_scope !== 'season' && dialog.user_data['tournament_end_time'] > player.get_absolute_time());
        dialog.widgets['trophy_icon'].asset = point_icon;
        dialog.widgets['trophy_icon'].state = point_icon_state;
        dialog.widgets['trophy_bg'].tooltip.str = dialog.data['widgets']['trophy_bg']['ui_tooltip'].replace('%type', point_ui_name);
        if(point_stat in gamedata['strings']['leaderboard']['categories']) {
            dialog.widgets['trophy_bg'].tooltip.str += '\n' + gamedata['strings']['leaderboard']['categories'][point_stat]['description'];
        }
        dialog.widgets['trophy_label'].str = dialog.data['widgets']['trophy_label']['ui_name'];
        dialog.widgets['trophy_amount'].str = pretty_print_number(point_count);
        dialog.widgets['trophy_amount'].color = SPUI.make_colorv(dialog.data['widgets']['trophy_amount']['text_color_'+(point_count>=0 ? 'plus':'minus')]);
    }

    if(event && trophy_type && trophy_challenge_name && trophy_count !== null) { // backup trophy display when primary display is something other than trophies
        dialog.widgets['backup_trophy_icon'].show =
            dialog.widgets['backup_trophy_count'].show = true;
        dialog.widgets['backup_trophy_icon'].state = trophy_type;
        dialog.widgets['backup_trophy_count'].str = pretty_print_number(trophy_count);
        dialog.widgets['backup_trophy_count'].color = SPUI.make_colorv(dialog.data['widgets']['backup_trophy_count']['text_color_'+(trophy_count>=0 ? 'plus':'minus')]);
        dialog.widgets['backup_trophy_count'].tooltip.str = dialog.data['widgets']['backup_trophy_count']['ui_tooltip'].replace('%type', gamedata['events'][trophy_challenge_name]['ui_name']);
    }

    // only show the 3 categories with top-most player ranking
    var shown_categories = [];

    for(var i = 0; i < scores.length; i++) {
        if(scores[i]['frequency'] == dialog.user_data['period'] && ('rank' in scores[i])) {
            shown_categories.push(scores[i]);
        }
    }

    var compare_by_rank = function(a,b) {
        if(a['rank'] > b['rank'])  {
            return 1;
        } else if(a['rank'] < b['rank']) {
            return -1;
        } return 0;
    };
    shown_categories.sort(compare_by_rank);

    // only show first 3 rows
    shown_categories = shown_categories.slice(0,3);

    var i;
    for(i = 0; i < shown_categories.length; i++) {
        var data = shown_categories[i];
        var cat = data['field'];
        var pct = 1.0-data['percentile'];
        var rank = data['rank']+1; // server numbering starts at 0

        dialog.widgets['leaderboard_accent'+i.toString()].show = (pct >= 0.5);
        dialog.widgets['leaderboard_accent'+i.toString()].state = (pct >= 0.99 ? 'top' : 'normal');

        var status = percentile_ui_status(rank, pct, true);

        dialog.widgets['leaderboard_data0,'+i.toString()].str = gamedata['strings']['leaderboard']['categories'][cat]['short_title'];
        dialog.widgets['leaderboard_data0,'+i.toString()].tooltip.str = gamedata['strings']['leaderboard']['categories'][cat]['description'];
        dialog.widgets['leaderboard_data1,'+i.toString()].str = status;
        dialog.widgets['leaderboard_data2,'+i.toString()].str = pretty_print_number(rank);
        dialog.widgets['leaderboard_data3,'+i.toString()].str = pretty_print_number(data['absolute']);
        dialog.widgets['leaderboard_data4,'+i.toString()].str = (data['absolute'] > 0 ? (100.0*pct).toFixed(1)+'%' : '-');
        for(var m = 0; m < 5; m++) {
            dialog.widgets['leaderboard_data'+m.toString()+','+i.toString()].show = true;
        }
    }

    // clear remaining rows
    while(i < 3) {
        dialog.widgets['leaderboard_accent'+i.toString()].show = false;
        for(var m = 0; m < 5; m++) {
            dialog.widgets['leaderboard_data'+m.toString()+','+i.toString()].show = false;
        }
        i++;
    }
}

function update_player_info_dialog_blockstate(dialog) {
    var user_id = dialog.user_data['user_id'];
    if(user_id == session.user_id) {
        // yourself
        dialog.widgets['ignore_button'].show =
            dialog.widgets['report_button'].show = false;
    }

    // gag buttons
    if(player.is_chat_mod && user_id != session.user_id) {
        var mutecb = function(_uid, cmd) { return function() { send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, cmd, _uid]);
                                                               change_selection(null); }; };
        dialog.widgets['dev_mute_button'].onclick = mutecb(user_id, "CHAT_GAG");
        dialog.widgets['dev_unmute_button'].onclick = mutecb(user_id, "CHAT_UNGAG");
        var info = PlayerCache.query_sync(user_id);
        if(info) {
            var gagged = info && (('chat_gagged' in info) && info['chat_gagged']);
            dialog.widgets['dev_mute_button'].show = !gagged;
            dialog.widgets['dev_unmute_button'].show = gagged;
        } else {
            dialog.widgets['dev_mute_button'].show =
                dialog.widgets['dev_unmute_button'].show = false;
        }
    }

    if(player.has_blocked_user(user_id)) {
        dialog.widgets['report_button'].state = 'disabled';
        dialog.widgets['report_button'].tooltip.str = dialog.data['widgets']['report_button']['ui_tooltip_already_reported'];
        dialog.widgets['ignore_button'].str = dialog.data['widgets']['ignore_button']['ui_name_unblock'];
        dialog.widgets['ignore_button'].tooltip.str = dialog.data['widgets']['ignore_button']['ui_tooltip_unblock'];
        dialog.widgets['ignore_button'].onclick = (function(d, uid) { return function() {
            invoke_ui_locker();
            player.unblock_user(uid);
            update_player_info_dialog_blockstate(d);
        }; })(dialog, user_id);
    } else {
        dialog.widgets['report_button'].state = 'normal';
        dialog.widgets['report_button'].tooltip.str = dialog.data['widgets']['report_button']['ui_tooltip'];
        dialog.widgets['ignore_button'].str = dialog.data['widgets']['ignore_button']['ui_name'];
        dialog.widgets['ignore_button'].tooltip.str = dialog.data['widgets']['ignore_button']['ui_tooltip'];
        dialog.widgets['ignore_button'].onclick = (function(d, uid) { return function() {
            invoke_ui_locker();
            player.block_user(uid);
            update_player_info_dialog_blockstate(d);
        }; })(dialog, user_id);
    }
}

// dialog for TRUE FACEBOOK FRIENDS
function invoke_player_info_dialog_facebook_friend(friend) {
    return invoke_player_info(friend.user_id,
                              {'name': friend.get_ui_name(),
                               'level': friend.get_player_level(),
                               'friend_list_entry': friend,
                               'facebook_id': friend.get_facebook_id(),
                               'social_id':friend.get_social_id(),
                               'battle_count': friend.battle_count,
                               'last_battle_time': friend.last_battle_time,
                               'relationship': gamedata['strings']['relationships']['facebook_friend'],
                               'messageable': true,
                               'giftable': friend.is_giftable()
                              });
}

// dialog for "Friends" in player.friends who are NOT true facebook friends
function invoke_player_info_dialog_rival(friend) {
    return invoke_player_info(friend.user_id,
                              {'name': friend.get_ui_name(),
                               'level': friend.get_player_level(),
                               'friend_list_entry': friend,
                               'facebook_id': friend.get_facebook_id(),
                               'social_id':friend.get_social_id(),
                               'battle_count': friend.battle_count,
                               'last_battle_time': friend.last_battle_time,
                               'relationship': gamedata['strings']['relationships']['rival']
                              });
}

/** @param {number} uid
    @param {string|null=} fbid
    @param {string|null=} name
    @param {number|null=} level */
function invoke_player_info_dialog_stranger(uid, fbid, name, level) {
    var relationship;
    if(uid == session.user_id) {
        relationship = gamedata['strings']['relationships']['yourself'];
    } else {
        relationship = gamedata['strings']['relationships']['rival'];
    }
    return invoke_player_info(uid,
                              {'name': name,
                               'level': level,
                               'facebook_id': fbid,
                               'relationship': relationship
                              });
}

function invoke_player_info_dialog_self() {
    return invoke_player_info_dialog_stranger(session.user_id, spin_facebook_user,
                                              player.get_ui_name(),
                                              player.resource_state['player_level']);
};

// search player.friends by user id
function find_friend_by_user_id(uid) {
    for(var i = 0; i < player.friends.length; i++) {
        var friend = player.friends[i];
        if(uid === friend.user_id) {
            return friend;
        }
    }
    return null;
}

// call this if you have no freaking idea who the user is (e.g. from chat hyperlink)
/** @param {number} uid
    @param {(string|null)=} fbid
    @param {(string|null)=} name
    @param {(number|null)=} level
    @param {(function(SPUI.Dialog)|null)=} cb */
function invoke_player_info_dialog_unknown(uid, fbid, name, level, cb) {
    if(!cb) { cb = function(x) { return x; } }
    if(fbid === '-1') { /* AI user*/ return null; };

    if(uid == session.user_id) { return cb(invoke_player_info_dialog_self()); }

    // search player.friends by user id
    var friend = find_friend_by_user_id(uid);
    if(friend) {
        if(friend.is_ai()) { return null; }
        if(friend.is_real_friend) { return cb(invoke_player_info_dialog_facebook_friend(friend)); }
        return cb(invoke_player_info_dialog_rival(friend));
    }

    // not in player.friends - it's a stranger (or yourself)
    if(fbid) {
        return cb(invoke_player_info_dialog_stranger(uid, fbid, name, level));
    }

    // all we know is uid - do async cache query
    var after_query = (function (_uid, _cb) { return function() {
        var info = PlayerCache.query_sync(_uid);
        if(!info || (!info['social_id'] && !info['facebook_id'])) {
            var s = gamedata['errors']['CANNOT_GET_INFO_PLAYER_NOT_FOUND'];
            invoke_child_message_dialog(s['ui_title'], s['ui_name'].replace('%d', _uid.toString()), {'dialog':'message_dialog_big'});
            return null;
        }
        return _cb(invoke_player_info_dialog_stranger(info['user_id'], info['facebook_id'], PlayerCache.get_ui_name(info), info['player_level']));
    }; })(uid, cb);

    if(PlayerCache.query_sync_fetch(uid)) {
        return after_query();
    } else {
        PlayerCache.launch_batch_queries(client_time, true); // force query to go out before request_sync
        invoke_ui_locker(synchronizer.request_sync(), after_query);
        return null;
    }
}

// fill in a unit_icon dialog widget
/** @param {SPUI.Dialog} dialog
    @param {string|null} specname
    @param {number=} qty, -1 if irrelevant
    @param {string|null=} obj
    @param {function(SPUI.DialogWidget)|null=} onclick
    @param {string|null=} frame_state_override
    @param {string|null=} tooltip_override */
function unit_icon_set(dialog, specname, qty, obj, onclick, frame_state_override, tooltip_override) {
    var spec = (specname ? gamedata['units'][specname] : null);
    dialog.user_data['spec'] = spec;
    dialog.user_data['obj'] = obj;
    dialog.user_data['frame_state_override'] = frame_state_override || null;
    dialog.widgets['icon'].show = dialog.widgets['slot'].show = dialog.widgets['stack'].show = dialog.widgets['frame'].show = !!spec;
    if(spec) {
        dialog.widgets['icon'].asset = get_leveled_quantity(spec['art_asset'], 1);
        dialog.widgets['icon'].state = 'icon';
        dialog.widgets['stack'].str = (qty > 1 ? pretty_print_number(qty) : null);
        dialog.widgets['frame'].onclick = (onclick ? onclick : null);
        dialog.widgets['frame'].tooltip.str = (tooltip_override ? tooltip_override : (onclick ? spec['ui_name'] + (('ui_tip' in spec) ? '\n'+spec['ui_tip'] : '') : null));
    }
    dialog.ondraw = unit_icon_update;
}
function unit_icon_update(dialog) {
    // update repair/wrench icon
    var obj = dialog.user_data['obj'];
    dialog.widgets['wrench'].show = false;
    var obj_repair_state = 0;
    if(obj) {
        obj_repair_state = army_unit_repair_state(obj);
        dialog.widgets['wrench'].show = (obj_repair_state > 0);
        dialog.widgets['wrench'].asset = dialog.data['widgets']['wrench']['asset_'+(obj_repair_state == 2 ? 'active' : 'queued')];
        dialog.widgets['wrench'].rocking = (obj_repair_state == 2);
    }
    if(dialog.widgets['frame'].show) {
        if(dialog.user_data['frame_state_override']) {
            dialog.widgets['frame'].state = dialog.user_data['frame_state_override'];
        } else {
            dialog.widgets['frame'].state = (obj_repair_state > 0 ? 'disabled' : (dialog.widgets['frame'].onclick ? 'normal' : 'normal_nohighlight'));
        }
    }
}

var squad_update_receivers = {};
var squad_update_receivers_serial = 1;

// squad_control dialog can be used for "normal" squad control or as a limited-use "squad picker"

function do_invoke_squad_control(dlg_mode, dlg_mode_data) {
    // check for no-squad-available error conditions
    if(dlg_mode == 'deploy' || dlg_mode == 'call') {
        var msg = null;
        if(goog.object.getCount(player.squads) < 2) {
            // player has not created any squads yet
            msg = "CANNOT_DEPLOY_SQUADS_NONE";
        }
        if(!msg) {
            var can_do_action = false;
            var needs_additional_deployment = true;
            goog.object.forEach(player.squads, function(squad) {
                if(!(player.squad_is_under_repair(squad['id']) || player.squad_is_in_battle(squad['id']) || !SQUAD_IDS.is_mobile_squad_id(squad['id']) || ((dlg_mode=='deploy')&& player.squad_is_deployed(squad['id'])) || player.squad_is_dead(squad['id']) || player.squad_is_empty(squad['id']))) {

                    can_do_action = true;
                    if(SQUAD_IDS.is_mobile_squad_id(squad['id']) &&
                       (dlg_mode=='call'&&player.squad_is_deployed(squad['id']))) {
                        needs_additional_deployment = false;
                    }
                }
            });
            if(!can_do_action) {
                msg = "CANNOT_DEPLOY_SQUADS_ALL_BUSY";
            } else if(needs_additional_deployment) {
                if(resolve_squad_deployment_problem()) { return null; }
            }
        }
        if(msg) {
            var s = gamedata['errors'][msg];
            invoke_child_message_dialog(s['ui_title'], s['ui_name'], {'dialog':'message_dialog_big',
                                                                      'cancel_button': true,
                                                                      'on_ok': function() { do_invoke_squad_control('manage',null); },
                                                                      'ok_button_ui_name': s['ui_button']});
            return null;
        }
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['squad_control']);
    dialog.user_data['dialog'] = 'squad_control';
    dialog.user_data['last_columns'] = -1;
    dialog.user_data['dlg_mode'] = dlg_mode;
    if(dlg_mode_data) {
        goog.object.forEach(dlg_mode_data, function(v,k) { dialog.user_data[k] = v; });
    }

    install_child_dialog(dialog);
    dialog.auto_center('root');
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;

    if(dlg_mode == 'normal') {
        init_army_dialog_buttons(dialog.widgets['army_dialog_buttons_army'], 'army', 'squad_control');
    } else {
        dialog.widgets['army_dialog_buttons_army'].show = false;
    }
    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name_'+dlg_mode];

    dialog.user_data['receiver_serial'] = squad_update_receivers_serial++;
    squad_update_receivers[dialog.user_data['receiver_serial']] = (function (_dialog) { return function() {
        squad_control_refresh(_dialog);
        squad_control_unblock(_dialog);
    }; })(dialog);
    dialog.on_destroy = function(_dialog) { delete squad_update_receivers[_dialog.user_data['receiver_serial']]; };

    squad_control_refresh(dialog);
    dialog.ondraw = update_squad_control;

    // ensure region map is somewhat up to date - we need it for pathfinding and quarry detection!
    if(dlg_mode == 'normal' && session.region && session.region.data && session.region.dirty && session.region.map_enabled()) {
        squad_control_block(dialog);
        session.region.call_when_fresh((function(_dialog) { return function() {
            squad_control_unblock(_dialog);
        }; })(dialog));
    }

    return dialog;
}
function invoke_squad_control() { return do_invoke_squad_control('normal', null); }

function squad_control_block(dialog) { dialog.widgets['loading_rect'].show = dialog.widgets['loading_text'].show = dialog.widgets['loading_spinner'].show = true; };
function squad_control_unblock(dialog) { dialog.widgets['loading_rect'].show = dialog.widgets['loading_text'].show = dialog.widgets['loading_spinner'].show = false; };

function squad_control_refresh(dialog) {
    // get rid of old squad widgets
    var to_remove = [];
    for(var name in dialog.widgets) {
        if(name.indexOf('squad') === 0) {
            to_remove.push(name);
        }
    }

    goog.array.forEach(to_remove, function(name) { dialog.remove(dialog.widgets[name]); delete dialog.widgets[name]; });

    var cur_squads = goog.object.getCount(player.squads);
    var builder = find_object_by_type(gamedata['squad_building']);
    var show_add_button = (dialog.user_data['dlg_mode'] == 'normal' || dialog.user_data['dlg_mode'] == 'manage') &&
        ((cur_squads-1 < player.stattab['max_squads'] ||
          !builder ||
          (builder && (builder.level < builder.get_max_ui_level()))));
    var need_tiles = cur_squads + (show_add_button ? 1 : 0);
    dialog.user_data['columns'] = (need_tiles <= (dialog.data['widgets']['squad']['array_max'][0]*dialog.data['widgets']['squad']['array_max'][1]) ? Math.min(dialog.data['widgets']['squad']['array_max'][0], need_tiles) : Math.floor((need_tiles+1)/2));
    // sort squads by ID
    var squad_ids = goog.array.map(goog.object.getKeys(player.squads), function(x) { return parseInt(x,10); }).sort();
    var grid_x = 0, grid_y = 0;
    goog.array.forEach(squad_ids, function (id) {
        make_squad_tile(dialog, player.squads[id.toString()], [grid_x,grid_y], dialog.user_data['dlg_mode']);
        grid_x += 1; if(grid_x >= dialog.user_data['columns']) { grid_x = 0; grid_y += 1; }
    });
    // add-squad button
    if(show_add_button) {
        make_squad_tile(dialog, null, [grid_x, grid_y], dialog.user_data['dlg_mode']);
    }

    dialog.user_data['scroll_limits'] = [0, Math.max(0, (dialog.user_data['columns']-1) * dialog.data['widgets']['squad']['array_offset'][0] - dialog.widgets['sunken'].wh[0] - dialog.widgets['sunken'].xy[0] + dialog.data['widgets']['squad']['xy'][0] + dialog.data['widgets']['squad']['dimensions'][0] + 1)];
    var scroller = function(incr) { return function(w) {
        var dialog = w.parent;
        dialog.user_data['scroll_goal'] = clamp(dialog.user_data['scroll_goal']+dialog.data['widgets']['squad']['array_offset'][0]*incr,
                                                dialog.user_data['scroll_limits'][0], dialog.user_data['scroll_limits'][1]);
        if(incr > 0) { dialog.user_data['scrolled'] = true; }
    }; };
    dialog.widgets['scroll_left'].onclick = scroller(-2);
    dialog.widgets['scroll_right'].onclick = scroller(2);

    // set initial scroll parameters
    if(dialog.user_data['last_columns'] != dialog.user_data['columns']) {
        dialog.user_data['scroll_pos'] = 0;
        dialog.user_data['scroll_goal'] = 0;
        scroller(0)(dialog.widgets['scroll_left']);
        dialog.user_data['last_columns'] = dialog.user_data['columns'];
    }

    // run the on_mousemove handler to reset hover states
    var offset = [0,0]; if(dialog.parent) { for(var d = dialog.parent; d; d = d.parent) { offset = vec_add(offset, d.xy); } }
    dialog.on_mousemove([mouse_state.last_raw_x, mouse_state.last_raw_y], offset);
}

function update_squad_control(dialog) {
    if(dialog.widgets['loading_text'].show) {
        var prog = (session.region.data ? session.region.refresh_progress() : -1);
        if(prog >= 0) {
            prog = Math.min(prog, 0.99);
            dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name_progress'].replace('%pct', (100.0*prog).toFixed(0));
        } else {
            dialog.widgets['loading_text'].str = dialog.data['widgets']['loading_text']['ui_name'];
        }
    }

    if(dialog.user_data['scroll_pos'] != dialog.user_data['scroll_goal']) {
        var delta = dialog.user_data['scroll_goal'] - dialog.user_data['scroll_pos'];
        var sign = (delta > 0 ? 1 : -1);
        dialog.user_data['scroll_pos'] += sign * Math.floor(0.15 * Math.abs(delta) + 0.5);
    }
    dialog.widgets['scroll_left'].state = (dialog.user_data['scroll_goal'] <= dialog.user_data['scroll_limits'][0] ? 'disabled' : 'normal');
    dialog.widgets['scroll_right'].state = (dialog.user_data['scroll_goal'] >= dialog.user_data['scroll_limits'][1] ? 'disabled' : 'normal');

    for(var grid_x = 0; grid_x < dialog.user_data['columns']; grid_x += 1) {
        for(var grid_y = 0; grid_y < dialog.data['widgets']['squad']['array'][1]; grid_y += 1) {
            var wname = 'squad'+grid_x.toString()+','+grid_y.toString();
            if(wname in dialog.widgets) {
                dialog.widgets[wname].xy = vec_add(vec_add(vec_mul([grid_x,grid_y], dialog.data['widgets']['squad']['array_offset']), [-dialog.user_data['scroll_pos'],0]), dialog.data['widgets']['squad']['xy']);
            }
        }
    }
}
function update_create_squad_tile(d) {
    var pred = {'predicate':'LIBRARY', 'name':'squad_play_requirement'};
    var tooltip = null;
    if(goog.object.getCount(player.squads)-1 >= player.stattab['max_squads']) {
        // cannot create more squads, upgrade building first
        var builder = find_object_by_type(gamedata['squad_building']);
        if(!builder) {
            pred = {'predicate': 'AND', 'subpredicates': [
                {'predicate': 'BUILDING_LEVEL', 'building_type': gamedata['squad_building'], 'trigger_level': 1},
                pred]};
        } else {
            var next_level = get_next_level_with_stat_increase(builder.spec, 'provides_squads', builder.level);
            if(next_level < 0) {
                tooltip = gamedata['errors']['CANNOT_CREATE_SQUAD_MAX_LIMIT_REACHED']['ui_name'];
                pred = {'predicate': 'ALWAYS_FALSE', 'ui_name': tooltip};
            } else {
                pred = {'predicate': 'AND', 'subpredicates': [
                    {'predicate': 'BUILDING_LEVEL', 'building_type': gamedata['squad_building'], 'trigger_level': next_level},
                    pred]};
            }
        }
    }
    var rpred = read_predicate(pred);
    var pred_ok = rpred.is_satisfied(player, null);

    d.widgets['create_button'].state = (!pred_ok ? 'disabled_clickable' : 'normal');
    d.widgets['create_button'].tooltip.str = (!pred_ok ? tooltip : null);
    d.widgets['create_button'].onclick = (!pred_ok ? function(w) {
        var helper = get_requirements_help(rpred);
        if(helper) { helper(); }
    } : function(w) {
        var _d = w.parent, _dialog = _d.parent;
        squad_control_block(_dialog);
        var cur_squads = goog.object.getCount(player.squads)-1;
        var ui_name = gamedata['strings']['icao_alphabet'][(cur_squads+1) % 26].toUpperCase();
        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_CREATE", ui_name]);
    });
}

function make_squad_tile(dialog, squad_data, ij, dlg_mode) {
    var template;
    if(squad_data) {
        // display a squad
        template = 'squad_tile';
    } else {
        // display a message instead
        template = 'create_squad_tile';
    }

    var d = new SPUI.Dialog(gamedata['dialogs'][template], dialog.data['widgets']['squad']);
    d.xy = vec_add(dialog.data['widgets']['squad']['xy'], vec_mul(ij, dialog.data['widgets']['squad']['array_offset']));
    var name = 'squad'+ij[0].toString()+','+ij[1].toString();
    if(name in dialog.widgets) {
        throw Error('double-create of '+name+': '+dialog.widgets[name].get_address());
    }
    dialog.widgets[name] = d;
    dialog.add_before(dialog.widgets['loading_rect'], d);

    if(template === 'create_squad_tile') {
        d.ondraw = update_create_squad_tile;
    } else if(squad_data) {
        d.user_data['squad_id'] = squad_data['id'];
        d.user_data['icon_unit_specname'] = null;
        d.widgets['manage_button'].onclick = function(w) {
            invoke_squad_manage(w.parent.user_data['squad_id']);
        };
        d.widgets['delete_button'].onclick = function(w) {
            var _d = w.parent, _dialog = _d.parent;

            var delete_func = (function (__d, __dialog) { return function() {
                squad_control_block(__dialog);
                send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_DELETE", __d.user_data['squad_id']]);
            }; })(_d, _dialog);

            squad_delete_confirm(_d.user_data['squad_id'], delete_func);
        };

        // special modes
        if(dlg_mode == 'deploy') {
            d.widgets['deploy_button'].onclick = function(w) {
                if(resolve_squad_deployment_problem()) { return; }

                // navigate back to the regional map
                // parent is squad_tile, parent.parent is squad_control, parent.parent.parent is map dialog
                var _squad_tile = w.parent;
                if(_squad_tile) {
                    var squad_id = _squad_tile.user_data['squad_id'];

                    // note: most error cases are handled by the 'can_do_action' logic in update_squad_tile

                    var _squad_control = _squad_tile.parent;
                    if(_squad_control) {
                        var _map_dialog = _squad_control.parent;
                        if(_map_dialog && _map_dialog.user_data['dialog'] == 'region_map_dialog') {
                            // yay we got it
                            // close squad control to get back to the map

                            // pop up deployment cursor
                            var from_loc = _squad_control.user_data['deploy_from'];
                            var icon_assetname = _squad_tile.widgets['unit_icon0,0'].widgets['icon'].asset;
                            _map_dialog.widgets['map'].invoke_deploy_cursor(from_loc, squad_id, icon_assetname);
                        }
                    }
                    close_parent_dialog(_squad_tile);
                }
            }
        } else if(dlg_mode == 'call') {
            d.widgets['call_button'].onclick = function(w) {
                // navigate back to the regional map
                // parent is squad_tile, parent.parent is squad_control, parent.parent.parent is map dialog
                var _squad_tile = w.parent;
                if(_squad_tile) {
                    var squad_id = _squad_tile.user_data['squad_id'];
                    var squad_data = player.squads[squad_id.toString()];
                    var _squad_control = _squad_tile.parent;
                    if(_squad_control) {
                        var to_loc = _squad_control.user_data['call_to'];
                        // note: most error cases are handled by the 'can_do_action' logic in update_squad_tile
                        if(player.squad_is_deployed(squad_id)) {
                            // queue movement
                            player.squad_set_client_data(squad_id, 'squad_orders', {'move': to_loc});
                        } else {
                            if(resolve_squad_deployment_problem()) { return; }

                            // find a place to deploy the squad
                            var neighbors = session.region.get_neighbors(player.home_base_loc);
                            var deploy_at = null;
                            goog.array.forEach(neighbors, function(xy) {
                                if(!session.region.find_feature_at_coords(xy)) {
                                    deploy_at = xy;
                                }
                            });
                            if(!deploy_at) {
                                var s = gamedata['errors']['INVALID_MAP_LOCATION'];
                                invoke_child_message_dialog(s['ui_title'], s['ui_name'].replace('%BATNAME', squad_data['ui_name']), {'dialog':'message_dialog_big'});
                                return;
                            }
                            // perform deployment
                            player.squads[squad_id.toString()]['pending'] = true;
                            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_ENTER_MAP", squad_id, deploy_at]);
                            // queue movement
                            player.squad_set_client_data(squad_id, 'squad_orders', {'move': to_loc});

                            // play movement sound
                            if(_squad_tile.user_data['icon_unit_specname']) {
                                var spec = gamedata['units'][_squad_tile.user_data['icon_unit_specname']];
                                if('sound_destination' in spec) {
                                    GameArt.assets[spec['sound_destination']].states['normal'].audio.play(client_time);
                                }
                            }
                        }
                    }
                    close_parent_dialog(_squad_tile);
                }
            }
        }
        d.ondraw = update_squad_tile;
    }
}

var SQUAD_IDS = { BASE_DEFENDERS: 0, RESERVES: -1,
                  is_mobile_squad_id: function(id) { return id > 0; }
                };

// return [cur,max] HP for a persisted unit
function army_unit_hp(obj) {
    var level = obj['level'] || 1;
    var spec = gamedata['units'][obj['spec']];
    var max_hp = ('max_hp' in obj ? obj['max_hp'] : get_leveled_quantity(spec['max_hp']||0, level));
    var cur_hp;
    if('hp' in obj) {
        cur_hp = obj['hp'];
    } else if('hp_ratio' in obj) {
        cur_hp = Math.floor(obj['hp_ratio'] * max_hp);
    } else {
        cur_hp = max_hp;
    }
    return [cur_hp, max_hp];
}
function army_unit_space(obj) {
    var level = obj['level'] || 1;
    var spec = gamedata['units'][obj['spec']];
    return get_leveled_quantity(spec['consumes_space']||0, level);
}
// returns: 0 if not under repair, 1 if queued, 2 if active
function army_unit_repair_state(obj) {
    for(var i = 0; i < player.unit_repair_queue.length; i++) {
        var item = player.unit_repair_queue[i];
        if(item['obj_id'] == obj['obj_id']) {
            return (i == 0 ? 2 : 1);
        }
    }
    return 0;
}

// used for sorting units in squad displays
function army_unit_compare(a,b) {
    // sort by "coolness" then health
    var aspc = get_leveled_quantity(gamedata['units'][a['spec']]['consumes_space'],1);
    var bspc = get_leveled_quantity(gamedata['units'][b['spec']]['consumes_space'],1);
    if(aspc < bspc) { return 1; }
    if(aspc > bspc) { return -1; }
    var acurmax = army_unit_hp(a), aratio = acurmax[0]/Math.max(acurmax[1],1);
    var bcurmax = army_unit_hp(b), bratio = bcurmax[0]/Math.max(bcurmax[1],1);
    if(aratio < bratio) { return 1; }
    if(aratio > bratio) { return -1; }
    return 0;
}
function army_unit_compare_specnames(a,b) {
    // sort by "coolness"
    var aspc = get_leveled_quantity(gamedata['units'][a]['consumes_space'],1);
    var bspc = get_leveled_quantity(gamedata['units'][b]['consumes_space'],1);
    if(aspc < bspc) { return 1; }
    if(aspc > bspc) { return -1; }
    return 0;
}

player.get_manufacture_queue_space_usage = function() {
    var usage = 0;
    goog.object.forEach(session.cur_objects.objects, function(obj) {
        if(obj.team === 'player' && obj.is_building() && obj.is_manufacturer()) {
            var manuf_queue = obj.get_client_prediction('manuf_queue', obj.manuf_queue);
            goog.array.forEach(manuf_queue, function(item) {
                var space = get_leveled_quantity(gamedata['units'][item['spec_name']]['consumes_space']||0, item['level']||1);
                usage += space;
            });
        }
    });
    return usage;
};

/** @return {Object.<string,number>} */
player.get_army_unit_count_by_specname = function() {
    var ret = {};
    // count objects in army
    goog.object.forEach(player.my_army, function(obj) {
        ret[obj['spec']] = (ret[obj['spec']]||0) + 1;
    });
    // also count units that are under construction
    goog.object.forEach(session.cur_objects.objects, function(obj) {
        if(obj.team === 'player' && obj.is_building() && obj.is_manufacturer()) {
            var manuf_queue = obj.get_client_prediction('manuf_queue', obj.manuf_queue);
            goog.array.forEach(manuf_queue, function(item) {
                ret[item['spec_name']] = (ret[item['spec_name']]||0) + 1;
            });
        }
    });
    return ret;
};

/** @return {Object.<string,number>} */
player.get_army_space_usage_by_squad = function() {
    var reserve_sid = SQUAD_IDS.RESERVES.toString();
    var ret = {'ALL': 0}; ret[reserve_sid] = 0;
    goog.object.forEach(player.squads, function(squad) { ret[squad['id'].toString()] = 0; });
    goog.object.forEach(player.my_army, function(obj) {
        var squad_id = obj['squad_id'] || 0;
        var space = army_unit_space(obj);
        ret[squad_id.toString()] += space;
        ret['ALL'] += space;
    });
    // also add space occupied by units that are under construction
    var space = player.get_manufacture_queue_space_usage();
    if(player.squads_enabled() && !gamedata['produce_to_reserves']) {
        ret[SQUAD_IDS.BASE_DEFENDERS.toString()] += space;
    }
    ret['ALL'] += space;
    return ret;
};

player.get_squad_hp_and_space = function(squad_id) {
    var cur_space = 0;
    var max_space = (squad_id === SQUAD_IDS.BASE_DEFENDERS ? player.stattab['main_squad_space'] : player.stattab['squad_space']);
    var cur_hp = 0, max_hp = 0;
    goog.object.forEach(player.my_army, function(obj, obj_id) {
        if((obj['squad_id']||0) !== squad_id) { return; }
        var spec = gamedata['units'][obj['spec']];
        var level = obj['level'] || 1;
        cur_space += get_leveled_quantity(spec['consumes_space']||0, level);
        var curmax = army_unit_hp(obj);
        cur_hp += curmax[0];
        max_hp += curmax[1];
    });
    return {'cur_space':cur_space, 'max_space':max_space, 'cur_hp':cur_hp, 'max_hp': max_hp};
};

player.which_squad_is_under_repair = function() {
    var squad_under_repair = null;
    for(var i = 0; i < player.unit_repair_queue.length; i++) {
        var item = player.unit_repair_queue[i];
        var obj = player.my_army[item['obj_id']] || null;
        if(!obj) { continue; }
        var squad_id = obj['squad_id'] || 0;
        squad_under_repair = squad_id;
        break;
    }
    return squad_under_repair;
};
player.squad_is_under_repair = function(squad_id) { return squad_id == player.which_squad_is_under_repair(); };
player.squad_is_deployed = function(squad_id) {
    var key = squad_id.toString();
    return (key in player.squads && ('map_loc' in player.squads[key]));
};
player.squad_base_id = function(squad_id) { return 's'+session.user_id.toString()+'_'+squad_id.toString(); };
player.squad_is_in_battle = function(squad_id) {
    var key = squad_id.toString();
    if(player.squad_is_deployed(squad_id) && session.region && session.region.data) {
        var feature = session.region.find_feature_by_id(player.squad_base_id(squad_id));
        if(feature && feature['LOCK_STATE']) { return true; }
    }
    return false;
};
player.squad_is_dead = function(squad_id) {
    var cur_hp = 0, max_hp = 0;
    goog.object.forEach(player.my_army, function(obj, obj_id) {
        if((obj['squad_id']||0) !== squad_id) { return; }
        var curmax = army_unit_hp(obj);
        cur_hp += curmax[0];
        max_hp += curmax[1];
    });
    return (max_hp > 0 && cur_hp <= 0);
};
player.squad_is_empty = function(squad_id) {
    for(var obj_id in player.my_army) {
        if((player.my_army[obj_id]['squad_id']||0) == squad_id) { return false; }
    }
    return true;
};
player.squad_set_client_data = function(squad_id, k, v) {
    var key = squad_id.toString();
    if(!(key in player.squad_client_data)) { player.squad_client_data[key] = {}; }
    player.squad_client_data[key][k] = v;
};
player.squad_get_client_data = function(squad_id, k) {
    var key = squad_id.toString();
    if(!(key in player.squad_client_data)) { return null; }
    return player.squad_client_data[key][k];
};
player.squad_clear_client_data = function(squad_id) {
    var key = squad_id.toString();
    if(!(key in player.squad_client_data)) { return; }
    delete player.squad_client_data[key];
};

player.squad_travel_time = function(squad_id, path) {
    var squad_data = player.squads[squad_id.toString()];
    return (path.length/(gamedata['territory']['unit_travel_speed_factor']*get_player_stat(player.stattab,'travel_speed')*(squad_data['travel_speed']||1)));
};

// return a path that leads to hex "dest", or immediately adjacent to it
player.squad_find_path_adjacent_to = function(squad_id, dest) {
    if(!session.region || !session.region.data) { return null; }
    if(player.squad_is_moving(squad_id)) { throw Error('squad '+squad_id.toString()+' is still moving'); }
    var squad_data = player.squads[squad_id.toString()];

    if(!squad_data['map_loc']) { throw Error('squad '+squad_id.toString()+' is not deployed'); }
    if(!dest) { throw Error('squad '+squad_id.toString()+' given null/undefined destination'); }

    // note! A* code tends to blow up memory/CPU if you ask it to go into a blocked destination

    // When pass_moving_squads is enabled, allow travel through hexes that are reserved as the destination
    // of another squad before its arrival time. This requires a path-dependent blockage check, since the
    // arrival time to check against depends on how long it takes us to get ther.

    /** @type AStar.PathChecker */
    var path_checker = null;
    if(gamedata['territory']['pass_moving_squads']) {
        path_checker = function (_squad_id, _dest) { return function(cell, path) {
            if(cell.block_count > 0) {
                for(var i = 0; i < cell.blockers.length; i++) {
                    var feature = cell.blockers[i];
                    if(session.region.feature_is_moving(feature)) {
                        var last_waypoint = feature['base_map_path'][feature['base_map_path'].length-1];
                        var their_arrival_time = last_waypoint['eta'];
                        var fudge_time = gamedata['territory']['pass_moving_squads_fudge_time'] || 0; // give some conservative leeway for network latency, otherwise players could get frustrated

                        if(!vec_equals(last_waypoint['xy'], cell.pos)) {
                            throw Error('last_waypoint '+JSON.stringify(last_waypoint)+' of feature '+JSON.stringify(feature)+' does not match cell.pos '+JSON.stringify(cell.pos));
                        }

                        if(!vec_equals(_dest, cell.pos) && // this exception does not apply to our final destination cell
                           their_arrival_time > server_time + player.squad_travel_time(_squad_id, path) + fudge_time) {
                            continue; // not necessarily blocked! (there might be another feature here though)
                        }
                    }
                    return true; // blocked by this feature
                }
            }
            return false; // not blocked
        }; };
    }

    // if dest is not blocked, try going directly there
    if(!session.region.occupancy.is_blocked(dest)) {
        var path = session.region.hstar_context.search(squad_data['map_loc'], dest, path_checker ? path_checker(squad_id, dest) : null);
        if(path && path.length >= 1 && hex_distance(path[path.length-1], dest) == 0) {
            return path; // good path
        }
    }

    // try aiming for neighbor squares around "dest"
    var neighbors = session.region.get_neighbors(dest);
    var best_path = null;
    var best_travel_time = -1;

    for(var i = 0; i < neighbors.length; i++) {
        var n = neighbors[i];
        if(!session.region.occupancy.is_blocked(n)) {
            var path = session.region.hstar_context.search(squad_data['map_loc'], n, path_checker ? path_checker(squad_id, n) : null);
            // path must lead INTO n
            if(path && path.length >= 1 && hex_distance(path[path.length-1], n) == 0) {
                // good path

                // trim off unnecessary extra moves at the end of the path that just circle around the destination hex
                // note: need to check for blockage on this intermediate waypoint before changing the final destination to it,
                // because it might be the destination of another moving squad, where we aren't allowed to land.
                while(path.length >= 2 && hex_distance(path[path.length-2], dest) == 1 && !session.region.occupancy.is_blocked(path[path.length-2])) {
                    goog.array.removeAt(path, path.length-1);
                }
                var travel_time = player.squad_travel_time(squad_id, path);
                if(best_path === null || travel_time  < best_travel_time) {
                    best_path = path;
                    best_travel_time = travel_time;
                }
                //return path;
            }
        }
    }

    return best_path;
};


player.squad_is_moving = function(squad_id) {
    var squad_data = player.squads[squad_id.toString()];
    return (('map_loc' in squad_data) &&
            (('map_path' in squad_data) && (squad_data['map_path'][squad_data['map_path'].length-1]['eta'] > server_time)));
};
player.squad_interpolate_pos_and_heading = function(squad_id) {
    var squad_data = player.squads[squad_id.toString()];
    if(player.squad_is_moving(squad_id)) {
        var path = squad_data['map_path'];
        var last_waypoint = path[0];
        for(var i = 1; i < path.length; i++) {
            var waypoint = path[i];
            if(waypoint['eta'] > server_time) {
                var delta = vec_sub(waypoint['xy'], last_waypoint['xy']);
                return [vec_add(last_waypoint['xy'], vec_scale((server_time-last_waypoint['eta'])/(waypoint['eta']-last_waypoint['eta']),delta)),
                        Math.atan2(delta[1], delta[0])];
            }
            last_waypoint = waypoint;
        }
    } else {
        return [squad_data['map_loc'], 0];
    }
};

// it is optional to provide the path home

/** @param {number} squad_id
    @param {Array.<Array.<number>>|null=} path */
player.squad_recall = function(squad_id, path) {
    if(player.squad_is_moving(squad_id)) {
        if(!player.squad_get_client_data(squad_id, 'halt_pending')) {
            player.squad_halt(squad_id);
        }
        player.squad_set_client_data(squad_id, 'squad_orders', {'recall_after_halt': 1, 'recall_path': path || null});
    } else {
        player.squad_recall_move(squad_id, path);
    }
};

player.squad_recall_move = function(squad_id, path) {
    var squad_data = player.squads[squad_id.toString()];

    // note: we can't just use home_base_loc here, because we need to path-find to it!
    var home_feature = session.region.find_home_feature();
    if(home_feature) {
        if(hex_distance(squad_data['map_loc'], player.home_base_loc) <= 1) {
            player.squad_set_client_data(squad_id, 'squad_orders', {'recall':1}); // trigger SQUAD_EXIT_MAP at next opportunity
            return;
        }

        if(!path) { path = player.squad_find_path_adjacent_to(squad_id, player.home_base_loc); }

        if(path) {
            player.squad_move(squad_id, path);
            player.squad_set_client_data(squad_id, 'squad_orders', {'recall':1}); // trigger SQUAD_EXIT_MAP at next opportunity
            return;
        }

        // uh oh, no way home!
        var s = gamedata['errors']['CANNOT_RECALL_SQUAD_MAP_BLOCKED'];
        invoke_child_message_dialog(s['ui_title'], s['ui_name'], {'dialog':'message_dialog_big'});
    }
};

player.squad_halt = function(squad_id) {
    if(!player.squad_is_moving(squad_id)) { throw Error('squad_halt but squad '+squad_id.toString()+' is not moving'); }
    var squad_data = player.squads[squad_id.toString()];
    squad_data['pending'] = true;
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_STEP", squad_id, null]);
    player.squad_clear_client_data(squad_id); // erase current movement orders
    player.squad_set_client_data(squad_id, 'halt_pending', true); // wait for squad to stop before issuing new orders
};
player.squad_move = function(squad_id, path) {
    if(player.squad_is_moving(squad_id)) { throw Error('squad_move but squad '+squad_id.toString()+' is still moving'); }
    if(!path || path.length < 1) { throw Error('squad_move with invalid path'); }
    var squad_data = player.squads[squad_id.toString()];
    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_STEP", squad_id, path]);
    player.squad_clear_client_data(squad_id); // erase current movement orders
    player.squad_set_client_data(squad_id, 'move_pending', squad_data['map_loc']); // wait for squad to move before issuing new orders - remember original loc

    // client-side predict - assumes success, may get corrected by server later
    if(gamedata['client']['predict_squad_movement']) {
        // translate path into xy/eta format for the map feature
        var next_eta = server_time + (-server_time_offset); // add 1x your buest-guess network latency
        next_eta += gamedata['client']['predict_squad_movement_estimated_latency'] || 0; // even more optional latency prediction
        var map_path = [{'xy': squad_data['map_loc'], 'eta': next_eta}];

        for(var i = 0; i < path.length; i++) {
            next_eta += 1.0 / (gamedata['territory']['unit_travel_speed_factor']*get_player_stat(player.stattab, 'travel_speed')*(squad_data['travel_speed']||1.0));
            map_path.push({'xy': path[i], 'eta': next_eta});
        }

        session.region.receive_feature_update({'base_id':player.squad_base_id(squad_id),
                                               'base_map_path': map_path,
                                               'base_map_loc': path[path.length-1]});
        squad_data['map_loc'] = path[path.length-1];
        squad_data['map_path'] = map_path;
    }
};

player.advance_squads = function() {
    goog.object.forEach(player.squads, function(squad_data) {
        // don't touch squads that are involved in the current battle
        if(session.has_attacked && goog.array.contains(session.deployable_squads, squad_data['id'])) { return; }

        // when a "Halt" is issued, the server will respond with SQUADS_UPDATE with a new path, but the
        // squad will still need to move to the nearest cell before it really halts. We have to track
        // this state transition in order to gray out "Halt" buttons until the squad really stops
        if(player.squad_get_client_data(squad_data['id'], 'halt_pending') && !player.squad_is_moving(squad_data['id'])) {
            player.squad_set_client_data(squad_data['id'], 'halt_pending', false);
        }

        // reset "move_pending" flag if squad is actually moving, or if we found it somewhere other than where it was when we started the move
        if(player.squad_get_client_data(squad_data['id'], 'move_pending') &&
           (!player.squad_is_deployed(squad_data['id']) ||
            player.squad_is_moving(squad_data['id']) ||
            !vec_equals(squad_data['map_loc'], player.squad_get_client_data(squad_data['id'], 'move_pending')))) {
            player.squad_set_client_data(squad_data['id'], 'move_pending', false);
        }

        // don't try to drive squads around outside home base (only because the server doesn't take the commands)
        if(!session.home_base) { return; }

        var orders = player.squad_get_client_data(squad_data['id'], 'squad_orders');
        if(!orders) { return; }
        if('recall_after_halt' in orders) {
            if(!player.squad_is_moving(squad_data['id'])) {
                player.squad_set_client_data(squad_data['id'], 'squad_orders', null);
                player.squad_recall_move(squad_data['id'], orders['recall_path']);
            }
        } else if('recall' in orders) {
            if(player.squad_is_moving(squad_data['id'])) {
                // wait til it stops (assumes recall is preceded by a halt)
            } else if(!player.squad_is_deployed(squad_data['id'])) {
                // already made it home
                player.squad_clear_client_data(squad_data['id']);
            } else {
                // not moving
                if(hex_distance(squad_data['map_loc'], player.home_base_loc) <= 1 &&
                   !squad_data['pending']) {
                    squad_data['pending'] = true;
                    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_EXIT_MAP", squad_data['id']]);
                    player.squad_clear_client_data(squad_data['id']);
                }
            }
        } else if('move' in orders) {
            var dest = orders['move'];
            if(player.squad_is_deployed(squad_data['id']) && !player.squad_is_moving(squad_data['id'])) {
                if(hex_distance(squad_data['map_loc'], dest) <= 1) {
                    // already there
                } else {
                    var path = player.squad_find_path_adjacent_to(squad_data['id'], dest);
                    if(path && path.length >= 1 && hex_distance(path[path.length-1], dest) <= 1) {
                        player.squad_move(squad_data['id'], path);
                    } else {
                        var s = gamedata['errors']['INVALID_MAP_LOCATION'];
                        invoke_child_message_dialog(s['ui_title'], s['ui_name'].replace('%BATNAME', squad_data['ui_name']), {'dialog':'message_dialog_big'});
                    }
                }
                player.squad_clear_client_data(squad_data['id']);
            }
        }
    });
};

// put up the GUI confirmation, if necessary
function squad_delete_confirm(squad_id, finisher_cb) {
    var usage = player.get_army_space_usage_by_squad();
    if(!usage[squad_id.toString()]) {
        // no confirm for empty squads
        finisher_cb();
    } else {
        var s = gamedata['strings']['squad_delete_confirm'];
        invoke_child_message_dialog(s['ui_title'],
                                    s['ui_description'],
                                    {'cancel_button': true,
                                     'ok_button_ui_name': s['ui_button'],
                                     'on_ok': finisher_cb});
    }
};

function update_squad_tile(dialog) {
    var dlg_mode;
    if(dialog.parent) {
        dlg_mode = dialog.parent.user_data['dlg_mode'];
    } else {
        return; // orphaned
    }

    // treat manage the same as normal here
    if(dlg_mode == 'manage') { dlg_mode = 'normal'; }

    var squad_data = player.squads[dialog.user_data['squad_id'].toString()];
    dialog.widgets['name'].str = squad_data['ui_name'];

    var units_by_type = {};
    var max_space = (dialog.user_data['squad_id'] === SQUAD_IDS.BASE_DEFENDERS ? player.stattab['main_squad_space'] : player.stattab['squad_space']);
    var cur_space = 0, max_hp = 0, cur_hp = 0;
    var squad_is_damaged = false, squad_is_destroyed = true;
    var cost_to_repair = {};

    goog.object.forEach(player.my_army, function(obj, obj_id) {
        if((obj['squad_id']||0) !== dialog.user_data['squad_id']) { return; }
        units_by_type[obj['spec']] = (units_by_type[obj['spec']]||0) + 1;
        var spec = gamedata['units'][obj['spec']];
        var level = obj['level'] || 1;
        cur_space += get_leveled_quantity(spec['consumes_space']||0, level);
        var curmax = army_unit_hp(obj);
        cur_hp += curmax[0];
        max_hp += curmax[1];
        if(curmax[0] > 0) { squad_is_destroyed = false; }
        if(curmax[0] < curmax[1]) {
            if((army_unit_repair_state(obj) == 0) && player.can_repair_unit_of_spec(spec, curmax[0])) {
                squad_is_damaged = true;
                var mycost = mobile_cost_to_repair(spec, level, curmax[0], curmax[1], player);
                for(var resname in gamedata['resources']) {
                    cost_to_repair[resname] = (cost_to_repair[resname]||0) + mycost[resname];
                }
                cost_to_repair['time'] = (cost_to_repair['time']||0) + mycost['time'];
            }
        }
    });

    var squad_is_deployed = player.squad_is_deployed(squad_data['id']);
    var squad_is_under_repair = player.squad_is_under_repair(squad_data['id']);
    var squad_in_battle = player.squad_is_in_battle(squad_data['id']);

    dialog.widgets['space_bar'].progress = cur_space / Math.max(max_space,1);
    dialog.widgets['hp_bar'].progress = (max_hp > 0 ? (cur_hp/max_hp) : 0);

    var my_status, my_status_s = '';
    if(squad_data['id'] === SQUAD_IDS.BASE_DEFENDERS) {
        my_status = 'defending_home_base';
    } else if(squad_in_battle) {
        my_status = 'in_battle';
        my_status_s = squad_data['map_loc'][0].toString()+','+squad_data['map_loc'][1].toString();
    } else if(cur_space <= 0) {
        my_status = 'empty';
    } else if(cur_hp <= 0) {
        my_status = 'destroyed';
    } else if(squad_is_deployed) {
        if(player.squad_is_moving(squad_data['id'])) {
            var orders = player.squad_get_client_data(squad_data['id'], 'squad_orders');
            if(orders && (('recall' in orders) || ('recall_after_halt' in orders))) {
                my_status = 'returning_to_home_base';
            } else {
                my_status = 'traveling';
                my_status_s = squad_data['map_loc'][0].toString()+','+squad_data['map_loc'][1].toString();
            }
        } else {
            var feat = (session.region.map_enabled() ? session.region.find_feature_at_coords(squad_data['map_loc']) : null);
            if(feat && feat['base_type'] == 'quarry') {
                my_status = 'quarry';
                my_status_s = feat['base_ui_name'];
            } else {
                my_status = 'deployed';
                my_status_s = '('+squad_data['map_loc'][0].toString()+','+squad_data['map_loc'][1].toString()+')';
            }
        }
    } else if(squad_is_under_repair) {
        my_status = 'under_repair';
    } else if(squad_is_damaged) {
        my_status = 'damaged';
    } else {
        my_status = 'ready';
    }
    dialog.widgets['status'].str = gamedata['strings']['squads']['status'][my_status].replace('%s', my_status_s);
    dialog.widgets['bg'].color = SPUI.make_colorv(dialog.data['widgets']['bg']['color_'+my_status]);
    dialog.widgets['status'].text_color = dialog.widgets['bg'].outline_color = SPUI.make_colorv(dialog.data['widgets']['bg']['outline_color_'+my_status]);

    var types_to_show = goog.object.getKeys(units_by_type);
    types_to_show.sort(army_unit_compare_specnames);

    dialog.user_data['icon_unit_specname'] = (types_to_show.length >= 1 ? types_to_show[0] : null);

    var i = 0, grid_x = 0, grid_y = 0;
    while(i < types_to_show.length && grid_y < dialog.data['widgets']['unit_icon']['array'][1]) {
        var wname = grid_x.toString()+','+grid_y.toString();
        unit_icon_set(dialog.widgets['unit_icon'+wname], types_to_show[i], units_by_type[types_to_show[i]], null, null,
                      (squad_is_under_repair || squad_is_deployed ? 'disabled' : null));
        i += 1;
        grid_x += 1;
        if(grid_x >= dialog.data['widgets']['unit_icon']['array'][0]) { grid_x = 0; grid_y += 1; }
    }
    while(grid_y < dialog.data['widgets']['unit_icon']['array'][1]) {
        while(grid_x < dialog.data['widgets']['unit_icon']['array'][0]) {
            var wname = grid_x.toString()+','+grid_y.toString();
            unit_icon_set(dialog.widgets['unit_icon'+wname], null, -1, null, null);
            grid_x += 1;
        }
        grid_x = 0; grid_y += 1;
    }

    var hover = (dialog.mouse_enter_time > 0) && (dialog.parent.mouse_enter_time > 0);
    var can_do_action = false; // apples when dlg_mode is deploy or call
    var repair_in_sync = synchronizer.is_in_sync(unit_repair_sync_marker);

    if(dlg_mode == 'normal') {
        dialog.widgets['coverup'].show = hover || squad_is_under_repair || squad_in_battle || (!squad_is_deployed && squad_is_damaged);
    } else if(dlg_mode == 'deploy' || dlg_mode == 'call') {
        can_do_action = !(squad_is_under_repair || squad_in_battle || !SQUAD_IDS.is_mobile_squad_id(dialog.user_data['squad_id']) || ((dlg_mode=='deploy') && squad_is_deployed) || squad_is_destroyed || (cur_space <= 0)); // || (my_status == 'quarry'));
        dialog.widgets['coverup'].show = hover || !can_do_action;
    }

    dialog.widgets['delete_button'].show = (dlg_mode=='normal') && hover && SQUAD_IDS.is_mobile_squad_id(dialog.user_data['squad_id']) && !squad_is_deployed && !squad_in_battle;
    dialog.widgets['manage_button'].show = (dlg_mode=='normal') && hover && !squad_in_battle;

    dialog.widgets['deploy_button'].show = (dlg_mode=='deploy') && hover && can_do_action;
    dialog.widgets['call_button'].show = (dlg_mode=='call') && hover && can_do_action;
    dialog.widgets['deploy_button'].state = dialog.widgets['call_button'].state = (can_do_action && !squad_data['pending'] ? 'normal' : 'disabled');

    dialog.widgets['repair_remain_bg'].show =
        dialog.widgets['repair_remain_icon'].show =
        dialog.widgets['repair_remain_value'].show =
        dialog.widgets['finish_button'].show =
        dialog.widgets['price_display'].show = (dlg_mode=='normal') && squad_is_under_repair && !squad_in_battle;
    dialog.widgets['price_spinner'].show = (dialog.widgets['price_display'].show && !repair_in_sync);
    dialog.widgets['cancel_button'].show = (dlg_mode=='normal') && squad_is_under_repair && !squad_in_battle && hover;

    if(squad_is_under_repair && !squad_in_battle) {
        var repair_togo = player.unit_repair_queue[player.unit_repair_queue.length-1]['finish_time']-server_time;
        dialog.widgets['repair_remain_value'].str = pretty_print_time(repair_togo);
        if(repair_togo <= 1) {
            // start pinging for repair completion
            request_unit_repair_update();
        }

        dialog.widgets['cancel_button'].onclick = function (w) {
            var _dialog = w.parent;
            squad_control_block(_dialog.parent);
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_REPAIR_CANCEL", _dialog.user_data['squad_id']]);
            unit_repair_sync_marker = synchronizer.request_sync();
        };
        dialog.widgets['cancel_button'].state = (repair_in_sync ? 'normal' : 'disabled');

        var price = Store.get_user_currency_price(0, gamedata['spells']['UNIT_REPAIR_SPEEDUP_FOR_MONEY'], null);
        dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_short_asset', gamedata['store']['price_display_short_asset']);
        dialog.widgets['price_display'].state = Store.get_user_currency();
        dialog.widgets['price_display'].str = (!repair_in_sync ? '' : Store.display_user_currency_price(price, 'compact')); // PRICE
        dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'+(!repair_in_sync ? '_pending': '')];
        dialog.widgets['price_display'].tooltip.str = (!repair_in_sync ? null : Store.display_user_currency_price_tooltip(price));
        if(price >= 0) {
            dialog.widgets['finish_button'].onclick = function() {
                if(Store.place_user_currency_order(GameObject.VIRTUAL_ID, "UNIT_REPAIR_SPEEDUP_FOR_MONEY", null, null)) {
                    unit_repair_sync_marker = synchronizer.request_sync();
                    invoke_ui_locker(unit_repair_sync_marker);
                }
            };
            dialog.widgets['finish_button'].state = (repair_in_sync ? 'normal' : 'disabled');
            dialog.widgets['price_display'].onclick = (!repair_in_sync ? null: dialog.widgets['finish_button'].onclick);
        } else {
            if(!player.unit_speedups_enabled()) {
                dialog.widgets['finish_button'].show = dialog.widgets['price_display'].show = false;
            } else {
                dialog.widgets['finish_button'].state = 'disabled';
                dialog.widgets['price_display'].onclick = null;
            }
        }
    }

    //console.log('squad ' +player.squads[dialog.user_data['squad_id'].toString()]['ui_name']+' mode '+dlg_mode+' damaged '+squad_is_damaged+' under_rep '+squad_is_under_repair+' is deployed '+squad_is_deployed+' in battle '+squad_in_battle);

    dialog.widgets['start_repair_button'].show = (dlg_mode=='normal') && (squad_is_damaged && !squad_is_under_repair && !squad_is_deployed && !squad_in_battle);
    dialog.widgets['requirements_bg'].show =
        dialog.widgets['requirements_time_icon'].show =
        dialog.widgets['requirements_time_value'].show = (dlg_mode=='normal') && (squad_is_damaged && !squad_is_under_repair && !squad_is_deployed && !squad_in_battle && hover);
    for(var res in gamedata['resources']) {
        if('requirements_'+res+'_icon' in dialog.widgets) {
            dialog.widgets['requirements_'+res+'_icon'].show =
                dialog.widgets['requirements_'+res+'_value'].show = dialog.widgets['requirements_time_icon'].show;
        }
    }

    if(squad_is_damaged && !squad_is_under_repair && !squad_is_deployed && !squad_in_battle) {
        if(hover) {
            for(var resname in gamedata['resources']) {
                if('requirements_'+resname+'_value' in dialog.widgets) {
                    dialog.widgets['requirements_'+resname+'_value'].str = pretty_print_number(cost_to_repair[resname]||0);
                }
            }
            dialog.widgets['requirements_time_value'].str = pretty_print_time(cost_to_repair['time']||0);
        }
        dialog.widgets['start_repair_button'].state = (repair_in_sync ? 'normal' : 'disabled');
        dialog.widgets['start_repair_button'].str = dialog.data['widgets']['start_repair_button'][(repair_in_sync ? 'ui_name' : 'ui_name_pending')];
        dialog.widgets['start_repair_button'].onclick = function(w) {
            var _dialog = w.parent;
            squad_control_block(_dialog.parent);
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_REPAIR_QUEUE", _dialog.user_data['squad_id']]);
            unit_repair_sync_marker = synchronizer.request_sync();
        };
    }
}

function invoke_squad_manage(squad_id) {
    var squad = player.squads[squad_id.toString()];
    if(!squad) { return; }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['squad_manage']);
    dialog.user_data['dialog'] = 'squad_manage';
    dialog.user_data['squad_id'] = squad_id;
    dialog.user_data['squad'] = squad;
    dialog.user_data['name_changed'] = false;
    dialog.user_data['reserve_scroll_pos'] = 0;
    dialog.user_data['reserve_scroll_goal'] = 0;
    dialog.user_data['reserve_scroll_limits'] = [0,0];
    dialog.user_data['squad_scroll_pos'] = 0;
    dialog.user_data['squad_scroll_goal'] = 0;
    dialog.user_data['squad_scroll_limits'] = [0,0];

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = dialog.widgets['save_button'].onclick = close_parent_dialog;
    dialog.widgets['name_input'].str = squad['ui_name'];
    if(squad_id === SQUAD_IDS.BASE_DEFENDERS) {
        dialog.widgets['name_input_bg'].show = dialog.widgets['name_input'].show = false;
        dialog.widgets['title'].str = squad['ui_name'];
    } else {
        dialog.widgets['name_input'].ontype = function(w) { w.parent.user_data['name_changed'] = true; };
        dialog.widgets['name_input'].ontextready = function(w, str) {
            var _dialog = w.parent;
            if(!str) { w.str = _dialog.user_data['squad']['ui_name']; return; }
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_RENAME", _dialog.user_data['squad_id'], SPHTTP.wrap_string(str)]);
            _dialog.user_data['name_changed'] = false;
        };
    }
    dialog.on_destroy = function(dialog) {
        // send out pending name change
        if(dialog.user_data['name_changed'] && dialog.widgets['name_input'].str && (dialog.user_data['squad_id'].toString() in player.squads)) {
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_RENAME", dialog.user_data['squad_id'], SPHTTP.wrap_string(dialog.widgets['name_input'].str)]);
        }
    };


    dialog.widgets['disband_button'].onclick = function(w) {
        var _dialog = w.parent; var _squad_data = _dialog.user_data['squad'];
        var delete_func = (function (__dialog, __squad_data) { return function() {
            var maybe_squad_control = __dialog.parent;
            close_parent_dialog(__dialog.widgets['disband_button']);
            if(maybe_squad_control && maybe_squad_control.user_data && maybe_squad_control.user_data['dialog'] == 'squad_control') {
                squad_control_block(maybe_squad_control);
            }
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_DELETE", __squad_data['id']]);
        }; })(_dialog, _squad_data);

        squad_delete_confirm(_squad_data['id'], delete_func);
    };

    dialog.widgets['find_on_map_button'].onclick = function(w) {
        var squad_data = w.parent.user_data['squad'];
        if('map_loc' in squad_data) {
            var pos = player.squad_interpolate_pos_and_heading(squad_data['id'])[0];

            // we're usually underneath squad_control which is underneath either the desktop, or an existing map dialog
            var map_dialog;
            if(w.parent.parent && w.parent.parent.parent && w.parent.parent.parent.user_data && w.parent.parent.parent.user_data['dialog'] == 'region_map_dialog') {
                map_dialog = w.parent.parent.parent;
                close_parent_dialog(w.parent.parent);
                map_dialog.widgets['map'].pan_to_cell(pos, {slowly:true});
            } else {
                change_selection_ui(null);
                map_dialog = invoke_region_map(pos);
            }
            if(map_dialog) {
                map_dialog.widgets['map'].follow_travel = false;
                map_dialog.widgets['map'].zoom_all_the_way_in();
            }
        }
    };

    dialog.widgets['halt_button'].onclick = function(w) {
        var squad_data = w.parent.user_data['squad'];
        player.squad_halt(squad_data['id']);
    };

    dialog.widgets['recall_button'].onclick = function(w) {
        var squad_data = w.parent.user_data['squad'];
        player.squad_recall(squad_data['id']);
    };

    var scroller = function(kind, incr) { return function(w) {
        var dialog = w.parent;
        dialog.user_data[kind+'_scroll_goal'] = clamp(dialog.user_data[kind+'_scroll_goal']+dialog.data['widgets'][kind+'_unit']['array_offset'][0]*incr,
                                                      dialog.user_data[kind+'_scroll_limits'][0], dialog.user_data[kind+'_scroll_limits'][1]);
    }; };
    dialog.widgets['reserve_scroll_left'].onclick = scroller('reserve', -2);
    dialog.widgets['reserve_scroll_right'].onclick = scroller('reserve', 2);
    dialog.widgets['squad_scroll_left'].onclick = scroller('squad', -4);
    dialog.widgets['squad_scroll_right'].onclick = scroller('squad', 4);
    dialog.ondraw = update_squad_manage;
}

function update_squad_manage(dialog) {
    var squad = player.squads[dialog.user_data['squad_id'].toString()];
    if(!squad) { dialog.widgets['close_button'].onclick(dialog.widgets['close_button']); return; }

    // always allow assign/unassign to base defenders, even without squad_play_requirement
    var pred = (SQUAD_IDS.is_mobile_squad_id(dialog.user_data['squad_id']) ? {'predicate':'LIBRARY', 'name':'squad_play_requirement'} : {'predicate': 'ALWAYS_TRUE'});
    var rpred = read_predicate(pred);
    var pred_ok = rpred.is_satisfied(player, null);
    var pred_help = (!pred_ok ? get_requirements_help(rpred) : null);

    // separate predicate check to deploy one addtional squad
    var deploy_pred_ok, deploy_pred_help;
    if(SQUAD_IDS.is_mobile_squad_id(dialog.user_data['squad_id'])) {
        var deploy_pred = {'predicate':'AND', 'subpredicates': [pred, get_squad_deployment_predicate()]};
        var deploy_rpred = read_predicate(deploy_pred);
        deploy_pred_ok = deploy_rpred.is_satisfied(player, null);
        deploy_pred_help = (!deploy_pred_ok ? get_requirements_help(deploy_rpred) : null);
    } else {
        deploy_pred_ok = pred_ok;
        deploy_pred_help = pred_help;
    }

    // clear out unit icons
    for(var name in dialog.widgets) {
        if(name.indexOf('reserve_unit') === 0 || name.indexOf('squad_unit') === 0) {
            unit_icon_set(dialog.widgets[name], null, -1, null, null);
        } else if(name.indexOf('squad_hp_bar') === 0) {
            dialog.widgets[name].show = false;
        }
    }

    // scan for units
    var reserve_units_by_type = {}, squad_units = [];
    var max_squad_space = (dialog.user_data['squad_id'] === SQUAD_IDS.BASE_DEFENDERS ? player.stattab['main_squad_space'] : player.stattab['squad_space']);
    var cur_squad_space = 0;
    var max_hp = 0, cur_hp = 0;
    var travel_speed = -1;
    var squad_is_deployed = player.squad_is_deployed(squad['id']);
    var squad_is_moving = player.squad_is_moving(squad['id']);
    var squad_is_under_repair = player.squad_is_under_repair(squad['id']);
    var squad_in_battle = player.squad_is_in_battle(squad['id']);

    goog.object.forEach(player.my_army, function(obj, obj_id) {
        var obj_squad_id = obj['squad_id'] || 0;
        if(obj_squad_id === SQUAD_IDS.RESERVES) {
            reserve_units_by_type[obj['spec']] = (reserve_units_by_type[obj['spec']]||0) + 1;
        } else if(obj_squad_id === dialog.user_data['squad_id']) {
            squad_units.push(obj);
            cur_squad_space += get_leveled_quantity(gamedata['units'][obj['spec']]['consumes_space']||0, obj['level']||1);
            var curmax = army_unit_hp(obj);
            cur_hp += curmax[0]; max_hp += curmax[1];
            var speed = get_leveled_quantity(gamedata['units'][obj['spec']]['maxvel']||0, obj['level']||1);
            if(travel_speed < 0) {
                travel_speed = speed;
            } else {
                travel_speed = Math.min(travel_speed, speed);
            }
        }
    });

    // add current production to space usage
    if(!gamedata['produce_to_reserves'] && dialog.user_data['squad_id'] === SQUAD_IDS.BASE_DEFENDERS) {
        cur_squad_space += player.get_manufacture_queue_space_usage();
    }

    var squad_is_dead = (max_hp > 0 && cur_hp <= 0);

    dialog.widgets['capacity_bar'].progress = cur_squad_space/Math.max(max_squad_space,1);
    dialog.widgets['capacity_label'].str = dialog.data['widgets']['capacity_label']['ui_name'].replace('%cur', pretty_print_number(cur_squad_space)).replace('%max', pretty_print_number(max_squad_space));

    // note: travel speed shown in GUI is not multiplied by the unit_travel_speed_factor or sttab
    dialog.widgets['travel_speed'].show = (dialog.user_data['squad_id'] != SQUAD_IDS.BASE_DEFENDERS);
    if(dialog.widgets['travel_speed'].show) {
        dialog.widgets['travel_speed'].str = dialog.data['widgets']['travel_speed']['ui_name'].replace('%s', (travel_speed > 0 ? travel_speed.toFixed(1) : '-'));
    }

    dialog.widgets['includes_manufacturing'].show = (dialog.user_data['squad_id'] === SQUAD_IDS.BASE_DEFENDERS) && (!player.squads_enabled() || !gamedata['produce_to_reserves']);

    var reserve_types_to_show = goog.object.getKeys(reserve_units_by_type);
    reserve_types_to_show.sort(army_unit_compare_specnames);
    squad_units.sort(army_unit_compare);

    // show manufacture-queued units in base defenders, after all other units
    if((!player.squads_enabled() || !gamedata['produce_to_reserves']) && (dialog.user_data['squad_id'] === SQUAD_IDS.BASE_DEFENDERS)) {
        goog.object.forEach(session.cur_objects.objects, function(obj) {
            if(obj.team === 'player' && obj.is_building() && obj.is_manufacturer()) {
                goog.array.forEach(obj.manuf_queue, function(item) {
                    squad_units.push({'obj_id':'IN_PRODUCTION', 'pending':1, 'in_manuf_queue':1,
                                      'spec': item['spec_name'], 'level': item['level']||1});
                });
            }
        });
    }

    var reserve_columns = dialog.user_data['reserve_columns'] = (reserve_types_to_show.length < dialog.data['widgets']['reserve_unit']['array_max'][0]*dialog.data['widgets']['reserve_unit']['array_max'][1] ? dialog.data['widgets']['reserve_unit']['array_max'][0] : Math.ceil((reserve_types_to_show.length+1)/dialog.data['widgets']['reserve_unit']['array_max'][1]));
    var squad_columns = dialog.user_data['squad_columns'] = (squad_units.length < dialog.data['widgets']['squad_unit']['array_max'][0]*dialog.data['widgets']['squad_unit']['array_max'][1] ? dialog.data['widgets']['squad_unit']['array_max'][0] : Math.ceil((squad_units.length+1)/dialog.data['widgets']['squad_unit']['array_max'][1]));

    dialog.user_data['reserve_scroll_limits'] = [0, Math.max(0, reserve_columns-dialog.data['widgets']['reserve_unit']['array_max'][0]) * dialog.data['widgets']['reserve_unit']['array_offset'][0]];
    dialog.user_data['squad_scroll_limits'] = [0, Math.max(0, squad_columns-dialog.data['widgets']['squad_unit']['array_max'][0]) * dialog.data['widgets']['squad_unit']['array_offset'][0]];

    goog.array.forEach(['reserve', 'squad'], function(kind) {
        dialog.user_data[kind+'_scroll_goal'] = clamp(dialog.user_data[kind+'_scroll_goal'], dialog.user_data[kind+'_scroll_limits'][0],  dialog.user_data[kind+'_scroll_limits'][1]);
        if(dialog.user_data[kind+'_scroll_pos'] != dialog.user_data[kind+'_scroll_goal']) {
            var delta = dialog.user_data[kind+'_scroll_goal'] - dialog.user_data[kind+'_scroll_pos'];
            var sign = (delta > 0 ? 1 : -1);
            dialog.user_data[kind+'_scroll_pos'] += sign * Math.floor(0.15 * Math.abs(delta) + 0.5);
        }
        dialog.widgets[kind+'_scroll_left'].state = (dialog.user_data[kind+'_scroll_goal'] <= dialog.user_data[kind+'_scroll_limits'][0] ? 'disabled' : 'normal');
        dialog.widgets[kind+'_scroll_right'].state = (dialog.user_data[kind+'_scroll_goal'] >= dialog.user_data[kind+'_scroll_limits'][1] ? 'disabled' : 'normal');
    });

    // show/hide right-hand widgets as appropriate
    dialog.widgets['reserve_topbar_label'].show =
        dialog.widgets['reserve_scroll_left'].show =
        dialog.widgets['reserve_scroll_right'].show = !squad_is_deployed;
    dialog.widgets['deployed_topbar_label'].show =

        dialog.widgets['deployed_midbar'].show =
        dialog.widgets['deployed_decoration'].show =
        dialog.widgets['deployed_unit_icon'].show =
        dialog.widgets['deployed_midbar_label'].show =
        dialog.widgets['deployed_midbar_coords'].show = squad_is_deployed;

    if(squad_is_deployed) {
        var orders = player.squad_get_client_data(squad['id'], 'squad_orders');

        // the definition of "recalling" is a little looser than squad_is_moving, since there may be a halt involved in the middle
        var squad_is_recalling = orders && ('recall' in orders || 'recall_after_halt' in orders);

        dialog.widgets['deployed_midbar_label'].str = dialog.data['widgets']['deployed_midbar_label']['ui_name' + ((squad_is_moving || squad_is_recalling) ? '_moving' : '')];
        dialog.widgets['deployed_midbar_coords'].str = ((vec_equals(squad['map_loc'], player.home_base_loc) || squad_is_recalling) ? gamedata['strings']['regional_map']['home_base'] : dialog.data['widgets']['deployed_midbar_coords']['ui_name'].replace('%x', squad['map_loc'][0].toString()).replace('%y', squad['map_loc'][1].toString()));
        dialog.widgets['deployed_unit_icon'].asset = (squad_units.length >= 1 ? get_leveled_quantity(gamedata['units'][squad_units[0]['spec']]['art_asset'], squad_units[0]['level']||1) : null);
        dialog.widgets['deployed_unit_icon'].rotating = squad_is_moving;
    }

    dialog.widgets['reserve_none_label'].show = !squad_is_deployed && (reserve_types_to_show.length < 1);
    if(dialog.widgets['reserve_none_label'].show) {
        dialog.widgets['reserve_none_label'].str = dialog.data['widgets']['reserve_none_label']['ui_name'+(squad_units.length >= 1 ? '' : '_squad_empty')];
    }

    dialog.widgets['squad_none_label'].show = !squad_is_deployed && (squad_units.length < 1);
    if(dialog.widgets['squad_none_label'].show) {
        dialog.widgets['squad_none_label'].str = dialog.data['widgets']['squad_none_label']['ui_name'+(reserve_types_to_show.length >= 1 ? '' : '_reserves_empty')];
    }

    dialog.widgets['arrow'].show = false;

    // RESERVES
    if(!squad_is_deployed) {
        var grid_x = 0, grid_y = 0;
        goog.array.forEach(reserve_types_to_show, function(specname) {
            var wname = 'reserve_unit'+grid_x.toString()+','+grid_y.toString();
            if(!(wname in dialog.widgets)) {
                dialog.widgets[wname] = new SPUI.Dialog(gamedata['dialogs'][dialog.data['widgets']['reserve_unit']['dialog']], dialog.data['widgets']['reserve_unit']);
                dialog.add_after(dialog.widgets['reserve_scroll_right'], dialog.widgets[wname]);
            }
            dialog.widgets[wname].xy = vec_add(vec_add(dialog.data['widgets']['reserve_unit']['xy'], [-dialog.user_data['reserve_scroll_pos'],0]),
                                               vec_mul([grid_x,grid_y], dialog.data['widgets']['reserve_unit']['array_offset']));
            var onclick;
            if(!pred_ok) {
                onclick = pred_help;
            } else {
                onclick = (function (_squad_id, _specname, _cur_squad_space, _max_squad_space) { return function(w, button) {
                    if(player.squad_is_deployed(_squad_id) || player.squad_is_in_battle(_squad_id)) {
                        var s = gamedata['errors']['CANNOT_ALTER_SQUAD_WHILE_TRAVELING'];
                        invoke_child_message_dialog(s['ui_title'], s['ui_name']);
                        return;
                    }
                    if(player.squad_is_under_repair(_squad_id)) {
                        var s = gamedata['errors']['CANNOT_ALTER_SQUAD_UNDER_REPAIR'];
                        invoke_child_message_dialog(s['ui_title'], s['ui_name']);
                        return;
                    }

                    // find healthiest (or unhealthiest) non-pending reserve unit of this type
                    var obj = null, extreme_hp_ratio, no_space = false;
                    if(button == SPUI.RIGHT_MOUSE_BUTTON) {
                        extreme_hp_ratio = 1;
                    } else {
                        extreme_hp_ratio = -1;
                    }
                    goog.object.forEach(player.my_army, function(o) {
                        if(o['squad_id'] === SQUAD_IDS.RESERVES && o['spec'] === _specname && !o['pending']) {
                            var space = get_leveled_quantity(gamedata['units'][o['spec']]['consumes_space']||0, o['level']||1);
                            if(_cur_squad_space+space <= _max_squad_space) {
                                var curmax = army_unit_hp(o);
                                var ratio = curmax[0]/Math.max(curmax[1],1);
                                if((button == SPUI.RIGHT_MOUSE_BUTTON && ratio <= extreme_hp_ratio) ||
                                   (button != SPUI.RIGHT_MOUSE_BUTTON && ratio > extreme_hp_ratio)) {
                                    extreme_hp_ratio = ratio;
                                    obj = o;
                                }
                            } else {
                                no_space = true;
                            }
                        }
                    });

                    if(no_space) {
                        var s = gamedata['errors']['CANNOT_SQUAD_ASSIGN_UNIT_LIMIT_REACHED'+(_squad_id == SQUAD_IDS.BASE_DEFENDERS ? '_BASE_DEFENDERS' : '')];
                        invoke_child_message_dialog(s['ui_title'], s['ui_name']);
                        return;
                    }
                    if(obj) {
                        send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_ASSIGN_UNIT", _squad_id, obj['obj_id']]);
                        unit_repair_sync_marker = synchronizer.request_sync();
                        obj['pending'] = 1;
                    }
                }; })(dialog.user_data['squad_id'], specname, cur_squad_space, max_squad_space);
            }

            var icon_state = ((!pred_ok || squad_is_under_repair || squad_is_deployed || squad_in_battle) ? 'disabled_clickable' : null);

            unit_icon_set(dialog.widgets[wname], specname, reserve_units_by_type[specname], null, onclick, icon_state);
            if(!icon_state && dialog.widgets[wname].mouse_enter_time > 0) {
                dialog.widgets['arrow'].show = true;
                dialog.widgets['arrow'].xy = dialog.widgets[wname].xy;
                dialog.widgets['arrow'].asset = dialog.data['widgets']['arrow']['asset_left'];
            }

            grid_x += 1; if(grid_x >= reserve_columns) { grid_y += 1; grid_x = 0; }
        });
    }

    // SQUAD
    if(1) {
        grid_x = grid_y = 0;
        goog.array.forEach(squad_units, function(obj) {
            var wname = 'squad_unit'+grid_x.toString()+','+grid_y.toString();
            if(!(wname in dialog.widgets)) {
                dialog.widgets[wname] = new SPUI.Dialog(gamedata['dialogs'][dialog.data['widgets']['squad_unit']['dialog']], dialog.data['widgets']['squad_unit']);
                dialog.add_after(dialog.widgets['squad_scroll_right'], dialog.widgets[wname]);
            }
            dialog.widgets[wname].xy = vec_add(vec_add(dialog.data['widgets']['squad_unit']['xy'], [-dialog.user_data['squad_scroll_pos'],0]),
                                               vec_mul([grid_x,grid_y], dialog.data['widgets']['squad_unit']['array_offset']));

            var onclick;
            if(obj['pending']) {
                onclick = null;
            } else if(!pred_ok) {
                onclick = pred_help;
            } else {
                onclick = (function (_squad_id, _obj) { return function(w) {
                    if(player.squad_is_deployed(_squad_id) || player.squad_is_in_battle(_squad_id)) {
                        var s = gamedata['errors']['CANNOT_ALTER_SQUAD_WHILE_TRAVELING'];
                        invoke_child_message_dialog(s['ui_title'], s['ui_name']);
                        return;
                    }
                    if(player.squad_is_under_repair(_squad_id)) {
                        var s = gamedata['errors']['CANNOT_ALTER_SQUAD_UNDER_REPAIR'];
                        invoke_child_message_dialog(s['ui_title'], s['ui_name']);
                        return;
                    }
                    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "SQUAD_UNASSIGN_UNIT", _squad_id, _obj['obj_id']]);
                    unit_repair_sync_marker = synchronizer.request_sync();
                _obj['pending'] = 1;
                }; })(dialog.user_data['squad_id'], obj)
            }
            var icon_state = ((obj['pending'] || !pred_ok || squad_is_under_repair || squad_is_deployed || squad_in_battle) ? 'disabled_clickable' : null);
            unit_icon_set(dialog.widgets[wname], obj['spec'], 1, obj, onclick, icon_state,
                          (obj['in_manuf_queue'] ? gamedata['strings']['squads']['in_manuf_queue'] : null)
                         );

            if(!icon_state && dialog.widgets[wname].mouse_enter_time > 0) {
                dialog.widgets['arrow'].show = true;
                dialog.widgets['arrow'].xy = dialog.widgets[wname].xy;
                dialog.widgets['arrow'].asset = dialog.data['widgets']['arrow']['asset_right'];
            }

            var hp_wname = 'squad_hp_bar'+grid_x.toString()+','+grid_y.toString();
            if(!(hp_wname in dialog.widgets)) {
                dialog.widgets[hp_wname] = SPUI.instantiate_widget(dialog.data['widgets']['squad_hp_bar']);
                dialog.add_after(dialog.widgets[wname], dialog.widgets[hp_wname]);
            }
            var curmax = army_unit_hp(obj);
            dialog.widgets[hp_wname].show = true;
            dialog.widgets[hp_wname].progress = curmax[0]/Math.max(curmax[1],1);
            if(curmax[0] < curmax[1] && squad_is_under_repair) { request_unit_repair_update(); }
            dialog.widgets[hp_wname].full_color = SPUI.make_colorv(dialog.data['widgets']['squad_hp_bar']['full_color' + (obj['in_manuf_queue'] ? '_queued' : '')]);
            dialog.widgets[hp_wname].xy = vec_add(vec_add(dialog.data['widgets']['squad_hp_bar']['xy'], [-dialog.user_data['squad_scroll_pos'],0]),
                                                  vec_mul([grid_x,grid_y], dialog.data['widgets']['squad_hp_bar']['array_offset']));
            grid_x += 1; if(grid_x >= squad_columns) { grid_y += 1; grid_x = 0; }
        });
    }

    // BUTTONS

    var is_nosql_region = (session.region.data && session.region.data['storage'] == 'nosql') && session.region.map_enabled();

    dialog.widgets['find_on_map_button'].show = squad_is_deployed;
    dialog.widgets['recall_button'].show = (squad_is_deployed); // && !squad_is_moving);
    dialog.widgets['halt_button'].show = false; // (squad_is_deployed && squad_is_moving);
    dialog.widgets['disband_button'].show = !squad_is_deployed && SQUAD_IDS.is_mobile_squad_id(dialog.user_data['squad_id']);
    dialog.widgets['deploy_button'].show = !squad_is_deployed && (cur_squad_space > 0) && SQUAD_IDS.is_mobile_squad_id(dialog.user_data['squad_id']);
    dialog.widgets['deploy_button'].state = (!is_nosql_region || !deploy_pred_ok || squad_is_under_repair || squad_is_dead ? 'disabled_clickable' : 'normal');

    dialog.widgets['recall_button'].state = ((squad['pending'] || player.squad_get_client_data(squad['id'], 'squad_orders')) ? 'disabled' : 'normal');

    dialog.widgets['halt_button'].state = ((squad['pending'] || player.squad_get_client_data(squad['id'], 'halt_pending')) ? 'disabled' : 'normal');

    dialog.widgets['deploy_button'].tooltip.str = null;
    if(!is_nosql_region) {
        dialog.widgets['deploy_button'].onclick = function() {
            var s = gamedata['errors']['CANNOT_DEPLOY_SQUAD_NO_NOSQL'];
            invoke_child_message_dialog(s['ui_title'], s['ui_name'], {'dialog':'message_dialog_big'});
        };
    } else if(!deploy_pred_ok) {
        dialog.widgets['deploy_button'].onclick = deploy_pred_help;
        dialog.widgets['deploy_button'].tooltip.str = deploy_rpred.ui_describe(player, null);
    } else {
        dialog.widgets['deploy_button'].onclick = function(w) {
            var squad_id = w.parent.user_data['squad_id'];
            var squad_data = w.parent.user_data['squad'];
            var icon_assetname = w.parent.widgets['squad_unit0,0'].widgets['icon'].asset;

            if(player.squad_is_under_repair(squad_id)) {
                var s = gamedata['errors']['CANNOT_DEPLOY_SQUAD_UNDER_REPAIR'];
                invoke_child_message_dialog(s['ui_title'], s['ui_name']);
                return;
            }
            if(player.squad_is_dead(squad_id)) {
                var s = gamedata['errors']['CANNOT_DEPLOY_SQUAD_DEAD'];
                invoke_child_message_dialog(s['ui_title'], s['ui_name']);
                return;
            }

            if(!session.home_base) { return; }
            change_selection_ui(null);
            var map_dialog = invoke_region_map(session.viewing_base.base_map_loc);
            if(map_dialog) {
                map_dialog.widgets['map'].invoke_deploy_cursor(session.viewing_base.base_map_loc, squad_id, icon_assetname);
            }
        };
    }

}

var unit_repair_sync_marker = Synchronizer.INIT;
function invoke_repair_control() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['repair_control']);
    dialog.user_data['dialog'] = 'repair_control';
    dialog.user_data['page'] = -1;
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };
    init_army_dialog_buttons(dialog.widgets['army_dialog_buttons_army'], 'army', 'repair_control');

    // this dialog has two "modes": squads and non-squads. Show/hide certain widgets as appropriate:
    dialog.widgets['squad_radio_label'].show =
        dialog.widgets['squad_radio_base_defenders'].show =
        dialog.widgets['squad_radio_reserves'].show =
        dialog.widgets['squad_label1'].show =
        dialog.widgets['squad_label2'].show = player.squads_enabled();
    dialog.widgets['add_all_button'].show =
        dialog.widgets['requirements_water_icon'].show =
        dialog.widgets['requirements_water_value'].show =
        dialog.widgets['requirements_iron_icon'].show =
        dialog.widgets['requirements_iron_value'].show =
        dialog.widgets['requirements_time_icon'].show =
        dialog.widgets['requirements_time_value'].show =
        dialog.widgets['in_production_bg'].show =
        dialog.widgets['in_production_icon'].show =
        dialog.widgets['in_production_time'].show =
        dialog.widgets['in_production_wrench'].show =
        dialog.widgets['in_production_cancel'].show =
        dialog.widgets['in_production_health'].show =
        dialog.widgets['price_display'].show =
        dialog.widgets['price_spinner'].show =
        dialog.widgets['finish_button'].show = !dialog.widgets['squad_radio_label'].show;

    for(var i = 0; i < dialog.data['widgets']['queue']['array'][0]; i++) {
        dialog.widgets['queue'+i.toString()].show =
            dialog.widgets['queue_bg'+i.toString()].show =
            dialog.widgets['queue_counter_bg'+i.toString()].show =
            dialog.widgets['queue_counter'+i.toString()].show =
            dialog.widgets['queue_cancel'+i.toString()].show = !dialog.widgets['squad_radio_label'].show;
    }

    // whether we are looking at base defenders or reserves
    dialog.user_data['squad_id'] = (player.squads_enabled() ? get_preference_setting(player.preferences, 'repair_control_squad_id') : SQUAD_IDS.BASE_DEFENDERS);
    var set_squad = function(_id) { return function(w) {
        if(w.parent.user_data['squad_id'] != _id) {
            w.parent.user_data['squad_id'] = _id;
            player.preferences['repair_control_squad_id'] = _id;
            send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
        }
    }; };
    dialog.widgets['squad_radio_base_defenders'].onclick = set_squad(SQUAD_IDS.BASE_DEFENDERS);
    dialog.widgets['squad_radio_reserves'].onclick = set_squad(SQUAD_IDS.RESERVES);

    dialog.ondraw = update_repair_control;

    // mostly so self-destruction shows up
    flush_dirty_objects({});

    repair_control_change_page(0);
    return dialog;
}
function repair_control_change_page(pagenum) {
    var dialog = selection.ui;
    if(dialog.user_data['dialog'] != 'repair_control') { return; }
    dialog.user_data['page'] = pagenum;
}

// replace our unit_repair_queue with the one the server provides,
// and update under_repair flags

// throttle unit repair ping requests
var unit_repair_ping_sent = false;
var last_unit_repair_ping = 0;

function request_unit_repair_update() {
    if(unit_repair_ping_sent) { return; } // only one outstanding request
    if(client_time - last_unit_repair_ping < gamedata['client']['unit_repair_ping_interval']) { return; }
    unit_repair_ping_sent = true;
    last_unit_repair_ping = client_time;
    send_to_server.func(["UNIT_REPAIR_TICK"]);
}

function receive_unit_repair_update(data) {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        obj.under_repair_finish = -1;
    }
    player.unit_repair_queue = data;
    for(var i = 0; i < player.unit_repair_queue.length; i++) {
        var item = player.unit_repair_queue[i];
        // can be race conditions here with server, so check to be careful
        if(item['obj_id'] in session.cur_objects.objects) {
            session.cur_objects.objects[item['obj_id']].under_repair_finish = item['finish_time'];
        }
    }
    // confirm receipt of response from the repair_control dialog
    unit_repair_ping_sent = false;
}

function update_repair_control(dialog) {

    dialog.widgets['squad_radio_base_defenders'].state = (dialog.user_data['squad_id'] == SQUAD_IDS.BASE_DEFENDERS ? 'active' : 'normal');
    dialog.widgets['squad_radio_reserves'].state = (dialog.user_data['squad_id'] == SQUAD_IDS.RESERVES ? 'active' : 'normal');

    // fill in the bottom of the dialog first, since we need the HP
    // estimate for the currently-under-repair unit for the grid above

    var total_res = {}, cur_repair_est_progress = 0, any_need_repair = false;

    // fill in current repair item
    dialog.widgets['in_production_icon'].show =
        dialog.widgets['in_production_time'].show =
        dialog.widgets['in_production_wrench'].show =
        dialog.widgets['in_production_health'].show = !player.squads_enabled() && (player.unit_repair_queue.length > 0 && player.unit_repair_queue[0]['obj_id'] in session.cur_objects.objects);
    dialog.widgets['in_production_cancel'].show = (dialog.widgets['in_production_icon'].show && gamedata['unit_repair_can_cancel'] && !player.squads_enabled());

    if(player.unit_repair_queue.length > 0) {
        var item = player.unit_repair_queue[0];
        var orig_hp = item['original_hp'];
        var cur_hp = null, max_hp = null;
        if(item['obj_id'] in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[item['obj_id']];
            dialog.widgets['in_production_icon'].bg_image = obj.get_leveled_quantity(obj.spec['art_asset']);
            dialog.widgets['in_production_icon'].alpha = (obj.spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1);

            dialog.widgets['in_production_time'].str = pretty_print_time(item['finish_time'] - server_time);
            dialog.widgets['in_production_cancel'].onclick = (function (id) { return function() {
                send_to_server.func(["UNIT_REPAIR_CANCEL", id]);
                unit_repair_sync_marker = synchronizer.request_sync();
            }; })(item['obj_id']);
            cur_hp = obj.hp; max_hp = obj.max_hp;
        } else if(item['obj_id'] in player.my_army) {
            var obj = player.my_army[item['obj_id']];
            var cur_max_hp = army_unit_hp(obj); cur_hp = cur_max_hp[0]; max_hp = cur_max_hp[1];
        }

        // estimate current HP value
        var progress = 1.0 - (item['finish_time'] - server_time)/(item['finish_time']-item['start_time']);

        // try pinging for (start or) completion
        if(progress >= 1 || (cur_hp !== null && cur_hp === 0)) {
            request_unit_repair_update();
        }

        if(max_hp !== null) {
            progress = (orig_hp + progress*(max_hp-orig_hp))/max_hp;
            cur_repair_est_progress = progress;

            progress = Math.min(Math.max(progress, 0), 1);
            dialog.widgets['in_production_health'].progress = progress;
            for(var res in gamedata['resources']) {
                if(res in item) {
                    total_res[res] = (total_res[res]||0) + item[res];
                }
            }
        }
    }

    // fill in backed-up part of the queue
    var NBOXES = 8;
    var counters = [];
    for(var box = 0; box < NBOXES; box++) {
        dialog.widgets['queue'+box.toString()].show = false;
        dialog.widgets['queue_counter_bg'+box.toString()].show = false;
        dialog.widgets['queue_counter'+box.toString()].show = false;
        dialog.widgets['queue_cancel'+box.toString()].show = false;
        counters.push(0);
    }
    var box = -1;
    var kind = null;
    for(var i = 1; i < player.unit_repair_queue.length; i++) {
        var item = player.unit_repair_queue[i];
        if(!(item['obj_id'] in session.cur_objects.objects)) { continue; }
        var obj = session.cur_objects.objects[item['obj_id']];
        for(var res in gamedata['resources']) {
            if(res in item) {
                total_res[res] = (total_res[res]||0) + item[res];
            }
        }
        if(obj.spec['name'] != kind) {
            // start new box
            box += 1;
            if(box < NBOXES) {
                counters[box] = 1;
                kind = obj.spec['name'];
                dialog.widgets['queue'+box.toString()].show = !player.squads_enabled();
                dialog.widgets['queue'+box.toString()].bg_image = obj.get_leveled_quantity(obj.spec['art_asset']);
                dialog.widgets['queue'+box.toString()].alpha = (obj.spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1);
                dialog.widgets['queue_counter_bg'+box.toString()].show =
                    dialog.widgets['queue_counter'+box.toString()].show = !player.squads_enabled();
                dialog.widgets['queue_cancel'+box.toString()].show = gamedata['unit_repair_can_cancel'] && !player.squads_enabled();
                dialog.widgets['queue_cancel'+box.toString()].onclick = (function (id) { return function() {
                    send_to_server.func(["UNIT_REPAIR_CANCEL", id]);
                    unit_repair_sync_marker = synchronizer.request_sync();
                }; })(item['obj_id']);
            }
        } else {
            if(box < NBOXES) {
                counters[box] += 1;
            }
        }
    }
    for(var b = 0; b < NBOXES; b++) {
        dialog.widgets['queue_counter'+b.toString()].str = counters[b].toString();
    }

    // collect and sort list of all mobile units to display
    var unit_list = [];

    if(player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units'])) {
        for(var id in player.my_army) {
            var obj = player.my_army[id];
            if((obj['squad_id'] || 0) === dialog.user_data['squad_id']) {
                unit_list.push(obj);
            }
        }
    } else {
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.team === 'player' && obj.is_mobile()) {
                unit_list.push(obj);
                if(obj.is_damaged() && !obj.is_under_repair()) {
                    any_need_repair = true;
                }
            }
        }
    }

    var compare_by_awesomeness = function(a,b) {
        var aq = a.get_leveled_quantity(a.spec['max_hp']),
        bq = b.get_leveled_quantity(b.spec['max_hp']);
        if(aq < bq) { return 1; }
        if(aq > bq) { return -1; }
        return 0;
    };
    unit_list.sort(player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units']) ? army_unit_compare : compare_by_awesomeness);

    // annoying paging code
    var page = dialog.user_data['page'], row = 0, rows_per_page = 20;
    var chapter_units = unit_list.length;
    var chapter_pages = Math.floor((chapter_units+rows_per_page-1)/rows_per_page);
    dialog.user_data['page'] = page = (chapter_units == 0 ? 0 : clamp(page, 0, chapter_pages-1));
    if(chapter_units > 0) {
        // show units!
        var first_on_page = page * rows_per_page;
        var last_on_page = (page+1)*rows_per_page-1;
        last_on_page = Math.max(0, Math.min(last_on_page, chapter_units-1));
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_on_page+1).toString()).replace('%d2',(last_on_page+1).toString()).replace('%d3',chapter_units.toString());
        for(var i = first_on_page; i <= last_on_page; i++) {
            var obj = unit_list[i];
            var coord = (row%10).toString()+','+Math.floor(row/10).toString();
            dialog.widgets['grid'+coord].show = true;

            var spec, level, hp, max_hp, obj_id, repair_progress, is_under_repair, allow_repair;

            if(player.squads_enabled() || ('enable_defending_units' in gamedata && !gamedata['enable_defending_units'])) {
                spec = gamedata['units'][obj['spec']]; level = obj['level'] || 1; obj_id = obj['obj_id'];
                var cur_max_hp = army_unit_hp(obj); hp = cur_max_hp[0]; max_hp = cur_max_hp[1];
                repair_progress = hp / Math.max(max_hp,1); is_under_repair = false;
                if(player.squads_enabled()) {
                    allow_repair = false;
                }
            } else {
                spec = obj.spec; level = obj.level; obj_id = obj.id;
                hp = obj.hp; max_hp = obj.max_hp;
                if(obj.is_under_repair() && obj_id == player.unit_repair_queue[0]['obj_id']) {
                    // for unit currently being repaired, use the more accurate estimated HP from the queue code above
                    repair_progress = cur_repair_est_progress;
                } else {
                    repair_progress = obj.hp / Math.max(obj.max_hp,1);
                }
                is_under_repair = obj.is_under_repair();
                allow_repair = obj.is_damaged() && !is_under_repair;
            }

            dialog.widgets['grid'+coord].asset = get_leveled_quantity(spec['art_asset'], level);
            dialog.widgets['grid'+coord].tooltip.str = spec['ui_name'];
            dialog.widgets['grid'+coord].alpha = (spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1);
            dialog.widgets['grid_health'+coord].show = (hp != max_hp) && (hp>0);
            dialog.widgets['grid_health'+coord].progress = repair_progress;

            dialog.widgets['grid_skull'+coord].show = (hp <= 0) && !is_under_repair;
            dialog.widgets['grid_wrench'+coord].show = is_under_repair;
            if(is_under_repair) {
                var active = (player.unit_repair_queue[0]['obj_id'] === obj_id);
                dialog.widgets['grid_wrench'+coord].asset = dialog.data['widgets']['grid_wrench']['asset_'+(active ? 'active' : 'queued')];
                dialog.widgets['grid_wrench'+coord].rocking = active;
            }

            var show_recycle, show_repair, alpha = 0;
            if(dialog.widgets['grid'+coord].mouse_enter_time > 0) {
                show_recycle = true;
                show_repair = allow_repair;
                alpha = 0.75*clamp((client_time - dialog.widgets['grid'+coord].mouse_enter_time)/0.15, 0, 1); // fade in
                dialog.widgets['grid_repair'+coord].onclick = (function (_obj, _coord) { return function(w) {
                    w.parent.widgets['grid'+_coord].tooltip.onleave();
                    var cost = _obj.cost_to_repair(player);
                    var ls = [];

                    for(var res in gamedata['resources']) {
                        if(player.resource_state[res][1] < (cost[res]||0)) {
                            ls.push(pretty_print_number(cost[res]||0) + ' ' + gamedata['resources'][res]['ui_name']);
                        }
                    }
                    if(ls.length > 0) {
                        var s = gamedata['strings']['requirements_help']['insufficient_resources_to_repair_a_unit']['any'];
                        invoke_child_message_dialog(s['ui_title'],
                                                    s['ui_description'].replace('%res', ls.join(', ')));
                        return;
                    }

                    if(!player.can_repair_unit(_obj)) {
                        var helper = get_requirements_help('tech_for_repair', _obj.spec['name']);
                        if(helper) { helper(); }
                        return;
                    }
                    send_to_server.func(["UNIT_REPAIR_QUEUE", _obj.id]);
                    unit_repair_sync_marker = synchronizer.request_sync();
                }; })(obj, coord);
                dialog.widgets['grid_recycle'+coord].onclick = (function (_obj, _coord) { return function(w) {
                    w.parent.widgets['grid'+_coord].tooltip.onleave();
                    invoke_recycle_dialog(_obj);
                }; })(obj, coord);

            } else {
                show_recycle = false;
                show_repair = false;
                alpha = 0;
            }
            dialog.widgets['grid_recycle'+coord].show = show_recycle;
            dialog.widgets['grid_repair'+coord].show = show_repair;
            dialog.widgets['grid_recycle'+coord].alpha = alpha;
            dialog.widgets['grid_repair'+coord].alpha = alpha;
            row += 1;
        }
    } else {
        // no units to show
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(0).toString()).replace('%d2',(0).toString()).replace('%d3',(0).toString());
    }

    // clear out empty rows
    while(row < rows_per_page) {
        var coord = (row%10).toString()+','+Math.floor(row/10).toString();
        dialog.widgets['grid'+coord].show =
            dialog.widgets['grid_health'+coord].show =
            dialog.widgets['grid_wrench'+coord].show =
            dialog.widgets['grid_skull'+coord].show =
            dialog.widgets['grid_recycle'+coord].show =
            dialog.widgets['grid_repair'+coord].show = false;
        row += 1;
    }

    // set clickability of scroll arrows
    if(page != 0) {
        dialog.widgets['scroll_left'].state = 'normal';
    } else {
        dialog.widgets['scroll_left'].state = 'disabled';
    }
    if(page < (chapter_pages-1)) {
        dialog.widgets['scroll_right'].state = 'normal';
    } else {
        dialog.widgets['scroll_right'].state = 'disabled';
    }

    dialog.widgets['scroll_left'].onclick = function() { repair_control_change_page(selection.ui.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function() { repair_control_change_page(selection.ui.user_data['page']+1); };

    var in_sync = synchronizer.is_in_sync(unit_repair_sync_marker);

    var space_usage = player.get_army_space_usage_by_squad();
    dialog.widgets['resource_bar_cap_amount'].str = pretty_print_number(space_usage['ALL']) + '/' + pretty_print_number(player.stattab['total_space']);
    dialog.widgets['resource_bar_cap'].progress = space_usage['ALL']/Math.max(player.stattab['total_space'],1);

    dialog.widgets['add_all_button'].state = (any_need_repair && in_sync ? 'normal' : 'disabled');
    dialog.widgets['add_all_button'].str = dialog.data['widgets']['add_all_button']['ui_name'+(!in_sync ? '_pending' : '')];

    dialog.widgets['add_all_button'].onclick = function() {
        var to_repair = [];
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];

            if(obj.team === 'player' && obj.is_mobile() && obj.is_damaged() && !obj.is_under_repair() ) {
                to_repair.push(obj);
            }
        }

        // add quickest units first
        var compare_by_reptime = (function(_player) { return function(a, b) {
            var acost = a.cost_to_repair(_player), bcost = b.cost_to_repair(_player);
            var aq = acost['time'], bq = bcost['time'];
            if(aq > bq) { return 1; }
            if(aq < bq) { return -1; }
            return 0;
        }; })(player);
        to_repair.sort(compare_by_reptime);

        var tech_alert = null;
        var enough_res = true;
        var total_cost = {};

        for(var i = 0; i < to_repair.length; i++) {
            var obj = to_repair[i];
            if(!player.can_repair_unit(obj)) {
                tech_alert = obj.spec['name'];
                continue;
            }

            var cost = obj.cost_to_repair(player);
            for(var resname in gamedata['resources']) {
                total_cost[resname] = (total_cost[resname]||0) + cost[resname];
                if(player.resource_state[resname][1] < total_cost[resname]) {
                    enough_res = false; // but keep going
                }
            }

            if(enough_res) {
                send_to_server.func(["UNIT_REPAIR_QUEUE", obj.id]);
                unit_repair_sync_marker = synchronizer.request_sync();
            }
        }

        if(!enough_res) {
            invoke_insufficient_resources_for_repair_message(total_cost);
        } else if(tech_alert) {
            var helper = get_requirements_help('tech_for_repair', tech_alert);
            if(helper) { helper(); }
        }
    };

    // res/time display at bottom
    for(var res in gamedata['resources']) {
        if('requirements_'+res+'_value' in dialog.widgets) {
            dialog.widgets['requirements_'+res+'_value'].str = pretty_print_number(total_res[res] || 0);
        }
    }

    if(player.unit_repair_queue.length > 0) {
        dialog.widgets['requirements_time_value'].str = pretty_print_time_brief(player.unit_repair_queue[player.unit_repair_queue.length-1]['finish_time'] - server_time);
    } else {
        dialog.widgets['requirements_time_value'].str = '-';
    }

    // price/finish button
    var price = Store.get_user_currency_price(0, gamedata['spells']['UNIT_REPAIR_SPEEDUP_FOR_MONEY'], null);
    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_short_asset', gamedata['store']['price_display_short_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].str = (!in_sync ? '' : Store.display_user_currency_price(price, 'compact')); // PRICE
    dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'+(!in_sync ? '_pending': '')];
    dialog.widgets['price_display'].tooltip.str = (!in_sync ? null : Store.display_user_currency_price_tooltip(price));
    dialog.widgets['price_spinner'].show = !in_sync && !player.squads_enabled();

    if(price == 0) {
        dialog.widgets['finish_button'].state = (!in_sync ? 'disabled': 'normal');
        dialog.widgets['finish_button'].onclick = function() {
            send_to_server.func(["UNIT_REPAIR_SPEEDUP_FOR_FREE"]);
            unit_repair_sync_marker = synchronizer.request_sync();
            invoke_ui_locker(unit_repair_sync_marker);
        };
        dialog.widgets['price_display'].onclick = (!in_sync ? null: dialog.widgets['finish_button'].onclick);
    } else if(price > 0) {
        dialog.widgets['finish_button'].state = (!in_sync ? 'disabled': 'normal');
        dialog.widgets['finish_button'].onclick = function() {
            if(Store.place_user_currency_order(GameObject.VIRTUAL_ID, "UNIT_REPAIR_SPEEDUP_FOR_MONEY", null, null)) {
                unit_repair_sync_marker = synchronizer.request_sync();
                invoke_ui_locker(unit_repair_sync_marker);
            }
        };
        dialog.widgets['price_display'].onclick = (!in_sync ? null: dialog.widgets['finish_button'].onclick);
    } else {
        dialog.widgets['finish_button'].state = 'disabled';
        dialog.widgets['price_display'].onclick = null;
    }
}

// set up the row of buttons for manufacture/upgrade/repair that go across the top of all "Army"/"Weapons" dialogs
var ARMY_DIALOG_BUTTONS = {
    'army': { 'production_button': { 'dialog_names': ['manufacture_dialog'],
                                     'spells': ['MAKE_DROIDS'],
                                     'onclick': function(w) {
                                         var _dialog = w.parent.parent;
                                         var category = (('category' in _dialog.user_data) ? _dialog.user_data['category'] : null);
                                         invoke_manufacture_dialog('production_button', category);
                                     } },
              'unlock_button': { 'dialog_names': ['research_dialog'],
                                 'spells': ['RESEARCH_FOR_FREE'],
                                 'onclick': function(w) {
                                     var _dialog = w.parent.parent;
                                     var category = (('category' in _dialog.user_data) ? _dialog.user_data['category'] : null);
                                     invoke_research_dialog('army', category);
                                 } },
              'repair_button': { 'dialog_names': ['repair_control'],
                                 'spells':['RECYCLE_UNIT'],
                                 'spells_nosquads': ['REPAIR','RECYCLE_UNIT'],
                                 'onclick': function(w) { invoke_repair_control(); } },
              'control_squads_button': { 'dialog_names': ['squad_control'],
                                         'spells': ['MANAGE_SQUADS'],
                                         'require_squads': true,
                                         'onclick': function(w) { change_selection_ui(null); invoke_squad_control(); } },
              'army_help_button': { 'dialog_names': [],
                                    'require_squads': true,
                                    'onclick': function(w) { invoke_army_dialog_help(); } }
            },
    'crafting': { 'production_button': { 'dialog_names': ['crafting_dialog'],
                                         'spells': ['CRAFT_FOR_FREE'],
                                         'onclick': function(w) {
                                             var _dialog = w.parent.parent;
                                             var category = (('category' in _dialog.user_data) ? _dialog.user_data['category'] : null);
                                             change_selection_ui(null);
                                             invoke_crafting_dialog(category);
                                         } },
                  'unlock_button': { 'dialog_names': ['research_dialog'],
                                     'spells': ['RESEARCH_FOR_FREE'],
                                     'onclick': function(w) {
                                         var _dialog = w.parent.parent;
                                         var category = (('category' in _dialog.user_data) ? _dialog.user_data['category'] : null);
                                         if(category) {
                                             var catspec = gamedata['crafting']['categories'][category];
                                             if(catspec['unlock_building_for_ui']) {
                                                 // no techs to research - point at building instead
                                                 var builder = find_object_by_type(catspec['unlock_building_for_ui']);
                                                 if(!builder) {
                                                     var helper = get_requirements_help(read_predicate({'predicate': 'BUILDING_LEVEL', 'building_type': catspec['unlock_building_for_ui'], 'trigger_level': 1}));
                                                     if(helper) {
                                                         helper();
                                                     } else {
                                                         console.log('unlock_building_for_ui not present and no helper available');
                                                     }
                                                     return;
                                                 }
                                                 change_selection_unit(builder);
                                                 invoke_upgrade_building_dialog();
                                                 return;
                                             }
                                         }
                                         invoke_research_dialog('crafting', category);
                                     } }
                },
    'leaders': { 'production_button': { 'dialog_names': ['crafting_dialog','crafting_table_of_contents_dialog'],
                                        'spells': ['CRAFT_FOR_FREE'],
                                        'onclick': function(w) {
                                            var _dialog = w.parent.parent;
                                            var category = (('category' in _dialog.user_data) ? _dialog.user_data['category'] : null);
                                            invoke_crafting_table_of_contents_dialog(category);
                                        } },
                  'unlock_button': { 'dialog_names': ['research_dialog'],
                                     'spells': ['RESEARCH_FOR_FREE'],
                                     'onclick': function(w) {
                                         var _dialog = w.parent.parent;
                                         var category = (('category' in _dialog.user_data) ? _dialog.user_data['category'] : null);
                                         invoke_research_dialog('leaders', category);
                                     } }
                }
};

function init_army_dialog_buttons(dialog, mode, my_dialog_name) {
    var use_squads = player.squads_enabled();
    goog.object.forEach(ARMY_DIALOG_BUTTONS[mode], function(data, btn) {
        if(!(btn in dialog.widgets)) { return; }
        dialog.widgets[btn].show = (use_squads || !data['require_squads']);
        var match = (data['dialog_names'] && goog.array.contains(data['dialog_names'], my_dialog_name));
        dialog.widgets[btn].onclick = (match ? null : data['onclick']);
        dialog.widgets[btn].state = (match ? 'active' : 'normal');
        var spells = data['spells'] || null;
        if(!use_squads) { // temporarily look different when squads are disabled
            if('spells_nosquads' in data) { spells = data['spells_nosquads']; }
            if('ui_name_nosquads' in dialog.data['widgets'][btn]) {
                dialog.widgets[btn].str = dialog.data['widgets'][btn]['ui_name_nosquads'];
            }
            if('xy_nosquads' in dialog.data['widgets'][btn]) {
                dialog.widgets[btn].xy = dialog.data['widgets'][btn]['xy_nosquads'];
            }
        }
        if(spells) {
            var spell_ui_names = [];
            goog.array.forEach(spells, function(spellname) {
                var ui_name = null;
                if(spellname == 'CRAFT_FOR_FREE' && mode in gamedata['crafting']['categories'] &&
                  'ui_verb' in gamedata['crafting']['categories'][mode]) {
                    ui_name = gamedata['crafting']['categories'][mode]['ui_verb'];
                } else {
                    var spell = gamedata['spells'][spellname];
                    ui_name = spell['ui_dialog_name'] || spell['ui_name'];
                }
                spell_ui_names.push(ui_name);
            });
            dialog.widgets[btn].str = spell_ui_names.join(' & ');
        }
    });
}
function hide_army_dialog_buttons(dialog, mode) {
    goog.object.forEach(ARMY_DIALOG_BUTTONS[mode], function(data, btn) {
        if(!(btn in dialog.widgets)) { return; }
        dialog.widgets[btn].show = false;
    });
}

/** @type {string|null} category name to use, unless another one is specified */
var last_manufacture_dialog_category = null;

/** @param {string} reason - arbitrary source ID, used for metrics only
    @param {string=} category - preselect a particular manufacture_category
    @param {string|null=} specname - preselect a particular unit (specname)
    @param {GameObject|null=} want_builder - use THIS factory building (otherwise pick any applicable factory) */
function invoke_manufacture_dialog(reason, category, specname, want_builder) {
    if(player.tutorial_state != "COMPLETE") {
        // during rails tutorial, force category to most basic one
        category = goog.object.getKeys(gamedata['strings']['manufacture_categories'])[0];
    }

    if(last_manufacture_dialog_category === null) {
        // default to first-listed manufacture category (the most basic one)
        last_manufacture_dialog_category = goog.object.getKeys(gamedata['strings']['manufacture_categories'])[0];
    }

    var dialog_data = gamedata['dialogs']['manufacture_dialog'];

    // instantiate the dialog
    var dialog = new SPUI.Dialog(dialog_data);

    // make the dialog modal and add it to the "desktop"
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'manufacture_dialog';
    dialog.user_data['reason'] = reason;
    dialog.user_data['category'] = null;
    dialog.user_data['page'] = 0;
    dialog.user_data['builder'] = null;
    dialog.user_data['units'] = null;
    dialog.user_data['units_this_page'] = null;
    dialog.user_data['current_unit'] = null;
    dialog.user_data['scrolled'] = false;
    dialog.user_data['want_builder'] = want_builder || null; // prefer this builder, if available

    dialog.widgets['close_button'].onclick = close_parent_dialog;

    init_army_dialog_buttons(dialog.widgets['army_dialog_buttons_army'], 'army', 'manufacture_dialog');

    // show labels for available manufacture categories and wire up click handlers
    var cat_i = 0;
    goog.object.forEach(gamedata['strings']['manufacture_categories'], function(data, cat) {
        if(!get_factory_for(cat)) { return; } // cannot be built
        if('show_if' in data && !read_predicate(data['show_if']).is_satisfied(player, null)) { return false; }

        if(cat_i < dialog.data['widgets']['cat_button']['array'][0]) {
            dialog.widgets['cat_button'+cat_i.toString()].str = data['plural'];
            dialog.widgets['cat_button'+cat_i.toString()].onclick = (function (_cat) { return function(w) { manufacture_dialog_change_category(w.parent, _cat); }; })(cat);
        }
        cat_i += 1;
    });

    // clear remaining unused labels
    while(cat_i < dialog.data['widgets']['cat_button']['array'][0]) {
        dialog.widgets['cat_button'+cat_i.toString()].show = false;
        cat_i += 1;
    }

    dialog.widgets['scroll_left'].onclick = function(w) { dialog.user_data['scrolled'] = true; manufacture_dialog_scroll(w.parent, w.parent.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function(w) { dialog.user_data['scrolled'] = true; manufacture_dialog_scroll(w.parent, w.parent.user_data['page']+1); };

    dialog.ondraw = update_manufacture_dialog;

    manufacture_dialog_change_category(dialog, category || last_manufacture_dialog_category, specname || null);
}

// return function that helps player to unlock unit "specname" (or units of category "category", whichever is non-null)
/** @param {string|null} category
    @param {string|null} specname
    @param {string} reason
    @return {function()|null} */
function manufacture_dialog_unlock_helper(category, specname, reason) {
    var builder_type = null;

    if(specname) {
        var spec = gamedata['units'][specname];
        builder_type = get_factory_for(spec['manufacture_category']);
        if(!builder_type) {
            throw Error('no factory can build '+spec['manufacture_category']);
        }

        var builder = find_object_by_type(builder_type);
        if(builder) {
            if(unit_unlock_level(specname) < 1) {
                var pred = get_leveled_quantity(spec['requires'] || null, 1);
                if(!pred) {
                    pred = {'predicate': 'TECH_LEVEL', 'tech': spec['level_determined_by_tech'], 'min_level':1};
                }
                // pass "even_if_tutorial_incomplete" option since this is vital for the manufacture_dialog to work properly, even during the tutorial
                return get_requirements_help(read_predicate(pred), null, {even_if_tutorial_incomplete:1});
            } else {
                throw Error('cannot determine what is wrong for '+specname+' reason '+reason+' current unlock level '+unit_unlock_level(specname).toString());
            }
        } else {
            // fall through
        }
    } else if(category) {
        builder_type = get_factory_for(category);
    }

    if(builder_type) {
        return get_requirements_help(read_predicate({'predicate': 'BUILDING_LEVEL', 'building_type': builder_type, 'trigger_level': 1}), null, {even_if_tutorial_incomplete:1});
    }
    throw Error('cannot determine what is wrong for cat '+ (category||'null') + ' spec '+(specname||'null')+' reason '+reason);
}


/** @param {SPUI.Dialog} dialog
    @param {string} catname
    @param {string|null=} preselect_specname */
function manufacture_dialog_change_category(dialog, catname, preselect_specname) {
    last_manufacture_dialog_category = catname;
    dialog.user_data['category'] = catname;

    // set appearance and state for category buttons
    var cat_i = 0;
    goog.object.forEach(gamedata['strings']['manufacture_categories'], function(data, cat) {
        if(!get_factory_for(cat)) { return; } // cannot be built
        if(cat_i < dialog.data['widgets']['cat_button']['array'][0]) {
            dialog.widgets['cat_button'+cat_i.toString()].state = (catname === cat ? 'active' : 'normal');
            dialog.widgets['cat_button'+cat_i.toString()].text_color = (catname === cat ? SPUI.default_text_color : SPUI.disabled_text_color);
        }
        cat_i += 1;
    });

    // select builder (may be null if no factory is present)
    var builder = null;
    var builder_type = get_factory_for(catname);
    if(dialog.user_data['want_builder'] && dialog.user_data['want_builder'].spec['name'] == builder_type) {
        builder = dialog.user_data['want_builder'];
    } else {
        builder = find_highest_level_object_by_type(builder_type);
    }

    // note: builder may be null here
    change_selection_unit(builder);
    dialog.user_data['builder'] = builder;

    // create list of units for this category
    dialog.user_data['units'] = [];
    for(var name in gamedata['units']) {
        var spec = gamedata['units'][name];

        if(spec['manufacture_category'] != dialog.user_data['category']) {
            continue;
        }
        if(spec['developer_only'] && (spin_secure_mode || !player.is_developer())) {
            continue;
        }
        if('show_if' in spec && !read_predicate(spec['show_if']).is_satisfied(player, null)) { continue; }
        if('activation' in spec && !read_predicate(spec['activation']).is_satisfied(player, null)) { continue; }
        dialog.user_data['units'].push(name);
    }

    if(player.upgrade_bar_enabled()) {
        UpgradeBar.invoke(dialog, 'building', (builder ? builder.spec['name'] : null), (builder ? builder.level+1 : -1), (builder ? builder.id : null));
    }

    manufacture_dialog_scroll(dialog, 0);
    manufacture_dialog_select_unit(dialog, preselect_specname || null);
}

function manufacture_dialog_scroll(dialog, page) {
    dialog.user_data['units_this_page'] = null;
    var builder = dialog.user_data['builder'];

    var chapter_units = (dialog.user_data['units'] ? dialog.user_data['units'].length : 0);
    var units_per_page = dialog.data['widgets']['grid']['array'][0]*dialog.data['widgets']['grid']['array'][1];
    var chapter_pages = Math.floor((chapter_units+units_per_page-1)/units_per_page);
    dialog.user_data['page'] = page = (chapter_units === 0 ? 0 : clamp(page, 0, chapter_pages-1));

    if(chapter_pages > 0) {
        dialog.user_data['units_this_page'] = [];
        var first_unit_on_page = page * units_per_page;
        var last_unit_on_page = Math.max(0, Math.min((page+1)*units_per_page-1, chapter_units-1));
        for(var i = first_unit_on_page; i <= last_unit_on_page; i++) {
            var name = dialog.user_data['units'][i];
            dialog.user_data['units_this_page'].push(name);
        }
        dialog.widgets['scroll_text'].show = true;
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_unit_on_page+1).toString()).replace('%d2',(last_unit_on_page+1).toString()).replace('%d3',chapter_units.toString()).replace('%cat', gamedata['strings']['manufacture_categories'][dialog.user_data['category']]['plural']);
    } else {
        dialog.widgets['scroll_text'].show = false;
    }

    dialog.widgets['scroll_left'].state = (page != 0 ? 'normal' : 'disabled');
    dialog.widgets['scroll_right'].state = ((page < chapter_pages-1) ? 'normal' : 'disabled');

    player.quest_tracked_dirty = true;
}

/** "Select" a unit, meaning show its stats on the right-hand side
    @param {SPUI.Dialog} dialog
    @param {string|null} name - specname of the unit to select. If null, then show generic "<- Click to produce" message */
function manufacture_dialog_select_unit(dialog, name) {
    dialog.user_data['current_unit'] = name;

    dialog.widgets['coverup_all'].show =
        dialog.widgets['coverup_queue'].show =
        dialog.widgets['click_to_unlock'].show =
        dialog.widgets['click_to_unlock_button'].show =
        dialog.widgets['click_to_produce_arrow'].show =
        dialog.widgets['click_to_produce'].show = false;

    if(!name) {
        dialog.widgets['coverup_all'].show =
            dialog.widgets['click_to_produce_arrow'].show =
            dialog.widgets['click_to_produce'].show = true;
        dialog.widgets['click_to_produce'].str = dialog.data['widgets']['click_to_produce']['ui_name'].replace('%VERB', gamedata['spells']['MAKE_DROIDS']['ui_name'].toLowerCase());
        return;
    }

    var spec = gamedata['units'][name];

    var level = unit_unlock_level(name);
    if(player.is_cheater) { level = Math.max(level, 1); }

    dialog.widgets['unit_name'].str = dialog.widgets['unit_name'].data[(level >= 1 ? 'ui_name' : 'ui_name_locked')].replace('%s', spec['ui_name']).replace('%d', level);
    dialog.widgets['unit_description'].str = spec['ui_tip'];

    var hero_asset, hero_state, hero_offset;
    if('splash_image' in spec) { // UNIT with splash image
        hero_asset = get_leveled_quantity(spec['splash_image'], Math.max(level, 1));
        hero_state = (level < 1 && GameArt.assets[hero_asset].has_state('normal_disabled') ? 'normal_disabled' : 'normal');
        hero_offset = dialog.data['widgets']['unit_hero_icon']['bg_image_offset_splash'];
    } else {
        hero_asset = get_leveled_quantity(spec['art_asset'], Math.max(level, 1));
        if(level < 1) {
            // player can't build this unit - show level 1 stats and gray out portrait
            level = 1;
            hero_state = 'hero_disabled';
        } else {
            hero_state = 'hero';
        }

        var voffset;
        if(spec['flying']) {
            voffset = -5*spec['altitude'];
        } else {
            voffset = 0;
        }
        hero_offset = vec_add(dialog.data['widgets']['unit_hero_icon']['bg_image_offset'], [0,voffset]);
    }
    dialog.widgets['unit_hero_icon'].bg_image = hero_asset;
    dialog.widgets['unit_hero_icon'].alpha = spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1;
    dialog.widgets['unit_hero_icon'].state = hero_state;

    dialog.widgets['unit_hero_icon'].bg_image_offset = hero_offset;

    // fill in unit stats
    var auto_spell = get_auto_spell_for_unit(player, spec);
    var auto_spell_level = Math.max(level, 1);

    var features = ['max_hp'];
    if(gamedata['show_armor_in_ui']) { features.push('armor'); }
    features.push('maxvel');
    if('ui_priority_vs' in spec) { features.push('ui_priority_vs'); }
    features.push('weapon_damage');
    if(!auto_spell || !is_melee_spell(auto_spell)) { // yes, things with no auto_spell can have ranges (at least the old code worked that way?)
        features.push('weapon_range');
    }
    if(auto_spell && ('splash_range' in auto_spell)) { features.push('splash_range'); }

    var row = 0;
    goog.array.forEach(features, function(stat) {
        var modchain = (player.stattab['units'][spec['name']] || {})[stat] || null;
        dialog.widgets['feature_value'+row.toString()].show = dialog.widgets['feature_label'+row.toString()].show = true;
        ModChain.display_widget(dialog.widgets['feature_value'+row.toString()], stat, modchain, spec, Math.max(level, 1), auto_spell, auto_spell_level);
        ModChain.display_label_widget(dialog.widgets['feature_label'+row.toString()], stat, auto_spell);
        row += 1;
    });
    while(row < dialog.data['widgets']['feature_label']['array'][1]) {
        dialog.widgets['feature_value'+row.toString()].show = dialog.widgets['feature_label'+row.toString()].show = false;
        row += 1;
    }
    init_damage_vs_icons(dialog, spec, auto_spell);
}

function cancel_manuf_item(builder, queue_slot, spec_name) {
    send_to_server.func(["CAST_SPELL", builder.id, "CANCEL_MAKE_DROIDS", queue_slot, spec_name]);

    // client-side predict what will happen
    var manuf_queue = builder.start_client_prediction('manuf_queue', builder.manuf_queue);
    var spec = gamedata['units'][spec_name];
    var level = player.tech[spec['level_determined_by_tech']] || 1;
    manuf_queue.splice(queue_slot,1);
    goog.object.forEach(gamedata['resources'], function(res, resname) {
        var cost = Math.floor(gamedata['manufacture_cancel_refund']*get_leveled_quantity(spec['build_cost_'+resname]||0, level));
        player.resource_state[resname][1] += cost;
    });
}

/** Main per-frame update - takes care of grid buttons and status displays*/
function update_manufacture_dialog(dialog) {
    var builder = dialog.user_data['builder'];

    // use client-side manuf_queue if we are out of sync
    var manuf_queue = (builder ? builder.get_client_prediction('manuf_queue', builder.manuf_queue) : null);

    // count how many units of each kind the player has
    var unit_count = {};

    if(!('enable_defending_units' in gamedata) || gamedata['enable_defending_units']) {
        // in games with defending units, count units in session (i.e. base defenders)
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.is_mobile() && (obj.team === 'player')) {
                var name = obj.spec['name'];
                if(name in unit_count) {
                    unit_count[name] += 1;
                } else {
                    unit_count[name] = 1;
                }
            }
        }
    } else {
        // in games without defending units, count entire army
        goog.object.forEach(player.my_army, function(obj) {
            var name = obj['spec'];
            if(name in unit_count) {
                unit_count[name] += 1;
            } else {
                unit_count[name] = 1;
            }
        });
    }

    // count queued units
    var queue_count = {};
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.is_building() && obj.is_manufacturer() && (obj.team === 'player')) {
            var q = obj.get_client_prediction('manuf_queue', obj.manuf_queue);
            goog.array.forEach(q, function(data) {
                var name = data['spec_name'];
                if(name in queue_count) {
                    queue_count[name] += 1;
                } else {
                    queue_count[name] = 1;
                }
            });
        }
    }

    // fill in grid of unit types
    var grid_x = 0, grid_y = 0;
    for(var u = 0; u < (dialog.user_data['units_this_page'] ? dialog.user_data['units_this_page'].length : 0); u++) {
        var name = dialog.user_data['units_this_page'][u];
        var spec = gamedata['units'][name];

        var widget_name = grid_x.toString() + ',' + grid_y.toString();
        var widget = dialog.widgets['grid'+widget_name];

        dialog.widgets['grid'+widget_name].show =
            dialog.widgets['grid_qty'+widget_name].show =
            dialog.widgets['sunken_grid_bg'+widget_name].show =
            dialog.widgets['sunken_grid'+widget_name].show =
            dialog.widgets['sunken_grid_label'+widget_name].show = true;

        dialog.widgets['sunken_grid_bg'+widget_name].color = SPUI.make_colorv(dialog.data['widgets']['sunken_grid_bg'][(dialog.user_data['current_unit'] == name ? 'color_highlight' : 'color')]);

        var asset_is_3d;
        var voffset; // tweak vertical positioning of icon

        if('icon' in spec) { // this doesn't necessarily look better - stay optional
            // override auto-generated 3D asset icon
            asset_is_3d = false;
            widget.bg_image = get_leveled_quantity(spec['icon'], 1);
            widget.alpha = 1;
            voffset = 0;
        } else {
            asset_is_3d = true;
            widget.bg_image = get_leveled_quantity(spec['art_asset'], 1);
            widget.alpha = spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1;
            if(spec['flying']) {
                voffset = -1*spec['altitude'];
            } else {
                voffset = 0;
            }
        }

        widget.bg_image_offset = [dialog.data['widgets']['grid']['bg_image_offset'][0],
                                  dialog.data['widgets']['grid']['bg_image_offset'][1] + voffset];

        widget.onenter = (function(_name) { return function(w) { manufacture_dialog_select_unit(w.parent, _name); } })(name);

        // this is the function that handles the mouse click
        var closure = (function(spec_name) {
            return function(w) {
                var dialog = w.parent;
                var builder = dialog.user_data['builder'];
                var unlock_level = unit_unlock_level(spec_name);

                if(player.is_cheater) {
                    var props = {}; props[spec_name] = 1;
                    send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "CHEAT_SPAWN_UNITS", props]);

                } else if(builder && unlock_level > 0) {

                    // this is the function that actually runs the build command
                    var send_command = (function (_dialog, _spec_name) { return function() {
                        var builder = _dialog.user_data['builder'];
                        send_to_server.func(["CAST_SPELL", builder.id, "MAKE_DROIDS", _spec_name]);
                        var manuf_queue = builder.start_client_prediction('manuf_queue', builder.manuf_queue);

                        // client-side predict what will happen
                        var spec = gamedata['units'][_spec_name];
                        var level = player.tech[spec['level_determined_by_tech']] || 1;
                        var cost_time = Math.floor(get_leveled_quantity(spec['build_time'], level) / builder.get_stat('manufacture_speed', builder.get_leveled_quantity(builder.spec['manufacture_speed'] || 1.0)));
                        manuf_queue.push({'spec_name':_spec_name,
                                          'level':level,
                                          'total_time':cost_time
                                         });
                        goog.object.forEach(gamedata['resources'], function(res, resname) {
                            var cost = get_leveled_quantity(spec['build_cost_'+resname] || 0, level);
                            player.resource_state[resname][1] -= cost;
                        });

                        // play different effect when starting manufacturing vs. subsequent queue appends
                        var fx_name = (manuf_queue.length == 1 ? 'unit_manufacture_start' : 'unit_manufacture_add_to_queue');
                        var fx_data = gamedata['client']['vfx'][fx_name];
                        if(fx_data) {
                            SPFX.add_visual_effect([builder.x,builder.y], 0, [0,1,0], client_time, fx_data,
                                                   true,
                                                   { '%OBJECT_SPRITE': get_leveled_quantity(spec['art_asset'], level)});
                        }
                        player.quest_tracked_dirty = true;

                    }; })(dialog, spec_name);

                    // check requirements
                    var spec = gamedata['units'][spec_name];
                    var cost_space = get_leveled_quantity(spec['consumes_space'], unlock_level);
                    var cost_res = {}; var not_enough_res = null; // name of one needy resource
                    var resources_needed = {};

                    for(var res in gamedata['resources']) {
                        cost_res[res] = get_leveled_quantity(spec['build_cost_'+res]||0, unlock_level);
                        if(player.resource_state[res][1] < cost_res[res]) {
                            not_enough_res = res;
                            resources_needed[res] = cost_res[res] - player.resource_state[res][1];
                        }
                    }

                    var space_usage = player.get_army_space_usage_by_squad();
                    var available_space = player.stattab['total_space'] - space_usage['ALL'];
                    if(!player.squads_enabled() || !gamedata['produce_to_reserves']) {
                        available_space = Math.min(available_space, player.stattab['main_squad_space'] - space_usage[SQUAD_IDS.BASE_DEFENDERS.toString()]);
                    }

                    // check count limit
                    var count_limit_problem = false;
                    if(spec['limit'] && !player.is_cheater) {
                        var counts = player.get_army_unit_count_by_specname();
                        var cur_count = counts[spec['name']] || 0;
                        if(cur_count + 1 > spec['limit']) {
                            count_limit_problem = true;
                        }
                    }

                    if(count_limit_problem) {
                        var helper = get_requirements_help('unit_count', spec['name']);
                        if(helper) {
                            helper();
                        } else {
                            var s = gamedata['errors']['UNIT_COUNT_LIMIT'];
                            invoke_child_message_dialog(s['ui_title'], s['ui_name'], {'dialog': 'message_dialog_big'});
                        }
                    } else if(available_space < cost_space && !player.is_cheater) {
                        var dripper = w.get_dripper();
                        if (!dripper || dripper.times_fired <= 1) { // do not repeatedly display help when dripper is rapid-firing more clicks
                            var helper = get_requirements_help('unit_space', cost_space - available_space);
                            if(helper) {
                                helper();
                            } else {
                                var s = null;
                                if(player.squads_enabled()) {
                                    var reason = classify_unit_space_shortage();
                                    if(reason == 'base_defenders') {
                                        s = gamedata['strings']['requirements_help']['unit_space_base_defenders']['manage_base_defenders'];
                                    } else if(reason == 'total_army') {
                                        s = gamedata['strings']['requirements_help']['unit_space_total_army']['upgrade'];
                                    } else if(reason == 'recycle') {
                                        s = gamedata['strings']['requirements_help']['unit_space_total_army']['recycle'];
                                    }
                                } else {
                                    s = gamedata['strings']['requirements_help']['unit_space']['upgrade'];
                                }
                                if(s) {
                                    invoke_child_message_dialog(s['ui_title'], s['ui_description'], {'dialog': 'message_dialog_big'});
                                }
                            }
                        }
                    } else if(builder.is_repairing()) {
                        // prompt player to speedup repair
                        invoke_child_speedup_dialog('production');
                    } else if(builder.is_damaged()) {
                        // prompt player to initiate repair
                        invoke_child_repair_dialog();
                    } else if(builder.is_upgrading()) {
                        // prompt player to speedup upgrade
                        invoke_child_speedup_dialog('production');
                    } else if(builder.level < get_leveled_quantity(gamedata['units'][spec_name]['requires_factory_level']||0, unlock_level)) {
                        var err = gamedata['errors']['FACTORY_LEVEL_TOO_LOW'];
                        var builder_name = builder.spec['ui_name'];
                        invoke_child_message_dialog(err['ui_title'].replace('%s', builder_name),
                                                    err['ui_help'].replace('%s', builder_name).replace('%d', get_leveled_quantity(gamedata['units'][spec_name]['requires_factory_level']||0, unlock_level).toString()),
                                                    {'dialog':'message_dialog_big'});
                    } else if(not_enough_res) {
                        var helper = get_requirements_help('resources', resources_needed, {continuation:send_command});
                        if(helper) {
                            helper();
                        }
                    } else {
                        send_command();
                    }

                } else {
                    var helper = manufacture_dialog_unlock_helper(dialog.user_data['category'], spec_name, 'closure:builder'+(builder?'1':'0')+'unlock_level'+unlock_level.toString());
                    if(helper) { helper(); }
                }
            };
        })(name);
        widget.onclick = closure;

        if(!gamedata['client']['unit_manufacture_dripper']) {
            widget.dripper_cb = null; // disable dripper behavior
        }

        var qty_current = (name in unit_count ? unit_count[name] : 0);
        var qty_queued = (name in queue_count ? queue_count[name] : 0);

        widget.state = ((builder &&
                         unit_unlock_level(name) > 0 &&
                         builder.level >= get_leveled_quantity(gamedata['units'][name]['requires_factory_level']||0, unit_unlock_level(name))) ||
                        player.is_cheater) ? (asset_is_3d ? 'icon' : 'normal') : (asset_is_3d ? 'icon_disabled' : 'disabled_clickable');

        if((builder && unit_unlock_level(name) > 0) || qty_current + qty_queued > 0 || player.is_cheater) {
            var str = qty_current.toString();
            if(qty_queued > 0) {
                str += ' (+' + qty_queued.toString()+')';
            }
            dialog.widgets['grid_qty'+widget_name].str = str;
            dialog.widgets['sunken_grid_label'+widget_name].show = true;
        } else {
            dialog.widgets['grid_qty'+widget_name].str = dialog.data['widgets']['grid_qty']['ui_name_locked']; // '';
        }

        grid_x += 1;
        if(grid_x >= dialog.data['widgets']['grid']['array'][0]) {
            grid_x = 0; grid_y += 1;
        }
    }

    // empty out remaining grid cells
    while(grid_y < dialog.data['widgets']['grid']['array'][1]) {
        var widget_name = grid_x.toString()+','+grid_y.toString();
        dialog.widgets['grid'+widget_name].show =
            dialog.widgets['grid_qty'+widget_name].show =
            dialog.widgets['sunken_grid_bg'+widget_name].show =
            dialog.widgets['sunken_grid'+widget_name].show =
            dialog.widgets['sunken_grid_label'+widget_name].show = false;
        grid_x += 1;
        if(grid_x >= dialog.data['widgets']['grid']['array'][0]) {
            grid_x = 0; grid_y += 1;
        }
    }

    // fill in current production item
    dialog.widgets['in_production_icon'].show =
        dialog.widgets['in_production_time'].show =
        dialog.widgets['in_production_progress'].show =
        dialog.widgets['in_production_cancel'].show = (builder && manuf_queue.length > 0);

    if(builder && manuf_queue.length > 0) {
        var item = manuf_queue[0];
        dialog.widgets['in_production_icon'].bg_image = get_leveled_quantity(gamedata['units'][item['spec_name']]['art_asset'], item['level']);
        dialog.widgets['in_production_icon'].alpha = (gamedata['units'][item['spec_name']]['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1);

        var time_left = item['total_time'] - builder.manuf_done_time;
        if(builder.manuf_start_time > 0) {
            time_left -= (server_time - builder.manuf_start_time);
        }
        dialog.widgets['in_production_time'].str = pretty_print_time(time_left);

        var progress = 1 - time_left/item['total_time'];

        dialog.widgets['in_production_progress'].progress = progress;
        dialog.widgets['in_production_cancel'].onclick = (function(b,x,n) { return function() {
            cancel_manuf_item(b,x,n); }; })(builder, 0, item['spec_name']);
        dialog.widgets['in_production_cancel'].state = 'normal';
    }

    // fill in production queue display
    for(var box = 0; box < 4; box++) {
        dialog.widgets['queue'+box.toString()].show =
            dialog.widgets['queue_counter_bg'+box.toString()].show =
            dialog.widgets['queue_counter'+box.toString()].show =
            dialog.widgets['queue_cancel'+box.toString()].show = false;
    }

    var box = -1;
    var kind = null;
    var counters = [0,0,0,0];
    if(builder) {
        for(var i = 1; i < manuf_queue.length; i++) {
            var item = manuf_queue[i];
            if(item['spec_name'] != kind) {
                // start a new box
                box += 1;
                if(box >= 4) {
                    // ran out of boxes
                    break;
                }
                kind = item['spec_name'];
                dialog.widgets['queue'+box.toString()].show = true;
                dialog.widgets['queue'+box.toString()].bg_image = get_leveled_quantity(gamedata['units'][kind]['art_asset'], item['level']);
                dialog.widgets['queue'+box.toString()].alpha = (gamedata['units'][kind]['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1);
                dialog.widgets['queue_counter_bg'+box.toString()].show = true;
                dialog.widgets['queue_counter'+box.toString()].show = true;
                dialog.widgets['queue_cancel'+box.toString()].show = true;
                dialog.widgets['queue_cancel'+box.toString()].state = 'normal';
                dialog.widgets['queue_cancel'+box.toString()].onclick = (function(b,x,n) { return function() { cancel_manuf_item(b,x,n); }; })(builder, i, kind);
                counters[box] = 1;
            } else {
                counters[box] += 1;
            }
        }
    }

    for(var b = 0; b < 4; b++) {
        dialog.widgets['queue_counter'+b.toString()].str = counters[b].toString();
    }

    // fill in price display and "finish" button callback
    var closure;
    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].tooltip.str = '';
    dialog.widgets['price_spinner'].show = (builder && !builder.is_in_sync());

    if(!player.unit_speedups_enabled()) {
        dialog.widgets['finish_button'].show = dialog.widgets['price_display'].show = false;
    } else {
        if(builder && !builder.is_in_sync()) {
            dialog.widgets['price_display'].str = '';
            closure = null;
            dialog.widgets['price_display'].onclick = null;
            dialog.widgets['finish_button'].state = 'disabled';
            dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name_pending'];
            dialog.widgets['price_display'].tooltip.str = dialog.widgets['finish_button'].tooltip.str = '';
        } else if(!builder || manuf_queue.length < 1 || !session.enable_dialog_completion_buttons) {
            dialog.widgets['price_display'].str = '';
            closure = null;
            dialog.widgets['price_display'].onclick = null;
            dialog.widgets['finish_button'].state = 'disabled';
            dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'];
            dialog.widgets['price_display'].tooltip.str = dialog.widgets['finish_button'].tooltip.str = '';
        } else {
            // note: SPEEDUP_FOR_MONEY will repair the factory rather than speed up production if factory is damaged
            dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'+(builder.is_damaged() ? '_repair' : '')];
            dialog.widgets['finish_button'].state = 'normal';

            var price = Store.get_user_currency_price(builder.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null);
            dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
            dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);

            if(price == 0) {
                closure = (function(_builder) { return function() {
                    if(selection.ui.widgets['coverup_queue'].show || selection.ui.widgets['coverup_all'].show) { return; } // ???
                    send_to_server.func(["CAST_SPELL", _builder.id, "SPEEDUP_FOR_FREE"]);
                    invoke_ui_locker(_builder.request_sync(), function() { change_selection(null); });
                }; })(builder);
            } else if(price > 0) {
                closure = (function(_builder) { return function() {
                    var dialog = selection.ui;
                    if(dialog.widgets['coverup_queue'].show || dialog.widgets['coverup_all'].show) { return; }
                    var cleanup_cb = (function (_dialog) { return function() {
                    }; })(dialog);

                    if(Store.place_user_currency_order(_builder.id, "SPEEDUP_FOR_MONEY", null, cleanup_cb)) {
                        invoke_ui_locker(_builder.request_sync(), function() { change_selection(null); });
                    }
                };})(builder);
            } else {
                // invalid order?
                if(builder.is_damaged() && !builder.is_repairing()) {
                    closure = (function (obj) { return function() {
                        change_selection(obj); invoke_repair_dialog();
                    }; })(builder);
                } else {
                    closure = null;
                    dialog.widgets['finish_button'].state = 'disabled';
                }
            }
        }

        dialog.widgets['price_display'].onclick =
            dialog.widgets['finish_button'].onclick = closure;
    } // END unit speedups available

    // fill in capacity display
    var space_usage = player.get_army_space_usage_by_squad();
    var total_capacity = player.stattab['total_space'];

    var used_capacity = space_usage['ALL'];
    var available_space = total_capacity - used_capacity;
    if(!player.squads_enabled() || !gamedata['produce_to_reserves']) {
        available_space = Math.min(available_space, player.stattab['main_squad_space'] - space_usage[SQUAD_IDS.BASE_DEFENDERS.toString()]);
    }
    dialog.widgets['capacity_bar'].progress = used_capacity/Math.max(1, total_capacity);
    dialog.widgets['capacity_label'].str = dialog.widgets['capacity_label'].data['ui_name'].replace('%s',used_capacity.toString() + '/' + total_capacity.toString());

    var overflow = false;
    var squads_enabled = player.squads_enabled();
    var queue_usage = 0;
    if(squads_enabled && gamedata['produce_to_reserves'] && manuf_queue) {
        // check if we're in an overflow situation
        for(var i = 0; i < manuf_queue.length; i++) {
            var item = manuf_queue[i];
            queue_usage += get_leveled_quantity(gamedata['units'][item['spec_name']]['consumes_space'], item['level']||1);
        }
        //if(dialog.user_data['current_unit']) { queue_usage += get_leveled_quantity(gamedata['units'][dialog.user_data['current_unit']]['consumes_space'], unit_unlock_level(dialog.user_data['current_unit'])||1); }
        if(space_usage[SQUAD_IDS.BASE_DEFENDERS.toString()] + queue_usage > player.stattab['main_squad_space']) {
            overflow = true;
        }
    }
    dialog.widgets['robot_in_production'].show = dialog.widgets['production_queue'].show = !squads_enabled || (queue_usage == 0);
    dialog.widgets['producing_to_base_defenders'].show = squads_enabled && queue_usage > 0 && !overflow;
    dialog.widgets['overflow_to_reserves'].show = squads_enabled && queue_usage > 0 && overflow;

    dialog.widgets['robot_in_production'].str = gamedata['spells']['MAKE_DROIDS']['ui_unit_in_progress'];
    dialog.widgets['producing_to_base_defenders'].str = gamedata['spells']['MAKE_DROIDS']['ui_to_base_defenders'];
    dialog.widgets['overflow_to_reserves'].str = gamedata['spells']['MAKE_DROIDS']['ui_to_reserves'];

    if(dialog.widgets['production_queue'].show) {
        var togo = (builder && !builder.is_damaged() && builder.is_manufacturing() ? builder.time_until_finish() : -1);
        if(togo > 0) {
            dialog.widgets['production_queue'].str =  dialog.data['widgets']['production_queue']['ui_name_togo'].replace('%s', pretty_print_time_brief(togo));
        } else {
            dialog.widgets['production_queue'].str = gamedata['spells']['MAKE_DROIDS']['ui_queue'];
        }
    }
    // update build requirements text
    if(dialog.user_data['current_unit']) {
        var spec = gamedata['units'][dialog.user_data['current_unit']];
        var level = unit_unlock_level(dialog.user_data['current_unit']);
        if(level < 1) { level = 1; }

        for(var res in gamedata['resources']) {
            if('requirements_'+res+'_value' in dialog.widgets) {
                var cost = get_leveled_quantity(spec['build_cost_'+res]||0, level);
                if(cost > 0) {
                    dialog.widgets['requirements_'+res+'_value'].show =
                        dialog.widgets['requirements_'+res+'_icon'].show = true;
                    dialog.widgets['requirements_'+res+'_value'].str = pretty_print_number(cost);
                    dialog.widgets['requirements_'+res+'_value'].tooltip.str = dialog.data['widgets']['requirements_'+res+'_value']['ui_tooltip'].replace('%RES', gamedata['resources'][res]['ui_name']).replace('%VERB', gamedata['spells']['MAKE_DROIDS']['ui_name'].toLowerCase());
                    dialog.widgets['requirements_'+res+'_value'].text_color = (player.resource_state[res][1] >= cost ? SPUI.good_text_color : SPUI.error_text_color);
                    // don't show button for topup, since the main "Use Resources" button will take care of it
                    if(!gamedata['resources'][res]['allow_topup'] && player.resource_state[res][1] < cost) {
                        var helper = get_requirements_help(res, cost - player.resource_state[res][1]);
                        dialog.widgets['resource_'+res+'_button'].show = !!helper;
                        dialog.widgets['resource_'+res+'_button'].onclick = helper;
                    } else {
                        dialog.widgets['resource_'+res+'_button'].show = false;
                    }
                } else {
                    dialog.widgets['requirements_'+res+'_value'].show =
                        dialog.widgets['requirements_'+res+'_icon'].show =
                        dialog.widgets['resource_'+res+'_button'].show = false;
                }
            }
        }

        var cost_space = get_leveled_quantity(spec['consumes_space'], level);
        dialog.widgets['requirements_space_value'].str = pretty_print_number(cost_space);
        dialog.widgets['requirements_space_value'].tooltip.str = dialog.data['widgets']['requirements_space_value']['ui_tooltip'].replace('%TOTAL_SPACE_BUILDING', gamedata['buildings'][total_space_building()]['ui_name']);
        dialog.widgets['requirements_space_value'].text_color = (available_space >= cost_space ? SPUI.good_text_color : SPUI.error_text_color);
        if(available_space < cost_space) {
            var helper = get_requirements_help('unit_space', cost_space - available_space);
            dialog.widgets['resource_space_button'].show = !!helper;
            dialog.widgets['resource_space_button'].onclick = helper;
        } else {
            dialog.widgets['resource_space_button'].show = false;
        }

        var cost_time = get_leveled_quantity(spec['build_time'], level);
        if(builder) {
            var speed = builder.get_stat('manufacture_speed', builder.get_leveled_quantity(builder.spec['manufacture_speed'] || 1.0));
            cost_time /= speed;
        }
        dialog.widgets['requirements_time_value'].str = pretty_print_time(cost_time);
        dialog.widgets['requirements_time_value'].tooltip.str = dialog.data['widgets']['requirements_time_value']['ui_tooltip'].replace('%VERB', gamedata['spells']['MAKE_DROIDS']['ui_name'].toLowerCase());
    }
}

// (inefficiently) find a particular object by its type and return a reference to it
// (or null if not found)
function find_object_by_type(specname) {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.spec['name'] === specname) {
            return obj;
        }
    }
    return null;
}

function find_all_objects_by_type(specname) {
    var ret = [];
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.spec['name'] === specname) {
            ret.push(obj);
        }
    }
    return ret;
}

function find_highest_level_object_by_type(specname) {
    var obj = null;
    for(var id in session.cur_objects.objects) {
        var o = session.cur_objects.objects[id];
        if(o.spec['name'] === specname) {
            if(!obj || o.level > obj.level) {
                obj = o;
            }
        }
    }
    return obj;
}
function count_objects_by_type(specname) {
    var count = 0;
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.spec['name'] === specname) {
            count += 1;
        }
    }
    return count;
}
function find_object_with_spell(spellname) {
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.spec['spells']) {
            for(var i = 0; i < obj.spec['spells'].length; i++) {
                if(obj.spec['spells'][i] === spellname) {
                    return obj;
                }
            }
        }
    }
    return null;
}


function invoke_crafting_table_of_contents_dialog(category) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['crafting_table_of_contents_dialog']);
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'crafting_table_of_contents_dialog';
    dialog.user_data['category'] = category;
    dialog.widgets['close_button'].onclick = function() { change_selection(null); };

    init_army_dialog_buttons(dialog.widgets['army_dialog_buttons_crafting'], (category in ARMY_DIALOG_BUTTONS ? category : 'crafting'), 'crafting_table_of_contents_dialog');

    var builder_type = get_workshop_for(category);
    var builder = find_object_by_type(builder_type);

    dialog.widgets['title'].str = gamedata['buildings'][builder_type]['ui_name'];
    var catspec = gamedata['crafting']['categories'][category];
    dialog.widgets['category_name'].str = catspec['ui_name'];
    dialog.user_data['rowdata'] = []; // for now, "crafting subcategories" are just the names of item sets

    dialog.widgets['coverup_all'].show =
        dialog.widgets['coverup_text'].show =
        dialog.widgets['coverup_icon'].show =
        dialog.widgets['coverup_button'].show = (!builder && !player.is_cheater);

    if(!builder && !player.is_cheater) {
        // workshop not present
        dialog.widgets['coverup_text'].str = dialog.data['widgets']['coverup_text']['ui_name'].replace('%s1', catspec['ui_name']).replace('%s2', gamedata['buildings'][builder_type]['ui_name_indefinite']);
        dialog.widgets['coverup_icon'].asset = get_leveled_quantity(gamedata['buildings'][builder_type]['art_asset'], 1);
        // special-case because some buildings are really tall
        dialog.widgets['coverup_icon'].xy = vec_add(dialog.data['widgets']['coverup_icon']['xy'], (gamedata['buildings'][builder_type]['hero_icon_pos'] || [0,0]));
        var helper = get_requirements_help(read_predicate({'predicate':'BUILDING_QUANTITY', 'building_type':builder_type, 'trigger_qty':1}), null, {short_circuit:true});
        dialog.widgets['coverup_button'].onclick = (helper ? helper : function() { invoke_build_dialog('production'); });
    } else {
        // construct recipe list
        for(var name in gamedata['crafting']['recipes']) {
            var spec = gamedata['crafting']['recipes'][name];
            if(spec['crafting_category'] != category) { continue; }
            if(!('associated_item_set' in spec)) { continue; }
            if(spec['developer_only'] && (spin_secure_mode || !player.is_developer())) { continue; }
            if('show_if' in spec && !read_predicate(spec['show_if']).is_satisfied(player, null)) { continue; }
            if('activation' in spec && !read_predicate(spec['activation']).is_satisfied(player, null)) { continue; }
            if(goog.array.contains(dialog.user_data['rowdata'], spec['associated_item_set'])) { continue; }
            dialog.user_data['rowdata'].push(spec['associated_item_set']);
        }
    }
    dialog.user_data['rowfunc'] = crafting_subcategory_setup_row;
    dialog.user_data['roworder'] = 'left_right_top_bottom';
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['subcategory']['array'][1];
    dialog.user_data['cols_per_page'] = dialog.data['widgets']['subcategory']['array'][0];
    scrollable_dialog_change_page(dialog, 0);
}
function crafting_subcategory_setup_row(dialog, row_col, rowdata) {
    var wname = SPUI.get_array_widget_name('subcategory', dialog.data['widgets']['subcategory']['array'], row_col);
    dialog.widgets[wname].show = !!rowdata;
    if(!rowdata) { return; }
    var set_spec = gamedata['item_sets'][rowdata];
    dialog.widgets[wname].widgets['icon'].asset = set_spec['icon'];
    dialog.widgets[wname].widgets['name'].str = set_spec['ui_name'];
    dialog.widgets[wname].widgets['description'].set_text_with_linebreaking(set_spec['ui_description']);
    dialog.widgets[wname].widgets['frame'].onclick = (function (_setname) { return function(w) {
        invoke_crafting_dialog(dialog.user_data['category'], _setname);
    }; })(rowdata);
}

/** @param {string} newcategory
    @param {string|null=} newsubcategory
    @param {number=} newpage */
function invoke_crafting_dialog(newcategory, newsubcategory, newpage) {
    if(!newcategory || newcategory == 'turret_heads') { // pick a reasonable default
        goog.object.forEach(gamedata['crafting']['categories'], function(entry, name) {
            if('dialog' in entry && entry['dialog'] != 'crafting_dialog') { return; } // do not display
            if(entry['table_of_contents']) { return; } // too complex to handle
            newcategory = name;
        });
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['crafting_dialog']);
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'crafting_dialog';
    dialog.user_data['category'] = newcategory;
    dialog.user_data['subcategory'] = newsubcategory || null;
    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    dialog.widgets['dev_title'].show = player.is_cheater;

    init_army_dialog_buttons(dialog.widgets['army_dialog_buttons_crafting'], (newcategory in ARMY_DIALOG_BUTTONS ? newcategory : 'crafting'), 'crafting_dialog');

    var catspec = gamedata['crafting']['categories'][newcategory];
    dialog.user_data['categories'] = [];

    if(catspec['table_of_contents']) {
        // for table-of-contents categories, don't show category buttons, just show a backlink to the table of contents
        if(!newsubcategory) {
            throw Error('crafting category '+newcategory+' has a table_of_contents and so requires a subcategory parameter');
        }
        var subcategory_spec = gamedata['item_sets'][newsubcategory];
        dialog.widgets['subcategory_name'].set_text_bbcode('[color=#'+SPUI.disabled_text_color.hex()+']'+catspec['ui_name'] + '  >[/color]  ' + subcategory_spec['ui_name']);
        dialog.widgets['subcategory_name'].onclick = (function (_catspec) { return function(w) {
            change_selection_ui(null);
            invoke_crafting_table_of_contents_dialog(_catspec['name']); // XXX this should preselect (scroll to) newsubcategory
        }; })(catspec);
    } else {
        // set up category buttons
        goog.object.forEach(gamedata['crafting']['categories'], function(entry, name) {
            if('dialog' in entry && entry['dialog'] != 'crafting_dialog') { return; } // do not display
            if('category_group' in entry && !goog.array.contains(entry['category_group'], newcategory)) { return; } // do not display
            if('show_if' in entry && !read_predicate(entry['show_if']).is_satisfied(player, null)) { return; } // hidden

            dialog.user_data['categories'].push(entry);
            if(dialog.user_data['categories'].length >= dialog.data['widgets']['category_button']['array'][0]) { throw Error('not enough category_button array entries!'); }
        });
    }

    dialog.widgets['scroll_left'].widgets['scroll_left'].onclick = function(w) { var dialog = w.parent.parent; dialog.user_data['scrolled'] = true; crafting_dialog_scroll(dialog, dialog.user_data['page']-1); };
    dialog.widgets['scroll_right'].widgets['scroll_right'].onclick = function(w) { var dialog = w.parent.parent; dialog.user_data['scrolled'] = true; crafting_dialog_scroll(dialog, dialog.user_data['page']+1); };

    dialog.ondraw = update_crafting_dialog;
    crafting_dialog_change_category(dialog, newcategory, newpage || 0);
    return dialog;
}

/** @param {SPUI.Dialog} dialog
    @param {string} category
    @param {number=} page */
function crafting_dialog_change_category(dialog, category, page) {
    dialog.user_data['category'] = category;
    dialog.user_data['recipes'] = null;
    dialog.user_data['selected_recipe'] = null;
    dialog.user_data['on_use_recipe'] = null;
    dialog.user_data['scrolled'] = false;
    dialog.user_data['open_time'] = client_time;
    // special case for mines, there is only one column of recipes
    dialog.user_data['recipe_columns'] = (category == 'mines' ? 1 : dialog.data['widgets']['recipe_icon']['array'][0]);

    // center scroll arrows relative to recipe icons
    goog.array.forEach(['scroll_left', 'scroll_right'], function(wname) {
        dialog.widgets[wname].xy[0] = Math.floor(dialog.data['widgets'][wname]['xy'][0] + (dialog.user_data['recipe_columns'] - 1)/2 * dialog.data['widgets']['recipe_icon']['array_offset'][0]);
    });

    var category_ui_name = null;
    var cats = dialog.user_data['categories'];
    for(var i = 0; i < dialog.data['widgets']['category_button']['array'][0]; i++) {
        dialog.widgets['category_button'+i.toString()].show = (i < cats.length);
        if(i < cats.length) {
            var entry = cats[i];
            // manually compute X coordinate to center all the visible buttons
            var x = Math.floor(dialog.wh[0]/2 + (i - cats.length/2) * dialog.data['widgets']['category_button']['array_offset'][0] + dialog.data['widgets']['category_button']['xy'][0]);
            dialog.widgets['category_button'+i.toString()].xy = [x, dialog.data['widgets']['category_button']['xy'][1]];
            dialog.widgets['category_button'+i.toString()].str = entry['ui_name'];
            dialog.widgets['category_button'+i.toString()].text_color = (category === entry['name'] ? SPUI.default_text_color : SPUI.disabled_text_color);
            dialog.widgets['category_button'+i.toString()].state = (category === entry['name'] ? 'active' : 'normal');
            if(category === entry['name']) { category_ui_name = entry['ui_name']; }
            dialog.widgets['category_button'+i.toString()].onclick = (function (_name) { return function(w) { crafting_dialog_change_category(w.parent, _name); }; })(entry['name']);
        }
    }

    var builder_type = get_workshop_for(category);

    dialog.widgets['title'].str = gamedata['buildings'][builder_type]['ui_name'];

    // check for presence of appropriate workshop
    var builder = find_object_by_type(builder_type);
    dialog.user_data['builder'] = builder;

    dialog.widgets['coverup_all'].show =
        dialog.widgets['coverup_text'].show =
        dialog.widgets['coverup_icon'].show =
        dialog.widgets['coverup_button'].show = (!builder && !player.is_cheater);

    var preselect = null;

    if(!builder && !player.is_cheater) {
        // workshop not present
        dialog.widgets['btmbar'].show =
            dialog.widgets['price_display'].show =
            dialog.widgets['finish_button'].show = false;
        dialog.widgets['coverup_text'].str = dialog.data['widgets']['coverup_text']['ui_name'].replace('%s1', category_ui_name).replace('%s2', gamedata['buildings'][builder_type]['ui_name_indefinite']);
        dialog.widgets['coverup_icon'].asset = get_leveled_quantity(gamedata['buildings'][builder_type]['art_asset'], 1);
        // special-case because some buildings are really tall
        dialog.widgets['coverup_icon'].xy = vec_add(dialog.data['widgets']['coverup_icon']['xy'], (gamedata['buildings'][builder_type]['hero_icon_pos'] || [0,0]));
        var helper = get_requirements_help(read_predicate({'predicate':'BUILDING_QUANTITY', 'building_type':builder_type, 'trigger_qty':1}), null, {short_circuit:true});
        dialog.widgets['coverup_button'].onclick = (helper ? helper : function() { invoke_build_dialog('production'); });

    } else {
        // construct recipe list
        dialog.user_data['recipes'] = [];

        for(var name in gamedata['crafting']['recipes']) {
            var spec = gamedata['crafting']['recipes'][name];
            if(spec['crafting_category'] != category) { continue; }

            // subcategory/associated_item_set mismatch
            if(dialog.user_data['subcategory'] && (dialog.user_data['subcategory'] != spec['associated_item_set'])) { continue; }

            if(spec['developer_only'] && (spin_secure_mode || !player.is_developer())) { continue; }
            if('show_if' in spec && !read_predicate(spec['show_if']).is_satisfied(player, null)) { continue; }
            if('activation' in spec && !read_predicate(spec['activation']).is_satisfied(player, null)) { continue; }
            dialog.user_data['recipes'].push(name);
            if(!preselect) { preselect = name; }
        }
    }

    goog.array.forEach(['recipe','status'], function(wname) {
        if(wname in dialog.widgets) {
            dialog.remove(dialog.widgets[wname]);
            delete dialog.widgets[wname];
        }
        var dialog_name = 'crafting_dialog_'+wname+'_'+category;
        if(!(dialog_name in gamedata['dialogs'])) {
            throw Error('missing dialog: '+dialog_name);
        }
        var w = new SPUI.Dialog(gamedata['dialogs'][dialog_name]);
        dialog.add(w);
        w.xy = w.data['xy'];
        dialog.widgets[wname] = w;
    });

    if(category == 'mines') {
        crafting_dialog_init_status_mines(dialog.widgets['status']);
    } else if(category == 'leaders') {
        crafting_dialog_init_status_leaders(dialog.widgets['status']);
    } else if(category == 'missiles') {
        crafting_dialog_init_status_missiles(dialog.widgets['status']);
    } else {
        throw Error('unhandled category '+category);
    }

    if(player.upgrade_bar_enabled()) {
        UpgradeBar.invoke(dialog, 'building', (builder ? builder.spec['name'] : null), (builder ? builder.level+1 : -1), (builder ? builder.id : null));
    }

    crafting_dialog_scroll(dialog, page || 0);

    if(dialog.user_data['page'] == 0) {
        // select first buildable recipe
        crafting_dialog_select_recipe(dialog.widgets['recipe'], preselect);
    }
}
function get_max_minefields() {
    if(!('minefield' in gamedata['buildings'])) { return 0; }
    var spec = gamedata['buildings']['minefield'];
    return spec['limit_requires'].length;
}
function crafting_dialog_init_status_mines(dialog) {
    var dims = dialog.data['widgets']['mine_slot']['array'];
    var max_minefields = (dialog.parent.user_data['builder'] ? get_max_minefields() : 0);
    for(var y = 0; y < dims[1]; y++) {
        dialog.widgets['row_labels'+y.toString()].str = (1+y).toString();
        dialog.widgets['row_labels'+y.toString()].show = (y*dims[0]) < max_minefields;
    }
    for(var x = 0; x < dims[0]; x++) {
        dialog.widgets['col_labels'+x.toString()].show = (max_minefields > x);
        dialog.widgets['col_labels'+x.toString()].str = String.fromCharCode('A'.charCodeAt(0)+x);
    }
    dialog.user_data['wname_to_tag'] = {};
    for(var y = 0; y < dims[1]; y++) {
        for(var x = 0; x < dims[0]; x++) {
            var wname = x.toString()+','+y.toString();
            var tag = dialog.widgets['col_labels'+x.toString()].str + dialog.widgets['row_labels'+y.toString()].str;
            dialog.user_data['wname_to_tag'][wname] = tag;
            dialog.widgets['mine_slot'+wname].show = ((y*dims[0]+x) < max_minefields);
        }
    }
}
function crafting_dialog_init_status_missiles(dialog) {
    var dims = dialog.data['widgets']['mine_slot']['array'];
    dialog.user_data['wname_to_tag'] = {};
    for(var y = 0; y < dims[1]; y++) {
        for(var x = 0; x < dims[0]; x++) {
            var wname = x.toString()+','+y.toString();
            var tag = wname;
            dialog.user_data['wname_to_tag'][wname] = tag; // not sure we need this for missile slots
            dialog.widgets['mine_slot'+wname].show = true; // update_status_missiles() takes care of hiding slots beyond the max available number
        }
    }
}
function crafting_dialog_init_status_leaders(dialog) {
}

function crafting_dialog_scroll(dialog, page) {
    dialog.user_data['recipes_by_widget'] = null;
    var chapter_recipes = (dialog.user_data['recipes'] ? dialog.user_data['recipes'].length : 0);
    var recipes_per_page = dialog.user_data['recipe_columns']*dialog.data['widgets']['recipe_icon']['array'][1];
    var chapter_pages = dialog.user_data['chapter_pages'] = Math.floor((chapter_recipes+recipes_per_page-1)/recipes_per_page);
    dialog.user_data['page'] = page = (chapter_recipes === 0 ? 0 : clamp(page, 0, chapter_pages-1));

    player.quest_tracked_dirty = true;
}
function crafting_dialog_select_recipe(dialog, specname) {
    dialog.parent.user_data['selected_recipe'] = specname;
    dialog.parent.user_data['on_use_recipe'] = null; // will be set by an ondraw update

    if(!specname) { dialog.show = false; return; }

    var recipe = gamedata['crafting']['recipes'][specname];
    dialog.show = true;
    dialog.user_data['recipe'] = recipe;
    if(recipe['crafting_category'] == 'mines') {
        crafting_dialog_select_recipe_mines(dialog, specname, recipe);
    } else if(recipe['crafting_category'] == 'missiles') {
        crafting_dialog_select_recipe_missiles(dialog, specname, recipe);
    } else if(recipe['crafting_category'] == 'leaders') {
        crafting_dialog_select_recipe_leaders(dialog, specname, recipe);
    }
}
function crafting_dialog_select_recipe_mines(dialog, specname, recipe) {
    dialog.widgets['name'].str = get_crafting_recipe_ui_name(recipe);
    dialog.widgets['icon'].asset = get_crafting_recipe_icon(recipe);
    dialog.widgets['frame'].onclick = function(w) {
        if(w.parent.parent) {
            var func = w.parent.parent.user_data['on_use_recipe'];
            if(func) { func(); }
        }
    };

    var mine_spec = ItemDisplay.get_crafting_recipe_product_spec(recipe);
    var mine_spell = ItemDisplay.get_inventory_item_weapon_spell(mine_spec);
    init_damage_vs_icons(dialog, {'kind':'building', 'ui_damage_vs':{}}, // fake building spec to fool init_damage_vs_icons()
                         mine_spell);
    var stat_spec = mine_spec;
    var stat_level = mine_spec['level'];
    var stat_spell = mine_spell;
    var stat_spell_level = 1;

    // set up stats display for this kind of recipe
    var statlist = gamedata['crafting']['categories'][recipe['crafting_category']]['display_stats'] || [];
    goog.array.forEach(['descriptionL0', 'descriptionR0', 'descriptionL1', 'descriptionR1'], function(wname, i) {
        if(i < statlist.length) {
            dialog.widgets[wname].show = true;
            var stat = statlist[i];
            var modchain = null;
            // hack - get the .str for the label, then reset the widget to be the stat value display, get the .str, and combine them
            ModChain.display_label_widget(dialog.widgets[wname], stat, stat_spell);
            var label_str = dialog.widgets[wname].str;
            ModChain.display_widget(dialog.widgets[wname], stat, modchain, stat_spec, stat_level, stat_spell, stat_spell_level);
            var value_str = dialog.widgets[wname].str;
            dialog.widgets[wname].str = label_str + ': ' + value_str;
        } else {
            dialog.widgets[wname].show = false;
        }
    });
}
function crafting_dialog_select_recipe_missiles(dialog, specname, recipe) {
    var product_spec = ItemDisplay.get_crafting_recipe_product_spec(recipe);
    dialog.widgets['name'].str = ItemDisplay.get_inventory_item_ui_name_long(product_spec);
    dialog.widgets['description'].set_text_with_linebreaking(product_spec['ui_description']); // XXX overflow?
    ItemDisplay.display_item(dialog.widgets['item'], {'spec':product_spec['name']}, {context_parent: dialog.parent});
    ItemDisplay.attach_inventory_item_tooltip(dialog.widgets['item'].widgets['frame'], {'spec':product_spec['name']}, dialog.parent);
    dialog.widgets['item'].widgets['frame'].onclick = function(w) {
        if(w.parent.parent.parent) {
            var func = w.parent.parent.parent.user_data['on_use_recipe'];
            if(func) { func(); }
        }
    };

    // set up stats display for this kind of recipe
    var statlist = gamedata['crafting']['categories'][recipe['crafting_category']]['display_stats'] || [];

    var product_spell = gamedata['spells'][product_spec['use']['spellname']];
    if(gamedata['crafting']['categories'][recipe['crafting_category']]['display_damage_vs']) {
        init_damage_vs_icons(dialog, {'kind':'building', 'ui_damage_vs':{}}, // fake building spec to fool init_damage_vs_icons()
                             product_spell);
    } else {
        init_damage_vs_icons(dialog, null, null);
    }

    var stat_spec = product_spec;
    var stat_level = product_spec['level'] || 1;
    var stat_spell = product_spell;
    var stat_spell_level = 1;

    for(var y = 0; y < dialog.data['widgets']['features']['array'][1]; y++) {
        for(var x = 0; x < dialog.data['widgets']['features']['array'][0]; x++) {
            var i = y * dialog.data['widgets']['features']['array'][0] + x;
            var wname = SPUI.get_array_widget_name('features', dialog.data['widgets']['features']['array'], [x,y]);
            if(i < statlist.length) {
                dialog.widgets[wname].show = true;
                var stat = statlist[i];
                var modchain = null;
                // hack - get the .str for the label, then reset the widget to be the stat value display, get the .str, and combine them
                ModChain.display_label_widget(dialog.widgets[wname], stat, stat_spell);
                var label_str = dialog.widgets[wname].str;
                ModChain.display_widget(dialog.widgets[wname], stat, modchain, stat_spec, stat_level, stat_spell, stat_spell_level);
                var value_str = dialog.widgets[wname].str;
                dialog.widgets[wname].str = label_str + ': ' + value_str;
            } else {
                dialog.widgets[wname].show = false;
            }
        }
    }
}

function crafting_dialog_select_recipe_leaders(dialog, specname, recipe) {
    var leader_spec = ItemDisplay.get_crafting_recipe_product_spec(recipe);
    var set_spec = gamedata['item_sets'][leader_spec['item_set']];
    var ui_item_set = set_spec['ui_name'];
    var ui_level = leader_spec['level'] || 1;
    var ui_index = set_spec['members'].indexOf(leader_spec['name']) + 1;
    var ui_members = set_spec['members'].length;
    var ui_subtitle = ItemDisplay.get_inventory_item_ui_subtitle(leader_spec);
    dialog.widgets['topinfo'].set_text_bbcode(dialog.data['widgets']['topinfo']['ui_name'].replace('%ITEM_SET', ui_item_set).replace('%INDEX', ui_index.toString()).replace('%MEMBERS', ui_members.toString()).replace('%SUBTITLE', ui_subtitle).replace('%LEVEL', ui_level.toString()));
    ItemDisplay.display_item(dialog.widgets['item'], {'spec':leader_spec['name']}, {context_parent: dialog.parent});
    ItemDisplay.attach_inventory_item_tooltip(dialog.widgets['item'].widgets['frame'], {'spec':leader_spec['name']}, dialog.parent);
    dialog.widgets['item'].widgets['frame'].onclick = function(w) {
        if(w.parent.parent.parent) {
            var func = w.parent.parent.parent.user_data['on_use_recipe'];
            if(func) { func(); }
        }
    };

    dialog.widgets['name'].str = ItemDisplay.get_inventory_item_ui_name_long(leader_spec);
    dialog.widgets['name'].text_color = ItemDisplay.get_inventory_item_color(leader_spec);

    // work on line breaking
    var bbtext = ItemDisplay.get_inventory_item_ui_description(leader_spec, 1, null, {hide_item_set:true});
    dialog.widgets['description'].set_text_bbcode(bbtext);
    if(dialog.widgets['description'].clip_to_max_lines(dialog.data['widgets']['description']['max_lines'], dialog.data['widgets']['description']['ui_name_seemore'])) {
        // there was an overflow, add tooltip
        ItemDisplay.attach_inventory_item_tooltip(dialog.widgets['description'], {'spec':leader_spec['name']}, dialog.parent);
    } else {
        ItemDisplay.remove_inventory_item_tooltip(dialog.widgets['description']);
    }
}


function update_crafting_dialog_recipe_common(dialog) {
    var specname = dialog.parent.user_data['selected_recipe'];
    var recipe = gamedata['crafting']['recipes'][specname];
    var builder = dialog.parent.user_data['builder'];
    dialog.show = true;
    var grid = [0,0], dims = dialog.data['widgets']['requirements_icon']['array'];

    goog.object.forEach(gamedata['resources'], function(resdata, resname) {
        var wname = grid[0].toString()+','+grid[1].toString();
        var cost = recipe['cost'][resname] || 0;
        dialog.widgets['requirements_icon'+wname].show =
            dialog.widgets['requirements_value'+wname].show = (cost > 0);
        if(cost > 0) {
            dialog.widgets['requirements_icon'+wname].asset = resdata['icon_small'];
            dialog.widgets['requirements_value'+wname].str = pretty_print_qty_brief(cost);
            dialog.widgets['requirements_value'+wname].tooltip.str = dialog.data['widgets']['requirements_value']['ui_tooltip'].replace('%res', resdata['ui_name']).replace('%qty', pretty_print_number(cost));

            dialog.widgets['requirements_value'+wname].text_color = (cost > player.resource_state[resname][1] ? SPUI.error_text_color : SPUI.good_text_color);
        }
        grid[1] += 1;
        if(grid[1] >= dims[1]) {
            grid[1] = 0;
            grid[0] += 1;
        }
    });

    while(grid[0] < dims[0]) {
        while(grid[1] < dims[1]) {
            var wname = grid[0].toString()+','+grid[1].toString();
            dialog.widgets['requirements_icon'+wname].show =
                dialog.widgets['requirements_value'+wname].show = false;
            grid[1] += 1;
        }
        grid[1] = 0;
        grid[0] += 1;
    }

    var cost_time = recipe['craft_time'];
    if(builder) {
        var speed = builder.get_stat('crafting_speed', builder.get_leveled_quantity(builder.spec['crafting_speed'] || 1.0));
        cost_time = Math.max(1, Math.floor(cost_time / speed));
    }

    dialog.widgets['requirements_time_value'].str = pretty_print_time_brief(cost_time);
}
function update_crafting_dialog_recipe_mines(dialog) {
    update_crafting_dialog_recipe_common(dialog);
}
function update_crafting_dialog_recipe_missiles(dialog) {
    update_crafting_dialog_recipe_leaders(dialog);
}
function update_crafting_dialog_recipe_leaders(dialog) {
    update_crafting_dialog_recipe_common(dialog);
    var specname = dialog.parent.user_data['selected_recipe'];
    var recipe = gamedata['crafting']['recipes'][specname];

    var can_craft = true;
    // note: like the main crafting_dialog recipe update, only gray out if a predicate is false, not if there is resource/ingredient trouble
    // can_craft = dialog.user_data['builder'] && can_cast_spell(dialog.user_data['builder'].id, 'CRAFT_FOR_FREE', [{'recipe': specname}]);
    can_craft = !(('requires' in recipe) && !player.is_cheater && !read_predicate(recipe['requires']).is_satisfied(player, null));

    dialog.widgets['item'].widgets['frame'].state = (can_craft ? 'normal' : 'disabled_clickable');


    var ingr_list = recipe['ingredients'] || [];
    ItemDisplay.display_item_array(dialog, 'requirements_item', ingr_list, {context_parent: dialog.parent,
                                                                            hide_tooltip: true});
    var by_specname = {};
    for(var i = 0; i < dialog.data['widgets']['requirements_item']['array'][0]; i++) {
        if(i < ingr_list.length) {
            var ingr = ingr_list[i];
            var ingr_spec = gamedata['items'][ingr['spec']];
            var ingr_stack = ('stack' in ingr ? ingr['stack'] : 1);
            var ui_ingr = ItemDisplay.get_inventory_item_stack_prefix(ingr_spec, ingr_stack) + ItemDisplay.get_inventory_item_ui_name_long(ingr_spec);
            dialog.widgets['requirements_item'+i.toString()].widgets['frame'].tooltip.str =
                dialog.data['widgets']['requirements_item']['ui_tooltip'].replace('%ITEM', ui_ingr);
            var has_it = player.inventory_item_quantity(ingr['spec']) - (by_specname[ingr['spec']] || 0) >= ingr_stack;
            by_specname[ingr['spec']] = (by_specname[ingr['spec']]||0) + ingr_stack;
            dialog.widgets['requirements_item'+i.toString()].widgets['frame'].state = (has_it ? 'normal_nohighlight' : 'disabled');
            dialog.widgets['requirements_item_status'+i.toString()].show = true;
            dialog.widgets['requirements_item_status'+i.toString()].color = SPUI.make_colorv(dialog.data['widgets']['requirements_item_status'][(has_it ? 'color_present' : 'color_missing')]);
        } else {
            dialog.widgets['requirements_item_status'+i.toString()].show = false;
        }
    }
}

function update_crafting_dialog(dialog) {
    var flash_scroll = false;
    if(!dialog.user_data['scrolled'] &&
       ((client_time - dialog.user_data['open_time']) < gamedata['store']['store_scroll_flash_time'])) {
        if(dialog.widgets['scroll_right'].state != 'disabled') {
            flash_scroll = (((client_time/gamedata['store']['store_scroll_flash_period']) % 1) >= 0.5);
        }
    }

    var page = dialog.user_data['page'], chapter_pages = dialog.user_data['chapter_pages'];
    var chapter_recipes = (dialog.user_data['recipes'] ? dialog.user_data['recipes'].length : 0);
    var recipes_per_page = dialog.user_data['recipe_columns']*dialog.data['widgets']['recipe_icon']['array'][1];
    var grid = [0,0];

    if(chapter_pages > 0) {
        dialog.user_data['recipes_by_widget'] = {};
        var first_recipe_on_page = page * recipes_per_page;
        var last_recipe_on_page = Math.max(0, Math.min((page+1)*recipes_per_page-1, chapter_recipes-1));
        for(var i = first_recipe_on_page; i <= last_recipe_on_page; i++) {
            var name = dialog.user_data['recipes'][i];
            var spec = gamedata['crafting']['recipes'][name];
            var wname = grid[0].toString() +',' + grid[1].toString();
            dialog.user_data['recipes_by_widget'][wname] = name;
            var tooltip_text = [], tooltip_text_color = SPUI.default_text_color;
            dialog.widgets['recipe_slot'+wname].show =
                dialog.widgets['recipe_icon'+wname].show =
                dialog.widgets['recipe_frame'+wname].show = true;
            var can_craft = true;

            tooltip_text.push(get_crafting_recipe_ui_name(spec));
            dialog.widgets['recipe_icon'+wname].asset = get_crafting_recipe_icon(spec);

            // get list of any unsatisfied requirements
            var pred = null, req = null;
            if(('requires' in spec) && !player.is_cheater) {
                pred = read_predicate(spec['requires']);
                req = pred.ui_describe(player);
                if(req) {
                    tooltip_text.push('');
                    tooltip_text.push(dialog.data['widgets']['recipe_frame']['ui_tooltip_requires'].replace('%s', req));
                    can_craft = false;
                }
            }

            dialog.widgets['recipe_frame'+wname].onclick = (function (_name) { return function(w) {
                if(w.parent.user_data['selected_recipe'] == _name) {
                    if(w.parent.user_data['on_use_recipe']) {
                        // note: assumes on_use_recipe has been set up by an ondraw update
                        w.parent.user_data['on_use_recipe'](w.parent);
                    }
                } else {
                    crafting_dialog_select_recipe(w.parent.widgets['recipe'], _name);
                }
            }; })(name);

            dialog.widgets['recipe_gray_outer'+wname].show = !can_craft;
            dialog.widgets['recipe_frame'+wname].state = (name == dialog.user_data['selected_recipe'] ? 'highlight' : 'normal');

            if(can_craft) {
            } else {
                if(pred) {
                    // still allow selecting the recipe so that players can see what its benefits and requirements are
                    tooltip_text_color = SPUI.error_text_color;
                } else {
                    dialog.widgets['recipe_frame'+wname].state = 'disabled';
                }
            }

            if(tooltip_text.length > 0) {
                dialog.widgets['recipe_frame'+wname].tooltip.str = tooltip_text.join('\n');
                dialog.widgets['recipe_frame'+wname].tooltip.text_color = tooltip_text_color;
            } else {
                dialog.widgets['recipe_frame'+wname].tooltip.str = null;
            }
            grid[0] += 1;
            if(grid[0] >= dialog.user_data['recipe_columns']) {
                // clear out unused columns to the right-hand side
                while(grid[0] < dialog.data['widgets']['recipe_icon']['array'][0]) {
                    var widget_name = grid[0].toString() + ',' + grid[1].toString();
                    dialog.widgets['recipe_slot'+widget_name].show =
                        dialog.widgets['recipe_icon'+widget_name].show =
                        dialog.widgets['recipe_gray_outer'+widget_name].show =
                        dialog.widgets['recipe_frame'+widget_name].show = false;
                    grid[0] += 1;
                }

                grid[0] = 0; grid[1] += 1;
            }
        }

        dialog.widgets['scroll_text'].show = true;
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_recipe_on_page+1).toString()).replace('%d2',(last_recipe_on_page+1).toString()).replace('%d3',chapter_recipes.toString());
    } else {
        dialog.widgets['scroll_text'].show = false;
    }

    // clear out empty widgets
    while(grid[1] < dialog.data['widgets']['recipe_icon']['array'][1]) {
        while(grid[0] < dialog.data['widgets']['recipe_icon']['array'][0]) {
            var widget_name = grid[0].toString() + ',' + grid[1].toString();
            dialog.widgets['recipe_slot'+widget_name].show =
                dialog.widgets['recipe_icon'+widget_name].show =
                dialog.widgets['recipe_gray_outer'+widget_name].show =
                dialog.widgets['recipe_frame'+widget_name].show = false;
            grid[0] += 1;
        }
        grid[0] = 0; grid[1] += 1;
    }

    dialog.widgets['scroll_left'].widgets['scroll_left'].state = (page != 0 ? 'normal' : 'disabled');
    dialog.widgets['scroll_left'].widgets['scroll_left_bg'].alpha = (page != 0 ? 0.86 : 0.25);
    dialog.widgets['scroll_left'].widgets['scroll_left_bg'].fade_unless_hover = (page != 0 ? 0.5 : 1);
    dialog.widgets['scroll_right'].widgets['scroll_right'].state = ((page < chapter_pages-1) ? 'normal' : 'disabled');
    dialog.widgets['scroll_right'].widgets['scroll_right_bg'].alpha = ((page < chapter_pages-1) ? (flash_scroll ? 1 : 0.86) : 0.25);
    dialog.widgets['scroll_right'].widgets['scroll_right_bg'].fade_unless_hover = ((page < chapter_pages-1) ? (flash_scroll ? 1 : 0.5) : 1);

    if(dialog.user_data['category'] == 'mines') {
        update_crafting_dialog_status_mines_and_missiles(dialog.widgets['status']);
    } else if(dialog.user_data['category'] == 'missiles') {
        update_crafting_dialog_status_mines_and_missiles(dialog.widgets['status']);
    } else if(dialog.user_data['category'] == 'leaders') {
        update_crafting_dialog_status_leaders(dialog.widgets['status']);
    } else {
        throw Error('unhandled category '+dialog.user_data['category']);
    }

    if(dialog.user_data['selected_recipe']) {
        if(dialog.user_data['category'] == 'mines') {
            update_crafting_dialog_recipe_mines(dialog.widgets['recipe']);
        } else if(dialog.user_data['category'] == 'missiles') {
            update_crafting_dialog_recipe_missiles(dialog.widgets['recipe']);
        } else if(dialog.user_data['category'] == 'leaders') {
            update_crafting_dialog_recipe_leaders(dialog.widgets['recipe']);
        }
    }

    // fill in price display and "finish" button callback
    var builder = dialog.user_data['builder'];
    var craft_queue = (builder ? builder.get_crafting_queue() : []);
    var closure;
    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].state = Store.get_user_currency();
    dialog.widgets['price_display'].tooltip.str = '';
    dialog.widgets['price_spinner'].show = (builder && !builder.is_in_sync());

    if(builder && builder.is_damaged()) {
        dialog.widgets['crafting_progress'].show =
            dialog.widgets['crafting_progress_text'].show = true;
        dialog.widgets['crafting_progress'].progress = (builder.is_crafting() ? builder.crafting_progress_one() : 0);
        dialog.widgets['crafting_progress_text'].str = dialog.data['widgets']['crafting_progress_text']['ui_name_damaged'];
        dialog.widgets['crafting_progress_text'].text_color = SPUI.error_text_color;
    } else if(builder && builder.is_crafting()) {
        dialog.widgets['crafting_progress'].show =
            dialog.widgets['crafting_progress_text'].show = true;
        dialog.widgets['crafting_progress'].progress = builder.crafting_progress_one();
        var ui_cat = 'unknown';
        for(var i = 0; i < craft_queue.length; i++) {
            var rspec = gamedata['crafting']['recipes'][craft_queue[i]['craft']['recipe']];
            if(rspec['crafting_category']) {
                ui_cat = gamedata['crafting']['categories'][rspec['crafting_category']]['ui_name_singular']; break;
            }
        }
        dialog.widgets['crafting_progress_text'].str = dialog.data['widgets']['crafting_progress_text']['ui_name_crafting'].replace('%togo',
                                                                                                                                    pretty_print_time(builder.crafting_time_left_all())).replace('%qty', craft_queue.length.toString()).replace('%cat',ui_cat);
        dialog.widgets['crafting_progress_text'].text_color = SPUI.make_colorv(dialog.data['widgets']['crafting_progress_text']['text_color']);
    } else {
        dialog.widgets['crafting_progress'].show = false;
        dialog.widgets['crafting_progress_text'].show = true;
        dialog.widgets['crafting_progress_text'].str = dialog.data['widgets']['crafting_progress_text']['ui_name_idle'];
        dialog.widgets['crafting_progress_text'].text_color = SPUI.make_colorv(dialog.data['widgets']['crafting_progress_text']['text_color']);
    }

    var can_speedup = player.crafting_speedups_enabled();
    if(can_speedup) {
        for(var i = 0; i < craft_queue.length; i++) {
            var rspec = gamedata['crafting']['recipes'][craft_queue[i]['craft']['recipe']];
            if(rspec['crafting_category']) {
                var cat = gamedata['crafting']['categories'][rspec['crafting_category']];
                if(('speedupable' in cat) && !cat['speedupable']) {
                    can_speedup = false;
                }
            }
        }
    }

    if(!can_speedup) {
        dialog.widgets['price_display'].show = dialog.widgets['finish_button'].show = false;
    } else {
        dialog.widgets['price_display'].show = dialog.widgets['finish_button'].show = true;

    // ! this block is left one indent to minimize diff
    if(builder && !builder.is_in_sync()) {
        dialog.widgets['price_display'].str = '';
        closure = null;
        dialog.widgets['price_display'].onclick = null;
        dialog.widgets['finish_button'].state = 'disabled';
        dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name_pending'];
        dialog.widgets['price_display'].tooltip.str = dialog.widgets['finish_button'].tooltip.str = '';
    } else if(!builder || craft_queue.length < 1) {
        dialog.widgets['price_display'].str = '';
        closure = null;
        dialog.widgets['price_display'].onclick = null;
        dialog.widgets['finish_button'].state = 'disabled';
        dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'];
        dialog.widgets['price_display'].tooltip.str = dialog.widgets['finish_button'].tooltip.str = '';
    } else {
        // note: SPEEDUP_FOR_MONEY will repair the factory rather than speed up production if factory is damaged
        dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'+(builder.is_damaged() ? '_repair' : '')];
        dialog.widgets['finish_button'].state = 'normal';

        var price = Store.get_user_currency_price(builder.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null);
        dialog.widgets['price_display'].str = Store.display_user_currency_price(price); // PRICE
        dialog.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(price);

        if(price == 0) {
            closure = (function(_builder) { return function(w) {
                var dialog = w.parent;
                if(dialog.widgets['coverup_all'].show) { return; }
                send_to_server.func(["CAST_SPELL", _builder.id, "SPEEDUP_FOR_FREE"]);
                invoke_ui_locker(_builder.request_sync(), function() { change_selection(null); });
            }; })(builder);
        } else if(price > 0) {
            closure = (function(_builder) { return function(w) {
                var dialog = w.parent;
                if(dialog.widgets['coverup_all'].show) { return; }

                var cleanup_cb = (function (_dialog) { return function() {
//                  change_selection(null);
                }; })(dialog);

                if(Store.place_user_currency_order(_builder.id, "SPEEDUP_FOR_MONEY", null, cleanup_cb)) {
                    invoke_ui_locker(_builder.request_sync(), function() {
                        //change_selection(null);
                    });
                }
            };})(builder);
        } else {
            // invalid order?
            if(builder.is_damaged() && !builder.is_repairing()) {
                closure = (function (obj) { return function() {
                    change_selection(obj); invoke_repair_dialog();
                }; })(builder);
            } else {
                closure = null;
                dialog.widgets['finish_button'].state = 'disabled';
            }
        }
    }

    dialog.widgets['price_display'].onclick =
        dialog.widgets['finish_button'].onclick = closure;
    } // END crafting speedups are available

}

function make_unique_id() { return server_time.toFixed(0)+'-'+(10000*Math.random()).toFixed(0); }

function start_crafting(_builder, _build_recipe_spec, extra_params) {
    // come up with a unique tag for this bus
    var ui_tag = make_unique_id();

    var params = {'recipe':_build_recipe_spec['name'], 'ui_tag': ui_tag};
    if(extra_params) {
        goog.array.forEach(['delivery','ui_index'], function(n) {
            if(n in extra_params) { params[n] = extra_params[n]; }
        });
    }

    send_to_server.func(["CAST_SPELL", _builder.id, "CRAFT_FOR_FREE", params]);
    var _craft_queue = _builder.start_client_prediction('crafting.queue', _builder.crafting ? _builder.crafting['queue'] : []);

    // client-side predict what will happen
    var cost_time = Math.max(1, Math.floor(_build_recipe_spec['craft_time'] / _builder.get_stat('crafting_speed', _builder.get_leveled_quantity(_builder.spec['crafting_speed'] || 1.0))));

    var delay = 0;
    for(var i = 0; i < _craft_queue.length; i++) {
        var entry = _craft_queue[i];
        var d = entry['total_time'] - entry['done_time'];
        if(entry['start_time'] > 0) {
            d -= Math.min(Math.max(server_time - entry['start_time'],0), entry['total_time']);
        }
        delay += d;
    }
    var start_time = server_time + Math.max(0, delay);
    _craft_queue.push({'craft':{'recipe':_build_recipe_spec['name'], 'ui_tag': ui_tag, 'cost': goog.object.clone(_build_recipe_spec['cost'])},
                       'start_time': start_time, 'done_time': 0, 'total_time': cost_time});
    goog.object.forEach(gamedata['resources'], function(res, resname) {
        var cost = _build_recipe_spec['cost'][resname] || 0;
        player.resource_state[resname][1] -= cost;
    });

    if('start_effect' in _build_recipe_spec) {
        SPFX.add_visual_effect(_builder.interpolate_pos(), 0, [0,1,0], client_time, _build_recipe_spec['start_effect'], true);
    }
    return ui_tag;
}

// cancel crafting job "p_bus"
// note that p_bus may not be the exact same object that's in the queue (due to client-side prediction) - match by ui_tag / attempt_id if possible
function do_cancel_crafting(builder, p_bus) {
    var craft_queue = builder.get_crafting_queue();
    var index;
    var bus = null;
    var match_kind = null, match_val = null;
    for(index = 0; index < craft_queue.length; index++) {
        var b = craft_queue[index];
        if('ui_tag' in p_bus['craft']) {
            if(b['craft']['ui_tag'] == p_bus['craft']['ui_tag']) {
                match_kind = 'ui_tag';
                match_val = p_bus['craft']['ui_tag'];
                bus = b;
                break;
            }
        } else if('attempt_id' in p_bus['craft']) {
            if(b['craft']['attempt_id'] == p_bus['craft']['attempt_id']) {
                match_kind = 'attempt_id';
                match_val = p_bus['craft']['attempt_id'];
                bus = b;
                break;
            }
        } else {
            if(b['craft']['recipe'] == p_bus['craft']['recipe']) {
                match_kind = 'index';
                match_val = index;
                bus = b;
                break;
            }
        }
    }
    if(!bus) { // no match
        console.log('do_cancel_crafting(): cannot find '+JSON.stringify(p_bus));
        return;
    }

    var spellarg = {'recipe':bus['craft']['recipe']};
    spellarg[match_kind] = match_val;
    send_to_server.func(["CAST_SPELL", builder.id, "CANCEL_CRAFT", spellarg]);

    // client-side predict what will happen
    craft_queue = builder.start_client_prediction('crafting.queue', builder.crafting ? builder.crafting['queue'] : []);
    craft_queue.splice(index,1);
    if(builder.repair_finish_time < 0 && !builder.is_damaged()) {
        _update_crafting(craft_queue, -1);
    }
    goog.object.forEach(gamedata['resources'], function(res, resname) {
        var cost = Math.floor(gamedata['manufacture_cancel_refund']*(bus['craft']['cost'][resname]||0));
        player.resource_state[resname][1] += cost;
    });
}

function cancel_unfinished_crafting(builder) {
    while(builder.is_crafting()) {
        var queue = builder.get_crafting_queue();
        var did_cancel = false;
        for(var i = 0; i < queue.length; i++) {
            var bus = queue[i];
            var prog = (bus['done_time'] + (bus['start_time'] > 0 ? (server_time - bus['start_time']) : 0))/bus['total_time'];
            if(prog >= 1) { continue; } // skip finished jobs
            did_cancel = true;
            do_cancel_crafting(builder, bus);
            break;
        }
        if(!did_cancel) { // we're done
            break;
        }
    }
}

function update_crafting_dialog_status_mines_and_missiles(dialog) {
    var dims = dialog.data['widgets']['mine_slot']['array'];
    var builder = dialog.parent.user_data['builder'];
    var category = dialog.parent.user_data['category'];
    var catspec = gamedata['crafting']['categories'][category];
    var selected_recipe = dialog.parent.user_data['selected_recipe'];
    var selected_recipe_spec = (selected_recipe ? gamedata['crafting']['recipes'][selected_recipe] : null);
    var selected_mine = (selected_recipe_spec ? ItemDisplay.get_crafting_recipe_product_spec(selected_recipe_spec)['name'] : null);
    var selected_mine_spec = (selected_mine ? ItemDisplay.get_inventory_item_spec(selected_mine) : null);

    var craft_queue = (builder ? builder.get_crafting_queue() : []);
    var num_slots = 0; // number of slots we currently have
    var max_slots = 0; // max number of slots we could have if FULLY upgraded
    var num_ready = 0; // number of slots that have an item completed and equipped

    dialog.parent.user_data['on_use_recipe'] = null; // default action when clicking the recipe on the left

    for(var y = 0; y < dims[1]; y++) {
        for(var x = 0; x < dims[0]; x++) {
            var wname = x.toString()+','+y.toString();
            var obj = null; // object for this delivery slot
            var delivery_slot_type = catspec['delivery_slot_type'];
            var delivery_slot_index;
            var multiple_delivery_slots;
            var pending = false;
            var cur_mine = null;
            var cur_config = null;

            if(builder) {
                if(category == 'mines') {
                    multiple_delivery_slots = false;
                    max_slots = get_max_minefields();
                    delivery_slot_index = 0;
                    var tag = dialog.user_data['wname_to_tag'][wname];
                    if((tag in session.minefield_tags_by_tag) && (session.cur_objects.has_object(session.minefield_tags_by_tag[tag]))) {
                        // minefield exists
                        obj = session.cur_objects.get_object(session.minefield_tags_by_tag[tag]);
                        cur_mine = (obj.equipment && (delivery_slot_type in obj.equipment) && obj.equipment[delivery_slot_type].length > 0 ? obj.equipment[delivery_slot_type][0] : null);
                        cur_config = (obj.config && (delivery_slot_type in obj.config) && (obj.config[delivery_slot_type] in gamedata['items']) ? obj.config[delivery_slot_type] : null);
                    }
                } else if(category == 'missiles') {
                    obj = find_object_by_type(catspec['delivery_building_for_ui']);
                    multiple_delivery_slots = true;
                    delivery_slot_index = y*dims[0] + x; // XXX assumes you only have one delivery building
                    var delivery_building_spec = gamedata['buildings'][catspec['delivery_building_for_ui']];
                    max_slots = get_leveled_quantity(delivery_building_spec['equip_slots'][delivery_slot_type], get_max_level(delivery_building_spec));
                    if(obj) {
                        cur_mine = (obj.equipment && (delivery_slot_type in obj.equipment) && obj.equipment[delivery_slot_type].length > delivery_slot_index ? obj.equipment[delivery_slot_type][delivery_slot_index] : null);
                        cur_config = (obj.config && (delivery_slot_type in obj.config) && obj.config[delivery_slot_type].length > delivery_slot_index && (obj.config[delivery_slot_type][delivery_slot_index] in gamedata['items']) ? obj.config[delivery_slot_type][delivery_slot_index] : null);
                    }
                } else {
                    throw Error('unhandled category '+category);
                }
            }
            if(obj && (!multiple_delivery_slots || (delivery_slot_index <= max_slots-1))) {
                // slot exists (now, or if fully upgraded)
                num_slots += 1;

                pending = !obj.is_in_sync(); // || !builder.is_in_sync();
                dialog.widgets['mine_slot'+wname].state = 'normal';

                var in_progress_recipe = null, in_progress_bus = null, in_progress_togo = -1;
                for(var i = 0; i < craft_queue.length; i++) {
                    var entry = craft_queue[i];
                    if(entry['craft']['delivery'] && entry['craft']['delivery']['obj_id'] == obj.id &&
                       (!('slot_type' in entry['craft']['delivery']) || entry['craft']['delivery']['slot_type'] == delivery_slot_type) &&
                       ((entry['craft']['delivery']['slot_index']||0) == delivery_slot_index)) {
                        in_progress_recipe = entry['craft']['recipe'];
                        in_progress_bus = entry;
                        in_progress_togo = entry['total_time'] - entry['done_time'];
                        if(entry['start_time'] > 0) {
                            in_progress_togo -= Math.max(0, server_time - entry['start_time']);
                        }
                        break;
                    }
                }

                dialog.widgets['mine_icon'+wname].show =
                    dialog.widgets['mine_frame'+wname].show =
                    dialog.widgets['mine_cancel'+wname].show = true;
                dialog.widgets['mine_icon'+wname].state = 'normal';
                dialog.widgets['mine_skull'+wname].show =
                    dialog.widgets['mine_timer'+wname].show = false;

                var build_mine = cur_config || selected_mine || null;
                var build_recipe = null;
                if(build_mine) {
                    if(build_mine == selected_mine) {
                        build_recipe = selected_recipe;
                    } else {
                        // look up the recipe for a DIFFERENT mine
                        for(var n in gamedata['crafting']['recipes']) {
                            var rec = gamedata['crafting']['recipes'][n];
                            if(rec['crafting_category'] == category && ItemDisplay.get_crafting_recipe_product_spec(rec)['name'] == build_mine) {
                                build_recipe = n; break;
                            }
                        }
                    }
                }
                var build_recipe_spec = (build_recipe ? gamedata['crafting']['recipes'][build_recipe] : null);

                var build_cb = null;
                var build_error_ui_text = null;

                if(build_recipe_spec) {
                    var can_cast = can_cast_spell_detailed(builder.id, 'CRAFT_FOR_FREE', [{'recipe': build_recipe_spec['name'],
                                                                                           'delivery': {'obj_id':obj.id, 'slot_type':delivery_slot_type, 'slot_index': delivery_slot_index}}]);
                    if(can_cast[0]) {
                        // the real build function
                        build_cb = (function (_builder, _build_recipe_spec, _obj, _delivery_slot_index) { return function() {
                            start_crafting(_builder, _build_recipe_spec, {'delivery': {'obj_id':_obj.id, 'slot_type':delivery_slot_type, 'slot_index': _delivery_slot_index}});
                            // play sound effect
                            if(1) {
                                var state = GameArt.assets['action_button_134px'].states['normal'];
                                if(state.audio) { state.audio.play(client_time); }
                            }
                            return true;
                        }; })(builder, build_recipe_spec, obj, delivery_slot_index);
                    } else {
                        build_error_ui_text = can_cast[1];
                        // get helper function
                        if(can_cast[2]) {
                            var helper = get_requirements_help(can_cast[2][0], can_cast[2][1], can_cast[2][2]);
                            build_cb = (helper ? (function (_helper) { return function() { _helper(); return false; }; })(helper) : null);
                        }
                    }
                }

                var unconfig_cb = (function (_obj, _delivery_slot_type, _delivery_slot_index, _multiple) { return function(w) {
                    var new_config = (_obj.config ? goog.object.clone(_obj.config) : {});
                    if(_multiple) {
                        if(!new_config[_delivery_slot_type]) {
                            new_config[_delivery_slot_type] = [];
                        }
                        while(new_config[_delivery_slot_type].length < _delivery_slot_index) {
                            new_config[_delivery_slot_type].push(null);
                        }
                        new_config[_delivery_slot_type][_delivery_slot_index] = null;
                    } else {
                        if(_delivery_slot_type in new_config) { delete new_config[_delivery_slot_type]; }
                        if(goog.object.getCount(new_config) <= 0) { new_config = null; }
                    }
                    send_to_server.func(["CAST_SPELL", _obj.id, "CONFIG_SET", new_config]);
                    // client-side predict
                    _obj.config = new_config;
                    _obj.request_sync();
                }; })(obj, delivery_slot_type, delivery_slot_index, multiple_delivery_slots);

                if(cur_mine) {
                    var cur_mine_spec = ItemDisplay.get_inventory_item_spec(cur_mine);
                    num_ready += 1;
                    dialog.widgets['mine_icon'+wname].alpha = 1;
                    dialog.widgets['mine_icon'+wname].asset = gamedata['items'][cur_mine]['icon'];
                    dialog.widgets['mine_frame'+wname].onclick = null;
                    dialog.widgets['mine_frame'+wname].tooltip.str = dialog.data['widgets']['mine_frame']['ui_tooltip_armed'].replace('%s', gamedata['items'][cur_mine]['ui_name']);
                    dialog.widgets['mine_cancel'+wname].show = !(('can_unequip' in cur_mine_spec) && !cur_mine_spec['can_unequip']);
                    dialog.widgets['mine_cancel'+wname].tooltip.str = dialog.data['widgets']['mine_cancel']['ui_tooltip_discard'].replace('%s', gamedata['items'][cur_mine]['ui_name']);
                    dialog.widgets['mine_cancel'+wname].onclick = (function (_obj, _cur_mine, _delivery_slot_type, _delivery_slot_index, _unconfig_cb) { return function(w) {
                        send_to_server.func(["EQUIP_BUILDING", _obj.id, [_delivery_slot_type,_delivery_slot_index], -1, null, _cur_mine, -1]);
                        // maybe put a confirmation dialog here?
                        invoke_ui_locker();
                        _unconfig_cb();
                    }; })(obj, cur_mine, delivery_slot_type, delivery_slot_index, unconfig_cb);
                } else if(in_progress_recipe) {
                    dialog.widgets['mine_icon'+wname].asset = get_crafting_recipe_icon(gamedata['crafting']['recipes'][in_progress_recipe]);
                    dialog.widgets['mine_icon'+wname].alpha = 1;
                    dialog.widgets['mine_frame'+wname].onclick = null;
                    dialog.widgets['mine_frame'+wname].tooltip.str = dialog.data['widgets']['mine_frame']['ui_tooltip_inprogress'].replace('%s', ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_crafting_recipe_product_spec(gamedata['crafting']['recipes'][in_progress_recipe])));
                    dialog.widgets['mine_cancel'+wname].tooltip.str = dialog.data['widgets']['mine_cancel']['ui_tooltip_cancel'];
                    dialog.widgets['mine_cancel'+wname].onclick = (function (_builder, _in_progress_bus, _unconfig_cb) { return function(w) {
                        do_cancel_crafting(_builder, _in_progress_bus);
                        _unconfig_cb();
                    }; })(builder, in_progress_bus, unconfig_cb);
                    dialog.widgets['mine_timer'+wname].show = true;
                    dialog.widgets['mine_timer'+wname].str = pretty_print_time_brief(in_progress_togo);
                } else if(cur_config) {
                    var cur_config_spec = gamedata['items'][cur_config];
                    dialog.widgets['mine_icon'+wname].asset = cur_config_spec['icon'];
                    dialog.widgets['mine_icon'+wname].state = 'icon_disabled';
                    dialog.widgets['mine_icon'+wname].alpha = 0.33;
                    dialog.widgets['mine_skull'+wname].show = true;
                    dialog.widgets['mine_frame'+wname].onclick = build_cb;
                    dialog.widgets['mine_frame'+wname].tooltip.str = dialog.data['widgets']['mine_frame']['ui_tooltip_produce'].replace('%s', cur_config_spec['ui_name']);
                    dialog.widgets['mine_cancel'+wname].onclick = unconfig_cb;

                    if(!dialog.parent.user_data['on_use_recipe'] && selected_mine_spec == cur_config_spec) {
                        dialog.parent.user_data['on_use_recipe'] = build_cb;
                    }

                } else if(selected_mine_spec) {
                    dialog.widgets['mine_icon'+wname].alpha = 0.33;
                    dialog.widgets['mine_icon'+wname].asset = selected_mine_spec['icon'];
                    dialog.widgets['mine_icon'+wname].show = (dialog.widgets['mine_frame'+wname].mouse_enter_time > 0) && (dialog.widgets['mine_cancel'+wname].mouse_enter_time < 0);
                    dialog.widgets['mine_frame'+wname].tooltip.str = dialog.data['widgets']['mine_frame']['ui_tooltip_produce'].replace('%s', selected_mine_spec['ui_name']);
                    var build_and_config_cb;
                    if(('persist_config' in catspec) && !catspec['persist_config']) {
                        build_and_config_cb = build_cb; // no persistence
                    } else {
                        build_and_config_cb = (function (_obj, _selected_mine_spec, _delivery_slot_type, _delivery_slot_index, _multiple, _build_cb) { return function(w) {
                        if(_build_cb && _build_cb()) {
                            var new_config = _obj.config || {};
                            if(_multiple) {
                                if(!new_config[_delivery_slot_type]) { new_config[_delivery_slot_type] = []; }
                                while(new_config[_delivery_slot_type].length < _delivery_slot_index) {
                                    new_config[_delivery_slot_type].push(null);
                                }
                                new_config[_delivery_slot_type][_delivery_slot_index] = _selected_mine_spec['name'];
                            } else {
                                new_config[_delivery_slot_type] = _selected_mine_spec['name'];
                            }
                            send_to_server.func(["CAST_SPELL", _obj.id, "CONFIG_SET", new_config]);
                            // client-side predict config
                            _obj.config = new_config;
                            _obj.request_sync();
                        }
                        }; })(obj, selected_mine_spec, delivery_slot_type, delivery_slot_index, multiple_delivery_slots, build_cb);
                    }
                    dialog.widgets['mine_frame'+wname].onclick = build_and_config_cb;
                    dialog.widgets['mine_cancel'+wname].show = false;

                    if(!dialog.parent.user_data['on_use_recipe']) {
                        dialog.parent.user_data['on_use_recipe'] = build_and_config_cb;
                    }
                } else {
                    dialog.widgets['mine_icon'+wname].show =
                        dialog.widgets['mine_frame'+wname].show =
                        dialog.widgets['mine_cancel'+wname].show = false;
                }

                dialog.widgets['mine_pending'+wname].show = pending;
                if(pending) {
                    dialog.widgets['mine_frame'+wname].onclick = null;
                }
            } else if(delivery_slot_index < max_slots) {
                // minefield does not exist
                dialog.widgets['mine_icon'+wname].show =
                    dialog.widgets['mine_skull'+wname].show =
                    dialog.widgets['mine_timer'+wname].show =
                    dialog.widgets['mine_frame'+wname].show =
                    dialog.widgets['mine_cancel'+wname].show =
                    dialog.widgets['mine_pending'+wname].show = false;
                dialog.widgets['mine_slot'+wname].state = 'locked';

                // Valentina help to do what you need to do to unlock another slot
                // XXXXXX port this to a get_requirements_help('equip_slot', delivery_slot_type) call?
                var help_pred = null;
                var slot_building = gamedata['crafting']['categories'][category]['delivery_building_for_ui'];
                var slot_building_spec = gamedata['buildings'][slot_building];
                if('limit_requires' in slot_building_spec) {
                    // minefield-style buildings where you build more to open slots
                    help_pred = {'predicate':'BUILDING_QUANTITY', 'building_type':slot_building, 'trigger_qty': count_objects_by_type(slot_building)+1};
                    dialog.widgets['mine_slot'+wname].tooltip.str = dialog.data['widgets']['mine_slot']['ui_tooltip_build_more'].replace('%s', slot_building_spec['ui_name']);
                } else {
                    // missile-style buildings where you upgrade a building to open slots
                    var b = find_object_by_type(slot_building);
                    if(!b) { throw Error('not slot_building '+slot_building); }
                    help_pred = {'predicate':'BUILDING_LEVEL', 'building_type':slot_building, 'trigger_level': b.level + 1};
                    dialog.widgets['mine_slot'+wname].tooltip.str = dialog.data['widgets']['mine_slot']['ui_tooltip_upgrade'].replace('%s', slot_building_spec['ui_name']);
                }

                var helper = null;
                if(help_pred && dialog.widgets['mine_slot'+wname].show) {
                    helper = function (use_short_circuit) { return function() {
                        var h = get_requirements_help(read_predicate(help_pred), null, {short_circuit:use_short_circuit});
                        if(h) { h(); }
                    }; };
                }
                dialog.widgets['mine_slot'+wname].onclick = (helper ? helper(true) : null);
                if(!dialog.parent.user_data['on_use_recipe']) {
                    dialog.parent.user_data['on_use_recipe'] = (helper ? helper(false) : null);
                }
            } else {
                // cannot ever exist
                dialog.widgets['mine_icon'+wname].show =
                    dialog.widgets['mine_skull'+wname].show =
                    dialog.widgets['mine_timer'+wname].show =
                    dialog.widgets['mine_frame'+wname].show =
                    dialog.widgets['mine_cancel'+wname].show =
                    dialog.widgets['mine_slot'+wname].show =
                    dialog.widgets['mine_pending'+wname].show = false;
            }
        }
    }

    // hide arrows below the final visible slot row
    if('arrow0' in dialog.widgets) {
        for(var i = 0; i < dialog.data['widgets']['arrow']['array'][1]; i++) {
            var wname = 'arrow'+i.toString();
            dialog.widgets[wname].show = (max_slots >= i*dialog.data['widgets']['mine_slot']['array'][0] + 1);
        }
    }

    if('num_ready' in dialog.widgets) {
        dialog.widgets['num_ready'].show = !!builder;
        dialog.widgets['num_ready'].str = dialog.data['widgets']['num_ready']['ui_name'].replace('%max', num_slots.toString()).replace('%cur', num_ready.toString()).replace('%s', catspec['ui_name']);
    }
}

function update_crafting_dialog_status_leaders(dialog) {
    var builder = dialog.parent.user_data['builder'];
    var selected_recipe = dialog.parent.user_data['selected_recipe'];
    var selected_recipe_spec = (selected_recipe ? gamedata['crafting']['recipes'][selected_recipe] : null);
    var selected_leader = (selected_recipe_spec ? ItemDisplay.get_crafting_recipe_product_spec(selected_recipe_spec)['name'] : null);
    var selected_leader_spec = (selected_leader ? ItemDisplay.get_inventory_item_spec(selected_leader) : null);

    var craft_queue = (builder ? builder.get_crafting_queue() : []);

    dialog.parent.user_data['on_use_recipe'] = null; // default action when clicking the recipe on the left
    var pending = (builder && !builder.is_in_sync());
    var in_progress_recipe = null, in_progress_bus = null, in_progress_togo = -1;
    goog.array.forEach(craft_queue, function(entry) {
        if(gamedata['crafting']['recipes'][entry['craft']['recipe']]['crafting_category'] == 'leaders') {
            // since there is no queueing, there should only be one of these
            in_progress_recipe = entry['craft']['recipe'];
            in_progress_bus = entry;
            in_progress_togo = entry['total_time'] - entry['done_time'];
            if(entry['start_time'] > 0) {
                in_progress_togo -= Math.max(0, server_time - entry['start_time']);
            }
        }
    });

    dialog.widgets['leader_icon'].show =
        dialog.widgets['leader_frame'].show =
        dialog.widgets['leader_cancel'].show = true;
    dialog.widgets['leader_icon'].state = 'normal';
    dialog.widgets['leader_timer'].show = false;
    var build_cb = null;
    var build_error_ui_text = null;

    if(builder) {
        var can_cast = can_cast_spell_detailed(builder.id, 'CRAFT_FOR_FREE', [{'recipe': selected_recipe}]);
        if(can_cast[0]) {
            // the real build function
            build_cb = (function (_builder, _selected_recipe_spec) { return function() {
                start_crafting(_builder, _selected_recipe_spec, {});
                // play sound effect
                if(1) {
                    var state = GameArt.assets['action_button_134px'].states['normal'];
                    if(state.audio) { state.audio.play(client_time); }
                }
                return true;
            }; })(builder, selected_recipe_spec);
        } else {
            build_error_ui_text = can_cast[1];
            // get helper function
            if(can_cast[2]) {
                var helper = get_requirements_help(can_cast[2][0], can_cast[2][1], can_cast[2][2]);
                build_cb = (helper ? (function (_helper) { return function() { _helper(); return false; }; })(helper) : null);
            }
        }
    }

    if(in_progress_recipe) {
        dialog.widgets['leader_icon'].asset = get_crafting_recipe_icon(gamedata['crafting']['recipes'][in_progress_recipe]);
        dialog.widgets['leader_icon'].alpha = 1;
        dialog.widgets['leader_frame'].onclick = null;
        dialog.widgets['leader_frame'].tooltip.str = dialog.data['widgets']['leader_frame']['ui_tooltip_inprogress'].replace('%s', ItemDisplay.get_inventory_item_ui_name_long(ItemDisplay.get_crafting_recipe_product_spec(gamedata['crafting']['recipes'][in_progress_recipe])));
        dialog.widgets['leader_frame'].tooltip.text_color = SPUI.default_text_color;
        dialog.widgets['leader_cancel'].tooltip.str = dialog.data['widgets']['leader_cancel']['ui_tooltip_cancel'];
        dialog.widgets['leader_cancel'].onclick = (function (_builder, _in_progress_bus) { return function(w) {
            do_cancel_crafting(_builder, _in_progress_bus);
        }; })(builder, in_progress_bus);
        dialog.widgets['leader_timer'].show = true;
        dialog.widgets['leader_timer'].str = pretty_print_time_brief(in_progress_togo);
    } else if(selected_leader_spec) {
        dialog.widgets['leader_icon'].alpha = 0.33;
        dialog.widgets['leader_icon'].asset = selected_leader_spec['icon'];
        dialog.widgets['leader_icon'].show = (dialog.widgets['leader_icon'].mouse_enter_time > 0) && (dialog.widgets['leader_cancel'].mouse_enter_time < 0);
        dialog.widgets['leader_frame'].tooltip.str = build_error_ui_text || dialog.data['widgets']['leader_frame']['ui_tooltip_produce'].replace('%s', ItemDisplay.get_inventory_item_ui_name_long(selected_leader_spec));
        dialog.widgets['leader_frame'].tooltip.text_color = (build_error_ui_text ? SPUI.error_text_color : SPUI.default_text_color);
        dialog.widgets['leader_frame'].onclick = build_cb;
        dialog.widgets['leader_cancel'].show = false;
        if(!dialog.parent.user_data['on_use_recipe']) {
            dialog.parent.user_data['on_use_recipe'] = build_cb;
        }
    } else {
        dialog.widgets['leader_icon'].show =
            dialog.widgets['leader_frame'].show =
            dialog.widgets['leader_cancel'].show = false;
    }

    // if out of sync, show spinner and disable clicks
    dialog.widgets['leader_pending'].show = pending;
    if(pending) {
        dialog.widgets['leader_frame'].onclick = dialog.widgets['leader_cancel'].onclick = null;
    }
}

function invoke_fishing_dialog() {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['fishing_dialog']);
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.user_data['dialog'] = 'fishing_dialog';
    dialog.user_data['builder'] = find_object_by_type(get_workshop_for('fishing'));
    dialog.user_data['open_metric_sent'] = false;

    // standard scrollable dialog stuff
    dialog.user_data['rowfunc'] = update_fishing_dialog_row;
    dialog.user_data['rows_per_page'] = dialog.data['widgets']['row']['array'][1];
    dialog.user_data['page'] = -1;

    // format of rowdata and collections:
    // {recipe: (pointer to recipe data), bus: (crafting queue entry, may be null),
    //  ui_priority: (display order), time: (collections only - time collected), state: (complete/inprogress/idle)}
    dialog.user_data['rowdata'] = [];

    dialog.user_data['collections'] = []; // list of jobs that were just collected and are displaying animation (see CRAFT_COMPLETE handler)
    dialog.user_data['ui_priority_overrides'] = {}; // mapping of bus['craft']['ui_tag'] -> ui_priority to keep rows in place across state transitions

    dialog.user_data['ui_priority_base_counter'] = 0;
    dialog.user_data['ui_priority_bases'] = {}; // mapping of recipe name to base value of ui_priority - used because sometimes these are randomized per player

    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name'].replace('%BUILDING', gamedata['buildings'][get_workshop_for('fishing')]['ui_name']);
    dialog.widgets['help_button'].onclick = function(w) {
        invoke_child_message_dialog(w.data['ui_tooltip'], w.data['ui_message'], {'dialog':'message_dialog_big'});
    };
    dialog.widgets['notify_choice'].show = (spin_frame_platform == 'fb');

    dialog.ondraw = update_fishing_dialog;
    update_fishing_dialog(dialog);
    scrollable_dialog_change_page(dialog, 0);
}

function fishing_dialog_get_ui_priority(dialog, recipe) {
    var bases = dialog.user_data['ui_priority_bases'];
    if(!(recipe['name'] in bases)) {
        var p = eval_cond_or_literal(recipe['ui_priority'], player, null);
        if(p < 0) { // randomize, but do it stably (because the recipe order is shuffled stably in update_fishing_dialog)
            p = dialog.user_data['ui_priority_base_counter'];
            dialog.user_data['ui_priority_base_counter'] += 1;
        }
        bases[recipe['name']] = p;
    }
    return bases[recipe['name']];
}

function update_fishing_dialog(dialog) {
    dialog.widgets['notify_choice'].state = (get_preference_setting(player.preferences, 'enable_fishing_notifications') ? 'active' : 'normal');
    dialog.widgets['notify_choice'].onclick = function(w) {
        player.preferences['enable_fishing_notifications'] = (w.state == 'active' ? 0 : 1);
        send_to_server.func(["UPDATE_PREFERENCES", player.preferences]);
        invoke_ui_locker();
    };

    var builder = dialog.user_data['builder'];
    dialog.user_data['rowdata'] = [];

    if(!player.cooldown_active('fish_slate_assigned')) {
        if(!player.cooldown_active('fish_slate_assign_pending')) {
            send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "FISH_SLATE_ASSIGN"]);
            player.cooldown_client_trigger('fish_slate_assign_pending', 999);
        }
        dialog.widgets['topbar_text'].str = dialog.data['widgets']['topbar_text']['ui_name_pending'];
        dialog.widgets['loading_rect'].show = dialog.widgets['loading_text'].show = dialog.widgets['loading_spinner'].show = true;
        dialog.widgets['no_recipes'].show = false;
    } else {
        if(!dialog.user_data['open_metric_sent'] && gamedata['crafting']['categories']['fishing']['log_ui_events']) {
            dialog.user_data['open_metric_sent'] = true;
            var time_left = (builder.is_crafting() ? Math.floor(builder.crafting_time_left_one()) : 0);
            var slate_id = player.cooldowns['fish_slate_assigned']['data']['slate'];
            metric_event('5154_fish_open_dialog', {'sum': player.get_denormalized_summary_props('brief'), 'slate_id':slate_id, 'time_left': time_left});
        }

        var assign_time_togo = player.cooldown_togo('fish_slate_assigned');
        dialog.widgets['topbar_text'].str = dialog.data['widgets']['topbar_text']['ui_name'].replace('%REFRESH', pretty_print_time_brief(assign_time_togo));
        dialog.widgets['loading_rect'].show = dialog.widgets['loading_text'].show = dialog.widgets['loading_spinner'].show = false;

        // find current in-progress recipe and completed recipes
        if(builder.is_crafting()) {
            var craft_queue = builder.get_crafting_queue();
            for(var i = 0; i < craft_queue.length; i++) {
                var bus = craft_queue[i];
                var rec = gamedata['crafting']['recipes'][bus['craft']['recipe']];
                var cat = gamedata['crafting']['categories'][rec['crafting_category']];
                var prog = bus['done_time'] + (bus['start_time'] > 0 && bus['start_time'] < server_time ? (server_time - bus['start_time']) : 0);
                var state;
                if(('auto_collect' in cat) && !cat['auto_collect'] && prog >= bus['total_time']) {
                    state = 'complete';
                } else {
                    state = 'inprogress';
                }

                var ui_priority;

                if(/* state == 'inprogress' && */ bus['craft']['ui_tag'] in dialog.user_data['ui_priority_overrides']) {
                    // keep recipes in place after state transitions while dialog was open
                    ui_priority = dialog.user_data['ui_priority_overrides'][bus['craft']['ui_tag']];
                } else {
                    // list completed/queued recipes at end, in reverse queue order
                    ui_priority = 1000 - i;
                }
                dialog.user_data['rowdata'].push({'recipe':rec, 'bus':bus, 'ui_priority': ui_priority, 'state': state})
            }
        }

        var all_recipes = goog.object.getValues(gamedata['crafting']['recipes']);
        goog.array.shuffle(all_recipes); // permute order so that fishing_dialog_get_ui_priority assigns randomized priorities (stably per dialog open)
        goog.array.forEach(all_recipes, function(recipe) {
            if(recipe['crafting_category'] == 'fishing') {
                if(read_predicate(recipe['show_if']).is_satisfied(player, null)) {
                    dialog.user_data['rowdata'].push({'recipe':recipe, 'bus': null, 'ui_priority': fishing_dialog_get_ui_priority(dialog, recipe), 'state': 'idle'});
                }
            }
        });

        // add collected recipes
        var to_remove = [];
        goog.array.forEach(dialog.user_data['collections'], function(data) {
            if(client_time - data['time'] >= dialog.data['collection_time']) { to_remove.push(data); return; }
            dialog.user_data['rowdata'].push({'recipe': data['recipe'], 'bus': data['bus'], 'loot':data['loot'], 'ui_priority':data['ui_priority'], 'state':'collecting'});
        });
        goog.array.forEach(to_remove, function(x) { goog.array.remove(dialog.user_data['collections'], x); });

        // sort by ui_priority
        dialog.user_data['rowdata'].sort(function(x,y) {
            var px = x['ui_priority'];
            var py = y['ui_priority'];
            if(px < py) {
                return -1;
            } else if(px > py) {
                return 1;
            }
            return 0;
        });

        dialog.widgets['no_recipes'].show = (dialog.user_data['rowdata'].length == 0);
        if(dialog.widgets['no_recipes'].show) {
            dialog.widgets['no_recipes'].str = dialog.data['widgets']['no_recipes']['ui_name'].replace('%REFRESH', pretty_print_time_brief(assign_time_togo));
        }
    }

    scrollable_dialog_change_page(dialog, dialog.user_data['page']);
}

function update_fishing_dialog_row(parent_dialog, row, rowdata) {
    var dialog = parent_dialog.widgets['row'+row.toString()];
    dialog.show = (rowdata !== null);
    if(!rowdata) { return; }

    var builder = dialog.parent.user_data['builder'];
    var recipe = rowdata['recipe'];
    var cat = gamedata['crafting']['categories'][recipe['crafting_category']];
    var bus = rowdata['bus'] || null;

    var state = rowdata['state'];
    var helper = null;
    var help_tip = null;

    var can_speedup = player.crafting_speedups_enabled();
    if(can_speedup) {
        if(('speedupable' in cat) && !cat['speedupable']) {
            can_speedup = false;
        }
    }

    // special-case idle recipes
    if(state == 'idle') {
        if(builder.is_crafting() && builder.crafting_time_left_one() >= 0) {
            // another operation is already in progress
            state = 'disabled';
            help_tip = 'inprogress';
            if(can_speedup) {
                helper = function() { invoke_child_speedup_dialog('crafting'); };
            }
        } else if(builder.is_crafting() && builder.get_crafting_queue().length >= builder.get_leveled_quantity(builder.spec['crafting_queue_space'])) {
            // no operation in progress, but there is no queue space
            state = 'disabled';
            help_tip = 'must_collect';
            helper = function() { invoke_child_message_dialog(dialog.data['widgets']['start_button']['ui_tooltip_must_collect'],
                                                              dialog.data['widgets']['start_button']['ui_must_collect_descr'].replace('%d', builder.get_leveled_quantity(builder.spec['crafting_queue_space']).toString()), {'dialog': 'message_dialog_big'});
                                };

        } else {
            state = 'idle';
        }
    }

    dialog.widgets['bg'].color = SPUI.make_colorv(dialog.data['widgets']['bg'][('color_'+state in dialog.data['widgets']['bg'] ? 'color_'+state : 'color')]);
    dialog.widgets['bg'].outline_color = SPUI.make_colorv(dialog.data['widgets']['bg'][('outline_color_'+state in dialog.data['widgets']['bg'] ? 'outline_color_'+state : 'outline_color')]);
    dialog.widgets['name'].str = dialog.data['widgets']['name']['ui_name_'+state].replace('%RECIPE', recipe['ui_name']);

    // parse recipe products. If awaiting collection and item is melting, display "decayed" duration
    var products = goog.array.map(recipe['product'], function(item) {
        var ret = {'spec': item['spec']};
        if('stack' in item) { ret['stack'] = item['stack']; }
        if('item_duration' in item) {
            var dur = item['item_duration'];
            if(bus && ('creation_time' in bus) && (state == 'complete' || state == 'collecting')) {
                // XXX this doesn't account for stoppage due to building damage - see note in server.py: do_collect_craft_one()
                var end_time = bus['creation_time'] + bus['total_time'];
                dur = dur - (server_time - end_time);
            }
            ret['item_duration'] = dur;
        }
        return ret;
    });

    // display reward names
    var reward_str = goog.array.map(products, function(item) {
        var stack = ('stack' in item ? item['stack'] : 1);
        var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
        var ret;
        // special case: use full-precision stack count for fungible items instead of stack_prefix
        if(spec['fungible'] && stack != 1) {
            ret = pretty_print_number(stack)+' '+ItemDisplay.get_inventory_item_ui_name(spec);
        } else {
            ret = ItemDisplay.get_inventory_item_stack_prefix(spec, stack) + ItemDisplay.get_inventory_item_ui_name(spec);
        }
        if('item_duration' in item) {
            if(item['item_duration'] >= 0) {
                ret += ' '+dialog.data['widgets']['descr']['ui_name_expires'].replace('%s', pretty_print_time(item['item_duration']));
            } else {
                ret += ' '+dialog.data['widgets']['descr']['ui_name_expired'];
            }
        }
        return ret;
    }).join(' + ');
    dialog.widgets['descr'].str = reward_str;

    goog.array.forEach(['name','descr','reward_label'], function(n) {
        var key = 'text_color_'+state;
        dialog.widgets[n].text_color = SPUI.make_colorv(dialog.data['widgets'][n][(key in dialog.data['widgets'][n] ? key : 'text_color')]);
    });

    for(var i = 0; i < dialog.data['widgets']['reward_item']['array'][0]; i++) { dialog.widgets['reward_item'+i.toString()].widgets['frame'].onclick = null; }
    // display reward items
    ItemDisplay.display_item_array(dialog, 'reward_item', products, {context_parent: dialog.parent});
    for(var i = 0; i < dialog.data['widgets']['reward_item']['array'][0]; i++) {
        dialog.widgets['reward_expires'+i.toString()].show = (i < products.length && ('item_duration' in products[i]));
        if(dialog.widgets['reward_item'+i.toString()].show) {
            dialog.widgets['reward_item'+i.toString()].widgets['frame'].state = (state == 'collecting' ? 'disabled' : 'normal_nohighlight');
        }
        dialog.widgets['reward_spinner'+i.toString()].show = (dialog.widgets['reward_item'+i.toString()].show && state == 'collecting');
    }

    dialog.widgets['timer'].show = (state == 'inprogress');
    if(dialog.widgets['timer'].show) {
        dialog.widgets['timer'].str = pretty_print_time(builder.crafting_time_left_one());
    }
    dialog.widgets['progress_bar'].show = (state == 'inprogress' || state == 'complete' || state == 'collecting');
    if(dialog.widgets['progress_bar'].show) {
        var prog = ((state == 'complete' || state == 'collecting') ? 1 : 1 - builder.crafting_time_left_one()/recipe['craft_time']);
        dialog.widgets['progress_bar'].progress = 0.2 + 0.8 * prog; // artificially boost by 20% at start
    }

    dialog.widgets['reward_label'].show = !dialog.widgets['timer'].show;

    dialog.widgets['expire_timer'].show = false; // (state == 'idle' || state == 'disabled');
    if(dialog.widgets['expire_timer'].show) {
        dialog.widgets['expire_timer'].str = dialog.data['widgets']['expire_timer']['ui_name'].replace('%s', pretty_print_time(player.cooldown_togo('fish_slate_assigned')));
    }

    // buttons
    if(state == 'inprogress') {
        dialog.widgets['finish_button'].show = dialog.widgets['price_display'].show = true;
        dialog.widgets['start_button'].show = dialog.widgets['collect_button'].show = false;

        if(!can_speedup) {
            dialog.widgets['price_display'].show = dialog.widgets['finish_button'].show = false;
            if(!(('cancelable' in cat) && !cat['cancelable'])) {
                dialog.widgets['cancel_button'].show = true;
                dialog.widgets['cancel_button'].onclick = (function (_builder, _cat, _bus) { return function (w) {
                    invoke_confirm_cancel_message(_cat['confirm_cancel_kind'] || 'crafting', (function (__builder, __bus) {
                        return function() {
                            do_cancel_crafting(__builder, __bus);
                        }; })(_builder, _bus));
                }; })(builder, cat, bus);
            } else {
                dialog.widgets['cancel_button'].show = false;
            }
        } else {
            dialog.widgets['price_display'].show = dialog.widgets['finish_button'].show = true;
            dialog.widgets['cancel_button'].show = false;

            var closure;

            if(builder && !builder.is_in_sync()) {
                closure = null;
                dialog.widgets['finish_button'].state = 'disabled';
                dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name_pending'];
                dialog.widgets['finish_button'].text_offset = dialog.data['widgets']['finish_button']['text_offset_pending'];
                dialog.widgets['finish_button'].tooltip.str = '';
                dialog.widgets['price_display'].str = '';
            } else {
                // note: SPEEDUP_FOR_MONEY will repair the factory rather than speed up production if factory is damaged
                dialog.widgets['finish_button'].state = 'normal';
                dialog.widgets['finish_button'].str = dialog.data['widgets']['finish_button']['ui_name'+(builder.is_damaged() ? '_repair' : '')];
                dialog.widgets['finish_button'].text_offset = dialog.data['widgets']['finish_button']['text_offset'];

                var price = Store.get_user_currency_price(builder.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null);
                dialog.widgets['price_display'].str = Store.display_user_currency_price(price) + ' ' + Store.gamebucks_ui_name(); // PRICE
                dialog.widgets['finish_button'].tooltip.str = Store.display_user_currency_price_tooltip(price);

                if(price == 0) {
                    closure = (function(_builder) { return function(w) {
                        var dialog = w.parent;
                        send_to_server.func(["CAST_SPELL", _builder.id, "SPEEDUP_FOR_FREE"]);
                        invoke_ui_locker(_builder.request_sync(), function() { /* change_selection(null); */ });
                    }; })(builder);
                } else if(price > 0) {
                    closure = (function(_builder) { return function(w) {
                        var dialog = w.parent;
                        var cleanup_cb = (function (_dialog) { return function() {
                            // change_selection(null);
                        }; })(dialog);

                        if(Store.place_user_currency_order(_builder.id, "SPEEDUP_FOR_MONEY", null, cleanup_cb)) {
                            invoke_ui_locker(_builder.request_sync(), function() {
                                //change_selection(null);
                            });
                        }
                    };})(builder)
                } else {
                    // invalid order?
                    if(builder.is_damaged() && !builder.is_repairing()) {
                        closure = (function (obj) { return function() {
                            change_selection(obj); invoke_repair_dialog();
                        }; })(builder);
                    } else {
                        closure = null;
                        dialog.widgets['finish_button'].state = 'disabled';
                    }
                }
            }
            dialog.widgets['price_display'].onclick =
                dialog.widgets['finish_button'].onclick = closure;
        }
    } else if(state == 'complete') {
        dialog.widgets['finish_button'].show = dialog.widgets['price_display'].show = dialog.widgets['start_button'].show = dialog.widgets['cancel_button'].show = false;
        dialog.widgets['collect_button'].show = true;

        // check storage space limit
        var res = null, excess = null;
        goog.array.forEach(recipe['product'], function(item) {
            if('spec' in item) {
                var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
                if(spec['fungible'] && spec['resource'] in gamedata['resources']) {
                    var stack = ('stack' in item ? item['stack'] : 1);
                    if(player.resource_state[spec['resource']][1] + stack > player.resource_state[spec['resource']][0]) {
                        res = spec['resource'];
                        excess = player.resource_state[res][1] + stack - player.resource_state[res][0];
                    }
                }
            }
        });

        if(excess) {
            dialog.widgets['collect_button'].state = 'green_disabled';
            dialog.widgets['collect_button'].str = dialog.data['widgets']['collect_button']['ui_name'];
            dialog.widgets['collect_button'].tooltip.str = gamedata['errors']['STORAGE_LIMIT']['ui_name']; // dialog.data['widgets']['collect_button']['ui_tooltip_storage_limit'];
            dialog.widgets['collect_button'].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['collect_button'].onclick = (function (_res, _excess) { return function(w) {
                var helper = get_requirements_help('need_more_storage', _res);
                if(helper) { helper(); }
            }; })(res, excess);
        } else {
            dialog.widgets['collect_button'].state = 'green';
            dialog.widgets['collect_button'].str = dialog.data['widgets']['collect_button']['ui_name'];
            dialog.widgets['collect_button'].tooltip.str = null;
            dialog.widgets['collect_button'].onclick = (function (_builder, _bus, _rowdata) { return function(w) {
                var dialog = w.parent;
                GameArt.assets['xp_gain_sound'].states['normal'].audio.play(client_time);

                send_to_server.func(["CAST_SPELL", _builder.id, "COLLECT_CRAFT", [_bus['craft']['attempt_id']]]);
                var queue = _builder.start_client_prediction('crafting.queue', _builder.crafting ? _builder.crafting['queue'] : []);
                // client-side predict what will happen
                for(var i = 0; i < queue.length; i++) {
                    var b = queue[i];
                    if(b['craft']['attempt_id'] == _bus['craft']['attempt_id']) {
                        // simulate loot based on predictable items
                        var recipe = gamedata['crafting']['recipes'][b['craft']['recipe']];
                        var loot = goog.array.filter(recipe['product'], function(entry) { return 'spec' in entry; } );
                        var data = {'time': client_time, 'recipe': gamedata['crafting']['recipes'][b['craft']['recipe']], 'bus': b, 'ui_priority': _rowdata['ui_priority'], 'loot':loot};
                        dialog.parent.user_data['collections'].push(data);
                        queue.splice(i,1);
                        break;
                    }
                }
                //invoke_ui_locker(_builder.request_sync()); // not necessary with client-side prediction
            }; })(builder, bus, rowdata);
        }
    } else if(state == 'collecting') {
        dialog.widgets['finish_button'].show = dialog.widgets['price_display'].show = dialog.widgets['start_button'].show = dialog.widgets['cancel_button'].show = false;
        dialog.widgets['collect_button'].show = true;
        dialog.widgets['collect_button'].state = 'green_disabled';
        dialog.widgets['collect_button'].str = dialog.data['widgets']['collect_button']['ui_name_collecting'];
        dialog.widgets['collect_button'].onclick = null;
        if(!dialog.user_data['collect_text']) {
            dialog.user_data['collect_text'] = true;
            var is_fungible = false;
            goog.array.forEach(rowdata['loot'], function(item) {
                var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
                if(spec['fungible']) {
                    is_fungible = true;
                }
            });
            if(is_fungible) {
                var str = gamedata['strings']['combat_messages']['adding_to_storage'];
                ItemDisplay.add_inventory_item_effect(dialog.widgets['reward_item0'].widgets['frame'], str, [1,1,1,1]);
            }
        }
    } else {
        dialog.widgets['finish_button'].show = dialog.widgets['price_display'].show = dialog.widgets['collect_button'].show = dialog.widgets['cancel_button'].show = false;
        dialog.widgets['start_button'].show = true;
        if(help_tip) {
            dialog.widgets['start_button'].tooltip.str = dialog.data['widgets']['start_button']['ui_tooltip_'+help_tip];
            dialog.widgets['start_button'].tooltip.text_color = SPUI.error_text_color;
        } else {
            dialog.widgets['start_button'].tooltip.str = null;
        }
        dialog.widgets['start_button'].str = dialog.data['widgets']['start_button']['ui_name'].replace('%TIME', pretty_print_time_brief(recipe['craft_time']));
        if(state == 'idle') {
            dialog.widgets['start_button'].state = 'normal';
            dialog.widgets['start_button'].onclick = (function (_builder, _recipe) { return function(w) {
                var dialog = w.parent;
                var ui_priority = fishing_dialog_get_ui_priority(dialog.parent, _recipe); // go back to the original recipe here (for metrics)
                var ui_tag = start_crafting(_builder, _recipe, {'ui_index': ui_priority});
                // client-side prediction for the per-SKU cooldown
                if('on_start' in recipe && recipe['on_start']['consequent'] == 'COOLDOWN_TRIGGER' && recipe['on_start']['duration_from_cooldown']) {
                    player.cooldown_client_trigger(recipe['on_start']['name'], player.cooldown_togo(recipe['on_start']['duration_from_cooldown']));
                }
                dialog.parent.user_data['ui_priority_overrides'][ui_tag] = ui_priority;
                invoke_ui_locker(_builder.request_sync());
                GameArt.assets['action_button_134px'].states['normal'].audio.play(client_time);
            }; })(builder, recipe);
        } else {
            dialog.widgets['start_button'].state = (helper ? 'disabled_clickable' : 'disabled');
            dialog.widgets['start_button'].onclick = helper;
        }
    }

    dialog.widgets['collect_spinner'].show = (state == 'collecting');
}

var last_research_dialog_category = null;

/** @param {(string|null)=} parent_category
    @param {string=} newcategory
    @param {number=} newpage */
function invoke_research_dialog(parent_category, newcategory, newpage) {
    // note: assumes the research lab is already selected

    if(last_research_dialog_category === null) {
        last_research_dialog_category = gamedata['strings']['research_categories']['army'][0]['name'];
    }

    // if parent category is not provided, find it
    if(!parent_category) {
        if(!newcategory) { throw Error('neither parent_category or newcategory was provided'); }
        for(var p in gamedata['strings']['research_categories']) {
            var entry = goog.array.find(gamedata['strings']['research_categories'][p], function(entry) {
                return (entry['name'] == newcategory);
            });
            if(entry) {
                parent_category = p;
                break;
            }
        }
    }
    if(!newcategory) { // pick a reasonable default
        if(last_research_dialog_category && goog.array.find(gamedata['strings']['research_categories'][parent_category],
                                                            function(entry) { return entry['name'] == last_research_dialog_category; })) {
            newcategory = last_research_dialog_category;
        } else {
            newcategory = gamedata['strings']['research_categories'][parent_category][0]['name'];
        }
    }

    var dialog_data = gamedata['dialogs']['research_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'research_dialog';
    dialog.user_data['parent_category'] = parent_category;
    dialog.user_data['category'] = newcategory;
    dialog.widgets['close_button'].onclick = function() { change_selection(null); };

    dialog.widgets['dev_title'].show = player.is_cheater;

    if('ui_name_'+parent_category in dialog.data['widgets']['title']) {
        dialog.widgets['title'].str = dialog.data['widgets']['title']['ui_name_'+parent_category];
    } // otherwise, this is set in change_category

    dialog.widgets['army_dialog_buttons_army'].show = (parent_category == 'army');
    dialog.widgets['army_dialog_buttons_crafting'].show = (parent_category == 'crafting');
    dialog.widgets['army_dialog_buttons_leaders'].show = (parent_category == 'leaders');
    init_army_dialog_buttons(dialog.widgets['army_dialog_buttons_'+parent_category], parent_category, 'research_dialog');


    // set up category buttons
    var i = 0;
    var cat_list = goog.array.filter(gamedata['strings']['research_categories'][parent_category], function(entry) {
        if('show_if' in entry && !read_predicate(entry['show_if']).is_satisfied(player, null)) { return false; }
        return !!get_lab_for(entry['name']);
    });
    var used = cat_list.length;
    goog.array.forEach(cat_list, function(entry) {
        // manually compute X coordinate to center all the visible buttons
        var x = Math.floor(dialog.wh[0]/2 + (i - used/2) * dialog.data['widgets']['category_button']['array_offset'][0] + dialog.data['widgets']['category_button']['xy'][0]);
        dialog.widgets['category_button'+i.toString()].xy = [x, dialog.data['widgets']['category_button']['xy'][1]];

        dialog.widgets['category_button'+i.toString()].str = entry['ui_name'];
        dialog.widgets['category_button'+i.toString()].onclick = function(w) { research_dialog_change_category(w.parent, entry['name']); };
        i++;
        if(i >= dialog.data['widgets']['category_button']['array'][0]) { throw Error('not enough category_button array entries!'); }
    });
    while(i < dialog.data['widgets']['category_button']['array'][0]) {
        dialog.widgets['category_button'+i.toString()].show = false;
        i++;
    }
    dialog.user_data['category_list'] = cat_list;

    dialog.widgets['scroll_left'].onclick = function(w) { dialog.user_data['scrolled'] = true; research_dialog_scroll(w.parent, w.parent.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function(w) { dialog.user_data['scrolled'] = true; research_dialog_scroll(w.parent, w.parent.user_data['page']+1); };

    dialog.ondraw = update_research_dialog;
    research_dialog_change_category(dialog, newcategory, newpage || 0);
}

/** @param {SPUI.Dialog} dialog
    @param {string} category
    @param {number=} num page to scroll to */
function research_dialog_change_category(dialog, category, num)
{
    dialog.user_data['category'] = category;
    last_research_dialog_category = dialog.user_data['category'];

    var page_ui_name = null;
    goog.array.forEach(gamedata['strings']['research_categories'][dialog.user_data['parent_category']], function(entry) {
        if(entry['name'] == category) {
            page_ui_name = entry['ui_name'];
        }
    });

    dialog.user_data['techs'] = null;
    dialog.user_data['scrolled'] = false;
    dialog.user_data['open_time'] = client_time;

    goog.array.forEach(dialog.user_data['category_list'], function(entry, i) {
        var w = dialog.widgets['category_button'+i.toString()];
        w.text_color = (category === entry['name'] ? SPUI.default_text_color : SPUI.disabled_text_color);
        w.state = (category === entry['name'] ? 'active' : 'normal');
    });

    var builder_type = get_lab_for(category);

    if(!('ui_name_'+dialog.user_data['parent_category'] in dialog.data['widgets']['title'])) {
        dialog.widgets['title'].str = gamedata['buildings'][builder_type]['ui_name'];
    }

    // check for presence of research lab
    var builder = find_object_by_type(builder_type);
    dialog.user_data['builder'] = builder;

    dialog.widgets['coverup_all'].show =
        dialog.widgets['coverup_text'].show =
        dialog.widgets['coverup_icon'].show =
        dialog.widgets['coverup_button'].show = (!builder && !player.is_cheater);

    if(!builder && !player.is_cheater) {
        // research lab not present - show instructions for building research lab
        dialog.widgets['coverup_text'].str = dialog.data['widgets']['coverup_text']['ui_name'].replace('%verb', gamedata['spells']['RESEARCH_FOR_FREE']['ui_dialog_name']).replace('%s1', page_ui_name).replace('%s2', gamedata['buildings'][builder_type]['ui_name_indefinite']);
        dialog.widgets['coverup_icon'].asset = get_leveled_quantity(gamedata['buildings'][builder_type]['art_asset'], 1);
        // special-case because some buildings are really tall
        dialog.widgets['coverup_icon'].xy = vec_add(dialog.data['widgets']['coverup_icon']['xy'], (gamedata['buildings'][builder_type]['hero_icon_pos'] || [0,0]));
        var helper = get_requirements_help(read_predicate({'predicate':'BUILDING_QUANTITY', 'building_type':builder_type, 'trigger_qty':1}), null, {short_circuit:true});
        dialog.widgets['coverup_button'].onclick = (helper ? helper : function() { invoke_build_dialog('production'); });

    } else {
        // fill in grid of technologies
        dialog.user_data['techs'] = [];

        for(var name in gamedata['tech']) {
            var spec = gamedata['tech'][name];
            if(spec['research_category'] != category) {
                continue;
            }
            if(spec['developer_only'] && (spin_secure_mode || !player.is_developer())) { continue; }
            if('show_if' in spec && !read_predicate(spec['show_if']).is_satisfied(player, null)) { continue; }
            if('activation' in spec && !read_predicate(spec['activation']).is_satisfied(player, null)) { continue; }

            // only show techs associated with unit production when in army mode
            if(!('associated_unit' in spec) && dialog.user_data['parent_category'] == 'army') { continue; }

            dialog.user_data['techs'].push(name);
        }
    }

    if(player.upgrade_bar_enabled()) {
        UpgradeBar.invoke(dialog, 'building', (builder ? builder.spec['name'] : null), (builder ? builder.level+1 : -1), (builder ? builder.id : null));
    }

    research_dialog_scroll(dialog, num || 0);
}

function research_dialog_scroll(dialog, page) {
    var grid_x = 0, grid_y = 0;
    dialog.user_data['techs_by_widget'] = null;
    var builder = dialog.user_data['builder'];

    var chapter_techs = (dialog.user_data['techs'] ? dialog.user_data['techs'].length : 0);
    var techs_per_page = dialog.data['widgets']['grid']['array'][0]*dialog.data['widgets']['grid']['array'][1];
    var chapter_pages = Math.floor((chapter_techs+techs_per_page-1)/techs_per_page);
    dialog.user_data['page'] = page = (chapter_techs === 0 ? 0 : clamp(page, 0, chapter_pages-1));

    if(chapter_pages > 0) {
        dialog.user_data['techs_by_widget'] = {};
        var first_tech_on_page = page * techs_per_page;
        var last_tech_on_page = Math.max(0, Math.min((page+1)*techs_per_page-1, chapter_techs-1));
        for(var i = first_tech_on_page; i <= last_tech_on_page; i++) {
            var name = dialog.user_data['techs'][i];
            var spec = gamedata['tech'][name];
            //  current research level and limit
            var current = (name in player.tech ? player.tech[name] : 0);
            var limit = get_max_ui_level(spec);

            var widget_name = grid_x.toString() +',' + grid_y.toString();
            var widget = dialog.widgets['grid'+widget_name];
            dialog.user_data['techs_by_widget'][widget_name] = name;

            if(spec['associated_unit']) {
                var unit_spec = gamedata['units'][spec['associated_unit']];
                if('splash_image' in unit_spec) {
                    widget.bg_image = get_leveled_quantity(unit_spec['splash_image'], Math.min(current+1, limit));
                    widget.transform = dialog.data['widgets']['grid']['transform_splash_image'];
                } else {
                    widget.bg_image = get_leveled_quantity(unit_spec['art_asset'], Math.min(current+1, limit));
                    widget.transform = null;
                }
                widget.alpha = unit_spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1;
            } else if('icon' in spec) {
                widget.bg_image = get_leveled_quantity(spec['icon'], Math.min(current+1, limit));
                widget.transform = null;
            }

            widget.show = true;
            dialog.widgets['grid_glow'+widget_name].show = true;
            dialog.widgets['grid_label'+widget_name].str = spec['ui_name'];
            dialog.widgets['grid_label'+widget_name].show = true;
            dialog.widgets['grid_status'+widget_name].show = true;

            var tooltip_text = [];
            var able_to_research = true;
            var unlocked = true;



            // limit on tech level
            if(current >= limit) {
                able_to_research = false;
                tooltip_text.push(gamedata['errors']['MAX_LEVEL_REACHED']['ui_name']);
            } else if(builder && builder.is_damaged()) {
                able_to_research = false;
                tooltip_text.push(gamedata['errors']['LAB_DAMAGED']['ui_name']);
            } else {
                // research time
                var research_time = Math.floor(get_leveled_quantity(spec['research_time'], current+1) / (dialog.user_data['builder'] ? dialog.user_data['builder'].get_stat('research_speed',1) : 1));
                tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_unlocks_in'].replace('%s',pretty_print_time(research_time)));

                // minimum resoure amounts
                for(var res in gamedata['resources']) {
                    var resdata = gamedata['resources'][res];
                    var min_quant = get_leveled_quantity(spec['cost_'+res] || 0, current+1);
                    var player_quant = player.resource_state[res][1];
                    if(player_quant < min_quant) {
                        able_to_research = false;
                    }
                    tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_requires_res'].replace('%d',pretty_print_number(min_quant)).replace('%res',resdata['ui_name']));
                }

                // get list of any unsatisfied requirements
                var req = null;
                if(('requires' in spec) && !player.is_cheater) {
                    var pred = read_predicate(get_leveled_quantity(spec['requires'], current+1));
                    req = pred.ui_describe(player);
                }
                if(req) {
                    tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_requires'].replace('%s', req));
                    able_to_research = false;
                    if(current === 0) {
                        unlocked = false;
                    }
                }
            }

            // bring up the tech upgrade dialog
            widget.onclick = (function(bname) {
                return function(w) {
                    var dialog = w.parent;
                    // play sound effect
                    if(1) {
                        var state = GameArt.assets['action_button_134px'].states['normal'];
                        if(state.audio) { state.audio.play(client_time); }
                    }
                    invoke_upgrade_tech_dialog(bname, (function (_cat,_page) { return function() {
                        invoke_research_dialog(null,_cat,_page);
                    }; })(dialog.user_data['category'],dialog.user_data['page']));
                };
            })(name);

            if(able_to_research || 1) {
                widget.tooltip.str = '';
                widget.tooltip.text_color = SPUI.default_text_color;
            } else {
                widget.tooltip.str = tooltip_text.join('\n');
                widget.tooltip.text_color = SPUI.error_text_color;
            }
            grid_x += 1;
            if(grid_x >= dialog.data['widgets']['grid']['array'][0]) {
                grid_x = 0; grid_y += 1;
            }
        }
        dialog.widgets['scroll_text'].show = true;
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_tech_on_page+1).toString()).replace('%d2',(last_tech_on_page+1).toString()).replace('%d3',chapter_techs.toString());
    } else {
        dialog.widgets['scroll_text'].show = false;
    }

    // clear out empty widgets
    while(grid_y < dialog.data['widgets']['grid']['array'][1]) {
        while(grid_x < dialog.data['widgets']['grid']['array'][0]) {
            var widget_name = grid_x.toString() + ',' + grid_y.toString();
            dialog.widgets['grid_price'+widget_name].show = false;
            dialog.widgets['grid'+widget_name].bg_image = null;
            dialog.widgets['grid'+widget_name].show = false;
            dialog.widgets['grid_glow'+widget_name].show = false;
            dialog.widgets['grid_label'+widget_name].show = false;
            dialog.widgets['grid_status'+widget_name].show = false;
            grid_x += 1;
        }
        grid_x = 0;
        grid_y += 1;
    }

    dialog.widgets['scroll_left'].state = (page != 0 ? 'normal' : 'disabled');
    dialog.widgets['scroll_right'].state = ((page < chapter_pages-1) ? 'normal' : 'disabled');
    player.quest_tracked_dirty = true;
}

// responsible for updating "grid_status", "grid_price" "grid_finish_button" only
function update_research_dialog(dialog) {
    if(!dialog.user_data['techs_by_widget']) { return; }

    if(!dialog.user_data['scrolled'] &&
       ((client_time - dialog.user_data['open_time']) < gamedata['store']['store_scroll_flash_time']) &&
       player.get_any_abtest_value('enable_store_scroll_flash', gamedata['store']['enable_store_scroll_flash'])) {
        if(dialog.widgets['scroll_right'].state != 'disabled') {
            dialog.widgets['scroll_right'].state = ((((client_time/gamedata['store']['store_scroll_flash_period']) % 1) >= 0.5) ? 'highlight' : 'normal');
        }
    }

    // mapping of techs -> labs working on it
    var under_research = {};
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.is_building() && obj.is_researcher() && obj.team == 'player' && obj.is_researching()) {
            under_research[obj.research_item] = obj;
        }
    }

    var grid_x = 0, grid_y = 0;

    while(grid_y < dialog.data['widgets']['grid']['array'][1]) {
        while(grid_x < dialog.data['widgets']['grid']['array'][0]) {
            var widget_name = grid_x.toString() +',' + grid_y.toString();

            dialog.widgets['grid_price'+widget_name].bg_image = player.get_any_abtest_value('price_display_short_asset', gamedata['store']['price_display_short_asset']);
            dialog.widgets['grid_price'+widget_name].state = Store.get_user_currency();

            if(dialog.user_data['techs_by_widget'] && widget_name in dialog.user_data['techs_by_widget'] && dialog.user_data['techs_by_widget'][widget_name] in under_research) {
                // tech is currently under research
                var tech_name = dialog.user_data['techs_by_widget'][widget_name];
                var tech = gamedata['tech'][tech_name];
                var lab = under_research[tech_name];
                var current = player.tech[tech_name] || 0;

                dialog.widgets['grid'+widget_name].state = 'normal';
                dialog.widgets['grid'+widget_name].rotating = (!lab.is_damaged());
                var height = (tech['associated_unit'] && gamedata['units'][tech['associated_unit']]['flying'] ? -2*gamedata['units'][tech['associated_unit']]['altitude'] : 0);
                dialog.widgets['grid'+widget_name].bg_image_offset[1] = dialog.data['widgets']['grid']['bg_image_offset_'+(tech['associated_unit'] ? 'unit':'icon')][1] + height + dialog.data['widgets']['grid']['finish_shift'][1];

                dialog.widgets['grid_label'+widget_name].text_color = SPUI.default_text_color;

                dialog.widgets['grid_progress'+widget_name].show = false;
                dialog.widgets['grid_price'+widget_name].show =
                    dialog.widgets['grid_finish_button'+widget_name].show = true;

                dialog.widgets['grid_finish_button'+widget_name].str = dialog.data['widgets']['grid_finish_button']['ui_name'+(lab.is_damaged() ? '_repair' : '')];

                var cb, display_price, display_tooltip = '';
                if(lab.is_damaged()) {
                    dialog.widgets['grid_status'+widget_name].str = dialog.data['widgets']['grid_status']['ui_name_repair'];
                    display_price = dialog.data['widgets']['grid_price']['ui_name_start'];
                    cb = (function(_lab) { return function() {
                        change_selection_unit(_lab);
                        if(_lab.is_damaged() && !_lab.is_repairing()) {
                            invoke_repair_dialog();
                        } else {
                            invoke_child_speedup_dialog('research');
                        }
                    }; })(lab);
                } else {
                    dialog.widgets['grid_status'+widget_name].str = dialog.data['widgets']['grid_status']['ui_name_inprogress'].replace('%d',(current+1).toString()).replace('%s',pretty_print_time(lab.research_time_left()));
                    var price = Store.get_user_currency_price(lab.id, gamedata['spells']['SPEEDUP_FOR_MONEY'], null);
                    if(price == 0) {
                        cb = (function(_lab) { return function() {
                            change_selection_unit(_lab);
                            send_to_server.func(["CAST_SPELL", _lab.id, "SPEEDUP_FOR_FREE"]);
                            invoke_ui_locker(_lab.request_sync());
                        }; })(lab);
                    } else if(price > 0) {
                        cb = (function(_lab) { return function(widget) {
                            change_selection_unit(_lab);
                            if(Store.place_user_currency_order(_lab.id, "SPEEDUP_FOR_MONEY", null, function() { change_selection(null); })) {
                                widget.state = 'disabled';
                                var _dialog = widget.parent;
                                widget.str = _dialog.data['widgets']['grid_finish_button']['ui_name_pending'];
                                invoke_ui_locker(_lab.request_sync());
                            }
                        } })(lab);
                    } else {
                        cb = null;
                    }
                    display_price = Store.display_user_currency_price(price, 'compact'); // PRICE
                    display_tooltip = Store.display_user_currency_price_tooltip(price);
                }

                dialog.widgets['grid_price'+widget_name].str = display_price;
                dialog.widgets['grid_price'+widget_name].tooltip.str = display_tooltip;
                dialog.widgets['grid_price'+widget_name].onclick =
                    dialog.widgets['grid_finish_button'+widget_name].onclick = cb;

                dialog.widgets['grid_status'+widget_name].text_color = (lab.is_damaged() ? SPUI.error_text_color : SPUI.default_text_color);
            } else {
                var unlocked = true;
                if(dialog.user_data['techs_by_widget'] && widget_name in dialog.user_data['techs_by_widget']) {
                    // present but not under research
                    var tech_name = dialog.user_data['techs_by_widget'][widget_name];
                    var tech = gamedata['tech'][tech_name];
                    var current = player.tech[tech_name] || 0;
                    var limit = get_max_ui_level(tech);
                    var req = null;

                    if('requires' in tech && !read_predicate(get_leveled_quantity(tech['requires'], 1)).is_satisfied(player, null) && !player.is_cheater) {
                        unlocked = false; req = true;
                    } else if(current < limit) {
                        req = !read_predicate(get_leveled_quantity(tech['requires'], current+1)).is_satisfied(player, null);
                    } else {
                        req = true;
                    }

                    var height = (tech['associated_unit'] && gamedata['units'][tech['associated_unit']]['flying'] ? -2*gamedata['units'][tech['associated_unit']]['altitude'] : 0);
                    dialog.widgets['grid'+widget_name].bg_image_offset[1] = dialog.data['widgets']['grid']['bg_image_offset_'+(tech['associated_unit'] ? 'unit':'icon')][1] + height;

                    var tsize = dialog.widgets['grid_status'+widget_name].data['text_size'];
                    if(1 || unlocked) {
                        if(current == 0) {
                            dialog.widgets['grid_status'+widget_name].str = dialog.data['widgets']['grid_status']['ui_name_click_to_unlock'];
                            dialog.widgets['grid_status'+widget_name].font = SPUI.make_font(tsize, tsize+3, 'normal');
                        } else {
                            dialog.widgets['grid_status'+widget_name].str = dialog.data['widgets']['grid_status']['ui_name_level'].replace('%cur',current.toString()).replace('%max',limit.toString());
                            dialog.widgets['grid_status'+widget_name].font = SPUI.make_font(tsize, tsize+3, 'normal');
                        }
                    } else {
                        dialog.widgets['grid_status'+widget_name].str = dialog.data['widgets']['grid_status']['ui_name_locked'];
                        dialog.widgets['grid_status'+widget_name].font = SPUI.make_font(tsize, tsize+3, 'normal');
                    }

                    dialog.widgets['grid_status'+widget_name].text_color = (current >= limit) ? SPUI.disabled_text_color : (current==0 && req ? SPUI.disabled_text_color : (current ==0 && !req ? SPUI.make_colorv([1,1,0,1]) : SPUI.default_text_color));
                    dialog.widgets['grid_label'+widget_name].text_color = ((current >= limit) ? SPUI.disabled_text_color : SPUI.default_text_color);

                    dialog.widgets['grid_progress'+widget_name].show = (current > 0) && (current < limit);
                    if(dialog.widgets['grid_progress'+widget_name].show) {
                        dialog.widgets['grid_progress'+widget_name].progress = current/limit;
                        dialog.widgets['grid_progress'+widget_name].full_color = SPUI.make_colorv(dialog.data['widgets']['grid_progress']['full_color'+(current>=limit?'_done':'')]);
                    }
                } else {
                    // not present
                    dialog.widgets['grid_status'+widget_name].str = '';
                    dialog.widgets['grid_progress'+widget_name].show = false;
                }

                if(dialog.widgets['grid'+widget_name].bg_image) {
                    // check for support for the new normal_disabled sprite state
                    var asset = GameArt.assets[dialog.widgets['grid'+widget_name].bg_image];
                    var disabled_state = ('normal_disabled' in asset.states ? 'normal_disabled' : ('icon_disabled' in asset.states ? 'icon_disabled' : null));
                    dialog.widgets['grid'+widget_name].state = (!unlocked && disabled_state) ? disabled_state : 'normal';
                    dialog.widgets['grid'+widget_name].rotating = false;
                    dialog.widgets['grid'+widget_name].xy[1] = dialog.data['widgets']['grid']['xy'][1] + grid_y*dialog.data['widgets']['grid']['array_offset'][1];
                }

                dialog.widgets['grid_price'+widget_name].show = false;
                dialog.widgets['grid_finish_button'+widget_name].show = false;
            }
            grid_x += 1;
        }
        grid_x = 0;
        grid_y += 1;
    }
};

/** @param {boolean=} do_animation
    @param {Object=} preselect_quest */
function invoke_missions_dialog(do_animation, preselect_quest) {
    change_selection(null);

    player.update_quest_cache(true);

    var dialog_data = gamedata['dialogs']['missions_dialog'];

    // instantiate the dialog
    var dialog = new SPUI.Dialog(dialog_data);

    // make the dialog modal and add it to the "desktop"
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'missions_dialog';
    dialog.user_data['anim_start_time'] = (do_animation ? client_time : -1);
    dialog.user_data['quest_list'] = [];
    dialog.user_data['fb_likes_time'] = -1; // time the Facebook likes_cache was last invalidated
    dialog.user_data['selected_row'] = -1; // index of selected row in UI
    dialog.user_data['just_completed_row'] = -1; // index of row for previous completed quest in UI
    dialog.user_data['visible_rows'] = dialog.data['widgets']['row']['array'][1]; // # visible rows in UI
    dialog.user_data['first_row'] = 0; // index of top row that appears in UI
    dialog.user_data['context'] = null; // reward inventory item tooltip
    dialog.widgets['close_button'].onclick = function() { change_selection(null); player.invalidate_quest_cache(); };
    dialog.widgets['scroll_left'].onclick = function(w) { var dialog = w.parent; missions_dialog_scroll(dialog, dialog.user_data['first_row']-dialog.user_data['visible_rows']); };
    dialog.widgets['scroll_right'].onclick = function(w) { var dialog = w.parent; missions_dialog_scroll(dialog, dialog.user_data['first_row']+dialog.user_data['visible_rows']); };

    dialog.widgets['missions_button'].onclick = null;
    dialog.widgets['messages_button'].onclick = function() { invoke_mail_dialog(false); };
    dialog.widgets['missions_button'].show =
        dialog.widgets['messages_button'].show = player.get_any_abtest_value('enable_inventory', gamedata['enable_inventory']);

    // quest re-evaluation is not done on redraw to save CPU
    update_missions_dialog(dialog);

    // but animation is
    dialog.ondraw = animate_valentina_dialog;

    if(player.tutorial_state === 'open_missions_dialog') {
        advance_tutorial();
        // start arrow
        player.quest_tracked = gamedata['quests']['reclaim_base'];
        player.quest_tracked_dirty = true;
    }

    if(preselect_quest) {
        var idx = goog.array.indexOf(dialog.user_data['quest_list'], preselect_quest);
        if(idx >= 0) {
            missions_dialog_scroll(dialog, idx);
            missions_dialog_select_mission(dialog, idx);
        }
    }
    return dialog;
}

// animate Missions dialog zooming out of Valentina
function animate_valentina_dialog(dialog) {
    // handle invalidation of FB likes cache
    if(dialog.user_data['selected_row'] >= 0 && dialog.user_data['selected_row'] < dialog.user_data['quest_list'].length) {
        var quest = dialog.user_data['quest_list'][dialog.user_data['selected_row']];
        // if currently selected quest is incomplete, and calls for FB like refreshes
        if(('ui_refresh_likes' in quest) && !player.can_complete_quest(quest) && (client_time - dialog.user_data['fb_likes_time'] >= quest['ui_refresh_likes'])) {
            dialog.user_data['fb_likes_time'] = client_time;
            //console.log("REFRESH LIKES");
            if(spin_facebook_enabled) {
                SPFB.invalidate_likes_cache((function (_dialog, _row, _quest) { return function() {
                    // after the update comes back, force quest cache update, and attempt to update the Missions dialog state
                    player.update_quest_cache(true);
                    if(selection.ui === _dialog) {
                        if(_dialog.user_data['selected_row'] === _row) {
                            update_missions_dialog(_dialog);
                            for(var i = 0; i < dialog.user_data['quest_list'].length; i++) {
                                if(dialog.user_data['quest_list'][i] === _quest) {
                                    missions_dialog_select_mission(dialog, i);
                                    break;
                                }
                            }
                        }
                    }
                }; })(dialog, dialog.user_data['selected_row'], quest));
            }
            // trigger a re-evaluation of the predicate
            player.refresh_quest_cache_entry(quest);
        }
    }

    // handle flashing scroll buttons
    if(dialog.user_data['scroll_left_flash'] && dialog.widgets['scroll_left'].state === 'normal') {
        var flash = (client_time % 1.0) > 0.5;
        dialog.widgets['scroll_left'].text_color = SPUI.make_colorv(dialog.data['widgets']['scroll_left']['text_color_normal'+(flash?'_flash':'')]);
    }

    // zoom out of quest bar, or valentina
    if('quest_bar' in desktop_dialogs && dialog.user_data['selected_row'] >= 0 && dialog.user_data['selected_row'] < player.active_quests.length) {
        // note: coupled to ordering of QuestBar widgets matching player.active_quests
        var wname = SPUI.get_array_widget_name('icon', desktop_dialogs['quest_bar'].data['widgets']['icon']['array'], [0,dialog.user_data['selected_row']]);
        if(wname in desktop_dialogs['quest_bar'].widgets) {
            animate_dialog_zoom_effect(dialog, desktop_dialogs['quest_bar'].widgets[wname]);
            return;
        }
    }
    var bottom = desktop_dialogs['desktop_bottom'];
    var valentina = (bottom ? bottom.widgets['missions_button'] : null);
    animate_dialog_zoom_effect(dialog, valentina);
}

function animate_dialog_zoom_effect(dialog, src_widget) {
    if(SPFX.detail < 2) { return; } // do not do this in low-detail mode
    if(!src_widget) { dialog.transform = null; return; }

    var ANIM_TIME = player.get_any_abtest_value('valentina_dialog_anim_time', gamedata['client']['valentina_dialog_anim_time']);
    if(ANIM_TIME < 0 || !('anim_start_time' in dialog.user_data) || dialog.user_data['anim_start_time'] < 0) { return; }

    var progress = clamp((client_time - dialog.user_data['anim_start_time'])/ANIM_TIME, 0, 1);
    dialog.modal = progress;
    if(progress >= 1) {
        dialog.transform = null;
    } else {
        progress = Math.pow(progress,2.0);
        var scale = progress;
        // centerpoint of scale effect
        var pivot = vec_add(dialog.xy, vec_scale(0.5, dialog.wh));
        // where centerpoint is at start of animation
        var startpos = vec_add(src_widget.get_absolute_xy(), vec_scale(0.5, src_widget.wh));
        // where centerpoint is at end of animation
        var endpos = pivot;
        //startpos = [0,0]; endpos = [0,0];
        var origin = vec_add(startpos, vec_scale(progress, vec_sub(endpos, startpos)));

        dialog.transform = [scale, 0,
                            0, scale,
                            origin[0] + scale*(-origin[0]), origin[1] + scale*(-origin[1])];
    }
}

// refresh missions dialog with a new quest list
// completely resets selection and scrolling
function update_missions_dialog(dialog) {

    if(dialog.widgets['messages_button'].show) {
        dialog.widgets['pending_missions_icon'].show =
            dialog.widgets['pending_missions_icon_glow'].show = (player.claimable_quests > 0);
        dialog.widgets['pending_messages_icon'].show =
            dialog.widgets['pending_messages_icon_glow'].show = player.has_unread_mail();
    }

    // re-show close button (though it may get hidden again immediately from the player.quest_tracked click-here tips)
    dialog.widgets['close_button'].show = true;

    var skip_tutorial = 'skip_tutorial' in player.preferences && player.preferences['skip_tutorial'];

    if(read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null) && player.get_any_abtest_value('skip_tutorial_button', gamedata['client']['skip_tutorial_button'])) {
        dialog.widgets['popup_button'].show = true;
        if(skip_tutorial) {
            // currently skipping
            dialog.widgets['popup_button'].state = 'normal';
            dialog.widgets['popup_button'].onclick = function(w) {
                var dialog = w.parent;
                tutorial_opt_in(player.quest_tracked);
                update_missions_dialog(dialog);
            };
        } else {
            // currently NOT skipping
            dialog.widgets['popup_button'].state = 'active';
            dialog.widgets['popup_button'].onclick = function(w) {
                var dialog = w.parent;
                tutorial_opt_out();
                update_missions_dialog(dialog);
            };
        }
    } else {
        dialog.widgets['popup_button'].show = false;
    }

    var enable_messages = read_predicate({'predicate': 'LIBRARY', 'name': 'enable_messages'});
    if(enable_messages.is_satisfied(player, null) || skip_tutorial) {
        dialog.widgets['messages_button'].state = 'normal';
        dialog.widgets['messages_button'].tooltip.str = null;
    } else {
        dialog.widgets['messages_button'].state = 'disabled';
        dialog.widgets['messages_button'].tooltip.str = dialog.data['widgets']['messages_button']['ui_tooltip_requires'].replace('%s', enable_messages.ui_describe(player));
    }

    // fill in list of missions

    // store a reference to all listed Quests inside the dialog so that we can
    // trace mouse clicks to the corresponding quest
    var pre_select = -1;
    dialog.user_data['quest_list'] = [];
    for(var i = 0; i < player.active_quests.length; i++) {
        var quest = player.active_quests[i];
        dialog.user_data['quest_list'].push(quest);

        // select tracked mission
        if(pre_select === -1 &&
           (quest === player.quest_tracked ||
            i === dialog.user_data['just_completed_row'])) { // same row as previously-claimed quest
            pre_select = i;
        }
    }

    var first_row = 0;
    if(pre_select != -1) {
        // adjust scroll position up or down to make sure the pre-selected quest is visible
        if(pre_select < first_row) { first_row = pre_select; }
        else if(pre_select >= first_row + dialog.user_data['visible_rows']) { first_row = pre_select; }
    } else {
        // no pre-selection yet - just use row 0
        pre_select = first_row;
    }
    dialog.user_data['selected_row'] = pre_select;
    dialog.user_data['first_row'] = first_row;
    missions_dialog_scroll(dialog, dialog.user_data['first_row']);
};

// set scroll position, shifting selection to keep it visible
function missions_dialog_scroll(dialog, first_row) {
    // constrain first_row to valid range
    first_row = Math.max(Math.min(first_row, player.active_quests.length - 1), 0);
    // quantize first_row to pages
    first_row = Math.floor(first_row/dialog.user_data['visible_rows'])*dialog.user_data['visible_rows'];
    dialog.user_data['first_row'] = first_row;

    // fill in UI quest list at left-hand side of dialog
    var ui_row = 0;
    for(var i = first_row; i < player.active_quests.length; i++) {
        var quest = dialog.user_data['quest_list'][i];
        var rowname = 'row'+ui_row.toString();
        dialog.widgets[rowname].show = true;
        dialog.widgets[rowname].str = quest['ui_name'];
        dialog.widgets[rowname].onclick = (function (rownum) { return function (w) {
            missions_dialog_select_mission(w.parent, rownum); }; })(i);
        dialog.widgets['row_icon'+ui_row.toString()].show = player.can_complete_quest(quest);

        ui_row += 1;
        if(ui_row >= dialog.user_data['visible_rows']) {
            break;
        }
    }

    // hide remaining rows
    var last_row_str = player.get_any_abtest_value('missions_dialog_last_row_ui_name', gamedata['strings']['missions_dialog_last_row_ui_name']);
    while(ui_row < dialog.user_data['visible_rows']) {
        if(ui_row + first_row == dialog.user_data['quest_list'].length) {
            dialog.widgets['row'+ui_row.toString()].show = true;
            dialog.widgets['row'+ui_row.toString()].str = last_row_str;
        } else {
            dialog.widgets['row'+ui_row.toString()].show = false;
        }
        dialog.widgets['row_icon'+ui_row.toString()].show = false;
        ui_row += 1;
    }

    // set scroll widget clickability
    dialog.widgets['scroll_left'].state = (first_row > 0 ? 'normal':'disabled');
    dialog.widgets['scroll_right'].state = (dialog.user_data['quest_list'].length > first_row+dialog.user_data['visible_rows'] ? 'normal':'disabled');

    dialog.user_data['scroll_left_flash'] = (first_row > 0 && read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null));

    dialog.widgets['scroll_left'].text_color = SPUI.make_colorv(dialog.data['widgets']['scroll_left']['text_color_'+dialog.widgets['scroll_left'].state]);
    dialog.widgets['scroll_right'].text_color = SPUI.make_colorv(dialog.data['widgets']['scroll_right']['text_color_'+dialog.widgets['scroll_right'].state]);

    dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1', dialog.user_data['quest_list'].length > 0 ? first_row+1 : 0).replace('%d2', Math.min(first_row+dialog.user_data['visible_rows'], dialog.user_data['quest_list'].length)).replace('%d3', dialog.user_data['quest_list'].length);

    // select the pre-selection, or any row that's visible
    missions_dialog_select_mission(dialog, dialog.user_data['selected_row']);
}

function missions_dialog_select_mission(dialog, row) {
    dialog.user_data['selected_row'] = row;
    dialog.user_data['selected_row'] = Math.min(Math.max(dialog.user_data['selected_row'], dialog.user_data['first_row']), Math.min(dialog.user_data['first_row']+dialog.user_data['visible_rows']-1, dialog.user_data['quest_list'].length-1));

    if(dialog.user_data['selected_row'] < 0) { // no quests
        dialog.widgets['your_reward'].show =
        dialog.widgets['reward_gamebucks_icon'].show =
        dialog.widgets['reward_gamebucks_amount'].show =
        dialog.widgets['claim_button'].show =
        dialog.widgets['tips_label'].show =
        dialog.widgets['mission_icon'].show =
        dialog.widgets['mission_icon_frame'].show =
        dialog.widgets['mission_accomplished_bar'].show =
        dialog.widgets['mission_accomplished'].show =
        dialog.widgets['mission_incomplete_bar'].show =
        dialog.widgets['mission_incomplete'].show =
        dialog.widgets['sunken_right3'].show =
        dialog.widgets['selected_row'].show = false;
        for(var res in gamedata['resources']) {
            if('reward_'+res+'_icon' in dialog.widgets) {
                dialog.widgets['reward_'+res+'_icon'].show = dialog.widgets['reward_'+res+'_amount'].show = false;
            }
        }
        dialog.widgets['noquests'].show = true;
        dialog.widgets['valentina'].show = true;
        return;
    }

    var quest = dialog.user_data['quest_list'][dialog.user_data['selected_row']];
    // check whether quest goal has been satisfied
    var pred = read_predicate(quest['goal']);
    var pending = player.can_complete_quest(quest);

    // update highlight on left-hand display
    var white = new SPUI.Color(1,1,1,1);
    var highlight_color = new SPUI.Color(0.75,0.75,0.75,1), important_highlight_color = new SPUI.Color(1,1,0.7,1);
    var important_color = new SPUI.Color(1,1,0.4,1);

    for(var i = 0; i < dialog.user_data['visible_rows']; i++) {
        var rowname = 'row'+i.toString();
        var index = i+dialog.user_data['first_row'];
        var rq = (index < dialog.user_data['quest_list'].length ? dialog.user_data['quest_list'][index] : null);
        var select_this = (index == dialog.user_data['selected_row']);
        var important = rq && rq['ui_important'];

        dialog.widgets[rowname].font = SPUI.make_font(dialog.widgets[rowname].data['text_size'], dialog.widgets[rowname].data['text_size']+3,
                                                      (important ? 'normal' : 'normal'));

        if(rq) {
            dialog.widgets[rowname].text_color = (select_this ? (important ? important_highlight_color : white) : (important ? important_color : SPUI.disabled_text_color));
            dialog.widgets[rowname].highlight_text_color = (select_this ? (important ? important_highlight_color : white) : (important ? important_highlight_color : highlight_color));
            dialog.widgets[rowname].state = 'normal';
            if(!select_this && pending && quest['force_claim'] && !player.preferences['skip_tutorial']) {
                // remove ability to select other quests
                dialog.widgets[rowname].state = 'disabled';
            }
        } else {
            dialog.widgets[rowname].highlight_text_color = dialog.widgets[rowname].text_color = new SPUI.Color(0.25,0.25,0.25,1);
            dialog.widgets[rowname].state = 'disabled';
        }

        if(select_this) {
            var spacing = dialog.data['widgets']['row']['array_offset'][1];
            dialog.widgets['selected_row'].xy[1] = dialog.data['widgets']['row']['xy'][1]+i*spacing-2;
        }
    }

    // update info at right
    if('icon' in quest) {
        dialog.widgets['mission_icon'].show = true;
        dialog.widgets['mission_icon'].asset = quest['icon'];
    } else {
        dialog.widgets['mission_icon'].show = false;
    }
    dialog.widgets['mission_icon_frame'].show = dialog.widgets['mission_icon'].show;
    dialog.widgets['valentina'].show = !dialog.widgets['mission_icon'].show;

    dialog.widgets['flavor_title'].text_color = (quest['ui_important'] ? important_color : SPUI.default_text_color);
    dialog.widgets['flavor_title'].str = (quest['ui_flavor_name'] ? quest['ui_flavor_name'] : quest['ui_name']);
    dialog.widgets['subtitle'].str = (quest['ui_flavor_name'] ? quest['ui_name'] : '');

    if(quest['ui_instructions']) {
        dialog.widgets['tips_label'].show = true;
        dialog.widgets['tips'].set_text_with_linebreaking(quest['ui_instructions']);
    } else {
        dialog.widgets['tips_label'].show = false;
        dialog.widgets['tips'].str = '';
    }

    dialog.widgets['description'].set_text_with_linebreaking(eval_cond_or_literal(quest['ui_description'], player, null));
    dialog.widgets['description'].xy = dialog.widgets['description'].data['xy'+(quest['ui_flavor_name'] ? '':'_nosubtitle')];

    var reward_res = {};
    var max_res = player.get_max_storage();
    for(var res in gamedata['resources']) {
        reward_res[res] = quest['reward_'+res]||0;
        if('reward_'+res+'_ratio' in quest) {
            reward_res[res] += Math.floor(quest['reward_'+res+'_ratio']*max_res[res]);
        }
        if('repeat_interval' in quest) {
            var ratio = player.get_any_abtest_value('daily_quest_reward_ratio', gamedata['daily_quest_reward_ratio']);
            reward_res[res] = Math.floor(reward_res[res] * ratio);
        }
        if('reward_'+res+'_amount' in dialog.widgets) {
            dialog.widgets['reward_'+res+'_amount'].str = pretty_print_number(reward_res[res]);
            dialog.widgets['reward_'+res+'_amount'].tooltip.str = dialog.widgets['reward_'+res+'_icon'].tooltip.str = gamedata['resources'][res]['ui_description'];
            dialog.widgets['reward_'+res+'_amount'].show = dialog.widgets['reward_'+res+'_icon'].show = (reward_res[res] > 0);
        }
    }

    var reward_other = [];
    dialog.widgets['reward_unit_icon'].show = dialog.widgets['reward_unit_icon_stack'].show = false;
    dialog.widgets['reward_unit_icon'].onenter = dialog.widgets['reward_unit_icon'].onleave_cb = null;
    dialog.widgets['reward_unit_icon'].xy = dialog.data['widgets']['reward_unit_icon']['xy'];
    dialog.widgets['reward_unit_icon'].wh = dialog.data['widgets']['reward_unit_icon']['dimensions'];

    if('reward_heal_all_units' in quest && quest['reward_heal_all_units']) {
        reward_other.push(dialog.data['widgets']['reward_other_text']['ui_name_heal_all_units']);
        if(!dialog.widgets['reward_unit_icon'].show) {
            dialog.widgets['reward_unit_icon'].show = true;
            dialog.widgets['reward_unit_icon'].asset = 'inventory_repair_item_green';
            dialog.widgets['reward_unit_icon'].xy = dialog.data['widgets']['reward_unit_icon']['alloy_xy'];
        }
    }

    var reward_units = null;
    if('reward_give_units' in quest) {
        reward_units = quest['reward_give_units'];
    } else if (('reward_consequent' in quest) && (quest['reward_consequent']['consequent'] == 'GIVE_UNITS')) {
        reward_units = quest['reward_consequent']['units'];
    } else if (('reward_consequent' in quest) && (quest['reward_consequent']['consequent'] == 'GIVE_LOOT') &&
               (quest['reward_consequent']['loot'].length > 0)) {

        // XXX this is a special-case hack - we don't have a general-purpose way to display arbitrary loot tables
        // instead, abuse reward_unit_icon to display a loot item

        if(('spec' in quest['reward_consequent']['loot'][0]) &&
           (quest['reward_consequent']['loot'][0]['spec'].indexOf('packaged_') == 0) &&
           (quest['reward_consequent']['loot'][0]['spec'].slice(9) in gamedata['units'])) {
            reward_units = {};
            reward_units[quest['reward_consequent']['loot'][0]['spec'].slice(9)] = quest['reward_consequent']['loot'][0]['stack'] || 1;
        } else if(('multi' in quest['reward_consequent']['loot'][0]) && (quest['reward_consequent']['loot'][0]['multi'][0]['table'] == 'sexy_unlocked_unit')) {
            reward_units = {};
            var stack = (quest['reward_consequent']['loot'][0]['multi_stack'] || 1);

            // manually check the loot table to see what we're going to get
            var cond = gamedata['loot_tables_client']['sexy_unlocked_unit']['loot'][0]['cond'];
            for(var i = 0; i < cond.length; i++) {
                if(read_predicate(cond[i][0]).is_satisfied(player, null)) {
                    var unit_name = cond[i][1]['spec'].slice(9);
                    if(!(unit_name in gamedata['units'])) {
                        throw Error('cannot parse sexy_unlocked_unit '+cond[i][1]['spec']);
                    }
                    reward_units[unit_name] = stack;
                    break;
                }
            }
        } else if('spec' in quest['reward_consequent']['loot'][0]) {
            // display an arbitrary item
            dialog.widgets['reward_unit_icon'].show = dialog.widgets['reward_unit_icon_stack'].show = true;
            var item = quest['reward_consequent']['loot'][0]; // fake item for tooltip
            var spec = ItemDisplay.get_inventory_item_spec(item['spec']);
            ItemDisplay.set_inventory_item_asset(dialog.widgets['reward_unit_icon'], spec);
            ItemDisplay.set_inventory_item_stack(dialog.widgets['reward_unit_icon_stack'], spec, item);

            // reposition icon for item display
            dialog.widgets['reward_unit_icon'].xy = dialog.data['widgets']['reward_unit_icon']['item_xy'];
            dialog.widgets['reward_unit_icon'].wh = dialog.data['widgets']['reward_unit_icon']['item_dimensions'];

            dialog.widgets['reward_unit_icon'].onenter = (function (_item) { return function(w) {
                var dialog = w.parent;
                if(dialog.user_data['context']) { return; }
                invoke_inventory_context(dialog, w, 0, _item, false);
                // set transparent so that onleave is always called reliably
                if(dialog.user_data['context']) { dialog.user_data['context'].transparent_to_mouse = true; }
            }; })(item);
            dialog.widgets['reward_unit_icon'].onleave_cb = function(w) {
                var dialog = w.parent;
                if(dialog.user_data['context']) { invoke_inventory_context(dialog, w, -1, null, false); }
            };
        }
    }

    if(reward_units) {
        var data = reward_units;
        for(var name in data) {
            var qty = data[name];
            if(!(name in gamedata['units'])) {
                continue;
            }
            var spec = gamedata['units'][name];
            if(qty > 0) {
                var str = qty.toString() + 'x ' + spec['ui_name'];
                reward_other.push(str);
                dialog.widgets['reward_unit_icon'].show = true;
                dialog.widgets['reward_unit_icon'].asset = get_leveled_quantity(spec['art_asset'], 1);
                var voffset;
                if(spec['flying']) {
                    voffset = -4*spec['altitude'];
                } else {
                    voffset = 0;
                }
                dialog.widgets['reward_unit_icon'].bg_image_offset = [dialog.data['widgets']['reward_unit_icon']['bg_image_offset'][0],
                                                                      dialog.data['widgets']['reward_unit_icon']['bg_image_offset'][1] + voffset];
            }
        }
    }
    dialog.widgets['reward_other_text'].str = reward_other.join('\n');

    var reward_xp = 0;

    if('quest_reward_resources' in gamedata['player_xp']) {
        var total_res = 0;
        for(var res in gamedata['resources']) {
            total_res += quest['reward_'+res] || 0;
        }
        reward_xp = Math.floor(gamedata['player_xp']['quest_reward_resources'] * total_res);
    } else {
        reward_xp = ('reward_xp' in quest ? Math.max(Math.floor(quest['reward_xp']*gamedata['player_xp']['quests']), gamedata['player_xp']['quests_min']) : 0);
    }

    if(('reward_gamebucks' in quest) && player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks') {
        dialog.widgets['reward_gamebucks_amount'].show =
            dialog.widgets['reward_gamebucks_icon'].show = true;
        dialog.widgets['reward_gamebucks_amount'].str = Store.display_user_currency_amount(quest['reward_gamebucks'], 'compact');
        dialog.widgets['reward_gamebucks_icon'].asset = player.get_any_abtest_value('gamebucks_resource_icon', gamedata['store']['gamebucks_resource_icon']);
        reward_other.push(Store.display_user_currency_amount(quest['reward_gamebucks'], 'full'));
        dialog.widgets['reward_gamebucks_amount'].tooltip.str =
            dialog.widgets['reward_gamebucks_icon'].tooltip.str = dialog.data['widgets']['reward_gamebucks_icon']['ui_tooltip'].replace('%s', player.get_any_abtest_value('gamebucks_ui_name', gamedata['store']['gamebucks_ui_name']));

        dialog.widgets['reward_xp_amount'].show =
            dialog.widgets['reward_xp_icon'].show = false;
    } else {
        dialog.widgets['reward_gamebucks_amount'].show =
            dialog.widgets['reward_gamebucks_icon'].show = false;

        // gamebucks and xp take up the same space, so only show one of them at a time
        if(reward_xp > 0) {
            dialog.widgets['reward_xp_amount'].show =
                dialog.widgets['reward_xp_icon'].show = true;

            dialog.widgets['reward_xp_amount'].str = pretty_print_number(reward_xp);
        }
    }

    dialog.widgets['claim_button'].state = (pending ? 'bigaction' : 'normal');
    dialog.widgets['claim_button'].str = dialog.data['widgets']['claim_button']['ui_name'+ (pending ? '' : '_accept')];
    dialog.widgets['claim_button'].bg_image = (pending ? 'action_button_134px' : 'menu_button_134px');
    if(pending) {
        dialog.widgets['claim_button'].onclick = (function (q) { return function(w) {
            var dialog = w.parent;
            if(1) {
                dialog.widgets['glow'].show = true;
                dialog.widgets['glow'].reset_fx();
            }
            send_to_server.func(["COMPLETE_QUEST", q['name']]);
            dialog.widgets['claim_button'].str = dialog.data['widgets']['claim_button']['ui_name_claiming'];
            dialog.widgets['claim_button'].state = 'disabled';
        }; })(quest);
    } else {
        dialog.widgets['claim_button'].onclick = (function (q) { return function() {
            if('ui_accept_url' in q) {
                // override default behavior with a URL open
                var handle = window.open(q['ui_accept_url'], '_blank');
                if(handle) { handle.focus(); }
                return;
            }

            change_selection(null);

            if('ui_accept_consequent' in q) {
                read_consequent(q['ui_accept_consequent']).execute();
            }

            // "accept" button works like "close" if in skip_tutorial mode
            if('skip_tutorial' in player.preferences && player.preferences['skip_tutorial']) {
                // NOTE! do NOT track the quest, since the player does not want tips
                player.quest_tracked = null;
                player.quest_tracked_dirty = true;
            } else {
                tutorial_opt_in(q);
            }
        }; })(quest);
    }

    dialog.widgets['mission_accomplished'].show =
        dialog.widgets['mission_accomplished_bar'].show = pending;
    dialog.widgets['mission_incomplete'].show =
        dialog.widgets['mission_incomplete_bar'].show = !pending;

    if(!pending) {
        // get mission progress text, if available
        var text = null;
        if(pred.ui_progress) {
            text = pred.ui_progress(player);
        }

        if(text) {
            dialog.widgets['mission_incomplete'].str = text;
        } else {
            dialog.widgets['mission_incomplete'].str = dialog.data['widgets']['mission_incomplete']['ui_name'];
        }
    }

    if(0) {
        if(!pending) {
            // add tooltip to explain why quest is not complete yet
            dialog.widgets['claim_button'].tooltip.str = pred.ui_describe(player);
        } else {
            dialog.widgets['claim_button'].tooltip.str = '';
        }
    }
    player.quest_tracked_dirty = true;
}

function invoke_map_dialog(force_page) {
    change_selection(null);

    var dialog_data = gamedata['dialogs']['map_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);

    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'map_dialog';
    dialog.user_data['chapter'] = null;
    dialog.user_data['page'] = 0;
    dialog.user_data['quarries'] = null;
    dialog.user_data['friends_on_page'] = [];
    dialog.user_data['quarries_on_page'] = [];
    dialog.user_data['rivals_fetched'] = 0;
    dialog.user_data['quarries_fetched'] = 0;
    dialog.user_data['hitlist_scanned'] = 0;

    dialog.widgets['close_button'].onclick = function() {
        if(player.tutorial_state != "COMPLETE") { return; }
        change_selection(null);
    };

    dialog.widgets['refresh_button'].onclick = function(w) {
        var dialog = w.parent;

        if(dialog.user_data['chapter'] === 'rivals') {
            var cb = (function(_dialog) { return function() {
                dialog.user_data['rivals_fetched'] += 1;

                // reset rivals list and page number
                if(_dialog.user_data['chapter'] === 'rivals') {
                    var oldpage = _dialog.user_data['page']; // 0
                    _dialog.user_data['page'] = -1;
                    map_dialog_change_page(_dialog, _dialog.user_data['chapter'], oldpage);
                }
            }; })(dialog);

            // send a query for battled rivals the first time, then set flag to false on subsequent refreshes
            query_rivals(cb, (dialog.user_data['rivals_fetched'] == 0));
        } else if(dialog.user_data['chapter'] === 'quarries') {
            var cb = (function(_dialog) { return function(db_time, result) {
                dialog.user_data['quarries'] = [];
                dialog.user_data['quarries_fetched'] += 1;

                for(var i = 0; i < result.length; i++) {
                    var quarry = result[i];
                    if(quarry['base_type'] == 'quarry') {
                        dialog.user_data['quarries'].push(quarry);
                    }
                }

                // reset rivals list and page number
                if(_dialog.user_data['chapter'] === 'quarries') {
                    var oldpage = _dialog.user_data['page']; // 0
                    _dialog.user_data['page'] = -1;
                    map_dialog_change_page(_dialog, _dialog.user_data['chapter'], oldpage);
                }
            }; })(dialog);
            query_quarries(cb, -1);
        }
    };

    dialog.ondraw = update_map_dialog;
    update_map_dialog_header_buttons(dialog); // to set up onclick handlers for the below

    dialog.widgets['dev_title'].show = !!player.is_cheater;

    // very, very awkward, but this dialog is a mess
    var page = map_dialog_get_default_page();
    if(page != 'computers' && force_page) {
        page = 'computers';
    }
    dialog.widgets[page+'_button'].onclick(dialog.widgets[page+'_button']);
    if(force_page && dialog.user_data['chapter'] != force_page && dialog.widgets[force_page+'_button'].show) {
        dialog.widgets[force_page+'_button'].onclick(dialog.widgets[force_page+'_button']);
    }


    if(player.tutorial_state === 'open_map_dialog') { advance_tutorial(); }
}

// store choice once, then allow player to override
var map_dialog_default_page = null;
function map_dialog_get_default_page() {
    if(!map_dialog_default_page) {
        var page = 'computers';

        if(player.tutorial_state != "COMPLETE" || !read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null)) {
            page = 'computers';
        } else if(player.get_any_abtest_value('map_dialog_default_page', null)) {
            page = player.get_any_abtest_value('map_dialog_default_page', null);
        } else {
            page = eval_cond_or_literal(gamedata['map_dialog_default_page'], player, null);
        }
        map_dialog_default_page = page;
    }

    // check for tab accessibility
    if((!player.is_pvp_player() || !player.is_legacy_pvp_player()) && map_dialog_default_page == 'rivals') { map_dialog_default_page = 'computers'; }
    if(!session.region.map_enabled() && map_dialog_default_page == 'quarries') { map_dialog_default_page = 'computers'; }

    return map_dialog_default_page;
}

function update_map_dialog(dialog) {
    update_map_dialog_header_buttons(dialog);

    var show_loading = false;
    if(dialog.user_data['chapter'] === 'hitlist') {
        if(!player.cooldown_active('hitlist_assigned')) {
            if(!player.cooldown_active('hitlist_assign_pending')) {
                send_to_server.func(["CAST_SPELL", GameObject.VIRTUAL_ID, "HITLIST_ASSIGN"]);
                player.cooldown_client_trigger('hitlist_assign_pending', 999);
            }
            show_loading = true;
        } else if(!dialog.user_data['hitlist_scanned']) {
            dialog.user_data['hitlist_scanned'] = 1;
            map_dialog_change_page(dialog, dialog.user_data['chapter'], -1); // rescan list after the assignment comes in (use page = -1 to force rescan)
        }
    } else {
        var last_query_time = (dialog.user_data['chapter'] === 'quarries' ? last_quarry_query_time : last_rivals_query_time);
        var fetched = dialog.user_data[(dialog.user_data['chapter'] === 'quarries' ? 'quarries_fetched' : 'rivals_fetched')];

        var ok_to_send_query = (last_query_time == -1 ||
                                (last_query_time > 0 && client_time > (last_query_time+gamedata['rival_query_cooldown'])));

        dialog.widgets['refresh_button'].state = ok_to_send_query ? 'normal' : 'disabled';

        if(last_query_time == -1 || (dialog.user_data['chapter'] === 'quarries' && dialog.user_data['quarries'] === null)) {
            // start initial refresh
            if(dialog.user_data['chapter'] === 'rivals' || dialog.user_data['chapter'] === 'quarries') {
            dialog.widgets['refresh_button'].onclick(dialog.widgets['refresh_button']);
            }
        }
        // show "Loading..." only during true query latency on first try,
        // but then keep it up until cooldown expires on subsequent tries

        show_loading = ((dialog.user_data['chapter'] == 'rivals' || dialog.user_data['chapter'] == 'quarries') &&
                        (last_query_time == 0 ||
                         (fetched && !ok_to_send_query)));
    }

    dialog.widgets['loading_rect'].show = dialog.widgets['loading_text'].show = dialog.widgets['loading_spinner'].show = show_loading;

    // update timers
    var row = 0;
    if(dialog.user_data['chapter'] === 'quarries') {
        for(; row < dialog.user_data['quarries_on_page'].length; row++) {
            var quarry = dialog.user_data['quarries_on_page'][row];

            // travel timer
            dialog.widgets['row_travel0'+row].show = true;
            var travel_time = player.travel_time_to(quarry['base_map_loc']);
            var to_go = player.travel_state['end_time'] - server_time; // may not be relevant if travel_satisfied() is true
            dialog.widgets['row_travel0'+row].str = pretty_print_time_brief(travel_time);
            dialog.widgets['row_travel1'+row].show = true;
            if(quarry['base_landlord_id'] === session.user_id) {
                dialog.widgets['row_travel1'+row].str = dialog.data['widgets']['row_travel1']['ui_name_owned'];
                if(player.travel_state['dest_loc'] && vec_equals(player.travel_state['dest_loc'], quarry['base_map_loc'])) {
                    if(player.travel_satisfied(quarry['base_map_loc'])) {
                        dialog.widgets['row_travel1'+row].str = dialog.data['widgets']['row_travel1']['ui_name_ready_to_reinforce'];
                    } else {
                        dialog.widgets['row_travel1'+row].str = dialog.data['widgets']['row_travel1']['ui_name_reinforce_in'].replace('%s', pretty_print_time_brief(to_go));
                    }
                }
                dialog.widgets['row_travel1'+row].text_color = new SPUI.Color(0,1,0,1);
            } else if(player.travel_state['dest_loc'] && vec_equals(player.travel_state['dest_loc'], quarry['base_map_loc'])) {
                if(player.travel_satisfied(quarry['base_map_loc'])) {
                    dialog.widgets['row_travel1'+row].str = dialog.data['widgets']['row_travel1']['ui_name_ready_for_battle'];
                    dialog.widgets['row_travel1'+row].text_color = SPUI.default_text_color;
                } else {
                    dialog.widgets['row_travel1'+row].str = dialog.data['widgets']['row_travel1']['ui_name_arriving_in'].replace('%s',pretty_print_time_brief(to_go));
                    dialog.widgets['row_travel1'+row].text_color = new SPUI.Color(0.5,0.5,0.5,1);
                }
            } else {
                dialog.widgets['row_travel1'+row].str = '';
            }

            // Spy button
            var visit_func = (function (_quarry) { return function() {
                do_visit_base(-1, {base_id:_quarry['base_id']});
            }; })(quarry);
            var travel_func = (function (_quarry) { return function() {
                send_to_server.func(["TRAVEL_BEGIN", _quarry['base_map_loc'], player.travel_time_to(_quarry['base_map_loc'])]);
            }; })(quarry);

            dialog.widgets['row_button'+row].show = true;

            if((quarry['base_landlord_id'] === session.user_id || player.travel_satisfied(quarry['base_map_loc']))) {
                // can visit immediately
                dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name'];
                dialog.widgets['row_button'+row].tooltip.str = '';
                dialog.widgets['row_button'+row].state = 'normal';
                dialog.widgets['row_button'+row].onclick = visit_func;

                // attack status overrides other possibilities
                var lock_state = quarry['LOCK_STATE'] || 0;
                var lock_owner = quarry['LOCK_OWNER'] || -1;
                if(lock_state != 0 && (lock_owner != session.user_id)) {
                    dialog.widgets['row_button'+row].state = 'disabled';
                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_under_attack'];
                    dialog.widgets['row_button'+row].tooltip.str = dialog.data['widgets']['row_button']['ui_tooltip_under_attack'];
                }

            } else {
                // must travel first
                dialog.widgets['row_button'+row].tooltip.str = '';

                if(!player.travel_state['dest_loc']) {
                    // no destination selected, show Travel button
                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_travel'];
                    dialog.widgets['row_button'+row].state = 'normal';
                    dialog.widgets['row_button'+row].onclick = travel_func;
                } else if(vec_equals(player.travel_state['dest_loc'], quarry['base_map_loc'])) {
                    // on way to this destination, show Cancel Travel button
                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_cancel_travel'];
                    dialog.widgets['row_button'+row].state = 'normal';
                    dialog.widgets['row_button'+row].onclick = function() { send_to_server.func(["TRAVEL_BEGIN", null, 0]); };
                } else if(player.travel_state['end_time'] >= server_time) {
                    // on way to another destination
                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_travel'];
                    //dialog.widgets['row_button'+row].state = 'disabled';
                    dialog.widgets['row_button'+row].onclick = travel_func;
                    dialog.widgets['row_button'+row].tooltip.str = dialog.data['widgets']['row_button']['ui_tooltip_travel'];
                } else {
                    // arrived at another destination
                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_travel'];
                    dialog.widgets['row_button'+row].state = 'normal';
                    dialog.widgets['row_button'+row].onclick = travel_func;
                }
            }
            dialog.widgets['row_ai_info'+row].show = false;
            dialog.widgets['row_button'+row].drop_shadow = (dialog.widgets['row_button'+row].state == 'attack');
        }
    } else {
        for(; row < dialog.user_data['friends_on_page'].length; row++) {
            var friend = dialog.user_data['friends_on_page'][row];
            dialog.widgets['row_attackability'+row].show =
                dialog.widgets['row_hider'+row].show =
                dialog.widgets['row_ai_info'+row].show =
                dialog.widgets['row_hider_button'+row].show = false;

            // Spy button
            dialog.widgets['row_button'+row].show = true;

            var callback = (function (uid) { return function() {
                visit_base(uid);
                if(player.tutorial_state === 'spy_on_ai') {
                    advance_tutorial();
                }
            }; })(friend.user_id);

            dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name'];
            dialog.widgets['row_button'+row].tooltip.str = '';
            dialog.widgets['row_button'+row].state = (dialog.user_data['chapter'] == 'hitlist' ? 'attack' : 'normal');
            dialog.widgets['row_button'+row].onclick = callback;

            if(friend.is_ai() && !dialog.widgets['row_info_button'+row].show) {
                // for AIs without "?" buttons, make the portrait/name do the spy action when clicked
                dialog.widgets['row_portrait'+row].onclick = dialog.widgets['row_name'+row].onclick = callback;
            }

            var attackability_str = null, attackability_col = dialog.data['widgets']['row_attackability']['text_color'];

            if(false /*(friend.protection_end_time == 1 || friend.protection_end_time > server_time) XXX obsolete, needs PlayerCache */ ) {
                attackability_str = dialog.data['widgets']['row_attackability']['ui_name_protection'];
            } else if(false /* friend.attack_cooldown_expire > server_time XXX obsolete, needs PlayerCache */ ) {
                attackability_str = dialog.data['widgets']['row_attackability']['ui_name_cooldown']; // .replace('%s', pretty_print_time_brief(friend.attack_cooldown_expire - server_time));
            } else if(friend.is_ai()) {
                var base = gamedata['ai_bases_client']['bases'][friend.user_id.toString()];

                if('ui_spy_button' in base) {
                    dialog.widgets['row_button'+row].str = base['ui_spy_button'];
                    if(dialog.user_data['chapter'] != 'hitlist') {
                        dialog.widgets['row_button'+row].state = 'passive';
                    }
                } else if(base['kind'] == 'ai_attack') {
                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_ai_attack'];
                }

                if(base['kind'] == 'ai_attack') {
                    // replace the regular Spy command with start_ai_attack()
                    dialog.widgets['row_portrait'+row].onclick = dialog.widgets['row_name'+row].onclick = dialog.widgets['row_button'+row].onclick = (function (uid) { return function() {
                        start_ai_attack(uid);
                    }; })(friend.user_id);
                }

                var pred = read_predicate(base['activation']);
                if(!pred.is_satisfied(player, null) && !player.is_cheater) {
                    //attackability_str = dialog.data['widgets']['row_attackability']['ui_ name_locked'];
                    dialog.widgets['row_hider'+row].show =
                        dialog.widgets['row_hider_button'+row].show = true;
                    dialog.widgets['row_hider_button'+row].onclick = get_requirements_help(pred, null);
                    var ui_pred = pred.ui_describe(player);
                    dialog.widgets['row_hider_button'+row].tooltip.str = (ui_pred ? dialog.data['widgets']['row_hider_button']['ui_tooltip'].replace('%s', ui_pred) : null);
                    if('ui_info' in base) {

                        dialog.widgets['row_hider_button'+row].tooltip.str += '\n\n' + base['ui_info'];
                    }
                    dialog.widgets['row_hider_button'+row].tooltip.text_color = SPUI.error_text_color;

                    // if the AI base uses an instance cooldown, AND the cooldown is running,
                    // show cooldown info
                    if('ui_resets' in base) {
                        attackability_str = base['ui_resets'];
                        attackability_col = dialog.data['widgets']['row_attackability']['text_color_resets'];
                    }
                    if('ui_instance_cooldown' in base) {
                        var togo = player.cooldown_togo(base['ui_instance_cooldown']);
                        if(togo > 0) {
                            attackability_str = (base['ui_instance_cooldown_template'] || dialog.data['widgets']['row_attackability']['ui_name_instance_cooldown']).replace('%s', pretty_print_time(togo));
                            attackability_col = dialog.data['widgets']['row_attackability']['text_color_resets_inprogress'];

                            // detect dummy bases that exist only to hold a place while waiting for the cooldown to expire,
                            // and show plain ui_info instead of the failed predicate text
                            if(base['activation']['predicate'] == 'ALWAYS_FALSE' && ('ui_info' in base)) {
                                dialog.widgets['row_hider_button'+row].tooltip.str = base['ui_info'];
                                dialog.widgets['row_hider_button'+row].tooltip.text_color = SPUI.default_text_color;
                            }
                        } else if('ui_resets' in base) {
                            attackability_str = base['ui_resets'];
                            attackability_col = dialog.data['widgets']['row_attackability']['text_color_resets'];
                        }
                    }

                    dialog.widgets['row_button'+row].str = dialog.data['widgets']['row_button']['ui_name_locked'];
                    dialog.widgets['row_button'+row].state = 'disabled';
                } else {
                    if('ui_resets' in base) {
                        attackability_str = base['ui_resets'];
                        attackability_col = dialog.data['widgets']['row_attackability']['text_color_resets'];
                    }
                    if('ui_instance_cooldown' in base) {
                        var togo = player.cooldown_togo(base['ui_instance_cooldown']);
                        if(togo > 0) {
                            attackability_str = dialog.data['widgets']['row_attackability']['ui_name_instance_cooldown'].replace('%s', pretty_print_time(togo));
                            attackability_col = dialog.data['widgets']['row_attackability']['text_color_resets_inprogress'];
                        }
                    }
                    dialog.widgets['row_ai_info'+row].show = true;
                    dialog.widgets['row_ai_info'+row].onclick = null;
                    dialog.widgets['row_ai_info'+row].tooltip.str = base['ui_info'] || null;
                }
            }

            if(attackability_str) {
                dialog.widgets['row_attackability'+row].show = true;
                dialog.widgets['row_attackability'+row].str = attackability_str;
                dialog.widgets['row_attackability'+row].text_color = new SPUI.Color(attackability_col[0],
                                                                                    attackability_col[1],
                                                                                    attackability_col[2],1);
            }
            dialog.widgets['row_button'+row].drop_shadow = (dialog.widgets['row_button'+row].state == 'attack');
        }
    }

    while(row < dialog.data['widgets']['row_attackability']['array'][1]) {
        dialog.widgets['row_button'+row].show =
            dialog.widgets['row_attackability'+row].show =
            dialog.widgets['row_ai_info'+row].show =
            dialog.widgets['row_hider'+row].show =
            dialog.widgets['row_hider_button'+row].show = false;
        row += 1;
    }

    dialog.widgets['hitlist_empty'].show = (dialog.user_data['chapter'] == 'hitlist' && dialog.user_data['friends_on_page'].length == 0 &&
                                            player.cooldown_active('hitlist_assigned'));
    if(dialog.widgets['hitlist_empty'].show) {
        dialog.widgets['hitlist_empty'].str = dialog.data['widgets']['hitlist_empty']['ui_name'].replace('%s', pretty_print_time(player.cooldown_togo('hitlist_assigned')));
    }
}

// global flag - show rival warning only once per session
var map_dialog_rivals_warned = false;

// "chapter" means "computers", "rivals", "friends", or "quarries"
// "page" refers to the left/right scrolling position

function map_dialog_change_page(dialog, chapter, page) {

    player.quest_tracked_dirty = true;

    // see whether rivals page would be empty
    var any_rivals = true;

    /*
    for(var i = 0; i < player.friends.length; i++) {
        var friend = player.friends[i];
        if(!friend.is_ai() && !friend.is_real_friend) {
            any_rivals = true;
            break;
        }
    }
    */

    // hide rivals until tutorial is complete
    if(player.tutorial_state != "COMPLETE") {
        any_rivals = false;
    }

    // if rivals page would be empty, divert to computers page
    if(!any_rivals && chapter === 'rivals') {
        chapter = 'computers';
    }
    if(!player.is_legacy_pvp_player() && chapter === 'rivals') {
        chapter = 'computers';
    }

    if(dialog.user_data['chapter'] === chapter && dialog.user_data['page'] === page) { return; }
    dialog.user_data['chapter'] = chapter;
    dialog.user_data['page'] = page;
    map_dialog_default_page = chapter;

    dialog.widgets['refresh_button'].show = (chapter === 'rivals' || chapter === 'quarries');
    dialog.widgets['refresh_button'].tooltip.str = dialog.data['widgets']['refresh_button'][(chapter === 'quarries' ? 'ui_tooltip_quarries' : 'ui_tooltip')];

    dialog.widgets['column_header_travel'].show = (chapter === 'quarries');

    dialog.widgets['column_header_battle_stars'].show = (chapter !== 'quarries' && !!gamedata['client']['map_dialog_battle_stars_column']);
    dialog.widgets['column_header_level'].show = (chapter !== 'quarries' && !dialog.widgets['column_header_battle_stars'].show);

    // show rival warning dialog
    if(dialog.user_data['chapter'] != 'computers' &&
       player.resource_state['protection_end_time'] > server_time &&
       player.get_any_abtest_value('map_dialog_warn_rivals', gamedata['client']['map_dialog_warn_rivals']) &&
       player.quest_root.children.length == 0 &&
       ((player.history['attacks_launched_vs_human'] || 0) == 0) &&
       !map_dialog_rivals_warned) {
        map_dialog_rivals_warned = true;
        invoke_ingame_tip('human_rivals_tip', {force:true});
    } else if(dialog.user_data['chapter'] === 'quarries') {
        invoke_ingame_tip('map_quarries_tip');
    }


    var item_list = [];

    if(chapter === 'quarries') {
        if(dialog.user_data['quarries'] !== null) {

            for(var i = 0; i < dialog.user_data['quarries'].length; i++) {
                var quarry = dialog.user_data['quarries'][i];
                if(quarry['base_expire_time'] &&
                   quarry['base_expire_time'] > 0 &&
                   server_time >= quarry['base_expire_time']) {
                    continue;
                }
                item_list.push(quarry);
            }

            var compare_by_base_id = function (a,b) {
                if(a['base_id'] < b['base_id']) {
                    return -1;
                } else if(a['base_id'] > b['base_id']) {
                    return 1;
                } else {
                    return 0;
                }
            };

            var compare_by_ownership_and_travel_time = function (a,b) {
                var time_a = player.travel_time_to(a['base_map_loc']);
                var time_b = player.travel_time_to(b['base_map_loc']);
                var owns_a = a['base_landlord_id'] === session.user_id;
                var owns_b = b['base_landlord_id'] === session.user_id;
                if(owns_a && !owns_b) {
                    return -1;
                } else if(owns_b && !owns_a) {
                    return 1;
                } else if(time_a < time_b) {
                    return -1;
                } else if(time_a > time_b) {
                    return 1;
                } else {
                    return 0;
                }
            };

            item_list.sort(compare_by_ownership_and_travel_time);
        }
    } else {
        if(chapter == 'hitlist') {
            goog.object.forEach(gamedata['ai_bases_client']['bases'], function(ai_base, sid) {
                if((ai_base['ui_category']||'computers') != chapter) { return; }
                if(('show_if' in ai_base) && !read_predicate(ai_base['show_if']).is_satisfied(player, null)) { return; }
                // create a fake Friend entry for the AI
                var info = {'social_id': 'ai', 'ui_name': ai_base['ui_name'], 'player_level': ai_base['resources']['player_level']};
                item_list.push(new Friend(parseInt(sid,10), 0, -1, false, info));
            });
        } else {
            // first filter the list of friends down to those who should appear on this page
            for(var i = 0; i < player.friends.length; i++) {
                var friend = player.friends[i];
                var ai_base = (friend.is_ai() ? gamedata['ai_bases_client']['bases'][friend.user_id.toString()] || null : null);

                if(chapter === 'computers') {
                    if(friend.is_ai()) {
                        if(player.tutorial_state != "COMPLETE") {
                            // special case for tutorial - only show Lion Stone
                            if(friend.user_id != LION_STONE_ID) { continue; }
                        }
                        if(ai_base && (ai_base['ui_category']||'computers') != 'computers') { continue; }
                        item_list.push(friend);
                    }
                } else if(chapter === 'friends') {
                    if(!friend.is_ai() && friend.is_real_friend) {
                        item_list.push(friend);
                    }
                } else if(chapter === 'rivals') {
                    if(!friend.is_ai() && !friend.is_real_friend) {
                        item_list.push(friend);
                    }
                } else if(chapter === 'hitlist') {
                    if(ai_base) {
                        if((ai_base['ui_category']||'computers') != 'hitlist') { continue; }
                        item_list.push(friend);
                    }
                }
            }
        }

        // sort list
        var compare_by_ai_level = function (a,b) {
            // first sort by ui_priority high to low
            var ap = eval_cond_or_literal(gamedata['ai_bases_client']['bases'][a.user_id.toString()]['ui_priority'] || 0, player, null);
            var bp = eval_cond_or_literal(gamedata['ai_bases_client']['bases'][b.user_id.toString()]['ui_priority'] || 0, player, null);

            if(ap < bp) {
                return 1;
            } else if(ap > bp) {
                return -1;
            } else {
                // then level low to high
                if(a.get_player_level() < b.get_player_level()) {
                    return -1;
                } else if(a.get_player_level() > b.get_player_level()) {
                    return 1;
                } else {
                    // use user_id as final sort key to ensure stable order for AIs
                    if(a.user_id < b.user_id) {
                        return 1;
                    } else if(a.user_id > b.user_id) {
                        return -1;
                    } else {
                        return 0;
                    }
                }
            }
        };
        var compare_by_battle_count = function(a,b) {
            if(a.battle_count > b.battle_count) {
                return -1;
            } else if(a.battle_count < b.battle_count) {
                return 1;
            } else {
                if(a.get_player_level() < b.get_player_level()) {
                    return 1;
                } else if(a.get_player_level() > b.get_player_level()) {
                    return -1;
                } else {
                    return 0;
                }
            }
        };
        item_list.sort(goog.array.contains(['computers','hitlist'], chapter) ? compare_by_ai_level : compare_by_battle_count);
    }


    // now fill in the dialog widgets
    var row = 0;

    var rows_per_page = 5; // how many rows show up on each page

    var chapter_friends = item_list.length; // total number of entries in this chapter

    // how many pages are in this chapter
    var chapter_pages = Math.floor((chapter_friends+rows_per_page-1)/rows_per_page);

    // reset the page index if it's out of bounds
    dialog.user_data['page'] = page = (chapter_pages === 0 ? 0 : clamp(page, 0, chapter_pages-1));

    dialog.user_data['quarries_on_page'] = [];
    dialog.user_data['friends_on_page'] = [];

    if(chapter_pages > 0) {
        // if any friends are to be shown

        // indices of the first and last friends able to be shown in the page
        var first_friend_on_page = page * rows_per_page;
        var last_friend_on_page = (page+1)*rows_per_page - 1;
        last_friend_on_page = Math.max(0, Math.min(last_friend_on_page, chapter_friends-1));

        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_friend_on_page+1).toString()).replace('%d2',(last_friend_on_page+1).toString()).replace('%d3',chapter_friends.toString());

        for(var i = first_friend_on_page; i <= last_friend_on_page; i++) {
            dialog.widgets['row_bg'+row].show = true;
            dialog.widgets['row_bg'+row].color = SPUI.make_colorv(dialog.data['widgets']['row_bg'][('color_'+chapter in dialog.data['widgets']['row_bg'] ? 'color_'+chapter : 'color')]);
            dialog.widgets['row_portrait_outline'+row].show = true;
            dialog.widgets['row_portrait_outline'+row].outline_color = SPUI.make_colorv(dialog.data['widgets']['row_portrait_outline'][('outline_color_'+chapter in dialog.data['widgets']['row_portrait_outline'] ? 'outline_color_'+chapter : 'outline_color')]);
            dialog.widgets['row_challenge_icon'+row].show = false;

            for(var h = 0; h < dialog.data['widgets']['row_star_holes']['array'][0]; h++) {
                dialog.widgets[SPUI.get_array_widget_name('row_stars', dialog.data['widgets']['row_stars']['array'], [h,row])].show = false;
                dialog.widgets[SPUI.get_array_widget_name('row_star_holes', dialog.data['widgets']['row_star_holes']['array'], [h,row])].show = false;
            }

            if(chapter === 'quarries') {
                var quarry = item_list[i];
                dialog.user_data['quarries_on_page'].push(quarry);
                var landlord = PlayerCache.query_sync(quarry['base_landlord_id']);

                dialog.widgets['row_portrait'+row].show = true;
                dialog.widgets['row_portrait'+row].set_user(quarry['base_landlord_id'] || null);

                var info_func = (function(_landlord) { return function() {
                    if(_landlord && !is_ai_user_id_range(_landlord['user_id'])) {
                        invoke_player_info_dialog_unknown(_landlord['user_id'],
                                                          _landlord['facebook_id'],
                                                          PlayerCache.get_ui_name(_landlord),
                                                          _landlord['player_level'] || 1);
                    }
                }; })(landlord);

                dialog.widgets['row_portrait'+row].onclick =
                    dialog.widgets['row_attackability'+row].onclick =
                    dialog.widgets['row_name'+row].onclick = info_func;

                dialog.widgets['row_name'+row].show = true;
                dialog.widgets['row_name'+row].str = quarry['base_ui_name'];
                dialog.widgets['row_level'+row].show = false;



                dialog.widgets['row_qicon'+row].show = true;
                dialog.widgets['row_qicon'+row].bg_image = 'resource_icon_'+quarry['base_icon'];

                var TIMELEFT = [[1, 'low'], [3600, 'medium'], [43200, 'full']];
                var fullness_state;
                if(quarry['base_expire_time'] < 0) {
                    fullness_state = 'full';
                } else {
                    fullness_state = 'empty';
                    for(var r = 0; r < TIMELEFT.length; r++) {
                        if((quarry['base_expire_time'] - server_time) >= TIMELEFT[r][0]) {
                            fullness_state = TIMELEFT[r][1];
                        } else { break; }
                    }
                }
                var RICHNESS = gamedata['strings']['regional_map']['richness'];
                var rich_str = '?';
                for(var r = 0; r < RICHNESS.length; r++) {
                    if(quarry['base_richness'] >= RICHNESS[r][0]) {
                        rich_str = RICHNESS[r][1];
                    } else { break; }
                }

                dialog.widgets['row_qstat'+row].show = true;
                dialog.widgets['row_qstat'+row].state = fullness_state;

                var qtip;
                if(1) {
                    var data = dialog.data['widgets']['row_qstat'];
                    qtip = data['ui_tooltip_'+fullness_state].replace('%SIZE', data['ui_tooltip_sizes'][rich_str]).replace('%RESOURCE', gamedata['resources'][quarry['base_icon']]['ui_name']);
                }

                dialog.widgets['row_qsize'+row].show = true;
                dialog.widgets['row_qsize'+row].str = rich_str;

                dialog.widgets['row_qstat'+row].tooltip.str =
                    dialog.widgets['row_qicon'+row].tooltip.str =
                    dialog.widgets['row_qsize'+row].tooltip.str = qtip;

                dialog.widgets['row_qstat'+row].onclick =
                dialog.widgets['row_qicon'+row].onclick =
                    dialog.widgets['row_qsize'+row].onclick = function() { invoke_ingame_tip('map_quarries_tip', {force:true}); };

                dialog.widgets['row_progress'+row].show = false;
                dialog.widgets['row_progress_str'+row].show = false;

                // abuse old protection/cooldown fields for Quarry info
                dialog.widgets['row_attackability'+row].text_color = SPUI.default_text_color;
                dialog.widgets['row_attackability'+row].show = true;
                if(landlord) {
                    dialog.widgets['row_attackability'+row].str = dialog.data['widgets']['row_attackability']['ui_name_owner'].replace('%s', PlayerCache.get_ui_name(landlord));
                } else {
                    dialog.widgets['row_attackability'+row].str = dialog.data['widgets']['row_attackability']['ui_name_no_owner'];
                }
                // Spy button and travel timers are updated per-frame in update_map_dialog()

            } else { // NOT quarries
                var friend = item_list[i];
                dialog.user_data['friends_on_page'].push(friend);

                // portrait
                dialog.widgets['row_portrait'+row].show = true;
                var display_name = friend.get_ui_name();
                dialog.widgets['row_portrait'+row].set_user(friend.user_id);

                var base = null;

                if(friend.is_ai()) {
                    // AI

                    // will be overridden in update_map_dialog()
                    dialog.widgets['row_portrait'+row].onclick =
                        dialog.widgets['row_name'+row].onclick = null;

                    base = gamedata['ai_bases_client']['bases'][friend.user_id.toString()];
                    if(base && 'ui_map_name' in base) {
                        display_name = base['ui_map_name']; // override normal display name
                    }
                } else {
                    // Facebook user
                    if(friend.is_real_friend) {
                        dialog.widgets['row_portrait'+row].onclick =
                            dialog.widgets['row_name'+row].onclick = (function (fr) { return function() { invoke_player_info_dialog_facebook_friend(fr); }; })(friend);
                    } else {
                        dialog.widgets['row_portrait'+row].onclick =
                            dialog.widgets['row_name'+row].onclick = (function (fr) { return function() { invoke_player_info_dialog_rival(fr); }; })(friend);
                    }
                }

                // name/level/battles
                dialog.widgets['row_name'+row].show = true;
                dialog.widgets['row_name'+row].str = display_name;

                dialog.widgets['row_info_button'+row].show = false;

                if(base && gamedata['client']['map_dialog_battle_stars_column'] && ('ui_battle_stars_key' in base)) {
                    dialog.widgets['row_ai_difficulty'+row].show =
                        dialog.widgets['row_level'+row].show = false;
                    for(var h = 0; h < dialog.data['widgets']['row_star_holes']['array'][0]; h++) {
                        var star_count = player.history[base['ui_battle_stars_key']] || 0;
                        dialog.widgets[SPUI.get_array_widget_name('row_stars', dialog.data['widgets']['row_stars']['array'], [h,row])].show = (h < star_count);
                        dialog.widgets[SPUI.get_array_widget_name('row_star_holes', dialog.data['widgets']['row_star_holes']['array'], [h,row])].show = true;
                    }
                    // add the level number to the display name, since we're hiding the normal level display
                    dialog.widgets['row_name'+row].str += ' (L'+friend.get_player_level().toString()+')';

                } else {
                    dialog.widgets['row_level'+row].show = true;
                    dialog.widgets['row_level'+row].str = dialog.data['widgets']['row_level']['ui_name'].replace('%s', friend.get_player_level().toString());

                    var level_color = SPUI.default_text_color, show_difficulty = false;
                    if(friend.is_ai() && player.get_any_abtest_value('map_dialog_ai_difficulty', gamedata['client']['map_dialog_ai_difficulty'])) {
                        var difficulty = friend.classify_ai_difficulty();
                        if(difficulty) {
                            show_difficulty = true;
                            dialog.widgets['row_ai_difficulty'+row].str = dialog.data['widgets']['row_ai_difficulty']['ui_name_'+difficulty];
                            var COLOR_MAP = {'easy': SPUI.good_text_color,
                                             'medium': SPUI.warning_text_color,
                                             'hard': SPUI.error_text_color,
                                             'monstrous': SPUI.error_text_color,
                                             'extreme': SPUI.error_text_color};
                        level_color = COLOR_MAP[difficulty];
                            dialog.widgets['row_ai_difficulty'+row].text_color = level_color;
                        }
                    }
                    dialog.widgets['row_ai_difficulty'+row].show = show_difficulty;
                    dialog.widgets['row_level'+row].text_color = level_color;
                }

                dialog.widgets['row_qsize'+row].show = false;
                dialog.widgets['row_qicon'+row].show = false;
                dialog.widgets['row_qstat'+row].show = false;

                dialog.widgets['row_progress'+row].show = false;
                dialog.widgets['row_progress_str'+row].show = false;
                if(friend.is_ai()) {
                    if(base && ('ui_progress' in base)) {
                        // hide level/difficulty display
                        dialog.widgets['row_level'+row].show = false;
                        dialog.widgets['row_ai_difficulty'+row].show = false;

                        dialog.widgets['row_progress'+row].show = true;
                        dialog.widgets['row_progress_str'+row].show = true;
                        dialog.widgets['row_progress'+row].progress = base['ui_progress']['cur']/base['ui_progress']['max'];
                        if(base['ui_progress']['cur'] >= base['ui_progress']['max']) {
                            dialog.widgets['row_progress'+row].full_color = SPUI.make_colorv(dialog.data['widgets']['row_progress']['full_color_complete']);
                            dialog.widgets['row_progress_str'+row].str = dialog.data['widgets']['row_progress_str']['ui_name_complete'];
                        } else {
                            dialog.widgets['row_progress'+row].full_color = SPUI.make_colorv(dialog.data['widgets']['row_progress']['full_color']);
                            dialog.widgets['row_progress_str'+row].str = dialog.data['widgets']['row_progress_str']['ui_name'].replace('%cur', base['ui_progress']['cur'].toString()).replace('%max', base['ui_progress']['max'].toString());
                        }
                    }

                    if(base && ('ui_info_url' in base)) {
                        var info_url = eval_cond_or_literal(base['ui_info_url'], player, null);
                        if(info_url) {
                            var opener = (function (_info_url) { return function() {
                                var handle = window.open(_info_url, '_blank');
                                if(handle) { handle.focus(); }
                            }; })(info_url);

                            // "?" Info button and level display are mutually exclusive
                            dialog.widgets['row_info_button'+row].show = true;
                            dialog.widgets['row_level'+row].show = false;
                            dialog.widgets['row_ai_difficulty'+row].show = false;
                            dialog.widgets['row_info_button'+row].onclick = opener;

                            // also link portrait and name to the URL
                            dialog.widgets['row_portrait'+row].onclick =
                                dialog.widgets['row_name'+row].onclick = opener;
                        }
                    }

                    if(base && ('challenge_icon' in base)) {
                        dialog.widgets['row_challenge_icon'+row].show = true;
                        dialog.widgets['row_challenge_icon'+row].asset = base['challenge_icon'];
                    }
                }

                dialog.widgets['row_travel0'+row].show = false;
                dialog.widgets['row_travel1'+row].show = false;

                // if player is still in the tutorial, disable irrelevant buttons
                if(player.tutorial_state != 'COMPLETE') {
                    if(chapter != 'computers' || row != 0) {
                        dialog.widgets['row_button'+row].state = 'disabled';
                    }
                }
            } // END not quarries

            row += 1;
        }
    } else {
        // no friends in the list
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(0).toString()).replace('%d2',(0).toString()).replace('%d3',(0).toString());
    }

    // clear out empty rows
    while(row < rows_per_page) {
        dialog.widgets['row_bg'+row].show =
            dialog.widgets['row_portrait'+row].show =
            dialog.widgets['row_portrait_outline'+row].show =
            dialog.widgets['row_name'+row].show =
            dialog.widgets['row_level'+row].show =
            dialog.widgets['row_challenge_icon'+row].show =
            dialog.widgets['row_ai_difficulty'+row].show =
            dialog.widgets['row_info_button'+row].show =
            dialog.widgets['row_qsize'+row].show =
            dialog.widgets['row_qicon'+row].show =
            dialog.widgets['row_qstat'+row].show =
            dialog.widgets['row_travel0'+row].show =
            dialog.widgets['row_travel1'+row].show =
            dialog.widgets['row_progress'+row].show =
            dialog.widgets['row_progress_str'+row].show =
            dialog.widgets['row_button'+row].show = false;
        for(var h = 0; h < dialog.data['widgets']['row_star_holes']['array'][0]; h++) {
            dialog.widgets[SPUI.get_array_widget_name('row_stars', dialog.data['widgets']['row_stars']['array'], [h,row])].show = false;
            dialog.widgets[SPUI.get_array_widget_name('row_star_holes', dialog.data['widgets']['row_star_holes']['array'], [h,row])].show = false;
        }
        row += 1;
    }

    // set clickability of scroll arrows
    if(page != 0) {
        dialog.widgets['scroll_left'].state = 'normal';
    } else {
        dialog.widgets['scroll_left'].state = 'disabled';
    }

    if(page < (chapter_pages-1)) {
        dialog.widgets['scroll_right'].state = 'normal';
    } else {
        dialog.widgets['scroll_right'].state = 'disabled';
    }

    dialog.widgets['scroll_left'].onclick = function(w) { map_dialog_change_page(w.parent, w.parent.user_data['chapter'], w.parent.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function(w) { map_dialog_change_page(w.parent, w.parent.user_data['chapter'], w.parent.user_data['page']+1); };

    // disable irrelevant buttons during tutorial
    if(player.tutorial_state != "COMPLETE") {
        dialog.widgets['scroll_left'].state =
            dialog.widgets['scroll_right'].state = 'disabled';
    }
}

function invoke_fullscreen_instructions() {
    player.record_feature_use('fullscreen_dialog');
    change_selection(null);
    var dialog = new SPUI.Dialog(gamedata['dialogs']['fullscreen_instructions']);
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['flavor'].str = gamedata['strings']['fullscreen_instructions_flavor_text'];
    dialog.widgets['ok_button'].onclick =
        dialog.widgets['close_button'].onclick = function() { change_selection_ui(null); };
    if(spin_demographics['browser_OS'] === "Mac") {
        dialog.widgets['os'].str = dialog.data['widgets']['os']['ui_name'].replace('%s', 'Mac');
        dialog.widgets['key'].str = '\u2318-Shift-F'; // Unicode for Mac command key
    } else if(spin_demographics['browser_OS'] === "Windows") {
        dialog.widgets['os'].str = dialog.data['widgets']['os']['ui_name'].replace('%s', 'Windows');
        dialog.widgets['key'].str = 'F11';
    } else {
        change_selection_ui(null);
    }
    return dialog;
}

function invoke_daily_tip_pages(tiplist) {
    if(tiplist.length < 1) { return null; }
    var dialog = new SPUI.Dialog(gamedata['dialogs']['daily_tip_pageable']);
    dialog.user_data['dialog'] = 'daily_tip_pageable';
    dialog.user_data['tiplist'] = tiplist;
    dialog.user_data['idx'] = -1;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['next_button'].onclick = function(w) {
        var _dialog = w.parent;
        if(_dialog.user_data['idx']+1 >= _dialog.user_data['tiplist'].length) {
            close_parent_dialog(w);
        } else {
            daily_tip_pageable_show_tip(_dialog, _dialog.user_data['idx']+1);
        }
    };
    dialog.widgets['prev_button'].onclick = function(w) {
        var _dialog = w.parent;
        daily_tip_pageable_show_tip(_dialog, _dialog.user_data['idx']-1);
    };

    // show oldest non-understood tip
    var i;
    for(i = 0; i < tiplist.length; i++) {
        if(!tiplist[i]['understood']) { break; }
    }
    i = Math.min(i, tiplist.length-1);
    dialog.ondraw = update_daily_tip_pageable;
    daily_tip_pageable_show_tip(dialog, i);
    return dialog;
}

function daily_tip_pageable_show_tip(dialog, idx) {
    dialog.user_data['idx'] = idx;
    var tip = dialog.user_data['tiplist'][idx];
    if(!tip['understood']) {
        tip['understood'] = 1;
        send_to_server.func(["DAILY_TIP_UNDERSTOOD", tip['name'], true]);
    }

    dialog.widgets['description'].clear_text();
    if('ui_description' in tip) {
        dialog.widgets['description'].append_text(SPText.cstring_to_ablocks_bbcode(tip['ui_description']));
    }

    var image_name = ('image' in tip ? tip['image'] : gamedata['game_id']+'_pageable_generic.jpg');
    var image_url = GameArt.art_url('art/daily_tips/'+image_name, false);
    var img = new Image();
    img.src = image_url;
    dialog.widgets['picture'].raw_image = img;

    var tiplist = dialog.user_data['tiplist'];
    dialog.widgets['next_button'].state = ((idx < tiplist.length-1) ? (!tiplist[idx+1]['understood'] ? 'active' : 'normal') : 'disabled');
    //dialog.widgets['next_button'].str = dialog.data['widgets']['next_button']['ui_name'+((idx >= tiplist.length-1) ? '_close' : '')];
    dialog.widgets['prev_button'].state = (idx > 0 ? 'normal' : 'disabled');
    dialog.default_button = (dialog.widgets['next_button'].state == 'active' ? dialog.widgets['next_button'] : dialog.widgets['close_button']);
}

// this mainly just handles the link button
function update_daily_tip_pageable(dialog) {
    var idx = dialog.user_data['idx'];
    if(idx < 0 || dialog.user_data['tiplist'].length < 1) { return; }
    var tip = dialog.user_data['tiplist'][idx];

    dialog.widgets['link_button'].show = false;

    if(('link_button_url' in tip) || ('link_button_consequent' in tip) &&
       (!('link_button_show_if' in tip) || read_predicate(tip['link_button_show_if']).is_satisfied(player,null))) {
        var url = eval_cond_or_literal(tip['link_button_url'] || null, player, null);
        if(url) { url = url_put_info(url, session.user_id, player.history['money_spent']||0); }

        var cons = null, helper = null, helper_tooltip = null;
        if(tip['link_button_consequent']) {
            if('link_button_activation' in tip) {
                var pred = read_predicate(tip['link_button_activation']);
                if(pred.is_satisfied(player,null)) {
                    cons = tip['link_button_consequent'];
                } else {
                    helper_tooltip = pred.ui_describe(player);
                    helper = get_requirements_help(pred);
                    // show the tooltip even if we can't provide help
                    if(helper_tooltip && !helper) { helper = function() {}; }
                }
            } else {
                cons = tip['link_button_consequent'];
            }
        }

        if(url || cons || helper) {
            dialog.widgets['link_button'].show = true;
            if('link_button_bg_image' in tip) {
                dialog.widgets['link_button'].bg_image = tip['link_button_bg_image'];
            } else {
                dialog.widgets['link_button'].bg_image = dialog.data['widgets']['link_button']['bg_image'];
            }
            if('link_button_ui_name' in tip) {
                dialog.widgets['link_button'].str = tip['link_button_ui_name'];
            } else {
                dialog.widgets['link_button'].str = dialog.data['widgets']['link_button']['ui_name'];
            }
            dialog.widgets['link_button'].state = (cons || url) ? 'normal' : 'disabled_clickable';
            dialog.widgets['link_button'].tooltip.str = helper_tooltip;
            dialog.widgets['link_button'].onclick = (function (_url, _cons, _helper) { return function() {
                if(_url) {
                    var handle = window.open(_url, '_blank');
                    if(handle) { handle.focus(); }
                }
                if(_cons) { change_selection_ui(null); read_consequent(_cons).execute(); }
                if(_helper) { _helper(); }
            }; })(url, cons, helper);
        }
    }
}

/** @param {string} tipname
    @param {boolean=} skip_notification_queue */
function invoke_daily_tip(tipname, skip_notification_queue) {
    var tip = null;
    for(var i = 0; i < gamedata['daily_tips'].length; i++) {
        var t = gamedata['daily_tips'][i];
        if(t['name'] == tipname) {
            tip = t;
            break;
        }
    }
    if(!tip) { console.log('daily tip '+tipname+' not found!'); return; }
    if(tip['kind'] == 'pageable') { return invoke_daily_tip_pages([tip]); } // for testing only
    if('consequent' in tip) {
        // new-style pure consequent
        read_consequent(tip['consequent']).execute({'daily_tip': tip['name']});
        return;
    }

    // load img asynchronously and display when ready
    var img = new Image();

    var complete_cb = (function (_tip, _img) { return function() {
        var dialog = new SPUI.Dialog(gamedata['dialogs']['daily_tip']);
        dialog.user_data['dialog'] = 'daily_tip';
        install_child_dialog(dialog);
        dialog.auto_center();
        dialog.modal = true;
        dialog.widgets['picture'].raw_image = _img;
        var go_away = function (_name, _ack, _url, _cons) { return function(widget) {
            send_to_server.func(["DAILY_TIP_UNDERSTOOD", _name, _ack]);
            close_parent_dialog(widget);
            if(_url) {
                var handle = window.open(_url, '_blank');
                if(handle) { handle.focus(); }
            }
            if(_cons) {
                read_consequent(_cons).execute();
            }
        }; };
        dialog.widgets['close_button'].onclick = go_away(_tip['name'], false, null, null);
        dialog.widgets['ok_button'].onclick = go_away(_tip['name'], true,
                                                      ('understood_button_url' in _tip ?
                                                       url_put_info(_tip['understood_button_url'], session.user_id, player.history['money_spent'] || 0) : null),
                                                      tip['understood_button_consequent'] || null);

        if('sound' in _tip) {
            GameArt.assets[_tip['sound']].states['normal'].audio.play(client_time);
        }
        if('alloy_bonus_hack' in _tip) {
            var data = _tip['alloy_bonus_hack'];
            dialog.widgets['alloy_bonus'].show = data['enable'];
            dialog.widgets['alloy_bonus'].str = dialog.data['widgets']['alloy_bonus']['ui_name'].replace('%d', Store.display_user_currency_amount(player.get_any_abtest_value('free_gamebucks_veteran',
                                                                                                                                                                              gamedata['starting_conditions']['veteran_gamebucks']), 'full'));
        }
        if(('link_button_url' in _tip) || ('link_button_consequent' in _tip)) {

            var url = eval_cond_or_literal(_tip['link_button_url'], player, null);
            if(url) { url = url_put_info(url, session.user_id, player.history['money_spent']||0) }
            var cons = (_tip['link_button_consequent'] || null);
            if(url || cons) {
                dialog.widgets['link_button'].show = true;
                dialog.widgets['link_button'].xy = _tip['link_button_xy'];
                if('link_button_bg_image' in _tip) { dialog.widgets['link_button'].bg_image = _tip['link_button_bg_image']; }
                if('link_button_ui_name' in _tip) {
                    dialog.widgets['link_button'].str = _tip['link_button_ui_name'];
                }
                dialog.widgets['link_button'].onclick = (function (_url, _cons) { return function() {
                    if(_url) {
                        var handle = window.open(_url, '_blank');
                        if(handle) { handle.focus(); }
                    }
                    if(_cons) { change_selection_ui(null); read_consequent(_cons).execute(); }
                }; })(url, cons);
            }
        }
        apply_dialog_hacks(dialog, _tip);
    }; })(tip, img);

    img.onload = (function (cb, _skip_notification_queue) {
        return function() {
            if (!_skip_notification_queue) {
                notification_queue.push(cb);
            } else {
                cb();
            }
        };
    })(complete_cb, skip_notification_queue || false);
    img.src = GameArt.art_url('art/daily_tips/'+tip['image'], false);
}

// common function used by daily tips and AI base completion Consequents (DISPLAY_MESSAGE)
// to apply widget hacks to the dialog
/** @param {SPUI.Dialog} dialog
    @param {Object} _tip
    @param {Object=} consequent_context */
function apply_dialog_hacks(dialog, _tip, consequent_context) {
    dialog.user_data['consequent_context'] = consequent_context || null;
    if('sunken_asset' in _tip) {
        dialog.widgets['sunken'].asset = _tip['sunken_asset'];
    }
    if('picture_asset' in _tip) {
        dialog.widgets['picture'].asset = _tip['picture_asset'];
    }
    if('inset_picture' in _tip) {
        dialog.widgets['inset_picture'].show = true;
        dialog.widgets['inset_picture'].asset = _tip['inset_picture'];
        if('inset_picture_xy' in _tip) { dialog.widgets['inset_picture'].xy = _tip['inset_picture_xy']; }
        if('inset_picture_dimensions' in _tip) { dialog.widgets['inset_picture'].wh = _tip['inset_picture_dimensions']; }
    }
    if('unit_icon' in _tip) {
        var spec = gamedata['units'][_tip['unit_icon']] || gamedata['buildings'][_tip['unit_icon']] || null;
        if(spec) {
            dialog.widgets['unit_icon'].show = true;
            dialog.widgets['unit_icon'].asset = get_leveled_quantity(spec['art_asset'], 1);
        }
        if('unit_icon_xy' in _tip) { dialog.widgets['unit_icon'].xy = _tip['unit_icon_xy']; }
    }

    if('understood_button_xy' in _tip) {
        dialog.widgets['ok_button'].xy = _tip['understood_button_xy'];
    }
    if('understood_button_ui_name' in _tip) {
        dialog.widgets['ok_button'].str = _tip['understood_button_ui_name'];
    }
    if('understood_button_bg_image' in _tip) {
        dialog.widgets['ok_button'].bg_image = _tip['understood_button_bg_image'];
    }

    if('understood_button_onclick' in _tip) {
        var old_cb = dialog.widgets['ok_button'].onclick;
        var new_cb = null;
        if(_tip['understood_button_onclick'] == 'invoke_curiosity_research') {
            new_cb = function(w) {
                invoke_upgrade_tech_dialog('curiosity_production', null);
            };
        } else if(_tip['understood_button_onclick'] == 'invoke_store_specials') {
            new_cb = function(w) {
                invoke_store('specials');
            };
        }
        if(new_cb) {
            dialog.widgets['ok_button'].onclick = (function (_new, _old) { return function(w) {
                _old(w);
                _new(w);
            }; })(new_cb, old_cb);
        }
    }
    if('event_video_hack' in _tip && _tip['event_video_hack']['enable']) {
        var hack = _tip['event_video_hack'];
        if(!hack['show_if'] || read_predicate(hack['show_if']).is_satisfied(player, null)) {
            var old_cb = dialog.widgets['ok_button'].onclick;
            var new_cb = (function (_old_cb, _hack) { return function(w) {
                _old_cb(w);
                // create a fake dialog underneath the video widget just for the modal background-darkening effect
                var dialog = new SPUI.Dialog(gamedata['dialogs']['null_dialog']);
                dialog.transparent_to_mouse = true;
                dialog.auto_center();
                dialog.modal = true;
                change_selection_ui(dialog);
                var close_cb = (function (_dialog) { return function() { change_selection_ui(null); }; })(dialog);
                SPVideoWidget.init(SPVideoWidget.make_youtube_url(_hack['youtube_id']), close_cb);
            }; })(old_cb, hack);
            var wname = hack['widget'] || 'ok_button';
            dialog.widgets[wname].onclick = new_cb;
        }
    }
    if('ui_description' in _tip) {
        dialog.widgets['description'].show = true;
        if('description_xy' in _tip) { dialog.widgets['description'].xy = _tip['description_xy']; }
        if('description_dimensions' in _tip) { dialog.widgets['description'].wh = _tip['description_dimensions']; }
        dialog.widgets['description'].set_text_with_linebreaking(_tip['ui_description']);
    }
    if('event_countdown_hack' in _tip && _tip['event_countdown_hack']['enable']) {
        var hack = _tip['event_countdown_hack'];
        dialog.widgets['event_countdown'].show = 1;
        if('ui_title' in hack) { dialog.widgets['event_countdown_title'].str = hack['ui_title']; }
        if('ui_value' in hack) {
            dialog.widgets['event_countdown'].str = hack['ui_value'];
        } else {
            var time_to_print;
            if(hack['reset_origin_time']) {
                // count down to end of current repetition interval
                var now = player.get_absolute_time();
                var this_period_end = ((Math.floor( (now - hack['reset_origin_time']) / hack['reset_interval'] ) + 1) * hack['reset_interval']) + hack['reset_origin_time'];
                time_to_print = (this_period_end - now);
            } else {
                // count down to start or end of event
                time_to_print = -player.get_event_time(hack['event_kind'] || 'current_event', hack['event_name'], hack['method'], true);
            }
            var ui_name = hack['ui_name'] || dialog.data['widgets']['event_countdown']['ui_name'];
            dialog.widgets['event_countdown'].str = ui_name.replace('%s', do_pretty_print_time(time_to_print, 2, true));
        }
        if('xy' in hack) { dialog.widgets['event_countdown'].xy = hack['xy']; }
        if('dimensions' in hack) { dialog.widgets['event_countdown'].wh = hack['dimensions']; }
        if('text_size' in hack) { dialog.widgets['event_countdown'].font = SPUI.make_font(hack['text_size'], hack['text_size']+3, hack['text_style'] || 'bold'); }
        if('text_color' in hack) { var col = hack['text_color']; dialog.widgets['event_countdown'].text_color = new SPUI.Color(col[0], col[1], col[2], col[3]); }
        if('text_hjustify' in hack) { dialog.widgets['event_countdown'].text_hjustify = hack['text_hjustify']; }
    }
    if('event_victories_hack' in _tip && _tip['event_victories_hack']['enable']) {
        var hack = _tip['event_victories_hack'];
        dialog.widgets['event_victories'].show =
            dialog.widgets['event_victories_bar'].show = 1;
        var cur = player.history[hack['history_key']] || 0;
        dialog.widgets['event_victories'].str = dialog.data['widgets']['event_victories']['ui_name'].replace('%d1', pretty_print_number(cur)).replace('%d2', pretty_print_number(hack['max']));
        dialog.widgets['event_victories_bar'].progress = cur/hack['max'];
    }
    if('logged_in_times_hack' in _tip && _tip['logged_in_times_hack']['enable']) {
        var hack = _tip['logged_in_times_hack'];
        dialog.widgets['logged_in_times'].show = true;
        var cur;
        if('number' in hack) {
            cur = hack['number'];
        } else {
            cur = player.history['logged_in_times'] || 0;
        }
        dialog.widgets['logged_in_times'].str = dialog.data['widgets']['logged_in_times']['ui_name_'+(cur==1?'one':'many')].replace('%d', cur.toString());
    }
    if('showcase_hack' in _tip) {
        Showcase.apply_showcase_hacks(dialog, _tip['showcase_hack']);
    }
}

// these are not daily tips, but small one-time GUI messages that pop up for certain actions
/** @param {string} name
    @param {Object=} options */
function invoke_ingame_tip(name, options) {
    if(!options) { options = {}; }
    if(!player.check_feature_use(name) || options.force) {
        player.record_feature_use(name);
        var tip = gamedata['strings'][name];

        var dialog_options = options.dialog_options || {};
        dialog_options['dialog'] = options.dialog || 'message_dialog_big';
        var descr = tip['ui_description'];
        if(options.replacements) {
            for(var k in options.replacements) {
                descr = descr.replace(k, options.replacements[k]);
            }
        }
        var dialog = invoke_child_message_dialog(tip['ui_title'], descr, dialog_options);

        if(tip['unit_icon']) {
            var spec = gamedata['units'][tip['unit_icon']] || gamedata['buildings'][tip['unit_icon']] || null;
            if(spec) {
                dialog.widgets['unit_icon'].show = true;
                dialog.widgets['unit_icon'].asset = get_leveled_quantity(spec['art_asset'], 1);
            }
        }
        return dialog;
    }
    return null;
}

function invoke_ingame_tip_force(name) { return invoke_ingame_tip(name, {force:true}); }

player.get_absolute_time = function() {
    var cur_time;
    var time_override = get_query_string('event_time_override');
    if(time_override) {
        cur_time = parseInt(time_override,10);
    } else {
        cur_time = server_time;
    }
    return cur_time;
};

// these are caches derived from immutable (after A/B test patching) gamedata
// for speeding up searches for events

/** @type {?Array.<Object>} */
player.event_list_cache = null;

/** Speed up lookups of events by name
    @type {?Object.<string, Array.<Object>>} */
player.event_list_cache_index = null;

/** @param {string} event_kind
    @param {string|null} event_name
    @param {number} ref_time
    @param {boolean=} ignore_activation */
player.get_event = function(event_kind, event_name, ref_time, ignore_activation) {
    if(!goog.array.contains(['current_event','current_event_store','facebook_sale',
                             'current_stat_tournament',
                             'current_trophy_pve_challenge','current_trophy_pvp_challenge'], event_kind)) {
        throw Error('unhandled event_kind '+event_kind);
    }
    if(player.isolate_pvp && (event_kind.indexOf('trophy') != -1)) { return null; }

    if(player.event_list_cache === null) {
        player.event_list_cache = gamedata['event_schedule'].concat(player.get_any_abtest_value('event_schedule', []));
        player.event_list_cache_index = {};
        goog.array.forEach(player.event_list_cache, function(entry) {
            var name = entry['name'];
            if(!(name in player.event_list_cache_index)) {
                player.event_list_cache_index[name] = [];
            }
            player.event_list_cache_index[name].push(entry);
        });
    }

    var event_list;
    if(event_name) { // restrict lookups to events with matching name
        event_list = player.event_list_cache_index[event_name] || [];
    } else {
        event_list = player.event_list_cache;
    }
    if(!event_list) { throw Error('bad event_list'); }

    for(var i = 0; i < event_list.length; i++) {
        var entry = event_list[i];
        var data = gamedata['events'][entry['name']] || null;
        if(!data) { continue; }
        if(!('kind' in data) || (data['kind'] != event_kind)) { continue; }
        if(entry['end_time'] <= ref_time) { continue; }
        if(entry['start_time'] > ref_time) { continue; }
        if(event_name && (entry['name'] != event_name)) { continue; }
        if(!ignore_activation) {
            if(('activation' in entry) && !read_predicate(entry['activation']).is_satisfied(player, null)) { continue; }
            if(('activation' in data) && !read_predicate(data['activation']).is_satisfied(player, null)) { continue; }
        }
        return entry;
    }

    return null;
};

/** @param {string} event_kind
    @param {string|null} event_name
    @param {string} method
    @param {boolean=} ignore_activation
    @param {number=} t_offset */
player.get_event_time = function(event_kind, event_name, method, ignore_activation, t_offset) {
    if(typeof t_offset == 'undefined') { t_offset = 0; }
    var cur_time = player.get_absolute_time() + t_offset;
    var event_data = player.get_event(event_kind, event_name, cur_time, ignore_activation);
    if(!event_data) { return null; }

    if(method === 'start') {
        return cur_time - event_data['start_time'];
    } else if(method === 'end') {
        return cur_time - event_data['end_time'];
    } else if(method === 'inprogress') {
        return (cur_time >= event_data['start_time'] && cur_time < event_data['end_time']);
    } else if(method === 'enabled') {
        return true;
    } else {
        throw Error('unknown method '+method);
    }
};

// returns the event_schedule entry
player.current_stat_tournament = function() {
    return player.get_event('current_stat_tournament', null, player.get_absolute_time(), false);
};

// returns the events entry
player.current_stat_tournament_event = function() {
    var sched = player.current_stat_tournament();
    if(sched) {
        return gamedata['events'][sched['name']];
    } else {
        return null;
    }
};

// returns the events entry
player.current_alliance_stat_tournament_event = function() {
    // do not return the event if its "alliance" setting is false
    var event = player.current_stat_tournament_event();
    if(event &&
       (!('alliance' in event) || event['alliance'])) {
        return event;
    }
    return null;
};

// returns the event_schedule entry
player.current_alliance_stat_tournament = function() {
    if(player.current_alliance_stat_tournament_event()) {
        return player.current_stat_tournament();
    }
    return null;
};

function display_trophy_count(raw, trophy_type) {
    var offset;
    if(trophy_type in gamedata['trophy_display_offset']) {
        offset = gamedata['trophy_display_offset'][trophy_type];
    } else {
        console.log('unknown trophy_type '+trophy_type.toString());
        offset = 0;
    }
    return raw+offset;
}

player.get_current_trophy_challenge_name = function(kind) {
    var entry = player.get_event(kind, null, player.get_absolute_time());
    if(entry) { return entry['name']; }
    return null;
};
player.current_trophy_pve_challenge_name = function() { return player.get_current_trophy_challenge_name('current_trophy_pve_challenge'); };
player.current_trophy_pvp_challenge_name = function() { return player.get_current_trophy_challenge_name('current_trophy_pvp_challenge'); };
player.current_trophy_challenge_name = function() {
    var ret = player.current_trophy_pvp_challenge_name();
    if(ret) { return ret; }
    return player.current_trophy_pve_challenge_name();
};

player.get_current_trophy_challenge_togo = function(kind) {
    var event_name = player.get_current_trophy_challenge_name(kind);
    if(event_name && player.get_event_time(kind, event_name, 'inprogress')) {
        var togo = -player.get_event_time(kind, event_name, 'end');
        return togo;
    }
    return -1;
};

player.current_trophy_pve_challenge_togo = function() { return player.get_current_trophy_challenge_togo('current_trophy_pve_challenge'); };
player.current_trophy_pvp_challenge_togo = function() { return player.get_current_trophy_challenge_togo('current_trophy_pvp_challenge'); };
player.current_trophy_challenge_togo = function() {
    var ret = player.current_trophy_pvp_challenge_togo();
    if(ret >= 0) { return ret; }
    return player.current_trophy_pve_challenge_togo();
};

player.use_trophies = function() {
    return (player.get_any_abtest_value('enable_trophy_ui', gamedata['client']['enable_trophy_ui']) &&
            (player.current_trophy_challenge_togo() >= 0));
};

player.current_trophy_type = function() {
    if(player.current_trophy_pvp_challenge_togo() >= 0) {
        return 'pvp';
    } else if(player.current_trophy_pve_challenge_togo() >= 0) {
        return 'pve';
    }
    return null;
};


function invoke_sprobe_dialog() {
    player.record_feature_use('sprobe_dialog');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['sprobe_dialog']);
    dialog.user_data['dialog'] = 'sprobe_dialog';
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.user_data['sprobes'] = []
    for(var i = 0; i < dialog.data['widgets']['result']['array'][0]; i++) {
        var on_finish = (function (_dialog, next_i) { return function() {
            if(_dialog.is_visible() && next_i < _dialog.user_data['sprobes'].length) {
                _dialog.user_data['sprobes'][next_i].go();
            }
        }; })(dialog, i+1);
        dialog.widgets['trial_label'+i.toString()].str = dialog.data['widgets']['trial_label']['ui_name'].replace('%d', (i+1).toString());
        dialog.user_data['sprobes'].push(sprobe_init(on_finish));
    }
    dialog.widgets['close_button'].onclick = dialog.widgets['dismiss_button'].onclick = close_parent_dialog;
    // note: obfuscate the string a bit
    dialog.widgets['your_gameapi_url'].str = dialog.data['widgets']['your_gameapi_url']['ui_name'].replace('%s', gameapi_url().replace('.com','').replace('http','').replace('GAMEAPI','').replace('//','').replace('/','')).replace('%method', gameapi_connection_method());
    if(longpoll_error_count >= 4) {
        dialog.widgets['longpoll_error'].show = 1;
    }
    dialog.widgets['warning_label'].append_text(SPText.cstring_to_ablocks_bbcode(dialog.data['widgets']['warning_label']['ui_name_bbcode']));

    var probe = dialog.user_data['sprobes'][0];
    goog.array.forEach(dialog.data['widgets']['description']['tests'], function(test, n) {
        dialog.widgets['description'+n.toString()].str = test['ui_name'];
    });
    probe.go();
    dialog.ondraw = update_sprobe_dialog;
    return dialog;
}

function update_sprobe_dialog(dialog) {
    dialog.widgets['your_framerate'].str = dialog.data['widgets']['your_framerate']['ui_name'].replace('%s', fps_counter.cur_fps.toFixed(1));

    for(var col = 0; col < dialog.data['widgets']['result']['array'][0]; col++) {
        var probe = dialog.user_data['sprobes'][col];
        for(var n = 0; n < dialog.data['widgets']['description']['tests'].length; n++) {
            var test = dialog.data['widgets']['description']['tests'][n];
            var w = dialog.widgets['result'+col.toString()+','+n.toString()];
            var kind = 'unsup', s = '';
            if(test['name'] in probe.tests) {
                var x = probe.tests[test['name']];
                if(x.state == SProbe.TestState.INIT) {
                    kind = 'init';
                } else if(x.state == SProbe.TestState.PENDING) {
                    kind = 'pending';
                } else if(x.state == SProbe.TestState.DONE) {
                    if(x.result['result'] == 'ok') {
                        kind = 'ok'; s = '';
                        if('ping' in x.result) {
                            if(x.result['ping'] >= dialog.data['widgets']['result']['ping_warn_threshold']) {
                                kind = 'warn';
                            }
                            s = (1000.0*x.result['ping']).toFixed(0) + 'ms';
                        }
                    } else {
                        if(x.result['error'] == 'timeout') {
                            kind = 'timeout';
                        } else {
                            kind = 'error'; s = x.result['error'];
                        }
                    }
                }
            }
            w.str = dialog.data['widgets']['result']['ui_name_'+kind].replace('%s', s);
            w.text_color = SPUI.make_colorv(dialog.data['widgets']['result']['text_color_'+kind]);
        }
    }
}

function invoke_settings_dialog() {
    player.record_feature_use('settings_dialog');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['settings_dialog']);
    dialog.user_data['dialog'] = 'settings_dialog';
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['preferences'] = {};
    for(var key in player.preferences) {
        dialog.user_data['preferences'][key] = player.preferences[key];
    }
    dialog.user_data['requires_reload'] = false;

    dialog.widgets['sprobe_button'].onclick = function() { invoke_sprobe_dialog(); };

    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    dialog.widgets['apply_button'].onclick = function(w) {
        var dialog = w.parent;
        if(!dialog) { return; }

        dialog.widgets['apply_button'].state = 'disabled';
        dialog.widgets['apply_button'].str = dialog.data['widgets']['apply_button']['ui_name_applying'];

        send_to_server.func(["UPDATE_PREFERENCES", dialog.user_data['preferences']]);

        if(dialog.user_data['requires_reload']) {
            flush_message_queue(true);
            window.setTimeout(function() { reload_game(); }, 1000);
        } else {
            var requires_recensor = false;
            if(global_chat_frame &&
               (get_preference_setting(dialog.user_data['preferences'], 'chat_filter') !=
                get_preference_setting(player.preferences, 'chat_filter'))) {
                requires_recensor = true
            }

            player.preferences = dialog.user_data['preferences'];
            change_selection(null);

            if(requires_recensor) {
                recensor_chat_frame(global_chat_frame);
            }
        }
    };
    dialog.widgets['apply_button'].state = 'disabled';

    var settings = gamedata['strings']['settings'];
    dialog.user_data['settings'] = [];
    var row = 0;
    for(var name in settings) {
        var data = settings[name];
        if('show_if' in data && !read_predicate(data['show_if']).is_satisfied(player, true)) {
            continue;
        }
        dialog.user_data['settings'].push(data);
        dialog.widgets['description'+row].str = data['ui_description'];
        for(var c = 0; c < 2; c++) {
            var choice = data['choices'][c];
            dialog.widgets['choice'+c+','+row].str = choice['ui_name'];
            dialog.widgets['choice'+c+','+row].tooltip.str = choice['ui_tooltip'];
            dialog.widgets['choice'+c+','+row].onclick = (function (_dialog, _data, _choice) { return function() {
                _dialog.user_data['preferences'][_data['preference_key']] = _choice['preference_val'];
                _dialog.user_data['requires_reload'] |= !!_data['requires_reload'];
                //console.log('set '+_data['preference_key']+' to '+_choice['preference_val']);

                dialog.widgets['apply_button'].state = 'normal';
            }; })(dialog, data, choice);
        }
        if('help_url' in data) {
            dialog.widgets['help'+row].show = true;
            dialog.widgets['help'+row].onclick = (function (_data) { return function(w) {
                var handle = window.open(_data['help_url'], '_blank');
                if(handle) { handle.focus(); }
            }; })(data);
        }
        row += 1;
    }
    // blank out unused entries
    while(row < dialog.data['widgets']['separator']['array'][1]) {
        dialog.widgets['separator'+row].show =
            dialog.widgets['description'+row].show = false;
        for(var c = 0; c < 2; c++) {
            dialog.widgets['choice'+c+','+row].show = false;
        }
        row += 1;
    }
    dialog.ondraw = update_settings_dialog;
    return dialog;
}

// get the value of a player-controllable preference setting
// @param {object} prefs The dictionary of current preferences (usually player.preferences)
// @param {string} pref_name Name of an entry in gamedata['strings']['settings']
// order of precedence:
// manual setting >> A/B test >> default value from gamedata_main.json
function get_preference_setting(prefs, pref_name) {
    var data = gamedata['strings']['settings'][pref_name];
    if(data['preference_key'] in prefs) {
        return prefs[data['preference_key']];
    }
    if('abtest_key' in data) {
        var UNSET = -999;
        var val = player.get_any_abtest_value(data['abtest_key'], UNSET);
        if(val !== UNSET) { return val; }
    }

    // use default value
    return eval_cond_or_literal(data['default_val'], player, null);
}

function update_settings_dialog(dialog) {
    var settings = dialog.user_data['settings'];
    for(var row = 0; row < settings.length; row++) {
        var data = settings[row];
        var enabled = ('enable_if' in data ? read_predicate(data['enable_if']).is_satisfied(player, null) : true);
        dialog.widgets['coverup'+row].show = !enabled;
        var cur_value = get_preference_setting(dialog.user_data['preferences'], data['name']);
        for(var c = 0; c < 2; c++) {
            var choice = data['choices'][c];
            var choice_selected = (cur_value == choice['preference_val']);
            dialog.widgets['choice'+c+','+row].state = (choice_selected ? 'active' : 'normal');
        }
    }
}

function invoke_keyboard_shortcuts() {
    player.record_feature_use('keyboard_shortcuts_list');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['keyboard_shortcuts']);
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.user_data['page'] = 0;
    // array of bbcode text to display (one string per page)
    dialog.user_data['text'] = dialog.data['widgets']['shortcut_text'][player.unit_micro_enabled() ? 'bbcode_pages' : 'bbcode_pages_nomicro'];

    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    if(gamedata['strings']['keyboard_shortcuts_help_url']) {
        dialog.widgets['link_button'].onclick = (function (_url) { return function() {
            var newWindow = window.open(_url, '_blank');
            if(newWindow) { newWindow.focus(); }
        }; })(gamedata['strings']['keyboard_shortcuts_help_url']);
    } else {
        dialog.widgets['link_button'].show = false;
    }

    dialog.widgets['prev_button'].show = dialog.widgets['next_button'].show = (dialog.user_data['text'].length > 1);
    dialog.widgets['prev_button'].onclick = function (w) {
        var dialog = w.parent; if(!dialog) { return; }
        keyboard_shortcuts_change_page(dialog, dialog.user_data['page']-1);
    };
    dialog.widgets['next_button'].onclick = function (w) {
        var dialog = w.parent; if(!dialog) { return; }
        keyboard_shortcuts_change_page(dialog, dialog.user_data['page']+1);
    };

    keyboard_shortcuts_change_page(dialog, 0);
    dialog.ondraw = keyboard_shortcuts_update;
    return dialog;
}
function keyboard_shortcuts_change_page(dialog, page) {
    dialog.user_data['page'] = Math.min(Math.max(page, 0), dialog.user_data['text'].length-1);
    dialog.widgets['shortcut_text'].clear_text();
    dialog.widgets['shortcut_text'].append_text(SPText.cstring_to_ablocks_bbcode(dialog.user_data['text'][dialog.user_data['page']]));
}
function keyboard_shortcuts_update(dialog) {
    dialog.widgets['prev_button'].state = (dialog.user_data['page'] > 0 ? 'normal' : 'disabled');
    dialog.widgets['next_button'].state = (dialog.user_data['page'] < 1 ? 'normal' : 'disabled');
}

function invoke_region_map_help() {
    player.record_feature_use('region_map_help');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['region_map_help']);
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    var s = dialog.data['widgets']['description']['ui_name_bbcode'];
    for(var res in gamedata['resources']) {
        s = s.replace('%'+res.toUpperCase(), gamedata['resources'][res]['ui_name']);
    }
    dialog.widgets['description'].append_text(SPText.cstring_to_ablocks_bbcode(s));
    return dialog;
}

function invoke_army_dialog_help() {
    player.record_feature_use('army_dialog_help');
    var dialog = new SPUI.Dialog(gamedata['dialogs']['army_dialog_help']);
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['description'].append_text(SPText.cstring_to_ablocks_bbcode(dialog.data['widgets']['description']['ui_name_bbcode']));
    return dialog;
}

function invoke_cc_upgrade_info() { return do_invoke_cc_upgrade_dialog('info'); }
function invoke_cc_upgrade_congrats() { return do_invoke_cc_upgrade_dialog('congrats'); }
function do_invoke_cc_upgrade_dialog(mode) {
    var cc = find_object_by_type(gamedata['townhall']);
    if(!cc) { return null; }
    var level;
    if(mode == 'congrats') {
        level = cc.level;
    } else {
        if(cc.level >= cc.get_max_level()) { return null; }
        level = cc.level + 1;
    }

    var dialog = new SPUI.Dialog(gamedata['dialogs']['cc_upgrade_congrats']);
    if(mode == 'congrats') {
        change_selection_ui(dialog);
    } else {
        install_child_dialog(dialog);
    }
    dialog.auto_center();
    dialog.modal = true;
    goog.array.forEach(['title','you_completed','details_header'], function(wname) {
        dialog.widgets[wname].str = dialog.data['widgets'][wname]['ui_name_'+mode];
    });
    dialog.widgets['icon'].asset = get_leveled_quantity(gamedata['buildings'][gamedata['townhall']]['art_asset'], level);
    dialog.widgets['level_text'].str = dialog.data['widgets']['level_text']['ui_name'].replace('%TOWNHALL',gamedata['buildings'][gamedata['townhall']]['ui_name']).replace('%d', level.toString());
    dialog.widgets['close_button'].onclick = dialog.widgets['ok_button'].onclick = close_parent_dialog;

    if(mode == 'congrats') {
        var viral_name = null, viral_props = null;
        if('ui_congrats_viral' in cc.spec) {
            viral_name = get_leveled_quantity(cc.spec['ui_congrats_viral'], cc.level);
            if(viral_name) {
                viral_props = {};
            }
        }
        var viral = get_facebook_viral(viral_name);
        if(viral) {
            dialog.widgets['ok_button'].show = false;
            dialog.widgets['viral_button'].show = true;
            dialog.default_button = dialog.widgets['viral_button'];
            dialog.widgets['viral_button'].str = viral['ui_button_text'];
            dialog.widgets['viral_button'].onclick = (function (_vname, _vprops) { return function() {
                invoke_facebook_viral(_vname, _vprops);
            }; })(viral_name, viral_props);
        }
    }

    dialog.widgets['details'].scroll_up_button = dialog.widgets['scroll_up'];
    dialog.widgets['details'].scroll_down_button = dialog.widgets['scroll_down'];
    dialog.widgets['scroll_up'].onclick = function(w) { w.parent.widgets['details'].scroll_up(); };
    dialog.widgets['scroll_down'].onclick = function(w) { w.parent.widgets['details'].scroll_down(); };

    var parsed = Congrats.cc_upgrade(cc, level);
    dialog.widgets['details'].max_lines = parsed.length+10;
    dialog.user_data['parsed'] = parsed;
    dialog.user_data['line'] = 0;

    if(mode == 'congrats') {
        dialog.widgets['glow'].show = true;
        play_level_up_sound(null);

        dialog.user_data['typewriter'] = (function (d) { return function() {
            if(!d.parent) { return; }
            var parsed = d.user_data['parsed'];
            if(d.user_data['line'] >= parsed.length) {
                return;
            } else {
                if(d.user_data['line'] % 2 == 0) {
                    GameArt.assets['xp_gain_sound'].states['normal'].audio.play(client_time);
                }
                d.widgets['details'].append_text(parsed[d.user_data['line']]);
                d.user_data['line'] += 1;
                window.setTimeout(d.user_data['typewriter'], 350);
            }
        }; })(dialog);
        dialog.user_data['typewriter']();
    } else {
        goog.array.forEach(parsed, function(line) { dialog.widgets['details'].append_text(line); });
        dialog.widgets['details'].scroll_to_top();
    }
    return dialog;
}

function invoke_generic_upgrade_congrats(small_asset, alt_bg, sound_name, title, level, text, asset, cloaked, viral_name, viral_props) {
    change_selection(null);
    var dialog = new SPUI.Dialog(gamedata['dialogs']['unit_upgrade_congrats']);
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    if(alt_bg) {
        dialog.widgets['sunken'].asset = dialog.data['widgets']['sunken']['asset'] + '_alt';
    }

    dialog.widgets['small_icon'].show = !!small_asset;
    dialog.widgets['small_icon'].asset = small_asset;

    dialog.widgets['big_icon'].asset = asset;
    if(dialog.widgets['big_icon'].asset) {
        dialog.widgets['big_icon'].state = (GameArt.assets[asset].has_state('hero') ? 'hero' : 'normal');
    }

    dialog.widgets['big_icon'].alpha = dialog.widgets['small_icon'].alpha = cloaked ? gamedata['client']['cloaked_opacity'] : 1;
    dialog.widgets['level_text'].set_text_with_linebreaking(dialog.data['widgets']['level_text']['ui_name'].replace('%s', title).replace('%d', level.toString()));
    dialog.widgets['description'].set_text_with_linebreaking(text);
    dialog.widgets['close_button'].onclick = function() { change_selection(null); };

    if(1) { // old A/B test
        dialog.widgets['flash'].show = true;
        dialog.widgets['glow'].show = true;
    } else if(sound_name) {
        play_level_up_sound(sound_name);
    }

    var viral = get_facebook_viral(viral_name);
    if(viral) {
        dialog.widgets['ok_button'].str = viral['ui_button_text'];
        dialog.widgets['ok_button'].onclick = (function (_vname, _vprops) { return function() {
            change_selection(null);
            invoke_facebook_viral(_vname, _vprops);
        }; })(viral_name, viral_props);
    } else {
        dialog.widgets['ok_button'].onclick = dialog.widgets['close_button'].onclick;
    }

    return dialog;
}

function invoke_building_upgrade_congrats(spec_name, level) {
    if(spec_name == gamedata['townhall']) { return invoke_cc_upgrade_congrats(); }

    var spec = gamedata['buildings'][spec_name];
    if(!('ui_congrats' in spec)) { return null; }
    var text = get_leveled_quantity(spec['ui_congrats'], level);
    if(!text) { return; }

    var viral_name = null, viral_props = null;
    if('ui_congrats_viral' in spec) {
        viral_name = get_leveled_quantity(spec['ui_congrats_viral'], level);
        if(viral_name) {
            viral_props = {};
        }
    }

    // new: sound is handled by the VFX or dialog widgets for new flashy case
    var sound_name = null;

    var dialog = invoke_generic_upgrade_congrats(null, false, sound_name, spec['ui_name'], level, text, get_leveled_quantity(spec['art_asset'], level),
                                                 get_leveled_quantity(spec['cloaked'] || 0, level),
                                                 viral_name, viral_props);
    if(level == 1) {
        // replace "You Upgraded:" with "You Constructed:"
        dialog.widgets['you_completed'].str = dialog.data['widgets']['you_completed']['ui_name_constructed'];
    }
    return dialog;
}

function invoke_tech_upgrade_congrats(spec_name) {
    var tech_spec = gamedata['tech'][spec_name];
    if(!('ui_congrats' in tech_spec)) { return; }

    var level = player.tech[spec_name];

    var text = get_leveled_quantity(tech_spec['ui_congrats'], level);
    if(!text) { return; }

    var unit_spec, ui_tech_name;

    if('associated_unit' in tech_spec) {
        // tech for unlocking a unit
        unit_spec = gamedata['units'][tech_spec['associated_unit']];
        ui_tech_name = unit_spec['ui_name'];
    } else if('affects_unit' in tech_spec) {
        // tech that buffs a unit
        unit_spec = gamedata['units'][tech_spec['affects_unit']];
        ui_tech_name = tech_spec['ui_name'];
    } else if('affects_manufacture_category' in tech_spec) {
        // tech that buffs a category of units
        for(var name in gamedata['units']) {
            if(gamedata['units'][name]['manufacture_category'] == tech_spec['affects_manufacture_category']) {
                // show "coolest" unit of this manufacture category that the player has
                if(!unit_spec || gamedata['units'][name]['level_determined_by_tech'] in player.tech) {
                    unit_spec = gamedata['units'][name];
                }
            }
        }
        ui_tech_name = tech_spec['ui_name'];
    } else {
        return;
    }

    // show different background for mod upgrades
    var alt_bg = ('affects_unit' in tech_spec);

    // new: sound is handled by the VFX or dialog widgets for new flashy case
    var sound_name = null;

    var dialog = invoke_generic_upgrade_congrats(get_leveled_quantity(unit_spec['art_asset'], level), alt_bg, sound_name,
                                                 ui_tech_name, level, text, get_leveled_quantity(unit_spec['splash_image'] || unit_spec['art_asset'], level),
                                                 get_leveled_quantity(unit_spec['cloaked'] || 0, level),
                                                 null, null);

    if(level == 1) {
        // replace "You Upgraded:" with "You Unlocked:"
        dialog.widgets['you_completed'].str = dialog.data['widgets']['you_completed']['ui_name_unlocked'];
    }

    // show "Produce" button if player is beyond extended tutorial
    if(read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null)) {
        dialog.widgets['ok_button'].str = gamedata['spells']['MAKE_DROIDS']['ui_name'];
        dialog.widgets['ok_button'].onclick = (function (sp) { return function() {
            change_selection(find_object_by_type(get_factory_for(sp['manufacture_category'])));
            invoke_manufacture_dialog('tech_upgrade_congrats', sp['manufacture_category'], sp['name']);
        }; })(unit_spec);
    }

    if('ui_congrats_viral' in tech_spec && player.get_any_abtest_value('unit_tech_virals_replace_produce', gamedata['virals']['unit_tech_virals_replace_produce'])) {
        var viral_name = get_leveled_quantity(tech_spec['ui_congrats_viral'], level);
        if(viral_name) {
            var viral = get_facebook_viral(viral_name);
            if(viral) {
                var viral_props = {'%UNIT': tech_spec['ui_name']};
                dialog.widgets['ok_button'].str = viral['ui_button_text'];
                dialog.widgets['ok_button'].onclick = (function (_vname, _vprops) { return function() {
                    invoke_facebook_viral(_vname, _vprops);
                }; })(viral_name, viral_props);
                }
        }
    }

    return dialog;
}

function invoke_blueprint_congrats(item_spec_name, tech_spec_name) {
    var item_spec = ItemDisplay.get_inventory_item_spec(item_spec_name);
    var tech_spec = gamedata['tech'][tech_spec_name];
    var unit_spec = null;
    if('associated_unit' in tech_spec) {
        // tech for unlocking/upgrading a unit
        unit_spec = gamedata['units'][tech_spec['associated_unit']];
    } else if('associated_item' in tech_spec) {
        // tech for unlocking/upgrading an item (via crafting recipe)
    } else {
        return;
    }

    change_selection(null);
    var dialog = new SPUI.Dialog(gamedata['dialogs']['blueprint_congrats']);
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var icon_alpha = 1;
    if(unit_spec) {
        var is_cloaked = ('cloaked' in unit_spec ? unit_spec['cloaked'] : 0);
        if(get_leveled_quantity(is_cloaked, 1)) {
            icon_alpha = gamedata['client']['cloaked_opacity'];
        }
    }

    if(unit_spec) {
        dialog.widgets['small_icon'].asset = get_leveled_quantity(unit_spec['art_asset'],1);
        dialog.widgets['small_icon'].alpha = icon_alpha;
        dialog.widgets['big_icon'].alpha = icon_alpha;
    }

    if('splash_image' in tech_spec) {
        dialog.widgets['splash_icon'].asset = get_leveled_quantity(tech_spec['splash_image'],1);
        dialog.widgets['splash_icon_bg'].show = true;
    } else {
        dialog.widgets['big_icon'].asset = dialog.widgets['small_icon'].asset; // might be null
    }

    dialog.widgets['level_text'].set_text_with_linebreaking(dialog.data['widgets']['level_text']['ui_name'].replace('%s',ItemDisplay.get_inventory_item_ui_name(item_spec)));
    dialog.widgets['description'].set_text_with_linebreaking(dialog.data['widgets']['description']['ui_name'].replace('%lab', gamedata['buildings'][get_lab_for(tech_spec['research_category'])]['ui_name']));

    dialog.widgets['close_button'].onclick = function() { change_selection(null); };
    dialog.widgets['ok_button'].onclick = (function (_tech_spec_name) { return function() {
        change_selection_ui(null);
        invoke_upgrade_tech_dialog(_tech_spec_name, null);
    }; })(tech_spec_name);

    return dialog;
}

player.gift_orders_enabled = function() {
    var default_value = eval_cond_or_literal(gamedata['store']['enable_gift_orders'], player, null);
    return player.get_any_abtest_value('enable_gift_orders', default_value);
};

function invoke_buy_gamebucks_dialog(reason, amount, order) {
    var ver = eval_cond_or_literal(player.get_any_abtest_value('buy_gamebucks_dialog_version', gamedata['store']['buy_gamebucks_dialog_version'] || 1), player, null);

    // this option controls whether the game will automatically
    // re-attempt the gamebucks purchase that caused this dialog to
    // appear after the player buys the gamebucks. Default to off
    // because it often causes support tickets like "I bought 1000
    // Gold but only recevied 490!" (because 510 was spent on
    // auto-completing the original order).
    if(!eval_cond_or_literal(player.get_any_abtest_value('reattempt_order_after_buy_gamebucks', gamedata['store']['reattempt_order_after_buy_gamebucks']||false), player, null)) {
        order = null;
    }

    if(ver == 1) {
        return invoke_buy_gamebucks_dialog1(reason, amount, order);
    } else {
        return invoke_buy_gamebucks_dialog23(ver, reason, amount, order);
    }
}

function invoke_buy_gamebucks_dialog1(reason, amount, order) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['buy_gamebucks_dialog']);
    dialog.user_data['dialog'] = 'buy_gamebucks_dialog';
    dialog.user_data['order'] = (order || null);
    dialog.user_data['enable_gift_orders'] = player.gift_orders_enabled() && (player.resource_state['gamebucks'] >= 0);
    dialog.user_data['chapter'] = 'yourself';
    dialog.user_data['gift_order'] = null;
    dialog.user_data['gift_order_candidates'] = null;

    dialog.widgets['title'].str = dialog.widgets['title'].data['ui_name'].replace('%s', Store.gamebucks_ui_name());

    // short-term hack - transition messages for users who haven't seen either gamebucks or the new fbpayments API yet
    // note: gamebucks transition message takes precedence over fbpayments
    if('transition_msg' in dialog.widgets) {
        var transition_msg;
        if(player.get_any_abtest_value('buy_gamebucks_transition_msg_gamebucks', gamedata['store']['buy_gamebucks_transition_msg_gamebucks'])) {
            transition_msg = 'gamebucks';
        } else if(player.get_any_abtest_value('buy_gamebucks_transition_msg_fbpayments', gamedata['store']['buy_gamebucks_transition_msg_fbpayments'])) {
            transition_msg = 'fbpayments';
        }

        if(transition_msg) {
            dialog.widgets['info_button'].show = dialog.widgets['transition_msg_header'].show = dialog.widgets['transition_msg'].show = true;
            dialog.widgets['transition_msg'].set_text_with_linebreaking(dialog.data['widgets']['transition_msg']['ui_name_'+transition_msg]);
            dialog.widgets['info_button'].onclick = (function (_transition_msg) { return function(w) {
                var handle = window.open(w.data['url_'+_transition_msg], '_blank');
                if(handle) { handle.focus(); }
            }; })(transition_msg);
        }
    }

    if(0 && amount > 0) {
        dialog.widgets['message'].set_text_with_linebreaking(dialog.data['widgets']['message']['ui_name'].replace('%d', Store.display_user_currency_amount(amount, 'compact')).replace('%s', Store.gamebucks_ui_name()));
        dialog.widgets['message'].show = true;
    } else {
        dialog.widgets['mf_logo'].show = true;
    }

    var spell_list = [];

    // optional top-up SKU that buys only enough gamebucks for whatever the player was attempting to do
    var topup_bucks = -1;
    if(order && order['price'] > 0 && order['price'] > player.resource_state['gamebucks'] &&
       (player.get_any_abtest_value('gamebucks_per_fbcredit_topup', gamedata['store']['gamebucks_per_fbcredit_topup']) > 0)) {
        topup_bucks = order['price'] - player.resource_state['gamebucks'];

    }
    dialog.user_data['topup_bucks'] = topup_bucks;

    // construct slate of SKUs from fixed-price bundles
    for(var spellname in gamedata['spells']) {
        if(spellname.indexOf("BUY_GAMEBUCKS_") != -1 && spellname !== "BUY_GAMEBUCKS_TOPUP") {
            var spell = gamedata['spells'][spellname];
            if('requires' in spell && !read_predicate(spell['requires']).is_satisfied(player, null)) {
                continue;
            }
            if(topup_bucks > 0) {
                // don't show SKUs smaller than the topup
                if(spell['quantity'] < topup_bucks) { continue; }
            }
            spell_list.push(spellname);
        }
    }

    spell_list.sort(function (a,b) {
        var sa = gamedata['spells'][a], sb = gamedata['spells'][b];
        var va = sa['quantity'], vb = sb['quantity'];
        if(va > vb) { return 1; } else if(va < vb) { return -1; } else { return 0; }
    });

    if(topup_bucks > 0) {
        var old_list = spell_list;
        // if the slate has a full 6 SKUs, omit the first one to make room for the topup
        if(old_list.length == 6) {
            old_list = old_list.slice(1);
        }
        // prepend the topup SKU at the beginning
        spell_list = ["BUY_GAMEBUCKS_TOPUP"];
        spell_list = spell_list.concat(old_list);
    }

    if(spell_list.length < 1 || spell_list.length > 6) {
        log_exception(null, 'weird number of gamebucks SKUs ('+spell_list.length.toString()+')! region '+player.price_region+' country '+player.country+' SKUs: ['+spell_list.join(',')+'] in invoke_buy_gamebucks_dialog');
    }

    if(spell_list.length > dialog.data['widgets']['radio']['array'][1]) {
        console.log('too many spells for list UI!');
    }

    dialog.user_data['spell_list'] = spell_list;
    dialog.user_data['selection'] = 0;
    dialog.user_data['pending'] = false;

    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    var go_away = function(w) {
        metric_event('4410_buy_gamebucks_dialog_close', {'purchase_ui_event': true, 'client_time': Math.floor(client_time)});
        close_parent_dialog(w);
    };

    dialog.widgets['close_button'].onclick = go_away;

    var default_selection = (topup_bucks > 0 ? 0 : player.get_any_abtest_value('default_gamebucks_offer_index', gamedata['store']['default_gamebucks_offer_index']));

    buy_gamebucks_dialog_select(dialog, default_selection);

    player.record_client_history('purchase_ui_opens', 1);
    if((player.history['money_spent'] || 0) <= 0) {
        player.record_client_history('purchase_ui_opens_preftd', 1);
    }
    var default_spellname = spell_list[default_selection];
    metric_event('4410_buy_gamebucks_dialog_open', {'purchase_ui_event': true, 'client_time': Math.floor(client_time),
                                                    'sku': default_spellname,
                                                    'gamebucks': gamedata['spells'][default_spellname]['quantity'],
                                                    'currency': gamedata['spells'][default_spellname]['currency'],
                                                    'currency_price': gamedata['spells'][default_spellname]['price'],
                                                    'method': reason});
    SPFB.AppEvents.logEvent('SP_PURCHASE_DIALOG_OPEN');

    dialog.widgets['gift_order_cancel_button'].onclick = function(w) { w.parent.user_data['gift_order'] = null; };
    dialog.widgets['gift_order_choose_button'].onclick = dialog.widgets['gift_order_friend_icon'].onclick = function(w) {
        invoke_choose_gift_order_dialog(w.parent, w.parent.user_data['gift_order_candidates']);
    };
    dialog.widgets['gifts_button'].onclick = function(w) { buy_gamebucks_dialog_change_chapter(w.parent, 'gifts'); }
    dialog.widgets['yourself_button'].onclick = function(w) {buy_gamebucks_dialog_change_chapter(w.parent, 'yourself'); };

    if(spin_frame_platform == 'fb' && player.get_any_abtest_value('enable_fb_gift_cards', eval_cond_or_literal(gamedata['store']['enable_fb_gift_cards'], player, null))) {
        dialog.widgets['redeem_gift_card_button'].show = true;
        dialog.widgets['redeem_gift_card_button'].tooltip.str = dialog.data['widgets']['redeem_gift_card_button']['ui_tooltip'].replace('%s', gamedata['store']['gamebucks_ui_name']);
        dialog.widgets['redeem_gift_card_button'].onclick = function(w) { Store.redeem_fb_gift_card( function() { change_selection(null); }, null); };
    }

    dialog.ondraw = update_buy_gamebucks_dialog;
    return dialog;
}

function buy_gamebucks_dialog_change_chapter(dialog, chapter) {
    dialog.user_data['chapter'] = chapter;
    buy_gamebucks_dialog_select(dialog, dialog.user_data['selection']); // recalculate SKUs
}

function update_buy_gamebucks_dialog(dialog) {
    dialog.widgets['loading_rect'].show =
        dialog.widgets['loading_text'].show =
        dialog.widgets['loading_spinner'].show = dialog.user_data['pending'];

    if(dialog.user_data['enable_gift_orders'] && dialog.user_data['gift_order_candidates'] === null) {
        dialog.user_data['gift_order_candidates'] = player.get_gift_order_candidates();
    }
    var anyone_to_gift = dialog.user_data['enable_gift_orders'] && dialog.user_data['gift_order_candidates'] && (dialog.user_data['gift_order_candidates'].length>=1);

    if(!anyone_to_gift) {
        dialog.user_data['chapter'] = 'yourself';
        dialog.widgets['gifts_button'].show =
        dialog.widgets['gift_order_title'].show =
        dialog.widgets['yourself_button'].show = false;
    } else {
        dialog.widgets['gifts_button'].show =
        dialog.widgets['gift_order_title'].show =
        dialog.widgets['yourself_button'].show = true;
        dialog.widgets['gifts_button'].state = (dialog.user_data['chapter'] == 'gifts' ? 'active' : 'normal');
        dialog.widgets['yourself_button'].state = (dialog.user_data['chapter'] == 'yourself' ? 'active' : 'normal');
    }

    goog.array.forEach(['select_your_package','buy_button'], function(name) {
        dialog.widgets[name].str = dialog.data['widgets'][name]['ui_name'+(dialog.user_data['chapter']=='gifts'?'_gifts':'')];
    });

    if(dialog.user_data['chapter'] == 'gifts') {
        //dialog.widgets['mf_logo'].show = false;
        dialog.widgets['buy_button'].state = (dialog.user_data['gift_order'] ? 'normal' : 'disabled');
        dialog.widgets['gift_order_choose_button'].show =
            dialog.widgets['gift_order_friend_icon'].show = true;

        if(dialog.user_data['gift_order']) {
            var entry = dialog.user_data['gift_order']['gifts'][0];
            dialog.widgets['gift_order_cancel_button'].show = false;
            dialog.widgets['gift_order_friend_icon'].set_user(entry['recipient_user_id']);
        } else {
            dialog.widgets['gift_order_cancel_button'].show = false;
            dialog.widgets['gift_order_friend_icon'].set_user(null);
        }
    } else {
        dialog.widgets['buy_button'].state = 'normal';
        //dialog.widgets['mf_logo'].show = true;
        dialog.widgets['gift_order_choose_button'].show =
            dialog.widgets['gift_order_cancel_button'].show =
            dialog.widgets['gift_order_friend_icon'].show = false;

    }
};

// return [qty (number), tooltip (array of strings, one per line)] describing bonus units given along with a gamebucks purchase
function get_gamebucks_sku_bonus_units(spell) {
    var cc_level = player.get_townhall_level();
    var tip = [];
    var total_qty = 0;
    for(var spec_name in spell['give_units']) {
        if(!(spec_name in gamedata['units'])) { continue; }
        var spec = gamedata['units'][spec_name];
        var qty = spell['give_units'][spec_name];
        var level = player.tech[spec['level_determined_by_tech']] || 1;
        if('level_by_cc' in spell['give_units']) {
            var table = gamedata['reward_unit_level_by_cc_level'];
            var index = clamp(cc_level-1, 0, table.length-1);
            level = Math.max(level, table[index]);
            if(player.get_any_abtest_value('reward_units_by_mail', gamedata['reward_units_by_mail'])) {
                // round generously
                if(level > 4) {
                    level = 8;
                } else if(level > 1) {
                    level = 4;
                } else {
                    level = 1;
                }
            }
        }
        var text = qty.toString()+'x '+spec['ui_name'];
        //text += ' (L'+level.toString()+')';
        tip.push(text);
        total_qty += qty;
    }
    return [total_qty, tip];
};

function buy_gamebucks_dialog_select(dialog, num) {
    var spell_list = dialog.user_data['spell_list'];
    var topup_bucks = dialog.user_data['topup_bucks'];
    num = Math.min(Math.max(num, 0), spell_list.length-1);
    dialog.user_data['selection'] = num;

    var display_currency = null;
    if(SPay.api == 'fbpayments') {
        // display_currency will be set on a per-spell basis
    } else if(SPay.api == 'kgcredits') {
        display_currency = 'Kongregate Kreds';
    } else if(player.get_any_abtest_value('use_local_currency', gamedata['store']['use_local_currency']) && player.facebook_currency) {
        display_currency = player.facebook_currency['user_currency'];
    } else {
        display_currency = 'Facebook Credits';
    }

    var i;
    for(i = 0; i < spell_list.length; i++) {
        var spellname = spell_list[i];
        var spell = gamedata['spells'][spellname];
        var alloy_qty = (spell['price_formula'] == 'gamebucks_topup' ? topup_bucks : spell['quantity']);

        var payment_currency = ('currency' in spell ? spell['currency'] : 'fbcredits');
        if(SPay.api == 'fbpayments') {
            if(payment_currency.indexOf('fbpayments:') != 0) { throw Error('bad payment_currency '+payment_currency); }
            display_currency = payment_currency.split(':')[1];
        }

        var payment_price = Store.get_price(payment_currency, GameObject.VIRTUAL_ID, spell, (spell['price_formula'] == 'gamebucks_topup' ? topup_bucks : null), false);

        dialog.widgets['radio'+i].state = (i === num ? 'active' : 'normal');
        dialog.widgets['radio'+i].onclick =
            dialog.widgets['icon'+i].onclick =
            dialog.widgets['bucks'+i].onclick =
//          dialog.widgets['label'+i].onclick =
            dialog.widgets['credits'+i].onclick =
            dialog.widgets['comment'+i].onclick =
            dialog.widgets['bonus'+i].onclick =
            dialog.widgets['bonus_slot'+i].onclick =
            (function (_i, _alloy_qty, _payment_currency, _payment_price) { return function(w) {
                var dialog = w.parent;
                var _spellname = dialog.user_data['spell_list'][_i];
                metric_event('4430_buy_gamebucks_select_qty', {'purchase_ui_event': true, 'client_time': Math.floor(client_time),
                                                               'sku': _spellname,
                                                               'gamebucks': _alloy_qty,
                                                               'currency': _payment_currency,
                                                               'currency_price': _payment_price});

                buy_gamebucks_dialog_select(dialog, _i);
            }; })(i, alloy_qty, payment_currency, payment_price);
        dialog.widgets['bucks'+i].str = dialog.data['widgets']['bucks']['ui_name'].replace('%d', Store.display_user_currency_amount(alloy_qty, 'full'));

        dialog.widgets['credits'+i].str = Store.display_real_currency_amount(display_currency, payment_price, payment_currency, false);
        // manually add " Credits" suffix to Facebook Credits amounts in the list
        if(display_currency == 'Facebook Credits' && payment_currency == 'fbcredits') {
            dialog.widgets['credits'+i].str += ' Credits';
        } else if(display_currency == 'Kongregate Kreds' && payment_currency == 'kgcredits') {
            dialog.widgets['credits'+i].str += ' Kreds';
        }

        dialog.widgets['icon'+i].bg_image = player.get_any_abtest_value('gamebucks_resource_icon', gamedata['store']['gamebucks_resource_icon']);

        dialog.widgets['comment'+i].str = ('ui_comment' in spell ? spell['ui_comment'] : '');
        dialog.widgets['bonus'+i].str = ('ui_bonus' in spell ? spell['ui_bonus'] : '');

        var give_units = ('give_units' in spell && (dialog.user_data['chapter'] != 'gifts')); // no bonus units in gifts

        dialog.widgets['bonus'+i].font = SPUI.make_font(dialog.data['widgets']['bonus']['text_size'],
                                                        dialog.data['widgets']['bonus']['text_size']+4,
                                                        (i === num && give_units ? 'bold' : 'normal'));
        dialog.widgets['bonus'+i].text_hjustify = (give_units ? 'center' : 'left');
        dialog.widgets['bonus'+i].show = dialog.widgets['bonus_slot'+i].show = !!give_units;

        if(give_units) {
            var temp = get_gamebucks_sku_bonus_units(spell);
            var total_qty = temp[0], tip = temp[1];
            dialog.widgets['bonus_slot'+i].tooltip.str = tip.join('\n');
            dialog.widgets['bonus'+i].xy[0] = dialog.data['widgets']['bonus']['xy'][0] + dialog.data['widgets']['bonus']['slot_shove'];
            var state = 'normal';
            if(total_qty >= 11) {
                state = 'gunship';
            } else if(total_qty >= 7) {
                state = 'transport';
            } else {
                state = 'rover';
            }
            dialog.widgets['bonus_slot'+i].state = state;
        } else {
            dialog.widgets['bonus_slot'+i].tooltip.str = '';
        }

        dialog.widgets['radio'+i].show =
            dialog.widgets['icon'+i].show =
            dialog.widgets['bucks'+i].show =
//          dialog.widgets['label'+i].show =
            dialog.widgets['comment'+i].show =
            dialog.widgets['credits'+i].show = true;
    }

    while(i < dialog.data['widgets']['radio']['array'][1]) {
        dialog.widgets['radio'+i].show =
            dialog.widgets['icon'+i].show =
            dialog.widgets['bucks'+i].show =
//          dialog.widgets['label'+i].show =
            dialog.widgets['comment'+i].show =
            dialog.widgets['bonus_slot'+i].show =
            dialog.widgets['bonus'+i].show =
            dialog.widgets['credits'+i].show = false;
        i++;
    }

    // selected spell
    var spellname = spell_list[num];
    var spell = gamedata['spells'][spellname];
    var payment_currency = ('currency' in spell ? spell['currency'] : 'fbcredits');
    if(SPay.api == 'fbpayments') { display_currency = payment_currency.split(':')[1]; }
    var alloy_qty = (spell['price_formula'] == 'gamebucks_topup' ? topup_bucks : spell['quantity']);
    var spellarg = (spell['price_formula'] == 'gamebucks_topup' ? topup_bucks : null);
    var payment_price = Store.get_price(payment_currency, GameObject.VIRTUAL_ID, spell, spellarg, false);

    // PRICE
    dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    dialog.widgets['price_display'].str = Store.display_real_currency_amount(display_currency, payment_price, payment_currency, true);
    if(payment_currency == 'kgcredits') {
        dialog.widgets['price_display'].state = 'kgcredits';
    } else {
        dialog.widgets['price_display'].state = ((display_currency == 'Facebook Credits' && payment_currency == 'fbcredits') || player.get_any_abtest_value('always_show_fbcredits_logo', gamedata['store']['always_show_fbcredits_logo']) ? 'fbcredits' : 'neutral');
    }
    dialog.widgets['price_display'].text_offset = (dialog.widgets['price_display'].state == 'fbcredits' ? [5,1] : [0,1] );
    dialog.widgets['price_display'].tooltip.str =
        (player.get_any_abtest_value('price_display_tooltip', gamedata['store']['price_display_tooltip']) ?
         dialog.data['widgets']['price_display']['ui_tooltip_buy'].replace('%bucks', dialog.widgets['bucks'+num].str).replace('%credits',dialog.widgets['credits'+num].str) : '');

    dialog.widgets['price_display'].onclick =
        dialog.widgets['buy_button'].onclick = (function (spname, _spellarg, _order, _alloy_qty, _payment_price, _payment_currency) { return function(widget) {
            var dialog = widget.parent;
            if(dialog.user_data['pending']) { return; }

            if(_order && (player.resource_state['gamebucks'] + _alloy_qty) < _order['price']) {
                // don't attempt continuation order if alloy amount would be insufficient
                _order = null;
            }

            metric_event('4440_buy_gamebucks_init_payment', {'purchase_ui_event': true, 'client_time': Math.floor(client_time),
                                                             'sku': spname,
                                                             'gamebucks': _alloy_qty,
                                                             'currency': _payment_currency,
                                                             'currency_price': _payment_price});
            var credits_props = {'no_clear': true};
            var gift_order = dialog.user_data['chapter'] == 'gifts' && dialog.user_data['gift_order'];
            if(gift_order) {
                // fill in amount here
                gift_order['gifts'][0]['gamebucks'] = _alloy_qty;
                credits_props['gift_order'] = gift_order;
            }

            var credits_cb = (function (_widget, __order) { return function() {
                var dialog = _widget.parent;
                if(dialog) {
                    dialog.user_data['pending'] = false;
                    close_parent_dialog(_widget); // get rid of Get More Alloy dialog
                }

                if(__order && player.resource_state['gamebucks'] >= __order['price']) {
                    // re-attempt the original order
                    if(Store.place_gamebucks_order(__order['price'], __order['unit_id'], __order['spellname'], __order['spellarg'], __order['cb'] || null)) {
                        invoke_ui_locker();
                    }
                }
            }; })(widget, _order);


            var placer = (function (_dialog, __payment_currency, _spname, _spellarg, _credits_cb, _credits_props) { return function() {
                if(SPay.api != 'fbcredits' && player.get_any_abtest_value('lock_buy_gamebucks_dialog_during_payment', gamedata['store']['lock_buy_gamebucks_dialog_during_payment'])) {
                    // lock dialog
                    _dialog.user_data['pending'] = true;
                    _credits_props['fail_cb'] = (function (__dialog) { return function() {
                        // unlock dialog on fail as well as success
                        __dialog.user_data['pending'] = false;
                    }; })(_dialog);
                }
                Store.place_order(__payment_currency, GameObject.VIRTUAL_ID, _spname, _spellarg, _credits_cb, _credits_props);
            }; })(dialog, _payment_currency, spname, spellarg, credits_cb, credits_props);

            if(gift_order) {
                invoke_confirm_gift_order_dialog(gift_order, placer);
            } else {
                placer();
            }
        }; })(spellname, spellarg, dialog.user_data['order'], alloy_qty, payment_price, payment_currency);
};

function invoke_you_got_bonus_units() {
    var dialog_data = gamedata['dialogs']['you_got_bonus_units'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'you_got_bonus_units';
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.widgets['ok_button'].onclick =
        dialog.widgets['close_button'].onclick = close_parent_dialog;
    GameArt.assets["success_playful_22"].states['normal'].audio.play(client_time);
    return dialog;
}


function invoke_buy_gamebucks_dialog23(ver, reason, amount, order) {
    var dialog = new SPUI.Dialog(gamedata['dialogs']['buy_gamebucks_dialog'+ver.toString()]);
    dialog.user_data['ver'] = ver;
    dialog.user_data['dialog'] = 'buy_gamebucks_dialog'+ver.toString();
    dialog.user_data['order'] = (order || null);
    dialog.user_data['pending'] = false;
    dialog.user_data['enable_gift_orders'] = player.gift_orders_enabled() && (player.resource_state['gamebucks'] >= 0);
    dialog.user_data['chapter'] = 'yourself';
    dialog.user_data['gift_order'] = null;
    dialog.user_data['gift_order_candidates'] = null;

    dialog.widgets['title_bold'].str = dialog.data['widgets']['title_bold']['ui_name'].replace('%s', Store.gamebucks_ui_name());

    // optional top-up SKU that buys only enough gamebucks for whatever the player was attempting to do
    var topup_bucks = -1;
    if(order && order['price'] > 0 && order['price'] > player.resource_state['gamebucks'] &&
       (player.get_any_abtest_value('gamebucks_per_fbcredit_topup', gamedata['store']['gamebucks_per_fbcredit_topup']) > 0)) {
        topup_bucks = order['price'] - player.resource_state['gamebucks'];

    }
    dialog.user_data['topup_bucks'] = topup_bucks;
    dialog.user_data['any_sku_has_bonus'] = 0;
    dialog.user_data['max_displayed_quantity'] = 0;

    // construct slate of SKUs from fixed-price bundles
    var spell_list = [];
    for(var spellname in gamedata['spells']) {
        if(spellname.indexOf("BUY_GAMEBUCKS_") != -1 && spellname !== "BUY_GAMEBUCKS_TOPUP") {
            var spell = gamedata['spells'][spellname];
            if('requires' in spell && !read_predicate(spell['requires']).is_satisfied(player, null)) {
                continue;
            }
            if(topup_bucks > 0) {
                // don't show SKUs smaller than the topup
                if(spell['quantity'] < topup_bucks) { continue; }
            }

            dialog.user_data['max_displayed_quantity'] = Math.max(dialog.user_data['max_displayed_quantity'], spell['quantity']);
            var bonus_lines = 0;
            if(spell['ui_bonus']) { bonus_lines += 1; }
            if(('nominal_quantity' in spell) && spell['nominal_quantity'] < spell['quantity']) { bonus_lines += 1; }
            dialog.user_data['any_sku_has_bonus'] = Math.max(dialog.user_data['any_sku_has_bonus'], bonus_lines);

            // note: picks up last ui_warning among all SKUs
            if(spell['ui_warning']) { dialog.widgets['warning_text'].str = spell['ui_warning']; }

            spell_list.push(spellname);
        }
    }

    spell_list.sort(function (a,b) {
        var sa = gamedata['spells'][a], sb = gamedata['spells'][b];
        var va = sa['quantity'], vb = sb['quantity'];
        if(va > vb) { return 1; } else if(va < vb) { return -1; } else { return 0; }
    });

    if(topup_bucks > 0) {
        spell_list = ["BUY_GAMEBUCKS_TOPUP"].concat(spell_list);
    }

    if(spell_list.length < 1) {
        log_exception(null, 'no gamebucks SKUs ('+spell_list.length.toString()+')! region '+player.price_region+' country '+player.country + 'in invoke_buy_gamebucks_dialog2');
    }

    dialog.user_data['spell_list'] = spell_list;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;

    // SKU setup
    var i = 0;
    for(; i < spell_list.length; i++) {
        var spellname = spell_list[i];
        var spell = gamedata['spells'][spellname];

        var d = new SPUI.Dialog(gamedata['dialogs'][dialog.data['widgets']['sku']['dialog']]);
        dialog.add(d); dialog.widgets['sku'+i.toString()] = d;
        d.user_data['spellname'] = spellname;
        d.user_data['spell'] = spell;
        d.user_data['ui_index'] = i;
        d.user_data['base_xy'] = [d.xy[0], d.xy[1]];

        d.widgets['name'].set_text_with_linebreaking(spell['ui_new_store_name'] || spell['ui_name']);
        //d.widgets['icon'].asset = spell['new_store_icon'] || spell['icon'];
        d.widgets['jewel'].user_data['count'] = 0;
        d.widgets['jewel'].ondraw = update_notification_jewel;
        d.ondraw = update_buy_gamebucks_sku2;
        d.ondraw(d);
        d.clip_to = [dialog.widgets['sunken'].xy[0], dialog.widgets['sunken'].xy[1],
                     dialog.widgets['sunken'].wh[0], dialog.widgets['sunken'].wh[1]];
    }

    // scrolling setup
    dialog.user_data['scroll_pos'] = 0;
    dialog.user_data['scroll_goal'] = 0;
    dialog.user_data['scroll_limits'] = [0, spell_list.length * dialog.data['widgets']['sku']['array_offset'][0] - dialog.widgets['sunken'].wh[0] + dialog.data['widgets']['sku']['xy'][0] + 3];
    dialog.user_data['open_time'] = client_time;
    dialog.user_data['scrolled'] = false;

    var scroller = function(incr) { return function(w) {
        var dialog = w.parent;
        dialog.user_data['scroll_goal'] = clamp(dialog.user_data['scroll_goal']+dialog.data['widgets']['sku']['array_offset'][0]*incr,
                                                dialog.user_data['scroll_limits'][0], dialog.user_data['scroll_limits'][1]);
        dialog.widgets['scroll_left'].state = (dialog.user_data['scroll_goal'] <= dialog.user_data['scroll_limits'][0] ? 'disabled' : 'normal');
        dialog.widgets['scroll_right'].state = (dialog.user_data['scroll_goal'] >= dialog.user_data['scroll_limits'][1] ? 'disabled' : 'normal');
        if(incr > 0 && !dialog.user_data['scrolled']) {
            dialog.user_data['scrolled'] = true;
            metric_event('4431_buy_gamebucks_dialog_scroll', {'gui_version': dialog.user_data['ver'], 'purchase_ui_event': true, 'client_time': Math.floor(client_time)});
        }
    }; };
    dialog.widgets['scroll_left'].onclick = scroller(-1);
    dialog.widgets['scroll_right'].onclick = scroller(1);
    dialog.widgets['scroll_left_jewel'].ondraw =
        dialog.widgets['scroll_right_jewel'].ondraw = update_notification_jewel;
    dialog.widgets['scroll_left_jewel'].user_data['count'] =
        dialog.widgets['scroll_right_jewel'].user_data['count'] = 0;

    dialog.widgets['scroll_left'].show = dialog.widgets['scroll_right'].show =
        dialog.data['widgets']['scroll_left']['show'] &&
        (spell_list.length * dialog.data['widgets']['sku']['array_offset'][0] >= dialog.widgets['sunken'].wh[0]);

    dialog.widgets['scroll_left_jewel'].show = dialog.widgets['scroll_right_jewel'].show =
        dialog.widgets['scroll_left'].show && false;

    // redeem gift card setup
    if(spin_frame_platform == 'fb' && player.get_any_abtest_value('enable_fb_gift_cards', eval_cond_or_literal(gamedata['store']['enable_fb_gift_cards'], player, null))) {
        dialog.widgets['redeem_gift_card_warning'].show = dialog.widgets['redeem_gift_card_button'].show = dialog.widgets['redeem_gift_card_icon'].show = true;
        dialog.widgets['redeem_gift_card_warning'].str = dialog.data['widgets']['redeem_gift_card_warning']['ui_name'].replace('%s', gamedata['store']['gamebucks_ui_name']);
        dialog.widgets['redeem_gift_card_button'].tooltip.str = dialog.data['widgets']['redeem_gift_card_button']['ui_tooltip'].replace('%s', gamedata['store']['gamebucks_ui_name']);
        dialog.widgets['redeem_gift_card_button'].onclick = function(w) { Store.redeem_fb_gift_card( function() { change_selection(null); }, null); };
    }

    if(Store.trialpay_available() && player.get_any_abtest_value('enable_trialpay', eval_cond_or_literal(gamedata['store']['enable_trialpay']||false, player, null))) {
        dialog.widgets['trialpay_button'].show = true;
        dialog.widgets['trialpay_button'].str = dialog.data['widgets']['trialpay_button']['ui_name'].replace('%s', gamedata['store']['gamebucks_ui_name']);
        dialog.widgets['trialpay_button'].onclick = function(w) { Store.trialpay_invoke(); };
    }

    var go_away = function(w) {
        metric_event('4410_buy_gamebucks_dialog_close', {'gui_version': w.parent.user_data['ver'], 'purchase_ui_event': true, 'client_time': Math.floor(client_time)});
        close_parent_dialog(w);
    };

    dialog.widgets['close_button'].onclick = go_away;
    dialog.ondraw = update_buy_gamebucks_dialog2;

    player.record_feature_use('buy_gamebucks_dialog2');
    player.record_client_history('purchase_ui_opens', 1);
    if((player.history['money_spent'] || 0) <= 0) {
        player.record_client_history('purchase_ui_opens_preftd', 1);
    }
    metric_event('4410_buy_gamebucks_dialog_open', {'gui_version': dialog.user_data['ver'], 'purchase_ui_event': true, 'client_time': Math.floor(client_time), 'method': reason});
    SPFB.AppEvents.logEvent('SP_PURCHASE_DIALOG_OPEN');
    return dialog;
}

function update_buy_gamebucks_dialog2(dialog) {
    var spell_list = dialog.user_data['spell_list'];

    if(!dialog.user_data['scrolled'] &&
       ((client_time - dialog.user_data['open_time']) < gamedata['store']['store_scroll_flash_time']) &&
       false &&
       player.get_any_abtest_value('enable_store_scroll_flash', gamedata['store']['enable_store_scroll_flash'])) {
        if(dialog.widgets['scroll_right'].state != 'disabled') {
            dialog.widgets['scroll_right'].state = ((((client_time/gamedata['store']['store_scroll_flash_period']) % 1) >= 0.5) ? 'highlight' : 'normal');
        }
    }

    if(dialog.user_data['scroll_pos'] != dialog.user_data['scroll_goal']) {
        var delta = dialog.user_data['scroll_goal'] - dialog.user_data['scroll_pos'];
        var sign = (delta > 0 ? 1 : -1);
        dialog.user_data['scroll_pos'] += sign * Math.floor(0.15 * Math.abs(delta) + 0.5);
    }

    var left_jewels = 0, right_jewels = 0; // count number of jeweled SKUs to the left and right of the window

    for(var i = 0; i < spell_list.length; i++) {
        var w = dialog.widgets['sku'+i.toString()];
        /*
        var skudata = w.user_data['skudata'];
        if(!new_store_allow_sku(skudata)) {
            w.show = false;
            continue;
        }
        */
        var n_up = dialog.user_data['spell_list'].length;
        if(!('array_offset_'+n_up.toString()+'up' in dialog.data['widgets']['sku'])) {
            throw Error('unhandled number of skus: '+n_up.toString());
        }
        var offset = dialog.data['widgets']['sku']['array_offset_'+n_up.toString()+'up'];
        var base = dialog.data['widgets']['sku'][('xy_'+n_up.toString()+'up' in dialog.data['widgets']['sku'] ? 'xy_'+n_up.toString()+'up' : 'xy')];
        w.user_data['base_xy']= [i*offset[0] - dialog.user_data['scroll_pos'] + base[0], base[1]];
        /*
        if(('jewel' in skudata) && read_predicate(skudata['jewel']).is_satisfied(player, null)) {
            if(w.user_data['base_xy'][0] + 0.66*w.wh[0] < 0) { left_jewels += 1; }
            if(w.user_data['base_xy'][0] + 0.33*w.wh[0] >= dialog.widgets['sunken'].xy[0] + dialog.widgets['sunken'].wh[0]) { right_jewels += 1; }
        }

        // reposition tooltips
        if(w.user_data['context']) {
            w.user_data['context'].user_data['props']['parent_offset'] = w.user_data['base_xy'];
        }
        */
    }

    dialog.widgets['scroll_left_jewel'].user_data['count'] = left_jewels;
    dialog.widgets['scroll_right_jewel'].user_data['count'] = right_jewels;
}

function update_buy_gamebucks_sku2(dialog) {
    var pending = !!dialog.parent.user_data['pending'];
    var spellname = dialog.user_data['spellname'];
    var spell = dialog.user_data['spell'];

    dialog.widgets['loading_spinner'].show = dialog.widgets['hider'].show = pending;
    var hi = (dialog.mouse_enter_time > 0) && (!dialog.widgets['hider'].show) && !pending;
    dialog.xy = [dialog.user_data['base_xy'][0],
                 dialog.user_data['base_xy'][1] - (hi && !dialog.widgets['bg'].pushed ? 1 : 0)];
    dialog.widgets['bg'].bg_image = dialog.data['widgets']['bg']['bg_image_'+ (true ? 'normal' : 'special')];
    dialog.widgets['bg_shine'].alpha = (hi ? (dialog.widgets['bg'].pushed ? 1 : 0.66 ) : 0.5);
    dialog.widgets['price_bg_shine'].alpha = 0.8 * (hi ? (dialog.widgets['bg'].pushed ? 0.8 : 0.66 ) : 0.6);
    if('buy_text' in dialog.widgets) {
        dialog.widgets['buy_text'].text_color = SPUI.make_colorv(dialog.data['widgets']['buy_text']['text_color'+(hi? '_highlight':'')]);
    }

    var pile_size = ('ui_pile_size' in spell ? spell['ui_pile_size'] : dialog.user_data['ui_index']);
    dialog.widgets['gamebucks_pile'].asset = player.get_any_abtest_value('gamebucks_pile_asset', gamedata['store']['gamebucks_pile_asset']);
    dialog.widgets['gamebucks_pile'].state = 'size'+pile_size.toString();

    var banner_text = ('ui_banner' in spell ? eval_cond_or_literal(spell['ui_banner'], player, null) : null);
    dialog.widgets['sale_bg'].show = dialog.widgets['sale_label'].show = (!!banner_text && (banner_text.length > 0));
    dialog.widgets['sale_label'].str = banner_text;
    if(banner_text in dialog.data['widgets']['sale_label']['xy_shift']) {
        dialog.widgets['sale_label'].xy = vec_add(dialog.data['widgets']['sale_label']['xy'], dialog.data['widgets']['sale_label']['xy_shift'][banner_text]);
    }

    var display_currency = null;
    if(SPay.api == 'fbpayments') {
        // display_currency will be set on a per-spell basis
    } else if(SPay.api == 'kgcredits') {
        display_currency = 'Kongregate Kreds';
    } else if(player.get_any_abtest_value('use_local_currency', gamedata['store']['use_local_currency']) && player.facebook_currency) {
        display_currency = player.facebook_currency['user_currency'];
    } else {
        display_currency = 'Facebook Credits';
    }

    var alloy_qty = (spell['price_formula'] == 'gamebucks_topup' ? dialog.parent.user_data['topup_bucks'] : spell['quantity']);
    var spellarg = (spell['price_formula'] == 'gamebucks_topup' ? dialog.parent.user_data['topup_bucks'] : null);

    var payment_currency = ('currency' in spell ? spell['currency'] : 'fbcredits');
    if(SPay.api == 'fbpayments') {
        if(payment_currency.indexOf('fbpayments:') != 0) { throw Error('bad payment_currency '+payment_currency); }
        display_currency = payment_currency.split(':')[1];
    }
    var payment_price = Store.get_price(payment_currency, GameObject.VIRTUAL_ID, spell, spellarg, false);

    goog.array.forEach(['name','name2'], function(wname) {
        if(wname in dialog.widgets) {
            var ui_key = (dialog.parent.user_data['any_sku_has_bonus'] ? '_withbonus' : '_nobonus');

            var s = dialog.data['widgets'][wname]['ui_name'+ui_key].replace('%qty', pretty_print_number(spell['nominal_quantity'] || alloy_qty)).replace('%gamebucks', Store.gamebucks_ui_name());

            if(s.indexOf('%bonus') != -1) {
                var bonus_list = [];
                if('nominal_quantity' in spell && spell['nominal_quantity'] < spell['quantity'] && 'ui_name_bonus_quantity' in dialog.data['widgets'][wname]) {
                    bonus_list.push(dialog.data['widgets'][wname]['ui_name_bonus_quantity'].replace('%qty', pretty_print_number(spell['quantity'] - spell['nominal_quantity'])).replace('%GAMEBUCKS_NAME', Store.gamebucks_ui_name()));
                }
                if(spell['ui_bonus']) {
                    var b = spell['ui_bonus'];
                    // special-case hack for backwards compatibility with old SKUs ("Unit Bonus" -> "Units")
                    if(b.indexOf('Unit Bonus') != -1) {
                        b = b.replace('Unit Bonus', 'Units');
                    }

                    bonus_list.push(b);
                }

                if(bonus_list.length > 0) {
                    s = s.replace('%bonus', bonus_list.join('\n'));
                } else {
                    // blank it out
                    s = '';
                }
            }
            dialog.widgets[wname].str = s;

            if('text_offset'+ui_key in dialog.data['widgets'][wname]) {
                dialog.widgets[wname].text_offset = dialog.data['widgets'][wname]['text_offset'+ui_key];
            }

            var size_ui_key = 'text_size'+ ui_key + (wname == 'name' && alloy_qty >= 10000 && ('text_size'+ui_key+'_big' in dialog.data['widgets'][wname]) ? '_big': '');
            var size;
            if(size_ui_key in dialog.data['widgets'][wname]) {
                size = dialog.data['widgets'][wname][size_ui_key];
            } else {
                size = dialog.data['widgets'][wname]['text_size'];
            }
            dialog.widgets[wname].font = SPUI.make_font(size, dialog.data['widgets'][wname]['text_leading']|| (size+3),
                                                        dialog.data['widgets'][wname]['text_style']);
        }
    });

    if(('name2' in dialog.widgets) && !dialog.widgets['name2'].str && !dialog.parent.user_data['any_sku_has_bonus']) {
        dialog.widgets['name'].text_vjustify = 'center';
    } else {
        dialog.widgets['name'].text_vjustify = 'top';
        // note: if any_sku_has_bonus, then use max of number of bonus lines among all SKUs
        var bonus_lines = (dialog.parent.user_data['any_sku_has_bonus'] && ('name2' in dialog.widgets) ? Math.max(dialog.parent.user_data['any_sku_has_bonus']+1, dialog.widgets['name2'].str.split('\n').length) : 0);
        if(bonus_lines == 1) {
            dialog.widgets['name2'].text_vjustify = 'bottom';
            dialog.widgets['name'].text_offset = dialog.data['widgets']['name']['text_offset_oneline'];
            dialog.widgets['name2'].text_offset = dialog.data['widgets']['name2']['text_offset_oneline'];
        } else if(bonus_lines == 3) {
            dialog.widgets['name2'].text_vjustify = 'bottom';
            dialog.widgets['name'].text_offset = dialog.data['widgets']['name']['text_offset_threelines'];
            dialog.widgets['name2'].text_offset = dialog.data['widgets']['name2']['text_offset_threelines'];
        }
    }

    // build tooltip
    var tooltip_list = [];
    if('name2' in dialog.widgets) {
        // clarify nominal/total quantity
        if(('nominal_quantity' in spell) && spell['nominal_quantity'] < spell['quantity']) {
            var s = dialog.data['widgets']['name2']['ui_tooltip_bonus_quantity'];
            s = s.replace('%qty', pretty_print_number(spell['quantity'] - spell['nominal_quantity']));
            s = s.replace('%nominal_qty', pretty_print_number(spell['nominal_quantity']));
            while(s.indexOf('%GAMEBUCKS_NAME') != -1) {
                s = s.replace('%GAMEBUCKS_NAME', Store.gamebucks_ui_name());
            }
            tooltip_list.push(s);
        }
        // list bonus units
        if('give_units' in spell) {
            var temp = get_gamebucks_sku_bonus_units(spell);
            var tip = temp[1].join('\n');
            tooltip_list.push(dialog.data['widgets']['name2']['ui_tooltip_bonus_units'].replace('%units', tip));
        }
    }

    if(tooltip_list.length > 0) {
        dialog.widgets['name2'].tooltip.str = tooltip_list.join('\n\n');
    } else {
        dialog.widgets['name2'].tooltip.str = null;
    }

    // do not display a comment unless at least one SKU has a bonus
    if(dialog.parent.user_data['any_sku_has_bonus']) {
        if('ui_comment' in spell) {
            dialog.widgets['comment'].str = spell['ui_comment'];
        } else if(('nominal_quantity' in spell) && (spell['nominal_quantity'] < spell['quantity']) && (spell['quantity'] >= dialog.parent.user_data['max_displayed_quantity'])) {
            dialog.widgets['comment'].str = dialog.data['widgets']['comment']['ui_name_best_value'];
        } else {
            dialog.widgets['comment'].str = '';
        }
    }


    //dialog.widgets['price_display'].bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    //if(payment_currency == 'kgcredits') {
    //dialog.widgets['price_display'].state = 'kgcredits';
    //} else {
    //dialog.widgets['price_display'].state = ((display_currency == 'Facebook Credits' && payment_currency == 'fbcredits') || player.get_any_abtest_value('always_show_fbcredits_logo', gamedata['store']['always_show_fbcredits_logo']) ? 'fbcredits' : 'neutral');
    //}

    dialog.widgets['price_display'].str = Store.display_real_currency_amount(display_currency, payment_price, payment_currency, false);
    // manually add " Credits" suffix to Facebook Credits amounts in the list
    if(display_currency == 'Facebook Credits' && payment_currency == 'fbcredits') {
        dialog.widgets['price_display'].str += ' Credits';
    } else if(display_currency == 'Kongregate Kreds' && payment_currency == 'kgcredits') {
        dialog.widgets['price_display'].str += ' Kreds';
    }

    if(payment_price >= 0 && !pending) {
        dialog.widgets['bg'].state = 'normal';
        dialog.widgets['bg'].onclick = (function (spname, _spellarg, _order, _alloy_qty, _payment_price, _payment_currency) { return function(widget) {
            var dialog = widget.parent;
            if(dialog.parent.user_data['pending']) { return; }

            if(_order && (player.resource_state['gamebucks'] + _alloy_qty) < _order['price']) {
                // don't attempt continuation order if alloy amount would be insufficient
                _order = null;
            }

            metric_event('4440_buy_gamebucks_init_payment', {'gui_version': dialog.parent.user_data['ver'], 'purchase_ui_event': true, 'client_time': Math.floor(client_time),
                                                             'sku': spname,
                                                             'gamebucks': _alloy_qty,
                                                             'currency': _payment_currency,
                                                             'currency_price': _payment_price});
            var credits_props = {'no_clear': true};
            var gift_order = dialog.parent.user_data['chapter'] == 'gifts' && dialog.parent.user_data['gift_order'];
            if(gift_order) {
                // fill in amount here
                gift_order['gifts'][0]['gamebucks'] = _alloy_qty;
                credits_props['gift_order'] = gift_order;
            }

            var credits_cb = (function (_widget, __order) { return function() {
                var dialog = _widget.parent;
                if(dialog) {
                    dialog.parent.user_data['pending'] = false;
                    close_parent_dialog(dialog); // get rid of buy gamebucks dialog
                }

                if(__order && player.resource_state['gamebucks'] >= __order['price']) {
                    // re-attempt the original order
                    if(Store.place_gamebucks_order(__order['price'], __order['unit_id'], __order['spellname'], __order['spellarg'], __order['cb'] || null)) {
                        invoke_ui_locker();
                    }
                }
            }; })(widget, _order);

            var placer = (function (_dialog, __payment_currency, _spname, _spellarg, _credits_cb, _credits_props) { return function() {
                _dialog.widgets['glowfx'].show = true;
                _dialog.widgets['glowfx'].reset_fx();

                if(SPay.api != 'fbcredits' && player.get_any_abtest_value('lock_buy_gamebucks_dialog_during_payment', gamedata['store']['lock_buy_gamebucks_dialog_during_payment'])) {
                    // lock dialog
                    _dialog.parent.user_data['pending'] = true;
                    _credits_props['fail_cb'] = (function (__dialog) { return function() {
                        // unlock dialog on fail as well as success
                        __dialog.parent.user_data['pending'] = false;
                    }; })(_dialog);
                }
                Store.place_order(__payment_currency, GameObject.VIRTUAL_ID, _spname, _spellarg, _credits_cb, _credits_props);
            }; })(dialog, _payment_currency, spname, spellarg, credits_cb, credits_props);

            if(gift_order) {
                invoke_confirm_gift_order_dialog(gift_order, placer);
            } else {
                placer();
            }
        }; })(spellname, spellarg, dialog.parent.user_data['order'], alloy_qty, payment_price, payment_currency);
    } else {
        dialog.widgets['bg'].state = 'disabled';
        dialog.widgets['bg'].onclick = null;
    }
}


// utility to completely lock up the UI until server catches up, with optional cb to call after we close
/** @param {number|null=} sync_marker
    @param {function()=} cb */
function invoke_ui_locker(sync_marker, cb) {
    if(!sync_marker && (sync_marker !== 0)) { sync_marker = synchronizer.request_sync(); }
    var dialog_data = gamedata['dialogs']['ui_locker'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'ui_locker';
    dialog.user_data['sync_marker'] = sync_marker;
    dialog.user_data['cb'] = cb || null;
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = dialog_data['modal'];
    dialog.ondraw = update_ui_locker;
    return dialog;
}
function update_ui_locker(dialog) {
    if(synchronizer.is_in_sync(dialog.user_data['sync_marker'])) {
        var cb = dialog.user_data['cb'];
        close_parent_dialog(dialog.widgets['loading_rect']);
        if(cb) { cb(); }
    }
}

function invoke_item_discovered(items, duration) {
    // skip if using fast modal looting
    if(loot_dialog_fast_anim) {
        // awkward - delay so that the following LOOT_BUFFER_UPDATE takes effect
        window.setTimeout(function() { invoke_loot_dialog(gamedata['strings']['combat_messages']['item_discovered']); }, 1);
        return null;
    }

    var dialog_data = gamedata['dialogs']['item_discovered'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'item_discovered';
    dialog.user_data['anim_start_time'] = -1;
    install_child_dialog(dialog);
    dialog.modal = true;
    dialog.auto_center();

    var exp_days = duration / (24*60*60);
    if(exp_days < 0) {
        dialog.widgets['expiry'].show = false;
    } else {
        dialog.widgets['expiry'].str = dialog.data['widgets']['expiry']['ui_name'].replace('%d', exp_days.toFixed(0));
    }

    var item = items[0];
    var spec = gamedata['items'][item['spec']];
    var sku = dialog.widgets['sku'];
    sku.widgets['name'].set_text_with_linebreaking(ItemDisplay.get_inventory_item_ui_name(spec));
    ItemDisplay.set_inventory_item_asset(sku.widgets['icon'], spec);
    ItemDisplay.set_inventory_item_stack(sku.widgets['icon_stack'], spec, item);
    sku.widgets['price_icon'].show = false;
    sku.widgets['price_display'].text_offset = [0,0];
    var rarity = (spec['rarity'] || 0);
    sku.widgets['price_display'].str = gamedata['strings']['rarities'][rarity+1].toUpperCase();
    var col = gamedata['client']['loot_rarity_colors'][rarity+1];
    sku.widgets['price_display'].text_color = new SPUI.Color(col[0], col[1], col[2], 1);
    sku.widgets['glowfx'].show = true;
    sku.widgets['glowfx'].reset_fx();
    sku.widgets['slot0,0'].show = true;
    sku.widgets['jewel'].show = false;

    sku.user_data['context'] = null;

    if(player.get_any_abtest_value('modal_looting', gamedata['modal_looting'])) {
        // modal looting - turn off extra stuff, and no onhover tip, no animation
        dialog.widgets['subtitle'].show = dialog.widgets['expiry'].show = dialog.widgets['store_soon'].show = false;
        dialog.widgets['close_button'].str = dialog.data['widgets']['close_button']['ui_name_modal'];
        dialog.widgets['close_button'].onclick = function(w) {
            close_parent_dialog(w);
            invoke_loot_dialog(); // immediate
        };
    } else {
        // nonmodal looting
        dialog.widgets['close_button'].onclick = close_item_discovered;
        sku.widgets['icon_frame'].onenter = (function (_item) { return function(w) {
            var dialog = w.parent;
            if(dialog.user_data['context']) { return; }
            invoke_inventory_context(dialog, w, 0, _item, false);
            // set transparent so that onleave is always called reliably
            if(dialog.user_data['context']) { dialog.user_data['context'].transparent_to_mouse = true; }
        }; })(item);
        sku.widgets['icon_frame'].onleave_cb = (function (_item) { return function(w) {
            var dialog = w.parent;
            if(dialog.user_data['context']) { invoke_inventory_context(dialog, w, -1, null, false); }
        }; })(item);
        dialog.ondraw = animate_item_discovered;
    }


    return dialog;
}
function close_item_discovered(widget) {
    var dialog = widget.parent;
    if(dialog.user_data['anim_start_time'] < 0) {
        dialog.user_data['anim_start_time'] = client_time;
    }
}

function animate_item_discovered(dialog) {
    if(dialog.user_data['anim_start_time'] < 0) { return; }

    var ANIM_TIME = player.get_any_abtest_value('valentina_dialog_anim_time', gamedata['client']['valentina_dialog_anim_time']);

    var progress = clamp((client_time - dialog.user_data['anim_start_time'])/ANIM_TIME, 0, 1);
    if(ANIM_TIME < 0 || dialog.user_data['anim_start_time'] < 0) { progress = 1; }

    var bottom = desktop_dialogs['desktop_bottom'];
    var valentina = bottom.widgets['missions_button'];
    if(!valentina) { progress = 1; }

    dialog.modal = 1-progress;

    if(progress >= 1) {
        close_parent_dialog(dialog.widgets['close_button']);
    } else if(progress > 0) {
        dialog.widgets['bg_blanker'].show = false;
        // zoom into valentina
        progress = 1 - progress;
        progress = Math.pow(progress,2.0);
        var scale = progress;
        // centerpoint of scale effect
        var pivot = vec_add(dialog.xy, vec_scale(0.5, dialog.wh));
        // where centerpoint is at start of animation
        var startpos = vec_add(vec_add(bottom.xy, valentina.xy), vec_scale(0.5, valentina.wh));
        // where centerpoint is at end of animation
        var endpos = pivot;
        //startpos = [0,0]; endpos = [0,0];
        var origin = vec_add(startpos, vec_scale(progress, vec_sub(endpos, startpos)));

        dialog.transform = [scale, 0,
                            0, scale,
                            origin[0] + scale*(-origin[0]), origin[1] + scale*(-origin[1])];
    }
}

function invoke_new_store_dialog() {
    var dialog_data = gamedata['dialogs']['new_store_dialog'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'new_store_dialog';
    install_child_dialog(dialog);
    dialog.modal = true;
    dialog.auto_center();
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.user_data['categories'] = [];

    for(var i = 0; i < gamedata['store']['catalog'].length; i++) {
        var cat = gamedata['store']['catalog'][i];
        if('activation' in cat && !read_predicate(cat['activation']).is_satisfied(player,null)) { continue; }
        dialog.user_data['categories'].push(cat);
    }

    var i = 0, grid_x = 0, grid_y = 0;
    for(; i < Math.min(dialog.data['widgets']['cat']['array'][0]*dialog.data['widgets']['cat']['array'][1], dialog.user_data['categories'].length); i++) {
        var cat = dialog.user_data['categories'][i];
        var d = dialog.widgets['cat'+grid_x.toString()+','+grid_y.toString()];
        d.show = true;
        d.user_data['category'] = cat;
        d.widgets['icon'].asset = cat['icon'];
        d.widgets['label'].str =  cat['ui_name'];
        d.widgets['bg'].onclick = function(w) {
            var d = w.parent;
            close_parent_dialog(w.parent);
            invoke_new_store_category(d.user_data['category']);
        };
        d.widgets['jewel'].user_data['count'] = 0;
        d.widgets['jewel'].ondraw = update_notification_jewel;
        d.ondraw = update_new_store_category_label;
        grid_x += 1;
        if(grid_x >= dialog.data['widgets']['cat']['array'][0]) {
            grid_x = 0;
            grid_y += 1;
        }
    }
    while(grid_y < dialog.data['widgets']['cat']['array'][1]) {
        while(grid_x < dialog.data['widgets']['cat']['array'][0]) {
            dialog.widgets['cat'+grid_x.toString()+','+grid_y.toString()].show = false;
            grid_x += 1;
        }
        grid_x = 0;
        grid_y += 1;
    }

    dialog.ondraw = update_new_store;
    return dialog;
}

function update_new_store(dialog) {
    // how big can we be?
    var new_width = canvas_width - 2*dialog.data['margin'][0];
    new_width = clamp(new_width, dialog.data['dimensions'][0], dialog.data['max_dimensions'][0]);
    dialog.wh = [new_width, dialog.data['dimensions'][1]];
    dialog.on_resize(); // reset centering
    dialog.apply_layout(); // adjust miscellaneous widgets

    // lay out category labels
    var slen = dialog.user_data['categories'].length.toString();
    if(!(slen in dialog.data['positions'])) {
        throw Error('unhandled number of store categories: '+slen);
    }
    var POSITIONS = dialog.data['positions'][slen];
    var i = 0, grid_x = 0, grid_y = 0;

    for(; i < Math.min(dialog.data['widgets']['cat']['array'][0]*dialog.data['widgets']['cat']['array'][1], dialog.user_data['categories'].length); i++) {
        var cat = dialog.user_data['categories'][i];
        var d = dialog.widgets['cat'+grid_x.toString()+','+grid_y.toString()];
        // set position, correcting for resizing
        d.xy = vec_add(POSITIONS[i], vec_floor(vec_scale(0.5, vec_sub(dialog.widgets['sunken'].wh, dialog.data['widgets']['sunken']['dimensions']))));
        d.user_data['base_xy'] = [d.xy[0], d.xy[1]];
        grid_x += 1;
        if(grid_x >= dialog.data['widgets']['cat']['array'][0]) {
            grid_x = 0;
            grid_y += 1;
        }
    }
}

function update_new_store_category_label(d) {
    var hi = (d.mouse_enter_time > 0);
    d.xy[1] = d.user_data['base_xy'][1] - (hi && !d.widgets['bg'].pushed ? 1 : 0);

    d.widgets['icon_glow'].xy = vec_copy(d.data['widgets']['icon_glow']['xy'+ (d.widgets['bg'].pushed ? '_pushed' : '')]);
    d.widgets['icon_glow'].wh = vec_copy(d.data['widgets']['icon_glow']['dimensions'+ (d.widgets['bg'].pushed ? '_pushed' : '')]);
    d.widgets['icon_glow'].alpha = (hi ? (d.widgets['bg'].pushed ? 0.66 : 0.2) : 0);
    d.widgets['icon_glow'].asset = d.data['widgets']['icon_glow']['asset'+(d.widgets['bg'].pushed ? '_pushed': '')];
    d.widgets['bg_shine'].alpha = (hi ? (d.widgets['bg'].pushed ? 1 : 0.66 ) : 0.5);
    d.widgets['label_bg_shine'].alpha = 0.8 * d.widgets['bg_shine'].alpha;

    var count = 0;

    if(player.get_any_abtest_value('enable_store_jewel', gamedata['store']['enable_store_jewel'])) {
        if('jewel' in d.user_data['category'] && read_predicate(d.user_data['category']['jewel']).is_satisfied(player, null)) { // jewel on category itself - unusual
            count += 1;
        }
        for(var isku = 0; isku < d.user_data['category']['skus'].length; isku++) {
            var skudata = d.user_data['category']['skus'][isku];
            if(new_store_allow_sku(skudata)) {
                if('jewel' in skudata) {
                    if(read_predicate(skudata['jewel']).is_satisfied(player, null)) {
                        count += 1;
                    }
                }
            }
        }
    }
    d.widgets['jewel'].user_data['count'] = count;
    d.widgets['jewel_new'].show = (count > 0);
}

function new_store_allow_sku(skudata) {
    if('show_if' in skudata && !read_predicate(skudata['show_if']).is_satisfied(player, null)) {
        return false;
    }
    if('spell' in skudata) {
        var spell = gamedata['spells'][skudata['spell']];
        if('new_store_requires' in spell && !read_predicate(spell['new_store_requires']).is_satisfied(player, null)) {
            return false;
        }
    } else if('item' in skudata) {
        var spec = gamedata['items'][skudata['item']];
        if('store_requires' in spec && !read_predicate(spec['store_requires']).is_satisfied(player, null)) {
            return false;
        }
    }
    if(('start_time' in skudata) && (player.get_absolute_time() < skudata['start_time'])) { return false; }
    if(('expire_time' in skudata) && (player.get_absolute_time() >= skudata['expire_time'])) { return false; }

    return true;
}

/** @param {Object} catdata
    @param {(Array.<{cat:Object, sku_name:(string|null|undefined), pos:(number|null|undefined)}>|null)=} parent_catdata
        this is a list of the catdatas on the hierarchical path to this category
        PLUS either a sku name or literal scroll position to scroll to when stepping back up the hierarchy
    @param {string|null=} scroll_to_sku_name - "name" string of a spell, item, or subcategory to scroll to upon opening the category. null to ignore.
    @param {number|null=} scroll_to_pos - explicit initial scroll position. Overrides scroll_to_sku_name. null to ignore.
*/
function invoke_new_store_category(catdata, parent_catdata, scroll_to_sku_name, scroll_to_pos) {
    scroll_to_sku_name = scroll_to_sku_name || null;
    scroll_to_pos = (typeof scroll_to_pos == 'undefined' ? null : scroll_to_pos);

    var dialog_data = gamedata['dialogs']['new_store_category'];
    var dialog = new SPUI.Dialog(dialog_data);
    dialog.user_data['dialog'] = 'new_store_category';
    dialog.user_data['catdata'] = catdata;
    if(parent_catdata && parent_catdata.length < 1) { parent_catdata = null; } // code below expects parent_catdata to be null instead of []
    dialog.user_data['parent_catdata'] = parent_catdata || null;

    var skulist = [];

    if('record_feature_use' in catdata) {
        player.record_feature_use(catdata['record_feature_use'].replace('%WEEK', current_pvp_week().toFixed(0)));
    }

    for(var i = 0; i < catdata['skus'].length; i++) {
        var skudata = catdata['skus'][i];
        if(!new_store_allow_sku(skudata)) { continue; }
        skulist.push(skudata);
    }

    // add extra special item SKUs from A/B tests
    if(catdata['name'] == 'specials') {
        for(var test_name in player.abtests) {
            var group = player.abtests[test_name];
            if(test_name in gamedata['abtests'] && gamedata['abtests'][test_name]['active'] && (group in gamedata['abtests'][test_name]['groups'])) {
                var data = gamedata['abtests'][test_name]['groups'][group];
                if('extra_store_specials' in data) {
                    var extras = data['extra_store_specials'];
                    for(var i = 0; i < extras.length; i++) {
                        if(new_store_allow_sku(extras[i])) {
                            skulist.push(extras[i]);
                        }
                    }
                }
            }
        }
    }

    dialog.user_data['skulist'] = skulist;
    install_child_dialog(dialog);
    dialog.modal = true;
    dialog.auto_center();

    var ui_name = '';
    if(parent_catdata) {
        goog.array.forEach(parent_catdata, function(data, idx) {
            if(data.cat['ui_name']) { // toplevel catalog does not have a ui_name
                ui_name = ui_name + (idx != 0 ? ' :: ' : '') + data.cat['ui_name'];
            }
        });
    }
    ui_name += (ui_name.length != 0 ? ' :: ' : '') + catdata['ui_name'];

    dialog.widgets['title_bold'].str = dialog.data['widgets']['title_bold']['ui_name'].replace('%s', ui_name);
    dialog.widgets['close_button'].onclick = close_parent_dialog;
    dialog.widgets['back_button'].onclick = function(w) {
        var parent_catdata = w.parent.user_data['parent_catdata'];
        close_parent_dialog(w);
        if(parent_catdata && parent_catdata.length > 0 && parent_catdata[0].cat['ui_name']) { // note: toplevel catalog does not have a ui_name
            // invoke parent category
            invoke_new_store_category(parent_catdata[parent_catdata.length-1].cat, (parent_catdata.length > 1 ? parent_catdata.slice(0, parent_catdata.length-1) : null),
                                      parent_catdata[parent_catdata.length-1].sku_name || null, parent_catdata[parent_catdata.length-1].pos || null);
        } else {
            // go back to top level
            invoke_new_store_dialog();
        }
    };

    if(('activation' in catdata) && !read_predicate(catdata['activation']).is_satisfied(player,null)) {
        // illegal category - punt
        dialog.widgets['back_button'].onclick(dialog.widgets['back_button']);
        return null;
    }

    dialog.widgets['resource_bar_fbcredits_button'].onclick = Store.get_balance_plus_cb();

    dialog.user_data['open_time'] = client_time;

    // the index of a SKU to show in the center as soon as the dialog opens
    // null for no scrolling (0 means "center first SKU")
    dialog.user_data['initial_scroll'] = null;
    dialog.user_data['initial_scroll_exact'] = false;
    if(scroll_to_pos !== null) {
        // convert from pixels to SKU index units
        dialog.user_data['initial_scroll'] = scroll_to_pos / dialog.data['widgets']['sku']['array_offset'][0];
        dialog.user_data['initial_scroll_exact'] = true;
    } else if(scroll_to_sku_name) {
        dialog.user_data['initial_scroll'] = goog.array.findIndex(skulist, function(entry) {
            return ((('name' in entry) && entry['name'] === scroll_to_sku_name) ||
                    (('item' in entry) && entry['item'] === scroll_to_sku_name) ||
                    (('spell' in entry) && entry['spell'] === scroll_to_sku_name));
        });
        if(dialog.user_data['initial_scroll'] < 0) {
            dialog.user_data['initial_scroll'] = null;
            console.log("invoke_new_store_category(): did not find scroll_to_sku_name: "+scroll_to_sku_name);
        }
    }
    dialog.user_data['scroll_pos'] = dialog.user_data['scroll_goal'] = 0;
    dialog.user_data['scrolled'] = false;

    dialog.widgets['scroll_left'].onclick = function (w) { new_store_category_scroll(w.parent, -1); };
    dialog.widgets['scroll_right'].onclick = function (w) { new_store_category_scroll(w.parent, 1); };
    dialog.widgets['scroll_left_jewel'].ondraw =
        dialog.widgets['scroll_right_jewel'].ondraw = update_notification_jewel;
    dialog.widgets['scroll_left_jewel'].user_data['count'] =
        dialog.widgets['scroll_right_jewel'].user_data['count'] = 0;

    var default_sku_index = -1;
    var default_sku_priority = -1;

    var i = 0;
    for(; i < skulist.length; i++) {
        var skudata = skulist[i];

        if(('ui_new_store_enterkey_priority' in skudata) && (skudata['ui_new_store_enterkey_priority'] > default_sku_priority)) {
            default_sku_priority = skudata['ui_new_store_enterkey_priority'];
            default_sku_index = i;
        }

        var d = new SPUI.Dialog(gamedata['dialogs'][dialog.data['widgets']['sku']['dialog']]);
        dialog.add(d);
        dialog.widgets['sku'+i.toString()] = d;

        d.user_data['skudata'] = skudata;
        d.user_data['ui_index'] = i;

        d.user_data['catpath'] = [];
        if(parent_catdata) {
            goog.array.forEach(parent_catdata, function(data) {
                d.user_data['catpath'].push(data.cat['name']);
            });
        }
        d.user_data['catpath'].push(catdata['name']);

        d.user_data['base_xy'] = [d.xy[0], d.xy[1]];
        d.user_data['pending'] = -1;
        d.user_data['context'] = null;
        d.user_data['anim_start'] = client_time + d.data['widgets']['info']['blink_offset'] * i;
        d.user_data['sound_start'] = -1;

        var banner_text = ('ui_banner' in skudata ? eval_cond_or_literal(skudata['ui_banner'], player, null) : null);
        d.widgets['sale_bg'].show = d.widgets['sale_label'].show = (!!banner_text && (banner_text.length > 0));
        d.widgets['sale_label'].str = banner_text;
        if(banner_text in d.data['widgets']['sale_label']['xy_shift']) {
            d.widgets['sale_label'].xy = vec_add(d.data['widgets']['sale_label']['xy'], d.data['widgets']['sale_label']['xy_shift'][banner_text]);
        }

        d.widgets['icon_frame'].onclick = null;
        d.widgets['icon_frame'].transparent_to_mouse = true;
        d.widgets['slot0,0'].show = true;

        var tip_item = null;

        if('spell' in skudata) {
            var spell = gamedata['spells'][skudata['spell']];
            d.widgets['name'].set_text_with_linebreaking(skudata['ui_name'] || spell['ui_new_store_name'] || spell['ui_name']);
            d.widgets['icon'].asset = spell['new_store_icon'] || spell['icon'];

            if('new_store_tip_item' in spell) {
                // create a "virtual" fake item for showing on the tooltip
                tip_item = {'spec':spell['new_store_tip_item'] };
            }
        } else if('item' in skudata) {
            var spec = gamedata['items'][skudata['item']];
            var stack = ('stack' in skudata ? skudata['stack'] : 1);
            tip_item = {'spec': skudata['item'], 'stack': stack};
            if('melt_duration' in skudata) {
                tip_item['melt_duration'] = skudata['melt_duration'];
            }
            if('melt_time' in skudata) {
                tip_item['expire_time'] = skudata['melt_time'];
            }

            var fallback_name = ItemDisplay.get_inventory_item_stack_prefix(spec, stack) + ItemDisplay.get_inventory_item_ui_name(spec);

            d.widgets['name'].set_text_with_linebreaking(('ui_name' in skudata ? skudata['ui_name'] : fallback_name));
            ItemDisplay.set_inventory_item_asset(d.widgets['icon'], spec);
            ItemDisplay.set_inventory_item_stack(d.widgets['icon_stack'], spec, tip_item);
        } else if('name' in skudata) {
            // hierarchical child category

            // change a few widget settings to look better as a category
            d.widgets['folder_icon'].show = true;
            d.widgets['icon_frame'].state = 'normal_nohighlight'; // disable onhover highlight on the icon
            d.widgets['name'].text_hjustify = d.widgets['name'].text_vjustify = 'center';
            d.widgets['name'].text_color = SPUI.make_colorv(d.data['widgets']['name']['text_color_category']);
            d.widgets['name'].font = SPUI.make_font(d.data['widgets']['name']['text_size_category'], d.data['widgets']['name']['text_size_category']+3, d.data['widgets']['name']['text_style']);
            d.widgets['name'].set_text_with_linebreaking(skudata['ui_name']);
            d.user_data['icon_assets'] = [];
            if('icon' in skudata) {
                d.user_data['icon_assets'].push(skudata['icon']);
            } else {
                // get icons from child items

                // first pass - uncollected items
                var stack = [skudata];
                while(stack.length > 0) {
                    var sku = stack.pop();
                    if('icon' in sku) {
                        d.user_data['icon_assets'].push(sku['icon']);
                    } else if('skus' in sku) {
                        stack = stack.concat(sku['skus']);
                    } else if('item' in sku && ('icon' in gamedata['items'][sku['item']])) {
                        if('collected' in sku && read_predicate(sku['collected']).is_satisfied(player, null)) { continue; }
                        d.user_data['icon_assets'].push(gamedata['items'][sku['item']]['icon']);
                    }
                }

                // second pass - all items
                if(d.user_data['icon_assets'].length < 1) {
                    stack = [skudata];
                    while(stack.length > 0) {
                        var sku = stack.pop();
                        if('icon' in sku) {
                            d.user_data['icon_assets'].push(sku['icon']);
                        } else if('skus' in sku) {
                            stack = stack.concat(sku['skus']);
                        } else if('item' in sku && ('icon' in gamedata['items'][sku['item']])) {
                            d.user_data['icon_assets'].push(gamedata['items'][sku['item']]['icon']);
                        }
                    }
                    if(d.user_data['icon_assets'].length < 1) {
                        d.user_data['icon_assets'].push('inventory_unknown');
                    }
                }
            }

            d.widgets['price_icon'].show =
                d.widgets['price_display'].show = false;
            goog.array.forEach(['info','name','name_bg','bg_shine','price_bg','price_bg_shine'], function(wname) {
                d.widgets[wname].xy = vec_copy(d.data['widgets'][wname]['xy_category']);
                d.widgets[wname].wh = vec_copy(d.data['widgets'][wname]['dimensions_category']);
                if('gradient_color_category' in d.data['widgets'][wname]) {
                    d.widgets[wname].gradient_color = SPUI.make_colorv(d.data['widgets'][wname]['gradient_color_category']);
                }
            });
        }

        if(tip_item) {
            d.widgets['icon_frame'].onenter = (function (_item, _skudata) { return function(w) {
                var dialog = w.parent;
                if(dialog.user_data['context']) { return; }

                if(dialog.user_data['sound_start'] < client_time - 1) {
                    dialog.user_data['sound_start'] = client_time;
                    if('mouseover_effect' in _skudata) {
                        SPFX.add_visual_effect([0,0], 0, [0,1,0], client_time, _skudata['mouseover_effect'], true, null);
                    } else {
                        var assetname = ('mouseover_sound' in _skudata ? _skudata['mouseover_sound'] : 'mouseover_button_sound');
                        GameArt.assets[assetname].states['normal'].audio.play(client_time);
                    }
                }

                //w.state = 'active';

                // note: parent the context tooltip to the
                // new_store_category dialog, not the SKU, so that it
                // appears in the top of the Z order

                invoke_inventory_context(dialog, w, 0, _item, false, {'parent_dialog': dialog.parent});

                // set transparent so that onleave is always called reliably
                if(dialog.user_data['context']) { dialog.user_data['context'].transparent_to_mouse = true; }
            }; })(tip_item, skudata);
            d.widgets['icon_frame'].onleave_cb = (function (_item) { return function(w) {
                var dialog = w.parent;
                //w.state = 'normal';
                if(dialog.user_data['context']) {
                    invoke_inventory_context(dialog, w, -1, null, false);
                }
            }; })(tip_item);
        }

        d.widgets['jewel'].user_data['count'] = 0;
        d.widgets['jewel'].ondraw = update_notification_jewel;

        d.ondraw = update_new_store_sku;
        d.ondraw(d);
    }

    if(default_sku_index >= 0) {
        // on Enter keypress, send click to default sku
        dialog.widgets['default_button'].onclick = (function (_index) { return function(w) {
            var d = w.parent.widgets['sku'+_index.toString()];
            if(d.widgets['bg'].state != 'disabled') {
                d.widgets['bg'].onclick(d.widgets['bg']);
            }
        }; })(default_sku_index);
    } else {
        dialog.widgets['default_button'].onclick = null;
    }

    dialog.ondraw = update_new_store_category;
    return dialog;
}

// recalculate scroll limits and goal. incr +/- 1 to go left and right, 0 to just recalculate in place.
function new_store_category_scroll(dialog, incr) {
    var skulist = dialog.user_data['skulist'];

    // how much horizontal space do we need for ALL SKUs?
    var extent = skulist.length * dialog.data['widgets']['sku']['array_offset'][0] + dialog.data['widgets']['sku']['xy'][0] + 3;

    if(extent > dialog.widgets['sunken'].wh[0]) {
        // we have more SKUs than space
        dialog.user_data['scroll_limits'] = [0, Math.max(0, extent - dialog.widgets['sunken'].wh[0])];

        // correct the initial_scroll index to put that SKU in the center, not at the left edge
        if(dialog.user_data['initial_scroll'] !== null && !dialog.user_data['initial_scroll_exact']) {
            // add/subtract as necessary to center this SKU
            dialog.user_data['initial_scroll'] = dialog.user_data['initial_scroll'] - Math.floor((dialog.widgets['sunken'].wh[0]/dialog.data['widgets']['sku']['array_offset'][0])/2 - 0.5);
        }
    } else {
        // we have more space than SKUs - just center everything
        var left_edge = Math.floor((dialog.widgets['sunken'].wh[0] - extent)/2);
        dialog.user_data['scroll_limits'] = [-left_edge, -left_edge];
        dialog.user_data['initial_scroll'] = null; // no need to scroll anywhere
    }

    // note: this part only runs on the very first call after the dialog opens
    if(dialog.user_data['initial_scroll'] !== null) {
        var initial_scroll = dialog.user_data['initial_scroll'];
        dialog.user_data['initial_scroll'] = null;
        dialog.user_data['scrolled'] = true;
        // immediately snap scroll position
        dialog.user_data['scroll_pos'] = dialog.user_data['scroll_goal'] = clamp(initial_scroll * dialog.data['widgets']['sku']['array_offset'][0],
                                                                                 dialog.user_data['scroll_limits'][0], dialog.user_data['scroll_limits'][1]);
    }

    if(incr != 0) { // move left or right
        dialog.user_data['scroll_goal'] = dialog.user_data['scroll_goal']+dialog.data['widgets']['sku']['array_offset'][0]*incr;
        dialog.user_data['scrolled'] = true;
    }

    // ensure goal is in bounds
    dialog.user_data['scroll_goal'] = clamp(dialog.user_data['scroll_goal'], dialog.user_data['scroll_limits'][0], dialog.user_data['scroll_limits'][1]);

    // set button clickability
    dialog.widgets['scroll_left'].state = (dialog.user_data['scroll_goal'] <= dialog.user_data['scroll_limits'][0] ? 'disabled' : 'normal');
    dialog.widgets['scroll_right'].state = (dialog.user_data['scroll_goal'] >= dialog.user_data['scroll_limits'][1] ? 'disabled' : 'normal');
};

function update_new_store_category(dialog) {
    update_resource_bars(dialog, false, false, true);
    var skulist = dialog.user_data['skulist'];

    // first resize the dialog itself, then worry about scrolling calculations

    // how big can we be?
    var new_width = canvas_width - 2*dialog.data['margin'][0];
    new_width = clamp(new_width, dialog.data['dimensions'][0], dialog.data['max_dimensions'][0]);
    dialog.wh = [new_width, dialog.data['dimensions'][1]];
    dialog.on_resize(); // reset centering
    dialog.apply_layout(); // adjust miscellaneous widgets

    // perform scroll limit/goal calculations without moving left or right
    new_store_category_scroll(dialog, 0);

    if(!dialog.user_data['scrolled'] &&
       ((client_time - dialog.user_data['open_time']) < gamedata['store']['store_scroll_flash_time']) &&
       player.get_any_abtest_value('enable_store_scroll_flash', gamedata['store']['enable_store_scroll_flash'])) {
        if(dialog.widgets['scroll_right'].state != 'disabled') {
            dialog.widgets['scroll_right'].state = ((((client_time/gamedata['store']['store_scroll_flash_period']) % 1) >= 0.5) ? 'highlight' : 'normal');
        }
    }

    // adjust smooth scrolling position
    if(dialog.user_data['scroll_limits'][0] == dialog.user_data['scroll_limits'][1]) {
        // if window is wider than needed to show all SKUs, just snap to the centered position
        dialog.user_data['scroll_pos'] = dialog.user_data['scroll_limits'][0];
    } else if(dialog.user_data['scroll_pos'] != dialog.user_data['scroll_goal']) {
        // exponential movement
        var delta = dialog.user_data['scroll_goal'] - dialog.user_data['scroll_pos'];
        var sign = (delta > 0 ? 1 : -1);
        dialog.user_data['scroll_pos'] += sign * Math.floor(0.20 * Math.abs(delta) + 0.5);
    }

    dialog.widgets['scroll_left'].show = dialog.widgets['scroll_right'].show =
        (skulist.length * dialog.data['widgets']['sku']['array_offset'][0] >= dialog.widgets['sunken'].wh[0]);

    dialog.widgets['scroll_left_jewel'].show = dialog.widgets['scroll_right_jewel'].show =
        dialog.widgets['scroll_left'].show && player.get_any_abtest_value('enable_store_jewel', gamedata['store']['enable_store_jewel']);

    var left_jewels = 0, right_jewels = 0; // count number of jeweled SKUs to the left and right of the window

    // adjust child SKU dialogs
    for(var i = 0; i < skulist.length; i++) {
        var w = dialog.widgets['sku'+i.toString()];
        var skudata = w.user_data['skudata'];

        if(!new_store_allow_sku(skudata)) { // a predicate changed, or something else made it want to disappear
            w.show = false;
            continue;
        }

        // left/right scrolling
        w.user_data['base_xy'][0] = i*dialog.data['widgets']['sku']['array_offset'][0] - dialog.user_data['scroll_pos'] + dialog.data['widgets']['sku']['xy'][0];
        w.user_data['base_xy'][1] = dialog.data['widgets']['sku']['xy'][1];

        // set clipping
        w.clip_to = [dialog.widgets['sunken'].xy[0], dialog.widgets['sunken'].xy[1],
                     dialog.widgets['sunken'].wh[0], dialog.widgets['sunken'].wh[1]];

        if(('jewel' in skudata) && read_predicate(skudata['jewel']).is_satisfied(player, null)) {
            if(w.user_data['base_xy'][0] + 0.66*w.wh[0] < 0) { left_jewels += 1; }
            if(w.user_data['base_xy'][0] + 0.33*w.wh[0] >= dialog.widgets['sunken'].xy[0] + dialog.widgets['sunken'].wh[0]) { right_jewels += 1; }
        }
    }

    dialog.widgets['scroll_left_jewel'].user_data['count'] = left_jewels;
    dialog.widgets['scroll_right_jewel'].user_data['count'] = right_jewels;
}

function update_new_store_sku(d) {
    var pending = (d.user_data['pending'] > client_time);
    var skudata = d.user_data['skudata'];
    var price = -1, shown_price = -1, sale_currency = Store.get_user_currency(), buyable = true; // buyable means "show hider if 'requires' predicate is false"
    var set_completed = false;
    var info_str = null, info_col = 'ok', info_small = false, info_high = false;
    var helper = null, child_catdata = null;

    d.widgets['cooldown_label'].show = d.widgets['cooldown_time'].show = false;

    var count = 0;
    if(player.get_any_abtest_value('enable_store_jewel', gamedata['store']['enable_store_jewel'])) {
        if(('jewel' in skudata) && read_predicate(skudata['jewel']).is_satisfied(player, null)) {
            count += 1;
        }
    }
    d.widgets['jewel'].user_data['count'] = count;

    if('spell' in skudata) {
        var spell = gamedata['spells'][skudata['spell']];
        var pred = (('requires' in spell) ? read_predicate(spell['requires']) : null);
        var tip_item = ('new_store_tip_item' in spell ? {'spec':spell['new_store_tip_item']} : null);
        var tip_item_spec = (tip_item ? ItemDisplay.get_inventory_item_spec(tip_item['spec']) : null);
        if('currency' in spell) { sale_currency = spell['currency']; }

        if(tip_item_spec) {
            var subtitle = ItemDisplay.get_inventory_item_ui_subtitle(tip_item_spec);
            if(subtitle) {
                // adding the subtitles here causes too much clutter
                /*
                info_str = subtitle;
                info_high = true; info_small = true;
                */
            }
        }

        price = Store.get_price(sale_currency, GameObject.VIRTUAL_ID, spell, null);
        if(price < 0) {
            // try to display a price even though spell is unavailable
            shown_price = Store.get_price(sale_currency, GameObject.VIRTUAL_ID, spell, null, true);
        } else {
            shown_price = price;
        }

        var formula = spell['price_formula'];
        // ability to purchase is a combination of new-style "requires" predicates
        // plus some ugly legacy code that checks specific price formulas

        if(pred && (price < 0) && !pred.is_satisfied(player, null)) {
            // show reason for unfulfilled predicate
            var req_text = pred.ui_describe(player);
            if(req_text) {
                info_col = 'error';
                info_str = req_text; // d.data['widgets']['info']['ui_name_unmet'].replace('%s', req_text);
                helper = get_requirements_help(pred, null);
            }
            info_high = info_small = false;
            if(formula.indexOf('resource_boost') == 0) {
                shown_price = -1; // do not show "FREE" for unpurchaseable resource boosts
            }
        } else if(formula === 'resource_boost' || formula === 'resource_boost_gamebucks') {
            var resource = spell['resource'];
            var amount;
            if(spell['boost_amount'] < 1) {
                amount = Math.floor(spell['boost_amount'] * player.resource_state[resource][0]);
            } else {
                // full 100% boost
                amount = player.resource_state[resource][0] - player.resource_state[resource][1];
            }
            amount = Math.max(amount, 0);

            if(price >= 0) {
                info_col = 'ok';
                info_str = pretty_print_number(amount) + ' ' + (gamedata['resources'][resource]['ui_name']);
                info_high = info_small = false;
            } else {
                info_col = 'error';
                info_str = d.data['widgets']['info']['ui_name_not_enough_room'];
                if(amount <= 0) {
                    shown_price = -1; // don't show "FREE" for a full boost when resources are already full
                }
                info_high = info_small = false;
            }

        } else if(formula.indexOf('grow_base_perimeter') === 0) {
            info_col = (price >= 0 ? 'ok' : 'error');
            var to_level = parseInt(formula[formula.length-1],10);
            if(session.viewing_base.base_size >= to_level) {
                info_str = d.data['widgets']['info']['ui_name_already_upgraded'];
                info_high = info_small = false;
            } else {
                info_high = info_small = (price >= 0);
            }
        } else if(formula.indexOf('barrier_upgrade') === 0) {
            info_col = (price >= 0 ? 'ok' : 'error');
            if(price < 0) {
                info_str = d.data['widgets']['info']['ui_name_already_upgraded'];
            }
            info_high = info_small = false;
        }

        if(('cooldown_name' in spell) && (!info_str || info_high)) {
            var cd_name = spell['cooldown_name'];
            var togo = player.cooldown_togo(cd_name);

            d.widgets['cooldown_label'].show = d.widgets['cooldown_time'].show = true;
            d.widgets['cooldown_label'].str = d.data['widgets']['cooldown_label']['ui_name_'+(togo>0 ? (spell['price'] === 0 ? 'available' : 'rebuy') : 'cd')];

            if(togo > 0) {
                d.widgets['cooldown_time'].str = pretty_print_time(togo);
            } else if('cooldown_origin' in spell) {
                d.widgets['cooldown_label'].str = d.data['widgets']['cooldown_label']['ui_name_expires'];
                d.widgets['cooldown_time'].str = pretty_print_time(spell['cooldown_interval'] - (server_time - spell['cooldown_origin']) % spell['cooldown_interval']);
            } else {
                d.widgets['cooldown_time'].str = pretty_print_time(spell['cooldown']);
                d.widgets['cooldown_time'].text_color = new SPUI.Color(1,0.7,1,1);
            }
            var col = d.data['widgets']['cooldown_time']['text_color_'+(togo > 0 ? 'rebuy':'cd')];
            d.widgets['cooldown_time'].text_color = new SPUI.Color(col[0], col[1], col[2], col[3]);
        }

    } else if('item' in skudata) {
        var pred = (('requires' in skudata) ? read_predicate(skudata['requires']) : null);
        var spec = gamedata['items'][skudata['item']];
        var stack = ('stack' in skudata ? skudata['stack'] : 1);
        var arg = {'catpath': d.user_data['catpath'], 'ui_index': d.user_data['ui_index'], 'skudata':skudata};
        if('price_currency' in skudata) { sale_currency = skudata['price_currency']; }

        if('price' in skudata) {
            price = Store.get_price(sale_currency, GameObject.VIRTUAL_ID, gamedata['spells']["BUY_ITEM"], arg);
            if(price < 0) {
                // try to display a price even though item is unavailable
                shown_price = Store.get_price(sale_currency, GameObject.VIRTUAL_ID, gamedata['spells']["BUY_ITEM"], arg, true);
            } else {
                shown_price = price;
            }
        } else if('ui_availability' in skudata) {
            buyable = false;
            d.widgets['availability'].show = true;
            d.widgets['price_icon'].show = false;
            d.widgets['availability'].set_text_with_linebreaking(skudata['ui_availability']);
        }

        if(pred && (price < 0) && !pred.is_satisfied(player, null)) {
            var req_text = pred.ui_describe(player);
            if(req_text) {
                buyable = true; // DO show hider
                info_small = true;
                info_col = 'error';
                info_str = (('ui_name' in skudata['requires'] || ('ui_name_literal' in skudata['requires']) || ('ui_cooldown_name' in skudata['requires'])) ? req_text : d.data['widgets']['info']['ui_name_unmet'].replace('%s', req_text));
                helper = get_requirements_help(pred, null);
            }
        }

        if(!info_str) {
            var ls = [];
            var subtitle = null;
            if('ui_subtitle' in skudata) {
                subtitle = skudata['ui_subtitle'];
            } else {
                subtitle = ItemDisplay.get_inventory_item_ui_subtitle(spec);
            }
            if(subtitle) { ls.push([subtitle,'ok']); }

            // blink with item set membership
            if(spec['item_set']) {
                var set_spec = gamedata['item_sets'][spec['item_set']];
                var s = d.data['widgets']['info']['ui_name_item_set'].replace('%s', set_spec['ui_name']).replace('%n', (1+set_spec['members'].indexOf(spec['name'])).toString()).replace('%total', set_spec['members'].length.toString());
                ls.push([s,'item_set']);
            }

            if(ls.length > 0) {
                var period = d.data['widgets']['info']['blink_period'];
                var index = (Math.floor(((client_time - d.user_data['anim_start'] + period/2)/period) % ls.length) + ls.length) % ls.length;
                info_str = ls[index][0];
                info_col = ls[index][1];
                info_high = true;
                info_small = true;
            }
        }

        var expire_time = -1;
        if('expire_time' in skudata) {
            expire_time = skudata['expire_time'];
        } else {
            // look to parents for inherited expiration time
            var cat = null;
            var catlist = gamedata['store']['catalog'];
            var catpath = d.user_data['catpath'];
            for(var i = 0; i < catpath.length; i++) {
                cat = goog.array.find(catlist, function (entry) {
                    return (entry['name'] && entry['name'] === catpath[i] &&
                            (!('activation' in entry) || read_predicate(entry['activation']).is_satisfied(player,null)) &&
                            (!('start_time' in entry) || entry['start_time'] < player.get_absolute_time()) &&
                            (!('expire_time' in entry) || entry['expire_time'] >= player.get_absolute_time()));
                });
                if(cat) {
                    // figure out parent's expiration time
                    var etime = -1;
                    if('expire_time' in cat) {
                        etime = cat['expire_time'];
                    } else if('activation' in cat) {
                        etime = read_predicate(cat['activation']).ui_expire_time(player);
                    }
                    if(etime > 0) {
                        expire_time = (expire_time > 0 ? Math.min(expire_time, etime) : etime);
                    }
                } else {
                    break;
                }
                catlist = cat['skus'] || [];
            }
        }

        if(expire_time > 0) {
            if(info_str) { info_high = true; }
            d.widgets['cooldown_label'].show = d.widgets['cooldown_time'].show = true;
            d.widgets['cooldown_label'].str = d.data['widgets']['cooldown_label'][('ui_availability' in skudata ? 'ui_name_availability_ends' : 'ui_name_expires')];
            d.widgets['cooldown_time'].str = pretty_print_time(expire_time - player.get_absolute_time());
            var col = d.data['widgets']['cooldown_time']['text_color_expires'];
            d.widgets['cooldown_time'].text_color = new SPUI.Color(col[0], col[1], col[2], col[3]);
        }
    } else if('name' in skudata) {
        // hierarchical category
        child_catdata = skudata;
        price = shown_price = 0;
        if('ui_info' in skudata) {
            info_col = 'category';
            info_small = true;
            info_str = skudata['ui_info'];
        }

        // blink icon graphic
        var ls = d.user_data['icon_assets'];
        var period = d.data['widgets']['icon']['blink_period'];
        var index = (Math.floor(((client_time - d.user_data['anim_start'] + period/2)/period) % ls.length) + ls.length) % ls.length;
        d.widgets['icon'].asset = ls[index];

        // compute number collected out of all children underneath here
        var set_n = 0, set_total = 0;
        var stack = [skudata];
        while(stack.length > 0) {
            var sku = stack.pop();
            if(new_store_allow_sku(sku)) { // skip SKUs that are not currently shown in store
                if('skus' in sku) { // folder
                    stack = stack.concat(sku['skus']);
                } else if('collected' in sku) { // single SKU
                    set_total += 1;
                    if(read_predicate(sku['collected']).is_satisfied(player, null)) { set_n += 1; }
                }
            }
        }

        if(set_total > 0) {
            d.widgets['category_completion'].show = true;
            d.widgets['category_completion'].str = d.data['widgets']['category_completion']['ui_name'].replace('%n', set_n.toString()).replace('%total', set_total.toString());
            set_completed = (set_n >= set_total);
        }

    } else {
        throw Error('unhandled skudata '+JSON.stringify(skudata));
    }

    d.widgets['info'].show = !!info_str;
    if(info_str) {
        var sz = d.data['widgets']['info']['text_size'], st = d.data['widgets']['info']['text_style'];
        if(info_small) {
            sz = d.data['widgets']['info']['text_size_small'];
            st = d.data['widgets']['info']['text_style_small'];
        }
        d.widgets['info'].font = SPUI.make_font(sz, sz+3, st);
        d.widgets['info'].xy = d.data['widgets']['info']['xy' + (info_high ? '_high' : (child_catdata ? '_category' : ''))];
        d.widgets['info'].wh = d.data['widgets']['info']['dimensions' + (info_high ? '_high' : (child_catdata ? '_category' : ''))];
        d.widgets['info'].set_text_with_linebreaking(info_str);
    }
    if(info_col) {
        var col = d.data['widgets']['info']['text_color_'+info_col];
            d.widgets['info'].text_color = new SPUI.Color(col[0], col[1], col[2], col[3]);
    }

    d.widgets['hider'].show = (price < 0 && buyable) || pending;

    d.widgets['loading_spinner'].show = pending;
    var hi = (d.mouse_enter_time > 0) && (!d.widgets['hider'].show) && !pending;
    d.xy[0] = d.user_data['base_xy'][0];
    d.xy[1] = d.user_data['base_xy'][1] - (hi && !d.widgets['bg'].pushed ? 1 : 0);
    d.widgets['icon_glow'].xy = vec_copy(d.data['widgets']['icon_glow']['xy'+ (d.widgets['bg'].pushed ? '_pushed' : '')]);
    d.widgets['icon_glow'].wh = vec_copy(d.data['widgets']['icon_glow']['dimensions'+ (d.widgets['bg'].pushed ? '_pushed' : '')]);
    d.widgets['icon_glow'].alpha = (hi ? (d.widgets['bg'].pushed ? 0.66 : 0.2) : 0);
    d.widgets['icon_glow'].asset = d.data['widgets']['icon_glow']['asset'+(d.widgets['bg'].pushed ? '_pushed': '')];
    d.widgets['bg_shine'].alpha = (hi ? (d.widgets['bg'].pushed ? 1 : 0.66 ) : 0.5) * (set_completed ? 0.5 : 1);
    d.widgets['price_bg_shine'].alpha = 0.8*  (hi ? (d.widgets['bg'].pushed ? 1 : 0.66 ) : 0.5);

    // PRICE
    if(child_catdata || ('ui_availability' in skudata)) {
        d.widgets['price_icon'].show = d.widgets['price_display'].show = false;
    } else {
        if(sale_currency == 'gamebucks') {
            d.widgets['price_icon'].asset = player.get_any_abtest_value('gamebucks_resource_icon', gamedata['store']['gamebucks_resource_icon']);
        } else if(sale_currency == 'fbcredits') {
            d.widgets['price_icon'].asset = 'resource_icon_fbcredits';
        } else if(sale_currency.indexOf('item:') === 0) {
            d.widgets['price_icon'].asset = ItemDisplay.get_inventory_item_spec(sale_currency.split(':')[1])['store_icon'];
        } else if(sale_currency in gamedata['resources']) {
            d.widgets['price_icon'].asset = gamedata['resources'][sale_currency]['icon_small'];
        } else {
            throw Error('unknown sale_currency '+sale_currency);
        }

        if(sale_currency == 'gamebucks' || sale_currency == 'fbcredits') {
            d.widgets['price_display'].str = Store.display_user_currency_price(shown_price);
            d.widgets['price_display'].tooltip.str = Store.display_user_currency_price_tooltip(shown_price);
        } else if(sale_currency.indexOf('item:') === 0) {
            d.widgets['price_display'].str = (shown_price > 0 ? pretty_print_number(shown_price) : '-');
            var currency_item_spec = ItemDisplay.get_inventory_item_spec(sale_currency.split(':')[1]);
            d.widgets['price_display'].tooltip.str = (shown_price > 0 ? gamedata['strings']['store']['buy_for'].replace('%s',
                                                                                                                        ItemDisplay.get_inventory_item_stack_prefix(currency_item_spec, shown_price)+ItemDisplay.get_inventory_item_ui_name(currency_item_spec)) : null);
        } else if(sale_currency in gamedata['resources']) {
            d.widgets['price_display'].str = (shown_price > 0 ? pretty_print_number(shown_price) : '-');
            d.widgets['price_display'].tooltip.str = (shown_price > 0 ? gamedata['strings']['store']['buy_for'].replace('%s', pretty_print_number(shown_price) + ' ' +gamedata['resources'][sale_currency]['ui_name']) : null);
        }
    }

    if(child_catdata) {
        d.widgets['bg'].state = 'normal';
        d.widgets['bg'].onclick = function(w) {
            var d = w.parent;
            var child_catdata = d.user_data['skudata'];
            // this saves the scroll_goal so that hitting the "Back" button brings you to the exact spot you were before you clicked this
            var new_parent_catdata = (d.parent.user_data['parent_catdata'] || []).concat([{cat:d.parent.user_data['catdata'], pos:d.parent.user_data['scroll_goal']}]);
            close_parent_dialog(w.parent);
            // don't specify anything to scroll toward, just leave it at the default
            invoke_new_store_category(child_catdata, new_parent_catdata);
        };
    } else if(price >= 0 && !pending) {
        d.widgets['bg'].state = 'normal';
        d.widgets['bg'].onclick = function(w) {
            var d = w.parent;
            var skudata = d.user_data['skudata'];
            var cleanup_cb = (function (_d, _w) { return function() {
                _d.user_data['pending'] = client_time + 1.5;
                var skudata = _d.user_data['skudata'];
                var spell = ('spell' in skudata ? gamedata['spells'][skudata['spell']] : null);

                if(spell && spell['close_store_on_purchase']) {
                    change_selection_ui(null);
                    return;
                }

                _d.widgets['glowfx'].show = true;
                _d.widgets['glowfx'].reset_fx();

                if(!player.get_any_abtest_value('modal_looting', gamedata['modal_looting'])) {
                    var floating_msg = (spell ? ('ui_new_store_activated' in spell ? spell['ui_new_store_activated'] : gamedata['strings']['combat_messages']['purchased']) : gamedata['strings']['combat_messages']['sent_to_messages']);
                    if(floating_msg.length > 0) {
                        ItemDisplay.add_inventory_item_effect(_d.widgets['icon'], floating_msg, [1,1,0.3]);
                    }
                }
            }; })(d, w);

            var order_spell = ('spell' in skudata ? skudata['spell'] : "BUY_ITEM");
            var order_spellarg = ('spell' in skudata ? null : {'catpath': d.user_data['catpath'], 'ui_index': d.user_data['ui_index'], 'skudata':skudata});
            // note: there is no 0-credit order path for FB Credits or tokens, so make a gamebucks order for free items
            var order_currency = (price == 0 ? 'gamebucks' : sale_currency);

            // function to place the order, with a parameter for a spellarg that might come from further pre-order GUI
            var order_cb = (function (_d, _order_currency, _order_spell, _order_spellarg, _cleanup_cb) { return function(override_spellarg) {
                var placed = Store.place_order(_order_currency, GameObject.VIRTUAL_ID, _order_spell,
                                               (override_spellarg ? override_spellarg : _order_spellarg),
                                               _cleanup_cb, {'no_clear':true});
                if(placed) {
                    invoke_ui_locker();
                    _d.user_data['pending'] = client_time + 6000;
                    var spell = gamedata['spells'][_order_spell];
                    if(('cooldown_name' in spell) && ((!('activation' in spell)) || spell['activation'] == 'instant')) {
                        // preemptively trigger the cooldown on client side to prevent duplicate orders
                        // the actual real cooldown info comes from the COOLDOWNS_UPDATE that the server will send when it receives the order
                        // but we trigger it here on client-side to make sure the UI is blocked while the order is in-flight
                        player.cooldown_client_trigger(spell['cooldown_name'], spell['cooldown']);
                    }
                }
                return placed;

            }; })(d, order_currency, order_spell, order_spellarg, cleanup_cb);


            // fire order immediately, or need further GUI?
            var spell = gamedata['spells'][order_spell];
            if(((!('activation' in spell)) || spell['activation'] == 'instant')) {
                order_cb(null);
                return;
            }

            if(order_spell == "CHANGE_REGION" || order_spell.indexOf("CHANGE_REGION_INSTANTLY")==0) {
                change_selection_ui(null); // don't want to do this, but the tooltips are unbearable
                invoke_change_region_dialog(order_cb, order_spell);
            } else {
                throw Error('unhandled order_spell '+order_spell.toString());
            }

        };
    } else if(helper) {
        d.widgets['bg'].state = 'disabled_clickable';
        d.widgets['bg'].onclick = helper;
    } else {
        d.widgets['bg'].state = 'disabled';
    }
}

/** @param {string=} purpose
    @param {string=} path */
function invoke_store(purpose, path) {
    // purpose: null, or (a resource name like 'iron'), 'special_items', 'barriers', 'defenses', 'exact_path'
    // path (required when purpose='exact_path', otherwise null): a string specifying the SKU or category to scroll to, in the form of a /-delimited hierarchical path
    // examples:
    // "event_prizes/blueprints/t90_blueprint" (opens BLUEPRINTS category and scrolls to highlight t90_blueprint)
    // "event_prizes/blueprints" (opens EVENT PRIZES category and scrolls to highlight blueprints folder)
    // "event_prizes/blueprints/" (opens BLUEPRINTS category)

    var store = null;

    var catalog = gamedata['store']['catalog'];
    if(purpose in gamedata['resources']) {
        var i;
        for(i = 0; i < catalog.length; i++) { if(catalog[i]['name'] == 'resources') { break; } }
        var catdata = catalog[i];
        store = invoke_new_store_category(catdata);
        var skulist = store.user_data['skulist'];
        for(i = 0; i < skulist.length; i++) {
            var skudata = skulist[i];
            if('spell' in skudata) {
                var spell = gamedata['spells'][skudata['spell']];
                if('resource' in spell && spell['resource'] == purpose) {
                    break;
                }
            }
        }
        if(i < skulist.length) {
            store.user_data['initial_scroll'] = i;
        }
    } else if(purpose == 'barriers' || purpose == 'special_items' || purpose == 'specials' || purpose == 'defenses') {
        var i;
        if(purpose == 'barriers' || purpose == 'special_items') { purpose = 'defenses'; }
        for(i = 0; i < catalog.length; i++) { if(catalog[i]['name'] == purpose) { break; } }
        if(i < catalog.length) {
            var catdata = catalog[i];
            store = invoke_new_store_category(catdata);
        } else {
            console.log("invoke_store(): unhandled purpose "+purpose);
            store = invoke_new_store_dialog();
        }
    } else if(purpose == 'exact_path') {
        var split_path = (path.length > 1 ? path.split('/') : []);
        var parent_catdata = []; // build list of parent nodes as we drill down
        var catdata = {'skus': catalog}; // begin at toplevel
        for(var i = 0; i < split_path.length; i++) {
            var cur = split_path[i];
            if(i >= split_path.length-1) { // final SKU or category
                store = invoke_new_store_category(catdata, parent_catdata.slice(1,parent_catdata.length), cur);
                break;
            } else {
                // drill down
                if(!('skus' in catdata)) { break; }
                parent_catdata.push({cat:catdata, sku_name:cur});
                catdata = goog.array.find(catdata['skus'], function(entry) {
                    return entry['name'] == cur;
                });
                if(!catdata) { break; }
            }
        }
        if(!store) {
            throw Error('bad SKU path: "'+path+'"');
        }
    } else {
        store = invoke_new_store_dialog();
    }

    return store;
}

var last_build_dialog_category = 'resources';

/** @param {string=} newcategory */
function invoke_build_dialog(newcategory) {
    //metric_event('4020_open_menu', {'menu_name':'build_dialog'});

    change_selection(player.virtual_units["BUILDMENU"]);

    var dialog_data = gamedata['dialogs']['build_dialog'];

    // instantiate the dialog
    var dialog = new SPUI.Dialog(dialog_data);

    // make the dialog modal and add it to the "desktop"
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;

    dialog.user_data['dialog'] = 'build_dialog';

    dialog.widgets['close_button'].onclick = function() {
        if(player.tutorial_state != "COMPLETE") { return; }
        change_selection(null);
    };
    dialog.widgets['inert_button'].show = !!player.is_cheater;

    goog.array.forEach(['inert', 'resources', 'production', 'defense'], function(cat) {
        dialog.widgets[cat+'_button'].onclick = (function (_cat) { return function(w) { build_dialog_change_category(w.parent, _cat); }; })(cat);
        dialog.widgets[cat+'_button_jewel'].ondraw = update_notification_jewel;
    });

    var category;
    if(player.tutorial_state === 'choose_defensive_cannon') {
        category = 'defense';
    } else if(newcategory) {
        category = newcategory;
    } else {
        var preselect = null;
        if('default_build_dialog_category' in gamedata['client']) {
            preselect = eval_cond_or_literal(gamedata['client']['default_build_dialog_category'], player, null);
        }
        category = preselect || last_build_dialog_category;
    }
    build_dialog_change_category(dialog, category);

    dialog.widgets['scroll_left'].onclick = function(w) { dialog.user_data['scrolled'] = true; build_dialog_scroll(w.parent, w.parent.user_data['page']-1); };
    dialog.widgets['scroll_right'].onclick = function(w) { dialog.user_data['scrolled'] = true; build_dialog_scroll(w.parent, w.parent.user_data['page']+1); };
    dialog.widgets['scroll_left_jewel'].ondraw =
        dialog.widgets['scroll_right_jewel'].ondraw = update_notification_jewel;

    if(player.tutorial_state === 'open_buildings_dialog') {
        advance_tutorial();
        dialog.widgets['close_button'].onclick = null; // don't let player close the dialog!
    }
    return dialog;
}

// return a dictionary of "able to build additional buildings of this type" jewels by build_category and specname
// e.g. {"defense": {"turret": 3, // can build 3 more turrets
//                   "barrier": 1, // and one more barrier
//                   "ALL": 4, "ALL_unique": 2}, // for convenience
//       "ALL": 4, "ALL_unique": 2
//      }
function get_building_jewels() {
    var ret = {'ALL':0, 'ALL_unique':0};
    if(!read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null)) { return ret; } // tutorial not complete
    if(!player.get_any_abtest_value('build_dialog_jewels', gamedata['client']['build_dialog_jewels'])) { return ret; } // disabled by A/B test

    for(var name in gamedata['buildings']) {
        var spec = gamedata['buildings'][name];
        var category = spec['build_category'];
        if(spec['developer_only']) { continue; }

        var pred_ok = true;
        goog.array.forEach(['show_if', 'activation', 'requires'], function(pred) {
            if((pred in spec) && !read_predicate(get_leveled_quantity(spec[pred],1)).is_satisfied(player, null)) {
                pred_ok = false;
            }
        });
        if(!pred_ok) { continue; }

        var current = count_objects_by_type(spec['name']);
        var cc_level = player.get_townhall_level();
        if(!('limit' in spec)) { continue; }
        var limit = get_leveled_quantity(spec['limit'], Math.max(1, cc_level));
        if(current >= limit) { continue; }

        if('limit_requires' in spec) {
            limit = Math.min(limit, spec['limit_requires'].length);
            var req_limit = current;
            for(; req_limit < spec['limit_requires'].length; req_limit++) {
                if(!read_predicate(spec['limit_requires'][req_limit]).is_satisfied(player, null)) { break; }
            }
            limit = Math.min(limit, req_limit);
        }
        if(limit - current > 0) {
            if(!(category in ret)) {
                ret[category] = {'ALL': 0};
            }
            ret[category][spec['name']] = limit - current;
            ret[category]['ALL'] += limit - current;
            ret[category]['ALL_unique'] += 1;
            ret['ALL'] += limit - current;
            ret['ALL_unique'] += 1;
        }
    }
    return ret;
}

function build_dialog_change_category(dialog, category) {
    dialog.user_data['category'] = category;
    dialog.user_data['scrolled'] = false;
    dialog.user_data['open_time'] = client_time;
    dialog.user_data['speclist'] = [];

    if(category === 'defense' && player.tutorial_state === 'go_to_defense_tab') {
        advance_tutorial();
    }

    last_build_dialog_category = category;

    var building_jewels = get_building_jewels();
    goog.array.forEach(['inert', 'resources', 'production', 'defense'], function(cat) {
        dialog.widgets[cat+'_button'].state = (category === cat ? 'active' : 'normal');
        dialog.widgets[cat+'_button_jewel'].user_data['count'] = ((cat in building_jewels) ? building_jewels[cat]['ALL'] : 0);
    });


    if(player.tutorial_state === 'choose_defensive_cannon') {
        dialog.widgets['resources_button'].state =
            dialog.widgets['production_button'].state = 'disabled';
    }

    if(category === 'inert') {
        for(var name in gamedata['inert']) {
            var spec = gamedata['inert'][name];
            if(('base_climates' in spec) && session.viewing_base.base_climate &&
               (!goog.array.contains(spec['base_climates'], session.viewing_base.base_climate))) {
                // inappropriate climate
                continue;
            }
            dialog.user_data['speclist'].push(name);
        }
    } else {
        for(var name in gamedata['buildings']) {
            var spec = gamedata['buildings'][name];
            if(spec['build_category'] != category) {
                continue;
            }
            if(spec['developer_only'] && (spin_secure_mode || !player.is_developer())) {
                continue;
            }
            if('show_if' in spec && !read_predicate(spec['show_if']).is_satisfied(player, null)) { continue; }
            if('activation' in spec && !read_predicate(spec['activation']).is_satisfied(player, null)) { continue; }
            dialog.user_data['speclist'].push(name);
        }
    }
    build_dialog_scroll(dialog, 0);
}

function build_dialog_scroll(dialog, page) {
    // fill in grid of building types
    var grid_x = 0, grid_y = 0;
    // list of widget [specname,x,y] coords - for usage by TUTORIAL_ARROW consequents and get_requirements_help
    dialog.user_data['slots_this_page'] = [];

    var building_jewels = get_building_jewels();

    var chapter_specs = (dialog.user_data['speclist'] ? dialog.user_data['speclist'].length : 0);
    var specs_per_page = dialog.data['widgets']['grid']['array'][0]*dialog.data['widgets']['grid']['array'][1];
    var chapter_pages = Math.floor((chapter_specs+specs_per_page-1)/specs_per_page);
    dialog.user_data['page'] = page = (chapter_specs === 0 ? 0 : clamp(page, 0, chapter_pages-1));

    // this is the function that actually starts the build command
    var build_closure = function(kind, bname) {
        return function() {
            // if foreman is busy, prompt player to add foreman or speed up current operation
            if(player.foreman_is_busy()) {
                if(gamedata['enable_multiple_foremen'] && player.tutorial_state == "COMPLETE") {
                    var helper = get_requirements_help('foreman', null);
                    if(helper) {
                        helper();
                        return;
                    }
                }
                var obj = player.foreman_get_tasks()[0];
                change_selection(obj);
                invoke_speedup_dialog('busy');
                return;
            }

            var spec = gamedata[kind][bname];
            // prime targeted "build" spell
            selection.spellname = "BUILD";
            selection.spellkind = bname;
            // add spell target graphics
            change_selection_ui_under(new BuildUICursor(null, spec));
            if(player.tutorial_state === 'choose_defensive_cannon' && bname === gamedata['tutorial'][player.tutorial_state]['target']) {
                advance_tutorial();
            }

            // try to pre-locate the building
            if(player.tutorial_state == 'place_defensive_cannon') {
                // this should probably be run no matter what
                //var loc = gamedata['tutorial'][player.tutorial_state]['location'];
                var loc = screen_to_ortho([mouse_state.last_raw_x, mouse_state.last_raw_y]);
                var xy = ortho_to_screen(loc);
                mouse_state.last_x = xy[0]; mouse_state.last_y = xy[1];

            } else if(player.tutorial_state == "COMPLETE" && (!player.quest_tracked || !player.quest_tracked['tips'])) {
                var loc = find_valid_building_location(session.viewing_base.midcell(), bname);
                if(loc) {
                    // scroll instantly over there
                    view_pos = ortho_to_playfield_vector(vec_sub(loc, vec_scale(0.5,session.viewing_base.ncells())));
                    // fake a mouse position update right on the build location
                    var xy = ortho_to_screen(loc);
                    mouse_state.last_x = xy[0]; mouse_state.last_y = xy[1];
                }
            }
        };
    };

    if(chapter_pages > 0) {
        var first_spec_on_page = page * specs_per_page;
        var last_spec_on_page = Math.max(0, Math.min((page+1)*specs_per_page-1, chapter_specs-1));
        for(var i = first_spec_on_page; i <= last_spec_on_page; i++) {
            var name = dialog.user_data['speclist'][i];
            var widget_name = grid_x.toString() + ',' + grid_y.toString();

            dialog.user_data['slots_this_page'].push([name,grid_x,grid_y]);

            if(name in gamedata['inert']) {
                var spec = gamedata['inert'][name];
                dialog.widgets['grid_label'+widget_name].show = true;
                dialog.widgets['grid_label'+widget_name].str = name;
                dialog.widgets['grid_status'+widget_name].show = false;
                dialog.widgets['grid_jewel'+widget_name].show = false;
                dialog.widgets['grid'+widget_name].show = true;
                dialog.widgets['grid'+widget_name].bg_image = spec['art_asset'];
                dialog.widgets['grid'+widget_name].state = 'normal';
                // shrink large sprites
                dialog.widgets['grid'+widget_name].transform = (spec['gridsize'][0] > 8 ?  [0.2,0,0,0.2,dialog.data['widgets']['grid']['dimensions'][0]/2,dialog.data['widgets']['grid']['dimensions'][1]/2] : null);
                dialog.widgets['grid'+widget_name].onclick = build_closure('inert', name);
                dialog.widgets['grid'+widget_name].tooltip.str = null;
            } else {
                var spec = gamedata['buildings'][name];
                var widget = dialog.widgets['grid'+widget_name];
                widget.bg_image = get_leveled_quantity(spec['art_asset'], 1);
                widget.state = 'icon';
                widget.transform = null;
                widget.show = true;
                dialog.widgets['grid_label'+widget_name].str = spec['ui_name'];
                dialog.widgets['grid_label'+widget_name].show = true;
                dialog.widgets['grid_status'+widget_name].show = true;
                dialog.widgets['grid_jewel'+widget_name].show = true;
                dialog.widgets['grid_jewel'+widget_name].ondraw = update_notification_jewel;
                dialog.widgets['grid_jewel'+widget_name].user_data['count'] = (dialog.user_data['category'] in building_jewels ? (building_jewels[dialog.user_data['category']][name] || 0) : 0);

                var tooltip_text = [];
                var able_to_build = true;
                var max_built = false, can_build_more_if_cc_higher = false, can_build_more_if_cc_one_higher = false, can_build_more_if_pred = null;
                var unlocked = true;
                var helper = null;

                tooltip_text.push(SPUI.break_lines(spec['ui_description'],SPUI.desktop_font, [300,0])[0]);
                tooltip_text.push('');

                // hack for tutorial
                if(player.tutorial_state != 'COMPLETE') {
                    if(name != gamedata['tutorial']['choose_defensive_cannon']['target']) {
                        able_to_build = false; unlocked = false;
                    }
                }

                // display current number of this kind of building, and quantity limit
                var current = count_objects_by_type(spec['name']);
                var limit;
                var cc_obj = player.get_townhall();
                var cc_level = (cc_obj ? cc_obj.level : 0);
                var max_cc_level = (cc_obj ? cc_obj.get_max_ui_level() : 0);
                if('limit' in spec) {
                    limit = get_leveled_quantity(spec['limit'], Math.max(1, cc_level));
                    if('limit_requires' in spec) {
                        limit = Math.min(limit, spec['limit_requires'].length);
                        var req_limit = current;
                        for(; req_limit < spec['limit_requires'].length; req_limit++) {
                            if(!read_predicate(spec['limit_requires'][req_limit]).is_satisfied(player, null)) { break; }
                        }
                        limit = Math.min(limit, req_limit);
                    }
                } else {
                    limit = '-';
                }

                // limit on number of buildings
                if(('limit_requires' in spec) && !player.is_cheater) {
                    if(current >= spec['limit_requires'].length) {
                        // already built all that you can
                        able_to_build = false;
                        max_built = true;
                        tooltip_text.push(gamedata['errors']['BUILDING_LIMIT_EXCEEDED']['ui_name']);
                    } else {
                        var pred = read_predicate(spec['limit_requires'][current]);
                        if(!pred.is_satisfied(player, null)) {
                            able_to_build = false;
                            max_built = true;
                            can_build_more_if_pred = pred;
                            if(!helper) { helper = get_requirements_help(pred, null); }
                        }
                    }
                } else if(((typeof limit) == 'number') && current >= limit && !player.is_cheater) {
                    able_to_build = false;
                    max_built = true;
                    var msg = gamedata['errors']['BUILDING_LIMIT_EXCEEDED']['ui_name'];

                    if((cc_level < max_cc_level) &&
                       current < get_leveled_quantity(spec['limit'], max_cc_level)) {
                        can_build_more_if_cc_higher = true;
                        can_build_more_if_cc_one_higher = (current < get_leveled_quantity(spec['limit'], cc_level+1));

                        var cc_ui_name = gamedata['buildings'][gamedata['townhall']]['ui_name'];
                        msg = gamedata['errors']['BUILDING_LIMIT_EXCEEDED']['ui_name_detailed'].replace('%townhall1',cc_ui_name).replace('%townhall2',cc_ui_name).replace('%lev', cc_level.toString());

                        if(!helper) { helper = get_requirements_help('cc_limit', spec); }
                    }
                    tooltip_text.push(msg);
                }

                if(!max_built || can_build_more_if_cc_higher || can_build_more_if_pred) {

                    // build time
                    var build_time = get_leveled_quantity(spec['build_time'], 1);
                    if(build_time > 0) {
                        //tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_builds_in'].replace('%s',pretty_print_time(build_time)));
                    } else {
                        tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_builds_instantly']);
                    }

                    // get list of any unsatisfied requirements
                    if('requires' in spec && !player.is_cheater) {
                        var pred = read_predicate(get_leveled_quantity(spec['requires'], 1));
                        var req = pred.ui_describe(player);
                        if(req) {
                            tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_unmet'].replace('%s',req));
                            able_to_build = false;
                            unlocked = false;
                            // this should take priority over any previous helper
                            if(true || !helper) { helper = get_requirements_help(pred, null); }
                        }
                    }

                    if(can_build_more_if_pred) {
                        tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_unmet'].replace('%s',can_build_more_if_pred.ui_describe(player)));
                    }

                    // minimum resource amounts
                    var min_quant;
                    var res_needed = {};
                    for(var res in gamedata['resources']) {
                        var resdata = gamedata['resources'][res];
                        min_quant = get_leveled_quantity(spec['build_cost_'+res] || 0, 1);
                        var player_quant = player.resource_state[res][1];
                        if(player_quant < min_quant && !player.is_cheater) {
                            able_to_build = false;
                            res_needed[res] = min_quant - player_quant;
                        }
                        if(min_quant > 0) {
                            tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_requires_res'].replace('%d',pretty_print_number(min_quant)).replace('%res',resdata['ui_name']));
                        }
                    }
                    if(goog.object.getCount(res_needed) > 0) {
                        if(!helper) {
                            helper = get_requirements_help('resources', res_needed, {continuation:(function (_build_closure, _name) { return function() {
                                _build_closure('buildings',_name)();
                            }; })(build_closure, name)});
                        }
                    }

                    // power requirements
                    if('consumes_power' in spec) {
                        var consumes_power = get_leveled_quantity(spec['consumes_power'], 1);
                        var extra_power_needed = (session.viewing_base.power_state[1] + consumes_power) - session.viewing_base.power_state[0];
                        if(consumes_power > 0 && extra_power_needed > 0) {
                            able_to_build = false;
                            tooltip_text.push(dialog.data['widgets']['grid']['ui_tooltip_requires_power'].replace('%d',pretty_print_number(extra_power_needed)).replace('%POWERPLANTS', gamedata['buildings'][gamedata['strings']['modstats']['stats']['limit:energy']['check_spec']]['ui_name_plural']));
                            if(!helper) { helper = get_requirements_help('power', null); }
                        }
                    }

                } /// END can still build more

                dialog.widgets['grid_glow'+widget_name].show = true;

                var str = '', color = SPUI.default_text_color;
                if(unlocked) {
                    widget.state = 'icon';

                    if(max_built) {
                        if(can_build_more_if_cc_higher) {
                            color = SPUI.warning_text_color;
                            str += dialog.data['widgets']['grid_status']['ui_name_x_of_y'].replace('%cur',current.toString()).replace('%max',limit.toString());

                            // All friendly_build_dialog does is add the text
                            // "Upgrade CC for more" when upgrading the CC by
                            // one level would allow you to build more of this
                            // building.
                            if(player.get_any_abtest_value('friendly_build_dialog', gamedata['client']['friendly_build_dialog']) &&
                               can_build_more_if_cc_one_higher &&
                               (cc_level >= 2 || read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null))) {
                                str += '\n'+dialog.data['widgets']['grid_status']['ui_name_upgrade_cc'].replace('%TOWNHALL', gamedata['buildings'][gamedata['townhall']]['ui_name_abbreviation'] || gamedata['buildings'][gamedata['townhall']]['ui_name']);
                            }
                        } else if(can_build_more_if_pred) {
                            color = SPUI.warning_text_color;
                            str += dialog.data['widgets']['grid_status']['ui_name_x_of_y'].replace('%cur',current.toString()).replace('%max',limit.toString());
                        } else {
                            color = SPUI.error_text_color;
                            str += dialog.data['widgets']['grid_status']['ui_name_max_built'].replace('%cur', current.toString()).replace('%max',limit.toString());
                        }
                    } else {
                        str += dialog.data['widgets']['grid_status']['ui_name_x_of_y'].replace('%cur',current.toString()).replace('%max',limit.toString());
                    }
                } else {
                    widget.state = 'icon_disabled';
                    str = dialog.data['widgets']['grid_status']['ui_name_locked'];
                    color = SPUI.error_text_color;
                }
                if(spec['developer_only']) { str = '(DEV ONLY) '+str; }

                dialog.widgets['grid_status'+widget_name].str = str;
                dialog.widgets['grid_status'+widget_name].text_color = color;

                if(able_to_build) {
                    widget.onclick = build_closure('buildings', name);
                    widget.tooltip.text_color = SPUI.default_text_color;
                } else {
                    if(helper) {
                        // hack - need to update helper on a per-frame basis - this closes the build dialog as a work-around
                        widget.onclick = (function (_helper) { return function(w) {
                            close_parent_dialog(w);
                            _helper();
                        }; })(helper);
                    } else {
                        widget.onclick = null;
                    }
                    widget.tooltip.text_color = SPUI.error_text_color;
                }

                widget.tooltip.str = tooltip_text.join('\n');
            } // END building

            grid_x += 1;
            if(grid_x >= dialog.data['widgets']['grid']['array'][0]) {
                grid_x = 0; grid_y += 1;
            }
        }
        dialog.widgets['scroll_text'].show = true;
        dialog.widgets['scroll_text'].str = dialog.data['widgets']['scroll_text']['ui_name'].replace('%d1',(first_spec_on_page+1).toString()).replace('%d2',(last_spec_on_page+1).toString()).replace('%d3',chapter_specs.toString());
    } else {
        dialog.widgets['scroll_text'].show = false;
    }

    // clear out empty widgets
    while(grid_y < dialog.data['widgets']['grid']['array'][1]) {
        while(grid_x < dialog.data['widgets']['grid']['array'][0]) {
            var widget_name = grid_x.toString() + ',' + grid_y.toString();
            dialog.widgets['grid'+widget_name].bg_image = null;
            dialog.widgets['grid'+widget_name].show =
                dialog.widgets['grid_glow'+widget_name].show =
                dialog.widgets['grid_label'+widget_name].show =
                dialog.widgets['grid_status'+widget_name].show =
                dialog.widgets['grid_jewel'+widget_name].show = false;
            grid_x += 1;
        }
        grid_x = 0;
        grid_y += 1;
    }

    dialog.widgets['scroll_left'].state = (page != 0 ? 'normal' : 'disabled');
    dialog.widgets['scroll_right'].state = ((page < chapter_pages-1) ? 'normal' : 'disabled');

    goog.array.forEach([['scroll_left', [0, first_spec_on_page]],
                        ['scroll_right', [last_spec_on_page+1, dialog.user_data['speclist'].length]]],
                       function(data) {
                           var wname = data[0], range = data[1];
                           var count = 0;
                           if(dialog.widgets[wname].state != 'disabled') {
                               for(var i = range[0]; i < range[1] && i < dialog.user_data['speclist'].length; i++) {
                                   var name = dialog.user_data['speclist'][i];
                                   count += (dialog.user_data['category'] in building_jewels ? (building_jewels[dialog.user_data['category']][name] || 0) : 0);
                               }
                           }
                           dialog.widgets[wname+'_jewel'].user_data['count'] = count;
                       });

    player.quest_tracked_dirty = true;
}

// determine whether a shortage of unit space is because of base defenders or total army being full
function classify_unit_space_shortage() {
    var space_usage = player.get_army_space_usage_by_squad();
    var available_total_army = player.stattab['total_space'] - space_usage['ALL'];
    var available_base_defenders = player.stattab['main_squad_space'] - space_usage[SQUAD_IDS.BASE_DEFENDERS.toString()];
    if(available_base_defenders < available_total_army && (!player.squads_enabled() || !gamedata['produce_to_reserves'])) {
        return 'base_defenders';
    } else {
        // can squad bay be built, or upgraded further?
        var target = find_object_by_type(gamedata['squad_building']);
        if(!target || target.level < target.get_max_ui_level()) {
            return 'total_army';
        } else {
            // maxed out - only thing you can do is recycle
            return 'recycle';
        }
    }
}

/** Try to help the player overcome a lack of resources or unfulfilled predicate
    @returns {function()|null} a function that will cause the helper UI to appear (null if we can't help)
    @param {string|Predicate} kind
    @param {?=} arg
    @param {Object=} options */
function get_requirements_help(kind, arg, options) {
    if(!options) { options = {}; }

    if(!player.get_any_abtest_value('plus_buttons', gamedata['client']['plus_buttons'])) { return null; }
    if(player.tutorial_state != "COMPLETE") { return null; }
    if(!(options && options.even_if_tutorial_incomplete) &&
       !read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null) && player.quest_tracked) {
        return null;
    }

    var noun = null, verb = null, target = null;
    var ui_arg_s = null, ui_arg_d = null, ui_override_title = null, ui_override_description = null, unit_icon = null;

    // convert legacy resource requests into combo ones
    if(kind in gamedata['resources']) {
        var amount = arg;
        arg = {}; arg[kind] = amount;
        kind = 'resources';
    }

    // when the player doesn't have enough resource storage to hold the extra amount needed,
    // convert the "more res needed" help into a prompt to add/upgrade storage buildings
    if(kind == 'resources') {
        for(var res in arg) {
            if((player.resource_state[res][1] + arg[res]) > player.resource_state[res][0]) {
                kind = 'need_more_storage';
                arg = res;
                break;
            }
        }
    }

    if(kind == 'resources') {
        noun = kind;
        var can_topup = true;
        var need_more = false;

        // legacy path: one at a time
        for(var res in arg) {
            if(arg[res] > 0) {
                need_more = true;
                if(!gamedata['resources'][res]['allow_topup']) {
                    can_topup = false;
                    verb = res; ui_arg_s = pretty_print_number(arg[res]);
                    break;
                }
            }
        }
        if(need_more && can_topup) {
            // optional continuation callback
            var continuation = options.continuation || null;
            return (function (_arg, _continuation) { return function() { invoke_buy_resources_dialog(_arg, _continuation); }; })(arg, continuation);
        }

        // otherwise fall through to standard helper

    } else if(kind == 'insufficient_resources_to_repair_units' || kind == 'insufficient_resources_to_repair_squad') {
        noun = kind;
        if(!arg) { return null; }
        var can_topup = true;
        var missing_res = {};

        // don't need to worry about the case where resource storage is insufficient to hold the amount,
        // because the player would not have been able to build those units in the first place (I think...)

        for(var res in gamedata['resources']) {
            if((res in arg) && (arg[res] > player.resource_state[res][1])) {
                missing_res[res] = arg[res] - player.resource_state[res][1];
                verb = res; // for the fallback non-topup path
                if(!gamedata['resources'][res]['allow_topup']) {
                    can_topup = false;
                    break;
                }
            }
        }
        if(goog.object.getCount(missing_res) > 0 && can_topup) {
            // optional continuation callback
            var continuation = options.continuation || null;
            return (function (_missing_res, _continuation) { return function() { invoke_buy_resources_dialog(_missing_res, _continuation); }; })(missing_res, continuation);
        }

        if(!verb) { return null; }
        ui_arg_s = pretty_print_number(arg[verb] - player.resource_state[verb][1]);
        if('squad_id' in arg) { // awkward - passed in from invoke_insufficient_resources_for_repair_message()
            ui_arg_d = player.squads[arg['squad_id'].toString()]['ui_name'];
        }
    } else if(kind == 'storages_full' ||
              kind == 'storages_full_attack' ||
              kind == 'storages_almost_full_attack' ||
              kind == 'need_more_storage') {
        noun = kind;
        var rsrc = arg;
        var specname = gamedata['resources'][rsrc]['storage_building'];
        // see if we have already built enough storages
        var cc = player.get_townhall();
        var cc_level = player.get_townhall_level();
        var under_construction_obj = null;
        var num_built = 0;
        var min_level = 999, need_to_upgrade_obj = null;
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.spec['name'] === specname && obj.team === 'player') {
                if(obj.is_under_construction()) {
                    under_construction_obj = obj;
                    continue;
                }
                num_built += 1;
                if(obj.level < min_level && obj.level < obj.get_max_ui_level()) {
                    min_level = obj.level;
                    need_to_upgrade_obj = obj;
                }
            }
        }
        ui_arg_s = gamedata['buildings'][specname]['ui_name'];
        ui_arg_d = gamedata['resources'][rsrc]['ui_name_lower'];
        unit_icon = get_leveled_quantity(gamedata['buildings'][specname]['art_asset'], 1);
        if(num_built < 1) {
            // player has not built any storages yet
            if(under_construction_obj) {
                verb = 'finish_construction'; target = under_construction_obj;
            } else {
                verb = 'build_first'; target = specname;
            }
        } else if(num_built < get_leveled_quantity(gamedata['buildings'][specname]['limit'], cc_level)) {
            // player has not built the full number of storages yet
            verb = 'build_more'; target = specname;
        } else if(need_to_upgrade_obj) {
            // player has an under-leveled storage
            verb = 'upgrade'; target = need_to_upgrade_obj;
        } else if(cc && cc.level < cc.get_max_ui_level()) {
            // player must ugprade CC
            verb = 'upgrade_cc'; target = cc;
        } else {
            console.log('unable to help with '+kind+' problem!');  return null;
        }

    } else if(kind == 'power') {
        // see if we have already built enough power plants
        var cc_level = player.get_townhall_level();
        var num_built = 0;
        var min_level = 999, need_to_upgrade_obj = null, powerplant_specname = null;
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(('provides_power' in obj.spec) && obj.team === 'player') {
                powerplant_specname = obj.spec['name'];
                num_built += 1;
                if(obj.level < min_level && obj.level < obj.get_max_ui_level()) {
                    min_level = obj.level;
                    need_to_upgrade_obj = obj;
                }
            }
        }
        if(powerplant_specname && (num_built < get_leveled_quantity(gamedata['buildings'][powerplant_specname]['limit'], cc_level))) {
            // player has not built the full number of energy plants yet
            noun = 'power'; verb = 'build_more'; target = powerplant_specname;
        } else if(need_to_upgrade_obj) {
            // player has an under-leveled power plant
            noun = 'power'; verb = 'upgrade'; target = need_to_upgrade_obj;
        } else {
            console.log('unable to help with power problem!');  return null;
        }
    } else if(kind == 'unit_count') {
        noun = kind; verb = 'default';
        ui_arg_s = gamedata['units'][arg]['ui_name_plural'];
    } else if(kind == 'unit_space') {
        if(player.squads_enabled()) {
            // squads case
            var reason = classify_unit_space_shortage();
            if(reason == 'recycle') {
                noun = 'unit_space_total_army'; verb = 'recycle';
            } else if(reason == 'base_defenders') {
                noun = 'unit_space_base_defenders'; verb = 'manage_base_defenders';
            } else if(reason == 'total_army') {
                noun = 'unit_space_total_army';
                target = find_object_by_type(gamedata['squad_building']);
                if(!target) {
                    verb = 'build_first';
                    target = gamedata['squad_building'];
                } else if(target.level < target.get_max_ui_level()) {
                    verb = 'upgrade';
                } else {
                    verb = 'recycle'; // nothing else to do
                }
            }
        } else {
            // non-squads case
            var specname = attack_space_building();
            if(specname == gamedata['townhall']) {
                // TR-like case where the townhall just needs to be upgraded
                target = player.get_townhall();
                if(!target || (target.level >= target.get_max_ui_level())) { return null; }
                noun = 'unit_space'; verb = 'upgrade';
            } else {
                // SG-like case where a separate building provides army space
                var cc_level = player.get_townhall_level();
                var num_built = 0;
                var min_level = 999, need_to_upgrade_obj = null;
                for(var id in session.cur_objects.objects) {
                    var obj = session.cur_objects.objects[id];
                    if(obj.spec['name'] === specname && obj.team === 'player') {
                        num_built += 1;
                        if(obj.level < min_level && obj.level < obj.get_max_ui_level()) {
                            min_level = obj.level;
                            need_to_upgrade_obj = obj;
                        }
                    }
                }
                if(num_built < get_leveled_quantity(gamedata['buildings'][specname]['limit'], cc_level)) {
                    // player has not built the full number yet
                    noun = 'unit_space'; verb = (num_built < 1 ? 'build_first' : 'build_more'); target = specname;
                } else if(need_to_upgrade_obj) {
                    // player has an under-leveled building
                    noun = 'unit_space'; verb = 'upgrade'; target = need_to_upgrade_obj;
                } else {
                    console.log('unable to help with unit_space problem!');  return null;
                }
            }
        }
    } else if(typeof(kind) === 'string' && kind.indexOf('inventory_space') != -1) {
        noun = kind;
        var warehouse = find_object_by_type(gamedata['inventory_building']);
        if(warehouse) {
            if(warehouse.level < warehouse.get_max_ui_level()) {
                verb = 'upgrade'; target = warehouse; ui_arg_s = warehouse.spec['ui_name'];
            } else {
                verb = 'discard_items'; target = warehouse; ui_arg_s = warehouse.spec['ui_name'];
            }
        } else {
            verb = 'build_first'; target = gamedata['inventory_building'];
            ui_arg_s = gamedata['buildings'][gamedata['inventory_building']]['ui_name_indefinite'];
        }
    } else if(kind == 'cc_limit') {
        noun = 'cc_limit'; verb = 'upgrade'; target = player.get_townhall();
        ui_arg_s = target.spec['ui_name']; ui_arg_d = arg['ui_name'];
    } else if(kind == 'limited_equipped') {
        noun = kind;
        var item_spec = ItemDisplay.get_inventory_item_spec(arg)
        target = player.get_townhall(); // assumes townhall is the building that provides_limited_equipped
        ui_arg_s = target.spec['ui_name']; ui_arg_d = ItemDisplay.get_inventory_item_ui_name_long(item_spec);

        var provides = target.spec['provides_limited_equipped'] && (item_spec['limited_equipped'] in target.spec['provides_limited_equipped']) ? target.spec['provides_limited_equipped'][item_spec['limited_equipped']] : -1;
        var cur = get_leveled_quantity(provides, target.level);
        var max_ever = get_leveled_quantity(provides, target.get_max_ui_level());
        if(max_ever > cur) {
            verb = 'upgrade';
        } else {
            verb = 'max';
        }
    } else if(kind == 'player_aura_limit') {
        noun = kind; verb = 'any';
    } else if(kind == 'invalid_building_location') {
        noun = kind; verb = arg;
    } else if(kind == 'tech_for_repair') {
        var unit_spec = gamedata['units'][arg];
        noun = kind; verb = 'research'; target = unit_spec['level_determined_by_tech']; ui_arg_s = unit_spec['ui_name'];
    } else if(kind == 'foreman') {
        // find an extra_foreman for the player to upgrade
        var min_level = 999, need_to_upgrade_obj = null;
        var num_built = 0;

        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(('provides_foremen' in obj.spec) && obj.team === 'player') {
                num_built += 1;
                if(obj.level < min_level && obj.level < obj.get_max_ui_level()) {
                    min_level = obj.level;
                    need_to_upgrade_obj = obj;
                }
            }
        }

        // find what type of building provides foremen
        var builder_spec = null;
        goog.object.forEach(gamedata['buildings'], function(spec) { if('provides_foremen' in spec) { builder_spec = spec; } });

        if(builder_spec && (num_built < get_leveled_quantity(builder_spec['limit'], player.get_townhall_level()))) {
            // player can build more foremen buidlings
            noun = 'foreman'; verb = (num_built < 1 ? 'build_first' : 'build_more'); target = builder_spec['name'];
            ui_arg_s = builder_spec[(num_built < 1 ? 'ui_name_indefinite' : 'ui_name')];
        } else if(need_to_upgrade_obj) {
            // player has an under-leveled extra_foreman (and we're assuming that they can be upgraded while other foremen are busy)
            noun = 'foreman'; verb = 'upgrade'; target = need_to_upgrade_obj;
            ui_arg_s = need_to_upgrade_obj.spec['ui_name'];
        } else {
            // fallback to a speedup dialog on one of the current busy buildings
            var tasks = player.foreman_get_tasks();
            if(tasks.length > 0) {
                return (function(_busy_obj) { return function() {
                    change_selection(_busy_obj);
                    invoke_speedup_dialog('speedup');
                }; })(tasks[0]);
            } else {
                console.log('cannot help with foreman problem!');
                return null;
            }
        }
    } else if(kind == 'friends') {
        if(arg.indexOf('invite') == 0) {
            noun = kind; verb = arg;
        } else {
            console.log('cannot help with friend problem: ' + (arg || 'unknown'));
            return null;
        }
    } else if(kind == 'crafting_ingredients') {
        noun = 'crafting';
        verb = 'obtain_ingredients';
        var item_list = [];
        goog.object.forEach(arg, function(qty, specname) {
            var spec = ItemDisplay.get_inventory_item_spec(specname);
            item_list.push(ItemDisplay.get_inventory_item_stack_prefix(spec, qty) + ItemDisplay.get_inventory_item_ui_name_long(spec));
        });
        ui_arg_s = item_list.join(', ');
    } else if(kind == 'speedup' || kind == 'repair') {
        noun = 'building';
        verb = kind;
        target = arg; // the object you want to speedup or repair
        ui_arg_s = arg.spec['ui_name'];
    } else if(kind.ui_help) {
        // it's a Predicate instance
        var ret = kind.ui_help(player);
        if(ret) {
            noun = ret['noun']; verb = ret['verb']; target = ret['target'] || null;
            ui_arg_s = ret['ui_arg_s'] || null; ui_arg_d = ret['ui_arg_d'] || null;
            ui_override_title = ret['ui_title'] || null; ui_override_description = ret['ui_name'] || null;
        }
    } else {
        console.log('unknown requirements help type! '+kind.toString());
    }

    //console.log(noun + ' '+verb+' '+target+' '+ui_arg_s+' '+ui_arg_d);

    if(!noun || !verb) { return null; }
    var tip = gamedata['strings']['requirements_help'][noun][verb];
    if(!tip) { return null; }

    var title = ui_override_title || tip['ui_title'].replace('%s', ui_arg_s ? ui_arg_s : '').replace('%d', ui_arg_d ? ui_arg_d.toString() : '');
    var descr = ui_override_description || tip['ui_description'].replace('%s', ui_arg_s ? ui_arg_s : '').replace('%d', ui_arg_d ? ui_arg_d.toString() : '');
    var button = tip['ui_button'] ? tip['ui_button'] : null;
    var cancel_button = tip['ui_cancel_button'] ? tip['ui_cancel_button'] : null;
    var help_function = null;
    var open_function = null;

    if(verb in gamedata['resources']) {
        if((('allow_instant' in gamedata['resources'][verb]) && !gamedata['resources'][verb]['allow_instant'])) {
            // cannot be bought
        } else {
            if(gamedata['client']['log_insufficient_resources']) {
                open_function = function() {
                    metric_event('5200_insufficient_resources_dialog', {});
                };
            }
            help_function = (function (_verb) { return function() {
                if(gamedata['client']['log_insufficient_resources']) {
                    metric_event('5201_insufficient_resources_go_to_store', {});
                }

                invoke_store(_verb);
            }; })(verb);
        }
    } else if(verb == 'build_more' || verb == 'build_first') {
        unit_icon = get_leveled_quantity(gamedata['buildings'][target]['art_asset'], 1);
        // note: hack to pass parameter via ui_ name
        help_function = (function (_specname) { return function() {
            var dialog = invoke_build_dialog(gamedata['buildings'][_specname]['build_category']);
            if(dialog) {
                // find page containing the building
                var index = dialog.user_data['speclist'].indexOf(_specname);
                if(index < 0) { return; }
                build_dialog_scroll(dialog, Math.floor(index / (dialog.data['widgets']['grid']['array'][0]*dialog.data['widgets']['grid']['array'][1])));

                // find widget representing the building the player needs to build
                var widget_name = null;
                var widget = null;
                var slots = dialog.user_data['slots_this_page'];
                for(var i = 0; i < slots.length; i++) {
                    var name_x_y = slots[i];
                    if(name_x_y[0] == _specname) {
                        widget_name = 'grid'+name_x_y[1].toString()+','+name_x_y[2].toString();
                        widget = dialog.widgets[widget_name];
                        break;
                    }
                }
                if(0) {
                    // try to simulate a click on the widget representing this building
                    if(widget && widget.onclick && widget.state != 'disabled') {
                        widget.onclick(widget);
                    }
                } else {
                    // wire up the ENTER key to build it
                    dialog.default_button = widget;

                    // create a tutorial arrow pointing to the building
                    var dir = 'down';
                    var arrow = make_ui_arrow(dir);
                    player.quest_root.add(arrow);
                    arrow.ondraw = update_tutorial_arrow_for_button(arrow, dialog.user_data['dialog'], widget_name, dir);

                    // hack - invoke_build_dialog() dirties the quest tracker state, we need to "reset" it here so
                    // that the arrow we make doesn't immediately get cleared
                    player.quest_tracked_dirty = false;
                    selection.ui_change_time = -1;
                }
            }
        }; })(target);
    } else if(verb == 'upgrade' || verb == 'upgrade_cc') {
        help_function = (function(_target) { return function() {
            change_selection_unit(_target);
            invoke_upgrade_building_dialog();
        }; })(target);
    } else if(verb == 'research') {
        help_function = (function (_target) { return function() {
            invoke_upgrade_tech_dialog(_target, null);
        }; })(target);
    } else if(verb == 'repair') {
        help_function = (function (_target) { return function() {
            change_selection_unit(_target);
            if(_target.is_repairing()) {
                invoke_speedup_dialog('speedup');
            } else {
                invoke_repair_dialog();
            }
        }; })(target);
    } else if(verb == 'speedup' || verb == 'finish_construction') {
        help_function = (function (_target) { return function() {
            change_selection_unit(_target);
            if(_target.time_until_finish() > 0) {
                invoke_speedup_dialog('speedup');
            } else if(_target.is_damaged() && !_target.is_repairing()) {
                invoke_repair_dialog();
            }
        }; })(target);
    } else if(verb == 'discard_items') {
        help_function = (function (_target) { return function() {
            if(!player.warehouse_is_busy()) {
                invoke_inventory_dialog();
            } else {
                change_selection_unit(target);
                if(target.is_damaged() && !target.is_repairing()) {
                    invoke_repair_dialog();
                } else {
                    invoke_speedup_dialog('speedup');
                }
            }
        }; })(target);
    } else if(verb == 'recycle') {
        help_function = function() { invoke_repair_control(); }
    } else if(verb == 'manage_base_defenders') {
        help_function = function() { invoke_squad_manage(SQUAD_IDS.BASE_DEFENDERS); }
    } else if(verb.indexOf('invite') == 0) {
        help_function = function() { invoke_invite_friends_dialog('get_requirements_help'); };
    }

    if(options.short_circuit) {
        return help_function;
    }

    return (function (_title, _descr, _button, _cancel_button, _help, _unit_icon, _options, _open_function) { return function() {
        var dialog = new SPUI.Dialog(gamedata['dialogs']['requirements_help_dialog']);
        dialog.user_data['dialog'] = 'requirements_help_dialog';
        install_child_dialog(dialog);
        dialog.modal = true;
        dialog.auto_center();
        dialog.widgets['close_button'].onclick = (function (_cancel) { return function(w) {
            close_parent_dialog(w);
            if(_cancel) { _cancel(); }
        }; })(_options.cancel_function);

        if(_cancel_button) {
            dialog.widgets['close_button'].str = _cancel_button;

            // swap around activity/passivity of buttons
            dialog.widgets['close_button'].state = 'active';
            dialog.widgets['ok_button'].state = 'passive';
            dialog.default_button = dialog.widgets['close_button'];
        }
        dialog.widgets['title'].str = _title;
        dialog.widgets['description'].set_text_with_linebreaking(_descr);
        if(_help) {
            dialog.widgets['ok_button'].show = true;
            if(_button) { dialog.widgets['ok_button'].str = _button; }
            dialog.widgets['ok_button'].onclick = (function (_help_func) { return function(w) {
                close_parent_dialog(w); _help_func();
            }; })(_help);
        }

        if(_unit_icon) {
            dialog.widgets['unit_icon'].show = true;
            dialog.widgets['unit_icon'].asset = _unit_icon;
        }

        if(_open_function) {
            _open_function();
        }

        return dialog;
    }; })(title, descr, button, cancel_button, help_function, unit_icon, options, open_function);
}

// upgrade a specific building (if preselect_building is null, use selection.unit)
/** @param {(GameObject|null)=} preselect_building */
function invoke_upgrade_building_dialog(preselect_building) { return invoke_upgrade_dialog_generic('BUILDING', null, preselect_building || null); }

// upgrade a technology
/** @param {string} techname
    @param {SPUI.Dialog|null=} prev_dialog */
function invoke_upgrade_tech_dialog(techname, prev_dialog) { return invoke_upgrade_dialog_generic(techname, prev_dialog || null, null); }

/** @param {string} techname
    @param {SPUI.Dialog|null} prev_dialog
    @param {GameObject|null} preselect */
function invoke_upgrade_dialog_generic(techname, prev_dialog, preselect) {

    if(techname == 'BUILDING') {
        // if building is busy, divert to speedup dialog
        var bldg = preselect || selection.unit;
        if(bldg.time_until_finish() > 0) {
            change_selection_unit(bldg);
            return invoke_child_speedup_dialog('speedup');
        }
    }

    // instantiate the dialog
    var dialog = new SPUI.Dialog(gamedata['dialogs']['upgrade_dialog']);

    // make the dialog modal and add it to the "desktop" (replacing any existing selection.ui)
    install_child_dialog(dialog);
    dialog.auto_center();
    dialog.modal = true;
    dialog.user_data['dialog'] = 'upgrade_dialog';
    dialog.user_data['unit'] = (preselect || selection.unit); // buildings only
    dialog.user_data['techname'] = techname;
    dialog.user_data['tech'] = (techname !== 'BUILDING' ? gamedata['tech'][techname] : null);
    dialog.user_data['prev_dialog'] = prev_dialog;
    dialog.user_data['context'] = null;
    dialog.user_data['feature_scroll'] = 0;
    dialog.user_data['equip_chooser'] = null;
    dialog.ondraw = update_upgrade_dialog;
    dialog.ondraw(dialog);
    return dialog;
}

/** Get list of features to show for a weapon on a unit or building
    @param {Object} spec
    @param {Object} spell
    @return {Array.<string>} */
function get_weapon_spell_features2(spec, spell) {
    var ret = [];
    ret.push('weapon_damage');
    if('effective_range' in spell) {
        ret.push('effective_weapon_range');
    }
    if(!is_melee_spell(spell)) {
        ret.push('weapon_range');
    }
    if('splash_range' in spell) {
        ret.push('splash_range');
    }
    if('accuracy' in spell) {
        ret.push('accuracy');
    }
    if('ui_priority_vs' in spell || 'ui_priority_vs' in spec) {
        ret.push('ui_priority_vs');
    }
    return ret;
};

function update_upgrade_dialog(dialog) {
    var techname = dialog.user_data['techname'];
    var unit = dialog.user_data['unit'];
    var tech = dialog.user_data['tech'];

    var old_level, max_level;

    if(techname != 'BUILDING') {
        old_level = (techname in player.tech ? player.tech[techname] : 0);
        max_level = get_max_ui_level(tech);
    } else {
        old_level = unit.level;
        max_level = unit.get_max_ui_level();
    }
    var new_level = old_level + 1;

    // whether it is possible to perform the upgrade using resources (vs. instant purchase)
    var use_resources_offered = true;

    // whether the player has fulfilled all requirements to perform
    // the upgrade/research, aside from having enough fungible resources
    var use_resources_requirements_ok = true, instant_requirements_ok = true;

    // requirements text for tooltip - add insufficient resource amounts for "Use Resources" tooltip
    var tooltip_req_instant = [], tooltip_req_use_resources = [];

    // whether the player has enough fungible resources
    var resources_ok = true;
    var resources_needed = {}; // dictionary of resource amounts needed
    var ui_resources_needed = []; // list of ui_strings describing resources we need, for tooltip

    // text describing any unsatisfied requirements
    var req = [];

    // already researched to maximum level?
    if(new_level > max_level) {
        use_resources_requirements_ok = instant_requirements_ok = false;
    }

    // is the appropriate building busy?
    var builder;
    if(tech) {
        var builder_type = get_lab_for(tech['research_category']);
        builder = find_object_by_type(builder_type);
        if(!builder && !player.is_cheater) {
            console.log('opened upgrade dialog but research lab was not present: '+techname+' '+tech['research_category']);
            invoke_research_dialog(null, tech['research_category']);
            return;
        }
        //change_selection_unit(builder);
    } else {
        builder = unit;
    }
    dialog.user_data['builder'] = builder;

    // building is missing, damaged or busy with something, cannot
    // perform upgrade/research

    if(!builder && !player.is_cheater) {
        use_resources_requirements_ok = instant_requirements_ok = false;
    } else if(builder && builder.is_damaged()) {
        req.push(dialog.data['widgets']['requirements_text']['ui_name_needs_repair'].replace('%s',builder.spec['ui_name']));
        use_resources_requirements_ok = false;
        if(tech) {
            // you CAN do an instant tech research even if the lab is daamged
        } else {
            instant_requirements_ok = false;
        }
    } else if(builder && builder.time_until_finish() > 0) {
        req.push(dialog.data['widgets']['requirements_text']['ui_name_busy'].replace('%s',builder.spec['ui_name']));
        use_resources_requirements_ok = false;
        if(tech) {
            // you CAN do an instant tech research even if the lab is busy
        } else {
            instant_requirements_ok = false;
        }
    }

    // now fill in some of the text fields inside of the dialog
    // by resetting the 'str' variable for a few widgets

    // dialog title
    // we are looking this up by the widget name, as specified in gamedata.json
    var widget = dialog.widgets['title'];

    if(tech) {
        if(old_level === 0) {
            dialog.widgets['title_bold'].str = dialog.data['widgets']['title_bold']['ui_name_unlock'];
            widget.str = widget.data['ui_name_unlock'].replace('%s',tech['ui_name']).replace('%d', new_level.toString());
        } else if(new_level > max_level) {
            dialog.widgets['title_bold'].str = dialog.data['widgets']['title_bold']['ui_name_stats'];
            widget.str = widget.data['ui_name_stats'].replace('%s',tech['ui_name']).replace('%d',max_level.toString());
        } else {
            widget.str = widget.data['ui_name'].replace('%s', tech['ui_name']).replace('%d', new_level.toString());
        }
    } else {
        if(new_level > max_level) {
            dialog.widgets['title_bold'].str = dialog.data['widgets']['title_bold']['ui_name_stats'];
            widget.str = widget.data['ui_name_stats'].replace('%s',unit.spec['ui_name']).replace('%d',max_level.toString());
        } else {
            widget.str = widget.data['ui_name'].replace('%s', unit.spec['ui_name']).replace('%d', new_level.toString());
        }
    }

    // big hero icon
    if(tech) {
        var asset, state = 'hero', pos_state = 'xy';;
        if('associated_unit' in tech && !('splash_image' in gamedata['units'][tech['associated_unit']])) { // UNIT without splash image
            var unit_spec = gamedata['units'][tech['associated_unit']];
            asset = get_leveled_quantity(unit_spec['art_asset'], (new_level > max_level ? max_level : new_level));

            var voffset;
            if(unit_spec['flying']) {
                voffset = -3*unit_spec['altitude'];
            } else {
                voffset = 0;
            }
            dialog.widgets['icon'].bg_image_offset = [dialog.data['widgets']['icon']['bg_image_offset'][0],
                                                      dialog.data['widgets']['icon']['bg_image_offset'][1] + voffset];
            dialog.widgets['icon'].alpha = unit_spec['cloaked'] ? gamedata['client']['cloaked_opacity'] : 1;
        } else {
            if('associated_unit' in tech && ('splash_image' in gamedata['units'][tech['associated_unit']])) { // UNIT with splash iamge
                asset = get_leveled_quantity(gamedata['units'][tech['associated_unit']]['splash_image'], (new_level > max_level ? max_level : new_level));
                pos_state = 'xy_unit_splash';
                if(old_level <= 1) {
                    state = 'normal_disabled';
                }
            } else if('splash_image' in tech) { // TECH with splash image
                asset = get_leveled_quantity(tech['splash_image'], (new_level > max_level ? max_level : new_level));
                if(GameArt.assets[asset].has_state('hero')) {
                    // 3D asset splash image
                } else {
                    // painted 2D splash image
                    state = 'normal';
                    pos_state = 'xy_splash';
                }
            } else { // TECH icon
                asset = get_leveled_quantity(tech['icon'], (new_level > max_level ? max_level : new_level));
            }

            if(!GameArt.assets[asset].has_state(state)) { // fallback for missing hero/normal_disabled
                state = 'normal';
            }
        }
        dialog.widgets['icon'].xy = dialog.data['widgets']['icon'][pos_state];
        dialog.widgets['icon'].asset = asset;
        dialog.widgets['icon'].state = state;
    } else {
        dialog.widgets['icon'].asset = get_leveled_quantity(unit.spec['art_asset'], (new_level > max_level ? max_level : new_level));
        // special-case because some buildings are really tall
        dialog.widgets['icon'].bg_image_offset = vec_add(dialog.data['widgets']['icon']['bg_image_offset'], unit.spec['hero_icon_pos'] || [0,0]);
    }

    dialog.widgets['cost_time'].show = (new_level <= max_level);
    for(var res in gamedata['resources']) {
        var show_res = (new_level <= max_level) && (tech ? ('cost_'+res in tech) : ('build_cost_'+res in unit.spec));
        if('resource_'+res+'_icon' in dialog.widgets) {
            dialog.widgets['resource_'+res+'_icon'].show = show_res;
            dialog.widgets['resource_'+res+'_icon'].asset = gamedata['resources'][res]['icon_small'];
        }
        if('cost_'+res in dialog.widgets) {
            dialog.widgets['cost_'+res].show = show_res;
        }
        if('resource_'+res+'_button' in dialog.widgets) {
            dialog.widgets['resource_'+res+'_button'].show = false;
        }
    }
    dialog.widgets['resource_power_button'].show = false;
    dialog.widgets['cost_power'].show =
        dialog.widgets['resource_power_icon'].show =
        (!tech && (unit.spec['kind'] === 'building') && (get_leveled_quantity(unit.spec['consumes_power']||0, max_level) > 0));

    // resource costs
    if(new_level > max_level) {
        // don't show resource costs if already at max level
        if(dialog.widgets['cost_power'].show) {
            dialog.widgets['cost_power'].tooltip.str = dialog.data['widgets']['cost_power']['ui_tooltip_maxlevel'];
            dialog.widgets['cost_power'].fixed_tooltip_offset = dialog.data['widgets']['cost_power']['fixed_tooltip_offset_maxlevel'];
            dialog.widgets['cost_power'].text_color = SPUI.default_text_color;
            dialog.widgets['cost_power'].str = pretty_print_number(get_leveled_quantity(unit.spec['consumes_power'], unit.level));
        }
        dialog.widgets['cost_time'].str = null;

    } else {
        var cost;

        for(var res in gamedata['resources']) {
            var resdata = gamedata['resources'][res];

            if(tech) {
                cost = get_leveled_quantity(tech['cost_'+res] || 0, new_level);
            } else {
                cost = get_leveled_quantity(unit.spec['build_cost_'+res] || 0, new_level);
            }

            if(!player.is_cheater && cost > 0 && ('allow_instant' in resdata) && !resdata['allow_instant']) {
                instant_requirements_ok = false;
                tooltip_req_instant.push(dialog.data['widgets']['instant_button']['ui_tooltip_rare_res'].replace('%s', resdata['ui_name']));
            }

            if(cost < 0) {
                use_resources_offered = false;
            } else if(player.resource_state[res][1] < cost) {
                resources_ok = false;
                resources_needed[res] = cost - player.resource_state[res][1];
                ui_resources_needed.push(dialog.data['widgets']['use_resources_button']['ui_tooltip_more_res'].replace('%d',pretty_print_number(cost - player.resource_state[res][1])).replace('%s',resdata['ui_name']));
            }

            if('cost_'+res in dialog.widgets) {
                widget = dialog.widgets['cost_'+res];
                widget.show = (cost > 0);
                if('resource_'+res+'_icon' in dialog.widgets) {
                    dialog.widgets['resource_'+res+'_icon'].show = (cost > 0);
                }
                widget.str = pretty_print_qty_brief(cost);
                widget.tooltip.str = widget.data['ui_tooltip'].replace('%RES', resdata['ui_name']).replace('%QTY', pretty_print_number(cost));
                if(cost > 0 && player.resource_state[res][1] < cost) {
                    widget.text_color = SPUI.error_text_color;
                    // don't show button for topup, since the main "Use Resources" button will take care of it
                    if(!gamedata['resources'][res]['allow_topup'] && 'resource_'+res+'_button' in dialog.widgets) {
                        var helper = get_requirements_help(res, cost - player.resource_state[res][1]);
                        dialog.widgets['resource_'+res+'_button'].show = !!helper;
                        dialog.widgets['resource_'+res+'_button'].onclick = helper;
                    }
                } else {
                    widget.text_color = SPUI.good_text_color;
                }
            }
        }

        if(dialog.widgets['cost_power'].show) {
            var old_cost = get_leveled_quantity(unit.spec['consumes_power'], unit.level);
            cost = get_leveled_quantity(unit.spec['consumes_power'], unit.level+1);

            dialog.widgets['cost_power'].tooltip.str = dialog.data['widgets']['cost_power']['ui_tooltip'].replace('%CUR', pretty_print_number(old_cost)).replace('%DURING', pretty_print_number(get_leveled_quantity(unit.spec['consumes_power_while_building'], unit.level+1)));
            dialog.widgets['cost_power'].fixed_tooltip_offset = dialog.data['widgets']['cost_power']['fixed_tooltip_offset'];

            dialog.widgets['cost_power'].str = pretty_print_number(cost);

            // do not display energy text in red for central computer upgrades, because they allow more plants to be built
            if((unit.spec['name'] != gamedata['townhall']) &&
               (session.viewing_base.power_state[1] + cost - old_cost) > session.viewing_base.power_state[0]) {
                dialog.widgets['cost_power'].text_color = SPUI.error_text_color;
                var helper = get_requirements_help('power', null);
                dialog.widgets['resource_power_button'].show = !!helper;
                dialog.widgets['resource_power_button'].onclick = helper;
            } else {
                dialog.widgets['cost_power'].text_color = SPUI.good_text_color;
            }

        }

        var cost_time = get_leveled_quantity((tech ? tech['research_time'] : unit.spec['build_time']), new_level);
        if(tech && builder) { cost_time = Math.floor(cost_time / builder.get_stat('research_speed',1)); }
        widget = dialog.widgets['cost_time'];
        widget.str = (cost_time > 0 ? pretty_print_time(cost_time) : '');

    } // END if not at max level

    dialog.widgets['cost_time_bar'].show = dialog.widgets['cost_time_clock'].show = !!dialog.widgets['cost_time'].str;

    if(tech) {
        dialog.widgets['cost_power'].show = false;
        dialog.widgets['resource_power_icon'].show = false;
    }

    // get equipment slots
    dialog.user_data['equip_slots_by_type'] = {};
    var equip_slots = null;

    if(player.get_any_abtest_value('enable_equipment', gamedata['client']['enable_equipment']) &&
       (!tech || player.get_any_abtest_value('enable_unit_equipment', gamedata['client']['enable_unit_equipment']))) {
        if(tech && ('associated_unit' in tech)) {
            // unit equipment
            var unit_spec = gamedata['units'][tech['associated_unit']];
            equip_slots = unit_spec['equip_slots'] || null;
        }
        if(!tech) {
            // building equipment
            equip_slots = unit.spec['equip_slots'] || null;
        }
    }

    // FEATURES

    var feature_list = [];

    if(tech) {
        // UNIT OR GENERIC TECH
        if('associated_unit' in tech) {
            var spec = gamedata['units'][tech['associated_unit']];
            feature_list.push('max_hp');
            if(gamedata['show_armor_in_ui']) { feature_list.push('armor'); }
            feature_list = feature_list.concat(get_weapon_spell_features2(spec, get_auto_spell_for_unit(player, spec)));
            feature_list.push('maxvel');
            feature_list.push('consumes_space');
            if('on_destroy' in spec) { feature_list.push('on_destroy'); }
        } else if('associated_item' in tech) {
            var item_spec = ItemDisplay.get_inventory_item_spec(get_leveled_quantity(tech['associated_item'], Math.min(new_level, max_level)));
            var auto_spell = get_auto_spell_for_item(item_spec);
            if(auto_spell) {
                feature_list = feature_list.concat(get_weapon_spell_features2(item_spec, auto_spell));
            }
        } else if('associated_building' in tech) {
            feature_list.push('limit:'+tech['associated_building']);
        }
    } else {
        // BUILDING
        if(unit.spec['show_hp_stat']) { feature_list.push('max_hp'); }
        if(unit.is_researcher()) { feature_list.push('research_level'); }
        if(unit.is_researcher()) { feature_list.push('research_speed'); }
        if(unit.is_crafter() && !unit.is_emplacement() && !('crafting_speed' in unit.spec)) { feature_list.push('crafting_level'); }
        if(unit.is_crafter() && ('crafting_queue_space' in unit.spec)) { feature_list.push('crafting_queue_space'); }
        goog.object.forEach(gamedata['resources'], function(resdata, resname) {
            if(('produces_'+resname) in unit.spec) { feature_list.push('produces_'+resname); }
            if(('storage_'+resname) in unit.spec && !('provides_space' in unit.spec) /* omit on CC */ ) { feature_list.push('storage_'+resname); }
        });
        if('provides_power' in unit.spec) { feature_list.push('provides_power'); }
        if('provides_foremen' in unit.spec) { feature_list.push('provides_foremen'); }

        if('provides_quarry_control' in unit.spec && session.region.map_enabled()) { feature_list.push('provides_quarry_control'); }
        if(player.squads_enabled()) {
            if('provides_total_space' in unit.spec) { feature_list.push('provides_total_space'); }
            if('provides_space' in unit.spec) { feature_list.push('provides_space'); }
            if('provides_squads' in unit.spec) { feature_list.push('provides_squads'); }
            if('provides_deployed_squads' in unit.spec) { feature_list.push('provides_deployed_squads'); }
            if('provides_squad_space' in unit.spec) { feature_list.push('provides_squad_space'); }
        } else {
            if('provides_space' in unit.spec) { feature_list.push('provides_space'); }
        }

        // attack space
        if(('provides_space' in unit.spec) && (gamedata['deployable_unit_space'] < 1)) { feature_list.push('deployable_unit_space'); }

        if('provides_donated_space' in unit.spec && player.unit_donation_enabled()) { feature_list.push('provides_donated_space'); }
        if('max_individual_donation_space' in unit.spec && player.unit_donation_enabled()) { feature_list.push('max_individual_donation_space'); }
        if('provides_inventory' in unit.spec) { feature_list.push('provides_inventory'); }

        if(unit.spec['name'] === gamedata['townhall']) {
            // not enough space in dialog for "limit:barriers" :(
            goog.array.forEach(['limit:storages','limit:harvesters','limit:turrets','limit:emplacements'], function(statname) {
                var statdata = gamedata['strings']['modstats']['stats'][statname];
                if(statdata) {
                    var check_spec = gamedata['buildings'][statdata['check_spec']];
                    if(!(check_spec['show_if']) || read_predicate(check_spec['show_if']).is_satisfied(player, null)) {
                        feature_list.push(statname);
                    }
                }
            });
            if(gamedata['enable_power']) {
                feature_list.push('limit:energy');
            }
        }

        if('provides_limited_equipped' in unit.spec) {
            goog.object.forEach(unit.spec['provides_limited_equipped'], function(num_array, kind) {
                var statname = 'provides_limited_equipped:'+kind;
                var statdata = gamedata['strings']['modstats']['stats'][statname];
                if(statdata) {
                    var check_spec = gamedata['buildings'][statdata['check_spec']];
                    if(!(check_spec['show_if']) || read_predicate(check_spec['show_if']).is_satisfied(player, null)) {
                        feature_list.push(statname);
                    }
                }
            });
        }

        if(unit.is_manufacturer()) {
            feature_list.push('manufacture_speed');
            feature_list.push('unit_repair_speed');
        }

        if(unit.is_crafter() && ('crafting_speed' in unit.spec)) {
            feature_list.push('crafting_speed');
        }

        var auto_spell = get_auto_spell_raw(unit.spec); // not unit.get_auto_spell(), since that includes equipped item mods
        if(auto_spell) {
            feature_list = feature_list.concat(get_weapon_spell_features2(unit.spec, auto_spell));
        }

        // test for new-style modstats
        //if('damage_taken' in unit.modstats) { feature_list.push('damage_taken'); }

    } // END is a building

    // gather misc. new-style modstats
    var modstats = null;
    if(!tech) {
        modstats = unit.modstats;
    } else if('associated_unit' in tech) {
        modstats = player.stattab['units'][tech['associated_unit']] || {};
    }
    if(modstats !== null) {
        goog.object.forEach(modstats,
                            function(modchain, stat) {
                                if(stat in gamedata['strings']['modstats']['stats'] && !goog.array.contains(feature_list, stat) &&
                                   gamedata['strings']['modstats']['stats'][stat]['display'] !== null &&
                                   (stat.indexOf('weapon_')!=0 || stat.indexOf('weapon_damage_vs:')==0) && /* weapon* stats, except for weapon_damage_vs, should be handled above since they need to look up auto_spell */
                                   (stat != 'weapon' || !(unit && unit.is_emplacement())) && /* don't show "weapon" stat on emplacements */
                                   (modchain['mods'].length>1 && modchain['val'] != modchain['mods'][0]['val'])) {
                                    feature_list.push(stat);
                                }
                            });
    }

    var grid_y = 0;
    var delta_color = SPUI.make_colorv(dialog.data['widgets']['col0,']['delta_color']);

    function feature_widget(dialog, y, x) { return dialog.widgets['col'+x.toString()+','+y.toString()]; }

    var max_rows = dialog.data['widgets']['col0,']['array'][1] + (equip_slots ? -1 : 0); // equip_slots cover last line

    dialog.widgets['feature_scroll_up'].show = dialog.widgets['feature_scroll_down'].show = (feature_list.length > max_rows);
    if(dialog.widgets['feature_scroll_up'].show) {
        dialog.user_data['feature_scroll'] = Math.max(Math.min(dialog.user_data['feature_scroll'], feature_list.length - max_rows), 0);
        dialog.widgets['feature_scroll_up'].state = (dialog.user_data['feature_scroll'] > 0 ? 'normal' : 'disabled');
        dialog.widgets['feature_scroll_down'].state = (dialog.user_data['feature_scroll'] < (feature_list.length-max_rows) ? 'normal' : 'disabled');
        dialog.widgets['feature_scroll_up'].onclick = function(w) { w.parent.user_data['feature_scroll'] -= 1; };
        dialog.widgets['feature_scroll_down'].onclick = function(w) { w.parent.user_data['feature_scroll'] += 1; };
    } else {
        dialog.user_data['feature_scroll'] = 0;
    }

    for(var i = dialog.user_data['feature_scroll']; i < feature_list.length; i++) {

        if(grid_y >= max_rows) {
            //console.log("ran out of space to list features! need " + feature_list.length.toString());
            break;
        }
        var stat_name = feature_list[i];

        var spec = null;
        var old_spell_level = old_level, new_spell_level = new_level; // levels keying the auto_spell stats we are displaying
        if(!tech) {
            spec = unit.spec;
        } else if('associated_unit' in tech) {
            spec = gamedata['units'][tech['associated_unit']];
        } else if('associated_item' in tech) {
            spec = ItemDisplay.get_inventory_item_spec(get_leveled_quantity(tech['associated_item'], Math.min(new_level, max_level))); // note! doesn't handle item type changing!
        } else if('associated_building' in tech) {
            spec = gamedata['buildings'][tech['associated_building']];
        } else {
            throw Error('cannot display feature '+stat_name+' for upgrade that has no building or associated unit or item');
        }

        var modchain = null;
        if(!tech) {
            modchain = unit.modstats[stat_name] || null;
        } else if('associated_unit' in tech) {
            modchain = (player.stattab['units'][tech['associated_unit']] || {})[stat_name] || null;
        }

        var old_chain = null, new_chain = null;
        if(old_level > 0) {
            old_chain = modchain;
        }
        if(new_level <= max_level) {
            var new_base_value = ModChain.get_base_value(stat_name, spec, new_level);
            new_chain = (modchain ? ModChain.recompute_with_new_base_val(modchain, new_base_value, new_level) : ModChain.make_chain(new_base_value, {'level':new_level}));
        }

        // some special cases that rebase mod chains
        var rebase_old = null, rebase_new = null;

        // special case to conceal absolute harvester rates
        if(stat_name.indexOf('produces_') === 0 && (gamedata['strings']['modstats']['stats'][stat_name]['display_value'] || 'relative') == 'relative') {
            var one = get_leveled_quantity(spec[stat_name], 1);
            if(old_level > 0) { rebase_old = get_leveled_quantity(spec[stat_name], old_level) / one; }
            if(new_level <= max_level) { rebase_new = get_leveled_quantity(spec[stat_name], new_level) / one; }
        // special case to rebase deployable unit space
        } else if(stat_name == 'deployable_unit_space') {
            if(old_level > 0) { rebase_old = Math.floor(gamedata['deployable_unit_space']*get_leveled_quantity(spec['provides_space'], old_level)); }
            if(new_level <= max_level) { rebase_new = Math.floor(gamedata['deployable_unit_space']*get_leveled_quantity(spec['provides_space'], new_level)); }
        }

        if(rebase_old !== null) { old_chain = (old_chain ? ModChain.recompute_with_new_base_val(old_chain, rebase_old, old_level) : ModChain.make_chain(rebase_old, {'level':old_level})); }
        if(rebase_new !== null) { new_chain = (new_chain ? ModChain.recompute_with_new_base_val(new_chain, rebase_new, new_level) : ModChain.make_chain(rebase_new, {'level':new_level})); }

        var new_column = -1;
        var old_auto_spell, new_auto_spell;
        if(tech) {
            if('associated_unit' in tech) {
                old_auto_spell = new_auto_spell = get_auto_spell_for_unit(player, spec);
            } else if('associated_item' in tech) {
                old_auto_spell = get_auto_spell_for_item(ItemDisplay.get_inventory_item_spec(get_leveled_quantity(tech['associated_item'], Math.max(1,old_level))));
                new_auto_spell = get_auto_spell_for_item(ItemDisplay.get_inventory_item_spec(get_leveled_quantity(tech['associated_item'], Math.min(new_level,max_level))));
            } else if('associated_building' in tech) {
                old_auto_spell = new_auto_spell = null;
            } else {
                throw Error('cannot determine auto_spell for tech '+tech['name']);
            }
        } else {
            old_auto_spell = new_auto_spell = unit.get_auto_spell();
        }

        feature_widget(dialog, grid_y, 0).show = true;
        ModChain.display_label_widget(feature_widget(dialog, grid_y, 0), stat_name, old_auto_spell);

        if(old_level <= 0) {
            feature_widget(dialog, grid_y, 1).show = true;
            feature_widget(dialog, grid_y, 2).show = false;
            ModChain.display_widget(feature_widget(dialog, grid_y, 1), stat_name, new_chain, spec, new_level, new_auto_spell, new_spell_level);
        } else if(new_level > max_level) {
            feature_widget(dialog, grid_y, 1).show = true;
            feature_widget(dialog, grid_y, 2).show = false;
            ModChain.display_widget(feature_widget(dialog, grid_y, 1), stat_name, old_chain, spec, old_level, old_auto_spell, old_spell_level);
        } else {
            feature_widget(dialog, grid_y, 1).show = true;
            feature_widget(dialog, grid_y, 2).show = true;
            ModChain.display_widget(feature_widget(dialog, grid_y, 1), stat_name, old_chain, spec, old_level, old_auto_spell, old_spell_level);
            ModChain.display_widget(feature_widget(dialog, grid_y, 2), stat_name, new_chain, spec, new_level, new_auto_spell, new_spell_level); // sets text color
            if(feature_widget(dialog, grid_y, 2).str != feature_widget(dialog, grid_y, 1).str) {
                feature_widget(dialog, grid_y, 2).text_color = delta_color;
            }
        }

        grid_y += 1;
    }
    while(grid_y < max_rows) {
        feature_widget(dialog, grid_y, 0).show =
            feature_widget(dialog, grid_y, 1).show =
            feature_widget(dialog, grid_y, 2).show = false;
        grid_y += 1;
    }

    if(feature_list.length < 1) {
        dialog.widgets['header0'].show =
            dialog.widgets['header1'].show = false;
    } else if(old_level <= 0) {
        dialog.widgets['header0'].str = dialog.widgets['header0'].data['ui_name'].replace('%d', new_level);
        dialog.widgets['header1'].show = false;
    } else if(new_level > max_level) {
        dialog.widgets['header0'].str = dialog.widgets['header0'].data['ui_name'].replace('%d', old_level);
        dialog.widgets['header1'].show = false;
    } else {
        dialog.widgets['header0'].str = dialog.widgets['header0'].data['ui_name'].replace('%d', old_level);
        dialog.widgets['header1'].str = dialog.widgets['header1'].data['ui_name'].replace('%d', new_level);
        if(unit && unit.spec['name'] == gamedata['townhall']) {
            dialog.widgets['upgrade_info_button'].show = true;
            dialog.widgets['upgrade_info_button'].onclick = function(w) { invoke_cc_upgrade_info(); };
        }
    }

    // set up equipment widgets
    if(equip_slots) {
            // horrible hack to deal with tooltip overlap
            var child_dialog = (dialog.children[dialog.children.length-1].user_data && dialog.children[dialog.children.length-1].user_data['dialog']);
            equip_slots = get_leveled_quantity(equip_slots, Math.max(old_level, 1));
            var last_label = null, slot_i = 0;

            for(var type_name in equip_slots) {
                if(!player.is_cheater && ('show' in gamedata['strings']['equip_slots'][type_name]) && !gamedata['strings']['equip_slots'][type_name]['show']) { continue; }
                var n_slots = get_leveled_quantity(equip_slots[type_name], Math.max(old_level, 1));
                var max_slots = get_leveled_quantity(equip_slots[type_name], max_level);
                var n = 0;
                for(; n < n_slots; n++) {
                    if(slot_i >= dialog.data['widgets']['equip_slot']['array'][0]) { break; }

                    if(type_name != last_label) {
                        dialog.user_data['equip_slots_by_type'][type_name] = slot_i;
                        dialog.widgets['equip_type'+slot_i].show = true;
                        dialog.widgets['equip_type'+slot_i].str = gamedata['strings']['equip_slots'][type_name]['ui_name']+':';
                        last_label = type_name;
                    }

                    dialog.widgets['equip_slot'+slot_i].show =
                        dialog.widgets['equip_frame'+slot_i].show = true;

                    dialog.widgets['equip_slot'+slot_i].state = 'normal';
                    dialog.widgets['equip_slot'+slot_i].tooltip.str = null;

                    dialog.widgets['equip_frame'+slot_i].onclick = (function (_tech, _unit, _type_name, _n, _slot_i) { return function(w) {
                        // check for in-flight requests
                        if(tech) {
                            if(player.unit_equipment[tech['associated_unit']] &&
                               player.unit_equipment[tech['associated_unit']]['equip_pending']) { return; }
                        } else {
                            if(_unit.equip_pending) { return; }
                        }

                        // kill item tooltip
                        invoke_inventory_context(w.parent, w, -1, null, false);
                        var error = null;
                        if(player.warehouse_is_busy()) {
                            error = gamedata['errors']["WAREHOUSE_IS_BUSY"];
                        } else if(!tech &&
                                  (_unit.is_damaged() ||
                                   _unit.is_busy())) {
                            error = gamedata['errors']["CANNOT_EQUIP_BUILDING_WHILE_BUSY"];
                        }
                        if(error) {
                            invoke_child_message_dialog(error['ui_title'], error['ui_name'], {'dialog': 'message_dialog_big'});
                        } else {
                            invoke_equip_chooser(w.parent, w, _tech, _unit, _type_name, _n, _slot_i);
                        }
                    }; })(tech, unit, type_name, n, slot_i);

                    slot_i++;
                }
                for(; n < max_slots; n++) {
                    if(slot_i >= dialog.data['widgets']['equip_slot']['array'][0]) { break; }

                    if(type_name != last_label) {
                        dialog.user_data['equip_slots_by_type'][type_name] = slot_i;
                        dialog.widgets['equip_type'+slot_i].show = true;
                        dialog.widgets['equip_type'+slot_i].str = gamedata['strings']['equip_slots'][type_name]['ui_name']+':';
                        last_label = type_name;
                    }

                    var unlocks_at = old_level;
                    for(var l = old_level; l <= max_level; l++) {
                        if(get_leveled_quantity(equip_slots[type_name], l) >= n+1) {
                            unlocks_at = l;
                            break;
                        }
                    }
                    dialog.widgets['equip_frame'+slot_i].show =
                        dialog.widgets['equip_item'+slot_i].show = false;
                    dialog.widgets['equip_slot'+slot_i].state = 'locked';
                    dialog.widgets['equip_slot'+slot_i].show = true;
                    dialog.widgets['equip_slot'+slot_i].onclick = null;
                    dialog.widgets['equip_slot'+slot_i].tooltip.str = (!child_dialog ? dialog.data['widgets']['equip_slot']['ui_tooltip_unlocks_at'].replace('%d', unlocks_at.toString()) : null);
                    slot_i++;
                }
            }
    }

    // set up damage_vs icons
    if(!tech) {
        init_damage_vs_icons(dialog, unit.spec, get_auto_spell_raw(unit.spec)); // note: not unit.get_auto_spell(), since that includes equipped item mods
    } else if(tech['associated_unit']) {
        init_damage_vs_icons(dialog, gamedata['units'][tech['associated_unit']], get_auto_spell_for_unit(player, gamedata['units'][tech['associated_unit']]));
    } else if(tech['associated_item']) {
        var spell = get_auto_spell_for_item(ItemDisplay.get_inventory_item_spec(get_leveled_quantity(tech['associated_item'],Math.min(new_level, max_level))));
        init_damage_vs_icons(dialog, {'name': tech['name'], 'kind':'building', 'ui_damage_vs':{}}, // fake building spec to fool init_damage_vs_icons()
                             spell); // spell's ui_damage_vs will take precedence
    } else {
        init_damage_vs_icons(dialog, null, null);
    }

    // shift damage_vs icons over to make room for mod display
    if(tech && player.get_any_abtest_value('enable_mod_techs', gamedata['enable_mod_techs'])) {
        for(var i = 0; i < dialog.data['widgets']['damage_vs']['array'][0]; i++) {
            var w = dialog.widgets['damage_vs'+i.toString()];
            w.xy[0] = dialog.data['widgets']['damage_vs']['xy'][0] + i*dialog.data['widgets']['damage_vs']['array_offset'][0] + dialog.data['widgets']['icon']['mod_shift'][0];
        }
        dialog.widgets['damage_vs_label'].xy = vec_add(dialog.data['widgets']['damage_vs_label']['xy'], dialog.data['widgets']['icon']['mod_shift']);
    }

    // get tech requirements
    var req_spec = null;
    if(tech) {
        if('requires' in tech) {
            req_spec = tech['requires'];
        }
    } else {
        if('requires' in unit.spec) {
            req_spec = unit.spec['requires'];
        }
    }

    dialog.widgets['predicate_help_button'].show = false;

    if(new_level > max_level) {
        req.push(gamedata['errors']['MAX_LEVEL_REACHED']['ui_name']);
    } else if(builder && builder.is_damaged()) {
        // builder needs repair
        dialog.widgets['predicate_help_button'].show = true;
        dialog.widgets['predicate_help_button'].onclick = function(w) {
            var dialog = w.parent;
            change_selection_unit(dialog.user_data['builder']);
            if(selection.unit.is_repairing()) {
                invoke_child_speedup_dialog('speedup');
            } else {
                invoke_child_repair_dialog();
            }
        };
    } else if(builder && (builder.time_until_finish() > 0)) {
        // builder is busy
        dialog.widgets['predicate_help_button'].show = true;
        dialog.widgets['predicate_help_button'].onclick = function(w) {
            var dialog = w.parent;
            change_selection_unit(dialog.user_data['builder']);
            invoke_child_speedup_dialog('speedup');
        };
    } else if(req_spec && !player.is_cheater) {
        var pred = read_predicate(get_leveled_quantity(req_spec, new_level));
        var text = pred.ui_describe(player);  // XXX make ui_describe return a list
        if(text) {
            req.push(text);
            use_resources_requirements_ok = instant_requirements_ok = false;

            var helper = get_requirements_help(pred, null);
            dialog.widgets['predicate_help_button'].show = !!helper;
            dialog.widgets['predicate_help_button'].onclick = helper;
        }
    }

    dialog.widgets['requirements_text'].set_text_with_linebreaking(req.join(', '));

    for(var i = 0; i < req.length; i++) {
        tooltip_req_instant.push(req[i]);
        tooltip_req_use_resources.push(req[i]);
    }
    for(var i = 0; i < ui_resources_needed.length; i++) {
        tooltip_req_use_resources.push(ui_resources_needed[i]);
    }
    if(tooltip_req_instant.length > 0) { tooltip_req_instant.splice(0, 0, dialog.data['widgets']['use_resources_button']['ui_tooltip_unmet']); }
    if(tooltip_req_use_resources.length > 0) { tooltip_req_use_resources.splice(0, 0, dialog.data['widgets']['use_resources_button']['ui_tooltip_unmet']); }


    var flavor_text;
    if(tech) {
        if(tech['ui_description']) {
            flavor_text = tech['ui_description'];
        } else if(tech['associated_unit']) {
            flavor_text = gamedata['units'][tech['associated_unit']]['ui_description'] || '';
        } else {
            flavor_text = '';
        }
    } else {
        flavor_text = unit.spec['ui_description'] || '';
    }
    dialog.widgets['flavor_text'].set_text_with_linebreaking(flavor_text);

    // connect button widget onclick() handlers

    if(new_level > max_level) {
        // already at max level
        dialog.widgets['instant_button'].show = dialog.widgets['instant_credits'].show = dialog.widgets['use_resources_button'].show = false;
        // note: timer bar already hidden above
    } else {
        dialog.widgets['instant_button'].show = dialog.widgets['instant_credits'].show = dialog.widgets['use_resources_button'].show = true;

    // ! block below is deliberately one indent left to minimize diff

    // "Use Resources" button
    dialog.widgets['use_resources_button'].show = use_resources_offered;
    dialog.widgets['use_resources_button'].tooltip.str = null;

    var upgrade_func; // function to actually perform the (non-paid) upgrade
    if(tech) {
        upgrade_func = (function (_dialog) { return function() {
            // tell the server to research this tech
            var builder = _dialog.user_data['builder'] || null;
            if(builder) {
                send_to_server.func(["CAST_SPELL", builder.id, "RESEARCH_FOR_FREE", _dialog.user_data['techname']]);
                invoke_ui_locker(builder.request_sync(), (function (__dialog) { return function() { close_dialog(__dialog); }; })(_dialog));
            } else {
                close_dialog(_dialog);
            }
        }; })(dialog);
    } else {
        upgrade_func = (function (_dialog) { return function() {
            var unit = _dialog.user_data['unit'];

            var do_upgrade_func = (function (__unit, __dialog) { return function() {
                // tell the server we want to upgrade this building
                send_to_server.func(["CAST_SPELL", __unit.id, "UPGRADE_FOR_FREE"]);

                // trigger effect
                var fx_data = ('upgrade_start_effect' in __unit.spec ?
                               __unit.spec['upgrade_start_effect'] :
                               gamedata['client']['vfx']['building_upgrade_start']);
                if(fx_data) {
                    SPFX.add_visual_effect([__unit.x,__unit.y], 0, [0,1,0], client_time, fx_data,
                                           true, // !spec['worth_less_xp'], // no sound for barrier upgrades?
                                           { '%OBJECT_SPRITE': __unit.get_leveled_quantity(__unit.spec['art_asset'])});
                }

                invoke_ui_locker(__unit.request_sync(), (function (___dialog) { return function() { close_dialog(___dialog); }; })(__dialog));
            }; })(unit, _dialog);

            var confirm = unit.spec['name']+'_confirm_upgrade';
            if(confirm in gamedata['strings'] &&
               (unit.spec['name'] == gamedata['region_map_building'] && !player.get_any_abtest_value('region_map_available_during_transmitter_upgrade',gamedata['territory']['region_map_available_during_transmitter_upgrade'])) ||
               (unit.spec['name'] == gamedata['inventory_building'] && !player.get_any_abtest_value('inventory_available_during_warehouse_upgrade', gamedata['inventory_available_during_warehouse_upgrade']))) {
                // confirmation dialog
                var s = gamedata['strings'][confirm];
                invoke_child_message_dialog(s['ui_title'], s['ui_description'],
                                            {'cancel_button': true,
                                             'ok_button_ui_name': s['ui_button'],
                                             'on_ok': do_upgrade_func});
            } else {
                do_upgrade_func();
            }
        }; })(dialog);
    }

    if(builder && !builder.is_in_sync()) {
        dialog.widgets['use_resources_button'].state = 'disabled';
    } else if(use_resources_requirements_ok && resources_ok) {
        dialog.widgets['use_resources_button'].state = 'normal';
        dialog.widgets['use_resources_button'].onclick = upgrade_func;
    } else {
        dialog.widgets['use_resources_button'].state = 'disabled';
        if(tooltip_req_use_resources.length > 0) {
            dialog.widgets['use_resources_button'].tooltip.text_color = SPUI.error_text_color;
            dialog.widgets['use_resources_button'].tooltip.str = tooltip_req_use_resources.join('\n');
        }

        // search for appropriate "+" button to get help
        if(player.get_any_abtest_value('upgrade_dialog_clickhelp', gamedata['client']['upgrade_dialog_clickhelp'])) {
            var help_func = null;

            var HELPERS = ['predicate_help_button', 'resource_power_button'];
            for(var res in gamedata['resources']) {
                if('resource_'+res+'_button' in dialog.widgets) {
                    HELPERS.push('resource_'+res+'_button');
                }
            }
            for(var i = 0; i < HELPERS.length; i++) {
                var h = HELPERS[i];
                if(dialog.widgets[h].show) {
                    help_func = dialog.widgets[h].onclick;
                    break;
                }
            }

            var button_is_normal = false;

            if(!help_func && !resources_ok) {
                // try a resource basket
                // special case that leads to the "buy resources" dialog
                help_func = get_requirements_help('resources', resources_needed, {continuation:upgrade_func});

                // don't gray out the button if all resources can be topped-up
                var can_topup = true;
                for(var res in resources_needed) {
                    if(!gamedata['resources'][res]['allow_topup']) {
                        can_topup = false; break;
                    }
                }
                if(can_topup) { button_is_normal = true; }
            }

            if(help_func) {
                dialog.widgets['use_resources_button'].state = (button_is_normal ? 'normal' : 'disabled_clickable');
                dialog.widgets['use_resources_button'].onclick = help_func;
            }
        }
    }

    // "Instant" button

    if(get_leveled_quantity(tech ? (gamedata['tech'][techname]['research_credit_cost']||-1) : (unit.spec['upgrade_credit_cost']||-1), new_level) < 0) {
        // instant upgrade not offered
        dialog.widgets['instant_button'].show = dialog.widgets['instant_credits'].show = false;
        dialog.default_button = dialog.widgets['use_resources_button'];

        if(dialog.widgets['use_resources_button'].state == 'normal') {
            // make use_resources_button yellow and default
            dialog.widgets['use_resources_button'].state = 'active';
        } else if(dialog.widgets['use_resources_button'].state == 'disabled_clickable') {
            // dialog.widgets['use_resources_button'].state = 'normal'; ?
        }
    } else {
        dialog.default_button = dialog.widgets['instant_button'];

    // ! block below is deliberately one indent left to minimize diff
    var price;
    if(tech) {
        if(builder || player.is_cheater) {
            price = Store.get_user_currency_price(builder ? builder.id : 0, gamedata['spells']['RESEARCH_FOR_MONEY'], techname);
        } else {
            price = -1;
        }
    } else {
        price = Store.get_user_currency_price(unit.id, gamedata['spells']['UPGRADE_FOR_MONEY'], null);
    }

    // just for diagnotics - price should always be -1 if requirements are not met
    if(!instant_requirements_ok && price >= 0 && !player.is_cheater) {
        console.log('requirements/price mismatch!');
    }

    widget = dialog.widgets['instant_credits'];
    widget.bg_image = player.get_any_abtest_value('price_display_asset', gamedata['store']['price_display_asset']);
    widget.state = Store.get_user_currency();
    widget.str = Store.display_user_currency_price(price); // PRICE
    widget.tooltip.str = Store.display_user_currency_price_tooltip(price);

    if(price < 0) {
        // cannot make a purchase because tech requirements are not fulfilled
        dialog.widgets['instant_credits'].onclick = null;
        dialog.widgets['instant_button'].state = 'disabled';
        if(tooltip_req_instant.length > 0) {
            dialog.widgets['instant_button'].tooltip.str = tooltip_req_instant.join('\n');
            dialog.widgets['instant_button'].tooltip.text_color = SPUI.error_text_color;
        }

        if(player.get_any_abtest_value('upgrade_dialog_clickhelp', gamedata['client']['upgrade_dialog_clickhelp']) &&
           dialog.widgets['predicate_help_button'].show) {
            dialog.widgets['instant_button'].state = 'disabled_clickable';
            dialog.widgets['instant_credits'].onclick = dialog.widgets['instant_button'].onclick = dialog.widgets['predicate_help_button'].onclick;
        }

    } else if(price == 0) {
        dialog.widgets['instant_button'].state = 'normal';
        if(tech) {
            // if research is free, just do an RESEARCH_FOR_FREE followed by a SPEEDUP_FOR_FREE
            dialog.widgets['instant_credits'].onclick =
                dialog.widgets['instant_button'].onclick = function(w) {
                    var dialog = w.parent; if(!dialog) { return; }
                    var builder = dialog.user_data['builder'], techname = dialog.user_data['techname'];
                    if(builder) {
                        send_to_server.func(["CAST_SPELL", builder.id, "RESEARCH_FOR_FREE", techname]);
                        send_to_server.func(["CAST_SPELL", builder.id, "SPEEDUP_FOR_FREE"]);
                        builder.request_sync();
                    }
                    close_parent_dialog(w);
                };
        } else {
            // if upgrade is free, just do an UPGRADE_FOR_FREE followed by a SPEEDUP_FOR_FREE
            dialog.widgets['instant_credits'].onclick =
                dialog.widgets['instant_button'].onclick = function(w) {
                    var dialog = w.parent; if(!dialog) { return; }
                    var unit = dialog.user_data['unit'];
                    send_to_server.func(["CAST_SPELL", unit.id, "UPGRADE_FOR_FREE"]);
                    send_to_server.func(["CAST_SPELL", unit.id, "SPEEDUP_FOR_FREE"]);
                    unit.request_sync();
                    close_parent_dialog(w);
            };
        }
    } else {
        if(builder && !builder.is_in_sync()) {
            // waiting for server response
            dialog.widgets['instant_button'].state = 'disabled';
            dialog.widgets['instant_button'].str = dialog.data['widgets']['instant_button']['ui_name_pending'];
            dialog.widgets['instant_credits'].onclick = dialog.widgets['instant_button'].onclick = null;
        } else {
            dialog.widgets['instant_button'].state = 'normal';
            dialog.widgets['instant_button'].str = dialog.data['widgets']['instant_button']['ui_name'];

            var cleanup_cb = (function (_widget) { return function() {
                close_parent_dialog(_widget);
            }; })(widget);

            if(tech) {
                dialog.widgets['instant_credits'].onclick =
                    dialog.widgets['instant_button'].onclick = function(widget) {
                        var dialog = widget.parent; if(!dialog) { return; }
                        var builder = dialog.user_data['builder'], techname = dialog.user_data['techname'];

                        if(builder || player.is_cheater) {
                            if(Store.place_user_currency_order(builder ? builder.id : GameObject.VIRTUAL_ID, "RESEARCH_FOR_MONEY", techname, cleanup_cb)) {
                                invoke_ui_locker(builder ? builder.request_sync() : synchronizer.request_sync());
                            }
                        }
                    };
            } else {
                dialog.widgets['instant_credits'].onclick =
                    dialog.widgets['instant_button'].onclick = function(widget) {
                        var dialog = widget.parent; if(!dialog) { return; }
                        var unit = dialog.user_data['unit'];

                        if(Store.place_user_currency_order(unit.id, "UPGRADE_FOR_MONEY", null, cleanup_cb)) {
                            invoke_ui_locker(unit.request_sync());
                        }
                    };
            }
        }
    }

    } // END instant upgrade is offered

    } // END not at max level

    dialog.widgets['close_button'].onclick = function(w) {
        var _dialog = w.parent;
        var prev_dialog = _dialog.user_data['prev_dialog'];
        close_parent_dialog(w);
        if(prev_dialog) { prev_dialog(); }
    };

    update_upgrade_dialog_equipment(dialog);

    if(player.upgrade_bar_enabled()) {
        UpgradeBar.invoke(dialog, (tech ? 'tech' : 'building'),
                          (tech ? techname : (unit ? unit.spec['name'] : null)),
                          new_level, (unit ? unit.id : null));
    }

    // update tutorial UI
    player.quest_tracked_dirty = true;

    return dialog;
}

function update_upgrade_dialog_equipment(dialog) {
    var tech = dialog.user_data['tech'];
    var unit = dialog.user_data['unit'];

    // update equipment slots
    if((!tech && unit && unit.is_building() && ('equip_slots' in unit.spec) && player.get_any_abtest_value('enable_equipment', gamedata['client']['enable_equipment']) ||
        (tech && ('associated_unit' in tech) && player.get_any_abtest_value('enable_unit_equipment', gamedata['client']['enable_unit_equipment'])))) {

        var equip_pending = false;
        var equip_problem = player.warehouse_is_busy();
        var equip_slots = null, old_level = -1, max_level = -1;
        var equip = null;

        if(tech && ('associated_unit' in tech)) {
            // unit equipment
            var unit_spec = gamedata['units'][tech['associated_unit']];
            equip_slots = unit_spec['equip_slots'] || null;
            old_level = player.tech[tech['name']] || 0;
            max_level = get_max_ui_level(unit_spec);
            equip = player.unit_equipment[tech['associated_unit']] || {};
            equip_pending = !!(equip['equip_pending']);
        }

        if(!tech) {
            // building equipment
            equip_slots = unit.spec['equip_slots'] || null;
            old_level = unit.level;
            max_level = unit.get_max_ui_level();
            equip_pending = unit.equip_pending;
            equip_problem |= (unit.is_damaged() || unit.is_busy());
            equip = unit.equipment;
        }
        equip_problem |= equip_pending;

        if(equip_slots) {
            // horrible hack to deal with tooltip overlap
            var child_dialog = (dialog.children[dialog.children.length-1].user_data && dialog.children[dialog.children.length-1].user_data['dialog']);

            equip_slots = get_leveled_quantity(equip_slots, Math.max(old_level, 1));
            var slot_i = 0;
            for(var type_name in equip_slots) {
                if(!player.is_cheater && ('show' in gamedata['strings']['equip_slots'][type_name]) && !gamedata['strings']['equip_slots'][type_name]['show']) { continue; }

                var n_slots = get_leveled_quantity(equip_slots[type_name], Math.max(old_level, 1));
                var max_slots = get_leveled_quantity(equip_slots[type_name], max_level);

                var n = 0;
                for(; n < n_slots; n++) {
                    if(slot_i >= dialog.data['widgets']['equip_slot']['array'][0]) { break; }

                    dialog.widgets['equip_loading_spinner'+slot_i].show = equip_pending;
                    dialog.widgets['equip_loading_rect'+slot_i].show = equip_problem;

                    // update the items shown in the equipment slots
                    if(equip && (type_name in equip) && (equip[type_name].length > n) && equip[type_name][n]) {
                        var especname = equip[type_name][n];
                        var espec = ItemDisplay.get_inventory_item_spec(especname);
                        ItemDisplay.set_inventory_item_asset(dialog.widgets['equip_item'+slot_i], espec);
                        dialog.widgets['equip_item'+slot_i].show = true;
                        dialog.widgets['equip_frame'+slot_i].state = 'normal';

                        if(!child_dialog) {
                            dialog.widgets['equip_frame'+slot_i].onenter = (function (_slot_i, _type_name, _n, _espec) { return function(w) {
                                var dialog = w.parent;
                                if(dialog.user_data['context'] &&
                                   dialog.user_data['context'].user_data['slot'] === _slot_i) {
                                    return;
                                }
                                invoke_inventory_context(w.parent, w, _slot_i, {'spec':_espec['name']}, false, {'position':'top_or_bottom'});
                            }; })(slot_i, type_name, n, espec);
                        } else {
                            invoke_inventory_context(dialog, dialog.widgets['equip_frame'+slot_i], -1, null, false);
                            dialog.widgets['equip_frame'+slot_i].onenter = null;
                        }
                        dialog.widgets['equip_frame'+slot_i].onleave_cb = (function (_slot_i, _type_name, _n, _espec) { return function(w) {
                            if(dialog.user_data['context'] &&
                               dialog.user_data['context'].user_data['slot'] === _slot_i) {
                                invoke_inventory_context(w.parent, w, -1, null, false);
                            }
                        }; })(slot_i, type_name, n, espec);

                        dialog.widgets['equip_frame'+slot_i].tooltip.str = null;
                    } else { // slot is not filled
                        dialog.widgets['equip_item'+slot_i].show = false;
                        dialog.widgets['equip_frame'+slot_i].state = 'invisible';
                        dialog.widgets['equip_frame'+slot_i].onenter = null;
                        dialog.widgets['equip_frame'+slot_i].onleave_cb = null;
                        dialog.widgets['equip_frame'+slot_i].tooltip.str = (!child_dialog ? dialog.data['widgets']['equip_frame']['ui_tooltip_empty'] : null);
                    }
                    slot_i++;
                }
                for(;n < max_slots; n++) {
                    if(slot_i >= dialog.data['widgets']['equip_slot']['array'][0]) { break; }
                    slot_i++;
                }
            }
        }
    }
}

function init_damage_vs_icons(dialog, spec, weapon_spell) {
    var show = (weapon_spell && (('ui_damage_vs' in weapon_spell) || ('ui_damage_vs' in spec)));

    if('damage_vs_label' in dialog.widgets) { dialog.widgets['damage_vs_label'].show = show; }

    var CATS = gamedata['strings']['damage_vs_categories'];
    var ui_damage_vs = (show ? ('ui_damage_vs' in weapon_spell ? weapon_spell['ui_damage_vs'] : spec['ui_damage_vs']) : null);

    for(var i = 0; i < CATS.length; i++) {
        var xy;
        if(dialog.data['widgets']['damage_vs']['array'][1] <= 1) {
            xy = [i,0]; // 2D array
        } else {
            xy = [i % dialog.data['widgets']['damage_vs']['array'][0], Math.floor(i / dialog.data['widgets']['damage_vs']['array'][0])];
        }
        var widget = dialog.widgets[SPUI.get_array_widget_name('damage_vs', dialog.data['widgets']['damage_vs']['array'], xy)];
        widget.show = show;
        if(show) {
            widget.show = (spec['kind'] !== 'building' || CATS[i][0] != 'building');

            if(spec['kind'] === 'building' && dialog.data['widgets']['damage_vs']['array'][1] <= 1) {
                // slide widgets to the right to re-center them with missing "vs building" icon
                widget.xy[0] = dialog.data['widgets']['damage_vs']['xy'][0] + i*dialog.data['widgets']['damage_vs']['array_offset'][0] + Math.ceil(dialog.data['widgets']['damage_vs']['array_offset'][0]/2);
            }

            if(!(CATS[i][0] in ui_damage_vs)) {
                throw Error('ui_damage_vs from '+('ui_damage_vs' in weapon_spell ? 'weapon_spell '+weapon_spell['name'] : 'spec '+spec['name'])+' missing entry '+CATS[i][0]);
            }

            var q = ui_damage_vs[CATS[i][0]];
            widget.asset = 'damage_vs_'+CATS[i][0];
            if(q in gamedata['strings']['damage_vs_qualities']) {
                widget.state = gamedata['strings']['damage_vs_qualities'][q];
            } else {
                throw Error('not found: damage_vs_qualities: '+q);
            }
            var ui_name;
            if(CATS[i][1] in gamedata['strings']['manufacture_categories']) {
                ui_name = gamedata['strings']['manufacture_categories'][CATS[i][1]]['plural'];
            } else if(CATS[i][1] in gamedata['strings']['object_kinds']) {
                ui_name = gamedata['strings']['object_kinds'][CATS[i][1]]['plural'];
            } else {
                throw Error('unknown manuf category or object kind '+CATS[i][1]);
            }
            widget.tooltip.str = gamedata['strings']['damage_vs_ui_qualities'][q] + ' vs. '+ ui_name;
        }
    }
};

var Store = { order_cleanup_cb: null };

Store.get_free_speedup_time = function(player) { return eval_cond_or_literal(player.get_any_abtest_value('free_speedup_time', gamedata['store']['free_speedup_time']), player, null); };

// note: "user_currency" here refers to the in-game currency (either FB Credits or gamebucks a.k.a. alloys/gold), NOT the real payment currency
Store.get_user_currency = function() { return player.get_any_abtest_value('currency', gamedata['currency']); };
Store.gamebucks_ui_name = function() { return player.get_any_abtest_value('gamebucks_ui_name', gamedata['store']['gamebucks_ui_name']); };

// get the tooltip to display under the user's in-game currency balance
Store.get_balance_tooltip = function() {
    var currency = (player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks' ? 'gamebucks' : 'facebook_credits');
    var curr_qty = player.resource_state[currency] < 0 ? 'Unknown' : pretty_print_number(player.resource_state[currency]);
    var fb_qty = player.resource_state['facebook_credits'] < 0 ? 'Unknown' : pretty_print_number(player.resource_state['facebook_credits']);

    var tip;
    if(SPay.api == 'kgcredits') {
        tip = gamedata['dialogs']['desktop_top']['widgets']['resource_bar_fbcredits']['ui_tooltip_kgcredits'];
    } else {
        tip = gamedata['dialogs']['desktop_top']['widgets']['resource_bar_fbcredits']['ui_tooltip_'+currency+(player.resource_state['facebook_credits'] < 0 ? '_badapi' : '')];
    }
    tip = tip.replace('%d', curr_qty);
    tip = tip.replace('%s', (currency == 'gamebucks' ? Store.gamebucks_ui_name() : 'FB Credits'));
    while(tip.indexOf('%gamebucks') != -1) {
        tip = tip.replace('%gamebucks', Store.gamebucks_ui_name());
    }
    tip = tip.replace('%fbcredits', fb_qty);
    return tip;
};

// get the function to call when user clicks on the "+" button next to the in-game currency balance
Store.get_balance_plus_cb = function() {
    var credits_button_cb;
    if(player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks') {
        credits_button_cb = function(w) {
            if(w.parent) { w.parent.onleave(); } // get rid of tooltips
            invoke_buy_gamebucks_dialog('desktop_add_alloy_button', -1, null);
        };
    } else {
        credits_button_cb = Store.buy_more_fbcredits;
    }
    return credits_button_cb;
};

// display an amount of in-game currency
// format = 'compact' for raw number, 'normal' for 'N Alloy'/'N', or 'full' for 'N Alloy'/'N Facebook Credits'
/** @param {number} price
    @param {string=} format */
Store.display_user_currency_amount = function(price, format) {
    if(Store.get_user_currency() == 'gamebucks') {
        var divisor = player.get_any_abtest_value('gamebucks_display_divisor', gamedata['store']['gamebucks_display_divisor']);
        if(!format) { format = 'normal'; }
        var key = 'gamebucks_display_ui_'+format;
        var template = player.get_any_abtest_value(key, gamedata['store'][key]);
        var num;
        if(divisor == 1) {
            num = pretty_print_number(price);
        } else {
            // NOTE: only handles divisor=10
            num = pretty_print_number(Math.floor(price/divisor));
            var frac = price % divisor;
            if(frac > 0) {
                num += '.' + frac.toString();
            }
        }
        return template.replace('%s', num);
    } else { // fbcredits
        var ret = pretty_print_number(price);
        if(format && format == 'full') {
            ret += " Facebook Credit";
            if(price != 1) { ret += "s"; }
        }
        return ret;
    }
};

// display an in-game currency price. Same as display_user_currency_amount except returns "-" for things that are free
/** @param {number} price
    @param {string=} format */
Store.display_user_currency_price = function(price, format) {
    if(price < 0) {
        return "-"; // unfulfilled requirements or other error
    } else if(price == 0) {
        return gamedata['strings']['store']['FREE'];
    }
    return Store.display_user_currency_amount(price, format);
};

// display a real-world currency amount (also handles Facebook Credit prices)
// display_currency = the currency in which to display the final amount
// price_currency = must be either fbcredits (for the old FB Credits API) or fbpayments:display_currency (for the new FB Payments API)
Store.display_real_currency_amount = function (display_currency, price, price_currency, abbreviate) {
    var curr_prefix, curr_suffix, curr_decimals;
    if(display_currency in gamedata['currencies']) {
        var template = gamedata['currencies'][display_currency];

        curr_prefix = template['prefix'] || '';
        curr_suffix = template['suffix'] || '';

        if(SPay.api == 'fbpayments' && player.facebook_currency && player.facebook_currency['user_currency'] != display_currency && !abbreviate) {
            // when showing prices in a currency that is not the player's own currency, be very explicit about what we are showing
            // because it might be e.g. an Australian user seeing a US Dollar price
            if(curr_prefix.indexOf(display_currency) === -1 && curr_suffix.indexOf(display_currency) === -1) {
                // only prepend the currency abbreviation if local prefix/suffix does not already include it (e.g. "DKK 1234" already includes it)
                curr_prefix = display_currency + ' ' + curr_prefix;
            }
        }
        curr_decimals = ('decimals' in template ? template['decimals'] : 2);
    } else {
        // fallback for unknown currencies
        curr_prefix = '';
        curr_suffix = (abbreviate ? '' : ' '+display_currency);
        curr_decimals = 2;
    }

    var display_price;
    if(price_currency == display_currency || (price_currency.indexOf('fbpayments:') == 0 && price_currency.split(':')[1] == display_currency) ||
       (price_currency == 'fbcredits' && display_currency == 'Facebook Credits') ||
       (price_currency == 'kgcredits' && display_currency == 'Kongregate Kreds')) {
        display_price = price;
    } else {
        if(price_currency != 'fbcredits') {
            throw Error('unhandled conversion: '+price_currency+' -> '+display_currency);
        }
        if(!player.facebook_currency || display_currency != player.facebook_currency['user_currency']) {
            throw Error('display_currency '+display_currency+' does not match Facebook-provided data of '+(player.facebook_currency ? player.facebook_currency['user_currency'] : 'NONE'));
        }
        // use the Facebook-provided user currency data for the conversion
        display_price = Math.round(price * player.facebook_currency['currency_exchange_inverse']*player.facebook_currency['currency_offset'])/player.facebook_currency['currency_offset'];
    }

    return curr_prefix + display_price.toFixed(curr_decimals) + curr_suffix;
};

// get the tooltip to display under an in-game currency price
Store.display_user_currency_price_tooltip = function(price) {
    if(!player.get_any_abtest_value('price_display_tooltip', gamedata['store']['price_display_tooltip'])) {
        return "";
    }
    if(price <= 0) {
        return ""; // unfulfilled requirements or other error, or free
    }
    return gamedata['strings']['store']['buy_for'].replace('%s', Store.display_user_currency_amount(price, 'full'));
};

// convert FB Credit price to another in-game currency - used only for tooltips on cost-capping auras
Store.convert_credit_price_to_currency = function(p, currency) {
    if(currency == 'fbcredits') {
        return p;
    } else if(currency == 'gamebucks') {
        return player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) * p;
    } else {
        throw Error('unknown currency');
    }
};
Store.convert_credit_price_to_user_currency = function(p) {
    return Store.convert_credit_price_to_currency(p, Store.get_user_currency());
};

// get price of a spell in user's in-game currency
Store.get_user_currency_price = function(unit_id, spell, spellarg) {
    return Store.get_price(Store.get_user_currency(), unit_id, spell, spellarg, false);
};

// main pricing entry point
// this MUST match Store.get_price in server.py, or else there will be trouble!!!
/** @param {string} sale_currency
    @param {GameObjectId} unit_id
    @param {Object} spell
    @param {?} spellarg
    @param {boolean=} ignore_error */
Store.get_price = function(sale_currency, unit_id, spell, spellarg, ignore_error) {
    var p_p_currency = Store.get_base_price(unit_id, spell, spellarg, ignore_error);
    var p = p_p_currency[0], p_currency = p_p_currency[1];

    if(p <= 0) { return p; }

    // only check for currency match when price > 0
    if(sale_currency.indexOf('item:') !== 0 && !(sale_currency in gamedata['resources'])) {
        var spell_currency = ('currency' in spell ? spell['currency'] : Store.get_user_currency());
        if(sale_currency != spell_currency) { return -1; }
    }

    // convert base price currency to what the buyer wants to pay with

    if(sale_currency === p_currency) {
        return p;
    } else if(sale_currency == 'fbcredits') {
        if(p_currency = 'gamebucks') {
            return Math.floor(p/player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']))+1;
        } else {
            return -1;
        }
    } else if(sale_currency == 'gamebucks') {
        if(p_currency == 'fbcredits') {
            return player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) * p;
        } else {
            return -1;
        }
    } else {
        throw Error('unknown currency conversion '+p_currency+' -> '+sale_currency);
    }
};

// return whether or not it is possible to cast this (server-side) spell
// the _detailed() version returns [can_cast, ui_reason, and a list of up to 3 args [x,y,z] that will be passed to get_requirements_help(x,y,z) to make a Valentina helper]
/** @param {GameObjectId} unit_id
    @param {string} spellname
    @param {*} spellarg */
function can_cast_spell_detailed(unit_id, spellname, spellarg) {
    var spell = gamedata['spells'][spellname];

    // note: undecided if we should factor in the GCD here. Leaving it
    // off for now, item frames will have to deal with GCD on their
    // own.
    var to_go = -1; // player.cooldown_togo('GCD');

    if('cooldown_name' in spell) {
        var cd_name = spell['cooldown_name'];
        to_go = Math.max(to_go, player.cooldown_togo(cd_name));
    }

    if(to_go > 0) {
        return [false, 'On Cooldown: '+pretty_print_time(to_go), null];
    }

    if(spellname == "GIVE_UNITS_LIMIT_BREAK") {
        // always OK
    } else if(spellname == "SHOW_STORE" || spellname == "CLIENT_CONSEQUENT") {
        // always OK
    } else if(spellname.indexOf("BUY_RANDOM_") == 0 || spellname.indexOf("FREE_RANDOM_") == 0) {
        // always OK (when not on cooldown)
    } else if(spellname.indexOf("CHANGE_REGION_INSTANTLY") == 0) {
        var pred = read_predicate(player.get_any_abtest_value('change_region_requirement', gamedata['territory']['change_region_requirement']));
        if(!pred.is_satisfied(player, null)) {
            return [false, pred.ui_describe(player,null), [pred,null]];
        }
    } else if(spellname == "ALLIANCE_GIFT_LOOT") {
        if(!session.is_in_alliance()) {
            return [false, gamedata['strings']['requirements_help']['alliance']['join']['ui_description'], null];
        }
    } else if(spellname == "FRIEND_GIFT_LOOT") {
        // always OK - the friend_gift_dialog GUI handles the case where you have no friends
        /*
        if(goog.array.filter(player.friends, function(fr) { return fr.is_real_friend; }).length < 1) {
            return [false, gamedata['strings']['requirements_help']['friends']['invite']['ui_description'], ['friends','invite',{short_circuit:1}]];
        }
        */
    } else if(spellname == "GIVE_UNITS") {
        // add up the space required for the new units
        var total = 0;
        for(var name in spellarg) {
            if(!(name in gamedata['units'])) { continue; }
            var spec = gamedata['units'][name];

            var data = spellarg[name];
            var qty = 1;
            if(typeof(data) === "number") {
                qty = data;
            } else if('qty' in data) {
                qty = data['qty'];
            }

            var level = player.tech[spec['level_determined_by_tech']] || 1;
            var space = get_leveled_quantity(spec['consumes_space'] || 0, level);
            total += qty*space;

            if(spec['limit']) {
                var counts = player.get_army_unit_count_by_specname();
                var cur_count = counts[spec['name']] || 0;
                if(cur_count + 1 > spec['limit']) {
                    return [false, gamedata['errors']['UNIT_COUNT_LIMIT']['ui_name'], ['unit_count', spec['name']]];
                }
            }
        }
        var space_usage = player.get_army_space_usage_by_squad();
        var available_space = player.stattab['total_space'] - space_usage['ALL'];
        if(!player.squads_enabled() || !gamedata['produce_to_reserves']) {
            available_space = Math.min(available_space, player.stattab['main_squad_space'] - space_usage[SQUAD_IDS.BASE_DEFENDERS.toString()]);
        }
        if(total > available_space) {
            var tooltip = gamedata['errors']['UNIT_SPACE_LIMIT']['ui_name'];
            if(player.squads_enabled()) {
                var reason = classify_unit_space_shortage();
                if(reason == 'base_defenders') {
                    tooltip = gamedata['strings']['requirements_help']['unit_space_base_defenders']['manage_base_defenders']['ui_description'];
                } else if(reason == 'total_army') {
                    tooltip = gamedata['strings']['requirements_help']['unit_space_total_army']['upgrade']['ui_description'];
                } else if(reason == 'recycle') {
                    tooltip = gamedata['strings']['requirements_help']['unit_space_total_army']['recycle']['ui_description'];
                }
            }
            return [false, tooltip, ['unit_space',null]];
        }
    } else if(spellname.indexOf("BOOST_") == 0 && (spell['resource'] in gamedata['resources'])) {
        var resource = spell['resource'];
        var amount;
        if('boost_amount' in spell) { // percentage boost
            if(spell['boost_amount'] < 1) {
                amount = Math.floor(spell['boost_amount'] * player.resource_state[resource][0]);
            } else { // 100% boost
                amount = player.resource_state[resource][0] - player.resource_state[resource][1]; // note: can go negative if overfull
            }
        } else if('give_amount' in spell) { // flat amount
            amount = spell['give_amount'];
        } else {
            throw Error('do not know how to process boost spell '+spellname);
        }

        if(amount <= 0 || ((player.resource_state[resource][1] + amount) > player.resource_state[resource][0])) {
            return [false, gamedata['errors']['STORAGE_LIMIT']['ui_name'],
                    [resource, Math.max(1, ((player.resource_state[resource][1] + amount) - player.resource_state[resource][0])) ]];
        }
    } else if(spellname == "BUILD_INSTANTLY_FOR_FREE") {
        // this mirrors do_build in the server
        // checks everything EXCEPT resource levels
        if(!session.home_base) { return [false, gamedata['errors']["CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"]['ui_name'], null]; }
        var building_type = spellarg[0], j_i = spellarg[1];
        var spec = gamedata['buildings'][building_type];
        if(spec['developer_only'] && (spin_secure_mode || !player.is_developer())) { return [false, gamedata['errors']['DISALLOWED_IN_SECURE_MODE']['ui_name'], null]; }
        if(j_i && !player.is_building_location_valid(j_i, spec, null, {ignore_perimeter: !!spec['ignore_perimeter']})) {
            return [false, gamedata['errors']['INVALID_BUILDING_LOCATION']['ui_name'], ['invalid_building_location','any']];
        }
        if(spec['requires']) {
            var pred = read_predicate(get_leveled_quantity(spec['requires'],1));
            if(!pred.is_satisfied(player,null)) {
                return [false, gamedata['strings']['unmet_requirements'].replace('%s',pred.ui_describe(player)), [pred,null]];
            }
        }
        if(0 && spec['consumes_power'] &&
           (session.viewing_base.power_state[1] + get_leveled_quantity(spec['consumes_power'],1)) > session.viewing_base.power_state[0]) {
            return [false, gamedata['errors']['POWER_LIMIT']['ui_name'], ['power',null]];
        }
        if(spec['limit']) {
            var current = 0;
            for(var id in session.cur_objects.objects) {
                var obj = session.cur_objects.objects[id];
                if(obj.team === 'player' && obj.spec['name'] === spec['name']) { current += 1 }
            }
            var limit = get_leveled_quantity(spec['limit'], player.get_townhall_level());
            if(limit >= 0 && current >= limit && !player.is_cheater) {
                // can we build more at a higher CC level?
                var max_limit = ((typeof spec['limit']) === 'number' ? spec['limit'] : goog.array.reduce(spec['limit'], function(accum, cur) { accum = Math.max(accum,cur);}, 0));
                var helper_args = (max_limit > limit ? ['cc_limit',spec] : null);
                return [false, gamedata['errors']['BUILDING_LIMIT_EXCEEDED']['ui_name'], helper_args];
            }
        }
        return [true,null,null];
    } else if(spellname == "UPGRADE_UNIQUE_INSTANTLY_FOR_FREE") {
        if(!session.home_base) { return [false, gamedata['errors']["CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"]['ui_name'], null]; }
        var building_type = spellarg;
        var spec = gamedata['buildings'][building_type];
        var obj = find_object_by_type(building_type);
        if(!obj || !obj.is_building() || obj.team !== 'player') {
            return [false, gamedata['errors']['BUILDING_NOT_FOUND']['ui_name'], null];
        }
        if(obj.is_damaged() || obj.is_repairing()) {
            return [false, gamedata['errors']['CANNOT_UPGRADE_BUILDING_WHILE_DAMAGED']['ui_name'], null];
        }
        if(obj.is_busy() && !obj.is_upgrading()) {
            return [false, gamedata['errors']['CANNOT_UPGRADE_BUILDING_WHILE_BUSY']['ui_name'], null];
        }
        if(obj.level >= obj.get_max_level()) {
            return [false, gamedata['errors']['MAX_LEVEL_REACHED']['ui_name'], null];
        }

        return [true,null,null];
    } else if(spellname == "APPLY_AURA") {
        var target = spellarg[0], aura_name = spellarg[1], aura_strength = spellarg[2], aura_duration = spellarg[3];
        if(player.player_auras.length >= gamedata['player_aura_limit']) {
            // see if this will stack an existing aura
            var found = false;
            for(var i = 0; i < player.player_auras.length; i++) {
                if(player.player_auras[i]['spec'] === aura_name) {
                    found = true;
                    break;
                }
            }
            if(!found) {
                return [false, gamedata['errors']['PLAYER_AURA_LIMIT']['ui_name'], ['player_aura_limit', null]];
            }
        }
        return [true, null, null];
    } else if(spellname.indexOf("BUY_PROTECTION") == 0) {
        // always OK
    } else if(spellname.indexOf("UPGRADE_BARRIERS") == 0) {
        var min_level = 99;
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.spec['name'] === 'barrier') {
                min_level = Math.min(min_level, obj.level);
            }
        }
        var formula = spell['price_formula'];
        var up_level = parseInt(formula[formula.length-1],10);
        if(min_level >= up_level) {
            return [false, null, null];
        } else {
            return [true, null, null];
        }
    } else if(spellname.indexOf("GROW_BASE_PERIMETER") == 0) {
        var formula = spell['price_formula'];
        var to_level = parseInt(formula[formula.length-1],10);
        if(session.viewing_base.base_size >= to_level) {
            return [false, null, null];
        }
        return [true, null, null];
    } else if(('code' in spell) && (spell['code'] == 'projectile_attack')) {
        if(session.has_deployed) {
            if(session.viewing_base.base_climate_data['exclude_missiles']) {
                return [false, gamedata['errors']['CANNOT_USE_ITEM_UNDERGROUND']['ui_name'], null];
            } else {
                return [true, null, null];
            }
        } else {
            return [false, gamedata['errors']['CANNOT_USE_ITEM_OUTSIDE_OF_COMBAT']['ui_name'], null];
        }
    } else if(('code' in spell) && (spell['code'] == 'instant_repair' || spell['code'] == 'instant_combat_repair')) {
        var found = false;
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.team === 'player' && obj.is_damaged()) {
                found = true;
                break;
            }
        }
        if(!found && session.deployed_unit_space == 0) {
            return [false, gamedata['errors']['NOTHING_TO_REPAIR']['ui_name'], null];
        }

        if(spell['code'] == 'instant_combat_repair') {
            if(session.home_base || !session.has_deployed) {
                return [false, gamedata['errors']['CANNOT_USE_ITEM_OUTSIDE_OF_COMBAT']['ui_name'], null];
            }
        } else {
            if(!session.home_base && !session.has_deployed) {
                return [false, gamedata['errors']['CANNOT_USE_ITEM_OUTSIDE_OF_COMBAT']['ui_name'], null];
            }
        }

        return [true, null, null];
    } else if(spellname == "CRAFT_FOR_FREE") {
        var builder = session.cur_objects.objects[unit_id];
        var recipe_name = spellarg[0]['recipe'];
        var recipe_spec = gamedata['crafting']['recipes'][recipe_name];
        var ret = null;
        if(!player.is_cheater) {
            // check predicate requirements
            goog.array.forEach(['show_if','requires'], function(predname) {
                if(ret) { return; } // already found a reason we cannot proceed
                if(predname in recipe_spec) {
                    var pred = read_predicate(recipe_spec[predname]);
                    if(!pred.is_satisfied(player, null)) {
                        ret = [false, gamedata['errors']['REQUIREMENTS_NOT_SATISFIED']['ui_name'], [pred]];
                    }
                }
            });
            if(ret) { return ret; }

            // check resource requirements
            var resources_needed = {};
            for(var res in gamedata['resources']) {
                var cost = recipe_spec['cost'][res]||0;
                if(player.resource_state[res][1] < cost) {
                    resources_needed[res] = cost;
                }
            }
            if(goog.object.getCount(resources_needed) > 0) {
                return [false, gamedata['errors']['INSUFFICIENT_RESOURCES']['ui_name'], ['resources', resources_needed]];
            }

            // check ingredient requirements
            if('ingredients' in recipe_spec) {
                // have to pre-sum by specname in case there are multiple entries in the array with the same specname
                var by_specname = {};
                goog.array.forEach(recipe_spec['ingredients'], function(ingr) {
                    var stack = ('stack' in ingr ? ingr['stack'] : 1);
                    by_specname[ingr['spec']] = (by_specname[ingr['spec']] || 0) + stack;
                });
                var missing_items = {};
                goog.object.forEach(by_specname, function(qty, specname) {
                    if(player.inventory_item_quantity(specname) < qty) {
                        missing_items[specname] = qty - player.inventory_item_quantity(specname);
                    }
                });
                if(goog.object.getCount(missing_items) > 0) {
                    return [false, gamedata['errors']['CRAFT_INGREDIENT_MISSING']['ui_name'], ['crafting_ingredients', missing_items]];
                }
            }
        }

        var cat_spec = gamedata['crafting']['categories'][recipe_spec['crafting_category']];
        var queueable = !('queueable' in cat_spec && !cat_spec['queueable']);
        if((!queueable && builder.is_crafting()) ||
           (builder.is_repairing() || builder.is_upgrading() || builder.is_under_construction())) {
            return [false, gamedata['errors']['WORKSHOP_IS_BUSY']['ui_name'], ['speedup', builder]];
        } else if(builder.is_damaged()) {
            return [false, gamedata['errors']['WORKSHOP_IS_BUSY']['ui_name'], ['repair', builder]];
        }

        // OK!
    } else {
        throw Error('unhandled spell '+spellname);
    }
    return [true,null,null];
}

/** @param {GameObjectId} unit_id
    @param {string} spellname
    @param {*} spellarg */
function can_cast_spell(unit_id, spellname, spellarg) {
    var ret = can_cast_spell_detailed(unit_id, spellname, spellarg);
    return ret[0];
}

function sku_match(skudata, player, specname, stack, melt_time, melt_duration, tm, ignore_error) {
    if(!('item' in skudata) || skudata['item'] !== specname) { return false; }
    if(!('price' in skudata)) { return false; }
    if(melt_time > 0 && tm >= melt_time) { return false; }
    if(('start_time' in skudata) && (tm < skudata['start_time'])) { return false; }
    if(('expire_time' in skudata) && (tm >= skudata['expire_time'])) { return false; }
    var skustack = ('stack' in skudata ? skudata['stack'] : 1);
    if(skustack !== stack) { return false; }
    var skumelt = ('melt_time' in skudata ? skudata['melt_time'] : -1);
    if(skumelt !== melt_time) { return false; }
    var skudur = ('melt_duration' in skudata ? skudata['melt_duration'] : -1);
    if(skudur !== melt_duration) { return false; }
    if(('show_if' in skudata) && !read_predicate(skudata['show_if']).is_satisfied(player, null)) { return false; }
    if(!ignore_error && ('requires' in skudata) && !read_predicate(skudata['requires']).is_satisfied(player, null)) { return false; }
    return true;
}

// look through the store catalog for the SKU representing this BUY_ITEM spellarg
Store.buy_item_find_skudata = function(spellarg, player, ignore_error) {
    var catpath = spellarg['catpath'];
    var specname = spellarg['skudata']['item'];
    if(!catpath || !specname) { return null; }
    var stack = ('stack' in spellarg['skudata'] ? spellarg['skudata']['stack'] : 1);
    var melt_time = ('melt_time' in spellarg['skudata'] ? spellarg['skudata']['melt_time'] : -1);
    var melt_dur = ('melt_duration' in spellarg['skudata'] ? spellarg['skudata']['melt_duration'] : -1);
    var tm = player.get_absolute_time();

    // drill down into the category containing this SKU
    var cat = null;
    var catlist = gamedata['store']['catalog'];
    for(var i = 0; i < catpath.length; i++) {
        cat = goog.array.find(catlist, function (entry) {
            return (entry['name'] && entry['name'] === catpath[i] &&
                    (!('activation' in entry) || read_predicate(entry['activation']).is_satisfied(player,null)) &&
                    (!('start_time' in entry) || entry['start_time'] < tm) &&
                    (!('expire_time' in entry) || entry['expire_time'] >= tm));
        });
        if(!cat) { return null; }
        catlist = cat['skus'] || [];
    }
    if(!cat) { return null; }

    var ret = null, pr = -1;
    goog.array.forEach(cat['skus'], function(skudata) {
        if(sku_match(skudata, player, specname, stack, melt_time, melt_dur, tm, ignore_error)) {
            if(pr < 0 || skudata['price'] < pr) {
                // use lowest price, in case there are multiple matches
                ret = skudata;
                pr = skudata['price'];
            }
        }
    });

    // also look in extra_store_specials
    if(catpath[0] === 'specials') {
        for(var test_name in player.abtests) {
            var group = player.abtests[test_name];
            if(test_name in gamedata['abtests'] && gamedata['abtests'][test_name]['active'] && (group in gamedata['abtests'][test_name]['groups'])) {
                var data = gamedata['abtests'][test_name]['groups'][group];
                if('extra_store_specials' in data) {
                    var extras = data['extra_store_specials'];
                    for(var i = 0; i < extras.length; i++) {
                        var skudata = extras[i];
                        if(sku_match(skudata, player, specname, stack, melt_time, melt_dur, tm, ignore_error)) {
                            if(pr < 0 || skudata['price'] < pr) {
                                // use lowest price, in case there are multiple matches
                                ret = skudata;
                                pr = skudata['price'];
                            }
                        }
                    }
                }
            }
        }
    }

    return ret;
};

// for historical reasons, the core time/cost computation is done in units of fbcredits
Store.get_speedup_price_fbcredits = function(player, kind, seconds) {
    var mins_per_credit = player.get_any_abtest_value('speedup_minutes_per_credit', gamedata['store']['speedup_minutes_per_credit']);
    if(typeof mins_per_credit == 'object') { // dictionary of per-kind values
        mins_per_credit = (kind in mins_per_credit ? mins_per_credit[kind] : mins_per_credit['default']);
    }
    return (seconds/60.0)/mins_per_credit;
};
Store.get_speedup_price = function(player, kind, seconds, currency) {
    var quantize = true;
    var fbcredits_price = Store.get_speedup_price_fbcredits(player, kind, seconds);
    var ret;
    if(currency == 'gamebucks') {
        ret = player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) * fbcredits_price;
    } else if(currency == 'fbcredits') {
        ret = fbcredits_price;
    } else {
        throw Error('unhandled currency '+currency);
    }
    if(quantize) { // snap to next-highest integer price
            return Math.floor(ret) + 1;
    }
    return ret;
};

// main pricing function - MUST match Store.get_base_price in server.py!
Store.get_base_price = function(unit_id, spell, spellarg, ignore_error) {
    var p_currency = 'fbcredits';

    if('requires' in spell && !ignore_error) {
        if(!read_predicate(spell['requires']).is_satisfied(player, null)) { return [-1, p_currency]; }
    }

    if('cooldown_name' in spell && !ignore_error) {
        if(player.cooldown_active(spell['cooldown_name'])) {
            return [-1, p_currency];
        }
    }

    var formula = spell['price_formula'];
    if(formula === 'constant') {
        if('currency' in spell) { p_currency = spell['currency']; }
        return [spell['price'], p_currency];
    } else if(formula === 'item') {
        // find this SKU
        var skudata = Store.buy_item_find_skudata(spellarg, player, ignore_error);
        if(!skudata || !('price' in skudata)) { return [-1, p_currency]; }

        var stack = ('stack' in skudata ? skudata['stack'] : 1);
        var spec = gamedata['items'][skudata['item']];
        if(!spec) {
            return [-1, p_currency];
        }
        if(('store_requires' in spec) && !ignore_error && !read_predicate(spec['store_requires']).is_satisfied(player, null)) {
            return [-1, p_currency];
        }
        if('price_currency' in skudata) { p_currency = skudata['price_currency']; }
        return [skudata['price'], p_currency];

    } else if(formula === 'gamebucks_topup') {
        var bucks_per_credit = player.get_any_abtest_value('gamebucks_per_fbcredit_topup', gamedata['store']['gamebucks_per_fbcredit_topup']);
        if(bucks_per_credit < 0) { return [-1, p_currency]; }
        return [Math.max(1, Math.ceil(spellarg / (1.0*bucks_per_credit))), p_currency];
    } else if(formula.indexOf('barrier_upgrade') === 0) {
        var min_level = 99;
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.spec['name'] === 'barrier') {
                min_level = Math.min(min_level, obj.level);
            }
        }
        var up_level = parseInt(formula[formula.length-1],10);
        if(min_level >= up_level && !ignore_error) {
            return [-1, p_currency];
        } else {
            return [spell['price'], p_currency];
        }
    } else if(formula.indexOf('grow_base_perimeter') === 0) {
        var to_level = parseInt(formula[formula.length-1],10);
        if(session.viewing_base.base_size >= to_level && !ignore_error) {
            return [-1, p_currency];
        }
        return [spell['price'], p_currency];
    } else if(formula === 'speedup' || formula === 'speedup_gamebucks') {
        var unit = session.cur_objects.objects[unit_id];

        if(unit.is_damaged() && !unit.is_repairing()) { return [-1, p_currency]; }

        var time_to_finish = unit.time_until_finish();

        var allow_free_speedup = true;
        var always_free_speedup = false;

        if(!unit.is_repairing() && !unit.is_upgrading() && !unit.is_under_construction()) {
            if(unit.is_manufacturing()) {
                if(!player.unit_speedups_enabled()) {
                    return [-1, p_currency];
                }

                always_free_speedup = true;
                goog.array.forEach(unit.manuf_queue, function(item) {
                    var item_spec = gamedata['units'][item['spec_name']];
                    if('always_free_speedup' in item_spec && (get_leveled_quantity(item_spec['always_free_speedup'], item['level']))) {
                        return;
                    } else {
                        always_free_speedup = false;
                    }

                    if('no_free_speedup' in item_spec && (get_leveled_quantity(item_spec['no_free_speedup'], item['level']))) {
                        allow_free_speedup = false;
                    }
                });
            }
            if(unit.is_crafting()) {
                if(!player.crafting_speedups_enabled()) {
                    return [-1, p_currency];
                } else {
                    var queue = unit.get_crafting_queue();
                    if(goog.array.find(queue, function(bus) {
                        var cat = gamedata['crafting']['categories'][gamedata['crafting']['recipes'][bus['craft']['recipe']]['crafting_category']];
                        if(('speedupable' in cat) && !cat['speedupable']) {
                            return true;
                        }
                        return false;
                        })) {
                        return [-1, p_currency]; // no speedups
                    }
                }
            }
        }

        if(always_free_speedup || (allow_free_speedup && time_to_finish <= Store.get_free_speedup_time(player))) {
            return [0, p_currency];
        } else {
            if(allow_free_speedup && !player.get_any_abtest_value('count_free_speedup_time', gamedata['store']['count_free_speedup_time'])) {
                time_to_finish -= Store.get_free_speedup_time(player);
            }
            if(time_to_finish < 0) { time_to_finish = 0; }

            // apply upgrade_speedup_cost_factor
            if(unit.is_building() && !unit.is_repairing() && unit.is_upgrading()) {
                var factor = get_leveled_quantity(unit.spec['upgrade_speedup_cost_factor'] || 1, unit.level+1);
                time_to_finish *= factor;
            }


            if(formula === 'speedup_gamebucks') {
                p_currency = 'gamebucks';
            }
            var price = Store.get_speedup_price(player, unit.activity_speedup_kind(), time_to_finish, p_currency);

            return [price, p_currency];
        }
    } else if(formula === 'unit_repair_speedup' || formula === 'unit_repair_speedup_gamebucks') {
        if(!player.unit_speedups_enabled()) {
            return [-1, p_currency];
        }

        if(player.unit_repair_queue.length < 1) { return [-1, p_currency]; }

        var time_to_finish = player.unit_repair_queue[player.unit_repair_queue.length-1]['finish_time'] - server_time;
        if(!player.get_any_abtest_value('count_free_speedup_time', gamedata['store']['count_free_speedup_time'])) {
            time_to_finish -= Store.get_free_speedup_time(player);
        }
        // NOTE! unit repair speedups do not have the "5 minute instant" option!
        if(time_to_finish <= 0) {
            time_to_finish = 0;
        }

        if(formula === 'unit_repair_speedup_gamebucks') {
            p_currency = 'gamebucks';
        }
        var price = Store.get_speedup_price(player, 'unit_repair', time_to_finish, p_currency);

        return [price, p_currency];
    } else if(formula === 'repair_all' || formula === 'repair_all_gamebucks') {
        // similar to a speedup, but charge for the SUM repair price of all damaged buildings
        var sum_price = 0;
        var sum_time = 0;
        if(formula === 'repair_all_gamebucks') { p_currency = 'gamebucks'; }

        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            if(obj.is_building() && obj.is_damaged()) {
                var repair_time;
                if(obj.is_repairing()) {
                    repair_time = obj.repair_finish_time - server_time;
                } else {
                    var health = (1.0*obj.hp) / obj.max_hp;
                    repair_time = Math.floor((1-health) * obj.get_leveled_quantity(obj.spec['repair_time']));
                }
                if(repair_time < 0) { repair_time = 0; }
                sum_time += repair_time;
                var time_to_finish = repair_time - Store.get_free_speedup_time(player);
                if(time_to_finish <= 0) {
                } else {
                    sum_price += Store.get_speedup_price(player, 'building_repair', time_to_finish, p_currency);
                }
            }
        }

        if(player.get_any_abtest_value('building_repair_sum_times', gamedata['store']['building_repair_sum_times'])) {
            var time_to_finish = sum_time;
            if(time_to_finish <= Store.get_free_speedup_time(player)) {
                sum_price = 0;
            } else {
                sum_price = Store.get_speedup_price(player, 'building_repair', time_to_finish, p_currency);
            }
        }

        if(session.viewing_base.base_type != 'home') {
            // no free repairs away from home base - this is mainly
            // because the server doesn't implement it due to locking
            // complexity, not for design reasons
            if(sum_time > 0) { sum_price = Math.max(sum_price, 1); }
        }

        var do_units = session.home_base;

        if(!player.unit_speedups_enabled()) {
            do_units = false;
        }

        if(do_units) {
            // note: ignore repair queue, but sum unit times before applying formula
            var total_rep_time = 0;

            if(player.squads_enabled()) {
                goog.object.forEach(player.my_army, function(obj) {
                    var squad_id = obj['squad_id'] || 0;

                    // ignore army units not at home base
                    if(player.squad_is_deployed(squad_id)) { return; }

                    var spec = gamedata['units'][obj['spec']];
                    var level = obj['level'] || 1;
                    var curmax = army_unit_hp(obj);
                    if(curmax[0] < curmax[1]) {
                        if(/*(army_unit_repair_state(obj) == 0) && */ player.can_repair_unit_of_spec(spec, curmax[0])) {
                            var rep = mobile_cost_to_repair(spec, level, curmax[0], curmax[1], player);
                            total_rep_time += rep['time'];
                        }
                    }
                });

            } else { // OLD non-squads method
            for(var id in session.cur_objects.objects) {
                var obj = session.cur_objects.objects[id];
                if(obj.is_mobile() && obj.is_damaged() && player.can_repair_unit(obj)) {
                    var rep = obj.cost_to_repair(player);
                    total_rep_time += rep['time'];
                }
            }
            }

            if(total_rep_time > 0) {
                var time_to_finish = total_rep_time;
                if(!player.get_any_abtest_value('count_free_speedup_time', gamedata['store']['count_free_speedup_time'])) {
                    time_to_finish -= Store.get_free_speedup_time(player);
                }
                if(time_to_finish <= 0) {
                    time_to_finish = 0;
                }
                var unit_price = Store.get_speedup_price(player, 'unit_repair', time_to_finish, p_currency);
                sum_price += unit_price;
            }
        }
        return [sum_price, p_currency];

    } else if(formula === 'upgrade' || formula === 'research' || formula === 'craft_gamebucks') {
        var unit = null;
        if(unit_id == 0 && player.is_cheater && formula === 'research') {

        } else {
            unit = session.cur_objects.objects[unit_id];
            if(!unit.is_building() || unit.is_damaged() ||
               (unit.is_busy() && !((formula==='research') && unit.is_researching()))) {
                return [-1, p_currency];
            }
        }

        var price;

        if(formula === 'upgrade') {
            if(0 && player.foreman_is_busy()) {
                // still allow instant upgrades while foreman is busy?
                return [-1, p_currency];
            }
            if(unit.level >= unit.get_max_ui_level()) {
                return [-1, p_currency];
            }
            if(('requires' in unit.spec) && !player.is_cheater) {
                var pred = read_predicate(get_leveled_quantity(unit.spec['requires'], unit.level+1));
                if(!pred.is_satisfied(player, null)) {
                    return [-1, p_currency];
                }
            }

            if(!player.is_cheater) {
                for(var res in gamedata['resources']) {
                    var resdata = gamedata['resources'][res];
                    if(('allow_instant' in resdata) && !resdata['allow_instant']) {
                        if(get_leveled_quantity(unit.spec['build_cost_'+res] || 0, unit.level+1) > 0) {
                            return [-1, p_currency]; // requires rare resource
                        }
                    }
                }
            }

            price = get_leveled_quantity(unit.spec['upgrade_credit_cost']||-1, unit.level+1);
            var factor = player.get_any_abtest_value('building_muffin_factor', gamedata['store']['building_muffin_factor']);
            if(factor != 1) {
                price = Math.round(factor*price);
            }
        } else if(formula === 'craft_gamebucks') {
            p_currency = 'gamebucks';
            var delivery = spellarg['delivery'] || null;
            var recipe = gamedata['crafting']['recipes'][spellarg['recipe']];
            var recipe_level = spellarg['level'] || 1;
            var category = gamedata['crafting']['categories'][recipe['crafting_category']];

            /* allow instant upgrades even if foreman is busy
            if(category['foreman'] && player.foreman_is_busy()) {
                return [-1, p_currency];
            }
            */

            if(!player.is_cheater) {
                for(var res in gamedata['resources']) {
                    var resdata = gamedata['resources'][res];
                    if(('allow_instant' in resdata) && !resdata['allow_instant']) {
                        if(get_leveled_quantity(recipe['cost'][res] || 0, recipe_level) > 0) {
                            return [-1, p_currency]; // requires rare resource
                        }
                    }
                }
                var pred_fail = false;
                goog.array.forEach(['show_if','requires','activation'], function(predname) {
                    if(predname in recipe && !read_predicate(recipe[predname]).is_satisfied(player, null)) { pred_fail = true; };
                });
                if(pred_fail) { return [-1, p_currency]; }

                var limited_or_unique_equipped_fail = false;
                if(!ignore_error && delivery && delivery['obj_id']) {
                    goog.array.forEach(recipe['product'], function(my_product) {
                        var delivery_address = new BuildingEquipSlotAddress(delivery['obj_id'], delivery['slot_type'], delivery['slot_index']);
                        if(my_product['spec']) {
                            if(player.would_violate_limited_equipped(ItemDisplay.get_inventory_item_spec(my_product['spec']), delivery_address) ||
                               player.would_violate_unique_equipped(ItemDisplay.get_inventory_item_spec(my_product['spec']), delivery_address)) {
                                limited_or_unique_equipped_fail = true;
                            }
                        }
                    });
                }
                if(limited_or_unique_equipped_fail) { return [-1, p_currency]; }
            }
            // check existing queue
            // we don't bother with the more detailed checks the server does, since only a client bug would cause mal-formed requests here
            var craft_queue = unit.get_crafting_queue();
            if('queueable' in category && !category['queueable']) {
                if(craft_queue.length > 0) { return [-1, p_currency]; } // note: doesn't handle uncollected finished jobs
            }

            // check destination slot
            if(delivery && delivery['obj_id'] && !delivery['replace']) {
                var other = session.cur_objects.objects[delivery['obj_id']];
                if(other.equipment && delivery['slot_type'] in other.equipment && other.equipment[delivery['slot_type']][delivery['slot_index']||0]) {
                    return [-1, p_currency];
                }
            }

            price = get_leveled_quantity(recipe['craft_gamebucks_cost']||-1, recipe_level);

        } else {
            // tech research
            var spec = gamedata['tech'][spellarg];
            var new_level;
            if(spellarg in player.tech) {
                new_level = player.tech[spellarg] + 1;
            } else {
                new_level = 1;
            }
            if(new_level > get_max_ui_level(spec)) {
                return [-1, p_currency];
            }
            if(spec['developer_only'] && (spin_secure_mode || !player.is_developer())) {
                return [-1, p_currency];
            }
            if(!unit && !player.is_cheater) {
                return [-1, p_currency];
            }
            if(unit) {
                if(!unit.is_researcher()) {
                    return [-1, p_currency];
                }
                var found = false;
                var categories = unit.spec['research_categories'] || [];
                for(var i = 0; i < categories.length; i++) {
                    if(spec['research_category'] === categories[i]) {
                        found = true;
                        break;
                    }
                }
                if(!found) {
                    return [-1, p_currency];
                }
            }
            if(('requires' in spec) && !player.is_cheater) {
                var pred = read_predicate(get_leveled_quantity(spec['requires'], new_level));
                if(!pred.is_satisfied(player, null)) {
                    return [-1, p_currency];
                }
            }
            if(('activation' in spec) && !player.is_cheater) {
                if(!read_predicate(spec['activation']).is_satisfied(player, null)) {
                    return [-1, p_currency];
                }
            }

            if(!player.is_cheater) {
                for(var res in gamedata['resources']) {
                    var resdata = gamedata['resources'][res];
                    if(('allow_instant' in resdata) && !resdata['allow_instant']) {
                        if(get_leveled_quantity(spec['cost_'+res] || 0, new_level) > 0) {
                            return [-1, p_currency]; // requires rare resource
                        }
                    }
                }
            }

            price = get_leveled_quantity(spec['research_credit_cost'], new_level);
            var factor = player.get_any_abtest_value('tech_muffin_factor', gamedata['store']['tech_muffin_factor']);
            if(factor != 1) {
                price = Math.round(factor*price);
            }
        }

        return [price, p_currency];

    } else if(formula === 'resource_boost' || formula === 'resource_boost_gamebucks') {
        if(formula === 'resource_boost_gamebucks') { p_currency = 'gamebucks'; }

        var resource = spell['resource'];
        var amount;
        if(spell['boost_amount'] < 1) {
            amount = Math.floor(spell['boost_amount'] * player.resource_state[resource][0]);
            // only allow purchase of sub-100% boosts if there is storage room
            if((player.resource_state[resource][1] + amount) > player.resource_state[resource][0] && !ignore_error) {
                return [-1, p_currency];
            }
        } else {
            // 100% boost
            if(player.resource_state[resource][1] >= player.resource_state[resource][0]) {
                if(!ignore_error) {
                    // completely full
                    return [-1, p_currency];
                } else {
                    // for the ignore_error case, we'll return zero price, but the caller needs to be careful not to display this as "free"
                    amount = 0;
                }
            } else {
                amount = player.resource_state[resource][0] - player.resource_state[resource][1];
            }
        }

        return [Store.get_resource_price(resource, amount, p_currency), p_currency];
    } else if(formula === 'resource_topup') {
        p_currency = 'gamebucks'; // only option for this
        var price = 0;
        for(var res in spellarg) {
            if(!gamedata['resources'][res]['allow_topup']) {
                return [-1, p_currency]; // not allowed
            }
            if(player.resource_state[res][1] + spellarg[res] > player.resource_state[res][0]) {
                return [-1, p_currency]; // not enough room in storage
            }
            price += Store.get_resource_price(res, spellarg[res], p_currency);
        }
        return [price, p_currency];
    } else {
        throw Error('Unknown price formula '+formula);
    }
};

/** Returns a parameter from store.json that might be overridden by an A/B test, and/or a per-resource dictionary
    @param {string} name
    @param {string} resname
    @returns {?} */
Store.get_resource_parameter = function(name, resname) {
    var ret = player.get_any_abtest_value(name, gamedata['store'][name]);
    if(typeof ret === 'object' && !(0 in ret)) { // detect dictionaries
        ret = ret[resname];
    }
    return ret;
};

/** Returns the price of an arbitrary amount of fungible resources
    @param {number} amount
    @param {string} currency
    @returns {number} */
Store.get_resource_price = function(resname, amount, currency) {
    if(amount <= 0) { return 0; }

    var price_formulas = {
        'legacy_exp_log': function(_resname, _amount, _currency) {
            var scale_factor = Store.get_resource_parameter('resource_price_formula_scale', _resname);
            var coeff = (_currency === 'gamebucks' ? player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) : 1);
            var price = scale_factor * coeff * 0.06 * Math.exp(0.75 * (log10(_amount) - 2.2 * Math.pow(log10(_amount), -1.25)));
            return (_amount > 2) ? price : 1;
        },
        'piecewise_linear': function(_resname, _amount, _currency) {
            var price_points = Store.get_resource_parameter('resource_price_formula_piecewise_linear_points', _resname);

            for(var i = 1; i < price_points.length; i++) {
                if(_amount < price_points[i][0] || i == price_points.length - 1) {
                    var scale_factor = Store.get_resource_parameter('resource_price_formula_scale', _resname);
                    // scale down for fbcredits since this formula is designed for gamebucks
                    var coeff = (_currency !== 'gamebucks' ? 1 / player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) : 1);
                    var slope = (price_points[i][1] - price_points[i - 1][1]) / (price_points[i][0] - price_points[i - 1][0]);
                    return scale_factor * coeff * price_points[i - 1][1] + slope * (_amount - price_points[i - 1][0]);
                }
            }

            throw Error("Unhandled case while calculating piecewise_linear prices. This should never happen.");
        }
    };
    var price_formula_name = Store.get_resource_parameter('resource_price_formula', resname);
    return Math.ceil(price_formulas[price_formula_name](resname, amount, currency));
}

Store.fbcredits_to_dollars = function(amt) { return 0.07 * amt; };
Store.kgcredits_to_dollars = function(amt) { return 0.07 * amt; };

// To work around browsers dropping the order completion callback due
// to cross-site scripting errors, manually fire several events to update
// the GUI on the first UI event to happen after the dialog goes up.
// THEORETICALLY, if the Facebook API works correctly and calls the callback
// we supply, this should not be necessary.

Store.force_order_cleanup = function() {
    if(Store.order_cleanup_cb) {
        var cb = Store.order_cleanup_cb;
        console.log('PERFORMING POST-ORDER CLEANUP');
        Store.order_cleanup_cb = null;
        for(var id in session.cur_objects.objects) {
            var obj = session.cur_objects.objects[id];
            send_to_server.func(["PING_OBJECT", obj.id, "post_order_cleanup"]);
        }
        send_to_server.func(["UNIT_REPAIR_TICK"]);
        send_to_server.func(["PING_CREDITS"]);
        send_to_server.func(["PING_TECH"]);
        send_to_server.func(["PING_PLAYER"]);
        metric_event('4067_order_prompt_callback_dropped', add_demographics({}));
        cb();
    }
};

// NOTE: cb is a UI cleanup callback that will be called ONLY for gamebucks purchases, not for FB credits purchases!
// FB credits purchases always have to kill the entire UI because the FB script callback is unreliable

/** @param {GameObjectId} unit_id
    @param {string} spellname
    @param {?} spellarg
    @param {function(boolean)|null=} cb (called with true for success or false for failure)
    @param {Object|null=} props */
Store.place_user_currency_order = function(unit_id, spellname, spellarg, cb, props) {
    return Store.place_order(Store.get_user_currency(), unit_id, spellname, spellarg, cb, props);
};

/** @param {string} currency
    @param {GameObjectId} unit_id
    @param {string} spellname
    @param {?} spellarg
    @param {function(boolean)|null=} cb (called with true for success or false for failure)
    @param {Object|null=} props */
Store.place_order = function(currency, unit_id, spellname, spellarg, cb, props) {
    var no_clear = props && props['no_clear'];

    var price = Store.get_price(currency, unit_id, gamedata['spells'][spellname], spellarg, false);

    if(price < 0 || (price == 0 && (currency == 'fbcredits' || currency.indexOf('fbpayments:') === 0))) {
        change_selection(null);
        var msg = 'Error: invalid order, probably due to time delay, please try again.';
        user_log.msg(msg, new SPUI.Color(1,0,0,1));
        return false;
    }

    if(currency == 'fbcredits') {
        if(!no_clear) { change_selection(null); }
        Store.place_fbcredits_order(price, unit_id, spellname, spellarg, cb);
        return false;
    } else if(currency == 'kgcredits') {
        if(!no_clear) { change_selection(null); }
        Store.place_kgcredits_order(price, unit_id, spellname, spellarg, cb, (props ? (props['fail_cb'] || null) : null));
        return false;
    } else if(currency.indexOf('fbpayments:') === 0) {
        if(!no_clear) { change_selection(null); }
        Store.place_fbpayments_order(currency, price, unit_id, spellname, spellarg, cb, props);
        return false;
    } else if(currency == 'gamebucks') {
        return Store.place_gamebucks_order(price, unit_id, spellname, spellarg, cb);
    } else if(currency.indexOf('item:') === 0) {
        return Store.place_item_order(currency.split(':')[1], price, unit_id, spellname, spellarg, cb);
    } else if(currency in gamedata['resources']) {
        return Store.place_fungible_order(currency, price, unit_id, spellname, spellarg, cb);
    } else {
        throw Error('unknown currency '+currency);
    }
};

Store.gamebucks_order_serial = 6543;
Store.gamebucks_order_receivers = {};

Store.place_gamebucks_order = function(price, unit_id, spellname, spellarg, cb) {
    if(price > 0 && player.resource_state['gamebucks'] < price) {
        var descr = ''; // 'INSUFFICIENT:';
        try {
            // really don't want to get errors here, since it would kill the order
            descr += spellname+((unit_id in session.cur_objects.objects) ? ','+session.cur_objects.objects[unit_id].spec['name']:'')+(spellarg?','+spellarg.toString():'');
        } catch (e) {
            descr += 'UNKNOWN';
        }

        invoke_insufficient_alloy_message(descr, price - player.resource_state['gamebucks'],
                                          {'price':price, 'unit_id':unit_id, 'spellname':spellname, 'spellarg':spellarg, 'cb': cb});
        return false;
    }

    Store.gamebucks_order_serial += 1;
    var tag = "gbo"+Store.gamebucks_order_serial.toString();
    send_to_server.func(["GAMEBUCKS_ORDER", tag,
                    price, unit_id, spellname, spellarg, Math.floor(server_time)]);
    if(cb) {
        Store.gamebucks_order_receivers[tag] = cb;
    }
    return true;
};

Store.item_order_serial = 7345;
Store.item_order_receivers = {};
Store.place_item_order = function(specname, price, unit_id, spellname, spellarg, cb) {
    var has_qty = player.inventory_item_quantity(specname);
    if(has_qty < price) {
        var s = gamedata['errors']['INSUFFICIENT_ITEMS'];
        var spec = ItemDisplay.get_inventory_item_spec(specname);
        invoke_child_message_dialog(s['ui_title'], s['ui_name'].replace('%s',spec['ui_name_plural'] || spec['ui_name']).replace('%d',pretty_print_number(price-has_qty)), {'dialog': 'message_dialog_big'});
        return false;
    }

    Store.item_order_serial += 1;
    var tag = "io"+Store.item_order_serial.toString();
    send_to_server.func(["ITEM_ORDER", tag, specname, price, unit_id, spellname, spellarg, Math.floor(server_time)]);
    if(cb) {
        Store.item_order_receivers[tag] = cb;
    }
    return true;
}

Store.fungible_order_serial = 7345;
Store.fungible_order_receivers = {};
Store.place_fungible_order = function(resname, price, unit_id, spellname, spellarg, cb) {
    var has_qty = player.resource_state[resname][1];
    if(has_qty < price) {
        var resources_needed = {}; resources_needed[resname] = price - has_qty;
        var helper = get_requirements_help('resources', resources_needed, {even_if_tutorial_incomplete:true, continuation: null}); // maybe cb?
        if(helper) {
            helper();
        } else { // worst-case fallback
            var cost = {}; cost[resname] = price;
            invoke_insufficient_resources_message(cost, gamedata['errors']['INSUFFICIENT_RESOURCES']['ui_name']);
        }
        return false;
    }

    Store.fungible_order_serial += 1;
    var tag = "fo"+Store.fungible_order_serial.toString();
    send_to_server.func(["FUNGIBLE_ORDER", tag, resname, price, unit_id, spellname, spellarg, Math.floor(server_time)]);
    if(cb) {
        Store.fungible_order_receivers[tag] = cb;
    }

    // client-side prediction
    player.resource_state[resname][1] -= price;

    return true;
}

Store.credits_order_serial = 9241;
Store.credits_order_receivers = {};

Store.place_fbcredits_order = function(price, unit_id, spellname, spellarg, on_finish) {
    var descr = spellname;
    if(spellarg) {
        descr += ','+spellarg;
    }
    if(unit_id) {
        var object = session.cur_objects.objects[unit_id];
        descr += ','+object.spec['name'];
    }

    var icon;
    if(spellname.indexOf('BUY_GAMEBUCKS') === 0) {
        icon = player.get_any_abtest_value('fb_order_dialog_gamebucks_icon', gamedata['store']['fb_order_dialog_gamebucks_icon']);
    } else {
        icon = player.get_any_abtest_value('fb_order_dialog_generic_icon', gamedata['store']['fb_order_dialog_generic_icon']);
    }

    Store.credits_order_serial += 1;
    var tag = "fbo"+Store.credits_order_serial.toString();
    if(on_finish) {
        Store.credits_order_receivers[tag] = on_finish;
    }

    // this is arbitrary custom data for our server
    var order_info = {
        'session_id': session.session_id,
        'unit_id': unit_id,
        'client_unit_type': (object ? object.spec['name'] : null),
        'server_time_according_to_client': Math.floor(server_time),
        'spellname': spellname,
        'spellarg': spellarg,
        'client_price': price,
        'tag': tag,
        // have to pull images from proxyserver (?)
        'image_url': spin_server_protocol+spin_server_host+':'+spin_server_port+'/'+icon,
        'product_url': spin_server_protocol+spin_server_host+':'+spin_server_port+'/'+icon
    };

    // order completion callback
    var order_complete = (function(uid, pr, desc) { return function(data) {

        Store.order_cleanup_cb = null; // cancel it

        var props = {'currency': 'fbcredits',
                     'Billing Amount': Store.fbcredits_to_dollars(pr),
                     'Billing Description': desc};

        if(data['status'] != 'settled') {
            var msg = 'unknown error';
            if('error_code' in data && 'error_message' in data) {
                msg = 'error: '+data['error_code']+' '+data['error_message'];
            } else if('status' in data) {
                msg = 'status: '+data['status'];
            }
            console.log('ORDER PROBLEM: '+msg);
            props['method'] = msg;
            var ename;
            if(data['error_code'] == 1383010) {
                ename = '4068_order_prompt_canceled';
            } else {
                ename = '4069_order_prompt_failure';
            }
            metric_event(ename, props);
        } else {
            var msg = '';
            if('order_id' in data) {
                msg = 'order_id: '+data['order_id'];
                props['order_id'] = data['order_id'];
            }
            metric_event('4070_order_prompt_success', props);

            console.log('ORDER SUCCESSFUL: '+msg);

            // give realtime feedback on Facebook credit balance display
            // this may not be accurate - but we'll get an accurate update from the server
            // when it polls the Facebook API after processing the order
            player.resource_state['facebook_credits'] -= pr;

            // check for updated object and player status
            if(uid) {
                send_to_server.func(["PING_OBJECT", uid, "order_success"]);
            }
            send_to_server.func(["PING_TECH"]);
            send_to_server.func(["PING_PLAYER"]);
        }
    }; })(unit_id, price, descr);

    var props = {'currency': 'fbcredits',
                 'Billing Amount': Store.fbcredits_to_dollars(price),
                 'Billing Description': descr};

    if(spin_facebook_enabled) {
        // use the real Facebook Credits API
        var use_local_currency = (player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks') && player.get_any_abtest_value('use_local_currency', gamedata['store']['use_local_currency']) && player.facebook_currency;

        try {
            if(get_query_string('simulate_cb_fail')) { order_complete = function() { console.log("SIMULATING FB.PAY CALLBACK FAILURE"); }; }

            SPay.place_order_fbcredits(order_info, order_complete, use_local_currency);
        } catch(e) {
            log_exception(e, 'place_order');
            metric_event('4061_order_prompt_api_error', props);
            return false;
        }

        // set the cleanup-pending flag AFTER giving enough time for Facebook's dialog to block the UI
        window.setTimeout(function() { Store.order_cleanup_cb = function() {}; }, 2000);

    } else {
        // pretend the purchase was made successfully
        send_to_server.func(["DEV_SIMULATE_ORDER", order_info, 'fbcredits']);
        order_complete({'status':'settled'});

        user_log.msg('Simulating payment of '+ price.toString() + ' Facebook Credit(s)', new SPUI.Color(1,1,0,1));
        //invoke_child_message_dialog("Developer Message", 'Simulating payment of '+ price + ' Facebook credit(s)');
    }

    metric_event('4060_order_prompt', props);
    return true;
};

Store.place_kgcredits_order = function(price, unit_id, spellname, spellarg, on_finish, on_fail) {
    var descr = spellname;
    if(spellarg) {
        descr += ','+spellarg;
    }
    if(unit_id) {
        var object = session.cur_objects.objects[unit_id];
        descr += ','+object.spec['name'];
    }

    var icon = player.get_any_abtest_value('fb_order_dialog_gamebucks_icon', gamedata['store']['fb_order_dialog_gamebucks_icon']);

    Store.credits_order_serial += 1;
    var tag = "kgo"+Store.credits_order_serial.toString();
    if(on_finish) {
        Store.credits_order_receivers[tag] = on_finish;
    }

    // this is arbitrary custom data for our server
    var order_info = {
        'session_id': session.session_id,
        'unit_id': unit_id,
        'client_unit_type': (object ? object.spec['name'] : null),
        'server_time_according_to_client': Math.floor(server_time),
        'spellname': spellname,
        'spellarg': spellarg,
        'client_price': price,
        'tag': tag,
        // have to pull images from proxyserver (?)
        'image_url': spin_server_protocol+spin_server_host+':'+spin_server_port+'/'+icon
    };

    // order completion callback
    var order_complete = (function(uid, pr, desc, _on_fail) { return function(data) {

        Store.order_cleanup_cb = null; // cancel it

        var props = {'currency': 'kgcredits',
                     'Billing Amount': Store.kgcredits_to_dollars(pr),
                     'Billing Description': desc};

        if(!data['success']) {
            var msg = 'unknown error';
            console.log('ORDER PROBLEM: '+msg);
            props['method'] = msg;
            var ename = '4069_order_prompt_failure';
            metric_event(ename, props);
            if(_on_fail) { _on_fail(); }
        } else {
            var msg = '';
            if('item_order_id' in data) {
                msg = 'item_order_id: '+data['item_order_id'];
                props['item_order_id'] = data['item_order_id'];
            }
            metric_event('4070_order_prompt_success', props);

            console.log('ORDER SUCCESSFUL: '+msg);

            // check for updated object and player status
            if(uid) {
                send_to_server.func(["PING_OBJECT", uid, "order_success"]);
            }
            send_to_server.func(["PING_TECH"]);
            send_to_server.func(["PING_PLAYER"]);
        }
    }; })(unit_id, price, descr, on_fail);

    var props = {'currency': 'kgcredits',
                 'Billing Amount': Store.fbcredits_to_dollars(price),
                 'Billing Description': descr};
    var coded_order_info = 'SP'+SPHTTP.wrap_string(JSON.stringify(order_info));

    if(spin_kongregate_enabled) {
        // use the real API
        try {
            if(get_query_string('simulate_cb_fail')) { order_complete = function() { console.log("SIMULATING KONGREGATE.MTX.PURCHASEITEMsREMOTE CALLBACK FAILURE"); }; }
            SPay.place_order_kgcredits(coded_order_info, order_complete);
        } catch(e) {
            log_exception(e, 'place_order');
            metric_event('4061_order_prompt_api_error', props);
            return false;
        }
        // set the cleanup-pending flag AFTER giving enough time for Kongregate's dialog to block the UI
        window.setTimeout(function() { Store.order_cleanup_cb = function() {}; }, 2000);
    } else {
        // pretend the purchase was made successfully
        send_to_server.func(["DEV_SIMULATE_ORDER", coded_order_info, 'kgcredits']);
        order_complete({'success':true});

        user_log.msg('Simulating payment of '+ price.toString() + ' Kongregate Kred(s)', new SPUI.Color(1,1,0,1));
    }

    metric_event('4060_order_prompt', props);
    return true;
};

Store.fbpayments_order_serial = 1538;
Store.fbpayments_order_receivers = {};

Store.place_fbpayments_order = function(fbpayments_currency, price, unit_id, spellname, spellarg, on_finish, options) {
    if(!options) { options = {}; }
    var on_fail = options['fail_cb'] || null;
    var gift_order = options['gift_order'] || null;

    if(fbpayments_currency.indexOf('fbpayments:') !== 0) {
        throw Error('place_fbpayments_order with bad currency '+fbpayments_currency);
    }

    var currency = fbpayments_currency.split(':')[1];

    var descr = spellname;
    if(spellarg) {
        descr += ','+spellarg;
    }
    if(unit_id) {
        var object = session.cur_objects.objects[unit_id];
        descr += ','+object.spec['name'];
    }

    var product_url = 'http://'+spin_server_host+(parseInt(spin_server_http_port,10)!=80 ? ":"+spin_server_http_port : "")+"/OGPAPI?spellname="+spellname+"&type="+gamedata['game_id']+"_sku";
    var quantity = 1;

    Store.fbpayments_order_serial += 1;
    var request_id = gamedata['game_id']+'_'+session.user_id.toString()+'_'+spin_session_id+'_'+Store.fbpayments_order_serial.toString();

    var props = {'currency': currency,
                 'price': price,
                 'description': descr,
                 'product_url': product_url,
                 'request_id': request_id,
                 'quantity': 1};


    var tag = "fbp"+Store.fbpayments_order_serial.toString();
    if(on_finish) {
        Store.fbpayments_order_receivers[tag] = on_finish;
    }

    send_to_server.func(["FBPAYMENT_CREATE", tag, request_id, unit_id, spellname, spellarg, price, currency,
                         product_url, quantity, Math.floor(server_time), gift_order]);

    // order completion callback
    var order_complete = (function(_unit_id, _props, _on_fail) { return function(data) {

        Store.order_cleanup_cb = null; // cancel it

        if(!data || (data['status'] != 'completed')) {
            var msg = 'unknown error';
            if(data) {
                if('error_code' in data && 'error_message' in data) {
                    msg = 'error: '+data['error_code']+' '+data['error_message'];
                } else if('status' in data) {
                    msg = 'status: '+data['status'];
                }
            }
            console.log('ORDER PROBLEM: '+msg);
            _props['method'] = msg;
            var ename;
            if(data && data['error_code'] == 1383010) {
                ename = '4075_fbpayments_order_prompt_canceled';
            } else {
                ename = '4076_fbpayments_order_prompt_failure';
            }
            metric_event(ename, _props);
            send_to_server.func(["FBPAYMENT_IGNORE", _props['request_id']]);
            if(_on_fail) { _on_fail(); }
        } else {
            var msg = '';
            if('payment_id' in data) {
                msg = 'payment_id: '+data['payment_id'];
                _props['payment_id'] = data['payment_id'];
            }
            metric_event('4077_fbpayments_order_prompt_success', _props);

            console.log('ORDER SUCCESSFUL: '+msg);

            send_to_server.func(["FBPAYMENT_PING", _props['request_id'], data['signed_request'] || null]);
        }
    }; })(unit_id, props, on_fail);

    var test_currency = get_query_string('test_currency') || null;

    if(spin_facebook_enabled) {
        // use the real Facebook Credits API

        try {
            if(get_query_string('simulate_cb_fail')) { order_complete = function() { console.log("SIMULATING FB.PAY CALLBACK FAILURE"); }; }
            SPay.place_order_fbpayments(product_url, quantity, request_id, order_complete, test_currency);
        } catch(e) {
            log_exception(e, 'place_order');
            metric_event('4072_fbpayments_order_prompt_api_error', props);
            return false;
        }

        // set the cleanup-pending flag AFTER giving enough time for Facebook's dialog to block the UI
        // let's see if we can live without this for now...
        // window.setTimeout(function() { Store.order_cleanup_cb = function() {}; }, 2000);

    } else {
        // pretend the purchase was made successfully
        send_to_server.func(["FBPAYMENT_SIMULATE_PURCHASE", request_id]);
        order_complete({'status':'completed'});

        user_log.msg('Simulating payment of '+ price.toString() + ' ' + currency, new SPUI.Color(1,1,0,1));
    }
    metric_event('4071_fbpayments_order_prompt', props);
    return true;
};

Store.buy_more_fbcredits = function() {

    var order_complete = function(data) {

        Store.order_cleanup_cb = false;

        var props = {'Billing Description': 'buy_more_credits'};

        // Facebook does NOT apparently provide any info on whether it succeeded or failed...

        console.log('buy_more_credits result:');
        console.log(data);
        metric_event('4211_buy_more_credits_result_unknown', props);

        if(!('order_id' in data)) {
            var msg = 'unknown error';
            if('error_code' in data && 'error_message' in data) {
                msg = 'error: '+data['error_code']+' '+data['error_message'];
            } else if('status' in data) {
                msg = 'status: '+data['status'];
            }
            props['method'] = msg;
            //console.log('MORE CREDITS PROBLEM: '+msg);
            //metric_event('4209_buy_more_credits_failure', props);
        } else {
            var msg = '';
            if('order_id' in data) {
                msg = 'order_id: '+data['order_id'];
                props['order_id'] = data['order_id'];
            }
            //console.log('MORE CREDITS SUCCESSFUL: '+data);
            //metric_event('4210_buy_more_credits_success', props);
        }

        // recheck credit balance
        send_to_server.func(["PING_CREDITS"]);
    };

    if(spin_facebook_enabled) {
        try {
            SPay.buy_more_credits(order_complete);
        } catch(e) {
            log_exception(e, 'buy_more_credits');
            metric_event('4201_buy_more_credits_api_error', {'method':'buy_more_credits'});
            return;
        }

        // set the cleanup-pending flag AFTER giving enough time for Facebook's dialog to block the UI
        window.setTimeout(function() { Store.order_cleanup_cb = function() {}; }, 2000);

    } else {
        console.log('Store.buy_more_fbcredits()');
    }

    metric_event('4200_buy_more_credits_prompt', {});
};

Store.redeem_fb_gift_card = function(success_cb, fail_cb) {

    var order_complete = (function (_success_cb, _fail_cb) { return function(data) {
        // the callback only handles metrics. The actual success/failure and fulfillment
        // of the order happens via the FBRTAPI path on the server.

        Store.order_cleanup_cb = false;
        var success = false;

        if(data && ('status' in data) && (data['status'] == 'completed') && (data['quantity']>0)) {
            metric_event('4321_redeem_fb_gift_card_success', {'payment_id': data['payment_id'],
                                                              'quantity': data['quantity']});
            send_to_server.func(["FB_GIFT_CARD_REDEEMED", data['payment_id'], data['quantity']]);
            success = true;
        } else {
            metric_event('4322_redeem_fb_gift_card_failure', {'result':data});
        }

        // recheck credit balance
        send_to_server.func(["PING_CREDITS"]);

        // call provided callback
        if(success && _success_cb) {
            _success_cb();
        } else if(_fail_cb) {
            _fail_cb();
        }
    }; })(success_cb, fail_cb);

    if(spin_facebook_enabled) {
        try {
            SPay.redeem_fb_gift_card(order_complete);
        } catch(e) {
            log_exception(e, 'redeem_fb_gift_card');
            metric_event('4323_redeem_fb_gift_card_api_error', {'method':'redeem_fb_gift_card'});
            return;
        }

        // set the cleanup-pending flag AFTER giving enough time for Facebook's dialog to block the UI
        window.setTimeout(function() { Store.order_cleanup_cb = function() {}; }, 2000);

    } else {
        console.log('Store.redeem_fb_gift_card()');
    }

    metric_event('4320_redeem_fb_gift_card_prompt', {});
};

Store.trialpay_available = function() {
    return (spin_frame_platform == 'fb') &&
        spin_trialpay_vendor_id &&
        player.facebook_third_party_id &&
        SPay.trialpay_available();
};

Store.trialpay_invoke = function() {
    metric_event('4510_trialpay_invoked', {'purchase_ui_event': true, 'client_time':client_time});
    if(spin_facebook_enabled) {
        var proxyserver = spin_server_host+(parseInt(spin_server_http_port,10)!=80 ? ':'+spin_server_http_port : '');
        SPay.trialpay_invoke(spin_app_id,
                             spin_trialpay_vendor_id,
                             // callback URL
                             'http://'+proxyserver+'/TRIALPAYAPI',
                             // currency URL
                             'http://'+proxyserver+'/OGPAPI?type='+gamedata['game_id']+'_gamebucks', // note: MF would require a special hack
                             player.facebook_third_party_id,
                             session.user_id.toString(), // send user ID as order_info
                             Store.trialpay_callback);

        // set the cleanup-pending flag AFTER giving enough time for Facebook's dialog to block the UI
        window.setTimeout(function() { Store.order_cleanup_cb = function() {}; }, 2000);
    } else {
        console.log('Store.trialpay_invoke()');
    }
};

/** @param {string} result
    @param {Object=} data */
Store.trialpay_callback = function(result, data) {
    Store.order_cleanup_cb = false;

    if(result == 'open') {
        metric_event('4511_trialpay_opened', {'purchase_ui_event': true, 'client_time':client_time});
    } else if(result == 'close') {
        metric_event('4512_trialpay_closed', {'purchase_ui_event': true, 'client_time':client_time});
    } else if(result == 'complete') {
        metric_event('4513_trialpay_completed', {'purchase_ui_event': true, 'client_time':client_time,
                                                 'completions': data['completions'],
                                                 'gamebucks': data['vc_amount']});
        send_to_server.func(["PING_CREDITS"]); // may not be necessary, but just in case.
    }
};

// install a new dialog as a child of the current dialog (or at toplevel, if no UI is up)
function install_child_dialog(dialog) {
    // note: this should ideally be a check to make sure selection.ui inherits from SPUI.Container
    var parent = (selection.ui && selection.ui.add ? selection.ui : null);

    // never make major dialogs a child of a popup context menu, add them to the desktop instead
    if(parent && parent.user_data && parent.user_data['dialog'] &&
       (parent.user_data['dialog'] == 'context_menu' || parent.user_data['dialog'].indexOf('popout') != -1)) {
        parent = null;
    }

    if(parent) {
        if(0) { // XXXXXX descend hierarchy of child dialogs - this is actually more correct, try it sometime
            // (otherwise the current code appends to the topmost selection.ui, even if it already has a child dialog!)
            while(parent.children.length >= 1 && parent.children[parent.children.length-1].user_data && parent.children[parent.children.length-1].user_data['dialog']) {
                parent = parent.children[parent.children.length-1];
            }
        }

        if(parent.onleave) { parent.onleave(); }
        parent.add(dialog);
        SPUI.set_keyboard_focus(null);
    } else {
        change_selection_ui(dialog);
    }
    return dialog;
}

// Removes the parent. Works for both top-level and child dialogs.
function close_dialog(dialog) {
    if(selection.ui === dialog) {
        change_selection_ui(null);
    } else if(dialog.parent) {
        dialog.parent.remove(dialog);
    }
}

// Used as an onclick handler for "close" buttons. Closes the parent dialog containing widget "w".
function close_parent_dialog(w) {
    var dialog = w.parent;
    if(dialog) {
        close_dialog(dialog);
    }
}

function do_change_selection_ui(newui, under) {
    if(selection.ui) {
        SPUI.root.remove(selection.ui);
    }
    selection.ui = newui;
    if(selection.ui) {
        if(under) {
            SPUI.root.add_under(selection.ui);
        } else {
            SPUI.root.add(selection.ui);
        }
    }
    player.quest_tracked_dirty = true;
    selection.ui_change_time = client_time;
    SPUI.set_keyboard_focus(null);
}
function change_selection_ui(newui) {
    do_change_selection_ui(newui, false);
}
function change_selection_ui_under(newui) {
    do_change_selection_ui(newui, true);
}

function change_selection_unit(newunit) {
    selection.unit = newunit;
    selection.spellname = null;
    selection.spellkind = null;
    selection.slot = -1;
    selection.item = null;
    selection.multi = [];
    player.quest_tracked_dirty = true;
}

function change_selection(newsel) {
    change_selection_ui(null);
    change_selection_unit(newsel);
};

// add 'u' to selection, handling cases where it's already selected
function add_unit_to_selection(u) {
    if(u === selection.unit) { return; }
    for(var j = 0; j < selection.multi.length; j++) {
        if(selection.multi[j] === u) {
            return;
        }
    }
    selection.multi.push(u);
    if(!selection.unit) {
        selection.unit = u;
    }
};
// if 'u' was not selected, select it. Otherwise, deselect it.
function toggle_unit_selection(u) {
    if(u === selection.unit) {
        for(var j = 0; j < selection.multi.length; j++) {
            if(selection.multi[j] === u) {
                selection.multi.splice(j, 1);
                break;
            }
        }

        if(selection.multi.length > 0) {
            selection.unit = selection.multi[0];
        } else {
            change_selection_unit(null);
        }
        return;
    }
    for(var j = 0; j < selection.multi.length; j++) {
        if(selection.multi[j] === u) {
            selection.multi.splice(j, 1);
            return;
        }
    }
    // unit was definitely not selected
    if(!selection.unit) {
        selection.unit = u;
    } else {
        selection.multi.push(u);
    }
};

function on_ajax_goog(event) {
    if(!event.target.isSuccess()) {
        client_time = (new Date()).getTime()/1000;
        var code = event.target.getLastErrorCode();
        var msg = '';
        var conntime;
        if(!session.connected()) {
            conntime = -1;
            if(spin_game_direct_connect) {
                msg += 'FIRST(direct) ';
            } else {
                msg += 'FIRST(proxy) ';
            }
        } else {
            conntime = client_time - session.connect_time;
            msg += 'post-connect '+conntime.toFixed(2)+' sec, serial '+message_serial.toString();
        }
        msg += ', '+(client_time - spin_pageload_begin).toFixed(2)+' sec since pageload';
        msg += ', art progress '+GameArt.get_dl_progress_all().toFixed(3);

        try {
            // accessing some XHR object fields when request fails synchronously throws exceptions
            // just try to get as much info as we can
            msg += ', error code '+event.target.getLastErrorCode().toString();
            msg += ', status '+event.target.getStatus().toString();
            msg += ', statusText '+event.target.getStatusText();
        } catch (e) {}

        var props = add_demographics({'user_id':spin_user_id,
                                      'method':msg,
                                      'serial': last_ajax_serial,
                                      'len': last_ajax_xmit_len,
                                      'elapsed': client_time - last_ajax_xmit_time,
                                      'since_connect': conntime,
                                      'since_pageload': client_time - spin_pageload_begin,
                                      'connection': gameapi_connection_method()
                                     });

        if(!session.connected() && spin_game_direct_connect && session.client_hello_packet != null && ajax_config['enable_proxy']) {
            // fall back to proxied connection before giving up
            SPLWMetrics.send_event(spin_metrics_anon_id, '0631_direct_ajax_failure_falling_back_to_proxy', props);
            spin_game_direct_connect = false;
            spin_game_use_websocket = false; // if AJAX to nonstandard ports doesn't work, websockets probably won't either.

            // some browsers (Opera) call this synchronously from within send() in certain failure cases (overzealous CORS protection?)
            // perform the retry after an asynchronous wait in order to avoid messing up message_serial
            window.setTimeout(function() {
                message_serial = 0;
                message_queue = new AJAXMessageQueue();
                send_to_server.func(session.client_hello_packet);
                flush_message_queue(true, ajax_config['message_timeout_hello']);
            }, 10);
        } else {
            var coded_msg = null;

            if(code === goog.net.ErrorCode.HTTP_ERROR) {
                // we failed to send the request, or got a bad HTTP response code back
                if(SPINPUNCHGAME.shutdown_in_progress) {
                    // outstanding AJAX requests get aborted and return here when the browser window closes
                    // this is not to be considered a failure, so do not transmit the metric.
                } else {
                    coded_msg = '0630_client_died_from_ajax_xmit_failure';
                }
            } else if(code === goog.net.ErrorCode.TIMEOUT) {
                // request was sent but we didn't get an answer within the timeout period
                coded_msg = '0635_client_died_from_ajax_xmit_timeout';
            } else {
                console.log('unrecognized AJAX error!');
                coded_msg = '0639_client_died_from_ajax_unknown_failure';
            }
            if(coded_msg) {
                var template = gamedata['errors']['CLIENT_NETWORK_FAILURE'];
                invoke_timeout_message(coded_msg, props,
                                       {'ui_title': template['ui_title'],
                                        'ui_description': template['ui_description'].replace('%d', coded_msg.slice(0,4)),
                                        'dialog': template['dialog'],
                                        'ui_button': template['ui_button']
                                       });
            }
        }
    } else {
        return on_ajax(event.target.getResponseText(), gameapi_connection_method()+':sync');
    }
};

var ajax_recv_buffer = {};
var ajax_next_serial = 0;

function on_ajax(response, kind) {
    var from_server = JSON.parse(response);
    if(!from_server || !('serial' in from_server) || !('msg' in from_server) || !('clock' in from_server)) {
        // connection probably got terminated
        invoke_timeout_message('0640_client_died_from_ajax_recv_failure', {}, {});
        return -1;
    }
    var serial = from_server['serial'];
    var clock = from_server['clock'];
    var messages = from_server['msg'];

    return recv_message_bundle(serial, clock, messages, kind);
}

function recv_message_bundle(serial, clock, messages, kind) {
    if(clock > 0) {
        // reset server_time_offset
        server_time_offset = clock - (new Date()).getTime()/1000;
        update_client_and_server_time();
        SPUI.time = client_time; SPFX.time = client_time;
        GameArt.sync_time(client_time);
    }

    if(serial < 0) {
        // protocol error message - something is really messed up. Process immediately because it's not part of the regular message stream
        handle_server_message_bundle(-1, {'messages':messages, 'kind':'error'});
        return -1;
    }
    if(serial in ajax_recv_buffer) { throw Error('duplicated server serial '+serial.toString()); }
    ajax_recv_buffer[serial] = {'messages':messages, 'kind':kind};
    process_recv_buffer();
    return 0;
}

function process_recv_buffer() {
    while(ajax_next_serial in ajax_recv_buffer) {
        var bundle = ajax_recv_buffer[ajax_next_serial];
        delete ajax_recv_buffer[ajax_next_serial];
        handle_server_message_bundle(ajax_next_serial, bundle);
        ajax_next_serial += 1;
    }

    if(goog.object.getCount(ajax_recv_buffer) >= gamedata['client']['ajax_message_buffer']) {
        return invoke_timeout_message('0620_client_died_from_client_lag', {}, {});
    }
}

function handle_server_message_bundle(serial, bundle) {
    var messages = bundle['messages'];
    for(var msgnum = 0; msgnum < messages.length; msgnum++) {
        var msg = messages[msgnum];
        try {
            if(player.is_developer()) {
                console.log(['From Server ('+bundle['kind']+')', serial.toString()].concat(msg));
            }
            handle_server_message(msg);
        } catch(e) {
            log_exception(e, 'handle_server_message');
        }
    }
}

function handle_server_message(data) {
    var msg = data[0];

    if(msg == "SERVER_HELLO") {
        var server_gamedata_version = data[1];
        if(session.user_id != data[2]) { throw Error('unexpected user_id: spin_user_id '+spin_user_id.toString()+' SERVER_HELLO '+data[2].toString()); }
        if(session.session_id != data[3]) { throw Error('unexpected session_id: spin_session_id '+spin_session_id.toString()+' SERVER_HELLO '+data[3].toString()); }

        var server_measured_time = data[4];

        console.log("Your SpinPunch user ID is "+session.user_id+". Server gamedata version is "+server_gamedata_version);
        console.log("Server time is " + server_measured_time + ", client time is "+ client_time +", offset is " + server_time_offset)

        player.facebook_name = data[5];
        player.tutorial_state = data[6];
        if(data[7] !== null) { player.preferences = data[7]; }

        var needs_daily_attack = data[8];
        if(needs_daily_attack) {
            player.daily_attack_time = client_time + gamedata['ai_attacks_client']['after_login_time'];
            console.log('queueing daily attack for '+player.daily_attack_time);
        }

        player.country = data[9];
        player.country_tier = data[10];
        player.price_region = data[11];
        player.logged_in_times = data[12];
        player.init_abtests(data[13]);
        player.developer = !!data[14];
        player.is_suspicious = data[15];
        player.isolate_pvp = data[16];
        player.acquisition_campaign = data[17];
        player.home_base_id = data[18];
        var money_spent = data[19];
        player.history['money_spent'] = money_spent; // set this so early PLAYER_HISTORY predicates will work
        player.creation_time = data[20];
        player.chat_seen = data[21];
        player.is_chat_mod = data[22];
        var daily_banner = data[23];

        ChatFilter.init(gamedata['client']['chat_filter']);

        session.region = new Region(null); // note: start with "blank" region, updated later

        session.connect_time = client_time;
        session.client_hello_packet = null;

        if(gamedata['client']['enable_loading_metrics']) {
            metric_event('0106_game_connected_to_server', {'time_to_RUNNING': (new Date()).getTime()/1000 - spin_pageload_begin,
                                                           'method': (spin_game_direct_connect ? 'direct':'proxy')});
        }

        // optionally switch on websockets (which may already be on from init() if gamedata.client.enable_websockets is true)
        // but note: don't do this if spin_game_direct_connect has been turned off by error 0631 happening from an earlier connection attempt
        if(!spin_game_use_websocket && spin_game_direct_connect && (parseInt(spin_game_server_ws_port,10) > 0 || parseInt(spin_game_server_wss_port,10) > 0)) {
            if(player.get_any_abtest_value('enable_websockets', false) && SPWebsocket.is_supported()) {
                spin_game_use_websocket = true;
            }
        }

        // order of precedence for graphics options is browser default << A/B test << player preference << URL query
        var use_low_gfx = (spin_demographics['browser_name'] in gamedata['client']['force_low_gfx_by_browser']) ||
            (spin_demographics['browser_OS'] in gamedata['client']['force_low_gfx_by_os']);
        var use_high_gfx = false;
        var use_lazy_art = gamedata['client']['lazy_art'] || (spin_demographics['browser_name'] in gamedata['client']['force_lazy_art_by_browser']);

        use_low_gfx = player.get_any_abtest_value('force_low_gfx', use_low_gfx);
        use_high_gfx = player.get_any_abtest_value('force_high_gfx', use_high_gfx);
        use_lazy_art = player.get_any_abtest_value('force_lazy_art', use_lazy_art);

        // IGNORE player.preferences setting if the browser is in force_low_gfx_by_browser
        if(!((spin_demographics['browser_name'] in gamedata['client']['force_low_gfx_by_browser']) ||
             (spin_demographics['browser_OS'] in gamedata['client']['force_low_gfx_by_os']))) {
            if('low_gfx' in player.preferences) {
                use_low_gfx = !!player.preferences['low_gfx'];
                if(use_low_gfx) {
                    use_high_gfx = false;
                }
            } else {
                // note: set player.preferences explicitly here, so that
                // the browser default will get pushed into preferences
                player.preferences['low_gfx'] = (use_low_gfx ? 1 : 0);
            }
        }

        // permanently disabled this preference, since manually turning lazy_art off is really BAD for performance
        //if('lazy_art' in player.preferences) { use_lazy_art = !!player.preferences['lazy_art']; }

        if(document.URL.indexOf('low_gfx=1') != -1) { use_low_gfx = true; }
        if(document.URL.indexOf('low_gfx=0') != -1) { use_low_gfx = false; }
        if(document.URL.indexOf('high_gfx=1') != -1) { use_high_gfx = true; }
        if(document.URL.indexOf('high_gfx=0') != -1) { use_high_gfx = false; }
        if(document.URL.indexOf('lazy_art=1') != -1) { use_lazy_art = true; }
        if(document.URL.indexOf('lazy_art=0') != -1) { use_lazy_art = false; }


        var enable_audio = (!blacklist_audio) && (get_query_string('enable_audio') !== '0') && buzz.isSupported() && (buzz.isMP3Supported() || buzz.isOGGSupported());
        var audio_driver = null;
        if(enable_audio) {
            var q = get_query_string('audio_driver');
            if(q) {
                audio_driver = q;
            } else {
                audio_driver = eval_cond(player.get_any_abtest_value('default_audio_driver', gamedata['client']['default_audio_driver'] || null), player, null);
            }
        }

        console.log('GameArt settings: low_gfx '+use_low_gfx+' high_gfx '+use_high_gfx+' lazy_art '+use_lazy_art+' audio_driver '+(audio_driver ? audio_driver.toString() : null));

        GameArt.init(client_time, canvas, ctx, gamedata['art'], gameart_onload, audio_driver, use_low_gfx, use_lazy_art, player.get_any_abtest_value('enable_pixel_manipulation_in_low_gfx', gamedata['client']['enable_pixel_manipulation_in_low_gfx']));

        SPFX.init(canvas, ctx, use_low_gfx, use_high_gfx);

        if('sound_volume' in player.preferences) {
            GameArt.sound_volume = player.preferences['sound_volume'];
        } else {
            GameArt.sound_volume = 1;
        }
        if('music_volume' in player.preferences) {
            GameArt.music_volume = player.preferences['music_volume'];
        } else {
            GameArt.music_volume = 1;
        }

        PlayerCache.init(gamedata['client']['player_cache']);

        var need_reflow = false;

        // fill header
        var header = document.getElementById('spin_header');
        if(header) {
            var inner = player.get_any_abtest_value('spin_header_content', daily_banner);
            if(inner) {
                header.innerHTML = url_put_info(inner, session.user_id, money_spent);
                need_reflow = true;
            }
        }

        // fill the footer linkbar
        var bar = document.getElementById('spin_footer_linkbar_content');
        if(bar) {
            var inner = eval_cond_or_literal(player.get_any_abtest_value('footer_linkbar_content', gamedata['strings']['footer_linkbar_content'] || null), player, null);
            if(inner) {
                bar.innerHTML = url_put_info(inner, session.user_id, money_spent);
            }
        }

        linkbar_put_id(session.user_id);

        // reflow in case the header height changed
        if(need_reflow) { on_resize_browser(null); }

        // fill footer ad area
        if(player.is_syfy_user()) {
            var container = document.getElementById('spin_footer_ad');
            if(container) {
                container.style.background = '#000000';
                var rnd = window['rnd'] || Math.floor(Math.random()*10e6);
                var pid151920 = window['pid151920'] || rnd;
                var plc151920 = window['plc151920'] || 0;
                var abkw = window['abkw'] || '';
                var absrc = 'http://ab161933.adbutler-exciton.com/adserve/;ID=161933;size=760x250;setID=151920;type=iframe;kw='+abkw+';pid='+pid151920+';place='+(plc151920++)+';rnd='+rnd+'';
                container.innerHTML = '<ifr'+'ame src="'+absrc+'?syfy_game_MF_bottombanner" width="760" height="250" marginwidth="0" marginheight="0" hspace="0" vspace="0" frameborder="0" scrolling="no"></ifr'+'ame>';
            }
        }

        // apply Perfect Audience cookie
        if(player.get_any_abtest_value('enable_perfect_audience', gamedata['client']['enable_perfect_audience'])) {
            (function() {
                var pa = document.createElement('script'); pa.type = 'text/javascript'; pa.async = true;
                pa.src = ('https:' == document.location.protocol ? 'https:' : 'http:') + "//tag.perfectaudience.com/serve/503fb4dc726ac60002000001.js";
                var s = document.getElementsByTagName('script')[0];
                s.parentNode.insertBefore(pa, s);
            })();
        }

    } else if(msg == "SQUADS_UPDATE") {
        player.squads = data[1];
        for(var key in squad_update_receivers) {
            squad_update_receivers[key]();
        }
    } else if(msg == "PLAYER_ARMY_UPDATE" || msg == "PLAYER_ARMY_UPDATE_FULL") {
        if(msg == "PLAYER_ARMY_UPDATE_FULL") {
            player.my_army = {};
        }
        goog.array.forEach(data[1], function(state) {
            player.my_army[state['obj_id']] = state;
        });
        session.lazy_update_citizens();
    } else if(msg == "PLAYER_ARMY_UPDATE_DESTROYED") {
        var obj_id = data[1];
        if(obj_id in player.my_army) { delete player.my_army[obj_id]; }
        session.lazy_update_citizens();
    } else if(msg == "REGION_CHANGE") {
        change_region_pending = null;
        var new_region_id = data[1];
        var during_login = data[3];
        session.region = new Region(gamedata['regions'][new_region_id]);
        player.home_base_loc = data[2];
        if(session.home_base && session.viewing_base) { session.viewing_base.base_map_loc = player.home_base_loc; }
        session.region.ping_contest_rank();
        if(!during_login) {
            // kill any UI
            change_selection(null);
            notification_queue.push_with_priority(function() {
                if(!session.region.data) { return; }
                var msg = gamedata['strings']['change_region_finish'];
                invoke_child_message_dialog(msg['ui_title'].replace('%s', session.region.data['ui_name']),
                                            msg['ui_description'].replace('%s', session.region.data['ui_name']).replace('%loc', player.home_base_loc[0].toString()+','+player.home_base_loc[1].toString())+session.region.data['ui_description_long'],
                                            {'dialog': 'message_dialog_big'});
                GameArt.assets[ "success_playful_22"].states['normal'].audio.play(client_time);
            }, -2);
        }

        // XXX does not set gravity parameters as in SESSION_CHANGE
        session.viewing_base.base_climate = data[4];
        session.viewing_base.base_climate_data = (gamedata['climates'][session.viewing_base.base_climate] || {});

        if(global_chat_frame) { change_chat_tab(global_chat_frame, null); }

    } else if(msg == "MAP_BOOKMARKS_UPDATE") {
        player.map_bookmarks = data[1];
    } else if(msg == "FACEBOOK_NAME_UPDATE") {
        player.facebook_name = data[1];
    } else if(msg == "FACEBOOK_THIRD_PARTY_ID_UPDATE") {
        player.facebook_third_party_id = data[1];
    } else if(msg == "PLAYER_UI_NAME_UPDATE") {
        player.ui_name = data[1];
        var dlg = desktop_dialogs['desktop_top'];
        if(dlg && dlg.widgets['player_portrait']) { dlg.widgets['player_portrait'].invalidate(); } // reset avatar image
    } else if(msg == "PLAYER_CACHE_UPDATE") {
        PlayerCache.update_batch(data[1]);
    } else if(msg == "FACEBOOK_CURRENCY_UPDATE") {
        player.facebook_currency = data[1];
        if(player.facebook_currency && get_query_string('test_currency')) {
            player.facebook_currency['user_currency'] = get_query_string('test_currency');
        }
    } else if(msg == "ABTEST_UPDATE") {
        player.init_abtests(data[1]);
    } else if(msg == "CHAT_GAG_RESULT" || msg == "CHAT_UNGAG_RESULT") {
        var target_id = data[1], success = data[2];
        if(success) {
            PlayerCache.update(target_id, {'chat_gagged': (msg == "CHAT_GAG_RESULT" ? true : false)});
            var s = gamedata['strings'][(msg == "CHAT_GAG_RESULT" ? 'chat_gag_success' : 'chat_ungag_success')];
            var info = PlayerCache.query_sync(target_id);
            var name = PlayerCache.get_ui_name(info);
            invoke_child_message_dialog(s['ui_title'],
                                        s['ui_description'].replace('%d', target_id.toString()).replace('%s',name));
        }
    } else if(msg == "ALLIANCE_JOIN_REQUESTS") {
        var idlist = data[1], pcache_data = data[2];

        // stick pcache_data into PlayerCache
        PlayerCache.update_batch(pcache_data);

        var disp_func = function (_id) { return function() {
            invoke_alliance_join_request(_id);
        }; };

        for(var i = 0; i < idlist.length; i++) {
            notification_queue.push_with_priority(disp_func(idlist[i]), -10);
        }

    } else if(msg == "ALLIANCE_CREATE_RESULT" || msg == "ALLIANCE_MODIFY_RESULT") {
        var props = data[1], new_id = data[2]; // success if new_id > 0
        AllianceCache.receive_create_or_modify_result(props['tag'], new_id);
    } else if(msg == "ALLIANCE_INVITE_RESULT" || msg == "ALLIANCE_KICK_RESULT" || msg == "ALLIANCE_PROMOTE_RESULT") {
        var alliance_id = data[1], affected_user = data[2], success = data[3], tag = data[4];
        if(success) {
            GameArt.assets["success_playful_22"].states['normal'].audio.play(client_time);
            var ui_msg = gamedata['strings']['alliance_'+{'ALLIANCE_INVITE_RESULT':'invite',
                                                          'ALLIANCE_KICK_RESULT':'kick',
                                                          'ALLIANCE_PROMOTE_RESULT':'promote'}[msg]+'_finish'];
            var player_props = PlayerCache.query_sync(affected_user);
            var name = PlayerCache.get_ui_name(player_props);
            invoke_child_message_dialog(ui_msg['ui_title'],
                                        ui_msg['ui_description'].replace('%s', name),
                                        {'dialog': 'message_dialog_big'});
        }
        AllianceCache.receive_invite_or_kick_result(tag, success);
    } else if(msg == "ALLIANCE_ACK_JOIN_REQUEST_RESULT") {
        var alliance_id = data[1], affected_user = data[2], success = data[3], tag = data[4];
        AllianceCache.receive_ack_join_request_result(tag, success);
    } else if(msg == "ALLIANCE_SEND_JOIN_REQUEST_RESULT") {
        var alliance_id = data[1], success = data[2], tag = data[3];
        AllianceCache.receive_send_join_request_result(tag, success);
    } else if(msg == "ALLIANCE_UPDATE") {
        var old_id = session.alliance_id;
        session.alliance_id = data[1];
        var init = data[2]; // true if this is happening on login or otherwise silently updating state (suppresses GUI notifications)
        var cache_entry = data[3];
        session.alliance_membership = data[4];
        var role_changed = data[5];

        if(session.alliance_id > 0) {
            AllianceCache.update(session.alliance_id, cache_entry);
        }

        // sync the player cache
        PlayerCache.update_alliance_membership(session.user_id, session.alliance_id);

        if(global_chat_frame) {
            // make sure Alliance tab has the right state
            change_chat_tab(global_chat_frame, null);

            if(init && global_chat_frame.is_visible()) {
                var do_maximize;
                if(0 && 'chat_frame_minimized' in player.preferences) { // turned off for now
                    do_maximize = !player.preferences['chat_frame_minimized'];
                } else {
                    do_maximize = read_predicate(gamedata['client']['maximize_chat_on_login_if']).is_satisfied(player,null);
                }
                if(do_maximize) {
                    chat_frame_size(global_chat_frame, true, true);
                }
            }
        }

        if(role_changed) {
            var display_func = function() {
                if(!session.is_in_alliance()) { return; }
                var msg = gamedata['strings']['alliance_role_changed'];
                var info = AllianceCache.query_info_sync(session.alliance_id);
                invoke_child_message_dialog(msg['ui_title'],
                                            msg['ui_description'].replace('%alliance', alliance_display_name(info)).replace('%role', info['roles'][(session.alliance_membership['role']||0).toString()]['ui_name']),
                                            {'dialog': 'message_dialog_big'});
                GameArt.assets["success_playful_22"].states['normal'].audio.play(client_time);
            };
            notification_queue.push_with_priority(display_func, -3);

        } else if(!init) {
            if(session.alliance_id > 0) {
                AllianceCache.query_info(session.alliance_id, (function (_old_id) { return function(r) {
                    change_selection(null);
                    var display_func = (function (_r, action) { return function() {
                        var msg = gamedata['strings'][action+'_alliance_finish'];
                        invoke_child_message_dialog(msg['ui_title'].replace('%s', _r['ui_name']),
                                                    msg['ui_description'].replace('%s', _r['ui_name']),
                                                    {'dialog': 'message_dialog_big'});
                        GameArt.assets["success_playful_22"].states['normal'].audio.play(client_time);
                    }; })(r, (session.alliance_id == _old_id ? 'modify' : 'join'));
                    notification_queue.push_with_priority(display_func, -2);
                }; })(old_id));
            } else {
                var display_func = function() {
                    var msg = gamedata['strings']['leave_alliance_finish'];
                    invoke_child_message_dialog(msg['ui_title'],
                                                msg['ui_description'],
                                                {'dialog': 'message_dialog_big'});
                    GameArt.assets["error_sound"].states['normal'].audio.play(client_time);
                };
                change_selection(null);
                notification_queue.push_with_priority(display_func, -2);
            }
            if(global_chat_frame) {
                // force-maximize alliance chat
                if(global_chat_frame.is_visible() && session.is_in_alliance()) {
                    chat_frame_size(global_chat_frame, true, true);
                }
            }
        }

    } else if(msg == "SESSION_CHANGE") {

        APMCounter.reset();

        // see if we need to display a battle-end message
        var battle_ended = false, battle_loot = null, battle_summary = null, battle_type = null, battle_base = null, battle_ladder_state = session.ladder_state;
        var battle_opponent_user_id = null, battle_opponent_fbid = null, battle_opponent_level = null, battle_opponent_friend = null, battle_opponent_name = null;
        var battle_outcome = data[10];

        if(session.has_deployed && (!session.is_quarry() || (session.viewing_user_id != session.user_id))) {
            battle_ended = true;
            battle_base = session.viewing_base;

            // use the loot info sent from the server, because it may have been
            // increased by victory bonus XP

            battle_summary = data[9];
            if(battle_summary && ('loot' in battle_summary)) {
                battle_loot = battle_summary['loot']; // for legacy code
            } else {
                throw Error('received a bad battle summary: '+(battle_summary ? JSON.stringify(battle_summary) : 'null/undefined') + ' at '+(session.viewing_base ? session.viewing_base.base_id.toString() : 'null'));
            }

            if(session.home_base) {
                battle_type = 'home';
                battle_opponent_name = session.incoming_attacker_name;
            } else {
                battle_type = (battle_ladder_state ? 'ladder' : (session.viewing_base.base_type == 'quarry' ? 'quarry' : (session.viewing_base.base_type == 'squad' ? 'squad' : 'away')));
                battle_opponent_user_id = session.viewing_user_id;
                battle_opponent_fbid = null; // XXX this is obsolete and never used by callees (was session.viewing_fbid)
                battle_opponent_level = enemy.resource_state['player_level'];
                battle_opponent_name = session.ui_name;

                // increment opponent's battle count
                for(var i = 0; i < player.friends.length; i++) {
                    if(player.friends[i].user_id === session.viewing_user_id) {
                        battle_opponent_friend = player.friends[i];
                        player.friends[i].battle_count += 1;
                        break;
                    }
                }
            }
        }

        // blow away the old session
        change_selection(null);
        if(session.citizens) {
            session.citizens.dispose();
            session.citizens = null;
        }
        SPFX.clear();
        offscreen_unit_arrow = null;
        visit_base_pending = false;

        // cancel "loading base" message if it hasn't fired yet
        cancel_loading_base_timer();

        session.viewing_user_id = data[1];
        var unused_viewing_fbid = data[2];
        session.viewing_ai = is_ai_user_id_range(session.viewing_user_id);
        session.viewing_friend = null;
        session.ui_name = data[3];
        session.home_base = data[4];
        session.has_attacked = false;
        session.has_deployed = false;
        session.deploy_time = -1;
        session.enable_combat_resource_bars = true;
        session.enable_dialog_completion_buttons = true;
        session.surrender_pending = false;
        session.retreat_pending = -1;
        session.no_more_units = false;
        session.set_attack_finish_time(-1);
        session.incoming_attack_time = -1;
        session.incoming_attack_wave_time = -1;
        session.incoming_attack_units = [];
        session.incoming_attack_units_total = 0;
        session.incoming_attack_units_destroyed = 0;
        session.battle_outcome_sync_marker = Synchronizer.INIT;
        session.battle_outcome_dirty = false;

        // don't reset this, it needs to carry over between sessions: session.incoming_attacker_name = '';
        session.loot = {};
        session.last_loot = {};
        session.last_looted_uncapped = {};
        session.res_looter = null;
        session.pre_deploy_units = {};
        session.post_deploy_units = {};
        session.pvp_balance = data[11];
        session.viewing_lock_state = data[12];
        session.viewing_isolate_pvp = data[13];
        session.repeat_attack_cooldown_expire = data[14];

        var viewing_base_id = data[16];
        session.viewing_base = new Base(viewing_base_id);
        session.viewing_base.deployment_buffer = data[15];
        session.viewing_base.base_landlord_id = data[17];
        session.viewing_base.base_climate = data[18];
        session.viewing_base.base_climate_data = (gamedata['climates'][session.viewing_base.base_climate] || {});
        session.viewing_base.base_map_loc = data[19];
        session.viewing_base.base_expire_time = data[20];
        session.viewing_base.base_ui_name = data[21];
        session.viewing_base.base_type = data[22];
        session.viewing_base.base_ncells = data[23];
        session.viewing_player_home_base_id = data[24];
        session.viewing_player_home_region = data[25];
        session.is_alt_account = data[26];
        session.viewing_base.base_last_attack_time = data[27] || -1;
        session.deployable_squads = data[28];
        session.deployed_unit_space = 0;
        session.weak_zombie_warned = false;
        if(gamedata['territory']['dirty_region_map_after_session_change']) { session.region.dirty = true; }
        var viewing_alliance_id = data[29], viewing_alliance_info = data[30];
        session.ladder_state = data[31];
        var viewing_trophy_data = data[32];
        session.home_warehouse_busy = data[33];
        session.defending_squads = data[34];
        enemy.is_pvp_player_cache = data[35];
        var pcache_data = data[36];
        PlayerCache.update_batch(pcache_data);
        session.home_equip_items = data[37] || [];

        // when spying on friendly squads in NoSQL land, assume lock is taken
        if(!session.home_base && session.region.data && session.region.data['storage'] == 'nosql' &&
           (session.viewing_base.base_landlord_id == session.user_id) && (goog.array.contains(['squad','quarry'], session.viewing_base.base_type))) {
            session.has_attacked = true;
            session.set_attack_finish_time(server_time + gamedata['reinforce_time']);
        }

        // send lock state update into the player cache
        if(!session.home_base && !session.viewing_ai && (session.viewing_base.base_id == session.viewing_player_home_base_id)) {
            PlayerCache.update_lock_state(session.viewing_user_id, session.viewing_lock_state);
        }

        // send alliance update into the caches
        if(viewing_alliance_id > 0) {
            PlayerCache.update_alliance_membership(session.viewing_user_id, viewing_alliance_id);
            if(viewing_alliance_info) {
                AllianceCache.update(viewing_alliance_id, viewing_alliance_info);
            }
        }

        // send trophy data to the cache
        if(viewing_trophy_data) {
            PlayerCache.update(session.viewing_user_id, viewing_trophy_data);
        }

        session.combat_engine = new CombatEngine.CombatEngine();

        // set physics properties
        SPFX.global_gravity = (('gravity' in session.viewing_base.base_climate_data) ? session.viewing_base.base_climate_data['gravity'] : 1);
        SPFX.global_ground_plane = (('ground_plane' in session.viewing_base.base_climate_data) ? session.viewing_base.base_climate_data['ground_plane'] : 0);

        // see if the fbid is in our friend list
        for(var i = 0; i < player.friends.length; i++) {
            if(player.friends[i].user_id === session.viewing_user_id) {
                session.viewing_friend = player.friends[i];
                break;
            }
        }

        console.log("Session ("+session.ui_name+") ID is " + session.session_id);

        // set up game map
        var ncells = session.viewing_base.ncells();

        astar_map = new AStar.AStarRectMap(ncells, null, ('allow_diagonal_passage' in gamedata['map'] ? gamedata['map']['allow_diagonal_passage'] : true));
        astar_context = new AStar.CachedAStarContext(astar_map, {heuristic_name:gamedata['client']['astar_heuristic'],
                                                                 iter_limit:gamedata['client']['astar_iter_limit'][session.viewing_ai ? 'pve':'pvp'],
                                                                 use_connectivity:(!!gamedata['client']['astar_use_connectivity'])});
        voxel_map_accel = new VoxelMapAccelerator.VoxelMapAccelerator(ncells, gamedata['client']['map_accel_chunk']);
        team_map_accel = new TeamMapAccelerator.TeamMapAccelerator();
        map_queries_by_tag = {'ticks':0};

        // read object state from server
        session.cur_objects.clear();
        session.minefield_tags_by_obj_id = {};
        session.minefield_tags_by_tag = {};
        session.factory_tags_by_obj_id = {};
        session.factory_tags_by_tag = {};
        mouse_state.hovering_over = null;

        var object_state = data[5];
        for(var n = 0; n < object_state.length; n++) {
            var obj = create_object(object_state[n], false);
            session.add_object(obj);
            if(obj.team === 'player' && obj.is_mobile()) {
                session.deployed_unit_space += obj.get_leveled_quantity(obj.spec['consumes_space'] || 0);
            }
        }

        if(battle_type != 'home' && !goog.array.contains(['repair_message', 'wait_for_battle_finish','build_cannon_message','open_buildings_dialog'], player.tutorial_state)) {
            // recenter view, unless part of the "seamless" session change after home-base attack
            view_pos = [0,0];
            force_scroll_state.key = null;
            if(!session.home_base && session.viewing_ai &&
               !read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null) &&
               // during tutorial, when spying on AI enemies, recenter southwest to make deployment area more visible
               player.tutorial_state === 'click_attack') {
                if('force_scroll_after_session_change' in gamedata['tutorial'][player.tutorial_state]) {
                    //force_scroll(null, gamedata['tutorial'][player.tutorial_state]['force_scroll_after_session_change'], player.tutorial_state);
                    view_pos = ortho_to_playfield_vector(vec_sub(gamedata['tutorial'][player.tutorial_state]['force_scroll_after_session_change'], vec_scale(0.5,ncells)));
                } else {
                    view_pos = [-335,233];
                }
            } else {
                // find the townhall and center the player's view on it
                var townhall = find_object_by_type(gamedata['townhall']);
                if (townhall) {
                    view_pos = ortho_to_playfield_vector(vec_sub([townhall.x, townhall.y], vec_scale(0.5,ncells)));
                } else {
                    // if the townhall isn't found, the default centered view works fine
                }
            }
        }

        update_resources(data[6], true);
        update_enemy_resources(data[7]);
        enemy.instance_expiration_time = data[8];
        enemy.stattab = {'player':{},'units':{},'buildings':{},'INIT':'enemy'};
        enemy.player_auras = [];

        if(session.home_base && player.get_any_abtest_value('enable_citizens', gamedata['client']['enable_citizens'])) {
            session.citizens = new Citizens.Context(session.viewing_base, astar_context);
            session.lazy_update_citizens();
        }

        init_desktop_dialogs();
        set_view_zoom(get_preference_setting(player.preferences, 'playfield_zoom'));
        set_view_limits();

        // note: do not recall the persisted setting, but remember it for metrics?
        //if('playfield_speed' in player.preferences) { delete player.preferences['playfield_speed']; }
        update_player_combat_time_scale(get_preference_setting(player.preferences, 'playfield_speed'));

        if(client_state != client_states.RUNNING) {
            // very first session initiated
            client_state = client_states.RUNNING;

            //console.log('RUNNING');
            on_resize_game();

            if(player.tutorial_state === "COMPLETE" && player.logged_in_times === 3 && player.country === "ph") {
                // maximize chat frame
                if(global_chat_frame && global_chat_frame.is_visible()) {
                    chat_frame_size(global_chat_frame, true, true);
                }
            }

            if(get_query_string('fb_ref') && get_query_string('fb_ref').indexOf('fishing_') == 0) {
                notification_queue.push_with_priority(function() { invoke_fishing_dialog(); }, -4);
            }
        }

        if(session.home_base && session.last_map_dialog_state) {
            var state = session.last_map_dialog_state;
            session.last_map_dialog_state = null;
            // ideally this should just call directly, as pop-ups should appear as children instead of clearing UI
            // but we need to check whether invoke_defense_end, invoke_ai_attack_finish, and invoke_battle_end_dialog are safe without clears
            notification_queue.push_with_priority((function(_state) { return function() {
                var dialog = invoke_region_map();
                if(dialog) { dialog.widgets['map'].set_state(_state); }
            }; })(state), -3);
        }

        // hack to short-cut tutorial for testing purposes
        //battle_ended = true; battle_type = 'away'; battle_loot={}; player.tutorial_state = 'wait_battle_finish2';

        var defense_end_queued = false;

        if(battle_ended) {
            for(var res in battle_loot) { if(battle_loot[res]) { player.flash_res_time[res] = client_time; } }

            if(battle_type === 'home') {
                if(player.tutorial_state != "COMPLETE") {
                    invoke_ai_attack_finish_dialog(battle_loot);
                } else {
                    var cb = (function (_type, _base, _uid, _fbid, _level, _fr, _name, out, loot, dmg, ladder_state) { return function() {
                        invoke_defense_end_dialog(_type, _base, _uid, _fbid, _level, _fr, _name, out, loot, dmg, ladder_state);
                    }; })(battle_type, battle_base,
                          null, // battle_opponent_user_id,
                          null, // battle_opponent_fbid,
                          -1, // battle_opponent_level,
                          null, // battle_opponent_friend,
                          battle_opponent_name,
                          battle_outcome, battle_loot, battle_summary, battle_ladder_state);
                    notification_queue.push(cb);
                    //invoke_defense_end_dialog(battle_outcome, battle_loot);
                    defense_end_queued = true;
                }
            } else {
                if(battle_outcome != 'none') {
                    if(player.tutorial_state != "COMPLETE") {
                        // do not use notification queue, it tends to break the tutorial
                        invoke_battle_end_dialog(battle_type, battle_base,
                                                 battle_opponent_user_id,
                                                 battle_opponent_fbid,
                                                 battle_opponent_level,
                                                 battle_opponent_friend,
                                                 battle_opponent_name,
                                                 battle_outcome, battle_loot, battle_summary, battle_ladder_state);
                    } else {
                        var cb = (function (_type, _base, _uid, _fbid, _level, _fr, _name, out, loot, dmg, ladder_state) { return function() {
                            invoke_battle_end_dialog(_type, _base, _uid, _fbid, _level, _fr, _name, out, loot, dmg, ladder_state);
                        }; })(battle_type, battle_base,
                              battle_opponent_user_id,
                              battle_opponent_fbid,
                              battle_opponent_level,
                              battle_opponent_friend,
                              battle_opponent_name,
                              battle_outcome, battle_loot, battle_summary, battle_ladder_state);
                        notification_queue.push(cb);
                    }
                }
            }
        }

        if(player.tutorial_state != "COMPLETE") {
            tutorial_step(false);
        }

        change_backdrop_music(GameArt.assets['background_music'].states[(session.home_base ? 'normal' : 'recon')].audio);

        if(player.can_level_up()) {
            notification_queue.push_with_priority(invoke_level_up_dialog, -1);
        }

        // show repair dialog if something was damaged and we didn't get a "you were attacked"
        if(player.tutorial_state === "COMPLETE" && session.home_base && !defense_end_queued) {
            notification_queue.push_with_priority(invoke_repair_dialog_conditional, -2);
        } else if(session.is_quarry() && session.viewing_user_id == session.user_id) {
            notification_queue.push_with_priority(invoke_repair_dialog_conditional, -2);
        }

        var tip_shown = false;

        if(!tip_shown && session.viewing_base.base_climate && session.viewing_base.base_climate != 'normal') {
            var tip_name = session.viewing_base.base_climate_data['show_tip'];
            if(tip_name && (tip_name in gamedata['strings'])) {
                tip_shown = invoke_ingame_tip(tip_name);
            }
        }

        if(!tip_shown &&
           session.viewing_base.base_landlord_id != session.user_id &&
           session.viewing_ai &&
           player.get_any_abtest_value('enable_enemy_unit_tips', gamedata['client']['enable_enemy_unit_tips'])) {
            var tips = {};
            for(var id in session.cur_objects.objects) {
                var obj = session.cur_objects.objects[id];
                if(obj.team !== 'player') {
                    var tip = 'enemy_unit_'+obj.spec['name'];
                    if(tip in gamedata['strings']) {
                        tips[tip] = 1;
                    }
                }
            }
            for(var name in tips) {
                // as soon as any tip is shown, stop.
                if(invoke_ingame_tip(name)) {
                    tip_shown = true;
                    break;
                }
            }
        }

    } else if(msg == "END_SERVER_HELLO") {
        session.server_hello_ended = true;

        player.quest_tracked = null; player.quest_tracked_dirty = true;
        player.update_quest_cache(true);

        if(player.tutorial_state == "COMPLETE" && !player.preferences['skip_tutorial']) {
            var pred = player.get_any_abtest_value('popup_notification_on_login_if', gamedata['client']['popup_notification_on_login_if']);
            if(pred && read_predicate(pred).is_satisfied(player, null)) {
                notification_queue.push_with_priority(function() { invoke_missions_dialog(true); }, -5);
            } else if(0 && player.has_unread_mail()) {
                notification_queue.push_with_priority(function() { invoke_mail_dialog(true); }, -5);
            }
        }

        longpoll_send();

        // URL parameter processing

        // benchmark mode
        if(!spin_secure_mode) {
            var benchmark = get_query_string('benchmark');
            if(benchmark) {
                var context = JSON.parse(decodeURIComponent(benchmark));
                read_consequent({'consequent':'LIBRARY', 'name':'benchmark'}).execute(context);
            }
        }

        // allow developers to link directly to someone's base
        var immediate_visit = get_query_string('visit_base');
        if(player.is_developer() && immediate_visit) {
            visit_base(parseInt(immediate_visit,10));
        }

        // deep link to player info statistics
        if(player.tutorial_state == "COMPLETE") {
            var player_info_statistics = get_query_string('player_info_statistics');
            if(player_info_statistics) {
                var request = JSON.parse(decodeURIComponent(player_info_statistics));
                var dialog = invoke_player_info_dialog_unknown(request['user_id'], null, null, null,
                                                               (function(_request) { return function(_dialog) {
                                                                   invoke_statistics_tab(_dialog, _request['preselect'] || null);
                                                               }; })(request));
            }
        }

        SPLWMetrics.send_event(spin_metrics_anon_id, '0120_client_ingame', add_demographics({'splash_image':spin_loading_screen_name}));

    } else if(msg == "OBJECT_REMOVED" || msg == "OBJECT_REMOVED2") {
        var id = data[1];
        if(!(id in session.cur_objects.objects)) {
            console.log('race condition in OBJECT_REMOVED, ignoring');
            return;
        }
        var obj = session.cur_objects.objects[id];
        remove_object(obj);
        if(msg == "OBJECT_REMOVED") {
            update_resources(data[2], false);
        }
    } else if(msg == "OBJECT_CREATED" || msg == "OBJECT_CREATED2") {
        var state = data[1];
        var obj = create_object(state, true);
        session.add_object(obj);
        if(msg == "OBJECT_CREATED") {
            // OBJECT_CREATED2 does not include player state
            update_resources(data[2], false);
        }
        player.invalidate_quest_cache();
        player.quest_tracked_dirty = true;
    } else if(msg == "OBJECT_STATE_UPDATE" || msg == "OBJECT_STATE_UPDATE2") {
        var state = data[1];
        var id = state[0];
        if(!(id in session.cur_objects.objects)) {
            console.log('race condition in OBJECT_STATE_UPDATE, ignoring');
            return;
        }
        var obj = session.cur_objects.objects[id];
        obj.receive_state(state, false, false);

        if(msg == "OBJECT_STATE_UPDATE") {
                // OBJECT_STATE_UPDATE2 does not include player state
                update_resources(data[2], false);
        }

        if(obj.ping_sent) {
            obj.ping_sent = false;
        }
        player.invalidate_quest_cache();
        player.quest_tracked_dirty = true;
    } else if(msg == "OBJECT_AURAS_UPDATE") {
        var state = data[1];
        var id = state[0];
        if(!(id in session.cur_objects.objects)) {
            console.log('race condition in OBJECT_AURAS_UPDATE, ignoring');
            return;
        }
        var obj = session.cur_objects.objects[id];
        obj.receive_auras_update(state[1]);
    } else if(msg == "PLAYER_STATE_UPDATE") {
        update_resources(data[1], false);
        if(player.can_level_up()) {
            notification_queue.push_with_priority(invoke_level_up_dialog, -1);
        }
    } else if(msg == "ENEMY_STATE_UPDATE") {
        update_enemy_resources(data[1]);
    } else if(msg == "ENEMY_TECH_UPDATE") {
        enemy.tech = data[1];
    } else if(msg == "TECH_UPDATE") {
        player.tech = data[1];
        player.invalidate_quest_cache();
        player.claim_achievements();
    } else if(msg == "PLAYER_AURAS_UPDATE") {
        player.player_auras = data[1];

        // clear popups, if any
        if(session.home_base) {
            var dialog = desktop_dialogs['desktop_top'];
            if(dialog && dialog.user_data && dialog.user_data['aura_context']) {
                invoke_aura_context(dialog, null, -1, null, false);
            }
        }
    } else if(msg == "ENEMY_AURAS_UPDATE") {
        enemy.player_auras = data[1];
    } else if(msg == "PLAYER_STATTAB_UPDATE") {
        var old_combat_time_scale = combat_time_scale(); // remember old combat_time_scale, since stattab update can change it

        player.stattab = data[1];
        Building.update_modstats('player', player.stattab['buildings']);

        // check for any change to combat_time_scale
        var new_combat_time_scale = combat_time_scale();
        if(new_combat_time_scale != old_combat_time_scale) {
            // adjust in-progress time-dependent effects here
            if(session.incoming_attack_wave_time > server_time) {
                var delta = session.incoming_attack_wave_time - server_time;
                delta *= old_combat_time_scale / new_combat_time_scale;
                session.incoming_attack_wave_time = server_time + Math.floor(delta);
            }
        }
    } else if(msg == "ENEMY_STATTAB_UPDATE") {
        enemy.stattab = data[1];
        Building.update_modstats('enemy', enemy.stattab['buildings']);
    } else if(msg == "PLAYER_UNIT_EQUIP_UPDATE") {
        player.unit_equipment = data[1];
    } else if(msg == "ENEMY_UNIT_EQUIP_UPDATE") {
        enemy.unit_equipment = data[1];
    } else if(msg == "NEW_TECH") {
        var newly_researched = data[1];
        var new_level = data[2];
        var lab_id = data[3];

        // trigger congrats message, if applicable
        var cb = (function (n) { return function() { invoke_tech_upgrade_congrats(n); }; })(newly_researched);
        notification_queue.push(cb);

        // update research dialog
        if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'research_dialog') {
            research_dialog_change_category(selection.ui, selection.ui.user_data['category'], selection.ui.user_data['page']);
        }

        // fire M&M
        if(lab_id in session.cur_objects.objects) {
            var lab = session.cur_objects.objects[lab_id];
            if(!player.is_cheater) {
                // trigger visual effect
                var fx_data = gamedata['client']['vfx']['tech_research_finish'];
                var tech = gamedata['tech'][newly_researched];
                var unit = tech['associated_unit'] || tech['affects_unit'] || null;
                var asset = (unit ? get_leveled_quantity(gamedata['units'][unit]['art_asset'], Math.max(1,player.tech[unit['level_determined_by_tech']])) : lab.get_leveled_quantity(lab.spec['art_asset']));
                var instance_data = { '%OBJECT_SPRITE': asset };
                SPFX.add_visual_effect([lab.x,lab.y], 0, [0,1,0], client_time, fx_data,
                                       true,
                                       instance_data);
                // hold notification until animation finishes
                notification_queue.hold_until(client_time + 2.9);
            }
        }

        session.clear_building_idle_state_caches(); // for ALL buildings

    } else if(msg == "BASE_POWER_UPDATE") {
        session.viewing_base.update_power_state(data[1]);
    } else if(msg == "RES_LOOTER_UPDATE") {
        session.res_looter = data[1];
    } else if(msg == "BASE_SIZE_UPDATE") {
        session.viewing_base.base_size = data[1];
    } else if(msg == "PLAYER_TRAVEL_UPDATE") {
        player.travel_state = data[1];
    } else if(msg == "PLAYER_HISTORY_UPDATE") {
        player.history = data[1];
        player.invalidate_quest_cache();
        player.quest_tracked_dirty = true;
        player.claim_achievements();
    } else if(msg == "COOLDOWNS_UPDATE") {
        player.cooldowns = data[1];
    } else if(msg == "TUTORIAL_STATE_UPDATE") {
        player.tutorial_state = data[1];
    } else if(msg == "MAIL_UPDATE") {
        var msg_id = data[1];
        if(msg_id) {
            for(var i = 0; i < player.mailbox.length; i++) {
                var mail = player.mailbox[i];
                if(mail['msg_id'] === msg_id) {
                    player.mailbox[i] = data[2];
                    break;
                }
            }
        } else {
            // full replacement
            player.mailbox = data[2];
            if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] === 'mail_dialog') {
                update_mail_dialog(selection.ui);
            }
        }
        player.invalidate_quest_cache();
    } else if(msg == "MAIL_TAKE_ATTACHMENTS_RESULT") {
        var msg_id = data[1], slot = data[2], success = data[3], fungible = data[4], newmail = data[5];
        for(var i = 0; i < player.mailbox.length; i++) {
            var mail = player.mailbox[i];
            if(mail['msg_id'] === msg_id) {
                if('pending' in mail) { delete mail['pending']; }
                if(newmail) {
                    player.mailbox[i] = newmail;
                }
            }
        }
        if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] === 'mail_dialog') {
            if(success) {
                selection.ui.widgets['glow'].show = true;
                selection.ui.widgets['glow'].reset_fx();
                // make little rising text
                var framenum = slot - (selection.ui.user_data['attach_page']*selection.ui.data['widgets']['attach_frame']['array'][0]);
                var ui_msg = gamedata['strings']['combat_messages'][(fungible ? "collected" : "added_to_warehouse")];
                ItemDisplay.add_inventory_item_effect(selection.ui.widgets['attach_frame'+framenum.toString()], ui_msg, [1,1,0.3,1]);
            }
            var old_page = selection.ui.user_data['attach_page'];
            // reset state of mail dialog
            mail_dialog_scroll(selection.ui, selection.ui.user_data['first_row']);
            mail_dialog_select_mail(selection.ui, selection.ui.user_data['selected_row']);
            mail_dialog_attach_scroll(selection.ui, old_page);
        }
        player.quest_tracked_dirty = true;
    } else if(msg == "DONATED_UNITS_UPDATE") {
        player.donated_units = data[1];
    } else if(msg == "DONATED_UNITS_RECEIVED") {
        var unit_list = data[1];
        var from_id = data[2], from_fbid = data[3], from_name = data[4];
        var display_string = units_description(unit_list, ', ');
        user_log.msg(gamedata['strings']['you_got_reinforcements'].replace('%sender',from_name).replace('%units', display_string), new SPUI.Color(1,0,1,1));
    } else if(msg == "INVENTORY_UPDATE") {
        player.max_inventory = data[1];
        player.inventory = data[2];
        player.reserved_inventory = data[3];
    } else if(msg == "LOOT_BUFFER_UPDATE") {
        player.loot_buffer = data[1];
        var immediate = data[2] && selection.ui && selection.ui.user_data && goog.array.contains(['inventory_dialog','crafting_dialog'], selection.ui.user_data['dialog']);
        if(player.loot_buffer.length > 0 && session.home_base) {
            if(immediate) {
                invoke_loot_dialog();
            } else {
                var prio = -10;
                // boost priority so that it shows first when coming in on a promo code
                if(!session.server_hello_ended && get_query_string('spin_promo_code')) {
                    prio = 10;
                }
                notification_queue.push_with_priority(invoke_loot_dialog, prio);
            }
        }
        refresh_loot_dialog();
        player.claim_achievements();
    } else if(msg == "INVENTORY_USE_RESULT" || msg == "INVENTORY_TRASH_RESULT" || msg == "INVENTORY_REFUND_RESULT") {
        var index = data[1], specname = data[2], success = data[3], count = data[4];
        var spec = ItemDisplay.get_inventory_item_spec(specname);

        if(index < player.inventory.length && player.inventory[index]['spec'] == specname) {
            var item = player.inventory[index];
            if('pending' in item) {
                delete item['pending'];
                if('pending_action' in item) {
                    delete item['pending_action'];
                }
            }
        }

        if(success && msg == "INVENTORY_USE_RESULT") {
            var extra_spellargs = data[5];

            if('use_effect' in spec) {
                // check for null separately from checking if the effect exists so we can use a null effect
                // in the item spec to disable the game-wide effect
                if(spec['use_effect']) {
                    SPFX.add_visual_effect([0,0], 0, [0,1,0], client_time, spec['use_effect'], true, null);
                }
            } else if(gamedata['client']['vfx']['item_use']) {
                SPFX.add_visual_effect([0,0], 0, [0,1,0], client_time, gamedata['client']['vfx']['item_use'], true, null);
            }

            if('use' in spec) {
                var uselist = get_as_array(spec['use']);
                for(var m = 0; m < uselist.length; m++) {
                    var use = uselist[m];
                    if('spellname' in use) {
                        var spell = gamedata['spells'][use['spellname']];
                        if(('code' in spell) && (spell['code'] == 'projectile_attack')) {
                            var target_loc = extra_spellargs[0], target_height = 0;
                            var launch_loc = vec_add(target_loc, [-20, 20]);
                            var launch_height = (('ground_plane' in session.viewing_base.base_climate_data && session.viewing_base.base_climate_data['ground_plane'] < 0) ? -100 : 100);


                            // check for anti-missile defenses
                            var interceptor = null;
                            for(var id in session.cur_objects.objects) {
                                var obj = session.cur_objects.objects[id];
                                if(obj.is_building() && !obj.is_destroyed() && !obj.disarmed && !obj.combat_stats.stunned && (obj.team !== 'player') &&
                                   obj.equipment && obj.is_shooter()) {
                                    var chance = 1 - obj.combat_stats.anti_missile;
                                    if(chance > 0) {
                                        // check range
                                        var range = obj.weapon_range()[1];
                                        var dist = vec_distance(obj.interpolate_pos(), target_loc);
                                        if(range > 0 && dist < range) {
                                            // chance of interception
                                            if(Math.random() < chance) {
                                                interceptor = obj;
                                                target_height = (launch_height > 0 ? 10 : -4);
                                                break;
                                            }
                                        }
                                    }
                                }
                                if(interceptor) { break; }
                            }

                            // missile effect
                            var hit_time = do_fire_projectile(player.virtual_units["PLAYER"], '0', 'PLAYER', 1, 'player', null, launch_loc, launch_height, launch_loc, client_time, -1, spell, null, target_loc, target_height, (interceptor!=null));

                            if(interceptor) {
                                // intecepting shot effect
                                // hack - don't bother computing the actual fire time
                                interceptor.fire_projectile(hit_time-0.25, hit_time, interceptor.get_auto_spell(), interceptor.get_auto_spell_level(), null, target_loc, target_height);
                            }
                        }
                    }
                }
            }
        }

        // update Warehouse UI
        if(selection.ui && selection.ui.user_data &&
           (selection.ui.user_data['dialog'] === 'inventory_dialog' || selection.ui.user_data['dialog'] === 'loot_dialog')) {
            var dialog = selection.ui;
            if(dialog.user_data['context'] && dialog.user_data['context'].user_data['slot'] === index) {
                // clear context menu
                invoke_inventory_context(dialog, null, -1, null, false);
            }
            if(success) {
                var cols = selection.ui.data['widgets']['slot']['array'][0];
                var x = (index % cols), y = Math.floor(index / cols);
                var str = (count > 1 ? ItemDisplay.get_inventory_item_stack_prefix(spec, count) : '') + ItemDisplay.get_inventory_item_ui_name(spec);
                var color = [0.6,0.6,0.6,1];
                if(msg == "INVENTORY_TRASH_RESULT") {
                    str += ' '+gamedata['strings']['combat_messages']['discarded'];
                } else if(msg == "INVENTORY_REFUND_RESULT") {
                    str += ' '+gamedata['strings']['combat_messages']['refunded'];
                } else if(msg == "INVENTORY_USE_RESULT") {
                    selection.ui.widgets['glow'].show = true;
                    selection.ui.widgets['glow'].reset_fx();
                    str += ' '+gamedata['strings']['combat_messages']['activated'];
                    color = [1,1,0.3,1];
                }
                ItemDisplay.add_inventory_item_effect(selection.ui.widgets['slot'+x.toString()+','+y.toString()], str, color);
            }
        }
    } else if(msg == "EQUIP_BUILDING_RESULT") {
        var my_arg = data[1], success = data[2];
        var unit_id = my_arg[1], addr = my_arg[2], inv_slot = my_arg[3], add_specname = my_arg[4], remove_specname = my_arg[5], ui_slot = my_arg[6];

        if(unit_id in session.cur_objects.objects) {
            var unit = session.cur_objects.objects[unit_id];
            unit.equip_pending = false;

            // add feedback to Upgrade dialog
            if(success && selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'upgrade_dialog' && selection.ui.user_data['unit'] == unit) {
                var dialog = selection.ui;
                var str, color;
                var ui_name = ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(add_specname || remove_specname));
                if(!add_specname) {
                    var what_happened;
                    if(remove_specname && (remove_specname in gamedata['items']) && (gamedata['items'][remove_specname]['remove_fragility'] || 0) >= 1) {
                        what_happened = 'discarded';
                    } else {
                        what_happened = 'returned_to_warehouse';
                    }
                    str = ui_name + " "+ gamedata['strings']['combat_messages'][what_happened]; color = [0.6,0.6,0.6,1];
                } else {
                    str = ui_name + " "+ gamedata['strings']['combat_messages']['equipped']; color = [1,1,0.3,1];
                    dialog.widgets['equip_glow'+ui_slot].show = true;
                    dialog.widgets['equip_glow'+ui_slot].reset_fx();
                }
                ItemDisplay.add_inventory_item_effect(dialog.widgets['equip_frame'+ui_slot], str, color);
                player.claim_achievements();
            }
        }

    } else if(msg == "EQUIP_UNIT_RESULT") {
        var my_arg = data[1], success = data[2];
        var dest_spec_name = my_arg[1], addr = my_arg[2], inv_slot = my_arg[3], add_specname = my_arg[4], remove_specname = my_arg[5], ui_slot = my_arg[6];
        // add feedback to Upgrade dialog
        var dialog = find_dialog('upgrade_dialog');
        if(dialog && dialog.user_data['tech'] && dialog.user_data['tech']['associated_unit'] == dest_spec_name) {
            var str, color;
            var ui_name = ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(add_specname || remove_specname));
            if(!add_specname) {
                str = ui_name + " "+gamedata['strings']['combat_messages']['returned_to_warehouse']; color = [0.6,0.6,0.6,1];
            } else {
                str = ui_name + " "+ gamedata['strings']['combat_messages']['equipped']; color = [1,1,0.3,1];
                dialog.widgets['equip_glow'+ui_slot].show = true;
                dialog.widgets['equip_glow'+ui_slot].reset_fx();
            }
            ItemDisplay.add_inventory_item_effect(dialog.widgets['equip_frame'+ui_slot], str, color);
            player.claim_achievements();
        }

    } else if(msg == "ITEM_DISCOVERED") {
        var items = data[1], duration = data[2];
        invoke_item_discovered(items, duration);
    } else if(msg == "YOU_GOT_BONUS_UNITS") {
        notification_queue.push(invoke_you_got_bonus_units);
    } else if(msg == "YOU_SENT_GIFT_ORDER") {
        var gift_order = data[1];
        var func = (function (_gift_order) { return function() { invoke_you_sent_gift_order_dialog(_gift_order); }; })(gift_order);
        notification_queue.push(func);
    } else if(msg == "ITEM_PURCHASED") {

        // awkward - delay so that the following LOOT_BUFFER_UPDATE takes effect
        window.setTimeout(function() { invoke_loot_dialog(gamedata['strings']['combat_messages']['item_purchased']); }, 1);

    } else if(msg == "QUEST_STATE_UPDATE") {
        // completely replace quest state with the server's version
        player.completed_quests = data[1];
        player.invalidate_quest_cache();
    } else if(msg == "ACHIEVEMENTS_UPDATE") {
        player.achievements = data[1];

        // primitive check for new achievements
        if(1) {
            player.claim_achievements();
        }

    } else if(msg == "ACHIEVEMENT_CLAIMED") {
        var name = data[1], props = data[2];
        player.achievements[name] = props;
        var spec = gamedata['achievements'][name];
        if(player.get_any_abtest_value('enable_ingame_achievements', gamedata['client']['enable_ingame_achievements'])) {
            notification_queue.achievements.push(spec);
            notification_queue.push(notify_achievements);
        }
    } else if(msg == "FB_APP_EVENT") {
        var name = data[1], value = data[2], params = data[3];
        SPFB.AppEvents.logEvent(name, value, params);
    } else if(msg == "COMPLETED_QUEST") {
        var name = data[1];
        var qdata = data[2];
        var quest = gamedata['quests'][name];

        if(player.quest_tracked === quest) { player.quest_tracked = null; player.quest_tracked_dirty = true; }

        player.completed_quests[name] = qdata;
        player.invalidate_quest_cache();
        player.update_quest_cache();

        var missions_dialog = find_dialog('missions_dialog');

        var cb = (function (_quest) { return function() {
            var _missions_dialog = find_dialog('missions_dialog');
            if(_missions_dialog) {
                _missions_dialog.user_data['just_completed_row'] = _missions_dialog.user_data['quest_list'].indexOf(quest);
                _missions_dialog.user_data['selected_row'] = -1;
                update_missions_dialog(_missions_dialog);
            }

            if('completion' in _quest) {
                execute_logic(_quest['completion']);
            }
            if(player.can_level_up()) {
                notification_queue.push_with_priority(invoke_level_up_dialog, -1);
            }
        }; })(quest);

        // note: wait for missions dialog animation to finish before running other steps
        var fx_time = missions_dialog ? missions_dialog.widgets['glow'].fx_time_remaining() : -1;
        if(fx_time > 0) {
            window.setTimeout(cb, 1000.0*fx_time);
        } else {
            cb();
        }

    } else if(msg == "GIFT_PROMPT") {
        if(player.resource_gifts_enabled() && read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null)) {
            notification_queue.push(invoke_gift_prompt_dialog);
        }
    } else if(msg == "INVITE_FRIENDS_PROMPT") {
        if(read_predicate({'predicate':'LIBRARY', 'name': 'extended_tutorial_complete'}).is_satisfied(player,null)) {
            notification_queue.push(invoke_invite_friends_prompt);
        }
    } else if(msg == "YOU_WERE_ATTACKED") {
        var recent_attacks = data[1];
        var cb = (function (ra) { return function() { invoke_you_were_attacked_dialog(ra); }; })(recent_attacks);
        // remove any pending invoke_repair_dialog_conditionals, because we override that with our own repair buttons
        notification_queue.remove(invoke_repair_dialog_conditional);
        notification_queue.push(cb);
    } else if(msg == "SHOW_BATTLE_HISTORY") {
        notification_queue.push(function() { invoke_battle_history_dialog(session.user_id, -1, '', -1); });
    } else if(msg == "DISPLAY_MOTD") {
        var motd = data[1];
        var cb = (function (m) { return function() { invoke_motd_dialog(m); }; })(motd);
        notification_queue.push(cb);
    } else if(msg == "DISPLAY_DAILY_TIP") {
        notification_queue.push((function (tipname) { return function() { invoke_daily_tip(tipname); } })(data[1]));
    } else if(msg == "DISPLAY_DAILY_TIP_PAGES") {
        notification_queue.push_with_priority((function (tiplist) { return function() { invoke_daily_tip_pages(tiplist); } })(data[1]), -6);

    // unfortunately, these two code paths are kind of redundant and confusing
    // DISPLAY_MESSAGE is used in AI base "completion" predicates to show the victory M&M
    // MESSAGE_BOX is used for tutorial instruction dialogs
    } else if(msg == "DISPLAY_MESSAGE") {
        var msgdat = data[1];
        var cons = new DisplayMessageConsequent(msgdat);
        cons.execute();
    } else if(msg == "MESSAGE_BOX") {
        var msgdat = data[1];
        notification_queue.push((function (_msgdata) { return function() {
            read_consequent(_msgdata).execute();
        }; })(msgdat));

    } else if(msg == "CLIENT_CONSEQUENT") {
        read_consequent(data[1]).execute();

    } else if(msg == "FLASH_OFFER") {
        var msgdat = data[1];
        var cb = (function (dat) { return function() { invoke_flash_offer(dat); }; })(msgdat);
        notification_queue.push(cb);

    } else if(msg == "SYSTEM_REFUND") {
        var loot = data[1];
        var ui_reason = data[2];
        notification_queue.push((function(_loot, _ui_reason) { return function() {
            invoke_message_dialog(gamedata['strings']['system_refund']['ui_title'],
                                  ui_reason,
                                  {'dialog': 'message_dialog_big'});
        }; })(loot, ui_reason));
    } else if(msg == "RECEIVED_GIFT") {
        var sender_fb_id = data[1];
        var sender_user_id = data[2];
        var sender_ui_name = data[3];
        var res = data[4];

        var do_notify = (function(fb_id, user_id, name, loot) { return function() {
            invoke_gift_received_dialog(fb_id, user_id, name, loot);
        };})(sender_fb_id, sender_user_id, sender_ui_name, res);

        if(player.resource_gifts_enabled()) { // note: do not show dialog if gifting is turned off
            notification_queue.push(do_notify);
        }

    } else if(msg == "SESSION_LOOT_UPDATE") {
        session.last_loot = session.loot;
        session.loot = data[1];
    } else if(msg == "LOOTED_RESOURCES" || msg == "HARVESTED_RESOURCES") {
        var res = data[1];
        var obj_id = data[2];
        var pos = data[3];
        var base_type = data[4] || null;
        var base_ui_name = data[5] || null;

        var anything_to_show = false;
        if(res['gamebucks'] || res['cooldown']) { anything_to_show = true; }
        for(var resname in gamedata['resources']) {
            if(res[resname]) { anything_to_show = true; break; }
        }
        if(!anything_to_show) { return; }

        var prefix;

        if(base_type == 'quarry') {
            if(base_ui_name) {
                prefix = gamedata['strings']['regional_map']['quarry'].replace('%s',base_ui_name)+': ';
            } else {
                prefix = gamedata['strings']['regional_map']['all_quarries']+': ';
            }
            if(!res['cooldown']) { seen_quarry_harvest = true; }
            if(session.home_base) {
                // use the central computer to show quarry activity
                var cc = player.get_townhall();
                pos = [cc.x, cc.y];
                obj_id = cc.id;

                // invalidate point count
                if(!res['cooldown']) {
                    var event = player.current_stat_tournament_event();
                    if(event && goog.array.contains(['strongpoint_resources', 'quarry_resources'], event['stat']['name'])) {
                        var dialog = desktop_dialogs['desktop_bottom'];
                        if('point_count' in dialog.widgets['map_event_info'].user_data) {
                            delete dialog.widgets['map_event_info'].user_data['point_count'];
                        }
                    }
                }
            }
        } else {
            prefix = '';
        }

        var text = [];

        if(res['cooldown'] > 0) {
            text.push({'color': gamedata['client']['loot_text_color']['cooldown'],
                       'str': prefix+ gamedata['strings']['combat_messages']['ready_in'].replace('%s',pretty_print_time_brief(res['cooldown']-server_time))});
        } else {
            var sign;
            if(msg == "LOOTED_RESOURCES" && session.home_base) {
                // taken by AI
                sign = '-';
            } else {
                sign = '+';
            }

            for(var resname in gamedata['resources']) {
                if((res[resname]||0) > 0) {
                    var bonus_str = ((resname+'_bonus') in res ? ' '+gamedata['strings']['combat_messages']['resource_bonus'].replace('%d', pretty_print_number(res[resname+'_bonus'])) : '');
                    text.push({'color':gamedata['resources'][resname]['loot_text_color'],
                               'size': ((msg == "LOOTED_RESOURCES" && 'loot_text_size' in gamedata['resources'][resname]) ? gamedata['resources'][resname]['loot_text_size'] : null),
                               'rise_time': ((msg == "LOOTED_RESOURCES" && 'loot_text_rise_time' in gamedata['resources'][resname]) ? gamedata['resources'][resname]['loot_text_rise_time'] : null),
                               'str': prefix + sign + pretty_print_number(res[resname]) + ' '+gamedata['resources'][resname]['ui_name'] + bonus_str});
                    if(msg == "LOOTED_RESOURCES" &&
                       gamedata['resources'][resname]['loot_effect'] &&
                       pos && pos[0] >= 0 && pos[1] >= 0) {
                        var props = goog.object.clone(gamedata['resources'][resname]['loot_effect']);
                        //props['emit_instant'] = props['max_count'] = (res[resname] >= props['res_big'] ? props['count_big'] : (res[resname] >= props['res_med'] ? props['count_med'] : props['count_small']));
                        SPFX.add_visual_effect(pos, 0, [0,1,0], client_time, props, true);
                    }
                }
            }

            if(res['gamebucks'] > 0) {
                text.push({'color':gamedata['client']['loot_text_color']['gamebucks'],
                           'str': prefix + sign + Store.display_user_currency_amount(res['gamebucks'],'full')});
            }
        }

        if(pos && pos[0] >= 0 && pos[1] >= 0) {
            // prevent overlap
            var text_delay = 0;
            if(msg != "LOOTED_RESOURCES") {
                if(client_time - last_loot_text_time < 1.0) {
                    if(last_loot_text_pos && last_loot_text_pos[0] == pos[0] && last_loot_text_pos[1] == pos[1]) {
                        last_loot_text_count += 1;
                    }
                } else {
                    last_loot_text_count = 0;
                }
                text_delay = 0.5 * last_loot_text_count;
            }

            var default_rise_time = ((base_type == 'quarry') ? 5.0 : 3.0);
            var text_props = { drop_shadow: true, text_style: 'thick' };
            var center = (text.length > 1 ? 0.5 : 0);
            for(var i = 0; i < text.length; i++) {
                text_props.font_size = (text[i]['size'] || 20);
                var left_right_offset = 7 * (text_props.font_size/20);
                var rise_time = (text[i]['rise_time'] || default_rise_time);
                SPFX.add(new SPFX.CombatText([pos[0]-4 + (i-center)*left_right_offset,pos[1]-4 - (i-center)*left_right_offset], 0,
                                             text[i]['str'], text[i]['color'],
                                             client_time + text_delay, client_time + rise_time + text_delay,
                                             text_props));
            }
        } else {
            last_loot_text_count = 0;
        }

        var flash_delay, ticker_delay;
        var need_glow_effect = false;

        if(msg == "HARVESTED_RESOURCES") {
            // peaceful harvesting
            var has_sound = false;
            for(var resname in gamedata['resources']) {
                if((res[resname]||0) > 0) {
                    if(gamedata['resources'][resname]['harvest_effect']) {
                        SPFX.add_visual_effect(pos, 0, [0,1,0], client_time, gamedata['resources'][resname]['harvest_effect'], !has_sound);
                        has_sound = true;
                    } else {
                        need_glow_effect = true;
                    }
                }
            }
            if(!has_sound && client_time - last_loot_text_time > 1.0) { // play a default sound effect
                GameArt.assets['harvest_sound'].states['normal'].audio.play(client_time);
            }
            flash_delay = gamedata['client']['harvest_flash_delay'];
            ticker_delay = gamedata['client']['harvest_flash_delay'] + gamedata['client']['resource_ticker_delay'];
        } else {
            // combat loot
            if(gamedata['gradual_loot'] > 0) {
                flash_delay = ticker_delay = 0;
            } else {
                var loot_flash_delay = player.get_any_abtest_value('loot_flash_delay', gamedata['client']['loot_flash_delay']);
                flash_delay = loot_flash_delay;
                ticker_delay = loot_flash_delay + gamedata['client']['resource_ticker_delay'];
            }
            // note: FORCE the previous flash to conclude so that we
            // can restart it with a delay
            player.last_resource_time = -1;
            for(var resname in gamedata['resources']) {
                player.last_resource_state[resname] = player.resource_state[resname][1];
                if(res[resname]) { player.flash_res_time[resname] = -1; }
            }
        }

        for(var resname in gamedata['resources']) {
            if(res[resname] && player.flash_res_time[resname] <= 0) {
                player.flash_res_time[resname] = client_time + flash_delay;
            }
        }
        if(player.last_resource_time <= 0) {
            player.last_resource_time = client_time + ticker_delay;
        }

        if(need_glow_effect) { // trigger glow effect
            if(obj_id in session.cur_objects.objects) {
                var obj = session.cur_objects.objects[obj_id];
                if(obj.is_building() && obj.is_producer()) {
                    obj.harvest_glow_time = client_time;
                }
            }
        }

        // "ding" sound for gamebucks
        if(res['gamebucks'] > 0) {
            if(gamedata['client']['vfx']['gamebucks_harvest_effect']) {
                SPFX.add_visual_effect(pos, 0, [0,1,0], client_time, gamedata['client']['vfx']['gamebucks_harvest_effect'], true);
            } else {
                GameArt.assets['minor_level_up_sound'].states['normal'].audio.play(client_time);
            }
        }

        // GUI message
        if(res['gamebucks'] > 0) {
            var s = gamedata['strings']['gamebucks_discovered_in_deposit'];
            if(s) {
                invoke_child_message_dialog(s['ui_title'].replace('%s',Store.gamebucks_ui_name()),
                                            s['ui_description'].replace('%s', Store.display_user_currency_amount(res['gamebucks'], 'full')));
            }
        } else if((obj_id in session.cur_objects.objects) &&
                  session.cur_objects.objects[obj_id].spec['name'] == 'iron_deposit') {
            // see if this was the last deposit, and if so show consolation message
            var more_deposits = false;
            for(var id in session.cur_objects.objects) {
                var obj = session.cur_objects.objects[id];
                if(id != obj_id && obj.spec['name'] == 'iron_deposit') {
                    more_deposits = true;
                    break;
                }
            }
            if(!more_deposits &&
               player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks' &&
               player.get_any_abtest_value('gamebucks_in_deposits', gamedata['gamebucks_in_deposits'])) {
                var s = gamedata['strings']['deposits_mined_out'];
                if(s) {
                    invoke_child_message_dialog(s['ui_title'], s['ui_description'].replace('%s', Store.gamebucks_ui_name()));
                }
            }
        }

        last_loot_text_time = client_time;
        last_loot_text_pos = pos;

    } else if(msg == "GAINED_XP" || msg == "GAINED_XP2") {
        var amount = data[1];
        var obj_id = data[2];
        var pos = data[3];

        if(msg == "GAINED_XP2") { // also includes new total
            var new_player_xp = data[4];
            update_resources_xp(new_player_xp);
        }

        if(/* player.get_any_abtest_value('show_xp_gains', gamedata['client']['show_xp_gains']) && */ pos[0] >= 0 && pos[1] >= 0) {
            var str = ' +' + pretty_print_number(amount) + ' XP';

            // offset pos a little bit since these almost always go with other combat text
            var off = [-2,-2];
            var font_size = 16;
            if(obj_id in session.cur_objects.objects && session.cur_objects.objects[obj_id].is_building()) {
                off = [0, -11];
                font_size = 20;
            }

            var flashy = player.flashy_loot();
            var text_props_flashy = { drop_shadow: true, font_size: font_size, text_style: 'thick' };
            var text_props_boring = { drop_shadow: false, font_size: 14, text_style: 'normal' };
            var text_props = flashy ? text_props_flashy : text_props_boring;

            SPFX.add(new SPFX.CombatText([pos[0]+off[0],pos[1]+off[1]], 0, str, [1, 0.2, 1, 1], client_time, client_time + 3.0, text_props));
        }

        GameArt.assets['xp_gain_sound'].states['normal'].audio.play(client_time);

        if(player.can_level_up()) {
            notification_queue.push_with_priority(invoke_level_up_dialog, -1);
        }
    } else if(msg == "CRAFT_COMPLETE") {
        var obj_id = data[1], loot = data[2], attempt_ids = data[3];
        var obj = session.cur_objects.objects[obj_id] || null;
        if(!obj || !obj.is_building()) { return; }
        var pos = [obj.x, obj.y];
        var off = [0, 0];
        var str, clr;

        if(attempt_ids && attempt_ids[0] && selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'fishing_dialog') {
            return; // dialog handles sight & sound
        }

        if(loot) {
            GameArt.assets['xp_gain_sound'].states['normal'].audio.play(client_time);
            clr = [1,0.5,0,1];
            var ls = [];
            for(var i = 0; i < loot.length; i++) {
                var spec = ItemDisplay.get_inventory_item_spec(loot[i]['spec']);
                var stack = loot[i]['stack'] || 1;
                ls.push(ItemDisplay.get_inventory_item_stack_prefix(spec, stack) + ItemDisplay.get_inventory_item_ui_name(spec));
            }
            str = gamedata['strings']['craft_completed'].replace('%s', ls.join(', '));
        } else {
            GameArt.assets['xp_gain_sound'].states['normal'].audio.play(client_time);
            clr = [1,0.0,0.0,1];
            str = gamedata['strings']['craft_fizzled'];
        }
        SPFX.add(new SPFX.CombatText(vec_add(pos, off), 0, str, clr, client_time, client_time + 3.0,
                                     { drop_shadow: true, font_size: 20, text_style: 'thick' }));
    } else if(msg == "ADD_FRIEND") {
        var user_id = data[1]; var unused_facebook_id = data[2]; var unused_ui_name = data[3];
        var unused_player_level = data[4], battle_data = data[5], unused_giftable = data[6], is_real_friend = data[7], unused_protection_end_time = data[8];
        var pcache_data = data[9];
        if(pcache_data) { PlayerCache.update_batch(pcache_data); }
        var friend = new Friend(user_id, battle_data['count'] || 0, battle_data['last_time'] || -1, is_real_friend, pcache_data[0]);
        player.friends.push(friend);
        if(session.home_base) {
            if(desktop_dialogs['desktop_bottom'] && desktop_dialogs['desktop_bottom'].widgets['friend_bar']) {
                scroll_friend_bar(desktop_dialogs['desktop_bottom'].widgets['friend_bar'], -1);
            }
        }
    } else if(msg == "UPDATE_FRIEND") {
        // obsolete
    } else if(msg == "REM_FRIEND") {
        var user_id = data[1];
        for(var i = 0; i < player.friends.length; i++) {
            if(player.friends[i].user_id === user_id) {
                player.friends.splice(i,1);
                i -= 1;
                //break; allow duplicates
            }
        }
    } else if(msg == "AI_ATTACK_WARNING") {
        session.incoming_attack_time = data[1];
        session.incoming_attack_units = data[2];
        session.incoming_attacker_name = data[3];
        var text_index = data[4];
        session.incoming_attack_direction = data[5];
        var warning_time = data[6];

        session.incoming_attack_units_destroyed = 0;
        session.incoming_attack_units_total = 0;

        goog.array.forEach(session.incoming_attack_units, function(wave) {
            goog.object.forEach(wave, function(val, key) {
                if(!(key in gamedata['units'])) { return; }
                if(typeof val === 'number') {
                    session.incoming_attack_units_total += val;
                } else {
                    session.incoming_attack_units_total += val['qty']||1;
                }
            });
        });

        if(warning_time > 0) {
            invoke_ai_attack_warning_dialog(gamedata['ai_attacks_client']['flavor_text'][text_index]);
        }

    } else if(msg == "AI_ATTACK_WAVE_DEPLOYED") {
        session.has_attacked = true;
        session.set_attack_finish_time(data[1]);
        session.incoming_attack_units = data[2];
        session.incoming_attack_wave_time = data[3];
        session.incoming_attack_wave_pending = false;

        if(!session.has_deployed) {
            session.has_deployed = true;
            session.deploy_time = server_time;
            APMCounter.reset();

            change_selection(null);

            if(player.tutorial_state === 'ai_attack_begin') {
                metric_event('0260_tutorial_ai_attack_start', {});
                advance_tutorial();
            }

            init_desktop_dialogs();
            init_combat_item_bar();
            init_playfield_speed_bar();

            // use "recon" music if "combat" music not available
            change_backdrop_music(GameArt.assets['background_music'].states[(GameArt.assets['background_music'].has_state('combat') ? 'combat' : 'recon')].audio);
        }
    } else if(msg == "PLAYER_ATTACK_WAVE_DEPLOYED") {
        session.has_attacked = true;
        session.set_attack_finish_time(data[1]);
        if(!session.has_deployed) {
            session.has_deployed = true;
            session.deploy_time = server_time;
            APMCounter.reset();

            init_combat_item_bar();
            if(GameArt.assets['background_music'].has_state('combat')) {
                // if no "combat" music is available, stick with "recon"
                change_backdrop_music(GameArt.assets['background_music'].states['combat'].audio);
            }
        }
    } else if(msg == "CHAT_RECV") {
        var channel_name = data[1];
        var sender_info = data[2];
        var wrapped_body = data[3];

        if(!global_chat_frame) { return; }

        var tablist = [];

        if(channel_name == 'BROADCAST') {
            // spam to all open channels
            for(var i = 0; i < global_chat_frame.data['widgets']['tabs']['array'][0]; i++) {
                tablist.push(global_chat_frame.widgets['tabs'+i]);
            }
        } else if(channel_name in global_chat_frame.user_data['channel_to_tab']) {
            tablist.push(global_chat_frame.widgets['tabs'+global_chat_frame.user_data['channel_to_tab'][channel_name]]);
        } else {
            console.log("cannot find chat tab for channel "+channel_name+"!");
            return;
        }

        if(sender_info['type'] == 'unit_donation_request_invalidation') {
            if(sender_info['user_id'] == session.user_id) { return; }

            for(var i = 0; i < tablist.length; i++) {
                var tab = tablist[i];
                // invalidate any outstanding requests on this recipient_id
                for(var t in tab.user_data['unit_donation_requests']) {
                    var req = tab.user_data['unit_donation_requests'][t];
                    if(req['recipient_id'] === sender_info['user_id']) {
                        req['cur_space'] = req['max_space'];
                        var node = req['node'];
                        if(node) {
                            var text = SPText.cstring_to_ablocks_bbcode(gamedata['strings']['unit_donation_chat']['other']['stale'].replace('%recipient',req['recipient_name']));
                            tab.widgets['output'].revise_text(node, text);
                        }
                    }
                }
            }
            return;

        } else if(sender_info['type'] == 'unit_donation_request' ||
                  sender_info['type'] == 'unit_donation') {
            if(!player.unit_donation_enabled()) { return; }

            // handle unit donation messages
            var tag = sender_info['tag'] || 0;

            for(var i = 0; i < tablist.length; i++) {
                var tab = tablist[i];

                // search for existing request, or add new one if not found
                var req, node;

                if(tag in tab.user_data['unit_donation_requests']) {
                    req = tab.user_data['unit_donation_requests'][tag];
                    node = req['node'];
                    if(sender_info['type'] == 'unit_donation' && sender_info['user_id'] == session.user_id) {
                        req['i_donated'] = true;
                        req['my_xp'] += sender_info['xp_gained'];
                    }
                } else if(sender_info['type'] == 'unit_donation_request') {
                    node = tab.widgets['output'].append_text(SPText.cstring_to_ablocks(''));
                    req = tab.user_data['unit_donation_requests'][tag] = {'node':node,
                                                                          'tag':tag, 'cur_space':0, 'max_space':0,
                                                                          'i_donated':false, 'my_xp': 0, 'dialog': null,
                                                                          'recipient_id': sender_info['user_id'],
                                                                          'recipient_fbid': sender_info['facebook_id'],
                                                                          'recipient_name': sender_info['chat_name']};
                    node.on_destroy = (function (_req, _tab) { return function(_node) {
                        delete tab.user_data['unit_donation_requests'][_req['tag']];
                    }; })(req, tab);
                } else {
                    // it's a donation towards a request that we do not have - ignore it
                    continue;
                }

                req['cur_space'] = sender_info['cur_space'];
                req['max_space'] = sender_info['max_space'];

                if(req['dialog']) { update_unit_donation_dialog(req['dialog']); }

                var text;
                var callback = null;

                var pct = (100.0*(sender_info['cur_space']/sender_info['max_space'])).toFixed(0);

                if(req['recipient_id'] == session.user_id) {
                    text = SPText.cstring_to_ablocks_bbcode(gamedata['strings']['unit_donation_chat']['you'].replace('%pct', pct), {onclick:callback});
                } else {
                    var kind = (req['i_donated'] ? 'you_have_donated' : 'you_have_not_donated');

                    callback = (function () { return function(w, mloc) {
                        change_selection_ui(null);
                        req['dialog'] = invoke_unit_donation_dialog(req);
                    }; })();

                    text = SPText.cstring_to_ablocks_bbcode(gamedata['strings']['unit_donation_chat']['other'][kind].replace('%pct', pct).replace('%recipient',req['recipient_name']).replace('%xp', req['my_xp'].toString()), {onclick:callback});
                }

                tab.widgets['output'].revise_text(node, text);
            }

        } else {
            // normal chat message
            if(player.has_blocked_user(sender_info['user_id']) && (sender_info['type'] != 'i_got_gagged') && (channel_name != 'DEVELOPER')) { return; }

            var body = SPHTTP.unwrap_string(wrapped_body);
            var props = {};

            if('muted' in sender_info) {
                props.color = '#ff0000';
            } else if(channel_name == 'BROADCAST') {
                props.color = '#ffff00';
            }

            // functions run when part of the chat message is clicked
            var bbcode_click_handlers = {
                'player': { 'onclick': function (_suser_id) {
                    return function(w, mloc) {
                        if(!_suser_id) { return; }
                        var _user_id = parseInt(_suser_id,10);
                        if(!_user_id || is_ai_user_id_range(_user_id)) { return; }
                        change_selection_ui(null);
                        invoke_player_info_dialog_unknown(_user_id);
                    }; } },
                'alliance': { 'onclick': function(salliance_id) { return function(w, mloc) {
                    var alliance_id = parseInt(salliance_id,10);
                    if(alliance_id >= 0) {
                        change_selection_ui(null); invoke_alliance_info(alliance_id);
                    }
                }; } },
                'achievement': {'onclick': function(player_and_name) { return function(w, mloc) {
                    var fields = player_and_name.split(':');
                    var player_id = parseInt(fields[0],10), name = fields[1];
                    if(name in gamedata['achievements']) {
                        var cheeve = gamedata['achievements'][name];
                        change_selection_ui(null);
                        invoke_player_info_dialog_unknown(player_id, null, null, null,
                                                          (function (_cheeve) { return function(dialog) { invoke_achievements_tab(dialog.widgets['achievements_button'], _cheeve['category'], _cheeve['name']); }; })(cheeve)
                                                         );
                    }
                }; } }
            };

            // check for special message types
            var template = (sender_info['type'] && (sender_info['type'] in gamedata['strings']['chat_templates']) ? sender_info['type'] : 'default');

            var bb_text = gamedata['strings']['chat_templates'][template];

            // replace alliance chat tag
            if(bb_text.indexOf('%tag') != -1) {
                if((channel_name != 'ALLIANCE') && ('alliance_tag' in sender_info) && ('alliance_id' in sender_info) && (sender_info['alliance_id'] >= 0) &&
                   player.get_any_abtest_value('enable_alliance_chat_tags', gamedata['client']['enable_alliance_chat_tags'])) {
                    bb_text = bb_text.replace('%tag', gamedata['strings']['chat_templates']['alliance_tag'].replace('%alliance_tag', sender_info['alliance_tag']).replace('%alliance_id', sender_info['alliance_id']));
                } else {
                    bb_text = bb_text.replace('%tag', '');
                }
            }

            // replace achievement name template
            if(bb_text.indexOf('%achievement_name') != -1 && ('achievement_name' in sender_info)) { // check if the template has "%achievement_name in it" AND if the message includes an "achievement_name" property

                // if global option is disabled, or global persist is disabled and message is from before login, do not show the message
                if(!player.get_any_abtest_value('chat_alliance_achievements', gamedata['chat_alliance_achievements']) ||
                   ((sender_info['time'] < session.connect_time) &&
                    !player.get_any_abtest_value('chat_alliance_achievements_persist', gamedata['chat_alliance_achievements_persist']))) {
                    return; // ignore the message
                }

                var cheeve = gamedata['achievements'][sender_info['achievement_name']];
                if(cheeve) {
                    if('chat_announce' in cheeve && !cheeve['chat_announce']) { return; } // disabled for this achievement
                    bb_text = bb_text.replace('%achievement_name', cheeve['ui_name']);
                    bb_text = bb_text.replace('%achievement_id', sender_info['achievement_name']);
                }
            }

            // other text replacements
            goog.object.forEach({'%sender_id': 'user_id',
                                 '%sender_id2': 'user_id',
                                 '%sender_name': 'chat_name',
                                 '%target_id': 'target_user_id',
                                 '%target_name': 'target_chat_name',
                                 '%target_role': 'target_role_ui_name',
                                 '%alliance_id': 'alliance_id',
                                 '%alliance_name': 'alliance_name',
                                 '%alliance_points': 'alliance_points',
                                 '%points_to_win': 'points_to_win',
                                 '%prev_alliance_id': 'prev_alliance_id',
                                 '%prev_alliance_name': 'prev_alliance_name',
                                 '%region_name': 'region_name',
                                 '%item_name': 'item_name'
                                }, function(sender_key, repl_key) {
                if(bb_text.indexOf(repl_key) != -1 && (sender_key in sender_info)) {
                    bb_text = bb_text.replace(repl_key, SPText.bbcode_quote(sender_info[sender_key].toString()));
                }
                                });

            var base_props = {};
            if('time' in sender_info) {
                base_props.tooltip_func = (function (_send_time) { return function() {
                    return gamedata['strings']['chat_age'].replace('%s', pretty_print_time(server_time - _send_time));
                }; })(sender_info['time']);
            }

            var text = SPText.cstring_to_ablocks_bbcode(bb_text, base_props, bbcode_click_handlers);

            var disp_text, disp_user_data;

            if(gamedata['strings']['chat_templates'][template].indexOf('%body') != -1) {
                disp_user_data = {'prebody': text, 'unfiltered_body': body};
                if(sender_info['home_region']) { disp_user_data['home_region'] = sender_info['home_region']; }
                disp_text = display_user_chat_body_nodes(disp_user_data);
            } else {
                disp_text = text;
                disp_user_data = null;
            }

            for(var i = 0; i < tablist.length; i++) {
                var tab = tablist[i];
                tab.widgets['output'].append_text(disp_text, disp_user_data);
            }
        }

        // update timestamps for jewel notification, but not if we typed the message ourself, and not for ordinary unit donation and login updates
        if(sender_info['user_id'] != session.user_id &&
           sender_info['type'] != 'unit_donation' && sender_info['type'] != 'welcome' &&
           sender_info['type'] != 'logged_in' && sender_info['type'] != 'logged_out') {
            for(var i = 0; i < tablist.length; i++) {
                var tab = tablist[i];
                tab.user_data['last_timestamp'] = sender_info['time'] || server_time;
            }
        }

    } else if(msg == "DONATE_UNITS_RESULT") {
        var success = data[1], error_reason = data[2];
        var dialog = find_dialog('unit_donation_dialog');
        if(dialog) { dialog.user_data['pending'] = false; }
        if(success) {
            GameArt.assets["success_playful_22"].states['normal'].audio.play(client_time);
            if(dialog) { close_parent_dialog(dialog.widgets['close_button']); }
        } else {
            var error = gamedata['errors'][error_reason];
            if(error) {
                invoke_child_message_dialog(dialog.data['ui_error_title'], error['ui_name'], {'dialog':'message_dialog_big'});
            }
        }

    } else if(msg == "LOTTERY_GET_SLATE_RESULT") {
        var slate = data[1];
        for(var i = 0; i < lottery_slate_receivers.length; i++) {
            lottery_slate_receivers[i](slate);
        }
        lottery_slate_receivers = [];
    } else if(msg == "LOTTERY_SCAN_RESULT") {
        var result = data[1];
        for(var i = 0; i < lottery_scan_receivers.length; i++) {
            lottery_scan_receivers[i](result);
        }
        lottery_scan_receivers = [];
    } else if(msg == "NEW_BATTLE_HISTORIES") {
        player.new_battle_histories = data[1];
    } else if(msg == "QUERY_BATTLE_HISTORY_RESULT") {
        var tag = data[1], result = data[2], pcache_data = data[3];
        // stick pcache_data into PlayerCache
        PlayerCache.update_batch(pcache_data);
        if(tag in battle_history_receivers) {
            var cb = battle_history_receivers[tag];
            delete battle_history_receivers[tag];
            cb(data[2]);
        }
    } else if(msg == "GET_BATTLE_LOG3_RESULT") {
        var tag = data[1], result = data[2];
        if(tag in battle_log_receivers) {
            var cb = battle_log_receivers[tag];
            delete battle_log_receivers[tag];
            cb(data[2]);
        }
    } else if(msg == "QUERY_ACHIEVEMENTS_RESULT") {
        var tag = data[1], result = data[2];
        if(tag in achievements_receivers) {
            var cb = achievements_receivers[tag];
            delete achievements_receivers[tag];
            cb(result);
        }
    } else if(msg == "QUERY_PLAYER_CACHE_RESULT") {
        var result = data[1], tag = data[2];
        PlayerCache.receive_result(tag, result);
    } else if(msg == "SEARCH_PLAYER_CACHE_RESULT") {
        var result = data[1], pcache_data = data[2], tag = data[3];
        PlayerCache.update_batch(pcache_data);
        if(tag in search_player_cache_receivers) {
            var cb = search_player_cache_receivers[tag];
            delete search_player_cache_receivers[tag];
            cb(result);
        }
    } else if(msg == "QUERY_ALLIANCE_LIST_RESULT") {
        var result = data[1], tag = data[2];
        AllianceCache.receive_list_result(tag, result);
    } else if(msg == "QUERY_ALLIANCE_SCORE_LEADERS_RESULT") {
        var field = data[1], period = data[2], result = data[3], tag = data[4];
        AllianceCache.receive_list_result(tag, result);
    } else if(msg == "QUERY_ALLIANCE_INFO_RESULT") {
        var alliance_ids = data[1], result = data[2], tag = data[3];
        AllianceCache.receive_info_result(alliance_ids, tag, result);
    } else if(msg == "QUERY_ALLIANCE_MEMBERS_RESULT") {
        var alliance_id = data[1], result = data[2], pcache_data = data[3], invite_status = data[4], tag = data[5];
        // stick pcache_data into PlayerCache
        PlayerCache.update_batch(pcache_data);
        AllianceCache.receive_members(alliance_id, tag, result, invite_status);
    } else if(msg == "QUERY_PLAYER_SCORES_RESULT") {
        var user_id_list = data[1], result = data[2], tag = data[3], info = data[4] || null;
        if(tag in player_scores_receivers) {
            var cb = player_scores_receivers[tag];
            delete player_scores_receivers[tag];
            cb(user_id_list, result, info);
        }
    } else if(msg == "QUERY_SCORE_LEADERS_RESULT") {
        var tag = data[4];
        if(tag in score_leaders_receivers) {
            var cb = score_leaders_receivers[tag];
            delete score_leaders_receivers[tag];
            cb(data[1], data[2], data[3]);
        }
    } else if(msg == "QUERY_RIVALS_RESULT") {
        var tag = data[1];
        if(tag in rivals_receivers) {
            var cb = rivals_receivers[tag];
            delete rivals_receivers[tag];
            last_rivals_query_time = client_time;
            cb();
        }
    } else if(msg == "REGION_POP_QUERY_RESULT") {
        var tag = data[1], pops = data[2];
        if(tag in region_pop_receivers) {
            var cb = region_pop_receivers[tag];
            delete region_pop_receivers[tag];
            cb(pops);
        }
    } else if(msg == "QUARRY_QUERY_RESULT") {
        var tag = data[1];
        var region_id = data[2];
        var db_time = data[3];
        var codec = data[4];
        var z_result = data[5];
        var last_db_time = data[6];

        var result;
        if(codec == 'raw') {
            result = z_result;
        } else if(codec == 'lzjb') {
            result = JSON.parse(Iuppiter.bytes_to_string(Iuppiter.decompress(goog.crypt.base64.decodeStringToByteArray(z_result))));
        } else if(codec == 'lz4') {
            result = JSON.parse(Iuppiter.bytes_to_string(lz4.decompress(goog.crypt.base64.decodeStringToByteArray(z_result))));
        } else {
            throw Error('unknown codec '+codec);
        }

        last_quarry_query_time = client_time;

        if(session.region.data && session.region.data['id'] == region_id) {
            session.region.receive_update(db_time, result, last_db_time);
        }

        if(tag && (tag in quarry_receivers)) {
            var cb = quarry_receivers[tag];
            delete quarry_receivers[tag];
            cb(db_time, result, last_db_time);
        }

    } else if(msg == "REGION_TURF_UPDATE") {
        var region_id = data[1], updates = data[2];
        AllianceCache.turf_update(region_id, updates);
    } else if(msg == "REGION_MAP_UPDATES") {
        var region_id = data[1], updates = data[2];
        if(session.region.data && session.region.data['id'] == region_id) {
            goog.array.forEach(updates, function(update) { session.region.receive_feature_update(update); });
        } else {
            // ignore updates if we're not on a map
            console.log('ignoring spurious REGION_MAP_UPDATES'); console.log(data[1]);
        }
    } else if(msg == "REGION_MAP_ATTACK_START" || msg == "REGION_MAP_ATTACK_COMPLETE") {
        var region_id = data[1], base_id = data[2], attacker_id = data[3], defender_id = data[4], summary = data[5], pcache_data = data[6];
        if(session.region.data && session.region.data['id'] == region_id) {
            var feature = session.region.find_feature_by_id(base_id);
            if(feature && ('base_map_loc' in feature)) { // note: exclude features where all we know is the lock state (regional map isn't loaded)
                PlayerCache.update_batch(pcache_data);

                if(defender_id == session.user_id) {
                    var what_happened;
                    if(msg == "REGION_MAP_ATTACK_COMPLETE") {
                        what_happened = 'was_attacked_' + summary['defender_outcome'];
                    } else {
                        what_happened = 'is_under_attack';
                    }

                    var x = feature['base_map_loc'][0].toString(), y = feature['base_map_loc'][1].toString();
                    //var attacker_info = PlayerCache.query_sync(attacker_id); // can return null if an in-flight query already set 'pending' on the entry
                    var attacker_info = goog.array.find(pcache_data, function(entry) { return entry['user_id'] == attacker_id; });
                    if(!attacker_info) { throw Error('no attacker_info with '+msg+', attacker_id '+attacker_id.toString()+' pcache_data '+JSON.stringify(pcache_data)); }
                    var attacker_str = PlayerCache.get_ui_name(attacker_info) + ' (L'+ attacker_info['player_level'].toString()+')';
                    var str = null, name = null;

                    if(feature['base_type'] == 'squad') {
                        var squad_id = parseInt(base_id.split('_')[1],10);
                        if(squad_id.toString() in player.squads) {
                            name = player.squads[squad_id.toString()]['ui_name'];
                            str = gamedata['strings']['regional_map']['your_squad_'+what_happened];
                        }
                    } else if(feature['base_type'] == 'quarry') {
                        name = feature['base_ui_name'] || gamedata['strings']['regional_map']['unknown_name'];
                        str = gamedata['strings']['regional_map']['your_quarry_'+what_happened];
                    }

                    if(str) {
                        str = str.replace('%x',x).replace('%y',y).replace('%basename',name).replace('%attacker',attacker_str);
                        user_log.msg(str, new SPUI.Color(1,1,0,1));
                        // update repeater on the map
                        if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'region_map_dialog') {
                            var dialog = selection.ui;
                            var onclick = (function (_dialog, _feature) { return function() {
                                _dialog.widgets['map'].pan_to_cell(_feature['base_map_loc'], {slowly:true});
                                _dialog.widgets['map'].zoom_all_the_way_in();
                            }; })(dialog, feature);
                            dialog.widgets['notifications'].append_text(SPText.cstring_to_ablocks(str, {onclick: onclick, color:'#ff0000'}));
                        }
                    }
                }
            }
        }
    } else if(msg == "BASE_LOCK_STATE_UPDATE") {
        var base_id = data[1];
        var lock_state = data[2];
        if(base_id != session.viewing_base.base_id) { return; }
        var old_state = session.viewing_lock_state;
        session.viewing_lock_state = lock_state;

        // send lock state update into the player cache
        if(!session.home_base && !session.viewing_ai && (session.viewing_base.base_id == session.viewing_player_home_base_id)) {
            PlayerCache.update_lock_state(session.viewing_user_id, session.viewing_lock_state);
        }

        if(old_state == 0 && lock_state != old_state && !session.home_base && !session.has_attacked &&
           (lock_state == 2)) {
            // kick player out of base or quarry if it is attacked
            visit_base_home();
            notification_queue.push((function (_base) { return function() {
                var err = gamedata['errors'][(_base.base_type == 'quarry' ? "QUARRY_LOCK_TAKEN" : "OPPONENT_LOCK_TAKEN")];
                invoke_message_dialog(err['ui_title'], err['ui_name'].replace('%d', _base.base_ui_name));
            }; })(session.viewing_base));
        } else if(old_state != 0 && lock_state == 0 && !session.home_base && !session.has_attacked) {
            // opponent is now attackable, but reload because we have an old generation of his base
            if(session.is_remote_base()) {
                do_visit_base(-1, {base_id: session.viewing_base.base_id, force:true, short_loading_timeout: true});
            } else {
                do_visit_base(session.viewing_user_id, {force:true, short_loading_timeout: true});
            }
        }

    } else if(msg == "PING_BASE_DAMAGE_RESULT") {
        var base_id = data[1], base_damage = data[2], damage_flags = data[3];
        if(base_id != session.viewing_base.base_id || base_damage < 0 || damage_flags === null) { return; }
        var bars = desktop_dialogs['combat_resource_bars'];
        if(!bars) { return; }
        bars.user_data['base_damage_ping_pending'] = false;
        bars.user_data['base_damage_ping_time'] = client_time;
        bars.user_data['base_damage_server'] = base_damage;
        bars.user_data['base_damage_server_flags'] = damage_flags;
    } else if(msg == "MANUFACTURE_OVERFLOW_TO_RESERVES") {
        if(!session.manufacture_overflow_warned && session.home_base && !session.has_attacked) {
            session.manufacture_overflow_warned = true;
            notification_queue.push(function() { invoke_ingame_tip('manufacture_overflow_to_reserves_tip', {force:true, dialog:'message_dialog_big'}); });
        }
    } else if(msg == "GAMEBUCKS_ORDER_ACK") {
        var tag = data[1], success = data[2];
        if(tag in Store.gamebucks_order_receivers) {
            var cb = Store.gamebucks_order_receivers[tag];
            delete Store.gamebucks_order_receivers[tag];
            cb(success);
        }
    } else if(msg == "ITEM_ORDER_ACK") {
        var tag = data[1], success = data[2];
        if(tag in Store.item_order_receivers) {
            var cb = Store.item_order_receivers[tag];
            delete Store.item_order_receivers[tag];
            cb(success);
        }
    } else if(msg == "FUNGIBLE_ORDER_ACK") {
        var tag = data[1], success = data[2];
        if(tag in Store.fungible_order_receivers) {
            var cb = Store.fungible_order_receivers[tag];
            delete Store.fungible_order_receivers[tag];
            cb(success);
        }
    } else if(msg == "FBCREDITS_ORDER_ACK" || msg == "KGCREDITS_ORDER_ACK") {
        var tag = data[1];
        if(tag in Store.credits_order_receivers) {
            var cb = Store.credits_order_receivers[tag];
            delete Store.credits_order_receivers[tag];
            cb();
        }
    } else if(msg == "FBPAYMENT_ORDER_ACK") {
        var tag = data[1];
        if(tag in Store.fbpayments_order_receivers) {
            var cb = Store.fbpayments_order_receivers[tag];
            delete Store.fbpayments_order_receivers[tag];
            cb();
        }
    } else if(msg == "UNIT_REPAIR_UPDATE") {
        receive_unit_repair_update(data[1]);
    } else if(msg == "SERVER_MAINTENANCE_WARNING") {
        var s = gamedata['strings']['server_going_down_short'];
        invoke_child_message_dialog(s['ui_title'], s['ui_description'], {dialog: s['dialog']});
    } else if(msg == "IDLE_CHECK") {
        var play_time = data[1];
        invoke_idle_check_dialog(play_time);
    } else if(msg == "UNSUPPORTED_BROWSER_REDIRECT") {
        do_unsupported_browser_redirect(data.length > 1 ? data[1] : null);
    } else if(msg == "ACCOUNT_BANNED") {
        do_account_banned_redirect();
    } else if(msg == "PUSH_GAMEDATA") {
        var new_gamedata_str = data[1];
        var new_abtests = data[2];

        var new_gamedata = /** @type {Object.<string,?>} */ (JSON.parse(new_gamedata_str)); // eval('('+new_gamedata_str+')');
        /*
        console.log('HERE 0');
        console.log(new_gamedata);
        console.log('HERE 1 '+new_gamedata['spells']['MOTION_CANNON_SHOOT']['damage']);
        */
        gamedata = new_gamedata;
        /*
        console.log('HERE 2 '+gamedata['spells']['MOTION_CANNON_SHOOT']['damage']);
        */
        player.init_abtests(new_abtests);
        reset_specs();
    } else if(msg == "CLIENT_EVAL") {
        var str = data[1];
        var result = eval(str);
        send_to_server.func(["CLIENT_EVAL_RESULT", str, result]);
    } else if(msg == "SPROBE_RUN") {
        sprobe_run();
    } else if(msg == "SERVER_SYNC") {
        synchronizer.receive_sync(data[1]);
    } else if(msg == "CLIENT_TRACKING_PIXEL") {
        var str = data[1], tag = data[2];
        if(player.is_developer()) { console.log("CLIENT_TRACKING_PIXEL "+str); }
        var result = eval(str);
        if(typeof result == 'undefined') { result = null; }
        send_to_server.func(["CLIENT_TRACKING_PIXEL_RESULT", tag, result]);
    } else if(msg == "CLIENT_TRACKING_PIXEL_IMAGE") {
        var str = data[1], tag = data[2];
        if(player.is_developer()) { console.log("CLIENT_TRACKING_PIXEL_IMAGE "+str); }
        var img = new Image();
        //img.src = (location.protocol=='http:'?'http':'https')+'://'+str;
        img.src = 'https://'+str;
        result = true;
        send_to_server.func(["CLIENT_TRACKING_PIXEL_IMAGE_RESULT", tag, result]);
    } else if(msg == "FORCE_RELOAD") {
        invoke_login_error_message("CANNOT_LOG_IN_VERSION_MISMATCH_GAMEDATA");
    } else if(msg == "LOGIN_ABUSE_WARNING") {
        var actual = data[1], limit = data[2], range = data[3];

        notification_queue.push_with_priority((function (_msg, _actual, _limit, _range) { return function() {
            var msg = gamedata['errors'][_msg];
            invoke_message_dialog(msg['ui_title'],
                                  msg['ui_name'].replace('%ACTUAL', (actual/3600.0).toFixed(0)).replace('%LIMIT', (limit/3600.0).toFixed(0)).replace('%RANGE', (range/3600.0).toFixed(0)).replace('%RANGE', (range/3600.0).toFixed(0)),
                                  {'dialog': msg['dialog']});
        }; })(msg, actual, limit, range), 99);
    } else if(msg == "LOAD_AI_BASE_RESULT" || msg == "SAVE_AI_BASE_RESULT" || msg == "PUBLISH_AI_BASE_RESULT") {
        var success = data[1], error_kind = data[2], info = data[3];
        var dlg = null;
        if(success) {
            if(msg == "LOAD_AI_BASE_RESULT") {
                // temporarily turn this off for the benchmark feature, later find a way to re-enable it selectively
                //dlg = gamedata['strings']['load_ai_base_success'];
            } else if(msg == "SAVE_AI_BASE_RESULT") {
                dlg = gamedata['strings']['save_ai_base_success'];
            } else if(msg == "PUBLISH_AI_BASE_RESULT") {
                dlg = gamedata['strings']['publish_ai_base_success'];
            }
            if(msg != "LOAD_AI_BASE_RESULT") { // LOAD_AI_BASE causes a session change on success
                cancel_loading_base_timer(); visit_base_pending = false; change_selection(null);
            }
        } else {
            cancel_loading_base_timer(); visit_base_pending = false; change_selection(null);
            dlg = gamedata['errors'][error_kind];
        }
        if(dlg) {
            invoke_message_dialog(dlg['ui_title'], (dlg['ui_description'] || dlg['ui_name']).replace('%s', info), {'dialog':(dlg['dialog'] || 'message_dialog_big')});
        }
    } else if(msg == "OFFER_PAYER_PROMO") {
        var currency_url = data[1];

        // note: offer_payer_promo() must be triggered from a
        // mouse-click event in order to avoid being surpressed by
        // pop-up blockers, since FB.ui({'method':'fbpromotion})
        // requires an old-fashioned popup window instead of the
        // iframe-compatible div popup.

        var after_promo_cb = function() { send_to_server.func(["PING_CREDITS"]); send_to_server.func(["PING_PLAYER"]); };
        var make_offer_func = (function (_url, _cb) { return function() {
            SPay.offer_payer_promo(_url, _cb);
        }; })(currency_url, after_promo_cb);

        var launch_offer_dialog = (function (_make_offer) { return function() {
            invoke_child_message_dialog('Incoming Transmission',
                                        'Commander, Facebook has created a special offer for you to obtain free '+Store.gamebucks_ui_name(),
                                        {//'dialog':'message_dialog_big',
                                         'close_button': 0,
                                         'ok_button_ui_name': 'View Offer',
                                         'on_ok': _make_offer});
        }; })(make_offer_func);

        notification_queue.push(launch_offer_dialog);
    } else if(msg == "INVOKE_FACEBOOK_AUTH") {
        var scope = data[1];
        var ui_title = data[2];
        var ui_description = data[3];

        if(spin_frame_platform != 'fb') { return; }

        if(player.has_facebook_permissions(scope)) {
            // already have all the requested permissions
            send_to_server.func(["INVOKE_FACEBOOK_AUTH_RESPONSE", scope, player.facebook_permissions.join(','), true]);
            return;
        }

        var launch_auth_window = (function (_scope) { return function() { invoke_facebook_permissions_dialog(_scope); }; })(scope);

        var launch_ingame_dialog = (function (_launch_auth_window) { return function() {
            invoke_child_message_dialog(ui_title, ui_description,
                                        {//'dialog':'message_dialog_big',
                                         'close_button': 0,
                                         'ok_button_ui_name': 'Proceed',
                                         'on_ok': _launch_auth_window});
        }; })(launch_auth_window);

        notification_queue.push(launch_ingame_dialog);

    } else if(msg == "UNIT_MANUFACTURED") {
        // data is of the form ["UNIT_MANUFACTURED", manufacturer_id, [unit_id0, unit_id1, ...]]
        if('unit_manufactured' in gamedata['client']['vfx']) {
            var effect = gamedata['client']['vfx']['unit_manufactured'];
            var manufacturer = session.cur_objects.get_object(data[1]);

            if(effect['type'] === 'phantom_unit') {
                // pick a random squad building to walk to
                var squad_buildings = find_all_objects_by_type(gamedata['squad_building']);
                var squad_building = squad_buildings[Math.floor(Math.random() * squad_buildings.length)];

                // prepare to calculate a path between the buildings (only done if a unit actually needs it)
                var start_pos = vec_add(manufacturer.interpolate_pos(), vec_scale(0.5, manufacturer.spec['gridsize']));
                var end_pos = vec_add(squad_building.interpolate_pos(), vec_scale(0.5, squad_building.spec['gridsize']));
                var path, path_tried = false; // note: path is undefined until path_tried is set the first time

                for(var i = 0; i < data[2].length; i++) {
                    var unit = player.my_army[data[2][i]];
                    var spec = gamedata['units'][unit['spec']];

                    // add a slight delay of 1 tick per unit so that multiple units don't stack up
                    var delay = TICK_INTERVAL * i;

                    if(spec['noclip'] || spec['flying']) {
                        SPFX.add_visual_effect(start_pos, spec['flying'] ? spec['altitude'] : 0, [1, 0, 1], client_time,
                                gamedata['client']['vfx']['unit_manufactured'], true,
                                {'spec': unit['spec'], 'level': unit['level'], 'path': [start_pos, end_pos], 'start_halted': delay});
                    } else {
                        // calculate the path if it hasn't already been done
                        // note: this does not interact with tick_astar_queries_left, it always runs the query unconditionally.
                        if(!path_tried) {
                            path_tried = true;
                            path = astar_context.search(start_pos, end_pos);
                            if(path && path.length > 0) {
                                path = astar_map.smooth_path(path);
                            }
                        }

                        if(path && path.length > 0) {
                            // only show phantoms for ground units if we have at least a partial path to the squad building
                            SPFX.add_visual_effect(start_pos, spec['flying'] ? spec['altitude'] : 0, [1, 0, 1], client_time,
                                    gamedata['client']['vfx']['unit_manufactured'], true,
                                    {'spec': unit['spec'], 'level': unit['level'], 'path': path.slice(0), 'start_halted': delay});
                        }
                    }
                }
            } else {
                SPFX.add_visual_effect(manufacturer.interpolate_pos(), 0, [0, 1, 0], client_time, gamedata['client']['vfx']['unit_manufactured'], true, null);
            }
        }
    } else if(msg == "ERROR") {
        data.shift();
        var name = data.shift();
        var display_title = gamedata['errors'][name]['ui_title'] || null;
        var display_string = gamedata['errors'][name]['ui_name'];
        var argument = null;

        if(data.length > 0) {
            argument = data.shift();
            display_string = display_string.replace('%d', argument.toString());
        }

        // XXX hack - make sure GameArt is set up to be able to display errors pre-login
        if(!GameArt.initialized) {
            GameArt.init(client_time, canvas, ctx, gamedata['art'], gameart_onload, null, true, true, false);
        }

        if(name.indexOf("CANNOT_LOG_IN_") == 0) {
            client_state = client_states.UNABLE_TO_LOGIN;
            invoke_login_error_message(name);
        } else if(name == "UNKNOWN_SESSION") {
            invoke_timeout_message('0600_client_idle_timeout', {}, {});
        } else if(name == "SERVER_EXCEPTION") {
            invoke_timeout_message('0610_client_died_from_server_exception', {}, {});
        } else if(name == "TOO_LAGGED") {
            invoke_timeout_message('0620_client_died_from_client_lag', {}, {});
        } else if(name == "POWER_LIMIT") {
            var s = gamedata['strings']['requirements_help']['power']['unknown'];
            invoke_message_dialog(s['ui_title'], s['ui_description']);
        } else if(name == "UNIT_SPACE_LIMIT") {
            var helper = get_requirements_help('unit_space', null); if(helper) { helper(); }
        } else if(name == "INVENTORY_LIMIT") {
            var helper = get_requirements_help('inventory_space_need', null); if(helper) { helper(); }
        } else if(name == "EQUIP_INVALID_LIMITED" || name == "EQUIP_INVALID_UNIQUE") {
            display_string = display_string.replace('%s', ItemDisplay.get_inventory_item_ui_name(ItemDisplay.get_inventory_item_spec(argument)));
            invoke_child_message_dialog(display_title, display_string, {'dialog': 'message_dialog_big'});
        } else if(name == "PLAYER_AURA_LIMIT") {
            var helper = get_requirements_help('player_aura_limit', null); if(helper) { helper(); }
        } else if(name == "FOREMAN_IS_BUSY" && player.foreman_is_busy()) {
            var helper = get_requirements_help('foreman', null);
            if(helper) {
                change_selection_ui(null);
                helper();
                return;
            } else {
                var busy_obj = player.foreman_get_tasks()[0]; // this just prompts to speed up one possible building
                change_selection(busy_obj);
                invoke_speedup_dialog('busy');
            }
        } else if(name == "LAB_IS_BUSY") {
            var busy_obj = session.cur_objects.objects[argument];
            if(busy_obj) {
                change_selection(busy_obj);
                invoke_speedup_dialog('research');
            }
        } else if(name == "WORKSHOP_IS_BUSY") {
            var busy_obj = session.cur_objects.objects[argument];
            if(busy_obj) {
                change_selection(busy_obj);
                invoke_speedup_dialog('crafting');
            }
        } else if(name == "INVALID_MAP_LOCATION" || name == "CANNOT_ALTER_SQUAD_WHILE_UNDER_ATTACK" ||
                  name == "SQUAD_RACE_CONDITION" || name.indexOf("CANNOT_DEPLOY_SQUAD") == 0) {
            // stop whatever AI action the squad was trying to do
            if(argument && (argument.toString() in player.squads)) {
                var squad = player.squads[argument.toString()];
                player.squad_clear_client_data(argument); // unblock UI and erase orders
                if(1 /*name == "INVALID_MAP_LOCATION" || name == "CANNOT_ALTER_SQUAD_WHILE_UNDER_ATTACK"*/) {
                    invoke_child_message_dialog(display_title, display_string.replace('%BATNAME', squad['ui_name']), {'dialog':'message_dialog_big'});
                }
            }
        } else if(name.indexOf("CANNOT_CHANGE_REGION") == 0) {
            if(change_region_pending == 'paid') {
                display_string += gamedata['errors'][name]['ui_name_paid'].replace('%GAMEBUCKS', Store.gamebucks_ui_name());
            }
            invoke_child_message_dialog(display_title, display_string, {'dialog':'message_dialog_big'});
            change_region_pending = false;
        } else if(name.indexOf("CANNOT_SPY") == 0 ||
                  name == "CANNOT_LOCK_QUARRY" ||
                  name == "CANNOT_ATTACK_BASE_WHILE_ALREADY_UNDER_ATTACK" ||
                  name == "CANNOT_ATTACK_THEIR_SQUAD_MOVED" ||
                  name == "CANNOT_ATTACK_THEIR_SQUAD_OFFENSE" ||
                  name == "CANNOT_ATTACK_THEIR_SQUAD_DEFENSE" ||
                  name == "CANNOT_ATTACK_YOUR_SQUAD_RACE" ||
                  name == "LADDER_MATCH_FAILED") {

            cancel_loading_base_timer();
            visit_base_pending = false;

            var cb = (function (_title, _str) { return function() {
                invoke_child_message_dialog(_title, _str, {'dialog':'message_dialog_big'});
            }; })(display_title, display_string);

            if(1) { // OLD
                change_selection(null);
                notification_queue.push(cb);
            } else {
                cb();
            }
            if(name == "CANNOT_LOCK_QUARRY" ||
               name == "CANNOT_ATTACK_BASE_WHILE_ALREADY_UNDER_ATTACK" ||
               name == "CANNOT_ATTACK_THEIR_SQUAD_MOVED" ||
               name == "CANNOT_ATTACK_THEIR_SQUAD_OFFENSE" ||
               name == "CANNOT_ATTACK_THEIR_SQUAD_DEFENSE" ||
               name == "CANNOT_ATTACK_YOUR_SQUAD_RACE") {
                visit_base_home();
            } else if(name.indexOf("CANNOT_SPY") == 0 && session.home_base && session.last_map_dialog_state) {
                var state = session.last_map_dialog_state;
                session.last_map_dialog_state = null;
                var dialog = invoke_region_map();
                if(dialog) { dialog.widgets['map'].set_state(state); }
            }

        } else if(name == "CANNOT_CALL_INVALID_AI_ATTACK") {
            var s = gamedata['errors'][name];
            invoke_message_dialog(s['ui_title'], s['ui_name']);
        } else if(name == "INSUFFICIENT_GAMEBUCKS") {
            var deficit = argument, client_price = data[0], unit_id = data[1], spellname = data[2], spellarg = data[3];
            var cb = (function (_deficit) { return function() {
                invoke_insufficient_alloy_message('server_initiated', _deficit,
                                                  {'price':client_price, 'unit_id':unit_id, 'spellname':spellname, 'spellarg':spellarg});
            }; })(deficit);
            notification_queue.push(cb);
        } else if(name == "INSUFFICIENT_RESOURCES_TO_REPAIR") {
            invoke_insufficient_resources_for_repair_message(argument || {}, data[0] || null);
        } else if(name.indexOf("CANNOT_CREATE_ALLIANCE")==0 || name == "ALLIANCES_OFFLINE" || name == "CANNOT_JOIN_ALLIANCE") {
            invoke_child_message_dialog(display_title, display_string, {'dialog': 'message_dialog_big'});
        } else {
            user_log.msg('Error: '+display_string, new SPUI.Color(1,0,0,1));
        }

    } else if(msg == "NOMESSAGE") {
    } else {
        document.write("AJAX error: "+data);
    }
}

// Ask player to refresh the browser. This is a catch-all message that
// is used not only for genuine timeouts, but also for any kind of
// "deadly" error that can only be resolved by logging in again (e.g.,
// integrity failure of the AJAX message stream).

SPINPUNCHGAME.client_death_sent = null;

function invoke_timeout_message(event_name, props, options) {
    var code = (event_name ? event_name.slice(0,4) : null);

    var s = gamedata['strings']['timeout_message'];
    var title = s['ui_title'];
    var descr = s['ui_description'];
    var button_text = s['ui_button'];

    if(code != '0600') {
        // abnormal client termination - add error code for debugging purposes
        s = gamedata['strings']['network_error'];
        title = options['ui_title'] || s['ui_title'];
        descr = options['ui_description'] || (s['ui_description'].replace('%d',code.toString()));
        button_text = ('ui_button' in options ? options['ui_button'] : s['ui_button']);

        if(code && !SPINPUNCHGAME.client_death_sent) {
            // only send the metric once, for the first "deadly" event
            SPINPUNCHGAME.client_death_sent = event_name;

            props['connection'] = gameapi_connection_method();
            props['since_connect'] = (session.connected() ? client_time - session.connect_time : -1);
            props['since_pageload'] = client_time - spin_pageload_begin;
            if(spin_user_id) { props['user_id'] = spin_user_id; }

            // note: force metric to be sent via the GIF fetch method rather than with the normal client/server stream,
            // beacuse the normal stream may have been corrupted by this point
            SPLWMetrics.send_event(spin_metrics_anon_id, event_name, add_demographics(props));
        }
    }

    // XXX hack - make sure GameArt is set up to be able to display errors pre-login
    if(!GameArt.initialized) {
        GameArt.init(client_time, canvas, ctx, gamedata['art'], gameart_onload, null, true, true, false);
    }

    var dialog = invoke_message_dialog(title, descr, options);
    dialog.widgets['ok_button'].str = button_text;
    if(!button_text) {
        // for errors that involve server overload, do not provide a convenient "try again" button!
        dialog.widgets['ok_button'].show = dialog.widgets['close_button'].show = false;
    }

    // force a browser window refresh on click
    var do_reload = reload_game;
    // old code:
//    if((options['uncached_reload'] &&
//        location.href == spin_page_url) {
//      do_reload = function() { location.reload(true); };
//    } else {
//      do_reload = function() { location.href = spin_page_url; };
//    }

    dialog.widgets['close_button'].onclick =
        dialog.widgets['ok_button'].onclick = (function (_do_reload) { return function(w) {
            var dialog = w.parent;
            dialog.widgets['ok_button'].state = 'disabled';
            dialog.widgets['ok_button'].str = s['ui_button_pending'];
            dialog.widgets['close_button'].onclick =
                dialog.widgets['ok_button'].onclick = null;
            // put a timeout on the reload so that players can't spam it as easily
            window.setTimeout(_do_reload, (options['reload_delay'] || 2.0) * 1000);
        }; })(do_reload);

    // deactivate simulation and do not send any more pings
    client_state = client_states.TIMED_OUT;

    if(!options['continue_graphics']) {
        // scale back on CPU usage after client dies
        FRAME_RATE_CAP = 1;

        // force one display refresh
        force_draw();
    }
}

function invoke_login_error_message(error_name) {
    var errdat = gamedata['errors'][error_name];
    if('redirect' in errdat) {
        // just redirect the browser
        location.href = errdat['redirect'];
        return;
    }

    invoke_timeout_message(errdat['metric_event'] || null, {'method':error_name},
                           {'uncached_reload': true,
                            'continue_graphics': true,
                            'ui_title': errdat['ui_title'] || gamedata['strings']['reload_required']['ui_title'],
                            'ui_description': errdat['ui_name'],
                            'ui_button': ('ui_button' in errdat ? errdat['ui_button'] : gamedata['strings']['reload_required']['ui_button']),
                            'dialog': errdat['dialog'] || null,
                            'reload_delay': errdat['reload_delay'] || null
                           });
}

/** store the combat damage state of all mutated objects to the server
 * @param {{buildings_only:(boolean|undefined),
 *          urgent_only:(boolean|undefined),
 *          skip_check:(boolean|undefined)}} options
 * buildings_only: only flush building damage deltas
 * skip_check: do not trigger slow integrity checks
 */
function flush_dirty_objects(options) {
    var args = [];

    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.state_dirty != 0) {
            if(options.urgent_only && !(obj.state_dirty & obj_state_flags.URGENT)) { continue; }
            if(options.buildings_only && !obj.is_building()) { continue; }
            var xy, orders = null;
            if(obj.is_mobile()) {
                // send the (quantized) client simulation position
                xy = [Math.floor(obj.pos[0]), Math.floor(obj.pos[1])];
                if((obj.state_dirty & obj_state_flags.ORDERS) && obj.orders.length > 0) {
                    orders = [];
                    for(var i = 0; i < obj.orders.length; i++) {
                        orders.push(obj.orders[i]);
                    }
                    //orders = [obj.orders[0]];
                }
            } else {
                xy = [obj.x, obj.y];
            }
            var this_arg = [obj.id,
                            obj.spec['name'],
                            xy,
                            (obj.state_dirty & obj_state_flags.HP ? obj.hp : -1),
                            orders,
                            (obj.is_building() ? obj.killer_info : null),
                            ((obj.is_mobile() && (obj.state_dirty & obj_state_flags.PATROL)) ? obj.patrol : null)
                           ];
            args.push(this_arg);

            // snoop update into my_army
            if(obj.state_dirty & obj_state_flags.HP) {
                if(obj.id in player.my_army) {
                    var entry = player.my_army[obj.id];
                    entry['hp_ratio'] = obj.hp/Math.max(obj.max_hp,1);
                }
            }

            obj.state_dirty = 0;
        }
    }

    if(args.length > 0) {
        send_to_server.func(["OBJECT_COMBAT_UPDATES", args]);
    }
}

var change_region_pending = null;

var loading_base_dialog_timer = null;

function cancel_loading_base_timer() {
    if(loading_base_dialog_timer) {
        window.clearTimeout(loading_base_dialog_timer);
        loading_base_dialog_timer = null;
    }
};

function invoke_loading_base_dialog(dialog_name) {
    loading_base_dialog_timer = null;
    change_selection(null);
    var dialog_data = gamedata['dialogs'][dialog_name];
    var dialog = new SPUI.Dialog(dialog_data);
    change_selection_ui(dialog);
    dialog.auto_center();
    dialog.modal = true;
    return dialog;
};

var visit_base_pending = false;

// switch to view another user's base (or your own base)
// if short_loading_timeout, then show loading screen immediately rather than delaying
function do_visit_base(uid, options) {
    if(uid === session.viewing_user_id && !session.has_attacked && session.viewing_player_home_base_id === session.viewing_base.base_id && !options.force) {
        // already looking at this user
        return;
    }

    if(visit_base_pending) {
        console.log('visit_base already pending');
        return;
    }

    // catch-all for leaving home when there is something in the loot buffer
    if(session.home_base && !session.has_attacked && (player.loot_buffer.length > 0)) {
        invoke_loot_dialog();
        return;
    }

    if(!options.skip_loot_storage_warning && session.home_base && !session.has_attacked && is_ai_user_id_range(uid) && player.tutorial_state == "COMPLETE") {
        var almost_full = {}, full = {}, any_almost_full = false, any_full = false;
        for(var res in gamedata['resources']) {
            if(('loot_storage_warning_if' in gamedata['resources'][res]) &&
               !read_predicate(gamedata['resources'][res]['loot_storage_warning_if']).is_satisfied(player,null)) { continue; }
            almost_full[res] = (player.resource_state[res][1] >= gamedata['client']['loot_storage_warning_threshold'] * player.resource_state[res][0]);
            if(almost_full[res]) { any_almost_full = true; }
            full[res] = (player.resource_state[res][1] >= player.resource_state[res][0]);
            if(full[res]) { any_full = true; }
        }
        if(player.get_any_abtest_value('loot_storage_warning', gamedata['client']['loot_storage_warning']) &&
           (any_full || any_almost_full) &&
           (player.get_townhall_level() >= gamedata['client']['loot_storage_warning_min_cc_level']) &&
           (player.get_townhall_level() <= gamedata['client']['loot_storage_warning_max_cc_level'])) {
            var new_options = goog.object.clone(options);
            new_options.skip_loot_storage_warning = true;
            var proceed = (function (_uid, _new_options) { return function() {
                do_visit_base(_uid, _new_options);
            }; })(uid, new_options);

            var complain_about, truly_full;
            if(any_full) {
                for(var res in gamedata['resources']) {
                    if(full[res]) {
                        complain_about = res;
                        truly_full = true;
                        break;
                    }
                }
            } else {
                for(var res in gamedata['resources']) {
                    if(almost_full[res]) {
                        complain_about = res;
                        truly_full = false;
                        break;
                    }
                }
            }

            var helper = get_requirements_help((truly_full ? 'storages_full_attack' : 'storages_almost_full_attack'),
                                               complain_about,
                                               {cancel_function: proceed});
            if(helper) {
                helper();
                return;
            }
        }
    }

    if(1) {
        apply_queued_damage_effects();
        flush_dirty_objects({});
        persist_debris();
    }

    if(uid > 0 || options.base_id || options.ladder_battle) {
        var msg;
        var props = {};
        if(options.apm) {
            props['apm'] = options.apm;
        }
        if(options.pre_attack) {
            props['pre_attack'] = true;
        }

        if(options.ladder_battle) {
            player.cooldown_client_trigger('VISIT_LADDER_RIVAL', gamedata['matchmaking']['ladder_match_client_cooldown']);
            msg = ["VISIT_LADDER_RIVAL", !!options.ladder_switch, props];
        } else if(options.base_id) {
            msg = ["VISIT_BASE2", options.base_id, props];
        } else {
            msg = ["VISIT_BASE", uid, props];
        }
        send_to_server.func(msg);
        visit_base_pending = true;

        // when leaving home base, save state of map dialog so we can come back to it
        if(session.home_base) {
            if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'region_map_dialog') {
                session.last_map_dialog_state = selection.ui.widgets['map'].get_state();
            } else {
                session.last_map_dialog_state = null;
            }
        }

        // schedule the "Loading Base" message to appear after a slight delay (in case the session change completes quickly)
        if(loading_base_dialog_timer == null) {
            if(options.ladder_battle) {
                invoke_loading_base_dialog('loading_ladder_base_dialog');
            } else if(options.short_loading_timeout || (gamedata['client']['loading_base_time'] === 0)) {
                invoke_loading_base_dialog('loading_base_dialog');
            } else {
                var load_time = gamedata['client']['loading_base_time'];
                if(load_time && load_time > 0) {
                    loading_base_dialog_timer = window.setTimeout(function() { invoke_loading_base_dialog('loading_base_dialog'); }, 1000*load_time);
                }
            }
        }
    }
}

function visit_base(uid) { return do_visit_base(uid, {}); };
function visit_base_with_loading_message(uid) { return do_visit_base(uid, {short_loading_timeout: true}); };

// return to home base
function visit_base_home() { visit_base(session.user_id); }

// force a session change to end the current attack. Normally returns
// to home base, but if it's a quarry attack, and you won, return to
// the quarry instead.
function visit_base_after_attack() {
    if(session.home_base) {
        do_visit_base(session.user_id, {apm: APMCounter.get()});
    } else if(session.is_quarry() && session.viewing_user_id != session.user_id && session.quarry_victory_satisfied()) {
        do_visit_base(0, {base_id: session.viewing_base.base_id, apm: APMCounter.get()});
    } else {
        do_visit_base(session.user_id, {apm: APMCounter.get()});
    }
}

function change_region(new_region, new_loc) { send_to_server.func(["CHANGE_REGION", new_region, new_loc]); }

// convert coordinates of DOM mouse event to canvas coordinates
function event_to_canvas(e) {
    // get canvas coordinates of mouse-click location
    var x, y;
    if(mouse_state.pointer_locked) {
        x = mouse_state.pointer_lock_origin[0] + e['webkitMovementX'];
        y = mouse_state.pointer_lock_origin[1] + e['webkitMovementY'];
        mouse_state.pointer_lock_origin = [x,y];
    } else {
        if(e.pageX || e.pageY) {
            x = e.pageX;
            y = e.pageY;
        } else {
            x = e.clientX; /*+ document.body.scrollLeft + document.documentElement.scrollLeft; */
            y = e.clientY; /*+ document.body.scrollTop + document.documentElement.scrollTop; */
        }
        if(!canvas_is_fullscreen) {
            x -= canvas_div_offsetLeft;
            y -= canvas_div_offsetTop;
        }
    }
    return [x,y];
}

function on_mouseup(e) {
   try {
       do_on_mouseup(e);
   } catch (ex) {
       log_exception(ex, 'do_on_mouseup');
   }
}

function do_on_mouseup(e) {
    e.preventDefault();

    mouse_state.clear_button(e.button);

    // get canvas coordinates of mouse pointer location
    var xy = event_to_canvas(e);

    SPUI.dripper.stop(true);

    if(mouse_state.dripper.is_active()) {
        // Dripper.stop() will fire the callback one more time, but it doesn't have any way of updating the player's APM
        if(mouse_state.dripper.times_fired <= 0) {
            if(gamedata['unit_deploy_style'] === 'drip') {
                APMCounter.record_action();
            }
        }

        mouse_state.dripper.stop(true, xy);
    }

    if(e.button == SPUI.RIGHT_MOUSE_BUTTON) {
        // end drag
        if(mouse_state.has_dragged) {
            mouse_state.has_dragged = false;
            if(selection.multi.length > 1) {
                player.record_feature_use('drag_select');
            }
        } else {
            if(tutorial_root.on_mouseup(xy, [0,0], e.button)) {
                return;
            }
            if(player.quest_root.on_mouseup(xy, [0,0], e.button)) {
                return;
            }
            if(SPUI.root.on_mouseup(xy, [0,0], e.button)) {
                return;
            }
            if(player.tutorial_state != "COMPLETE") {
                return;
            }
            change_selection(null);
        }
        return;
    }

    if(mouse_state.has_scrolled == true) {
        mouse_state.has_scrolled = false;
        // do not trigger action if the mouse was just used for a BIG scroll
        if(Math.max(Math.abs(xy[0]-mouse_state.scroll_start_x),
                    Math.abs(xy[1]-mouse_state.scroll_start_y)) >= gamedata['client']['mouse_scroll_dead_zone']) {
            // but DO record use of "scrolling" feature
            player.record_feature_use('scrolling');
            return;
        }
    }

    // first let SPUI handle it
    if(tutorial_root.on_mouseup(xy, [0,0], e.button)) {
        return;
    }

    if(player.quest_root.on_mouseup(xy, [0,0], e.button)) {
        return;
    }

    if(SPUI.root.on_mouseup(xy, [0,0], e.button)) {
        return;
    }

    // take back keyboard focus from SPUI
    SPUI.set_keyboard_focus(null);

    if(player.tutorial_state != "COMPLETE") {
        if('disable_landscape_clicks' in gamedata['tutorial'][player.tutorial_state]) {
            return;
        }
    } else {
        // disable landscape clicks while any notifications are pending
        //if(session.home_base && !session.has_attacked && notification_queue.pending() && !selection.ui) {
        //return;
        //}
    }

    if(!session.viewing_base) { return; }

    // find cell index (note: j,i are not quantized to integers)
    var ji = screen_to_ortho(xy);

    var ncells = session.viewing_base.ncells();

    // clamp ji to game map bounds
    // NOTE! xy is not clamped, and can be off the map - this is necessary to hit-detect flying units
    // whose altitude puts them "outside" the map, as seen from the isometric camera
    ji[0] = clamp(ji[0], 0, ncells[0]); ji[1] = clamp(ji[1], 0, ncells[1]);

    var j = ji[0], i = ji[1];

    // is a ground-targeted spell "armed"?
    if(selection.spellname) {
        if(selection.spellname === "MOVE_UNIT") {
            unit_command_move(j, i, false, !!e.shiftKey);
            change_selection_ui(null);
            selection.spellname = null;
            return;
        } else if(selection.spellname === "BUILD") {
            do_build(ji);
            return;
        } else if(selection.spellname === "MOVE_BUILDING") {
            if(selection.unit && ((selection.unit.is_building() && selection.unit.team == 'player') || player.is_cheater)) {
                ji = player.quantize_building_location(ji, selection.unit.spec);
                if((ji[0] != selection.unit.x || ji[1] != selection.unit.y) &&
                   player.is_building_location_valid(ji, selection.unit.spec, selection.unit, {ignore_perimeter: !!selection.unit.spec['ignore_perimeter']})) {
                    send_to_server.func(["CAST_SPELL",
                                         selection.unit.id,
                                         selection.spellname,
                                         ji]);
                    // play sound effect
                    if(1) {
                        var state = GameArt.assets['action_button_134px'].states['bigaction'];
                        if(state.audio) { state.audio.play(client_time); }
                    }

                    // client-side predict - not 100% sure if this is safe?
                    var old_x = selection.unit.x, old_y = selection.unit.y;
                    selection.unit.x = ji[0]; selection.unit.y = ji[1];
                    selection.unit.update_map(old_x, old_y, selection.unit.is_destroyed());
                }
            }
            change_selection(null);
            return;
        } else if(selection.spellname === "DEPLOY_UNITS") {
            if(!session.viewing_base.is_deployment_location_valid(ji)) {
                return;
            }

            var any_selected = goog.object.getCount(session.pre_deploy_units) > 0;

            if(any_selected) {

                // try to prevent breaking the tutorial by deploying less than a full load of units
                if((player.tutorial_state != 'COMPLETE') &&
                   (player.tutorial_state != 'place_robots_action')) {
                    return;
                }

                if(gamedata['unit_deploy_style'] != 'drip') {
                    APMCounter.record_action();
                    do_deploy([j,i], goog.object.getValues(session.pre_deploy_units));
                }
            }

            if((any_selected || session.has_deployed) && gamedata['unit_deploy_style'] != 'drip') {
                // if in combat, or units were deployed, kill cursor
                // but do not kill it on initial deployment when empty, so the deployment zone stays visible
                change_selection(null);
            }
            return;

        } else if(gamedata['spells'][selection.spellname]['activation'] === 'targeted_area') {
            // generic targeted spell activation
            if(selection.unit) {
                var spell_name = selection.spellname, spell = gamedata['spells'][selection.spellname];
                var success = false;
                success |= selection.unit.cast_client_spell_checked(spell_name, spell, null, [j,i]);
                for(var m = 0; m < selection.multi.length; m++) {
                    var u = selection.multi[m];
                    if(u !== selection.unit && u.spec === selection.unit.spec) {
                        success |= u.cast_client_spell_checked(spell_name, spell, null, [j,i]);
                    }
                }
                if(success) {
                    SPFX.add_under(new SPFX.ClickFeedback([j,i], [1,1,1,1], client_time, client_time + 0.15));
                }
            } else if(selection.item) {
                var spec = gamedata['items'][selection.item['spec']];
                var spell = gamedata['spells'][selection.spellname];

                inventory_send_request(selection.item, selection.slot, "INVENTORY_USE", [[j,i]], session.has_deployed); // trigger GCD during combat only

                SPFX.add_under(new SPFX.ClickFeedback([j,i], [1,1,1,1], client_time, client_time + 0.15));
                if('ui_activation' in spell) {
                    SPFX.add(new SPFX.CombatText([j,i], 0,
                                                 spec['ui_name'] + " " + spell['ui_activation'],
                                                 [1,1,0.3],
                                                 client_time, client_time + 3.0,
                                                 { drop_shadow: true, font_size: 20, text_style: 'thick' }));
                }
            }
            APMCounter.record_action();

            change_selection_ui(null);
            selection.spellname = null;
            return;
        }
    }

    var found = find_object_at_screen_pixel(xy, ji, false);

    if(selection.spellname === "AMOVE_UNIT" || selection.spellname === "PATROL_UNIT") {
        if(selection.spellname === "AMOVE_UNIT") {
            player.record_feature_use('unit_attack_command');
            var add_waypoint = !!e.shiftKey;
            if(found &&
               (gamedata['allow_self_attack'] || player.is_developer() || (found.team != selection.unit.team))) {
                unit_command_attack(found, add_waypoint);
            } else {
                unit_command_move(j, i, true, add_waypoint);
            }
        } else if(selection.spellname === "PATROL_UNIT") {
            unit_command_patrol(j, i);
        }

        if(!e.shiftKey) {
            selection.spellname = null;
            change_selection_ui(null);
        }
        APMCounter.record_action();
        return;
    }


    if(found != null) {
        if((selection.unit != null) &&
           (selection.unit.spec['kind'] != 'virtual') &&
           (selection.unit.is_shooter()) &&
           (found != selection.unit) &&
           (found.team != selection.unit.team)) {

            unit_command_attack(found, !!e.shiftKey);

            if(player.tutorial_state === 'move_rover_action') {
                tutorial_step_move_rover_action_command();
            }

            SPFX.add_under(new SPFX.ClickFeedback(found.interpolate_pos(), [1,0,0,1], client_time, client_time + 0.15));
            APMCounter.record_action();

        } else {
            if((found.team === 'player') && found.is_mobile() && player.unit_micro_enabled() && (!session.is_quarry() || session.has_deployed || session.region.data['storage'] == 'nosql')) {
                // naked click on a player's own unit

                if(e.ctrlKey ||
                   (mouse_state.last_unit_clicked === found &&
                    (client_time - mouse_state.last_click_time < DOUBLE_CLICK_TIME))) {
                    // it's a double-click or control-click
                    // select all on-screen units of same type
                    var units = find_objects_in_screen_rect([0,0], [canvas_width,canvas_height], found.spec);
                    if(units.length > 0) { player.record_feature_use('double_click_select'); }

                    if(e.shiftKey) {
                        goog.array.forEach(units, function(u) {
                            add_unit_to_selection(u);
                        });
                    } else {
                        selection.multi = units;
                        if(!selection.unit && units.length > 0) { selection.unit = units[0]; }
                    }
                    mouse_state.last_unit_clicked = null;
                } else {
                    // NOT a double-click
                    mouse_state.last_unit_clicked = found;
                    mouse_state.last_click_time = client_time;

                    if(e.shiftKey) {
                        // flip selected state
                        toggle_unit_selection(found);
                        player.record_feature_use('shift_select');
                    } else {
                        // replace existing selection
                        change_selection(found);
                        selection.spellname = null;
                        selection.spellkind = null;

                        found.speak('click');
                    }
                }

                if(player.tutorial_state === 'click_on_rover_action') {
                    if(found.spec['name'] === gamedata['tutorial'][player.tutorial_state]['unit_type']) {
                        advance_tutorial();
                    } else {
                        goog.array.forEach(selection.multi, function(unit) {
                            if(unit.spec['name'] === gamedata['tutorial'][player.tutorial_state]['unit_type']) {
                                advance_tutorial();
                            }
                        });
                    }
                }

                return;
            } else if((found.team === 'player') &&
                      /* enable if not in combat (where "combat" explicitly excludes reinforcement mode at a friendly quarry/squad) */
                      (!session.has_attacked || (!session.home_base && session.viewing_user_id == session.user_id)) &&
                      (found.is_building() || found.is_inert()) &&
                      (session.home_base || !found.spec['quarry_invul'] || found.is_producer())) {
                // naked click on a player's own building
                change_selection(found);
                var allow_invoke = true;
                if(player.tutorial_state != "COMPLETE") {
                    allow_invoke = false;
                    if(player.tutorial_state === 'speedup_open_context_menu' &&
                       found.spec['name'] === gamedata['tutorial'][player.tutorial_state]['target']) {
                        allow_invoke = true;
                    }
                }

                if(session.has_attacked && !(!session.home_base && session.region.data && session.region.data['storage'] == 'nosql' &&
                                             (session.viewing_base.base_landlord_id == session.user_id) && (goog.array.contains(['squad','quarry'], session.viewing_base.base_type)))) {
                    allow_invoke = false;
                }

                if(allow_invoke) {
                    if(session.home_base && found.is_building() && found.is_producer() && gamedata['enable_oneclick_harvest'] &&
                       found.idle_state_cache && found.idle_state_cache['state'] &&
                       found.idle_state_cache['state'].indexOf('harvest_') == 0 &&
                       get_storage_fullness(found.produces_res()) < 1 &&
                       found.is_in_sync()) {
                        // do a one-click harvest iff the idle state is showing as "Collect"
                        do_harvest(false);
                    } else {
                        invoke_building_context_menu(xy);
                    }
                }
                return;
            } else if(player.is_cheater && found.is_inert()) {
                change_selection(found);
                invoke_building_context_menu(xy);
            }
        }
    } else {
        // click over empty ground
        if(selection.unit != null) {
            if(selection.unit.is_mobile()) {

                var use_amove = false;

                // in auto unit control mode and on touch screens, treat ALL (in combat) landscape clicks as a-move
                if(session.has_attacked && (touch_primary || get_preference_setting(player.preferences, 'auto_unit_control'))) {
                    use_amove = true;
                    if(client_time - mouse_state.last_click_time < DOUBLE_CLICK_TIME) {
                        use_amove = false;
                        //mouse_state.last_click_time = 0;
                    }
                    mouse_state.last_click_time = client_time;
                }

                // move units
                unit_command_move(j, i, use_amove, !!e.shiftKey);
                APMCounter.record_action();
            } else {
                // deselect
                change_selection(null);
            }
        }
    }
}

function on_mouseout(e) {
   try {
       do_on_mouseout(e);
   } catch (ex) {
       log_exception(ex, 'do_on_mouseout');
   }
}

function do_on_mouseout(e) {
    mouse_state.clear_all_buttons();
    mouse_state.dripper.stop();
    mouse_state.has_scrolled = false;
    mouse_state.has_dragged = false;
    mouse_state.hovering_over = null;
}

function create_mouse_tooltip() {
    // no tooltips during tutorial
    if(player.tutorial_state != "COMPLETE") { return; }

    if(!mouse_tooltip) {
        mouse_tooltip = new SPUI.Tooltip({'ui_name':'TEMP','delay':0}, null);
        mouse_tooltip.text_hjustify = 'center';
        mouse_tooltip.font = SPUI.make_font(13, 17, 'normal');
    }

    mouse_tooltip.onenter();

    mouse_tooltip.ondraw = function(mouse_tooltip) {
        // don't show tooltip if any other UI is up, or if mouse has left the object
        if(selection.ui != null || !mouse_state.hovering_over) {
            mouse_tooltip.onleave();
            return;
        }

        // also kill the tooltip if the mouse is hovering over any desktop UI element
        var ui_up = false;
        for(var name in desktop_dialogs) {
            var dialog = desktop_dialogs[name];
            if(dialog.mouse_enter_time > 0) {
                ui_up = true;
                mouse_tooltip.onleave();
                return;
            }
        }

        mouse_tooltip.text_color = SPUI.default_text_color;

        // update tooltip text
        var obj = mouse_state.hovering_over;
        var str = [];

        if(obj.is_mobile() || obj.is_building()) {
            if(obj.is_invisible() && obj.team !== 'player') {
                mouse_tooltip.onleave();
                return;
            }

            if(obj.is_building() && obj.is_emplacement() && obj.turret_head_item) {
                var item_name = obj.turret_head_item();
                if(item_name) {
                    var item_spec = ItemDisplay.get_inventory_item_spec(item_name);
                    var ui_name = ItemDisplay.strip_inventory_item_ui_name_level_suffix(ItemDisplay.get_inventory_item_ui_name(item_spec));
                    str.push(ui_name);
                    if((obj.team === 'player' || gamedata['enemy_tooltip_detail'][obj.spec['kind']])) {
                        var cur_level = item_spec['level'];
                        var max_level = get_max_level(gamedata['tech'][item_spec['associated_tech']]);
                        str.push(gamedata['strings']['cursors']['level_x_of_y'].replace('%cur', cur_level.toString()).replace('%max', max_level.toString()));
                    }
                    str.push('---'); // separator between head and emplacement
                }
            }

            var nameline = obj.spec['ui_name'];
            if(obj.is_building() && obj.is_minefield() && (obj.id in session.minefield_tags_by_obj_id)) {
                nameline += ' '+session.minefield_tags_by_obj_id[obj.id];
            }
            str.push(nameline);
            if((obj.team === 'player' || gamedata['enemy_tooltip_detail'][obj.spec['kind']]) && (obj.get_max_ui_level() > 1)) {
                var max_level = obj.get_max_ui_level();
                str.push(gamedata['strings']['cursors']['level_x_of_y'].replace('%cur', obj.level.toString()).replace('%max', max_level.toString()));
            }
        } else if(obj.is_inert()) {
            if(obj.metadata && 'tooltip' in obj.metadata) {
                str.push(obj.metadata['tooltip']);
            } else {
                str.push(obj.spec['ui_name'] || obj.spec['name']);
            }
        }

        if(obj.is_building()) {
            if(obj.is_storage() && !obj.is_under_construction() && obj.spec['name'] != gamedata['townhall'] &&
               (obj.team === 'player' || gamedata['enemy_storage_detail'])) {
                var resname = null;
                for(var res in gamedata['resources']) {
                    if('storage_'+res in obj.spec) {
                        resname = res; break;
                    }
                }
                if(obj.is_damaged()) {
                    str.push(gamedata['strings']['cursors']['damaged']);
                } else if(resname) {
                    // get % fullness relative to max undestroyed storage capacity
                    var fullness = get_storage_fullness(resname);
                    if(session.viewing_ai || session.viewing_base.base_id != session.viewing_player_home_base_id) {
                        // no info
                    } else {
                        str.push(gamedata['strings']['cursors']['fullness'].replace('%pct',(100*fullness).toFixed(0)));
                    }
                }
            } else if(obj.is_producer() && !obj.is_under_construction()) {
                if(obj.is_upgrading()) {
                    str.push(gamedata['strings']['cursors']['upgrading']);
                } else if(obj.team === 'player') {
                    var contents = obj.interpolate_contents();
                    var ui_contents = pretty_print_number(Math.floor(contents));
                    if(obj.produce_rate > 0 && obj.produce_rate < 1000 && contents < 10) {
                        // slow harvester - show fractional amounts
                        ui_contents += '.'+pad_with_zeros(Math.floor(100*(contents-Math.floor(contents))).toString(), 2);
                    }
                    var capacity = obj.get_production_capacity();
                    str.push(ui_contents+'/'+pretty_print_number(capacity));
                }
            }
        }

        // enhancement information
        if(obj.team === 'player' || gamedata['enemy_tooltip_detail'][obj.spec['kind']]) {
            if(obj.is_mobile()) {
                // mod techs
                var STAT_NAMES = gamedata['strings']['cursors']['mod_types'];
                var tech_dict = null;
                if(obj.team === 'player') {
                    tech_dict = player.tech;
                } else if(obj.team === 'enemy') {
                    tech_dict = enemy.tech;
                }
                if(tech_dict) {
                    for(var name in STAT_NAMES) {
                        var tech_name = obj.spec['name']+name;
                        if(tech_name in tech_dict) {
                            str.push('L'+tech_dict[tech_name].toFixed(0)+' '+STAT_NAMES[name]+' Mod');
                        }
                    }
                }
            }

            if(player.get_any_abtest_value('enable_equipment', gamedata['client']['enable_equipment'])) {
                // list equipped items

                var equip = null;
                if(obj.is_building()) {
                    equip = obj.equipment;
                } else if(obj.is_mobile() && player.get_any_abtest_value('enable_unit_equipment', gamedata['client']['enable_unit_equipment'])) {
                    var eqdic = (obj.team === 'player' ? player.unit_equipment : enemy.unit_equipment);
                    if(eqdic) {
                        equip = eqdic[obj.spec['name']] || null;
                    }
                }

                if(equip) {
                    for(var slot_type in equip) {
                        if(!player.is_cheater && ('show' in gamedata['strings']['equip_slots'][slot_type]) && !gamedata['strings']['equip_slots'][slot_type]['show']) { continue; }

                        var item_list = equip[slot_type];
                        for(var i = 0; i < item_list.length; i++) {
                            if(item_list[i]) {
                                var espec = ItemDisplay.get_inventory_item_spec(item_list[i]);
                                str.push(ItemDisplay.get_inventory_item_ui_name(espec));
                            }
                        }
                    }
                }

                if(obj.is_building() && obj.is_minefield() && !obj.is_minefield_armed()) {
                    str.push(gamedata['strings']['cursors']['no_mine_equipped']);
                    mouse_tooltip.text_color = SPUI.make_colorv([1,0,0,1]);
                }
            }
        }

        var pos = mouse_state.hovering_over.interpolate_pos();
        var alt = (mouse_state.hovering_over.is_mobile() && mouse_state.hovering_over.is_flying() ?
                   mouse_state.hovering_over.altitude - 1 : 0);

        if(!spin_secure_mode && player.is_developer()) {
            str.push('Coords: '+pos[0].toFixed(0)+','+pos[1].toFixed(0));
        }

        mouse_tooltip.str = str.join('\n');

        // have to pre-measure here since setting xy requires a correct value for this.wh[0]
        mouse_tooltip.wh = mouse_tooltip.font.measure_string(mouse_tooltip.str);

        // reposition the tooltip so it tracks objects on the landscape
        mouse_tooltip.xy = ortho_to_screen_3d([pos[0],alt,pos[1]]);
        mouse_tooltip.xy[0] = Math.floor(mouse_tooltip.xy[0] - mouse_tooltip.wh[0]/2);
        mouse_tooltip.xy[1] = Math.floor(mouse_tooltip.xy[1] + 30);
    };
}

function do_on_mousemove_update_drag_selection(xmin, xmax, ymin, ymax, add_to_selection) {
    // do not change selection during move_rover_action tutorial step
    if(player.tutorial_state != 'move_rover_action') {
        var units = find_objects_in_screen_rect([xmin,ymin], [xmax,ymax], null);

        if(add_to_selection) {
            // add to existing selection
            for(var i = 0; i < units.length; i++) {
                add_unit_to_selection(units[i]);
            }
        } else {
            // replace existing selection
            selection.multi = units;
        }

        if(player.tutorial_state === 'click_on_rover_action') {
            for(var i = 0; i < selection.multi.length; i++) {
                if(selection.multi[i].spec['name'] === gamedata['tutorial'][player.tutorial_state]['unit_type']) {
                    advance_tutorial();
                }
            }
        }

        // deselect selection.unit if it is not a member of selection.multi
        var keep_selection_unit = false;
        for(var i = 0; i < selection.multi.length; i++) {
            if(selection.multi[i] === selection.unit) {
                keep_selection_unit = true;
                break;
            }
        }
        if(!keep_selection_unit) {
            selection.unit = null;
        }

        if(selection.multi.length > 0 && !selection.unit) {
            // set selection.unit so multi-unaware code does the right thing
            selection.unit = selection.multi[0];
        }
    }
}

function on_mousewheel(e) {
   try {
       do_on_mousewheel(e);
   } catch (ex) {
       log_exception(ex, 'do_on_mousewheel');
   }
}

function do_on_mousewheel(e) {
    if(client_state != client_states.RUNNING) { return; }
    // get canvas coordinates of mouse pointer location
    var xy = event_to_canvas(e);

    var delta = 0;
    if(e.wheelDelta) {
        delta = e.wheelDelta / 60;
    } else if(e.detail) {
        delta = -e.detail;
    }

    if(SPUI.root.on_mousewheel(xy, [0,0], delta)) {
        if(e.preventDefault) { e.preventDefault(); }
        return;
    }
}

function on_mousemove(e) {
   try {
       do_on_mousemove(e);
    } catch (ex) {
        log_exception(ex, 'do_on_mousemove');
    }
}

function do_on_mousemove(e) {
    // do not fire event until server connection
    if(client_state != client_states.RUNNING) { return; }

    e.preventDefault();

    var allow_scroll = true;
    if(player.tutorial_state != "COMPLETE" &&
       ('disable_landscape_clicks' in gamedata['tutorial'][player.tutorial_state])) {
        allow_scroll = false;
    }

    // perform cleanup on first GUI event received after Facebook dialog goes away
    Store.force_order_cleanup();

    // get canvas coordinates of mouse pointer location
    var xy = event_to_canvas(e);
    var x = xy[0], y = xy[1];
    mouse_state.last_raw_x = x; mouse_state.last_raw_y = y;

    tutorial_root.on_mousemove(xy, [0,0]);
    if(!mouse_state.has_scrolled && !mouse_state.has_dragged) {
        if(SPUI.root.on_mousemove(xy, [0,0])) {
            // if SPUI handles the mousemove, that means the mouse is over
            // some UI element, so do not display the landscape tooltips
            if(mouse_state.hovering_over && mouse_tooltip) {
                mouse_tooltip.onleave();
            }
            mouse_state.hovering_over = null;
            return;
        }
    }

    // mouse tooltip processing. Skip if game not loaded, or in combat.
    if(session.viewing_base && !session.has_attacked) {
        var found = find_object_at_screen_pixel(xy, screen_to_ortho(xy), true);
        if(mouse_state.hovering_over != found) {
            if(mouse_state.hovering_over && mouse_tooltip) {
                mouse_tooltip.onleave();
            }
            mouse_state.hovering_over = found;
            if(mouse_state.hovering_over) {
                create_mouse_tooltip();
            } else {
                if(mouse_tooltip) {
                    mouse_tooltip.onleave();
                }
            }
        }
    } else {
        if(mouse_tooltip) { mouse_tooltip.onleave(); }
    }

    if(x != mouse_state.last_x || y != mouse_state.last_y) {
        if(mouse_state.get_button(SPUI.LEFT_MOUSE_BUTTON) && allow_scroll) {
            // scroll view
            var dx = x - mouse_state.last_x;
            var dy = y - mouse_state.last_y;
            view_pos[0] -= dx/view_zoom;
            view_pos[1] -= dy/view_zoom;
            view_pos[0] = clamp(view_pos[0], view_limits[0][0], view_limits[0][1]);
            view_pos[1] = clamp(view_pos[1], view_limits[1][0], view_limits[1][1]);

            mouse_state.drag_start_x += dx;
            mouse_state.drag_start_y += dy;

            if(!mouse_state.has_scrolled) {
                mouse_state.has_scrolled = true;
                mouse_state.scroll_start_x = x;
                mouse_state.scroll_start_y = y;
            }

            force_scroll_state.key = null; // kill current forced scroll move, if any

            // stop dripper, but only if the scroll is going to be a very large one. Ignore small moves.
            if(mouse_state.dripper.times_fired < 1 &&
               Math.max(Math.abs(x-mouse_state.scroll_start_x),
                        Math.abs(y-mouse_state.scroll_start_y)) >= gamedata['client']['mouse_scroll_dead_zone_dripper']) {
                mouse_state.dripper.stop(); // abort current drip operation
            }
        }
        if(player.unit_micro_enabled() && (mouse_state.get_button(SPUI.RIGHT_MOUSE_BUTTON) || mouse_state.spacebar)) {
            // drag-select
            if(!mouse_state.has_dragged) {
                mouse_state.has_dragged = true;
                mouse_state.drag_start_x = x;
                mouse_state.drag_start_y = y;
            } else {
                var xmin = Math.min(x, mouse_state.drag_start_x);
                var xmax = Math.max(x, mouse_state.drag_start_x);
                var ymin = Math.min(y, mouse_state.drag_start_y);
                var ymax = Math.max(y, mouse_state.drag_start_y);

                do_on_mousemove_update_drag_selection(xmin, xmax, ymin, ymax, !!e.shiftKey);
            }
        }

        if(mouse_state.button != SPUI.LEFT_MOUSE_BUTTON) {
            // remove pop-up UI ONLY if it's a context menu
            if(player.tutorial_state == "COMPLETE" &&
               selection.ui != null &&
               selection.ui.user_data &&
               'dialog' in selection.ui.user_data &&
               selection.ui.user_data['dialog'] === 'context_menu') {
                change_selection_ui(null);
            }
        }

    }

    mouse_state.last_x = x; mouse_state.last_y = y;
    // draw(); may cause performance problems
}

// emulate a regular mouse event based on a TouchEvent
function touch_emulate_mouse(e, touchevt) {
    return {'pageX': touchevt.pageX,
            'pageY': touchevt.pageY,
            'preventDefault': function() {},
            'ctrlKey': e.ctrlKey,
            'shiftKey': e.shiftKey,
            'button':0
           };
};

function on_touchstart(e) {
//    console.log('TOUCHSTART');
    e.preventDefault();
    if(e.changedTouches.length < 1) { return; }
    on_mousedown(touch_emulate_mouse(e, e.changedTouches[0]));
    mouse_state.has_dragged = false;
}

function on_touchend(e) {
//    console.log('TOUCHEND');
    e.preventDefault();
    if(e.changedTouches.length < 1) { return; }

    if(mouse_state.has_dragged) {
        mouse_state.has_dragged = false;
        if(e.targetTouches.length > 0) {
            var xy = event_to_canvas(e.targetTouches[0]);
            mouse_state.last_x = xy[0]; mouse_state.last_y = xy[1];
        }
    } else {
        on_mouseup(touch_emulate_mouse(e, e.changedTouches[0]));
    }
    mouse_state.has_dragged = false;
}

function on_touchmove(e) {
    e.preventDefault();
    if(e.changedTouches.length < 1) { return; }

        if(e.targetTouches.length > 1 && player.unit_micro_enabled()) {
            // two-finger multi-select
            var xy0 = event_to_canvas(e.targetTouches[0]);
            var xy1 = event_to_canvas(e.targetTouches[1]);

            mouse_state.last_x = xy1[0];
            mouse_state.last_y = xy1[1];

            if(!mouse_state.has_dragged) {
                mouse_state.has_dragged = true;
                mouse_state.drag_start_x = xy0[0];
                mouse_state.drag_start_y = xy0[1];
            } else {
                var xmin = Math.min(xy0[0], xy1[0]);
                var xmax = Math.max(xy0[0], xy1[0]);
                var ymin = Math.min(xy0[1], xy1[1]);
                var ymax = Math.max(xy0[1], xy1[1]);

                do_on_mousemove_update_drag_selection(xmin, xmax, ymin, ymax, false);
            }
        } else {
            on_mousemove(touch_emulate_mouse(e, e.changedTouches[0]));
        }
}

// we handle MSPointer events mostly the same as ordinary mouse events, just with some
// special tracking for multi-touch selection

// map of pointerId to {pageX, pageY} - conveniently makes event_to_canvas() work
var mspointer_state = {};
function on_MSPointerDown(e) {
    mspointer_state[e.pointerId] = {pageX: e.pageX, pageY: e.pageY};
    return on_mousedown(e);
}
function on_MSPointerUp(e) {
    if(e.pointerId in mspointer_state) { delete mspointer_state[e.pointerId]; }

    if(mouse_state.has_dragged) {
        mouse_state.has_dragged = false;
        var xy = event_to_canvas(e);
        mouse_state.last_x = xy[0]; mouse_state.last_y = xy[1];
        e.preventDefault();
    } else {
        return on_mouseup(e);
    }
}
function on_MSPointerOut(e) {
    if(e.pointerId in mspointer_state) { delete mspointer_state[e.pointerId]; }
    return false;
}
function on_MSPointerMove(e) {
    mspointer_state[e.pointerId] = {pageX: e.pageX, pageY: e.pageY};
    var count = 0;
    var pointer0 = null, pointer1 = null;
    for(var id in mspointer_state) {
        count += 1;
        if(!pointer0) {
            pointer0 = mspointer_state[id];
        } else if(!pointer1) {
            pointer1 = mspointer_state[id];
        }
    }

    if(e.pointerType===e.MSPOINTER_TYPE_TOUCH) { touch_primary = true; }

    if((e.pointerType===e.MSPOINTER_TYPE_TOUCH) && (count >= 2) && player.unit_micro_enabled()) {
        // two-finger multi-select
        e.preventDefault();
        var xy0 = event_to_canvas(pointer0);
        var xy1 = event_to_canvas(pointer1);

        mouse_state.last_x = xy1[0];
        mouse_state.last_y = xy1[1];

        if(!mouse_state.has_dragged) {
            mouse_state.has_dragged = true;
            mouse_state.drag_start_x = xy0[0];
            mouse_state.drag_start_y = xy0[1];
        } else {
            var xmin = Math.min(xy0[0], xy1[0]);
            var xmax = Math.max(xy0[0], xy1[0]);
            var ymin = Math.min(xy0[1], xy1[1]);
            var ymax = Math.max(xy0[1], xy1[1]);

            do_on_mousemove_update_drag_selection(xmin, xmax, ymin, ymax, false);
        }
    } else {
        return on_mousemove(e);
    }
}

SPINPUNCHGAME.first_action_sent = false;

function register_player_input() {
    input_since_last_xmit = true;
    input_since_last_proxy_xmit = true;
    if(!SPINPUNCHGAME.first_action_sent &&
       (client_state != client_states.LOADING)) { // wait until logged in (or prevented from logging in, after successful connection attempt) before sending
        SPINPUNCHGAME.first_action_sent = true;
        SPLWMetrics.send_event(spin_metrics_anon_id, '0125_first_action', add_demographics({}));
    }
}

function on_mousedown(e) {
   try {
       do_on_mousedown(e);
   } catch (ex) {
       log_exception(ex, 'do_on_mousedown');
   }
}

function do_on_mousedown(e) {
    canvas.focus();
    register_player_input();

    e.preventDefault();
    mouse_state.set_button(e.button);

    // get canvas coordinates of mouse-click location
    var xy = event_to_canvas(e);
    // first let SPUI handle it
    if(tutorial_root.on_mousedown(xy, [0,0], e.button)) {
        return;
    }
    if(player.quest_root.on_mousedown(xy, [0,0], e.button)) {
        return;
    }
    if(SPUI.root.on_mousedown(xy, [0,0], e.button)) {
        return;
    }

    if(e.button == 0) {
        // reset scroll
        mouse_state.has_scrolled = false;
    }
    if(e.button == 2) {
        // reset drag
        mouse_state.has_dragged = false;
    }

    var x = xy[0], y = xy[1];
    mouse_state.last_x = x; mouse_state.last_y = y;

    hitloc[0] = x; hitloc[1] = y;

    // if a popout UI is active, get rid of it
    if(selection.ui &&
       selection.ui.user_data &&
       'dialog' in selection.ui.user_data &&
       selection.ui.user_data['dialog'].indexOf('popout') != -1) {
        change_selection_ui(null);
    }

    // awkward special case for SG unit deployment
    // this has to fire on mousedown, not mouseup for "dripping" to work properly
    // so it cannot go together with the usual mouseup handling
    if(gamedata['unit_deploy_style'] == 'drip' && selection.spellname === "DEPLOY_UNITS") {
        APMCounter.record_action();

        var deployment_dripper_callback = function(mouse_xy) {
            var ji = screen_to_ortho(mouse_xy);
            if(!session.viewing_base.is_deployment_location_valid(ji)) {
                return;
            }
            var obj = null;
            // pick the first one
            for(var obj_id in session.pre_deploy_units) {
                obj = session.pre_deploy_units[obj_id];
                // predict new space accounting
                if(obj['source'] !== 'donated') {
                    session.deployed_unit_space += get_leveled_quantity(gamedata['units'][obj['spec']]['consumes_space'] || 0, obj['level']||1);
                }
                break;
            }
            if(obj) {
                do_deploy(ji, [obj]);
            } else {
                // nothing left
                mouse_state.dripper.stop();
            }
        }

        mouse_state.dripper.reset(deployment_dripper_callback,
                                  gamedata['client']['drip_deployment_rate'],
                                  client_time + gamedata['client']['drip_startup_delay']);
    }
}

function do_unit_command_attack(unit, target, add_waypoint) {
    if(target.is_destroyed() || target.is_indestructible()) { return; }
    if(!unit.is_shooter()) { return; }
    if(unit === target) { return; }
    if(!unit.can_shoot_at(target)) { return; }

    unit.new_order({'state': ai_states.AI_ATTACK_SPECIFIC,
                    'target': target.id},
                   !add_waypoint);
    //unit.ai_state = ai_states.AI_ATTACK_SPECIFIC;
    //unit.ai_target = target;
}

function unit_command_attack(target, add_waypoint) {
    if(!selection.unit) { return; }

    selection.unit.speak('attack');

    do_unit_command_attack(selection.unit, target, add_waypoint);
    for(var i = 0; i < selection.multi.length; i++) {
        do_unit_command_attack(selection.multi[i], target, add_waypoint);
    }
}

function do_unit_command_patrol(unit) {
    var patrol_ai_state = ai_state_values[gamedata['default_patrol_ai_state']];

    if(!unit.patrol) {
        // start the patrol - append new order sending unit back to start position
        var start_pos = unit.interpolate_pos();
        unit.new_order({'state':patrol_ai_state,
                        'patrol_origin': 1,
                        'dest': [Math.floor(start_pos[0]),Math.floor(start_pos[1])]}, false);
        unit.state_dirty |= obj_state_flags.ORDERS;
    }

    var found_origin = false;
    for(var i = 0; i < unit.orders.length; i++) {
        var ord = unit.orders[i];
        ord['state'] = patrol_ai_state;
        unit.state_dirty |= obj_state_flags.ORDERS;
        if(ord['patrol_origin']) { found_origin = true; }
    }

    // make sure there is a patrol_origin in the path
    if(!found_origin && unit.orders.length >= 1) {
        unit.orders[unit.orders.length-1]['patrol_origin'] = 1;
    }

    unit.ai_state = patrol_ai_state;
    unit.patrol = true;
    unit.state_dirty |= obj_state_flags.PATROL;
}

function unit_command_patrol(j, i) {
    if(!selection.unit || !selection.unit.is_mobile()) { return; }

    player.record_feature_use('unit_patrol_command');

    unit_command_move(j, i, true, true);

    do_unit_command_patrol(selection.unit);
    goog.array.forEach(selection.multi, function(obj) {
        do_unit_command_patrol(obj);
    });
}

function do_unit_command_make_aggressive(unit) {
    for(var i = 0; i < unit.orders.length; i++) {
        if(unit.orders[i]['state'] != ai_states.AI_ATTACK_MOVE &&
           unit.orders[i]['state'] != ai_states.AI_ATTACK_ANY) {
            unit.orders[i]['state'] = ai_states.AI_ATTACK_ANY;
        }

        unit.orders[i]['aggressive'] = true;
    }
    unit.state_dirty |= obj_state_flags.ORDERS;
    unit.apply_orders();
    //var order = {'state': ai_states.AI_ATTACK_ANY, 'aggressive': true};
    //unit.new_order(order, true);
}

function unit_command_make_aggressive() {
    if(!selection.unit || !selection.unit.is_mobile()) { return; }

    do_unit_command_make_aggressive(selection.unit);
    for(var i = 0; i < selection.multi.length; i++) {
        do_unit_command_make_aggressive(selection.multi[i]);
    }
}

function unit_command_move(j, i, use_amove, add_waypoint) {
    if(!selection.unit || !selection.unit.is_mobile()) { return; }

    SPFX.add_under(new SPFX.ClickFeedback([j,i], [1,1,1,1], client_time, client_time + 0.15));

    if(!add_waypoint || selection.unit.orders.length < 2) {
        selection.unit.speak('destination');
    }

    var force_attack_move_for_tutorial = ((player.tutorial_state === 'move_rover_action') || (player.tutorial_state === 'wait_for_battle_finish'));
    if(force_attack_move_for_tutorial) { use_amove = true; }

    // automatically append a-move if path already contains some non-normal movement
    if(add_waypoint && selection.unit.orders.length > 0 && selection.unit.orders[selection.unit.orders.length-1]['state'] != ai_states.AI_MOVE) {
        use_amove = true;
    }

    var use_state;
    if(use_amove) {
        if(selection.unit.patrol) {
            use_state = ai_state_values[gamedata['default_patrol_ai_state']];
        } else {
            if(get_preference_setting(player.preferences, 'auto_unit_control_dmove') && !force_attack_move_for_tutorial) {
                use_state = ai_states.AI_DEFEND_MOVE;
            } else {
                use_state = ai_states.AI_ATTACK_MOVE;
            }
        }
    } else {
        use_state = ai_states.AI_MOVE;
    }
    var my_order = {'state': use_state,
                    'dest': [j,i]};

    // EXPERIMENTAL
    // when in hostile territory and on auto_unit_control, make all player-initiated movement aggressive
    // otherwise, cancel aggressive mode
    var aggressive = (session.viewing_base.base_landlord_id !== session.user_id) &&
        ((get_preference_setting(player.preferences, 'auto_unit_control') && !get_preference_setting(player.preferences, 'auto_unit_control_dmove')) ||
         (('deploy_ai_order' in selection.unit.spec) && selection.unit.spec['deploy_ai_order']['aggressive']) ||
         gamedata['client']['default_deploy_ai_order']['manual']['aggressive']
        );
    my_order['aggressive'] = !!aggressive;

    selection.unit.new_order(my_order, !add_waypoint);
    selection.unit.feedback_pending = true;

    if(selection.multi.length > 0) {
        // formation movement referenced against selection.unit
        var origin = selection.unit.interpolate_pos();
        var FORMATION_RADIUS2 = 20*20; // how close units must be in order to be considered "in formation"

        for(var n = 0; n < selection.multi.length; n++) {
            if(selection.multi[n] === selection.unit) {
                continue;
            }
            var mydest = [j,i];
            var offset = vec_sub(selection.multi[n].interpolate_pos(), origin);
            if(vec_length2(offset) <= FORMATION_RADIUS2) {
                mydest = vec_add([j,i], offset);
                var ncells = session.viewing_base.ncells();
                mydest = [clamp(mydest[0], 0, ncells[0]-1),
                          clamp(mydest[1], 0, ncells[1]-1)];
                // check if the formation-movement destination is blocked. If so, just send it directly to dest
                mydest = vec_floor(mydest);
                if(astar_map.is_blocked(mydest)) {
                    mydest = [j,i];
                }
            }

            var form_order = goog.object.clone(my_order);
            form_order['dest'] = mydest;

            var form_aggressive = (session.viewing_base.base_landlord_id !== session.user_id) &&
                ((get_preference_setting(player.preferences, 'auto_unit_control') && !get_preference_setting(player.preferences, 'auto_unit_control_dmove')) ||
                 (('deploy_ai_order' in selection.multi[n].spec) && selection.multi[n].spec['deploy_ai_order']['aggressive']) ||
                 gamedata['client']['default_deploy_ai_order']['manual']['aggressive']
                );
            form_order['aggressive'] = !!form_aggressive;

            selection.multi[n].new_order(form_order, !add_waypoint);
            selection.multi[n].feedback_pending = true;
        }
    }

    if(player.tutorial_state === 'move_rover_action') {
        tutorial_step_move_rover_action_command();
    }
}


function on_textInput(e) {
    console.log('textInput '+e.data);
};

function on_pointer_lock_change(e) {
    if(document['webkitPointerLockElement'] === canvas) {
        console.log("POINTER LOCK ON");
        mouse_state.pointer_locked = true;
        mouse_state.pointer_lock_origin = [mouse_state.last_x, mouse_state.last_y];
    } else {
        console.log("POINTER LOCK OFF");
        mouse_state.pointer_locked = false;
        mouse_state.pointer_lock_origin = [-1,-1];
    }
};

function on_keypress(e) {
    if(e.which != 0 && e.charCode != 0) {
        //console.log('KEYPRESS ' + e.which);
        var str = String.fromCharCode(e.which);

        if(SPUI.keyboard_focus) {
            if(SPUI.keyboard_focus.onkeypress(e.which, str)) {
                // do not continue processing
                if(e.preventDefault) { e.preventDefault(); }
                return false;
            }
        }

        // WoW-like shortcut to focus chat
        if(str === '/' || str === 't') {
            if(global_chat_frame && global_chat_frame.is_visible()) {
                var w = global_chat_frame.widgets['input'];
                w.str = '';
                SPUI.set_keyboard_focus(w);
                if(e.preventDefault) { e.preventDefault(); }
                return false;
            }
        } else if(str === 'f') {
            fps_counter.show = !fps_counter.show;
        } else if(str === 'm') {
            if(!selection.unit) { toggle_region_map(); }
        } else if(str === 'l') {
            if(pointer_lock_supported) {
                if(!mouse_state.pointer_locked) {
                    canvas['webkitRequestPointerLock']();
                } else {
                    document['webkitExitPointerLock']();
                }
            }
        }
    }
    return true;
}

var key_unit_command_map = {
    //8: 'REMOVE_OBJECT', // backspace
    46: 'REMOVE_OBJECT', // delete key
    69: 'SPECIAL_ABILITY', // e E
    109: 'MOVE_UNIT', 77: 'MOVE_UNIT', // m M
    97: 'AMOVE_UNIT', 65: 'AMOVE_UNIT', // a A
    115: 'STOP_UNIT', 83: 'STOP_UNIT', // s S
    112: 'PATROL_UNIT', 80: 'PATROL_UNIT', // p P
    114: 'MAKE_AGGRESSIVE', 82: 'MAKE_AGGRESSIVE' // r R
};

function on_keydown(e) {
    register_player_input();

    var code = e.keyCode;
    //console.log('KEYDOWN ' + code);

    // escape key to get out of dialogs/chat
    if(player.tutorial_state === "COMPLETE" && code === 27) {
        if(selection.ui) {
            if(selection.ui.modal || (selection.ui.user_data && selection.ui.user_data['dialog'])) {
                // if it's a dialog, ensure that the close button is available
                if(selection.ui.widgets && 'close_button' in selection.ui.widgets &&
                   selection.ui.widgets['close_button'].show && selection.ui.widgets['close_button'].state != 'disabled' &&
                   !find_dialog('ui_locker')) {
                    // ok it's safe to close the dialog
                    var btn = selection.ui.widgets['close_button'];
                    if(btn.bg_image && GameArt.assets[btn.bg_image].states[btn.state].audio) {
                        GameArt.assets[btn.bg_image].states[btn.state].audio.play(client_time);
                    }
                    btn.onclick(btn);
                }
            } else if(selection.spellname) {
                if(selection.spellname == "DEPLOY_UNITS" && !session.has_deployed) {
                    selection.ui.destroy(); // if not in combat, reset unit count to zero but do NOT remove cursor
                } else {
                    // cancel targeted spell
                    change_selection_ui(null);
                    selection.spellname = null;
                }
            }
        } else {
            change_selection(null);
        }
        if(global_chat_frame && global_chat_frame.is_visible()) {
            if(SPUI.keyboard_focus === global_chat_frame.widgets['input']) {
                SPUI.set_keyboard_focus(null);
            }
        }

        if(e.preventDefault) { e.preventDefault(); }
        return false;
    }

    if(SPUI.keyboard_focus) {
        if(SPUI.keyboard_focus.onkeydown(code)) {
            if(e.preventDefault) { e.preventDefault(); }
            return false;
        }
        // skip unit commands and continue processing
        // EVEN IF SPUI does not consider the event "handled",
        // because if may produce a subsequent onkeypress event!
        return true;
    }

    if(code === 13) { // ENTER key
        var button = null;
        if(selection.ui) {
            button = selection.ui.default_button || null;
            // hack - handle nested dialogs
            if(selection.ui.children) {
                for(var i = 0; i < selection.ui.children.length; i++) {
                    if(selection.ui.children[i].default_button) {
                        button = selection.ui.children[i].default_button;
                    }
                }
            }
        } else if(tutorial_root.children.length >= 1 && tutorial_root.children[0].default_button) {
            button = tutorial_root.children[0].default_button;
        }
        if(button && button.is_clickable() && button.onclick) {
            button.onclick(button);
            if(e.preventDefault) { e.preventDefault(); }
            return false;
        }

        // if build spell is armed, fire it
        if(selection.spellname == "BUILD") {
            do_build(screen_to_ortho([mouse_state.last_x, mouse_state.last_y]));
            if(e.preventDefault) { e.preventDefault(); }
            return false;
        }

        // if a building is under construction, offer to speed it up (not during tutorial
        if(player.tutorial_state == "COMPLETE") {
            for(var id in session.cur_objects.objects) {
                var obj = session.cur_objects.objects[id];
                if(obj.is_building() && obj.team == 'player' && obj.is_under_construction()) {
                    change_selection(obj);
                    invoke_speedup_dialog('speedup');
                    if(e.preventDefault) { e.preventDefault(); }
                    return false;
                }
            }
        }
    }

    // 0-9 control group keys
    if(player.tutorial_state === "COMPLETE" && code >= 48 && code <= 57) {
        var group = code - 48;
        //console.log('group '+group.toString()+' '+e.shiftKey+' '+e.ctrlKey);
        if(e.ctrlKey && !e.shiftKey) {
            control_group_define(group);
        } else if(e.ctrlKey && e.shiftKey) {
            control_group_add(group);
        } else if(e.shiftKey) {
            control_group_toggle(group);
        } else {
            control_group_activate(group);
        }
        // do not continue keypress processing
        if(e.preventDefault) { e.preventDefault(); }
        return false;
    }

    // left arrow 37 right arrow 39 up arrow 38 down arrow 40 pgup 33 pgdown 34
    /*
    if(player.tutorial_state === "COMPLETE") {
        var scroll = null;
        if(code == 37 || code == 38 || code == 33) {
            scroll = 'scroll_left';
        } else if (code == 39 || code == 40 || code == 34) {
            scroll = 'scroll_right';
        }
    }
    */

    // spacebar
    if(code == 32) {
        mouse_state.spacebar = true;
        // do not continue keypress processing
        if(e.preventDefault) { e.preventDefault(); }
        return false;
    }

    if(code in key_unit_command_map && key_unit_command_map[code] === 'SPECIAL_ABILITY' && session.has_attacked) {
        if(global_spell_icon) { global_spell_icon.pushed_key = true; }
    }

    return true; // continue on to keypress processing
}

function on_keyup(e) {
    var code = e.keyCode;
    //console.log('KEYUP ' + code);

    if(SPUI.keyboard_focus) { return true; } // event should have been handled already

    if(selection.unit && selection.unit.is_mobile()) {
        if(code in key_unit_command_map) {
            var cmd = key_unit_command_map[code];
            if(cmd === 'SPECIAL_ABILITY') {
                if(session.has_attacked || player.is_cheater) {
                    if(global_spell_icon) { global_spell_icon.pushed_key = false; }
                    selection.unit.use_special_ability();
                    for(var j = 0; j < selection.multi.length; j++) {
                        if(selection.multi[j] === selection.unit) { continue; }
                        selection.multi[j].use_special_ability();
                    }
                }
            } else if(cmd === 'STOP_UNIT') {
                var order = {'state': ai_states.AI_ATTACK_STATIONARY, 'aggressive': false};
                selection.unit.new_order(order, true);
                selection.unit.ai_threatlist = null; selection.unit.ai_threatlist_dirty = true;
                for(var i = 0; i < selection.multi.length; i++) {
                    selection.multi[i].new_order(order, true);
                    selection.multi[i].ai_threatlist = null; selection.multi[i].ai_threatlist_dirty = true;
                }
            } else if(cmd === 'MAKE_AGGRESSIVE') {
                unit_command_make_aggressive();
            } else if(cmd === 'REMOVE_OBJECT' && player.is_cheater) {
                send_and_remove_object(selection.unit);
                var temp = goog.array.clone(selection.multi); // send_and_remove mutates selection.multi
                for(var i = 0; i < temp.length; i++) {
                    send_and_remove_object(temp[i]);
                }
            } else {
                // "arm" the spell for the next mousedown
                selection.spellname = cmd;
                var cursor;
                if(cmd === 'AMOVE_UNIT' || cmd === 'PATROL_UNIT') {
                    cursor = make_shoot_cursor();
                } else {
                    cursor = make_move_cursor();
                }
                change_selection_ui(cursor);
            }
            APMCounter.record_action();
            // do not continue keypress processing
            if(e.preventDefault) { e.preventDefault(); }
            return false;
        }
    }

    if(code == 32) { // spacebar
        if(mouse_state.has_dragged) {
            mouse_state.has_dragged = false;
            if(selection.multi.length > 1) {
                player.record_feature_use('drag_select');
            }
        }
        mouse_state.spacebar = false;
    } else if(code == 16) { // shift
        // get rid of move/amove/build cursors
        if(selection.spellname != null) {
            selection.spellname = null;
            change_selection_ui(null);
        }
    }

    return true;
}

function change_backdrop_music(new_backdrop_music) {
    if(new_backdrop_music != backdrop_music) {
        if(backdrop_music != null) {
            backdrop_music.unloop();
            if(GameArt.music_volume > 0) {
                backdrop_music.fadeOut(1000);
            } else {
                backdrop_music.stop(client_time);
            }

            backdrop_music = null;
        }
        backdrop_music = new_backdrop_music;
        if(backdrop_music) {
            //backdrop_music.stop(client_time);

            if(GameArt.music_volume > 0) {
                backdrop_music.loop();

                // setTime causes audio to stop playing on Firefox
                if(spin_demographics['browser_name'] === 'Explorer') {
                    backdrop_music.setTime(0);
                    backdrop_music.play(client_time);
                }

                backdrop_music.fadeTo(50, 1500);
            }
        }
    }
}

var APMCounter = {
    start_time: -1,
    actions: 0
};
APMCounter.reset = function() {
    APMCounter.start_time = client_time;
    APMCounter.actions = 0;
};
APMCounter.record_action = function() { APMCounter.actions += 1; };
APMCounter.get = function() {
    if(APMCounter.start_time > 0) {
        return (60.0*APMCounter.actions)/(client_time - APMCounter.start_time);
    }
    return -1;
};

/** @constructor */
var FPSCounter = function() {
    this.cur_fps = 0;
    this.last_time = 0;
    this.frame_count = 0;
    this.update_interval = 20; // # of frames between updates

    this.metric_interval = 3000; // # of seconds between framerate metric transmissions
    this.first_metric_interval = 60; // # of seconds after game start before metrics will be transmitted
    this.metric_wait = -1;
    this.last_metric = -1;
    this.show = false;
    this.transmit_metrics = false;
};

FPSCounter.prototype.get = function() {
    if(this.frame_count >= this.update_interval && FRAME_RATE_CAP >= 10) {
        this.frame_count = 0;
        this.cur_fps = this.update_interval / (client_time - this.last_time);
        this.last_time = client_time;

        if(this.transmit_metrics) {
            if(this.last_metric === -1) {
                this.last_metric = client_time;
                this.metric_wait = this.first_metric_interval;
            } else if((client_time - this.last_metric) >= this.metric_wait) {
                this.last_metric = client_time;
                this.metric_wait = this.metric_interval;
                metric_event('0960_framerate', add_demographics({'framerate':this.cur_fps,
                                                                 'framerate_cap':FRAME_RATE_CAP,
                                                                 'server_time_offset':server_time_offset,
                                                                 'canvas_width':canvas_width,
                                                                 'canvas_height':canvas_height
                                                                }));
            }
        }
    }
    this.frame_count += 1;
    return this.cur_fps;
};

var fps_counter = new FPSCounter();

function sprobe_init(cb) {
    var on_result = (function (_cb) { return function(probe) {
        metric_event('0961_sprobe_result', {'viewing_base_id':session.viewing_base.base_id, 'report':probe.report()});
        if(_cb()) { _cb(); }
    }; })(cb);
    var probe = new SProbe.ProbeRun(on_result,
                                    spin_server_host, spin_server_http_port, spin_server_ssl_port,
                                    spin_game_server_host, spin_game_server_http_port, spin_game_server_ssl_port,
                                    spin_game_server_ws_port, spin_game_server_wss_port,
                                    (fps_counter ? fps_counter.cur_fps : -1), canvas_width, canvas_height);
    return probe;
}

var g_sprobe = null; // currently-running sprobe
function sprobe_run() {
    if(g_sprobe) { return; }
    g_sprobe = sprobe_init(function() { g_sprobe = null; });
    g_sprobe.go();
}

// last time draw() painted the screen *relative to client_time*
var last_draw_time = 0;

// force at least one canvas repaint to happen, regardless of FRAME_RATE_CAP
var forced_draw_timer = null;
function force_draw() {
    if(client_state != client_states.RUNNING && client_state != client_states.TIMED_OUT) {
        return;
    }
    if(!forced_draw_timer) {
        forced_draw_timer = window.setTimeout(function() {
            forced_draw_timer = null;
            do_draw();
        }, 1);
    }
};

function draw() {
    // update world time
    update_client_and_server_time();
    SPUI.time = client_time; SPFX.time = client_time;
    GameArt.sync_time(client_time);

    //console.log('frame at '+client_time+' last_draw_time '+last_draw_time);

    // check how much time has elapsed since last draw()
    if((client_time - last_draw_time) < (1/FRAME_RATE_CAP)) {
        // don't draw faster than target frame rate - wait for next refresh instead
        var delay = (1 / FRAME_RATE_CAP) - (client_time - last_draw_time);
        //console.log('waiting for '+delay*1000+' ms');
        window['requestAnimFrame'](draw, canvas, delay*1000);
        return;
    } else {
        //console.log('doing draw');
    }
    last_draw_time = client_time;

    try {
        do_draw();
    } catch (e) {
        // kill any active dialogs, in case they are causing repeated errors
        change_selection(null);
        log_exception(e, 'do_draw');
    }

    flush_message_queue(false);

    window['requestAnimFrame'](draw, canvas, 1000 / FRAME_RATE_CAP);
}

// sort objects by z-order for drawing
function sort_scene_objects(a,b) {
    var atemp = a.draw_pos_cache;
    var pa = atemp[0], za = atemp[1];
    var btemp = b.draw_pos_cache;
    var pb = btemp[0], zb = btemp[1];
    if(za == zb) {
        // break ties to avoid Z-fighting
        if(pa[0] == pb[0]) {
            if(pa[1] == pb[1]) {
                return 0;
            }
            return (pa[1] < pb[1] ? -1 : 1);
        }
        return (pa[0] < pb[0] ? -1 : 1);
    }
    return (za < zb ? -1 : 1);
}

// apply the transformation matrix for drawing the playfield
function set_playfield_draw_transform(context) {
    if(view_is_zoomed()) {
        // shift view so that view_pos puts center grid cell at middle of canvas
        var ncells = session.viewing_base.ncells();
        context.transform(view_zoom, 0, 0, view_zoom,
                          -view_pos[0]*view_zoom + canvas_width_half,
                          -view_pos[1]*view_zoom + canvas_height_half - view_zoom*cellsize[1]*ncells[1]/2);
    }
}

function do_draw() {
    if(forced_draw_timer) { window.clearTimeout(forced_draw_timer); forced_draw_timer = null; }

    // snoop canvas_div.offsetLeft/Top in case the browser reflowed without us knowing
    if(gamedata['client']['canvas_div_offset_snoop_time'] > 0 && (client_time - canvas_div_offset_snoop_time > gamedata['client']['canvas_div_offset_snoop_time'])) {
        canvas_div_offset_snoop_time = client_time;
        canvas_div_offsetLeft = canvas_div.offsetLeft;
        canvas_div_offsetTop = canvas_div.offsetTop;
        //console.log("SNOOP "+canvas_div_offsetTop);

        // also snoop Facebook iframe coordinates
        if(spin_frame_platform == 'fb' && spin_facebook_enabled && gamedata['client']['facebook_iframe_resize_hack'] && (typeof FB != 'undefined')) {
            fb_iframe_update(null);
        }
    }

    // set default graphics state
    ctx.font = SPUI.desktop_font.str();
    ctx.fillStyle = "#ffffff";
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1;

    if(client_state == client_states.UNABLE_TO_LOGIN || SPINPUNCHGAME.client_death_sent) { // TIMED_OUT gets handled below
        kill_loading_screen();

        // clear background
        ctx.fillRect(0,0,canvas_width,canvas_height);

        // this will display the error message dialog
        SPUI.draw_all();
    } else if(client_state == client_states.LOADING ||
              client_art_state == client_art_states.DOWNLOADING_ESSENTIAL) {

        /** @type {string} to display loading progress in the GUI */
        var msg;

        if(client_state == client_states.LOADING) {
            var data = gamedata['strings']['connecting_to_server'];
            var index = Math.floor((client_time/data['interval']) % data['frames'].length);
            msg = data['frames'][index];
        } else {
            var progress;
            if(gamedata['client']['delay_load_art']) {
                progress = GameArt.get_dl_progress_essential();
            } else {
                progress = GameArt.get_dl_progress_all();
            }
            msg = gamedata['strings']['loading_screen_loading'].replace('%pct',(100*progress).toFixed(0));
        }

        if(startup_div_shown) {
            document.getElementById('startup_msg').innerHTML = msg;
        } else {

        ctx.save();

        // clear to white
        ctx.fillRect(0,0,canvas_width,canvas_height);

        // draw "Loading..." screen

        // center image on canvas.
        var wh = [736,423]; // hard-coded image dimensions
        var x = Math.floor((canvas_width-wh[0])/2);
        var y = Math.floor((canvas_height-wh[1])/2);
        x = clamp(x, 0, canvas_width);
        y = clamp(y, 0, canvas_height);

        if(loading_screen_image.complete && loading_screen_image.width > 0) {
            try { // this sometimes fails on FireFox even if 'complete' is true
                ctx.drawImage(loading_screen_image, x, y);
            } catch (e) {}
            // use white text
        } else {
            // black text
            ctx.fillStyle = "#000000";
        }

        // fails on FireFox due to ctx garbage collection
        try {
            ctx.font = "bold 15px sans-serif";
        } catch(e) {}

        // because we're a Web 2.0 app, yo!
        ctx.fillText(gamedata['strings']['loading_screen_beta'], x+215, y+398);
        ctx.fillText(msg, x+450, y+398);
        ctx.restore();
        }

    } else if(client_state == client_states.RUNNING || client_state == client_states.TIMED_OUT) {
        kill_loading_screen();

        if(client_state == client_states.RUNNING && !visit_base_pending) {

        SPUI.dripper.activate(client_time);

        mouse_state.dripper.activate(client_time, [mouse_state.last_x, mouse_state.last_y]);

        // run deferred citizens update
        session.do_update_citizens();

        // run game simulation tick, if enough time has elapsed since last tick
        run_unit_ticks();

        // if enough time has elapsed, save combat damage states to server
        if(client_time - last_combat_save > gamedata['client']['combat_state_save_interval']) {
            last_combat_save = client_time;
            flush_dirty_objects({});
        }

        // try to free A* memory
        if(session.region && session.region.occupancy) { session.region.occupancy.cleanup(); }

        if(global_chat_frame) { update_chat_frame(global_chat_frame); }

        // if enough time has elapsed, send a ping message to the server
        if(client_state != client_states.TIMED_OUT) {
            if(!gamedata['client']['enable_ajax_longpoll'] && (client_time - last_server_ping > gamedata['client']['player_ping_interval'])) {
                last_server_ping = client_time;
                last_chat_ping = client_time;
                last_websocket_keepalive = client_time;
                send_to_server.func(["PING_PLAYER"]);
            } else if(desktop_dialogs['chat_frame'] && desktop_dialogs['chat_frame'].parent &&
                      (desktop_dialogs['chat_frame'].user_data['size'] === 'big') &&
                      (client_time - last_chat_ping > gamedata['client']['chat_ping_interval'])) {
                last_chat_ping = client_time;
                last_websocket_keepalive = client_time;
                send_to_server.func(["PING_CHAT", player.chat_seen, 'chat_ping']);
            } else if(the_websocket && gamedata['client']['websocket_keepalive_interval'] > 0 &&
                      (client_time - last_websocket_keepalive > gamedata['client']['websocket_keepalive_interval'])) {
                last_chat_ping = client_time;
                last_websocket_keepalive = client_time;
                send_to_server.func(["PING_CHAT", player.chat_seen, 'websocket_keepalive']);
            }
        }

        // send any pending user/alliance queries
        PlayerCache.launch_batch_queries(client_time, false);
        AllianceCache.launch_batch_queries();

        // perform squad movement
        player.advance_squads();

        // send lock state query
        if(!session.home_base && !session.has_attacked &&
           (!session.viewing_ai || session.is_remote_base()) &&
           !player.cooldown_active('lock_state_poll')) {
            player.cooldown_client_trigger('lock_state_poll', gamedata['lock_state_poll_cooldown']+1);
            send_to_server.func(["POLL_BASE_LOCK_STATE", session.viewing_base.base_type, session.viewing_base.base_id]);
        }

        // check if we need to send a keepalive to the proxy server
        if(spin_game_direct_connect &&
           (gamedata['client']['proxy_keepalive_interval'] > 0) &&
           (client_time - last_proxy_keepalive > gamedata['client']['proxy_keepalive_interval'])) {
            // send proxy keepalive regardless of input, since this is necessary to prevent login locking issues
            // the game server will take care of terminating idle sessions
            if(true || input_since_last_proxy_xmit) {
                input_since_last_proxy_xmit = false;
                last_proxy_keepalive = client_time;
                send_proxy_keepalive();
            }
        }

        check_battle_outcome();

        if(session.has_attacked && session.attack_finish_time > 0 && server_time >= session.attack_finish_time) {
            // force the attack to conclude
            session.set_attack_finish_time(-1);
            visit_base_after_attack();
        } else if(session.incoming_attack_time > 0 && server_time >= session.incoming_attack_time) {
            // tell server to spawn units (if the server hasn't gotten around to it yet)
            start_incoming_attack();
        } else if(session.incoming_attack_wave_time > 0 && server_time >= session.incoming_attack_wave_time) {
            if(!session.incoming_attack_wave_pending) {
                session.incoming_attack_wave_pending = true;
                send_to_server.func(["NEXT_AI_ATTACK_WAVE"]);
            }
        } else if(player.tutorial_state === "COMPLETE" && (selection.ui === null || (selection.ui.user_data && selection.ui.user_data['dialog']=='region_map_dialog')) &&
                  (!session.has_attacked || (session.viewing_base.base_type == 'quarry' && session.viewing_base.base_landlord_id == session.user_id))) {
            notification_queue.fire_next();
        }

        // trigger the daily attack sequence
        if(player.daily_attack_time > 0 &&
           session.home_base && !session.has_attacked && !session.incoming_attack_pending() &&
           client_time >= player.daily_attack_time && player.tutorial_state === "COMPLETE") {
            player.daily_attack_time = -1;
            send_to_server.func(["START_DAILY_ATTACK"]);
        }

        player.update_quest_cache();

        // update quest tips UI
        if(selection.ui_change_time > 0) {
            if(client_time - selection.ui_change_time >= ((player.quest_tracked ? player.quest_tracked['ui_quiet_time'] : null) || gamedata['client']['ui_quiet_time']) &&
               !notification_queue.pending() &&
               synchronizer.is_globally_in_sync()) {
                selection.ui_change_time = -1;
                player.quest_tracked_dirty = true;
            }
        }

        if(player.quest_tracked_dirty) {
            player.quest_tracked_dirty = false;
            player.quest_root.clear();
            player.quest_landscape_arrow = null;
            if(player.quest_tracked && player.tutorial_state === "COMPLETE" &&
               (('tips' in player.quest_tracked) || player.quest_tracked['force_claim']) &&
               !notification_queue.pending() &&
               (session.home_base || player.quest_tracked['tips_in_enemy_base'])) {

                var can_complete = player.can_complete_quest(player.quest_tracked);
                if(can_complete && !selection.ui && player.quest_tracked_complete_time < 0 && player.quest_tracked['force_claim']) {
                    // pop up the missions dialog after a timeout to force claiming
                    player.quest_tracked_complete_time = client_time + player.get_any_abtest_value('ui_quest_complete_pop_time', gamedata['client']['ui_quest_complete_pop_time']);
                }

                var missions_dialog = ((selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'missions_dialog') ? selection.ui : null);

                // note: wait for missions dialog animation to finish before running tips_in_missions_dialog
                var fx_time = (missions_dialog && missions_dialog.widgets['glow'].show) ? missions_dialog.widgets['glow'].fx_time_remaining() : -1;
                if(player.quest_tracked['tips_in_missions_dialog'] && (fx_time > 0)) {
                    selection.ui_change_time = client_time + fx_time;
                } else if(player.quest_tracked['tips'] && (!can_complete || player.quest_tracked['tips_when_complete']) && (!session.has_attacked || player.quest_tracked['tips_in_combat'])) {
                    // display tips
                    execute_logic(player.quest_tracked['tips']);
                }

                // if missions dialog is up and pointing to the tracked mission, show arrow pointing to either "Accept" or "Claim"
                if(missions_dialog) {
                    var selected_quest = missions_dialog.user_data['quest_list'][missions_dialog.user_data['selected_row']];

                    // if the Missions dialog is showing the currently-tracked quest, show arrow to EITHER "Accept" OR "Claim"
                    if(selected_quest['force_claim'] && (selected_quest === player.quest_tracked) && (!player.quest_tracked['tips_in_missions_dialog'] || player.can_complete_quest(selected_quest))) {
                        read_consequent({'consequent':'TUTORIAL_ARROW',
                                         'arrow_type':'button',
                                         'direction':'up',
                                         'dialog_name':'missions_dialog',
                                         'widget_name':'claim_button'}).execute();
                        // AND disable/hide close button
                        if(selected_quest['force_claim']) {
                            missions_dialog.widgets['close_button'].show = false;
                            missions_dialog.widgets['messages_button'].state = 'disabled';
                        }
                    }
                }
            }
        }

        if(session.home_base && player.quest_tracked && player.quest_tracked_complete_time > 0 &&
           client_time > player.quest_tracked_complete_time && !selection.ui && !notification_queue.pending()) {
            player.quest_tracked_complete_time = -1;
            if(player.can_complete_quest(player.quest_tracked)) {
                invoke_missions_dialog(true);
                player.quest_tracked_dirty = true;
            }
        }

        } // END only do these if actually running, not timed out or waiting for session change

        var powerfac = (session.viewing_base ? session.viewing_base.power_factor() : 1);

        if(mouse_state.hovering_over && mouse_tooltip) {
            mouse_tooltip.activation_check();
        }

        // adjust view_pos for forced scrolling
        force_scroll_eval();

        // adjust view_pos according to shake
        var shake = SPFX.get_camera_shake();
        var dx = shake[0], dy = shake[1];
        if(dx != 0 || dy != 0) {
            view_pos[0] += shake[0]/view_zoom;
            view_pos[1] += shake[1]/view_zoom;
        }

        view_pos[0] = clamp(view_pos[0], view_limits[0][0], view_limits[0][1]);
        view_pos[1] = clamp(view_pos[1], view_limits[1][0], view_limits[1][1]);

        if(view_is_zoomed()) {
            // draw space is playfield space
            view_roi = [screen_to_playfield([0,0]), screen_to_playfield([canvas_width,canvas_height])];
        } else {
            // quantize view_pos to pixels when not zoomed, to avoid drawing at non-integer pixel coordinates
            view_pos = vec_floor(view_pos);
            view_roi = [[0,0],[canvas_width,canvas_height]]; // draw space is screen space
        }

        // keep track of whether any enemy units are on-screen for displaying the direction arrow
        var any_enemy = false, any_enemy_onscreen = false, offscreen_enemy_unit = null;

        // when intensive GUI dialogs are up, skip drawing playfield objects for speed
        var draw_playfield_objects = true;
        if(selection.ui && selection.ui.user_data && selection.ui.user_data['dialog'] == 'region_map_dialog') {
            draw_playfield_objects = false;
        }

        if(1) {
            // draw playfield (zoomed within these braces)
            ctx.save();
            set_playfield_draw_transform(ctx);

            // draw backdrop
            draw_backdrop(draw_playfield_objects);

            // draw map grid
            if(PLAYFIELD_DEBUG) {
                draw_debug_map();
                if(astar_context) { astar_context.debug_draw(ctx); }
            }

            if(draw_playfield_objects) {
                // draw special effects
                SPFX.draw_under();

                // draw flying unit shadows
                for(var id in session.cur_objects.objects) {
                    draw_shadow(session.cur_objects.objects[id]);
                }

                // prepare phantom objects for drawing and draw shadows if necessary
                var phantom_objects = SPFX.get_phantom_objects();
                goog.array.forEach(phantom_objects, function(obj) {
                    obj.update_draw_pos();
                    draw_shadow(obj);
                });

                // draw selection
                if(selection.unit && selection.unit.id &&
                   selection.unit.id !== GameObject.DEAD_ID && selection.unit.id !== GameObject.VIRTUAL_ID) {
                    draw_selection_highlight(selection.unit);
                }
                for(var i = 0; i < selection.multi.length; i++) {
                    if(selection.multi[i] !== selection.unit && selection.multi[i].id &&
                       selection.multi[i].id !== GameObject.DEAD_ID && selection.multi[i].id !== GameObject.VIRTUAL_ID) {
                        draw_selection_highlight(selection.multi[i]);
                    }
                }

                if(gamedata['client']['highlight_enemy_units'] && session.has_attacked) {
                    for(var id in session.cur_objects.objects) {
                        var obj = session.cur_objects.objects[id];
                        if(obj.is_mobile() && obj.team != 'player' && !obj.is_destroyed() &&
                           (!obj.spec['cloaked'] || !obj.is_invisible())) {
                            draw_selection_highlight(obj);
                        }
                    }
                }

                if(!selection.ui && !session.has_attacked && mouse_state.hovering_over && mouse_state.hovering_over.is_building() && mouse_state.hovering_over.team == 'player') {
                    draw_selection_highlight(mouse_state.hovering_over, 'hover');
                }

                // if mouse is hovering over a turret and there is no other UI up, draw all turret ranges
                /*
                  if(!selection.ui &&
                  mouse_state.hovering_over &&
                  mouse_state.hovering_over.is_building()) {
                  var range = mouse_state.hovering_over.weapon_range()[1];
                  if(range > 0) {
                  draw_turret_ranges(null);
                  }
                  }
                */

                // draw units and buildings in sorted Z-order
                var scene = [];

                for(var id in session.cur_objects.objects) {
                    var obj = session.cur_objects.objects[id];
                    if(!obj.spec['is_scenery'] || !obj.spec['draw_flat']) {
                        obj.update_draw_pos();
                        scene.push(obj);
                    }
                }
                goog.array.forEach(phantom_objects, function(obj) {
                    scene.push(obj);
                });
                scene.sort(sort_scene_objects);

                for(var i = 0; i < scene.length; i++) {
                    var obj = scene[i];
                    if(obj.is_mobile()) {
                        var visible = draw_unit(obj);
                        if(obj.team === 'enemy' && !obj.is_destroyed()) {
                            any_enemy = true;
                            if(visible) {
                                any_enemy_onscreen = true;
                            } else {
                                offscreen_enemy_unit = obj;
                            }
                        }
                    } else if(obj.is_building() || obj.is_inert()) {
                        draw_building_or_inert(obj, powerfac);
                    }
                }

                // draw special effects
                SPFX.draw_over();

                // draw A* debug info
                if(PLAYFIELD_DEBUG) {
                    draw_debug_astar_paths();
                }

            } // END draw playfield objects

            ctx.restore();
        } // END draw playfield

        draw_drag_selection();

        // draw a transparent black rect over the screen to simulate darkened lighting
        if(session.viewing_base && ('light_level' in session.viewing_base.base_climate_data) && (SPFX.detail >= 2) && draw_playfield_objects) {
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,'+(1-session.viewing_base.base_climate_data['light_level']).toString()+')';
            ctx.fillRect(0,0,canvas_width,canvas_height);
            ctx.restore();
        }

        //console.log('any '+any_enemy+' any_onscreen' +any_enemy_onscreen+' offscreen_enemy_unit '+!!offscreen_enemy_unit);

        var arrow_pos = null;
        if(false && selection.ui && selection.ui.user_data && selection.ui.user_data['cursor'] == 'DeployUICursor' &&
           session.viewing_base.base_landlord_id != session.user_id && session.viewing_base.has_deployment_zone()) {
            // when deploying into a base that has a polygonal deployment zone, show arrow towards deployment zone
            arrow_pos = session.viewing_base.deployment_buffer['vertices'][0];
        } else if(any_enemy && !any_enemy_onscreen && offscreen_enemy_unit) {
            arrow_pos = offscreen_enemy_unit.interpolate_pos();
        } else if(session.incoming_attack_pending() && session.incoming_attack_direction && session.incoming_attack_direction != 'tutorial') {
            var spawn_location = gamedata['ai_attacks_client']['directions'][session.incoming_attack_direction];
            // exaggerate spawn_location's distance from the middle of the map in order to force it offscreen
            var ncells = session.viewing_base.ncells();
            arrow_pos = [ncells[0]*(5*(spawn_location[0]-0.5)+0.5), ncells[1]*(5*(spawn_location[1]-0.5)+0.5)];
        } else if(player.quest_landscape_arrow) {
            // show white arrow pointing towards the tutorial arrow
            var loc = player.quest_landscape_arrow.user_data['reticle_loc'];
            if(loc) { arrow_pos = loc; }
        }

        if(!offscreen_unit_arrow) {
            offscreen_unit_arrow = new SPFX.OffscreenArrow();
            SPFX.add(offscreen_unit_arrow);
        }
        offscreen_unit_arrow.reset(arrow_pos);

        var fps = fps_counter.get();
        // draw developer-only FPS counter and art progress display
        if(1) {
            var origin = [5, canvas_height-30];
            var btm = desktop_dialogs['desktop_bottom'];
            if(btm) {
                origin = [btm.xy[0]+10, btm.xy[1]-33];
            }
            // draw nonessential art download progress (only for first minute though)
            if(client_art_state != client_art_states.DONE && (player.is_developer() || (client_time - session.connect_time < 60.0))) {
                ctx.fillText("Downloading ("+(100*GameArt.get_dl_progress_all()).toFixed(0)+"%)...", origin[0], origin[1]);
            }
            if(fps_counter.show) {
                var lines = [];
                lines.push('Performance Info: (Press "F" key to hide)');
                lines.push('FPS: '+fps.toFixed(2)+' (limit '+FRAME_RATE_CAP.toString()+')');
                if(USING_REQUESTANIMATIONFRAME) {
                    lines.push("using requestAnimationFrame()");
                } else {
                    lines.push("using window.setTimeout("+LAST_ANIM_FRAME_TIMEOUT.toFixed(0)+"ms)");
                }
                lines.push('Client/server clock offset: '+(-1000*server_time_offset).toFixed(0)+'ms');
                ctx.save();
                var fsize = 21;
                ctx.font = SPUI.make_font(fsize, fsize+6, 'thick').str();
                goog.array.forEach(lines, function(line, y) {
                    ctx.fillText(line, origin[0], origin[1] + 18 + (fsize+6) * y);
                });
                ctx.restore();
            }
        }

        // draw UI elements
        SPUI.draw_all();

        // draw tutorial UI elements
        if(player.tutorial_state != "COMPLETE" && client_state == client_states.RUNNING) {
            var data = gamedata['tutorial'][player.tutorial_state];
            if('bg_fill_color' in data) {
                var col = data['bg_fill_color'];
                var color = new SPUI.Color(col[0], col[1], col[2], col[3]);
                ctx.fillStyle = color.str();
                ctx.fillRect(0,0,canvas_width,canvas_height);
            }
        }
        player.quest_root.draw([0,0]);
        tutorial_root.draw([0,0]);

        // draw UI special effects
        SPFX.draw_ui();

        // draw active tooltip on top of everything else
        SPUI.draw_active_tooltip();

        // XXX temp - draw mouse location for debugging purposes
        if(get_query_string('show_mouse_loc') === '1') {
            ctx.save();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(0,255,0,1.0)';
            ctx.beginPath();
            ctx.arc(mouse_state.last_x, mouse_state.last_y, 6, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.restore();
        }

        // draw synthetic cursor
        if(mouse_state.pointer_locked) {
            ctx.save();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(0,255,0,1.0)';
            ctx.beginPath();
            ctx.arc(mouse_state.pointer_lock_origin[0], mouse_state.pointer_lock_origin[1], 6, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.restore();
        }

    } // END client_state == RUNNING

    // once first frame renders successfully, clear the watchdog timer
    if(SPINPUNCHGAME.watchdog_timer) {
        window.clearTimeout(SPINPUNCHGAME.watchdog_timer);
        SPINPUNCHGAME.watchdog_timer = null;
    }
}

function draw_backdrop_area_bounds() {
    var ncells = session.viewing_base.ncells();
    var xy;
    ctx.beginPath();
    xy = ortho_to_draw([0,0]);
    ctx.moveTo(xy[0],xy[1]);
    xy = ortho_to_draw([ncells[0],0]);
    ctx.lineTo(xy[0],xy[1]);
    xy = ortho_to_draw([ncells[0],ncells[1]]);
    ctx.lineTo(xy[0],xy[1]);
    xy = ortho_to_draw([0,ncells[1]]);
    ctx.lineTo(xy[0],xy[1]);
    xy = ortho_to_draw([0,0]);
    ctx.lineTo(xy[0],xy[1]);
    ctx.stroke();
}
function draw_backdrop_scenery() {
    // draw scenery objects
    var obj_list = [];
    for(var id in session.cur_objects.objects) {
        var obj = session.cur_objects.objects[id];
        if(obj.spec['is_scenery'] && obj.spec['draw_flat'] && (SPFX.detail >= 0 || obj.spec['is_debris'])) {
            obj.update_draw_pos();
            obj_list.push(obj);
        }
    }
    // do some Z-sorting
    obj_list.sort(sort_scene_objects);
    goog.array.forEach(obj_list, function(obj) { draw_building_or_inert(obj,1); });

    // draw building bases
    if(SPFX.detail >= 2) {
        var climate_data = (session.viewing_base && goog.object.getCount(session.viewing_base.base_climate_data)>0 ? session.viewing_base.base_climate_data : gamedata['climates'][gamedata['default_climate']]);
        if('building_bases' in climate_data) {
            var base_list = [];
            for(var id in session.cur_objects.objects) {
                var obj = session.cur_objects.objects[id];
                if(obj.is_building()) {
                    var key = obj.spec['gridsize'][0].toString()+'x'+obj.spec['gridsize'][1].toString();
                    if(key in climate_data['building_bases']) {
                        obj.update_draw_pos();
                        base_list.push(obj);
                    }
                }
            }
            base_list.sort(sort_scene_objects);
            goog.array.forEach(base_list, function(obj) {
                var key = obj.spec['gridsize'][0].toString()+'x'+obj.spec['gridsize'][1].toString();
                var sprite = GameArt.assets[climate_data['building_bases'][key]];
                var xy = vec_floor(ortho_to_draw([obj.x, obj.y]));
                if(!sprite.prep_for_draw(xy, 0, client_time, 'normal')) {
                    return; // not ready yet, no gray box
                }
                sprite.draw(xy, 0, client_time, 'normal');
            });
        }
    }
}
function draw_backdrop_blank() {
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#202020';
    ctx.fillRect(0,0,canvas_width,canvas_height);
    ctx.restore();
}

function draw_backdrop_tiled(data) {
    var assetname = data[(session.home_base || session.viewing_base.base_landlord_id === session.user_id ? 'friendly' : 'hostile')];

    var asset = GameArt.assets[assetname];
    var main_sprite = GameArt.assets[assetname].states['fullleft'];
    var main_image = main_sprite.images[0];
    if(!main_image.data_loaded) {
        // start it loading
        main_image.prep_for_draw();
        // but draw blank for now
        draw_backdrop_blank();
        return false;
    }

    ctx.save();
    ctx.setTransform(1,0,0,1,0,0); // undo playfield transform

    // [2,1]*tilesize must evenly divide nells*cellsize/2 in order for the edge tiles to line up
    // tilesize must be even
    var tilesize = (view_is_zoomed() ? vec_scale(view_zoom, main_sprite.wh) : main_sprite.wh); // size of a bg tile in pixels
    var ncells = session.viewing_base.ncells();
    var maptiles = vec_div(vec_mul(ncells,vec_div(cellsize,[2,2])), main_sprite.wh);
    if(!vec_equals(vec_mod(vec_mul([0.5,1],maptiles), 1), [0,0])) {
        throw Error('background tilesize does not evenly divide '+(ncells[0]*cellsize[0]).toString()+'x'+(ncells[1]*cellsize[1]).toString());
    }
    if(!vec_equals(vec_mod(main_sprite.wh, 2), [0,0])) {
        throw Error('background tilesize is not even: '+tilesize[0]+'x'+tilesize[1]);
    }
    maptiles = vec_floor(maptiles);
    //console.log('maptiles '+maptiles[0]+'x'+maptiles[1]);

    // pixel coordinates of top-left of view relative to game field's [0,0] origin
    // subtract [0,tilesize[1]] to shift the tiles up one-half-height vs the playfield (see TILES photoshop layer to visualize why)
    //var start = vec_sub(vec_sub(view_pos, vec_sub(view_pos, vec_scale(view_zoom, [canvas_width_half,canvas_height_half])), [0,tilesize[1]/2]);
    var start = vec_sub(vec_sub(vec_scale(view_zoom, view_pos), [canvas_width_half, canvas_height_half]), [0, tilesize[1]/2]);
    var end = vec_add(start, [canvas_width, canvas_height]);

    var istart = Math.floor(start[1]/tilesize[1]);
    var iend = Math.floor(end[1]/tilesize[1]);
    var jstart =  Math.floor(start[0]/tilesize[0]);
    var jend = Math.floor(end[0]/tilesize[0]);

    //console.log('jstart '+jstart+' istart '+istart);

    for(var i = istart; i <= iend; i++) {
        for(var j = jstart; j <= jend; j++) {
            var x = j*tilesize[0] - start[0];
            var y = i*tilesize[1] - start[1];

            // 16 possible cases for the tile!
            var state;
            var debug_color = '#ffffff';

            if(j >= 0) {
                // right side
                if(i < 0) {
                    // top
                    if(i < -maptiles[0]+j-1) {
                        state = 'empty';
                    } else if(i == -maptiles[0]+j-1) {
                        if(j == 0) {
                            state = 'corner_nwright'; debug_color='#ff0000';
                        } else if(j == maptiles[0]) {
                            state = 'corner_neright'; debug_color='#ff0000';
                        } else {
                            state = 'edge_nright'; debug_color='#880000';
                        }
                    } else if(i == -maptiles[0]+j) {
                        if(j == maptiles[0]-1) {
                            state = 'corner_neleft'; debug_color='#ff0000';
                        } else {
                            state = 'edge_nleft';  debug_color='#880000';
                        }
                    } else {
                        state = 'full';
                    }
                } else {
                    // bottom
                    if(i < maptiles[0]-j-2) {
                        state = 'full';
                    } else if(i == maptiles[0]-j-2) {
                        state = 'edge_eleft';  debug_color='#008800';
                    } else if(i == maptiles[0]-j-1) {
                        if(j == 0) {
                            state = 'corner_seright'; debug_color='#00ff00';
                        } else {
                            state = 'edge_eright'; debug_color='#008800';
                        }
                    } else {
                        state = 'empty';
                    }
                }
            } else {
                // left side
                if(i < 0) {
                    // top
                    if(i < -maptiles[0]-j-2) {
                        state = 'empty';
                    } else if(i == -maptiles[0]-j-2) {
                        if(j == -1) {
                            state = 'corner_nwleft'; debug_color='#ff0000';
                        } else if(j == -maptiles[0]-1) {
                            state = 'corner_swleft'; debug_color='#ff00ff';
                        } else {
                            state = 'edge_wleft'; debug_color='#000088';
                        }
                    } else if(i == -maptiles[0]-j-1) {
                        if(j == -maptiles[0]) {
                            state = 'corner_swright'; debug_color='#0000ff';
                        } else {
                            state = 'edge_wright'; debug_color='#000088';
                        }
                    } else {
                        state = 'full';
                    }
                } else {
                    // bottom
                    if(i < maptiles[0]+j-1) {
                        state = 'full';
                    } else if(i == maptiles[0]+j-1) {
                        state = 'edge_sright'; debug_color='#888800';
                    } else if(i == maptiles[0]+j) {
                        if(j == -1) {
                            state = 'corner_seleft'; debug_color='#ffff00';
                        } else {
                            state = 'edge_sleft'; debug_color='#888800';
                        }
                    } else {
                        state = 'empty';
                    }
                }
            }

            if(state == 'full') { // alternate left/right
                state = (((i+j)&1) ? 'fullright' : 'fullleft');
                // make use of alternate left/right sprites if available
                if('fullleft3' in asset.states) {
                    var mod = (i+Math.floor((i+j)/2)+maptiles[0]+5)%4;
                    if(mod > 0) {
                        state += mod.toString();
                    }
                }
            }

            if(!(state in asset.states)) {
                console.log("bad backdrop state "+state);
                state = 'fullleft';
            }

            var image = asset.states[state].images[0];
            var w = tilesize[0], h = tilesize[1];
            var sx = 0, sy = 0, sw = main_sprite.wh[0], sh = main_sprite.wh[1];

            if(!view_is_zoomed()) {
                // perform clipping
                // left
                if(x < 0) {
                    sx = -x;
                    w += x;
                    sw += x;
                    x = 0;
                }
                // top
                if(y < 0) {
                    sy = -y;
                    h += y;
                    sh += y;
                    y = 0;
                }
                // right
                if((x+w) >= canvas_width) {
                    w = canvas_width-x;
                    sw = canvas_width-x;
                }
                // bottom
                if((y+h) >= canvas_height) {
                    h = canvas_height-y;
                    sh = canvas_height-y;
                }
            }

            if(w > 0 && h > 0) {
                if(view_is_zoomed()) {
                    // enlarge source texture coordinates to hide interpolated pixel seams at the edges
                    var incr = gamedata['client']['view_zoom_tile_border'][view_zoom >= 1.0 ? 1 : 0];
                    sx += incr/view_zoom;
                    sy += incr/view_zoom;
                    sw -= (2/view_zoom)*incr;
                    sh -= (2/view_zoom)*incr;
                }
                image.drawSubImage([sx,sy],[sw,sh],[x,y],[w,h]);
                if(PLAYFIELD_DEBUG && w>2 && h>2) {
                    ctx.strokeStyle = debug_color;
                    ctx.strokeRect(x+1,y+1,w-2,h-2);
                    ctx.fillText('j='+j.toString()+' i='+i.toString()+' '+state, x+13, y+17);
                }
            }
        }
    }
    ctx.restore(); // redo playfield transform
    return true;
}

function draw_backdrop_whole(assetname) {
    var backdrop_sprite = GameArt.assets[assetname].states[(session.home_base ? 'home':'other')];
    var backdrop_image = backdrop_sprite.images[0];

    if(!backdrop_image.data_loaded || !session.viewing_base) {
        // start it loading
        backdrop_image.prep_for_draw();
        // but draw blank for now
        draw_backdrop_blank();
        return false;
    } else {
        ctx.save();
        ctx.setTransform(1,0,0,1,0,0); // undo playfield transform

        var ncells = session.viewing_base.ncells();

        // pixel coordinates of the subpart of the whole image that will land at the top left of the canvas
        // = 0.5*sprite.wh + view_pos + (1/zoom)*(-canvas_half)
        var start = vec_add(vec_scale(0.5, backdrop_sprite.wh), vec_add(view_pos, vec_scale(1/view_zoom, [-canvas_width_half, -canvas_height_half])));

        // add source pixel size of the subpart of the whole image that will fill the canvas
        var end = vec_add(start, vec_scale(1/view_zoom, [canvas_width, canvas_height]));

        var dest_area = [canvas_width, canvas_height];
        if(view_is_zoomed()) {
            // draw one extra pixel at right/bottom to avoid seams
            dest_area = vec_add(dest_area, [1/view_zoom,1/view_zoom]);
        } else {
            start = vec_floor(start);
            end = vec_floor(end);
        }
        backdrop_image.drawSubImage_clipped(start, vec_sub(end, start), [0,0], dest_area);

        // if the image doesn't fill the entire canvas, draw black borders around the edges
        // with optional gradient fringe
        var fringe = gamedata['client']['backdrop_whole_fringe']*view_zoom;
        var edges = [];
        if(start[0] < 0) {
            edges.push({x:0, y:0, w:-start[0]*view_zoom, h:dest_area[1], v:[1,0]});
        }
        if(start[1] < 0) {
            edges.push({x:0, y:0, w:dest_area[0], h:-start[1]*view_zoom, v:[0,1]});
        }
        if(end[0] >= backdrop_sprite.wh[0]) {
            var w = (end[0]-backdrop_sprite.wh[0])*view_zoom, h = dest_area[1];
            edges.push({x:dest_area[0]-w-0.5, y:0, w:w, h:dest_area[1], v:[-1,0]});
        }
        if(end[1] >= backdrop_sprite.wh[1]) {
            var h = (end[1]-backdrop_sprite.wh[1])*view_zoom;
            edges.push({x:0, y:dest_area[1]-h-0.5, w:dest_area[0], h:h, v:[0,-1]});
        }

        if(edges.length > 0) {
            ctx.fillStyle = '#000000';
            goog.array.forEach(edges, function(edge) {
                ctx.fillRect(Math.floor(edge.x), Math.floor(edge.y), Math.floor(edge.w+0.5), Math.floor(edge.h+0.5));
            });
            goog.array.forEach(edges, function(edge) {
                // firefox doesn't do a great job of clipping very thin gradients, so don't draw if too narrow
                if(fringe > 0 && Math.min(edge.w, edge.h) >= 2) {
                    var grd = ctx.createLinearGradient(Math.floor(edge.x+edge.v[0]*(edge.v[0] > 0 ? edge.w : 0)),
                                                       Math.floor(edge.y+edge.v[1]*(edge.v[1] > 0 ? edge.h : 0)),
                                                       Math.floor(edge.x+edge.v[0]*(edge.v[0] > 0 ? (edge.w+fringe) : fringe)),
                                                       Math.floor(edge.y+edge.v[1]*(edge.v[1] > 0 ? (edge.h+fringe) : fringe)));
                    grd.addColorStop(0, 'rgba(0,0,0,1)');
                    grd.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = grd;
                    //ctx.fillStyle = '#00ff00'; // for debugging

                    ctx.fillRect(Math.floor(edge.x+edge.v[0]*(edge.v[0] > 0 ? edge.w : fringe)),
                                 Math.floor(edge.y+edge.v[1]*(edge.v[1] > 0 ? edge.h : fringe)),
                                 Math.floor((1-Math.abs(edge.v[0]))*edge.w + Math.abs(edge.v[0])*fringe + 1.5),
                                 Math.floor((1-Math.abs(edge.v[1]))*edge.h + Math.abs(edge.v[1])*fringe + 1.5));
                }
            });
        }

        ctx.restore(); // redo playfield transform
    }
    return true;
}

function draw_backdrop_simple(assetname) {
    var backdrop_sprite = GameArt.assets[assetname].states[(session.home_base ? 'home':'other')];
    var backdrop_image = backdrop_sprite.images[0];

    if(!backdrop_image.data_loaded) {
        // start it loading
        backdrop_image.prep_for_draw();
        // but draw blank for now
        draw_backdrop_blank();
        return false;
    } else {
        ctx.save();
        ctx.setTransform(1,0,0,1,0,0); // undo playfield transform
        var tilesize = view_is_zoomed() ? vec_scale(view_zoom, backdrop_sprite.wh) : backdrop_sprite.wh;
        var start = [view_pos[0]*view_zoom - canvas_width_half, view_pos[1]*view_zoom - canvas_height_half];
        var end = [start[0]+canvas_width, start[1]+canvas_height];

        var istart = Math.floor(start[1]/tilesize[1]);
        var iend = Math.floor(end[1]/tilesize[1]);
        var jstart =  Math.floor(start[0]/tilesize[0]);
        var jend = Math.floor(end[0]/tilesize[0]);

        for(var i = istart; i <= iend; i++) {
            for(var j = jstart; j <= jend; j++) {
                var x = Math.floor(j*tilesize[0] - start[0]);
                var y = Math.floor(i*tilesize[1] - start[1]);
                var w = tilesize[0], h = tilesize[1];
                var sx = 0, sy = 0, sw = backdrop_sprite.wh[0], sh = backdrop_sprite.wh[1];

                // perform clipping
                if(!view_is_zoomed()) {
                    // left
                    if(x < 0) {
                        sx = -x;
                        sw += x;
                        w += x;
                        x = 0;
                    }
                    // top
                    if(y < 0) {
                        sy = -y;
                        sh += y;
                        h += y;
                        y = 0;
                    }
                    // right
                    if((x+w) >= canvas_width) {
                        w = canvas_width-x;
                        sw = w;
                    }
                    // bottom
                    if((y+h) >= canvas_height) {
                        h = canvas_height-y;
                        sh = h;
                    }
                }
                if(w > 0 && h > 0) {
                    if(view_is_zoomed()) {
                        // draw one extra pixel at left/bottom to avoid seams
                        w += 1/view_zoom; h += 1/view_zoom;
                    }
                    backdrop_image.drawSubImage([sx,sy],[sw,sh],[x,y],[w,h]);
                }
            }
        }
        ctx.restore(); // redo playfield transform
    }
    return true;
}

function draw_backdrop(want_scenery) {
    var show_backdrop = (get_query_string('nobackdrop') != '1');
    if(!show_backdrop) {
        draw_backdrop_blank();
        draw_backdrop_area_bounds();
        return;
    }
    var climate_data = (session.viewing_base && goog.object.getCount(session.viewing_base.base_climate_data)>0 ? session.viewing_base.base_climate_data : gamedata['climates'][gamedata['default_climate']]);
    var ncells = (session.viewing_base ? session.viewing_base.ncells() : null);

    if(('backdrop_whole' in climate_data) && ncells && (ncells[0].toString()+'x'+ncells[1].toString() in climate_data['backdrop_whole'])) {
        var drawn = draw_backdrop_whole(climate_data['backdrop_whole'][ncells[0].toString()+'x'+ncells[1].toString()]);
        if(drawn && want_scenery) { draw_backdrop_scenery(); }
        if(session.viewing_base && (!drawn || PLAYFIELD_DEBUG)) { draw_backdrop_area_bounds(); }
    } else if('backdrop_tiles' in climate_data && (SPFX.detail >= 2)) {
        var drawn = draw_backdrop_tiled(climate_data['backdrop_tiles']);
        if(drawn && want_scenery) { draw_backdrop_scenery(); }
        if(session.viewing_base && (!drawn || PLAYFIELD_DEBUG)) { draw_backdrop_area_bounds(); }
    } else {
        var drawn = draw_backdrop_simple(climate_data['backdrop']);
        if(drawn && want_scenery) { draw_backdrop_scenery(); }
        if(session.viewing_base) { draw_backdrop_area_bounds(); }
    }
}

// check a building for "idleness" ("can produce", "can manufacture", "can research", etc)
Building.prototype.get_idle_state = function() {
    if(this.spec['worth_less_xp']) { return null; } // exclude barriers
    if(this.is_destroyed()) { return null; }
    if(this.is_damaged() || this.is_upgrading() || this.is_under_construction()) { return null; }

    if(this.idle_state_cache === null || (this.idle_state_cache_valid_until > 0 && client_time > this.idle_state_cache_valid_until)) {
        // note: assumes get_idle_state_advanced/legacy() never return null
        if(player.get_any_abtest_value('idle_icon_type', gamedata['client']['idle_icon_type'] || 'old') == 'advanced') {
            this.idle_state_cache = this.get_idle_state_advanced(); // new SuperCell-like version
        } else {
            this.idle_state_cache = this.get_idle_state_legacy(); // old SpinPunch version
        }
        this.idle_state_cache_valid_until = -1;

        // for harvesters, invalidate a null cache every idle period in case its contents climb above threshold
        if(this.idle_state_cache['state'] === null && this.is_producer() && (this.produce_start_time > 0 && this.produce_rate > 0)) {
            this.idle_state_cache_valid_until = client_time + (gamedata['client']['harvester_idle_seconds'] || 60);
        }
    }

    // harvester sync gets handled outside of the cache since it needs low latency
    if(this.is_producer()) {
        if(!synchronizer.is_in_sync(session.quarry_harvest_sync_marker)) {
            if(session.region.data && session.region.refresh_progress() >= 0) {
                return {'state': 'harvest_in_progress_pct', 'can_upgrade': this.idle_state_cache['can_upgrade'],
                        's_replace': (100.0*Math.min(session.region.refresh_progress(), 0.99)).toFixed(0)};
            } else {
                return {'state': 'harvest_in_progress', 'can_upgrade': this.idle_state_cache['can_upgrade']};
            }
        } else if(!this.is_in_sync()) {
            return {'state': 'harvest_in_progress', 'can_upgrade': this.idle_state_cache['can_upgrade']}; // XXX could be out of sync for other reasons!
        }
    }

    // generic "Working..." message
    if(!this.is_in_sync() && !this.idle_state_cache['state']) { return {'state': 'pending', 'can_upgrade': this.idle_state_cache['can_upgrade']}; }

    return this.idle_state_cache;
};

Building.prototype.get_idle_state_legacy = function() {
    var draw_idle_icon = null;
    var draw_idle_icon_s = null;

    if(this.is_producer()) {
        var contents = this.interpolate_contents();
        var threshold = (this.produce_start_time > 0 && this.produce_rate > 0 ? Math.max(2, Math.floor((this.produce_rate/3600.0) * (gamedata['client']['harvester_idle_seconds'] || 60))) : -1);
        var resname = null;
        for(var res in gamedata['resources']) {
            if(('produces_'+res) in this.spec) {
                resname = res; break;
            }
        }
        if(contents >= this.get_production_capacity()) {
            draw_idle_icon = 'harvest_'+resname+'_full';
        } else if(threshold > 0 && contents >= threshold) {
            draw_idle_icon = 'harvest_'+resname;
        }
    } else if(this.is_storage() && this.spec['name'] != gamedata['townhall']) {
        // fullness state
        var resname = null;
        for(var res in gamedata['resources']) {
            if(('storage_'+res) in this.spec) {
                resname = res; break;
            }
        }
        if(resname) {
            var fullness = get_storage_fullness(resname);
            if(fullness >= 1) { draw_idle_icon = 'full'; }
        }
    } else if(this.is_factory() && !this.is_manufacturing()) {
        var space_usage = player.get_army_space_usage_by_squad();
        if(space_usage['ALL'] < 0.9*player.stattab['total_space']) { draw_idle_icon = 'manufacture'; }
    } else if(this.is_researcher()) {
        if(!this.is_researching()) { draw_idle_icon = 'research'; }
    } else if(this.is_crafter()) {
        if((!this.is_crafting() || this.crafting_progress_one() < 0) && !(this.is_emplacement() && this.turret_head_item())) {
            for(var i = 0; i < this.spec['crafting_categories'].length; i++) {
                var catname = this.spec['crafting_categories'][i];
                var cat = gamedata['crafting']['categories'][catname];
                if(catname == 'mines') {
                    if(!player.all_minefields_armed()) {
                        draw_idle_icon = cat['idle_state'] || 'craft';
                        break;
                    } else {
                        continue;
                    }
                }
                draw_idle_icon = cat['idle_state'] || 'craft';
                if(draw_idle_icon == 'fish') {
                    if(player.cooldown_active('fish_slate_assigned')) {
                        // show no idle icon if all available fishing SKUs are exhausted
                        if(!goog.object.findKey(gamedata['crafting']['recipes'], function(recipe) {
                            return (recipe['crafting_category'] == 'fishing' && read_predicate(recipe['show_if']).is_satisfied(player, null));
                        })) {
                            draw_idle_icon = null;
                        }
                    }
                }
                break;
            }
        } else if(this.crafting_progress_one() < 0) {
            /* draw_idle_icon = 'craft_done'; */
        }

        if(this.is_emplacement() && this.turret_head_item()) { // assumes emplacements are crafters
            var item_spec = ItemDisplay.get_inventory_item_spec(this.turret_head_item());
            // check if our tech level for this item is above its own level
            if('level' in item_spec && 'associated_tech' in item_spec) {
                var tech_level = player.tech[item_spec['associated_tech']] || 0;
                if(tech_level > item_spec['level']) {
                    draw_idle_icon = 'under_leveled_turret_head';
                }
            }
        }
    } else if(this.is_lottery_building()) {
        if(this.contents >= 1) { draw_idle_icon = 'scan'; }
    } else if(this.spec['name'] === gamedata['alliance_building']) {
        if(!session.is_in_alliance()) {
            var pr = gamedata['predicate_library']['alliance_join_requirement'];
            if(read_predicate({'predicate':'LIBRARY','name':'alliance_join_requirement'}).is_satisfied(player, null)) {
                draw_idle_icon = 'join_alliance';
            } else if(pr['predicate'] == 'BUILDING_LEVEL' && pr['building_type'] === this.spec['name'] && this.level < pr['trigger_level']) {
                draw_idle_icon = 'upgrade';
            }
        } else {
            if(player.unit_donation_enabled()) {
                var spell = gamedata['spells']['REQUEST_UNIT_DONATION'];
                var togo = player.cooldown_togo(spell['cooldown_name']);
                if(player.donated_units_space() < player.donated_units_max_space() && (togo <= 0)) {
                    draw_idle_icon = 'request_unit_donation';
                }
            }
        }
    }

    return {'state': draw_idle_icon,
            's_replace': draw_idle_icon_s,
            'can_upgrade': false};
};

Building.prototype.get_idle_state_advanced = function() {
    var draw_idle_icon = null;
    var draw_idle_icon_s = null;
    var can_upgrade = false;

    // check for upgradeability
    if(!player.foreman_is_busy() && this.time_until_finish() < 0 && this.level < this.get_max_ui_level()) {
        var req = get_leveled_quantity(this.spec['requires']||null, this.level+1);
        if(req && !read_predicate(req).is_satisfied(player, null)) {
            // cannot upgrade due to requirement predicate
        } else {
            // check minimum resource amounts
            can_upgrade = true;
            for(var res in gamedata['resources']) {
                if(player.resource_state[res][1] < get_leveled_quantity(this.spec['build_cost_'+res] || 0, this.level+1)) {
                    // cannot upgrade
                    can_upgrade = false;
                    break;
                }
            }
        }
    }

    // check for idleness
    if(this.is_producer()) {
        var contents = this.interpolate_contents();
        var threshold = (this.produce_start_time > 0 && this.produce_rate > 0 ? Math.max(2, Math.floor((this.produce_rate/3600.0) * (gamedata['client']['harvester_idle_seconds'] || 60))) : -1);
        var resname = null;
        for(var res in gamedata['resources']) {
            if(('produces_'+res) in this.spec) {
                resname = res; break;
            }
        }
        if(contents >= this.get_production_capacity()) {
            draw_idle_icon = 'harvest_'+resname+'_full';
        } else if(threshold > 0 && contents >= threshold) {
            draw_idle_icon = 'harvest_'+resname;
        }
    } else if(this.is_storage() && this.spec['name'] != gamedata['townhall']) {
        // fullness state
        var resname = null;
        for(var res in gamedata['resources']) {
            if(('storage_'+res) in this.spec) {
                resname = res; break;
            }
        }
        if(resname) {
            var fullness = get_storage_fullness(resname);
            if(fullness >= 1) { draw_idle_icon = 'full'; }
        }
    } else if(this.is_factory() && !this.is_manufacturing()) {
        var space_usage = player.get_army_space_usage_by_squad();
        if(space_usage['ALL'] < player.stattab['total_space']) {
            for(var specname in gamedata['units']) {
                var spec = gamedata['units'][specname];
                if(spec['manufacture_category'] == this.spec['manufacture_category']) {
                    var level = unit_unlock_level(specname);
                    if(level > 0) {
                        var pred_ok = true;
                        for(var pred in {'requires':1,'activation':1,'show_if':1}) {
                            if(pred in spec && !read_predicate(get_leveled_quantity(spec[pred], level)).is_satisfied(player, null)) {
                                pred_ok = false;
                                break;
                            }
                        }
                        if(pred_ok && player.stattab['total_space'] >= space_usage['ALL'] + get_leveled_quantity(spec['consumes_space'],level)) {
                            var res_ok = true;
                            for(var res in gamedata['resources']) {
                                if(player.resource_state[res][1] < get_leveled_quantity(spec['build_cost_'+res] || 0, level)) {
                                    // cannot manufacture
                                    res_ok = false;
                                    break;
                                }
                            }
                            if(res_ok) { // can make at least one unit
                                // detect human units by looking for a walk cycle in units.json
                                draw_idle_icon = (spec['walk_period'] ? 'train_advanced' : 'manufacture_advanced');
                                break;
                            }
                        }
                    }
                }
            }
        }
    } else if(this.is_researcher() && !this.is_researching()) {
        for(var specname in gamedata['tech']) {
            var spec = gamedata['tech'][specname];
            var cur_level = player.tech[specname]||0;
            if(cur_level < get_max_ui_level(spec) && goog.array.contains(this.spec['research_categories'], spec['research_category'])) {
                var pred_ok = true;
                for(var pred in {'requires':1,'activation':1,'show_if':1}) {
                    if(pred in spec && !read_predicate(get_leveled_quantity(spec[pred], cur_level+1)).is_satisfied(player, null)) {
                        pred_ok = false;
                        break;
                    }
                }
                if(pred_ok) {
                    var res_ok = true;
                    for(var res in gamedata['resources']) {
                        if(player.resource_state[res][1] < get_leveled_quantity(spec['cost_'+res] || 0, cur_level+1)) {
                            // cannot manufacture
                            res_ok = false;
                            break;
                        }
                    }
                    if(res_ok) { // can research at least one tech
                        draw_idle_icon = 'research_advanced';
                        break;
                    }
                }
            }
        }
    } else if(this.is_crafter()) {
        if((!this.is_crafting() || this.crafting_progress_one() < 0) && !(this.is_emplacement() && this.turret_head_item())) {
            for(var i = 0; i < this.spec['crafting_categories'].length; i++) {
                var catname = this.spec['crafting_categories'][i];
                var cat = gamedata['crafting']['categories'][catname];
                if(catname == 'mines') {
                    if(!player.all_minefields_armed()) {
                        draw_idle_icon = cat['idle_state'] || 'craft_advanced';
                        break;
                    } else {
                        continue;
                    }
                }
                draw_idle_icon = cat['idle_state'] || 'craft_advanced';
                if(draw_idle_icon == 'fish') {
                    if(player.cooldown_active('fish_slate_assigned')) {
                        // show no idle icon if all available fishing SKUs are exhausted
                        if(!goog.object.findKey(gamedata['crafting']['recipes'], function(recipe) {
                            return (recipe['crafting_category'] == 'fishing' && read_predicate(recipe['show_if']).is_satisfied(player, null));
                        })) {
                            draw_idle_icon = null;
                        }
                    }
                }
                break;
            }
        } else if(this.crafting_progress_one() < 0) {
            /* draw_idle_icon = 'craft_done'; */
        }

        if(this.is_emplacement() && this.turret_head_item()) { // assumes emplacements are crafters
            var item_spec = ItemDisplay.get_inventory_item_spec(this.turret_head_item());
            // check if our tech level for this item is above its own level
            if('level' in item_spec && 'associated_tech' in item_spec) {
                var tech_level = player.tech[item_spec['associated_tech']] || 0;
                if(tech_level > item_spec['level']) {
                    draw_idle_icon = 'under_leveled_turret_head';
                }
            }
        }
    } else if(this.is_crafter() && this.crafting_progress_one() < 0) {
        /* draw_idle_icon = 'craft_done_advanced'; */
    } else if(this.is_lottery_building()) {
        if(this.contents >= 1) { draw_idle_icon = 'scan'; }
    } else if(this.spec['name'] === gamedata['alliance_building']) {
        if(!session.is_in_alliance()) {
            var pr = gamedata['predicate_library']['alliance_join_requirement'];
            if(read_predicate({'predicate':'LIBRARY','name':'alliance_join_requirement'}).is_satisfied(player, null)) {
                draw_idle_icon = 'join_alliance_advanced';
            } else if(pr['predicate'] == 'BUILDING_LEVEL' && pr['building_type'] === this.spec['name'] && this.level < pr['trigger_level']) {
                draw_idle_icon = 'upgrade_to_join_alliance';
            }
        } else {
            if(player.unit_donation_enabled()) {
                var spell = gamedata['spells']['REQUEST_UNIT_DONATION'];
                var togo = player.cooldown_togo(spell['cooldown_name']);
                if(player.donated_units_space() < player.donated_units_max_space() && (togo <= 0)) {
                    draw_idle_icon = 'request_unit_donation_advanced';
                }
            }
        }
    }

    return {'state': draw_idle_icon,
            's_replace': draw_idle_icon_s,
            'can_upgrade': can_upgrade};
};

function draw_building_or_inert(obj, powerfac) {
    // for odd gridsizes, add one-half unit to center the sprite on the grid bounds
    var gridsize = obj.spec['gridsize'];
    var odd_shift = [gridsize[0] > 1 && (gridsize[0]&1) ? 0.5 : 0,
                     gridsize[1] > 1 && (gridsize[1]&1) ? 0.5 : 0];
    var xy = vec_floor(ortho_to_draw(vec_add([obj.x, obj.y], odd_shift)));

    var icon;
    var icon_state = 'unset';
    var icon_alternates = null; // substitutes in case icon is still loading [list of [icon, state]]
    var icon_time = client_time;
    var status_text = [];
    var sprite_data = null;

    if(obj.get_leveled_quantity(obj.spec['art_asset']) in GameArt.assets) {
        var sprite_name = obj.get_leveled_quantity(obj.spec['art_asset']);
        icon = GameArt.assets[sprite_name];
        sprite_data = gamedata['art'][sprite_name];
    } else {
        icon = "MISSING";
    }

    if(obj.is_destroyed()) {

        icon_alternates = [];
        if('damaged' in icon.states) {
            // use damaged version as alternate, if available
            icon_alternates.push([icon, 'damaged']);
        }
        // use normal version as alternate, if available
        icon_alternates.push([icon, 'normal']);

        var icon_name;

        if('destroyed_asset' in obj.spec) {
            icon_name = obj.spec['destroyed_asset'];
        } else {
            // use generic crater asset
            var size_str = obj.spec['gridsize'][0].toString()+'x'+obj.spec['gridsize'][1].toString();
            icon_name = 'building_crater_'+size_str;
        }

        if(!(icon_name in GameArt.assets)) {
            console.log('Missing destroyed building art asset '+icon_name);
            icon = "MISSING";
        } else {
            icon = GameArt.assets[icon_name];
        }
        icon_state = 'normal';
    } else if(obj.is_building() && obj.is_minefield()) {
        if(obj.is_minefield_armed()) {
            icon_state = 'loaded';
        } else {
            icon_state = 'normal';
        }
    } else if(obj.is_building() && obj.is_under_construction()) {
        // use generic under-construction asset
        var icon_name;
        if('under_construction_asset' in obj.spec) {
            icon_name = obj.spec['under_construction_asset'];
        } else {
            var size_str = obj.spec['gridsize'][0].toString()+'x'+obj.spec['gridsize'][1].toString();
            icon_name = 'building_construction_'+size_str;
        }

        if(!(icon_name in GameArt.assets)) {
            console.log('Missing under-construction building art asset '+icon_name);
            icon = "MISSING";
        } else {
            icon = GameArt.assets[icon_name];
        }
        icon_state = 'normal';
    } else if(obj.is_damaged() && !('turn_rate' in obj.spec)) {
        // ^ do not use damaged state for turrets, because it has no compass animation frames
        if(gamedata['client']['use_enemy_sprites'] && obj.team === 'enemy') {
            icon_state = 'enemy_damaged';
        } else {
            icon_state = 'damaged';
        }
        icon_alternates = [[icon, 'normal']]; // use normal version as alternate

    } else if(obj.is_building() && obj.is_storage() && obj.spec['name'] != gamedata['townhall'] && sprite_data && ('normal_fullness000' in sprite_data['states'])) {
        // fullness state
        var resname = null;
        for(var res in gamedata['resources']) {
            if(('storage_'+res) in obj.spec) {
                resname = res; break;
            }
        }
        if(resname) {
            var fullness = get_storage_fullness(resname);
            var TABLE = [[-Infinity,'000'],[0.25,'025'],[0.50,'050'],[0.75,'075'],[1.0,'100']];
            for(var i = 0; i < TABLE.length; i++) {
                if(fullness >= TABLE[i][0]) {
                    icon_state = 'normal_fullness'+TABLE[i][1];
                } else {
                    break;
                }
            }
        } else {
            throw Error("Cannot determine resname for "+obj.spec['name']);
        }

    } else {
        if(gamedata['client']['use_enemy_sprites'] && obj.team === 'enemy') {
            icon_state = 'enemy';
        } else {
            icon_state = 'normal';
        }
    }

    if(obj.is_invisible() && obj.team !== 'player' && !obj.is_destroyed()) {
        return; // hidden building!
    }

    if(obj.is_building() && obj.is_repairing()) {
        var progress = 1 + (server_time - obj.repair_finish_time)/obj.get_leveled_quantity(obj.spec['repair_time']);
        if(progress >= 1) {
            progress = 1;
            // ping server to see if it's been repaired
            if(/*obj.team === 'player' && */!obj.ping_sent) {
                send_to_server.func(["PING_OBJECT", obj.id, "repair_check", obj.spec['ui_name']]);
                obj.ping_sent = true;
            }
        }
        status_text.push(gamedata['strings']['cursors']['repairing']+': '+pretty_print_time(obj.repair_finish_time - server_time));
    }

    if(obj.is_building() && (obj.is_under_construction() || obj.is_upgrading() ||
                             obj.is_researching() || obj.is_manufacturing() || obj.is_crafting())) {
        var progress = 0;
        if(obj.is_under_construction()) {
            progress = obj.build_progress();
            if(progress >= 0 && (progress < 1 || obj.team == 'player')) {
                status_text.push(gamedata['strings']['cursors']['constructing']+': ' + pretty_print_time(obj.build_time_left()));
            }
        } else if(obj.is_upgrading()) {
            progress = obj.upgrade_progress();
            if(progress >= 0 && (progress < 1 || obj.team == 'player')) {
                status_text.push(gamedata['strings']['cursors']['upgrading']+': ' + pretty_print_time(obj.upgrade_time_left()));
            }
        } else if(obj.is_researching()) {
            var tech = (session.home_base ? player.tech : enemy.tech);
            var current = ((obj.research_item in tech) ? tech[obj.research_item] : 0);
            progress = obj.research_progress();
            if(progress >= 0 && (progress < 1 || obj.team == 'player')) {
                status_text.push(gamedata['strings']['cursors']['researching'].replace('%tech',gamedata['tech'][obj.research_item]['ui_name']).replace('%d', (current+1).toString())+': '+ pretty_print_time(obj.research_time_left()));
            }
        } else if(obj.is_crafting()) {
            var recipe = gamedata['crafting']['recipes'][obj.is_crafting()];
            progress = obj.crafting_progress_one();
            if(progress < 0) {
                // pending collection
                progress = 0;
            } else if(progress < 1 || obj.team == 'player') {
                status_text.push(get_crafting_recipe_ui_name(recipe) + ': '+pretty_print_time(obj.crafting_time_left_one()));
            }
        } else if(obj.is_manufacturing()) {
            var item = obj.manuf_queue[0];
            progress = obj.manuf_progress_one();
            if(progress < 1 || obj.team == 'player') {
                var s = gamedata['units'][item['spec_name']]['ui_name'];
                if(obj.manuf_queue.length > 1) {
                    s += ' ... ';
                }
                status_text.push(s + ': ' + pretty_print_time(obj.manuf_time_left()));
            }
        }

        if(progress >= 1) {
            progress = 1;
            // ping server to see if the action is finished
            if(obj.team === 'player' && !obj.ping_sent) {
                send_to_server.func(["PING_OBJECT", obj.id, "action_check", obj.spec['ui_name'], status_text.join('\n')]);
                obj.ping_sent = true;
            }
        }
    }

    var producer_halted = false;
    if(obj.is_building() && obj.is_producer()) {
        // draw harvester stats
        var contents = obj.interpolate_contents();
        var capacity = obj.get_production_capacity();

        // halt animation if full or disabled by low power
        if(powerfac == 0) {
            producer_halted = true;
        } else if(contents >= capacity && obj.team == 'player') {
            // note: do not stop animation on harvesters owned by other players or AIs, even if they are actually full
            producer_halted = true;
        }
    }

    // pause animation for idle factories and research labs
    if(obj.is_building() &&
       (obj.is_upgrading() ||
        (obj.is_factory() && !obj.is_manufacturing()) ||
        (obj.is_researcher() && !obj.is_researching()) ||
        (obj.is_producer() && producer_halted) ||
        (obj.is_crafter() && !obj.is_crafting() && !obj.spec['invert_idle']) ||
        (obj.is_lottery_building() && obj.contents < 1))) {
        icon_time = 0;
    } else if(obj.spec['invert_idle'] && obj.is_building() && !obj.is_destroyed() && obj.is_crafter() && obj.is_crafting()) {
        // this is used for Logistics Dispatch
        // icon_time = 0; // do not halt rotor blades when collection is pending
        if(obj.crafting_progress_one() >= 0 && icon_state == 'normal' && icon.has_state('normal_idle')) {
            icon_state = 'normal_idle'; // or if a job is in progress right now, show no helicopter
        }
    } else {
        // de-synchronize building animation loops
        icon_time += 2.7*obj.anim_offset;
    }

    // find wall segments
    var draw_as_wall = get_leveled_quantity(obj.spec['draw_as_wall']||null, obj.level);
    var wall_to = {'north':false, 'east':false, 'south':false, 'west':false}, wall_spacing = 0, wall_seg_offset = 0;
    if(draw_as_wall && !obj.is_destroyed() && ((icon_state+'_ns') in sprite_data['states'])) {
        wall_spacing = Math.floor(obj.spec['gridsize'][0]/2);
        // this extra offset is necessary for wall segments to be right on the centerline between posts
        // when the spacing is greater than 1 grid unit (SG)
        wall_seg_offset = (wall_spacing > 1 ? 0.25 : 0);

        var OFFSETS = [[0,-2*wall_spacing,'north'],
                       [0, 2*wall_spacing,'south'],
                       [-2*wall_spacing,0,'west'],
                       [ 2*wall_spacing,0,'east']
                      ];

        for(var i = 0; i < OFFSETS.length; i++) {
            var objlist = voxel_map_accel.objects_near_xy([obj.x+OFFSETS[i][0], obj.y+OFFSETS[i][1]], obj.team);
            if(objlist) {
                for(var j = 0; j < objlist.length; j++) {
                    var o = objlist[j];
                    if(!o.is_destroyed() && o.spec === obj.spec && o.team === obj.team) {
                        if(o.y == obj.y+OFFSETS[i][1] && o.x == obj.x+OFFSETS[i][0]) {
                            wall_to[OFFSETS[i][2]] = true;
                        }
                    }
                }
            }
        }

        /* // unoptimized brute-force version
        for(var id in session.cur_objects.objects) {
            var o = session.cur_objects.objects[id];
            if(o.y >= obj.y && (o.y - obj.y) < 2*wall_spacing && o.x == obj.x+2*wall_spacing) {
                wall_to['east'] = true;
            } else if(o.x >= obj.x && (o.x - obj.x) < 2*wall_spacing && o.y == obj.y+2*wall_spacing) {
                wall_to['south'] = true;
            }
        }
        */
    }

    // when the draw_as_wall setting is "corner_posts", do not draw posts in the middle of a continuous long NS or EW string
    var skip_wall_post = (draw_as_wall == 'corner_posts' &&
                          ((wall_to['north'] && wall_to['south'] && !wall_to['east'] && !wall_to['west']) ||
                           (!wall_to['north'] && !wall_to['south'] && wall_to['east'] && wall_to['west'])));
    // DRAW BUILDING

    if(icon != "MISSING" && !skip_wall_post) {
        var facing = 0;
        if(obj.is_inert() && obj.metadata && 'facing' in obj.metadata) {
            facing = obj.metadata['facing'];
        } else if('turn_rate' in obj.spec && !(obj.is_building() && (obj.is_upgrading() || obj.is_repairing() || obj.disarmed))) {
            facing = obj.interpolate_facing();
        }
        if(icon) {
            var ready = icon.prep_for_draw(xy, facing, icon_time, icon_state);

            // if desired icon state is not ready to draw yet, but an alternate exists and is ready to draw, use that instead
            var drawn = false;
            if(!ready && icon_alternates) {
                for(var i = 0; i < icon_alternates.length; i++) {
                    var alt = icon_alternates[i][0], st = icon_alternates[i][1];
                    if(alt.ready_to_draw(xy, facing, icon_time, st)) {
                        alt.draw(xy, facing, icon_time, st);
                        drawn = true;
                        break;
                    }
                }
            }

            if(!drawn) {
                icon.draw(xy, facing, icon_time, icon_state);
            }
        } else {
            throw Error('missing art asset for '+obj.spec['name']);
        }

        if(obj.is_building() && obj.is_invul()) {
            var asset = (obj.spec['gridsize'][0] >= 12 ? 'building_shield_big' : 'building_shield_small');
            if(asset in GameArt.assets) { GameArt.assets[asset].draw(xy, facing, client_time, 'normal'); }
        }
    }

    // draw weapon
    if(obj.is_building() && !obj.is_destroyed() && ('weapon_offset' in obj.spec)) {
        var weapon_asset = obj.get_stat('weapon_asset', null);
        if(weapon_asset) {
            var weapon_icon = GameArt.assets[weapon_asset];
            if(weapon_icon) {
                var x = obj.x + odd_shift[0], z = obj.y + odd_shift[1];
                var weapon_offset = obj.get_leveled_quantity(obj.spec['weapon_offset']);
                var pos = vec_floor(ortho_to_draw_3d(v3_add([x,0,z], weapon_offset)));
                weapon_icon.draw(pos, facing + (obj.spec['weapon_facing_fudge']||0), icon_time, icon_state);
            } else {
                //console.log('cannot find '+weapon_asset);
            }
        }
    }

    // draw wall segments
    if(wall_to['east']) {
        icon.draw(ortho_to_draw([obj.x+wall_spacing, obj.y-wall_seg_offset]), facing, icon_time, icon_state + '_ew');
    }
    if(wall_to['south']) {
        icon.draw(ortho_to_draw([obj.x-wall_seg_offset, obj.y+wall_spacing]), facing, icon_time, icon_state + '_ns');
    }

    // draw lottery scans remaining
    if(obj.team === 'player' && obj.is_building() && obj.is_lottery_building() && obj.contents >= 1) {
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = 'rgba(213,0,0,1)';
        SPUI.add_beveled_rectangle_to_path(vec_add(xy, obj.spec['scan_counter_offset']), [12+8*Math.floor(Math.log(obj.contents)/Math.log(10)),14], 2);
        ctx.fill();
        ctx.font = SPUI.make_font(13, 16, 'thick');
        ctx.fillStyle = 'rgba(255,255,255,1)';
        var txy = vec_add(vec_add(xy, obj.spec['scan_counter_offset']), [2,12]);
        ctx.fillText(pretty_print_number(obj.contents), txy[0], txy[1]);
        ctx.restore();
    }

    // draw harvest glow
    if(obj.harvest_glow_time > 0) {
        var glow_t = (client_time - obj.harvest_glow_time)/gamedata['client']['harvest_glow_time'];
        var glow = 0;
        if(glow_t > 1) {
            obj.harvest_glow_time = -1;
        } else if(glow_t > 0) {
            glow = Math.exp(-12*(glow_t-0.3)*(glow_t-0.3));
        }
        if(glow > 0) {
            ctx.save();

            // manual hack to position the effect over the harvester
            var off = ('harvest_glow_pos' in obj.spec ? obj.spec['harvest_glow_pos'] : [0,0]);

            if(obj.team === 'player') {
                // draw glow sprite
                ctx.globalAlpha = 0.75*glow;
                GameArt.assets['harvester_glow'].states['normal'].draw([xy[0]+off[0],xy[1]+off[1]], 0, 0);
            }

            // draw ringy things
            ctx.strokeStyle = 'rgba(128,255,255,1.0)';
            ctx.lineWidth = 3;
            var ring_y;
            ctx.globalAlpha = 0.55*(1-glow_t);
            ctx.save();
            ctx.beginPath();
            ring_y = -120*glow_t + 45;
            ctx.transform(1, 0, 0, 0.5, xy[0]+off[0], xy[1]+off[1]+ring_y);
            ctx.arc(0, 0, 60, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.restore();

            ctx.save();
            ctx.beginPath();
            ring_y = -240*glow_t + 45;
            ctx.transform(1, 0, 0, 0.5, xy[0]+off[0], xy[1]+off[1]+ring_y);
            ctx.arc(0, 0, 30, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.restore();

            ctx.save();
            ctx.beginPath();
            ring_y = -360*glow_t + 45;
            ctx.transform(1, 0, 0, 0.5, xy[0]+off[0], xy[1]+off[1]+ring_y);
            ctx.arc(0, 0, 15, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.restore();

            ctx.restore();
        }
    }

    // draw level flags
    if(obj.is_building() && !obj.is_destroyed() && player.get_any_abtest_value('enable_building_level_flags', gamedata['client']['enable_building_level_flags']) &&
      ('level_flag_offset' in obj.spec)) {
        var fsprite_name = 'building_level_flag_L'+obj.level.toFixed(0);
        if(fsprite_name in GameArt.assets) {
            var fsprite = GameArt.assets[fsprite_name].states['normal'];
            var foffset = ortho_to_draw_vector(obj.spec['level_flag_offset']);
            fsprite.draw_topleft(vec_floor(vec_add(xy, foffset)), 0, 0);
        }
    }

    // draw equip icons
    if(obj.is_building() && obj.equipment) {
        var ecount = 0, elevel = 0;
        for(var slot_type in obj.equipment) {
            if(slot_type == "mine" || // maybe set "show":0 on mine slots?
               ('show' in gamedata['strings']['equip_slots'][slot_type]) && !gamedata['strings']['equip_slots'][slot_type]['show']) { continue; }
            var item_list = obj.equipment[slot_type];
            for(var i = 0; i < item_list.length; i++) {
                if(item_list[i]) {
                    var espec = ItemDisplay.get_inventory_item_spec(item_list[i]);
                    if(('equip' in espec) && ('show_to_enemy' in espec['equip']) && !espec['equip']['show_to_enemy'] && obj.team !== 'player') { continue; }
                    elevel = Math.max(elevel, espec['level'] || 1);
                    ecount += 1;
                }
            }
        }
        var esprite_name = 'equip_icon'; // 'equip_icon_rarity'+rarity.toString();
        var esprite = GameArt.assets[esprite_name].states['normal'];
        var draw_count = elevel; // draw one icon per level, for the max level among all equips
        if(draw_count > 0) {
            var eoffset_map, edelta_map;
            if('equip_icon_offset' in obj.spec) {
                eoffset_map = obj.spec['equip_icon_offset'];
            } else {
                var d = gamedata['client']['default_equip_icon_offset'];
                eoffset_map = [d[0]*obj.spec['gridsize'][0]/2, d[1]*obj.spec['gridsize'][1]/2];
            }
            if('equip_icon_delta' in obj.spec) {
                edelta_map = obj.spec['equip_icon_delta'];
            } else {
                edelta_map = gamedata['client']['default_equip_icon_delta'];
            }
            var eoffset = ortho_to_draw_vector(eoffset_map);
            var edelta = ortho_to_draw_vector(edelta_map);
            //ctx.save();
            //ctx.globalAlpha = gamedata['client']['cloaked_opacity'];
            for(var i = 0; i < draw_count; i++) {
                esprite.draw_topleft(vec_floor(vec_add(vec_add(xy, eoffset), vec_scale(i, edelta))), 0, 0);
            }
            //ctx.restore();
        }
    }

    // draw alliance membership

    if('show_alliance_at' in obj.spec) {
        var alliance_id = -1;
        if(obj.team === 'player') {
            alliance_id = session.alliance_id;
        } else if(obj.team === 'enemy' && !session.home_base && !session.viewing_ai) {
            var player_entry = PlayerCache.query_sync(session.viewing_user_id);
            if(player_entry && ('alliance_id' in player_entry) && player_entry['alliance_id'] > 0) {
                alliance_id = player_entry['alliance_id'];
            }
        }
        var alliance_name = null;
        if(alliance_id > 0) {
            var info = AllianceCache.query_info_sync(alliance_id);
            if(info && ('ui_name' in info)) {
                alliance_name = alliance_display_name(info);
            }
        }
        //console.log(" ID "+alliance_id+" "+alliance_name);
        if(alliance_name) {
            var s = gamedata['strings']['alliance_building_tag'].replace('%s', alliance_name);
            draw_centered_text_with_shadow(ctx, s, vec_add(xy, obj.spec['show_alliance_at']));
        }
    }

    // draw status text
    var default_text_height = obj.get_health_bar_dims()[2];
    var status_text_height = default_text_height + 6;
    if(obj.is_damaged()) {
        // move to not conflict with health bar
        status_text_height = default_text_height - 30;
    }

    var count = 0;

    // draw "low power" icon
    if(powerfac < 1 && obj.is_building() && !obj.is_destroyed() && player.tutorial_state == "COMPLETE" &&
       ((obj.is_shooter() && !obj.is_minefield()) || obj.is_producer())
      /* obj.get_leveled_quantity(obj.spec['consumes_power'] || 0) > 0 */
      ) {
        GameArt.assets['low_power_icon'].states['normal'].draw([xy[0]+30+20*count,xy[1]-default_text_height+5], 0, 0);
        count++;
    }

    if(!obj.spec['worth_less_xp']) {

        // draw auras
        if(obj.combat_stats.stunned && !obj.is_destroyed()) {
            GameArt.assets['stun_icon'].states['normal'].draw([xy[0]+30+20*count,xy[1]-default_text_height+5], 0, 0);
            count++;
        }

        for(var i = 0; i < obj.auras.length; i++) {
            var aura = obj.auras[i];
            if(aura.visual_effect) {
                var pos = obj.interpolate_pos();
                aura.visual_effect.reposition([pos[0], 0, pos[1]]);
            }
            if(aura.spec['visual_effect'] || (aura.spec['show'] === 0)) { continue; } // aura has its own graphics
            draw_aura(xy, [xy[0]+30+20*count, xy[1]-default_text_height+5], aura);
            count++;
        }

        // draw status text
        if(status_text.length > 0) {
            var text_xy = [xy[0], xy[1]-status_text_height+6-0*SPUI.desktop_font.size];
            var LINEHEIGHT = 20;

            // draw drop shadow
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,1)';
            for(var i = 0; i < status_text.length; i++) {
                draw_centered_text(ctx, status_text[i], [text_xy[0]+1,text_xy[1]+1+i*LINEHEIGHT]);
            }
            ctx.restore();

            // draw main text
            // color top line white, lower lines gray (to indicate paused actions)
            for(var i = 0; i < status_text.length; i++) {
                var paused = (i != 0) || (obj.is_damaged() && !obj.is_repairing());
                if(paused) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(200,200,200,1)';
                }
                draw_centered_text(ctx, status_text[i], [text_xy[0], text_xy[1]+i*LINEHEIGHT]);
                if(paused) {
                    ctx.restore();
                }
            }
        }
    }

    // draw health bar
    draw_health_bar(xy, obj);

    // draw build idle status
    if(session.home_base && !session.has_attacked && gamedata['client']['enable_idle_icons'] && !player.is_cheater &&
       obj.is_building() && obj.team === 'player' && !obj.spec['worth_less_xp'] &&
       player.tutorial_state == "COMPLETE" && get_preference_setting(player.preferences, 'show_idle_buildings') &&
       read_predicate({'predicate':'LIBRARY', 'name': ('show_idle_buildings' in gamedata['predicate_library'] ? 'show_idle_buildings' : 'extended_tutorial_complete')}).is_satisfied(player,null)) {
        var idle = obj.get_idle_state();
        if(idle) {
            if(idle['can_upgrade']) {
                var eoffset_map = obj.spec['equip_icon_offset'] || vec_mul(gamedata['client']['default_equip_icon_offset'], vec_scale(0.5, obj.spec['gridsize']));
                var eoffset = ortho_to_draw_vector(eoffset_map);
                var img = GameArt.assets[gamedata['strings']['idle_buildings']['upgrade_advanced']['icon']].states['normal'];

                var sz = (obj.spec['unit_collision_gridsize']||obj.spec['gridsize']);
                var pos = vec_floor(vec_add(xy, ortho_to_draw_vector(vec_mul(sz, gamedata['strings']['idle_buildings']['upgrade_advanced']['icon_delta']))));
                var text_edge = draw_centered_text_with_shadow(ctx, gamedata['strings']['idle_buildings']['upgrade_advanced']['ui_name_short'], pos);
                img.draw_topleft(vec_add(text_edge, vec_scale(-1, gamedata['strings']['idle_buildings']['upgrade_advanced']['text_offset'])), 0, 0);
            }
            if(idle['state']) {
                if(!(idle['state'] in gamedata['strings']['idle_buildings'])) { throw Error('unknown building idle state '+idle['state']); }
                var text_ctr = vec_add(xy, [0, -Math.floor(0.75*default_text_height)]);
                var text_str = gamedata['strings']['idle_buildings'][idle['state']]['ui_name'];
                if(idle['s_replace']) { text_str = text_str.replace('%s', idle['s_replace']); }
                var text_edge = draw_centered_text_with_shadow(ctx, text_str, text_ctr);
                var icon_name = gamedata['strings']['idle_buildings'][idle['state']]['icon'];
                if(!(icon_name in GameArt.assets)) { throw Error('invalid draw_idle_icon '+icon_name); }
                GameArt.assets[icon_name].states['normal'].draw(vec_add(text_edge, [-19,-5]), 0, client_time);
            }
        }
    }

    if(0 /*PLAYFIELD_DEBUG*/) {
        // draw text label
        draw_centered_text(ctx, obj.spec['ui_name'] + ' (' + obj.team + ')', [xy[0], xy[1]-18]);
    }

    if(AI_DEBUG && obj.is_building() && obj.is_shooter()) {
        // draw ai state
        draw_centered_text(ctx, control_state_names[obj.control_state], [xy[0],xy[1]+30]);
        draw_centered_text(ctx, ai_state_names[obj.ai_state], [xy[0],xy[1]+45]);
    }

    obj.update_permanent_effect();
}

/**
 * Draws separate shadow sprites for a given GameObject.
 * @param {GameObject} unit
 */
function draw_shadow(unit) {
    if(!unit.is_mobile() || !unit.is_flying()) { return; }
    if(session.viewing_base.base_climate_data['fly_at_ground_level']) { return; }

    if(unit.altitude > 0 && !unit.is_destroyed() && 'shadow_asset' in unit.spec) {
        var curpos = unit.interpolate_pos_for_draw();
        var xy = ortho_to_draw(curpos);
        xy[0] = Math.floor(xy[0]); xy[1] = Math.floor(xy[1]);

        if((xy[0]+MAX_UNIT_SPRITE_SIZE < view_roi[0][0]) ||
           (xy[0]-MAX_UNIT_SPRITE_SIZE > view_roi[1][0]) ||
           (xy[1]+MAX_UNIT_SPRITE_SIZE < view_roi[0][1]) ||
           (xy[1]-MAX_UNIT_SPRITE_SIZE > view_roi[1][1])) {
            // cull
            return;
        }
        var alpha = ('unit_shadow_alpha' in session.viewing_base.base_climate_data ? session.viewing_base.base_climate_data['unit_shadow_alpha'] : 1);
        if(alpha > 0) {
            if(alpha != 1) { ctx.save(); ctx.globalAlpha = alpha; }
            GameArt.assets[unit.spec['shadow_asset']].draw(ortho_to_draw(curpos), 0, client_time, 'normal');
            if(alpha != 1) { ctx.restore(); }
        }
    }
}

// return true if the unit is on screen, false if offscreen
function draw_unit(unit) {
    // get simulated position
    var curpos = unit.interpolate_pos_for_draw();
    var alt = unit.altitude;

    // don't levitate debris piles
    if(unit.hp <= 0 && !unit.is_indestructible()) { alt = 0; }

    // perturb altitude to make flying units bob up and down
    if(alt > 0) {
        alt += 0.08 * Math.sin(2.2*client_time + 2*Math.PI*unit.anim_offset);
        if(unit.is_mobile() && unit.combat_stats.erratic_flight > 0) {
            curpos[0] += 0.7 * unit.combat_stats.erratic_flight * Math.sin(3.14*client_time + 2*Math.PI*unit.anim_offset);
            curpos[1] += 0.7 * unit.combat_stats.erratic_flight * Math.sin(3.64*client_time + 2*Math.PI*unit.anim_offset);
        }
    }

    var xy = ortho_to_draw_3d([curpos[0], alt, curpos[1]]);

    if(unit.altitude > 0 || view_is_zoomed()) {
        // NOTE: do not quantize xy, to get subpixel motion on the hovering effect for flying units
        // may be slow on some browsers!
    } else {
        xy = vec_floor(xy);
    }

    if((xy[0]+MAX_UNIT_SPRITE_SIZE < view_roi[0][0]) ||
       (xy[0]-MAX_UNIT_SPRITE_SIZE > view_roi[1][0]) ||
       (xy[1]+MAX_UNIT_SPRITE_SIZE < view_roi[0][1]) ||
       (xy[1]-MAX_UNIT_SPRITE_SIZE > view_roi[1][1])) {
        // cull
        return false;
    }

    var state;
    if(gamedata['client']['use_enemy_sprites'] && unit.team === 'enemy') {
        state = 'enemy';
    } else {
        state = 'normal';
    }

    // draw the sprite
    var sprite, alpha;
    if(unit.hp > 0 || unit.max_hp === 0) {
        sprite = unit.get_leveled_quantity(unit.spec['art_asset']);

        // special movement states
        var sprite_data = gamedata['art'][sprite];
        var mystates = sprite_data['states'];
        if((unit.control_state === control_states.CONTROL_SHOOT) && unit.control_spellname && ('melee_cycle' in sprite_data)) {
            // melee strikes
            var spell = gamedata['spells'][unit.control_spellname];
            // seconds remaining before next strike initiation
            var remaining_cooldown = unit.control_cooldown * TICK_INTERVAL - (client_time - last_tick_time);

            // calculate the spell's final cooldown value, accounting for things like unit rate of fire and power loss
            var cooldown = unit.get_leveled_quantity(spell['cooldown']);
            cooldown = cooldown / unit.combat_stats.rate_of_fire;
            cooldown = cooldown / unit.combat_power_factor();

            var animation_progress = -1;
            if('melee_cycle_duration' in spell) {
                // animation_start and animation_end are represented as a time delta from client_time to when those events occur(ed)
                var animation_start = remaining_cooldown - cooldown;
                var animation_duration = spell['melee_cycle_duration'];
                var animation_end = animation_start + animation_duration;

                if(animation_start <= 0 && animation_end > 0) {
                    animation_progress = Math.min(Math.max(1.0 - (animation_end / animation_duration), 0), 0.999);
                }
            } else {
                // run the melee animation across the entire actual spell cooldown
                animation_progress = Math.min(Math.max(1.0 - (remaining_cooldown / cooldown), 0), 0.999); // don't go to 1.0 since that will overflow the cycle length
            }

            if(animation_progress != -1) {
                var frame = Math.floor(sprite_data['melee_cycle'].length * animation_progress);
                state = sprite_data['melee_cycle'][frame];
            } else {
                // default to the "pausing between strikes" frame outside of the actual attack animation
                state = state + '_shoot';
            }
        } else if((unit.control_state === control_states.CONTROL_SHOOT) && (state+'_shoot' in mystates)) {
            state = state+'_shoot';
        } else if((unit.control_state === control_states.CONTROL_MOVING) && ('walk_cycle' in sprite_data)) {
            var walk_period = unit.get_leveled_quantity(unit.spec['walk_period'] || 1.0);
            var cycprog = ((client_time/walk_period) + unit.anim_offset) % 1.0;
            var cycfrm = Math.floor(sprite_data['walk_cycle'].length*cycprog);
            state = sprite_data['walk_cycle'][cycfrm];
        }

        if(unit.spec['cloaked']) {
            if(unit.team !== 'player' && unit.is_invisible()) {
                return false; // hidden unit!
            }
            if(unit.team === 'player') {
                if(unit.is_invisible()) {
                    alpha = gamedata['client']['invisible_opacity'];
                } else {
                    alpha = gamedata['client']['cloaked_opacity'];
                }
            } else {
                // even moving cloaked units get the lower opacity if they are unfriendly
                alpha = gamedata['client']['invisible_opacity'];
            }

        } else {
            alpha = 1;
        }
        alpha *= unit.cur_opacity;
    } else {
        if('destroyed_inert' in unit.spec) {
            if(unit.spec['destroyed_inert']) {
                sprite = gamedata['inert'][unit.spec['destroyed_inert']]['art_asset'];
            } else {
                sprite = null;
            }
        } else {
            sprite = gamedata['inert'][gamedata['default_debris_inert']]['art_asset'];
        }
        alpha = 1;
    }

    // fade in/out
    if(alpha != unit.last_opacity) {
        var trans_time = gamedata['client'][(unit.spec['cloaked'] ? 'cloak_transition_time' : 'unit_fade_time')];
        var trans_rate = 1.0 / trans_time;
        var trans_amt = Math.max(0, client_time - unit.last_opacity_time) * trans_rate;
        if(alpha < unit.last_opacity) {
            alpha = Math.max(alpha, unit.last_opacity - trans_amt);
        } else {
            alpha = Math.min(alpha, unit.last_opacity + trans_amt);
        }
        unit.last_opacity = alpha;
        unit.last_opacity_time = Math.max(client_time, unit.last_opacity_time);
    }

    if(sprite) {
        if(alpha != 1) { ctx.save(); ctx.globalAlpha = alpha; }
        GameArt.assets[sprite].draw(xy, unit.interpolate_facing(), client_time, state);
        if(alpha != 1) { ctx.restore(); }
    }

    if(0 /*PLAYFIELD_DEBUG*/) {
        // draw team tag
        draw_centered_text(ctx, unit.spec['ui_name'] + ' (' + unit.team + ')', [xy[0],xy[1]+15]);
    }

    if(unit.hp > 0 && unit.spec['elite_marker_offset'] && (SPFX.detail < 2) && !player.get_any_abtest_value('enable_pixel_manipulation_in_low_gfx', gamedata['client']['enable_pixel_manipulation_in_low_gfx'])) {
        GameArt.assets['elite_marker'].states['normal'].draw(vec_add(xy, unit.spec['elite_marker_offset']), 0, 0);
    }

    draw_health_bar(xy, unit);


    // draw repair wrench
    if(session.home_base && !session.has_attacked && unit.is_under_repair() && unit.team == 'player') {
        GameArt.assets['repair_wrench_' + (player.unit_repair_queue[0]['obj_id'] === unit.id ? 'green' : 'gray')].states['normal'].draw([xy[0]+20,xy[1]+15], 0, 0);
    } else if(unit.hp == 0 && unit.team == 'player') {
        // draw zombie skull
        GameArt.assets['repair_skull'].states['normal'].draw([xy[0]+20,xy[1]+15], 0, 0);
    } else if((unit.hp > 0) && ((unit.hp / unit.max_hp) < gamedata['zombie_debuff_threshold']) && unit.team == 'player' &&
       player.get_any_abtest_value('enable_zombie_debuff', gamedata['enable_zombie_debuff'])) {
        // when at home base, show yellow wrench unconditionally when at critical damage
        // but when attacking, only show if the weak_zombie aura truly applies (i.e. ignore battle damage that occurs DURING the fight).
        var show_yellow_wrench = session.home_base;
        if(!show_yellow_wrench) {
            for(var i = 0; i < unit.auras.length; i++) {
                if(unit.auras[i].spec['code'] === 'weak_zombie') {
                    show_yellow_wrench = true;
                    break;
                }
            }
        }
        if(show_yellow_wrench) {
            GameArt.assets['repair_wrench_yellow'].states['normal'].draw([xy[0]+20,xy[1]+15], 0, 0);
        }
    }

    // ping to make sure we bring the object up as soon as possible
    if(unit.is_under_repair() && (unit.hp == 0 || server_time > unit.under_repair_finish)) {
        request_unit_repair_update();
    }



    // draw ai state
    if(AI_DEBUG) {
        draw_centered_text(ctx, control_state_names[unit.control_state], [xy[0],xy[1]+30]);
        draw_centered_text(ctx, ai_state_names[unit.ai_state] + (unit.ai_aggressive ? '(Agg)' : ''), [xy[0],xy[1]+45]);
        draw_centered_text(ctx, 'DEST: '+(unit.ai_dest ? unit.ai_dest[0]+','+unit.ai_dest[1] : 'null'), [xy[0],xy[1]+60]);
        if(unit.squad_id) {
            draw_centered_text(ctx, 'SQUAD: '+unit.squad_id.toString(), [xy[0],xy[1]+75]);
        }
        if(unit.ai_threatlist !== null) {
            var s_list = goog.array.map(unit.ai_threatlist, function(entry) { return JSON.stringify(entry); });
            var s = s_list.join("\n");
            if(s) {
                draw_centered_text(ctx, s, [xy[0], xy[1]+75]);
            }
        }
    }

    // draw auras
    var count = 0;
    if(unit.combat_stats.stunned && !unit.is_destroyed()) {
        GameArt.assets['stun_icon'].states['normal'].draw([xy[0]+15*count,xy[1]-25], 0, 0);
        count++;
    }

    for(var i = 0; i < unit.auras.length; i++) {
        var aura = unit.auras[i];
        if(aura.visual_effect) {
            aura.visual_effect.reposition([curpos[0], unit.altitude, curpos[1]]);
        }
        if(aura.spec['visual_effect'] || (aura.spec['show'] === 0)) { continue; } // aura has its own graphics
        draw_aura(xy, [xy[0]+15*count, xy[1]-35], aura);
        count++;
    }

    unit.update_permanent_effect();

    // return whether unit is visible on screen or not (in addition to being unculled), for the purpose of determining whether to show the offscreen-unit arrow
    var visible = (xy[0] >= view_roi[0][0] &&
                   (xy[0] < view_roi[1][0]) &&
                   (xy[1] >= view_roi[0][1]) &&
                   (xy[1] < view_roi[1][1]));
    if(0) {
        console.log(unit.spec['ui_name']+' vis '+visible+' xy '+xy[0].toString()+','+xy[1].toString()+' roi '+view_roi[0][0].toString()+','+view_roi[0][1].toString()+' - '+view_roi[1][0].toString()+','+view_roi[1][1].toString());
    }
    return visible;
}

/** @param {Array.<number>} xy
    @param {Array.<number>} indicator_xy
    @param {!Aura} aura */
function draw_aura(xy, indicator_xy, aura) {
    if(aura.spec['code'] === 'weak_zombie') {
        // handled separately for UI consistency when debuff is not actually applied
        return;
    }

    var color;
    if('color' in aura.spec) {
        var c = SPUI.make_colorv(aura.spec['color']);
        color = c.str().split(',').slice(0,3).join(',')+',';
    } else if('help' in aura.spec) {
        color = 'rgba(0,50,255,';
    } else if('harm' in aura.spec) {
        color = 'rgba(255,50,0,';
    } else {
        color = 'rgba(200,200,200,'
    }

    if(aura.range > 0) {
        ctx.save();
        ctx.fillStyle = color+'0.125)';
        ctx.strokeStyle = color+'0.25)';
        ctx.transform(1, 0, 0, 0.5, xy[0], xy[1]);
        ctx.beginPath();
        ctx.arc(0, 0, 10*gamedata['map']['range_conversion'] * aura.range, 0, 2*Math.PI, false);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }

    draw_clock(indicator_xy, color+'1.0)', aura.start_tick, aura.expire_tick);
}

/** @param {Array.<number>} xy
    @param {string} color
    @param {!CombatEngine.TickCount} start_tick
    @param {!CombatEngine.TickCount} end_tick */
function draw_clock(xy, color, start_tick, end_tick) {
    if(CombatEngine.TickCount.lt(session.combat_engine.cur_tick, start_tick) ||
       CombatEngine.TickCount.gt(session.combat_engine.cur_tick, end_tick)) { return; }
    var client_tick_smooth = session.combat_engine.cur_tick.get() + (client_time - last_tick_time)/(TICK_INTERVAL/combat_time_scale());
    var progress;
    if(end_tick.get() - start_tick.get() > 1.5/TICK_INTERVAL) {
        progress = (client_tick_smooth - start_tick.get()) / (end_tick.get() - start_tick.get());
    } else {
        progress = 1;
    }
    progress = Math.min(Math.max(progress,0.001),0.999);
    var radius = 10;
    ctx.save();
    ctx.globalAlpha = 0.5;

    // circular background
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(xy[0]+radius,xy[1]+radius,radius, 0,2*Math.PI,false);
    ctx.fill();

    // sweeping "clock timer"
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath();
    ctx.moveTo(xy[0]+radius,xy[1]+radius);
    ctx.lineTo(xy[0]+radius,xy[1]);
    ctx.arc(xy[0]+radius, xy[1]+radius, radius, 0-Math.PI/2, 2*Math.PI*(progress)-Math.PI/2, true);
    ctx.lineTo(xy[0]+radius,xy[1]+radius);
    ctx.fill();

    ctx.restore();
}

function draw_unit_control_order_segment(xy, state, d) {
    ctx.beginPath();
    ctx.strokeStyle = gamedata['client']['unit_control_colors'][(state == ai_states.AI_ATTACK_MOVE || state == ai_states.AI_ATTACK_MOVE_AGGRO || state == ai_states.AI_ATTACK_SPECIFIC) ? 'amove_later' : 'move_later'];
    ctx.moveTo(Math.floor(xy[0]), Math.floor(xy[1]));

    xy = ortho_to_draw(d);
    ctx.lineTo(Math.floor(xy[0]), Math.floor(xy[1]));

    if(gamedata['client']['unit_control_detail'] >= 2) { // arc drawing is slow
        ctx.save();
        ctx.transform(1, 0, 0, 0.5, Math.floor(xy[0]), Math.floor(xy[1]));
        ctx.arc(0, 0, 6, 0, 2*Math.PI, false);
        ctx.stroke();
        ctx.restore();
    } else {
        ctx.stroke();
    }

    return xy;
}

// draw one step in the order queue
// NOTE: xy will be updated to point to the "endpoint" of this order
function draw_unit_control_order(xy, ord) {
    var d;
    if(ord['target'] && ord['target'] in session.cur_objects.objects) {
        d = session.cur_objects.objects[ord['target']].interpolate_pos();
    } else if(ord['dest']) {
        d = vec_add(ord['dest'], [0.5,0.5]);
    } else {
        return xy;
    }

    return draw_unit_control_order_segment(xy, ord['state'], d);
}

function draw_unit_control(unit, curpos) {
    //ctx.save();
    var xy = ortho_to_draw(curpos);

    // draw line to target
    var target_line_drawn = false;

    if(unit.control_target /*&& !unit.control_target.is_destroyed()*/ && (unit.control_state != control_states.CONTROL_STOP)) {
        ctx.strokeStyle = gamedata['client']['unit_control_colors']['target'];
        ctx.beginPath();
        ctx.moveTo(Math.floor(xy[0]), Math.floor(xy[1]));
        var target_pos = unit.control_target.interpolate_pos();
        var target_xy = ortho_to_draw(target_pos);
        ctx.lineTo(Math.floor(target_xy[0]), Math.floor(target_xy[1]));
        ctx.stroke();
        target_line_drawn = true;
    }

    if(unit.path_valid && unit.path.length >= 1 &&
       unit.ai_state !== ai_states.AI_ATTACK_SPECIFIC &&
        unit.ai_state !== ai_states.AI_ATTACK_STATIONARY &&
       (unit.ai_state !== ai_states.AI_ATTACK_ANY || unit.control_state === control_states.CONTROL_MOVING)) {
        //if(unit.path.length < 1) { return; }
        if(unit.ai_state === ai_states.AI_ATTACK_MOVE || unit.ai_state === ai_states.AI_ATTACK_MOVE_AGGRO) {
            ctx.strokeStyle = gamedata['client']['unit_control_colors']['amove_now'];
        } else {
            ctx.strokeStyle = gamedata['client']['unit_control_colors']['move_now'];
        }
        //ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(Math.floor(xy[0]), Math.floor(xy[1]));
        for(var i = 0; i < unit.path.length; i++) {
            xy = ortho_to_draw(vec_add(unit.path[i],[0.5,0.5]));
            ctx.lineTo(Math.floor(xy[0]), Math.floor(xy[1]));
        }

        if(gamedata['client']['unit_control_detail'] >= 2) { // arc drawing is slow
            ctx.save();
            ctx.transform(1, 0, 0, 0.5, Math.floor(xy[0]), Math.floor(xy[1]));
            ctx.arc(0, 0, 6, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.restore();
        } else {
            ctx.stroke();
        }
    }

    if(!unit.is_mobile()) { return; }

    if(typeof unit.orders == 'undefined') {
        console.log('unit.orders undefined!');
        console.log(unit);
        return;
    }

    if(unit.is_mobile() && unit.orders.length > 0 &&
       (unit.orders.length > 1 || !target_line_drawn)) {

        for(var i = 0; i < unit.orders.length; i++) {
            var ord = unit.orders[i];
            xy = draw_unit_control_order(xy, ord);
        }

        if(unit.patrol) {
            xy = draw_unit_control_order_segment(xy, unit.orders[unit.orders.length-1]['state'], curpos);
        }
    }
    //ctx.restore();
};

function draw_drag_selection() {
    if(!mouse_state.has_dragged) { return; }

    var xmin = Math.min(mouse_state.drag_start_x, mouse_state.last_x);
    var xmax = Math.max(mouse_state.drag_start_x, mouse_state.last_x);
    var ymin = Math.min(mouse_state.drag_start_y, mouse_state.last_y);
    var ymax = Math.max(mouse_state.drag_start_y, mouse_state.last_y);

    ctx.save();
    ctx.strokeStyle = 'rgba(0,255,0,0.8)';
    ctx.fillStyle = 'rgba(0,255,0,0.18)';
    ctx.beginPath();
    ctx.moveTo(xmin, ymin);
    ctx.lineTo(xmax, ymin);
    ctx.lineTo(xmax, ymax);
    ctx.lineTo(xmin, ymax);
    ctx.lineTo(xmin, ymin);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
};

/** @param {GameObject} unit
    @param {string=} config_override */
function draw_selection_highlight(unit, config_override) {
    var curpos = unit.interpolate_pos();
    ctx.save();

    var config_name;
    if(config_override) {
        config_name = config_override;
    } else if(unit.team !== 'player') {
        config_name = 'enemy';
    } else if(unit.ai_state === ai_states.AI_ATTACK_STATIONARY) {
        config_name = 'hold_position';
    } else if(unit.ai_aggressive) {
        config_name = 'aggressive';
    } else {
        config_name = 'normal';
    }
    var config = gamedata['client']['unit_highlights'][config_name];
    var stroke_alpha = config['stroke_alpha'];

    ctx.strokeStyle = config['basecol']+stroke_alpha.toString()+')';
    ctx.fillStyle = config['basecol']+config['fill_alpha'].toString()+')';

    if(unit.is_mobile()) {
        // draw ellipse underneath the object
        var xy = ortho_to_draw(curpos);
        xy[0] = Math.floor(xy[0]); xy[1] = Math.floor(xy[1]);

        if(gamedata['client']['unit_selection_shape'] == 'arc') { // arc drawing is slow
            ctx.save();
            ctx.beginPath();
            ctx.transform(1, 0, 0, 0.5, xy[0], xy[1]);
            ctx.arc(0, 0, Math.floor(10*config['ring_size']*unit.spec['gridsize'][0]), 0, 2*Math.PI, false);
            ctx.fill();
            if(stroke_alpha > 0) { ctx.stroke(); }
            ctx.restore();
        } else if(gamedata['client']['unit_selection_shape'] == 'rectangle') {
            var r = Math.floor(8*config['ring_size']*unit.spec['gridsize'][0]);
            ctx.fillRect(xy[0]-r, xy[1]-r/2, 2*r, r);
            if(stroke_alpha > 0) {
                ctx.strokeRect(xy[0]-r, xy[1]-r/2, 2*r, r);
            }
        } else if(gamedata['client']['unit_selection_shape'] == 'diamond') {
            var r = Math.floor(10*config['ring_size']*unit.spec['gridsize'][0]);
            ctx.beginPath();
            ctx.moveTo(xy[0]-r, xy[1]);
            ctx.lineTo(xy[0], xy[1]-r/2);
            ctx.lineTo(xy[0]+r, xy[1]);
            ctx.lineTo(xy[0], xy[1]+r/2);
            ctx.lineTo(xy[0]-r, xy[1]);
            ctx.fill();
            if(stroke_alpha > 0) { ctx.stroke(); }
        }

        // draw weapon range
        if(unit.team === 'player' &&
           (gamedata['client']['always_draw_mobile_weapon_range'] || unit.is_invisible())) {
            var ran = unit.weapon_range();
            var range = ran[1], aoe = ran[2], min_range = ran[4];
            if(range > 0) {
                draw_weapon_range(xy, range, true, false, min_range);
            }
        }

        if(unit.altitude > 0 && gamedata['client']['unit_control_detail'] >= 2) {
            // draw height line for flying units
            var xya = ortho_to_draw_3d([curpos[0], unit.altitude, curpos[1]]);
            ctx.strokeStyle = config['basecol']+config['altitude_alpha'].toString()+')';
            ctx.beginPath();
            ctx.moveTo(xy[0], xy[1]);
            ctx.lineTo(Math.floor(xya[0]), Math.floor(xya[1]));
            if(stroke_alpha > 0) { ctx.stroke(); }
        }
    } else {
        // draw rectangular outline for buildings
        var bound = get_grid_bounds(curpos, unit.spec['gridsize']);
        ctx.beginPath();
        SPUI.add_quad_to_path([ortho_to_draw([bound[0][0], bound[1][0]]),
                               ortho_to_draw([bound[0][1], bound[1][0]]),
                               ortho_to_draw([bound[0][1], bound[1][1]]),
                               ortho_to_draw([bound[0][0], bound[1][1]])]);
        ctx.fill();
        if(stroke_alpha > 0) { ctx.stroke(); }
    }
    if(unit.team === 'player') {
        draw_unit_control(unit, curpos);
    }
    ctx.restore();
}

function draw_centered_text_with_shadow(ctx, str, xy) {
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,1)';
    draw_centered_text(ctx, str, vec_add(xy, [1,1]));
    ctx.restore();
    return draw_centered_text(ctx, str, xy);
}

function draw_centered_text(ctx, str, xy) {
    var ret = vec_copy(xy);
    var lines = str.split('\n');
    for(var i = 0; i < lines.length; i++) {
        if(lines[i].length > 0) {
            var dims = ctx.measureText(lines[i]);
            var text_xy = vec_add(xy, [-Math.floor(dims.width/2), i*SPUI.desktop_font.leading]);
            ret[0] = Math.min(ret[0], text_xy[0]);
            ctx.fillText(lines[i], text_xy[0], text_xy[1]);
        }
    }
    return ret;
}

// return [width, height, yoffset] of unit health bar
GameObject.prototype.get_health_bar_dims = function() {
    return [50, 5, 40];
};
Mobile.prototype.get_health_bar_dims = function() {
    if('health_bar_dims' in this.spec) {
        return this.spec['health_bar_dims'];
    }
    return goog.base(this, 'get_health_bar_dims');
};
Building.prototype.get_health_bar_dims = function() {
    if('health_bar_dims' in this.spec) {
        return this.spec['health_bar_dims'];
    }
    return [Math.floor(120*this.spec['gridsize'][0]/12), 8, Math.floor(70 + 10*(this.spec['gridsize'][1]/12))];
};

function draw_health_bar(xy, obj) {
    var hp = obj.hp;
    var max_hp = obj.max_hp;

    if(obj.last_ui_hp_time == -1) { // init state for smooth transitions
        obj.last_ui_hp_stable = hp;
        obj.last_ui_hp = hp;
    }

    var show_at_full_health = (obj.is_mobile() &&
                               !obj.spec['never_show_full_health_bar'] &&
                               get_preference_setting(player.preferences, 'always_show_unit_health'));

    if(!show_at_full_health && obj.is_mobile()) {
        // shortcut
        if(hp === 0 || hp === max_hp) {
            obj.last_ui_hp_time = client_time;
            return;
        }
    }

    var dims = obj.get_health_bar_dims();
    var w = dims[0], h = dims[1], yoff = dims[2];

    if(obj.is_building() && obj.is_repairing()) {
        // estimate HP level
        var rep = 1 + (server_time - obj.repair_finish_time)/obj.get_leveled_quantity(obj.spec['repair_time']);
        hp = Math.floor(/*(1-rep)*obj.hp + */ rep*max_hp);
    }

    var displayed_hp;
    var trans_time = gamedata['client']['health_bar_transition_time'] || 0;
    if(trans_time > 0 && hp != obj.last_ui_hp_stable) { // perform smooth transition
        var rate = max_hp / trans_time; // "seconds per HP bar"
        // make rate faster for smaller health bars and slower for larger health bars, so it's basically constant in screen space
        rate *= 50/dims[0];
        var delta_t = (client_time - obj.last_ui_hp_time);
        var sign = (hp < obj.last_ui_hp ? -1 : 1);
        var delta_hp = sign * rate * delta_t;
        if(Math.abs(delta_hp) >= Math.abs(hp - obj.last_ui_hp)) {
            // transition done, reset the stable level
            displayed_hp = hp;
            obj.last_ui_hp_stable = hp;
        } else {
            displayed_hp = obj.last_ui_hp + delta_hp;
        }
    } else {
        displayed_hp = hp;
    }
    obj.last_ui_hp = displayed_hp;
    obj.last_ui_hp_time = client_time;


    ctx.save();

    if((displayed_hp!=0) &&
       (show_at_full_health || (displayed_hp < max_hp))) {

        var throb_speed = -1;
        if(obj.is_building() && obj.is_repairing()) {
            //if((obj.repair_finish_time - server_time) >= Store.get_free_speedup_time(player)) {
            if(player.tutorial_state === "COMPLETE") {
                throb_speed = 12;
            } else {
                throb_speed = 90;
            }
        }
        draw_bar([xy[0]-Math.floor(w/2), xy[1]-yoff], w, h,
                 Math.floor(w*(clamp(hp/max_hp,0,1))),
                 Math.floor(w*(clamp(displayed_hp/max_hp,0,1))),
                 gamedata['client'][(obj.team === 'enemy' ? 'health_bar_colors_enemy' : 'health_bar_colors_friendly')], throb_speed);
    }

    // also draw progress bar for building actions
    if(obj.is_building()) {
        var progress = -1;
        if(obj.is_under_construction()) {
            progress = obj.build_progress();
        } else if(obj.is_upgrading()) {
            progress = obj.upgrade_progress();
        } else if(obj.is_researching()) {
            progress = obj.research_progress();
        } else if(obj.is_crafting()) {
            progress = obj.crafting_progress_one();
        } else if(obj.is_manufacturing()) {
            progress = obj.manuf_progress_one();
        }

        if(progress > -1 && (progress < 1 || obj.team == 'player')) {
            progress = clamp(progress, 0, 1);
            var pw = w, ph = 6, pyoff = yoff - 12;
            var prog = Math.floor(pw*progress);
            draw_bar([xy[0]-Math.floor(pw/2), xy[1]-pyoff],
                     pw,
                     ph, prog, prog,
                     gamedata['client']['progress_bar_colors'], 10);
        }
    }

    ctx.restore();
}

/**
 * Test params
 * @param {number} w
 * @param {number} h
 * @param {number} prog - instantaneous progress, pixels
 * @param {number} prog2 - transitioning progress, pixels
 */
function draw_bar(xy, w, h, prog, prog2, colors, throb_speed) {
    // fill center/background
    ctx.fillStyle = colors['bg'];
    ctx.fillRect(xy[0], xy[1], w, h);
    // fill "progress" area
    ctx.fillStyle = colors['fg'];
    ctx.fillRect(xy[0], xy[1], prog, h);
    ctx.lineWidth = (h >= 6 ? 2 : 1);
    ctx.strokeStyle = colors['highlight'];
    ctx.beginPath();
    ctx.moveTo(xy[0], xy[1]+2);
    ctx.lineTo(xy[0]+prog, xy[1]+2);
    ctx.stroke();

    if(prog2 > prog) {
        ctx.fillStyle = colors['fg_transition'];
        ctx.fillRect(xy[0]+prog, xy[1], prog2 - prog, h);
    }

    // throbbing NOTE: disabled for now
    if(0 && throb_speed > 0) {
        ctx.strokeStyle = '#FFFFFF';
        ctx.globalAlpha = 0.4;
        ctx.lineWidth = 3;
        var NBARS = 5;
        ctx.beginPath();
        var margin = 2;
        var spacing = (w-2*margin) / NBARS;
        for(var i = 0; i < NBARS; i++) {
            var bar_x = Math.floor(i*spacing + client_time*throb_speed) % (w-2*margin);
            ctx.moveTo(xy[0]+bar_x+margin, xy[1]);
            ctx.lineTo(xy[0]+bar_x+margin, xy[1]+h);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
    }
    // stroke outline
    ctx.lineWidth = 1; // (h >= 6 ? 2 : 1);
    ctx.strokeStyle = colors['outline'];
    ctx.strokeRect(xy[0], xy[1], w, h);
};

function unit_path_feedback(unit) {
    if(!unit.is_mobile() || unit.path.length < 1) { return; }
    var waypoints = [];
    waypoints.push(unit.interpolate_pos());
    for(var i = 0; i < unit.path.length; i++) {
        var pos = unit.path[i];
        waypoints.push([pos[0]+0.5,pos[1]+0.5]);
    }
    var fx = new SPFX.UnitPath(waypoints, [0.15,1,0.15,0.8], client_time, client_time + 0.6);
    SPFX.add_under(fx);
};

function draw_debug_astar_paths() {
    ctx.save();

    for(var id in session.cur_objects.objects) {
        var unit = session.cur_objects.objects[id];

        if(!unit.is_mobile() ||
           unit.path.length < 1) {
            continue;
        }

        var path = unit.path;

        ctx.strokeStyle = (unit.path_new ? '#ffffff' : (unit.path_valid ? '#ffff00' : '#ff0000'));
        ctx.lineWidth = (unit.path_new ? 3 : 1);
        unit.path_new = false;
        ctx.beginPath();

        var pos = unit.interpolate_pos();
        var xy = ortho_to_draw(pos);
        ctx.moveTo(xy[0], xy[1]);
        for(var i = 0; i < path.length; i++) {
            xy = ortho_to_draw(vec_add(path[i], [0.5,0.5]));
            ctx.lineTo(xy[0], xy[1]);
        }
        ctx.stroke();

        if(0) {
            ctx.strokeStyle = '#00ff00';
            ctx.beginPath();
            xy = ortho_to_draw(pos);
            ctx.moveTo(xy[0], xy[1]);
            xy = ortho_to_draw(unit.dest);
            ctx.lineTo(xy[0], xy[1]);
            ctx.stroke();
        }
    }
    ctx.restore();
};

function draw_debug_map() {
    ctx.save();
    var ncells = session.viewing_base.ncells();

    for(var i = 0; i < ncells[1]; i++) {
        for(var j = 0; j < ncells[0]; j++) {
            var xy = ortho_to_draw([j,i]);
            var sprite;
            if(!astar_map.is_blocked([j,i])) {
                continue; // skip clear cells
                //ctx.strokeStyle = "green";
                //sprite = GameArt.assets['TEMP_mapcell'].states['open'].images[0];
            } else {
                ctx.strokeStyle = "red";
                sprite = GameArt.assets['TEMP_mapcell'].states['blocked'].images[0];
            }

            // translate to upper-left corner of cell sprite (left of the diamond tip)
            xy = [xy[0]-cellsize[0]/2,xy[1]];

            // cull against view bounds
            if((xy[0]+cellsize[0] < view_roi[0][0]) ||
               (xy[0] > view_roi[1][0]) ||
               (xy[1]+cellsize[1] < view_roi[0][1]) ||
               (xy[1] > view_roi[1][1])) {
                // cull
                continue;
            }

            if(1) {
                // draw grid cell as sprite
                sprite.drawSubImage([0,0], sprite.wh, xy, sprite.wh);
            } else {
                // draw grid cell as diamond outline
                var inset = 1;
                ctx.beginPath();
                ctx.moveTo(xy[0]+inset,xy[1]+cellsize[1]/2);
                ctx.lineTo(xy[0]+cellsize[0]/2,xy[1]+inset);
                ctx.lineTo(xy[0]+cellsize[0]-inset,xy[1]+cellsize[1]/2);
                ctx.lineTo(xy[0]+cellsize[0]/2,xy[1]+cellsize[1]-inset);
                ctx.lineTo(xy[0]+inset,xy[1]+cellsize[1]/2);
                ctx.stroke();
            }
        }
    }
    ctx.restore();
}

function test_consequent(cons) {
    read_consequent(cons).execute();
};

goog.exportSymbol('SPINPUNCHGAME_EXPORT.init', SPINPUNCHGAME.init);
goog.exportSymbol('SPINPUNCHGAME_EXPORT.shutdown', SPINPUNCHGAME.shutdown);
goog.exportSymbol('start_ai_attack', start_ai_attack);
goog.exportSymbol('visit_base', visit_base);
goog.exportSymbol('change_region', change_region);
goog.exportSymbol('test_fancy_victory_dialog', test_fancy_victory_dialog);
goog.exportSymbol('test_you_were_attacked_dialog', test_you_were_attacked_dialog);
goog.exportSymbol('test_notify_achievements', test_notify_achievements);
goog.exportSymbol('test_flash_offer', test_flash_offer);
goog.exportSymbol('test_consequent', test_consequent);
goog.exportSymbol('sprobe_run', sprobe_run);
goog.exportSymbol('invoke_daily_tip', invoke_daily_tip);
goog.exportSymbol('invoke_splash_message', invoke_splash_message);
goog.exportSymbol('invoke_ingame_tip_force', invoke_ingame_tip_force);
goog.exportSymbol('give_me_item', give_me_item);
goog.exportSymbol('load_ai_base', load_ai_base);
goog.exportSymbol('save_ai_base', save_ai_base);
goog.exportSymbol('publish_ai_base', publish_ai_base);
goog.exportSymbol('do_visit_base', do_visit_base);
goog.exportSymbol('enable_muffins', enable_muffins);
goog.exportSymbol('anon_mode', anon_mode);
goog.exportSymbol('MAP_DEBUG', MAP_DEBUG);
goog.exportSymbol('FORCE_BASE_DAMAGE_PING', FORCE_BASE_DAMAGE_PING);
goog.exportSymbol('metric_event', metric_event); // for calling by spin_header_content/spin_footer_content

// this global name conflicts with one of Facebook or our advertising systems' JavaScript
var js = null;
goog.exportSymbol('js', js);
