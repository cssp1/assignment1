#!/usr/bin/env python

# Copyright (c) 2015 Battlehouse Inc. All rights reserved.
# Use of this source code is governed by an MIT-style license that can be
# found in the LICENSE file.

# main game server

import sys, os, time, base64, hmac, hashlib, urllib, urlparse, random, string, glob, traceback, signal, re
import inspect
import socket
import functools
import math
import gzip # XXX replace with faster version?
import cStringIO
import copy
import getopt
import KISSmetrics
import xml.dom.minidom
from cgi import escape as cgi_escape

# on Linux, try to use Twisted's high-performance epoll reactor
if sys.platform == 'linux2':
    from twisted.internet import epollreactor
    epollreactor.install()

from twisted.python import log, failure
from twisted.internet import reactor, task, defer, protocol
from twisted.internet.defer import inlineCallbacks, returnValue
from twisted.protocols.policies import ProtocolWrapper
import twisted.internet.utils
from twisted.web import server, resource, http
import twisted.web.error

# handle different Twisted versions that moved NoResource around
if hasattr(twisted.web.resource, 'NoResource'):
    TwistedNoResource = twisted.web.resource.NoResource
else:
    TwistedNoResource = twisted.web.error.NoResource

from multiprocessing import cpu_count
import websockets
import TwistedLatency
from spinlibs import AsyncHTTP
import Predicates
import Consequents
import Business
import UpgradeHelp
import ModChain
from Equipment import Equipment
import LootTable
import MachineStats
import SpinLog
import Daemonize
import AtomicFileWrite
import SpinDB
import SocialIDCache
import SpinChatProtocol
import SpinChatClient
import SpinSSL
import SpinFacebook
import SpinKongregate
import SpinXsolla
import SpinMSReceiptParser
import SpinAtomFeed
import SpinGoogleAuth
from spinlibs import SpinHTTP
import SpinConfig
import SpinUserDB
import SpinJSON
import SpinLZJB
import SpinSignature
import SpinNoSQLId
import SpinNoSQL
import SpinNoSQLLog
import SpinNoSQLLockManager
import SpinSQLBattles
import SpinSQLAllianceEvents
import SpinIPReputation
import MalformedJSON
import PlayerPortraits
import Raid
import Scores2
import Notification2
import CustomerSupport
import ActivityClassifier
import IdleCheck
import ChatChannels
import ChatFilter
import ResLoot
import ResPrice
import AutoResolve
from Region import Region
import ioslave
import collections
import bisect
import subprocess
import itertools

# SP3RDPARTY : lz4 Python library (modified) : BSD License
try:
    import lz4
    has_lz4 = True
    try:
        import lz4.block # newer lz4 API
    except:
        pass
except:
    has_lz4 = False

# apply compression and JSON-safe wrapping to a text string for transmission to the client
def compress_and_wrap_string(s):
    if has_lz4:
        codec = 'lz4'
        if hasattr(lz4, 'block'): # newer lz4 API
            c = lz4.block.compress(s)
        else: # old lz4 API
            c = lz4.compress(s)
        z_result = base64.b64encode(bytes(c))
    else:
        codec = 'lzjb'
        z_result = base64.b64encode(bytes(SpinLZJB.compress(SpinLZJB.string_to_bytes(s))))

    return codec, z_result

#
# UTILITIES
#

def soft_assert(x):
    if not x:
        gamesite.exception_log.event(server_time, 'soft assert fail: '+string.join(traceback.format_stack(), ''))

def make_deferred(latency_tag): return TwistedLatency.InstrumentedDeferred(latency_tag)
def deferred_is_finished(d):
    return d.called and hasattr(d, 'result') and not isinstance(d.result, defer.Deferred)

# increment value of d[key], assuming that the current amount is zero
# if d[key] doesn't exist
def dict_increment(d, key, amount):
    if amount == 0: return False
    d[key] = d.setdefault(key, 0) + amount
    return True

def dict_setmax(d, key, amount):
    old = d.get(key, 0)
    if amount <= old:
        return False
    d[key] = amount
    return True

def dict_setvalue(d, key, amount):
    old = d.get(key, 0)
    if amount == old:
        return False
    d[key] = amount
    return True

def vec_add(a, b): return [a[0]+b[0], a[1]+b[1]]
def vec_sub(a, b): return [a[0]-b[0], a[1]-b[1]]
def vec_scale(factor, a): return [factor*a[0], factor*a[1]]

# see http://3dmdesign.com/development/hexmap-coordinates-the-easy-way
# but note, the distance code there doesn't work for our coordinates

def hex_slanted(a):
    # transform to "slanted" coordinate system for easier distance computation
    new_x = a[0] - int(a[1]/2)
    return (new_x, a[1])

def hex_distance(a, b):
    a2 = hex_slanted(a)
    b2 = hex_slanted(b)
    dx = b2[0]-a2[0]
    dy = b2[1]-a2[1]
    dd = dx+dy
    return max(abs(dx), abs(dy), abs(dd))

# Get the map cells occupied by a building or inert at position "xy" with size "gridsize"
# returns [[x_lo,x_hi], [y_lo,y_hi]]  (where lo to hi-1 are blocked, hi itself is not blocked)
# Must match get_grid_bounds() in client JavaScript!
def get_grid_bounds(xy, gridsize):
    # by convention, xy is at the "center" of the object
    # for objects with odd gridsizes, the bound is extended one unit east/south
    half = [gridsize[0]//2, gridsize[1]//2]
    extra = [1 if (gridsize[0]&1) else 0,
             1 if (gridsize[1]&1) else 0]
    return [[xy[0]-half[0], xy[0]+half[0]+extra[0]],
            [xy[1]-half[1], xy[1]+half[1]+extra[1]]]

def weighted_random_choice(groups, weights, r):
    """Given parallel arrays of groups and relative weights, and 0 <= r < 1, return a random
    element of groups chosen according to the weights."""
    breakpoints = []
    bp = 0.0
    for w in weights:
        bp += w
        breakpoints.append(bp)

    r = r * breakpoints[-1]
    return groups[min(bisect.bisect(breakpoints, r), len(breakpoints)-1)]


# valid characters in alliance string fields
name_chars_simple = map(chr, xrange(ord('a'),ord('z')+1)) + \
                    map(chr, xrange(ord('A'),ord('Z')+1))
tag_chars_ext = name_chars_simple + \
                map(chr, xrange(ord('0'),ord('9')+1))
name_chars_ext = tag_chars_ext + \
                 [' ', "'"]
descr_disallowed_chars = ['\n', '\t', '\r']

def is_valid_alliance_descr(name):
    if len(name) > 256: return False
    for c in name:
        if c in descr_disallowed_chars: return False
    if chat_filter.is_bad(name): return False
    if chat_filter.is_ugly(name): return False
    return True

def is_valid_alliance_name(name):
    if not is_valid_alliance_descr(name): return False
    if len(name) < 3 or len(name) > 24: return False
    for i in xrange(len(name)):
        if (i < 3) and (name[i] not in name_chars_simple): return False
        elif name[i] not in name_chars_ext: return False
    if chat_filter.is_bad(name): return False
    for word in name.split(' '):
        if word.lower() in gamedata['client']['chat_filter']['bad_words']: return False
    return True
def is_valid_alliance_tag(tag):
    if len(tag) not in (0, 3): return False
    if len(tag) > 0:
        for i in xrange(len(tag)):
            if tag[i] not in tag_chars_ext:
                return False
        if chat_filter.is_bad(tag): return False
        if tag.lower() in gamedata['client']['chat_filter']['bad_words']: return False
        if tag.lower() in gamedata['client']['chat_filter']['bad_tags']: return False
    return True

def is_valid_alias(name):
    assert type(name) is unicode # make sure we're given Unicode input
    if len(name) < 4 or len(name) > 15: return False
    if 'spinpunch' in name.lower(): return False
    if 'battlehouse' in name.lower(): return False
    if 'bh-' in name.lower(): return False
    if chat_filter.is_bad(name): return False
    if chat_filter.is_graphical(name): return False
    if chat_filter.switches_charsets_or_blacklisted_chars(name): return False
    if chat_filter.is_ugly(name): return False
    if chat_filter.has_repeating_characters(name): return False
    return True

# recognize obsolete time-series history fields for deletion
obsolete_time_series_re = re.compile('^unit:(.+):manufactured_at_time$|^(.+)_manufactured_at_time$|^(.+)recycled_at_time$|^(.+)_wk([0-9]+)_at_time$|^(.+)_s([0-9]+)_at_time$')

# recognize notification2 state counters for clearing
# note: do not clear :last_time, since that is required to avoid unnecessary repetition
# for now, I think it is OK to just clear "unacked" while keeping "sent"/"clicked"
notification2_state_re = re.compile('^notification2:.+:(unacked)$') # (sent|clicked|unacked)

SCORES2_MIGRATION_VERSION = 9

def conceal_protection_time(x):
    if gamedata['server']['conceal_protection_time']:
        if x > server_time:
            return 1
        else:
            return -1
    else:
        return x

last_mail_id = 0
def generate_mail_id():
    global last_mail_id
    last_mail_id += 1
    return '%d-%08x-%d' % (server_time, random.randint(0,0xffffffff), last_mail_id)

def inventory_item_equal(a, b):
    if a['spec'] != b['spec']: return False
    if a.get('stack',1) != b.get('stack',1): return False
    if a.get('expire_time',-1) != b.get('expire_time',-1): return False
    return True

def inventory_list_equal(a, b):
    if len(a) != len(b): return False
    for i in xrange(len(a)):
        if (not inventory_item_equal(a[i], b[i])):
            return False
    return True

# these functions work with the raw JSON structures stored in NoSQL for mobile objects
def army_unit_hp(obj):
    level = obj.get('level',1)
    spec = GameObjectSpec.lookup(obj['spec'])
    max_hp = obj['max_hp'] if 'max_hp' in obj else spec.get_leveled_quantity(spec.max_hp, level)
    if 'hp' in obj:
        cur_hp = obj['hp']
    elif 'hp_ratio' in obj:
        cur_hp = int(obj['hp_ratio'] * max_hp)
    else:
        cur_hp = max_hp
    return [cur_hp, max_hp]

def army_unit_is_dead(obj):
    return (obj.get('hp',1) <= 0 or obj.get('hp_ratio',1) <= 0)

# track values in player.history that accumulate over time
# keeps an atomic counter for the current accumulated total, plus an '_at_time' dictionary for totals by account age
# (relative to user.account_creation_time!)
# 'mutate' should be either dict_increment (for values that build up, like spending)
# dict_setmax (for values where we care about the max, like friends_in_game), or dict_setvalue (for "charted" values like resources currently in storage)
# 'bucket' to quantize samples to increments of 'bucket_size' seconds, to avoid bloating with fine time samples
# returns True only if a mutation was made
def record_player_metric(player, mutate, counter, amount, time_series = True, bucket = False, bucket_size = None):
    if player.is_ai(): return False

    # mutate the current counter
    if not mutate(player.history, counter, amount): return False

    if not time_series:
        return True

    # update corresponding time series
    if player.creation_time <= 0:
        # can't do this on old accounts that have no creation time
        return True
    time_series = counter + '_at_time'
    if time_series not in player.history:
        player.history[time_series] = {}

    age = int(server_time - player.creation_time)
    if bucket:
        # quantize age to nearest bucket_size increment
        if bucket_size is None: bucket_size = 5*60
        age = (age/bucket_size)*bucket_size
    mutate(player.history[time_series], str(age), amount)
    return True

# return abbreviated string representing a session ID, for logging purposes
def pretty_print_session(id):
    return id[0:4]+'...'+id[-4:]

#
# SERVER CODE BEGINS HERE
#

# GLOBALS

gamesite = None
spin_server_name = None

# decorator to trap all exceptions underneath a main entry point
def catch_all(name):
    def _apply_catch_decorator(func):
        def _catch_decorator(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except:
                gamesite.exception_log.event(server_time, '%s Exception: %s' % (name, traceback.format_exc().strip())) # OK
        return functools.wraps(func)(_catch_decorator)
    return _apply_catch_decorator

# table mapping sessions (big strings) to live Player objects
session_table = {}

def get_session_by_session_id(session_id, include_logout_in_progress = False):
    s = session_table.get(session_id, None)
    if s and s.logout_in_progress and not include_logout_in_progress: s = None
    return s
def get_session_by_user_id(user_id, include_logout_in_progress = False):
    for s in session_table.itervalues():
        if s.user.user_id == user_id:
            if s.logout_in_progress and not include_logout_in_progress: return None
            return s
    return None
def get_session_by_facebook_id(facebook_id, include_logout_in_progress = False):
    for s in session_table.itervalues():
        if s.user.facebook_id == facebook_id:
            if s.logout_in_progress and not include_logout_in_progress: return None
            return s
    return None
def get_session_by_xsolla_id(xs_id, include_logout_in_progress = False):
    for s in session_table.itervalues():
        if s.user.get_xsolla_id() == xs_id:
            if s.logout_in_progress and not include_logout_in_progress: return None
            return s
    return None

def iter_sessions(include_logout_in_progress = False):
    for session in session_table.itervalues():
        if session.logout_in_progress: continue
        yield session

invalid_sessions = {} # set of session IDs invalidated via CONTROLAPI (sid->count)
invalid_sessions_by_time = collections.deque() # (time,sid) for session invalidations


# load server configuration file
game_id = SpinConfig.config['game_id']
spin_secure_mode = SpinConfig.config.get('secure_mode', 0)
spin_log_verbosity = SpinConfig.config.get('log_verbosity', 0)
spin_log_dir = SpinConfig.config.get('log_dir', 'logs')
machine_stats_filesystems = ['/',
                             os.path.abspath(spin_log_dir)+'/'] + \
                             [os.path.abspath(fs) for fs in SpinUserDB.driver.get_filesystems()]

NOSQL_GEN = 2

# disable logging of minor metrics that clutter up the metrics file and load the server
LOTS_OF_METRICS = False

# special case for AI fought during the rails tutorial
LION_STONE_ID = 1002

# user_id numbers lower than or equal to max_user_id are used for AIs
def is_ai_user_id_range(id):
    return id > 0 and id <= gamedata.get('max_ai_user_id', 1100)

class SQUAD_IDS(object):
    # None or 0 means "base defenders", -1 is "reserves", 1..N is real squads
    BASE_DEFENDERS = 0
    RESERVES = -1
    @classmethod
    def is_mobile_squad_id(cls, id): return id > 0

# master gamedata
gamedata = None
gameclient_build_date = None

# cache of subparts of gamedata that need to be localized
# {"units": {"en_US": ..., "ko_KR": ...}, "buildings": ... }
localized_gamedata_cache = {}

def get_localized_gamedata(path, locale):
    """
    Retrieve the localized version of a specific top-level child of gamedata.
    Example: get_localized_gamedata('fb_notifications', 'ko_KR')
             returns Korean version of gamedata['fb_notifications']
    (if no localization is found, returns the default English version)
    """
    global localized_gamedata_cache

    # allow caller to pass null/empty locale
    if not locale:
        locale = 'en_US'

    if path not in localized_gamedata_cache:
        localized_gamedata_cache[path] = {}

    for loc in SpinConfig.locales_to_try(locale):
        if loc not in localized_gamedata_cache[path]:
            if loc == 'en_US': # shortcut to save memory
                localized_gamedata_cache[path][loc] = gamedata[path]
            else:
                fname = SpinConfig.gamedata_component_filename('%s_compiled-%s.json' % (path, loc))
                if os.path.exists(fname):
                    localized_gamedata_cache[path][loc] = SpinJSON.load(open(fname))
                else:
                    localized_gamedata_cache[path][loc] = None

        if localized_gamedata_cache[path][loc]:
            return localized_gamedata_cache[path][loc]

    # fall back to language-neutral gamedata
    return gamedata[path]

# cached ChatFilter instance - note: used for alliance name checking, not actually applied to chat (that's client side)
chat_filter = None

# global SpinIPReputation instance
ip_rep_checker = None

def reload_gamedata():
    global gamedata, gameclient_build_date, localized_gamedata_cache, chat_filter
    try:
        newdata = SpinJSON.load(open(SpinConfig.gamedata_filename()))

        # load private pieces of gamedata that are not included in the main client download
        newdata['server'] = SpinConfig.load(SpinConfig.gamedata_component_filename("server_compiled.json"))
        newdata['ai_bases_server'] = SpinConfig.load(SpinConfig.gamedata_component_filename("ai_bases_server.json"))
        # XXX ugly hack - the file should be prepared separately for the client
        if 'ai_bases_client' in newdata: del newdata['ai_bases_client']
        newdata['ai_attacks'] = SpinConfig.load(SpinConfig.gamedata_component_filename("ai_attacks_compiled.json"))
        for KIND in ('hives','quarries','raids'): # hives_server quarries_server raids_server (for grepping)
            newdata[KIND+'_server'] = SpinConfig.load(SpinConfig.gamedata_component_filename(KIND+"_server.json"))
            if KIND+'_client' in newdata: del newdata[KIND+'_client']
        newdata['offers'] = SpinConfig.load(SpinConfig.gamedata_component_filename("offers.json"))
        newdata['loot_tables'] = SpinConfig.load(SpinConfig.gamedata_component_filename("loot_tables.json"))
        newdata['promo_codes'] = SpinConfig.load(SpinConfig.gamedata_component_filename("promo_codes_compiled.json"))

        gamedata = newdata
        gameclient_build_date = str(open("../gameclient/compiled-client.js.date").read().strip())
        localized_gamedata_cache = {}

        chat_filter = ChatFilter.ChatFilter(gamedata['client']['chat_filter'])
        # reinitialize the IP Reputation database
        global ip_rep_checker
        if SpinConfig.config.get('ip_reputation_database') and os.path.exists(SpinConfig.config['ip_reputation_database']):
            ip_rep_checker = SpinIPReputation.Checker(SpinConfig.config['ip_reputation_database'])
        elif gamesite:
            gamesite.exception_log.event(server_time, 'config.json "ip_reputation_database" file is missing, will skip IP reputation checks')
        else: # on initial load, gamesite won't be initialized yet
            sys.stderr.write('config.json "ip_reputation_database" file is missing, will skip IP reputation checks\n')

        # make sure config.json setting for min_user_id is correct
        if 'max_ai_user_id' in gamedata:
            if SpinConfig.config.get('min_user_id',-1) <= gamedata['max_ai_user_id']:
                raise Exception('config.json min_user_id setting must be > gamedata["max_ai_user_id"]')

    except:
        writefunc = (lambda x: gamesite.exception_log.event(server_time, x)) if gamesite else (lambda x: sys.stderr.write(x+'\n'))
        writefunc('error (re)loading gamedata: '+traceback.format_exc().strip()) # OK
        pass

reload_gamedata()

try:
    SERVER_VERSION = subprocess.Popen('../scmtool.sh version', shell=True, stdout=subprocess.PIPE).stdout.readlines()[0].strip()
    SERVER_BRANCH = subprocess.Popen('../scmtool.sh git-branch', shell=True, stdout=subprocess.PIPE).stdout.readlines()[0].strip()
except:
    SERVER_VERSION = SERVER_BRANCH = 'unknown'


# global time value (in integer seconds since UNIX epoch)
# updated each time the main event handler runs
server_time_high = time.time()
server_time = int(server_time_high)
spin_server_launch_time = server_time

# called from event handlers to propagate new time value
def update_server_time():
    global server_time_high, server_time
    server_time_high = time.time()
    server_time = int(server_time_high)
    gamesite.nosql_id_generator.set_time(server_time)
    if gamesite.nosql_client: gamesite.nosql_client.set_time(server_time)
    return server_time_high

# utilities for inserting into Deferred callback chains
def _report_deferred_failure(fail, session):
    gamesite.exception_log.event(server_time, 'async exception on player %d: %s\n%s' % \
                                 (session.user.user_id, fail.getTraceback().strip(), fail.getErrorMessage().strip()))
def report_and_reraise_deferred_failure(fail, session):
    _report_deferred_failure(fail, session)
    return fail
def report_and_absorb_deferred_failure(fail, session, retval = None):
    _report_deferred_failure(fail, session)
    return retval


# live server administration interface
class AdminStats:
    def __init__(self):
        self.reset()
    def reset(self):
        self.start_time = server_time
        self.developer_revenue = 0.0
        self.revenue = 0.0
        self.users_seen = set()
        self.paying_users_seen = set()
        self.new_users_logged_in = set()
        self.last_payments = collections.deque([], 10)
        self.last_gamebucks = collections.deque([], 10)
        self.campaigns = {}
        self.econ = {}
        self.latency = {}
        self.quarry_cache_misses = 0
        self.quarry_cache_hits = 0
        self.controlapi_calls_by_method = {}
        self.ogpapi_calls_by_type = {}

    # convenience method when you have a live player instance
    def econ_flow_player(self, player, *args, **kwargs):
        self.econ_flow(player.user_id, player.get_denormalized_summary_props('brief'), *args, **kwargs)

    def econ_flow(self, user_id, player_summary_props, category, reason, res, spec = None, level = None):
        # eventually need to separate third resource out
        total = sum(res.itervalues(),0)
        if total == 0: return # we assume that entries are either all positive or all negative
        if category not in self.econ:
            self.econ[category] = {}
        self.econ[category][reason] = self.econ[category].get(reason,0) + total

        if gamedata['server'].get('log_econ_res', False) and gamesite.nosql_client:
            props = {'user_id':user_id, 'res':res, 'cat':category, 'sub': reason}
            if spec is not None:
                props['spec'] = spec
            if level is not None:
                props['level'] = level
            props.update(player_summary_props)
            gamesite.nosql_client.log_record('econ_res', server_time, props, log_ident = False, reason = 'econ_flow')

    def record_latency(self, name, elapsed):
        if name not in self.latency:
            self.latency[name] = {'N':0.0, 'total':0.0, 'max': 0.0}
        self.latency[name]['N'] += 1
        self.latency[name]['total'] += elapsed
        self.latency[name]['max'] = max(self.latency[name]['max'], elapsed)

    # decorator for timing a function
    def measure_latency(self, name):
        def _apply_latency_decorator(func):
            def _latency_decorator(*args, **kwargs):
                start_time = time.time()
                ret = func(*args, **kwargs)
                end_time = time.time()
                self.record_latency(name, end_time - start_time)
                return ret
            return functools.wraps(func)(_latency_decorator)
        return _apply_latency_decorator

    # context object for timing a block
    class MeasureLatency(object):
        def __init__(self, parent, name):
            self.parent = parent
            self.name = name
        def __enter__(self):
            self.start_time = time.time()
        def __exit__(self, type, value, traceback):
            end_time = time.time()
            self.parent.record_latency(self.name, end_time - self.start_time)
    def latency_measurer(self, name): return self.MeasureLatency(self, name)

    def add_visit(self, user_id, is_new, is_paying):
        self.users_seen.add(user_id)
        if is_paying:
            self.paying_users_seen.add(user_id)
        if is_new:
            self.new_users_logged_in.add(user_id)

    def add_revenue(self, user_id, dollar_amount, descr):
        self.revenue += dollar_amount
        # add here in case this is the user's first payment
        self.paying_users_seen.add(user_id)
        self.last_payments.append({'user_id':user_id,
                                   'time':server_time,
                                   'dollar_amount':dollar_amount,
                                   'description':descr})

    def add_gamebucks_spend(self, user_id, bucks, descr):
        self.last_gamebucks.append({'user_id':user_id,
                                    'time':server_time,
                                    'gamebucks_amount':bucks,
                                    'description':descr})

    def add_logout(self, user_id, campaign, length):
        # only track FIRST visits
        if user_id not in self.new_users_logged_in:
            return

        self.new_users_logged_in.remove(user_id)

        if campaign not in self.campaigns:
            self.campaigns[campaign] = {'lengths': collections.deque([], 5), 'num': 0}
        self.campaigns[campaign]['lengths'].append(length)
        self.campaigns[campaign]['num'] += 1

    def get_active_sessions(self):
        # also count valid in-flight asynchronous logins here
        return len(session_table) + sum((1 for async in gamesite.gameapi.AsyncLogin.in_progress_by_user_id.itervalues() if (not async.cancel_reason)),0)

    def get_server_status_json(self):
        return {'server_time': server_time,
                'launch_time': spin_server_launch_time,
                'type': SpinConfig.game(),
                'state': gamesite.server_state,
                'hostname': gamesite.config.game_host,
                'pid': os.getpid(),
                'game_listen_host': gamesite.config.game_listen_host,
                'game_snam': gamesite.config.game_snam,
                'game_http_port': gamesite.config.game_http_port,
                'game_ssl_port': gamesite.config.game_ssl_port,
                'game_ws_port': gamesite.config.game_ws_port,
                'game_wss_port': gamesite.config.game_wss_port,
                'affinities': gamesite.config.affinities,
                'scm_version': SERVER_VERSION,
                'scm_branch': SERVER_BRANCH,
                'gamedata_build': gamedata['gamedata_build_info']['date'],
                'gameclient_build': gameclient_build_date,
                'uptime': server_time - self.start_time,
                'load_unhalted': self.get_load(),
                'machine_stats': MachineStats.get_stats(filesystems = machine_stats_filesystems),
                'active_sessions': self.get_active_sessions(),
                'paying_sessions': sum((1 for session in iter_sessions() if session.player.history.get('money_spent',0)>=10.0),0),
                'stuck_sessions': sum((1 for session in iter_sessions() if server_time - session.last_active_time >= 2*gamedata['server']['session_timeout']),0),
                'active_protocol_clients': len(gamesite.active_clients),
                'active_protocol_requests': len(gamesite.active_requests),
                }

    def get_stats(self):
        props = {}
        up_hours = float(server_time - self.start_time)/3600.0
        up_days = up_hours/24.0
        props['uptime hours'] = up_hours
        props['revenue'] = self.revenue
        props['unique users'] = len(self.users_seen)
        DAU = len(self.users_seen) / up_days
        props['DAU (projected)'] = DAU
        return props

    def get_campaigns(self):
        ret = ''
        ret += '<table border="1" cellspacing="1">'
        ret += '<tr><td>Name</td><td>Last Session Lengths (new users only)</td><td>Average</td><td># Acquisitions</td></tr>'
        for name in sorted(self.campaigns.iterkeys()):
            data = self.campaigns[name]
            lengths = data['lengths']
            num = data['num']
            if len(lengths) > 0:
                str_average = SpinConfig.pretty_print_time(sum(lengths)/len(lengths))
            else:
                str_average = '-'
            str_lengths = string.join(map(SpinConfig.pretty_print_time, lengths), ', ')
            ret += '<tr><td>%s</td><td>%s</td><td>%s</td><td>%d</td></tr>' % (name, str_lengths, str_average, num)
        ret += '</table>'
        return ret

    def get_payments(self):
        ret = '<table border="1" cellspacing="1">'
        ret += '<tr><td>Time ago</td><td>User ID</td><td>Amount</td><td>Description</td></tr>'
        for props in reversed(self.last_payments):
            elapsed = server_time - props['time']
            ret += '<tr><td>%s</td><td>%d</td><td>$%0.2f</td><td>%s</td></tr>' % (SpinConfig.pretty_print_time(elapsed),
                                                                       props['user_id'],
                                                                       props['dollar_amount'],
                                                                       props['description'])
        ret += '</table>'
        return ret

    def get_gamebucks(self):
        ret = '<table border="1" cellspacing="1">'
        ret += '<tr><td>Time ago</td><td>User ID</td><td>Amount</td><td>Description</td></tr>'
        for props in reversed(self.last_gamebucks):
            elapsed = server_time - props['time']
            ret += '<tr><td>%s</td><td>%d</td><td>%d</td><td>%s</td></tr>' % (SpinConfig.pretty_print_time(elapsed),
                                                                       props['user_id'],
                                                                       props['gamebucks_amount'],
                                                                       props['description'])
        ret += '</table>'
        return ret

    def get_controlapi_calls(self):
        ret = '<table border="1" cellspacing="1">'
        ret += '<tr><td>Method</td><td>N</td></tr>'
        for name, calls in sorted(self.controlapi_calls_by_method.items()):
            ret += '<tr><td>%s</td><td>%d</td></tr>' % (name, calls)
        ret += '</table>'
        return ret

    def get_ogpapi_calls(self):
        ret = '<table border="1" cellspacing="1">'
        ret += '<tr><td>Type</td><td>N</td></tr>'
        for name, calls in sorted(self.ogpapi_calls_by_type.items()):
            ret += '<tr><td>%s</td><td>%d</td></tr>' % (name, calls)
        ret += '</table>'
        return ret

    def get_load(self):
        if 'ALL' in self.latency:
            return self.latency['ALL']['total'] / max(1, float(server_time - self.start_time))
        else:
            return -1

    def get_latency(self):
        ret = ''

        if 'ALL' in self.latency:
            ret += 'Approximate unhalted load: <b>%.1f%%</b><br>' % (100.0*self.get_load())
            ret += 'Average request latency: <b>%.1f ms</b><p>' % ((1000.0*self.latency['ALL']['total'])/self.latency['ALL']['N'])

        def sort_by_max(kv): return -kv[1]['max']
        def sort_by_average(kv): return -kv[1]['total']/kv[1]['N']
        def sort_by_total(kv): return -kv[1]['total']

        grand_total = sum([data['total'] for name, data in self.latency.iteritems() if name != 'ALL'])

        for sort_name, sort_func in {'Max': sort_by_max, 'Avg': sort_by_average, 'Total': sort_by_total}.iteritems():
            ret += '<p>Sort by %s<br>' % sort_name
            ret += '<table border="1" cellspacing="1">'
            ret += '<tr><td>Request</td><td>Average</td><td>Max</td><td>Total</td><td>Total %</td><td>#Calls</td></tr>'
            ls = self.latency.items()
            ls.sort(key = sort_func)
            for name, data in ls[0:25]:
                ret += '<tr><td>%s</td><td>%.1f ms</td><td>%.1f ms</td><td>%.1f s</td><td>%.1f%%</td><td>%d</td></tr>' % \
                       (name, 1000.0*data['total']/data['N'],
                        1000.0*data['max'],
                        data['total'],
                        (100.0*data['total']/grand_total) if grand_total != 0 else 0,
                        int(data['N'])
                        )
            ret += '</table>'

        quarry_total = self.quarry_cache_misses + self.quarry_cache_hits
        if quarry_total > 0:
            ret += '<p>Quarry cache hit rate: <b>%.1f%%</b><br>' % (100*self.quarry_cache_hits/float(quarry_total))
        return ret

    def get_econ(self):
        ret = '<table border="1" cellspacing="1">'
        ret += '<tr><td>Category</td><td>Reason</td><td>Amount</td><td>%</td></tr>'
        cat_totals = {}
        cat_totals = dict([(category, sum(self.econ[category].itervalues())) for category in self.econ.iterkeys()])
        grand_total = sum(cat_totals.itervalues())
        abs_total = sum([abs(x) for x in cat_totals.itervalues()])

        def big_number(x):
            return '%.3fM' % (x/1000000.0)

        for cat, data in sorted(self.econ.items()):
            cat_ratio = cat_totals[cat]/float(abs_total) if (abs_total != 0) else 0
            ret += '<tr><td><b>%s</b></td><td>%s</td><td><b>%s</b></td><td><b>%.1f%%</b></td></tr>' % (cat, '', big_number(cat_totals[cat]), 100.0*cat_ratio)
            for reason, amount in sorted(data.items()):
                ratio = amount/float(cat_totals[cat]) if (cat_totals[cat] != 0) else 0
                ret += '<tr><td></td><td>%s</td><td>%s</td><td>%.1f%%</td></tr>' % (reason, big_number(amount), 100.0*ratio)

        ret += '<tr><td><b>TOTAL</b></td><td></td><td>%s</td><td>-</td></tr>' % big_number(grand_total)
        ret += '</table>'
        return ret

admin_stats = AdminStats()

# userdb/playerdb/aistate file I/O backend
class IOSystem (object):
    def __init__(self, config):
        self.slowtest = config.get('slowtest', -1)

        # track size of largest objects processed, for logging purposes
        self.warn_size = gamedata['server'].get('io_warn_size', 32*1024*1024) # warn at this many bytes, and every power of 2 thereafter

    def start(self): pass
    def overloaded(self): return False
    def get_post_write_delay(self): return 0
    def get_stats(self): return None

    # PUBLIC API
    def sync_download_user(self, id): return SpinUserDB.driver.sync_download_user(id)
    def sync_write_user(self, id, buf): SpinUserDB.driver.sync_write_user(id, buf)
    def sync_write_player(self, id, buf): SpinUserDB.driver.sync_write_player(id, buf)
    def sync_write_base(self, region, id, buf): SpinUserDB.driver.sync_write_base(region, id, buf)

    def async_write_user(self, id, buf, success_cb, fsync, reason = None):
        self.async_write(SpinUserDB.driver.get_user_path(id), buf, success_cb, fsync, procnum = SpinUserDB.driver.io_channel_for_user(id))
    def async_write_player(self, id, buf, success_cb, fsync, reason = None):
        self.async_write(SpinUserDB.driver.get_player_path(id), buf, success_cb, fsync, procnum = SpinUserDB.driver.io_channel_for_player(id))
    def async_write_base(self, region, id, buf, success_cb, fsync, reason = None):
        self.async_write(SpinUserDB.driver.get_base_path(region, id), buf, success_cb, fsync, procnum = SpinUserDB.driver.io_channel_for_base(id))
    def async_write_aistate(self, user_id, game_id, ai_id, buf, success_cb, fsync, reason = None):
        self.async_write(SpinUserDB.driver.get_aistate_path(user_id, game_id, ai_id), buf, success_cb, fsync, procnum = SpinUserDB.driver.io_channel_for_aistate())

    def async_read_user(self, id, success_cb, error_cb, reason = None):
        self.async_read(SpinUserDB.driver.get_user_path(id), success_cb, error_cb, procnum = SpinUserDB.driver.io_channel_for_user(id))
    def async_read_player(self, id, success_cb, error_cb, reason = None):
        self.async_read(SpinUserDB.driver.get_player_path(id), success_cb, error_cb, procnum = SpinUserDB.driver.io_channel_for_player(id))
    def async_read_base(self, region, id, success_cb, error_cb, reason = None):
        self.async_read(SpinUserDB.driver.get_base_path(region, id), success_cb, error_cb, procnum = SpinUserDB.driver.io_channel_for_base(id))
    def async_read_aistate(self, user_id, game_id, ai_id, success_cb, error_cb, reason = None):
        self.async_read(SpinUserDB.driver.get_aistate_path(user_id, game_id, ai_id), success_cb, error_cb, procnum = SpinUserDB.driver.io_channel_for_aistate())

    def async_delete_aistate(self, user_id, game_id, ai_id, cb):
        self.async_delete(SpinUserDB.driver.get_aistate_path(user_id, game_id, ai_id), cb, procnum = SpinUserDB.driver.io_channel_for_aistate())
    def async_delete_base(self, region_id, base_id, cb):
        self.async_delete(SpinUserDB.driver.get_base_path(region_id, base_id), cb, procnum = SpinUserDB.driver.io_channel_for_base(base_id))

    # PRIVATE IMPLEMENTATION
    def call_cb(self, method, filename, cb, reason, request_time, *args):

        if method == 'read':
            buf = args[0]
            if buf and (isinstance(buf, basestring) or isinstance(buf, bytes)):
                self.check_size(method, filename, len(buf))

        if self.slowtest > 0:
            reactor.callLater(self.slowtest, cb, *args)
            return

        if reason:
            start_time = time.time()
        ret = cb(*args)
        if reason:
            end_time = time.time()
            admin_stats.record_latency(reason, end_time-start_time)
        return ret
    def async_write(self, filename, buf, success_cb, fsync, reason = None, procnum = None):
        if procnum is None: procnum = 0
        request_time = 0 # time.time()
        self.check_size('write', filename, len(buf))
        self.do_async_write(filename, buf, functools.partial(self.call_cb, 'write', filename, success_cb, reason, request_time), fsync, procnum)
    def async_read(self, filename, success_cb, error_cb, reason = None, procnum = None):
        if procnum is None: procnum = 0
        request_time = 0 # time.time()
        # check_size() has to come after the read completes...
        self.do_async_read(filename, functools.partial(self.call_cb, 'read', filename, success_cb, reason, request_time), error_cb, procnum)
    def async_delete(self, filename, success_cb, procnum = None):
        if procnum is None: procnum = 0
        self.do_async_delete(filename, success_cb, procnum)
    def async_exists(self, filename, success_cb, error_cb, procnum = None):
        if procnum is None: procnum = 0
        self.do_async_exists(filename, success_cb, error_cb, procnum)

    # need a little adaptor function to throw away the unnecessary "response" from async write requests
    def async_write_helper(self, ignore_errors, cb, delay, response):
        if (not ignore_errors) and (response == 'NOTFOUND'):
            raise Exception('server returned 404!')
        if delay > 0:
            reactor.callLater(delay, cb)
        else:
            cb()

    def async_write_error(self, reason):
        gamesite.exception_log.event(server_time, 'async write error! this is really bad! reason: '+repr(reason))

    # helper to return an async read as a deferred
    def async_read_deferred(self, filename, reason = None, procnum = None):
        d = make_deferred('IOSystem.async_read')
        self.async_read(filename,
                        lambda buf, d=d: d.callback(buf),
                        lambda err_reason, d=d: d.errback(failure.Failure(Exception('async_read() error: %r' % err_reason))),
                        reason = reason, procnum = procnum)
        return d
    def async_exists_deferred(self, filename, reason = None, procnum = None):
        d = make_deferred('IOSystem.async_exists')
        self.async_exists(filename,
                          lambda buf, d=d: d.callback(buf),
                          lambda err_reason, d=d: d.errback(failure.Failure(Exception('async_exists() error: %r' % err_reason))),
                          procnum = procnum)
        return d

    def collect_aistate_garbage(self):
        # get rid of all files not modified for at least one
        # entire persistence time - this is conservative
        max_time = gamedata['ai_base_persistence_time'][1]
        SpinUserDB.driver.collect_aistate_garbage(server_time - max_time)

    def shutdown(self):
        # override if necessary
        return defer.succeed(True)

    def check_size(self, method, filename, size):
        # warn about abnormally large objects
        if size > self.warn_size:
            # for next time, increase warn_size to the next power of 2 above size
            self.warn_size = 1 << size.bit_length()
            gamesite.exception_log.event(server_time, 'IOSystem: large object during %s of %r: %d kB' % \
                                         (method, filename, size/1024.0))

class FileIOSystem (IOSystem):
    def __init__(self, config):
        IOSystem.__init__(self, config)
        assert isinstance(SpinUserDB.driver, SpinUserDB.FileDriver)
    def do_async_read(self, filename, success_cb, error_cb, procnum):
        try:
            buf = open(filename).read()
        except:
            buf = 'NOTFOUND'
        reactor.callLater(0, success_cb, buf)
    def do_async_write(self, filename, buf, success_cb, fsync, procnum):
        atom = AtomicFileWrite.AtomicFileWrite(filename, 'w')
        atom.fd.write(buf)
        atom.complete(fsync = fsync)
        reactor.callLater(0, success_cb)
    def do_async_delete(self, filename, success_cb, procnum):
        safe_unlink(filename)
        reactor.callLater(0, success_cb)
    def do_async_exists(self, filename, success_cb, error_cb, procnum):
        reactor.callLater(0, success_cb, os.path.exists(filename))

class IOSlaveIOSystem (IOSystem):
    def __init__(self, config):
        IOSystem.__init__(self, config)
        assert isinstance(SpinUserDB.driver, SpinUserDB.FileDriver)
        self.clients = []
        self.secret = config.get('secret', '9sdSDFz')
        self.port_range = config.get('ports','12321-12322')
        self.port_range = map(int, self.port_range.split('-'))
        num_slaves = self.port_range[1]-self.port_range[0]+1
        optimal_num = SpinUserDB.driver.optimal_io_channels()
        if num_slaves != optimal_num:
            raise Exception('number of ioslaves (%d) does not match optimum for SpinUserDB (%d)' % (num_slaves, optimal_num))
    def start(self):
        for port in xrange(self.port_range[0], self.port_range[1]+1):
            client = ioslave.IOClient(port, self.secret, log_exception_func = gamesite.log_exception_func)
            self.clients.append(client)
            gamesite.exception_log.event(server_time, repr(client) + ' started')
    def overloaded(self):
        limit = gamedata['server']['io_backends']['ioslave'].get('max_in_flight', 50)
        current = sum([client.num_in_flight() for client in self.clients])
        return (current >= limit)
    def get_stats(self):
        ret = AsyncHTTP.AsyncHTTPRequester.stats_to_html(
            AsyncHTTP.AsyncHTTPRequester.merge_stats([client.req.get_stats() for client in self.clients]),
            server_time)
        return ret
    def do_async_read(self, filename, success_cb, error_cb, procnum):
        self.clients[procnum].async_read(filename, server_time, success_cb, error_cb)
    def do_async_write(self, filename, buf, success_cb, fsync, procnum):
        # note: ALWAYS ask for fsync when using a true asynchronous I/O method
        self.clients[procnum].async_write(filename, buf, server_time, success_cb, self.async_write_error, fsync = True)
    def do_async_delete(self, filename, success_cb, procnum):
        self.clients[procnum].async_delete(filename, server_time, success_cb, self.async_write_error)
    def do_async_exists(self, filename, success_cb, error_cb, procnum):
        self.clients[procnum].async_exists(filename, server_time, success_cb, error_cb)
    def shutdown(self):
        return defer.DeferredList([client.defer_until_all_complete() for client in self.clients])

class S3IOSystem (IOSystem):
    def __init__(self, config):
        IOSystem.__init__(self, config)
        assert isinstance(SpinUserDB.driver, SpinUserDB.S3Driver)
        self.s3 = SpinUserDB.driver.s3con # SpinS3.S3(SpinUserDB.driver.key_file)

        config = gamedata['server'].get('AsyncHTTP_S3', {})
        request_timeout = config.get('request_timeout', 15)
        max_tries = config.get('max_tries', 3) # was: 20 (high is better against S3 errors but worse against server flood attacks)
        retry_delay = config.get('retry_delay', 3)

        # Wait this many seconds after the actual HTTP response before returning success from an async write.
        # This is necessary to deal with S3's "eventual consistency" model, so that player files don't get
        # over-written with old data when being attacked immediately after logging out
        # Need to keep it as low as possible, because it adds directly to post-attack latency.
        self.post_write_delay = config.get('post_write_delay', 2)

        # hard-code max request count to infinite, since we can't drop them (but can throttle logins instead)
        self.s3_req = AsyncHTTP.AsyncHTTPRequester(-1, -1, request_timeout, 0,
                                                   lambda x: gamesite.exception_log.event(server_time, x),
                                                   error_on_404 = False, max_tries = max_tries, retry_delay = retry_delay)
    def overloaded(self):
        limit = gamedata['server']['io_backends']['s3'].get('max_in_flight', 50)
        current = self.s3_req.num_on_wire()
        return (current >= limit)
    def get_post_write_delay(self): return self.post_write_delay
    def get_stats(self):
        return self.s3_req.get_stats_html(server_time)

    # "preflight" callbacks update the request URL/headers to bump timestamps in case of retry problems
    def preflight_get_request(self, bucket, objname, request):
        request.url, request.headers = self.s3.get_request(bucket, objname)
    def preflight_put_request(self, bucket, objname, length, request):
        request.url, request.headers = self.s3.put_request(bucket, objname, length)
    def preflight_delete_request(self, bucket, objname, request):
        request.url, request.headers = self.s3.delete_request(bucket, objname)
    def preflight_exists_request(self, bucket, objname, request):
        request.url, request.headers = self.s3.head_request(bucket, objname)

    def do_async_read(self, path, success_cb, error_cb, procnum):
        bucket, objname = path
        url, headers = self.s3.get_request(bucket, objname)
        self.s3_req.queue_request(server_time, url, success_cb,
                                  error_callback = error_cb,
                                  preflight_callback = functools.partial(self.preflight_get_request, bucket, objname),
                                  method = 'GET', headers = headers)
    def do_async_write(self, path, buf, success_cb, fsync, procnum):
        bucket, objname = path
        url, headers = self.s3.put_request(bucket, objname, len(buf))
        self.s3_req.queue_request(server_time, url, functools.partial(self.async_write_helper, 0, success_cb, self.post_write_delay),
                                  error_callback = self.async_write_error,
                                  preflight_callback = functools.partial(self.preflight_put_request, bucket, objname, len(buf)),
                                  method = 'PUT', headers = headers, postdata = buf)
    def do_async_delete(self, path, success_cb, procnum):
        bucket, objname = path
        url, headers = self.s3.delete_request(bucket, objname)
        self.s3_req.queue_request(server_time, url, functools.partial(self.async_write_helper, 1, success_cb, 0),
                                  error_callback = self.async_write_error,
                                  preflight_callback = functools.partial(self.preflight_delete_request, bucket, objname),
                                  method = 'DELETE', headers = headers)
    def do_async_exists(self, path, success_cb, error_cb, procnum):
        bucket, objname = path
        url, headers = self.s3.head_request(bucket, objname)
        self.s3_req.queue_request(server_time, url, lambda ret, success_cb=success_cb: success_cb(ret != 'NOTFOUND'),
                                  error_callback = lambda err_reason, error_cb=error_cb: error_cb(err_reason),
                                  preflight_callback = functools.partial(self.preflight_exists_request, bucket, objname),
                                  method = 'HEAD', headers = headers)

IO_SYSTEMS = { 'file': FileIOSystem, 'ioslave': IOSlaveIOSystem, 's3': S3IOSystem }
io_system = None

def io_system_init(io_config):
    global io_system
    io_system = IO_SYSTEMS[io_config.get('backend', 'file')](io_config)

ASYNC_DEBUG = True
def ascdebug(msg):
    if gamedata['server'].get('log_async_io',False):
        print msg
        gamesite.exception_log.event(server_time, 'ASC: '+spin_server_name+' '+msg)

def log_player_io(category, action, id, generation, context):
    if gamedata['server'].get('log_player_io', False):
        gamesite.player_io_log.event(server_time, '%.6f %s %s %s %s %r (%s)' % (time.time(), spin_server_name, category, action, id, generation, context))

# safely coerce a value that might be unicode() or str() to a str()
def coerce_to_str(val):
    if isinstance(val, unicode):
        return val.encode('utf-8')
    else:
        return str(val)

# mapping of game user IDs to User objects
class UserTable:
    # note: these are updated from the login code, so don't read them from the file
    WRITE_ONLY_FIELDS = [('user_id', int), # for reference/recovery only, not used as database key
                         ('fb_oauth_token', str),
                         ('kg_auth_token', str),
                         ('ag_auth_token', str),
                         ('bh_auth_token', str),
                         ('mm_auth_token', str),
                         ]

    FIELDS = [('country', None),
              ('fb_hit_time', int),
              ('account_creation_time', int),
              ('account_creation_flow', None),
              ('last_login_time', int),
              ('last_login_ip', str),
              ('last_logout_time', int),
              ('uninstalled', int),
              ('uninstalled_reason', str),
              ('privacy_consent', None),
              ('privacy_consent_time', int),
              ('privacy_consent_reason', str),
              ('birthday', None),
              ('browser_name', coerce_to_str),
              ('spin_client_platform', coerce_to_str),
              ('spin_client_vendor', coerce_to_str),
              ('spin_client_version', int),
              ('browser_version', int),
              ('browser_os', coerce_to_str),
              ('browser_hardware', str),
              ('browser_caps', None),

              # user-supplied, and thus might contain Unicode - use safe conversion function
              ('browser_user_agent', coerce_to_str),

              ('last_sprobe_result', None),
              ('locale', str),
              ('timezone', int),
              ('frame_platform', str),
              ('social_id', str),
              ('facebook_id', str),
              ('facebook_profile', None),
              ('facebook_friends', None),
              ('facebook_likes', None),
              ('facebook_currency', None),
              ('facebook_third_party_id', None),
              ('facebook_name', None),
              ('facebook_first_name', None),
              ('fb_gamer_status', int),
              ('fb_credit_balance', int),
              ('kg_id', str),
              ('kg_hit_time', int),
              ('kg_username', None),
              ('kg_avatar_url', str),
              ('kg_friend_ids', None),
              ('ag_id', str),
              ('ag_hit_time', int),
              ('ag_profile', None),
              ('ag_username', None),
              ('ag_avatar_url', str),
              ('ag_friend_ids', None),
              ('bh_id', str),
              ('bh_hit_time', int),
              ('bh_profile', None),
              ('bh_username', None),
              ('bh_trust_level', None),
              ('bh_mentor_player_id_cache', int), # not authoritative - must query bhlogin server
              ('bh_trainee_player_ids_cache', None), # not authoritative - must query bhlogin server
              ('mm_id', str),
              ('mm_hit_time', int),
              ('mm_profile', None),
              ('mm_username', None),
              ('acquisition_data', None),
              ('acquisition_campaign', None),
              ('acquisition_secondary', None),
              ('acquisition_type', None),
              ('acquisition_game_version', None),
              ('acquisition_ad_image', None),
              ('acquisition_ad_title', None),
              ('acquisition_ad_text', None),
              ('acquisition_ad_target', None),
              ('acquisition_ad_skynet', None),
              ('skynet_retargets', None),
              ('adotomi_context', None),
              ('dauup_context', None),
              ('dauup2_context', None),
              ('adparlor_context', None),
              ('fb_conversion_pixels_context', None),
              ('kg_conversion_pixels_context', None),
              ('liniad_context', None),
              ('screen_width', int),
              ('screen_height', int),
              ('canvas_width', int),
              ('canvas_height', int),
              ('canvas_oversample', None),
              ('devicePixelRatio', None),
              ('age_group', None),
              ('preferences', None),
              ('chat_gagged', int), # read-only for legacy data
              ('chat_mod', None),
              ('developer', None),
              ]

    def __init__(self):
        pass

    def jsonize(self, user):
        jsonobj = {}
        for name, coerce in (self.WRITE_ONLY_FIELDS + self.FIELDS):
            val = getattr(user, name)
            if val is not None:
                if coerce:
                    val = coerce(val)
                jsonobj[name] = val

        # store unrecognized data
        for name, val in user.foreign_data.iteritems():
            jsonobj[name] = val
        return jsonobj

    def unparse(self, user):
        with admin_stats.latency_measurer('user_table:jsonize'):
            jsonobj = self.jsonize(user)

        with admin_stats.latency_measurer('user_table:serialize'):
            ret = SpinJSON.dumps(jsonobj, pretty = True, newline = True, size_hint = 65536, double_precision = 5)
        return ret

    def parse(self, buf, user_id):
        jsonobj = None

        try:
            with admin_stats.latency_measurer('user_table:deserialize'):
                jsonobj = SpinJSON.loads(buf)
        except:
            pass

        if not jsonobj:
            return None

        with admin_stats.latency_measurer('user_table:parse'):
            return self.unjsonize(jsonobj, user_id)

    def unjsonize(self, jsonobj, user_id):
        ret = User(user_id)

        if jsonobj.has_key('user_id') and jsonobj['user_id'] != user_id:
            print 'warning: UserTable lookup for id %d has data from id %d' % (user_id, jsonobj['user_id'])

        for name, coerce in self.WRITE_ONLY_FIELDS:
            if jsonobj.has_key(name):
                del jsonobj[name]

        # parse recognized fields
        for name, coerce in self.FIELDS:
            if jsonobj.has_key(name):
                val = jsonobj[name]
                if coerce:
                    val = coerce(val)
                setattr(ret, name, val)
                del jsonobj[name]

        # store unrecognized fields
        for name, val in jsonobj.iteritems():
            print 'unrecogized User data', name, ':', val
            ret.foreign_data[name] = val

        return ret

    def store_sync(self, user):
        io_system.sync_write_user(user.user_id, self.unparse(user))

    def store_async(self, user, cb, fsync, reason):
        io_system.async_write_user(user.user_id, self.unparse(user), cb, fsync)

    def lookup_sync(self, user_id, on_behalf_of):
        try:
            gamesite.exception_log.event(server_time, 'sync lookup of user %d on behalf of user %d' % (user_id, on_behalf_of))
            buf = io_system.sync_download_user(user_id)
        except:
            return None
        return self.parse(buf, user_id)

    class AsyncRead:
        def __init__(self, parent, user_id, cb):
            self.parent = parent
            self.user_id = user_id
            self.cb = cb
        def fail(self, reason): self.cb(False, None)
        def success(self, buf):
            if buf == 'NOTFOUND':
                ret = None
            else:
                ret = self.parent.parse(buf, self.user_id)
            self.cb(True, ret)

    def lookup_async(self, user_id, cb, reason):
        request = self.AsyncRead(self, user_id, cb)
        io_system.async_read_user(user_id, request.success, request.fail)

def pcache_get_chat_name(info):
    if 'ui_name' in info: return info['ui_name']
    if ('facebook_first_name' in info) or ('facebook_name' in info):
        first_name = info.get('facebook_first_name', info.get('facebook_name','').split(' ')[0])
        full_name = info.get('facebook_name', None)
        if full_name:
            fields = full_name.split(' ')
            if len(fields) >= 2 and (len(fields[-1]) >= 1):
                return first_name + fields[-1][0]
        else:
            return first_name
    return 'Unknown(pcchat)'

def pcache_get_ui_name(info):
    if 'ui_name' in info: return info['ui_name']
    if 'facebook_first_name' in info: return info['facebook_first_name']
    if 'facebook_name' in info: return info['facebook_name'].split(' ')[0]
    return 'Unknown(pc)'

def alliance_display_name(info):
    ret = info['ui_name']
    if ('chat_tag' in info) and len(info['chat_tag']) > 0:
        ret = '%s [%s]' % (ret, info['chat_tag'])
    return ret

user_table = UserTable()

class User:
    def __init__(self, user_id):
        self.user_id = user_id
        self.fb_hit_time = -1 # server_time at which the user's Facebook data was downloaded
        self.fb_retrieve_semaphore = None # set of outstanding profile/friends/likes requests (by string name) to keep track of what's in progress
        self.account_creation_time = -1 # server_time at which account was originally created
        self.account_creation_flow = None # can be a string that describes the login flow, e.g. "anonymous_autoplay"
        self.last_login_time = -1 # last time at which user played the game
        self.last_logout_time = -1 # last time at which user exited the game
        self.last_login_ip = '' # last IP address from which this user logged in
        self.uninstalled = 0 # >0 if person uninstalled the game via the frame platform (e.g. de-authorized the Facebook app). UNIX time of uninstall event, 1 for legacy accounts.
        self.uninstalled_reason = None # string describing where the uninstall request came from
        self.privacy_consent = None # 'yes' or 'no' if user has explicitly opted in or out of personal info access
        self.privacy_consent_time = -1 # last modification time of above
        self.privacy_consent_reason = None
        self.country = '' # Facebook country from which user last logged in
        self.fb_oauth_token = None # Facebook OAuth token from the proxyserver login

        # user settings like sound/music volume - NOTE: OBSOLETE! this is player.player_preferences now
        self.preferences = {}

        # browser demographics, as reported by client in last CLIENT_HELLO message
        self.browser_name = None
        self.browser_version = None
        self.browser_os = None
        self.browser_hardware = None
        self.browser_caps = {}
        self.browser_user_agent = None

        # client platform, used to report if player is using an Electron-based client
        self.spin_client_platform = 'unknown'
        self.spin_client_vendor = 'unknown'
        self.spin_client_version = 0

        # last result sent by SProbe.js
        self.last_sprobe_result = None

        # browser canvas pixel dimensions
        self.screen_width = None
        self.screen_height = None
        self.canvas_width = None
        self.canvas_height = None
        self.canvas_oversample = None
        self.devicePixelRatio = None

        self.locale = None
        self.timezone = None

        self.frame_platform = None
        self.social_id = None

        # facebook_id and facebook_name are always guaranteed to be available (for Facebook players)
        # however, facebook_name will be set to '(waiting for Facebook)' until the API call completes
        self.facebook_id = None
        self.facebook_name = None
        self.facebook_first_name = None

        # these fields are fetched asynchronously and may not be available immediately on login
        self.facebook_profile = None
        self.facebook_profile_backup = None # keep old profile, in case server returns bad info
        self.facebook_friends = None
        self.facebook_likes = None
        self.facebook_currency = None
        self.facebook_third_party_id = None

        self.fb_gamer_status = -1
        self.fb_credit_balance = -1
        self.credit_info_request_outstanding = False
        self.birthday = None # UNIX timestamp of midnight of the user's birthday, None if no birthday info available

        # Kongregate profile data
        self.kg_auth_token = None # Kongregate auth token from the proxyserver login
        self.kg_id = None # set on login
        # below fields are pulled asynchronously from the KG API
        self.kg_hit_time = -1
        self.kg_username = None
        self.kg_avatar_url = None
        self.kg_friend_ids = None

        # Armor Games profile data
        self.ag_auth_token = None # auth token from the proxyserver login
        self.ag_id = None # set on login
        # below fields are pulled asynchronously from the Armor Games API
        self.ag_profile = None
        self.ag_hit_time = -1
        self.ag_username = None
        self.ag_avatar_url = None
        self.ag_friend_ids = None

        # Battlehouse profile data
        self.bh_auth_token = None # auth token from proxyserver login
        self.bh_id = None # set on login
        self.bh_profile = None
        self.bh_hit_time = -1
        self.bh_username = None
        self.bh_trust_level = None
        self.bh_mentor_player_id_cache = None
        self.bh_trainee_player_ids_cache = None

        # Mattermost profile data
        self.mm_auth_token = None # auth token from proxyserver login
        self.mm_id = None # set on login
        self.mm_profile = None
        self.mm_hit_time = -1
        self.mm_username = None

        self.acquisition_data = []
        self.acquisition_campaign = ''
        self.acquisition_type = None
        self.acquisition_secondary = None
        self.acquisition_game_version = ''
        self.age_group = None
        self.acquisition_ad_image = None
        self.acquisition_ad_title = None
        self.acquisition_ad_text = None
        self.acquisition_ad_target = None
        self.acquisition_ad_skynet = None # skynet targeting parameter
        self.skynet_retargets = None # list of targeting parameters we've seen on retargeted ads
        self.adotomi_context = None
        self.dauup_context = None
        self.dauup2_context = None
        self.adparlor_context = None
        self.liniad_context = None
        self.fb_conversion_pixels_context = None # flag that we should send FB Conversion Pixels
        self.kg_conversion_pixels_context = None # flag that we should send KG Conversion Pixels

        # these fields are for use inside the game server process only
        self.client_friends = set() # list of all ADD_FRIENDS sent (for AIs and true friends)
        self.client_ai_friends = set() # only counts AIs
        self.client_social_friends = set() # ONLY counts "true friends"

        # the above also include players tested but then rejected (to optimize the second run of populate_friends_who_play())
        # client_strangers only includes players really sent via ADD_FRIEND
        # AND can include players outside of self.client_friends
        self.client_strangers = None # changed to a set() on first query

        self.active_session = None

        # note: None or False or < 1 is "not gagged"
        # True or 1 is "permanently (and silently) gagged"
        # OBSOLETE - read-only for legacy data. Replaced by chat_gagged player aura.
        self.chat_gagged = None

        # 1 if player can moderate (gag) chat
        self.chat_mod = None

        # 1 if player is a developer (access to special functions and exclude from metrics)
        self.developer = None

        # this holds any unrecognized JSON data from the saved file
        # necessary to preserve forwards-compatibility in case we load a file
        # that contains data from a future version of the server
        self.foreign_data = {}

        # string if player is on a VPN, None if not
        self.vpn_status = None

    def get_trust_level(self):
        # any login from KG, AG, or FB counts as "verified"
        if self.frame_platform in ('fb','kg','k2','ag'):
            return 10 # loginserver.py TRUST_VERIFIED

        elif self.frame_platform == 'bh':
            if self.bh_trust_level is not None:
                return self.bh_trust_level

        return 0 # loginserver.py TRUST_ANONYMOUS_GUEST

    # for the various get_name() functions, Player must be passed in
    # since we might want the alias/title to override the
    # platform-provided name stored on the User object.

    def get_chat_name(self, player):
        if player.alias: return player.get_titled_alias()
        if self.bh_username: return self.bh_username
        if self.ag_username: return self.ag_username
        if self.kg_username: return self.kg_username
        if self.mm_username: return self.mm_username
        if self.facebook_first_name:
            if self.facebook_name and len(self.facebook_name.split(' ')) >= 2:
                # first name + last initial
                fields = self.facebook_name.split(' ')
                ret = self.facebook_first_name or fields[0]
                if len(fields[-1]) >= 1:
                    ret += fields[-1][0]
                return ret
            else:
                return self.facebook_first_name
        return 'Unknown(userchat)'

    # player naming is documented here: https://sites.google.com/a/spinpunch.com/developers/code-formatting/special-topics/player-aliases

    # return the "real" (platform-provided) name of the player
    def get_real_name(self):
        if self.bh_username: return self.bh_username
        if self.ag_username: return self.ag_username
        if self.kg_username: return self.kg_username
        if self.mm_username: return self.mm_username
        if self.facebook_first_name: return self.facebook_first_name
        if self.facebook_name: return self.facebook_name.split(' ')[0]
        return 'Unknown(user)'

    # return the name that should be shown in the GUI (except chat) for this player
    def get_ui_name(self, player):
        if player.alias: return player.get_titled_alias()
        return self.get_real_name()

    # return the name that should be shown in out-of-game notifications
    def get_ui_and_real_name(self, player):
        ui_name = self.get_ui_name(player)
        real_name = self.get_real_name()
        if ui_name == real_name:
            return ui_name
        else:
            return ui_name + ' (' + real_name + ')'

    def get_ui_name_searchable(self, player):
        # get the name that should be referenced for case-insensitive searches (that want to use a case-sensitive index)
        if player.alias:
            # important: this should NOT include the title
            return player.alias.lower()
        return self.get_ui_name(player).lower()

    def get_xsolla_id(self):
        # return the unique ID for this user for the Xsolla API
        return self.social_id

    def get_email(self):
        # note: keep in sync with SpinUpcache.py update_upcache_entry()
        if self.bh_profile and self.bh_profile.get('ui_email') and self.bh_profile.get('email_verified'):
            return self.bh_profile['ui_email']
        if self.mm_profile and self.mm_profile.get('email'):
            return self.mm_profile['email']
        if self.facebook_profile and self.facebook_profile.get('email'):
            return self.facebook_profile['email']
        if self.ag_profile and self.ag_profile.get('email'):
            return self.ag_profile['email']
        return None

    def get_mailchimp_context(self):
        if not SpinConfig.config.get('mailchimp_api_key'):
            return None

        email = self.get_email()
        if not email: return None

        # rough name
        full_name = self.get_real_name()
        if ' ' in full_name:
            names = full_name.split(' ')
            first_name = names[0]
            last_name = ' '.join(names[1:])
        else:
            first_name = full_name
            last_name = ''

        # better name from FB profile
        if self.facebook_profile:
            if 'short_name' in self.facebook_profile:
                first_name = self.facebook_profile['short_name']
            elif 'first_name' in self.facebook_profile:
                first_name = self.facebook_profile['first_name']
            if 'last_name' in self.facebook_profile:
                last_name = self.facebook_profile['last_name']

        ret =  {'email_address': email,
                'merge_fields':
                {"FNAME": first_name,
                 "LNAME": last_name,
                 "FULLNAME": full_name,
                 "PLAYER_ID": self.user_id}
                }
        if self.locale: ret['language'] = self.locale[0:2]
        if self.account_creation_time > 0:
            ret['merge_fields']['ACCT_CREAT'] = time.strftime('%m/%d/%Y', time.gmtime(self.account_creation_time))

        if self.country:
            ret['merge_fields']['COUNTRY'] = self.country
            ret['merge_fields']['TIER'] = SpinConfig.country_tier_map.get(self.country, 4)
        return ret

    def chat_can_interact(self):
        if not self.active_session: return False
        return True

    def is_friends_with(self, social_id):
        if social_id:
            if social_id.startswith('fb'):
                fb_id = social_id[2:]
                if not self.facebook_friends:
                    return False
                for friend in self.facebook_friends:
                    if str(friend['id']) == fb_id:
                        return True
            elif social_id.startswith('kg'):
                kg_id = social_id[2:]
                if not self.kg_friend_ids:
                    return False
                for friend in self.kg_friend_ids:
                    if str(friend) == kg_id:
                        return True
            elif social_id.startswith('ag'):
                ag_id = social_id[2:]
                if not self.ag_friend_ids:
                    return False
                for friend in self.ag_friend_ids:
                    if str(friend) == ag_id:
                        return True
        return False

    def is_developer(self): return bool(self.developer)

    def is_suspicious(self):
        return self.user_id in gamedata['server']['suspicious_user_id_list']

    def is_chat_mod(self):
        return self.chat_mod or self.is_developer()

    def prune_acquisition_data(self):
        # after adding newest acquisition data entry, go back and prune out unwanted old entries
        # we get rid of anything that get_acquisition_data_from_url() considers 'useless'
        # as well as anything not marked 'important' on login
        new_data = []

        for i, d in enumerate(self.acquisition_data):
            if i > 0: # never prune first entry
                if d.get('useless',0):
                    continue # prune - useless
                elif ('url' in d):
                    parsed = get_acquisition_data_from_url(d['url'], self.user_id)
                    if parsed and parsed.get('useless',0):
                        continue # prune - useless

                if not d.get('important', False):
                    continue # prune - not important

            new_data.append(d)

        self.acquisition_data = new_data

    def update_acquisition_data(self, data, important = False):
        # 'important' means 'first acquisition, or reacquisition after account lapsed for a while'

        if data:
            data['time'] = server_time
            if important:
                data['important'] = 1
            self.acquisition_data.append(data)
            if ('adotomi' in gamedata['adnetworks']) and ('adotomi_context' in data) and (not self.adotomi_context):
                self.adotomi_context = data['adotomi_context']
                self.log_adnetwork_event('adotomi', {'user_id': self.user_id, 'kpi':'context_attached',
                                                         'context':self.adotomi_context, 'url':data.get('url','unknown')})
                if gamedata['server'].get('log_adotomi',1):
                    gamesite.exception_log.event(server_time, 'got adotomi context for user %d: "%s"' % (self.user_id, self.adotomi_context))

            if ('dauup' in gamedata['adnetworks']) and ('dauup_context' in data) and (not self.dauup_context):
                self.dauup_context = data['dauup_context']
                self.log_adnetwork_event('dauup', {'user_id':self.user_id, 'kpi':'context_attached',
                                                       'context':self.dauup_context, 'url':data.get('url','unknown')})
                if gamedata['server'].get('log_dauup',1):
                    gamesite.exception_log.event(server_time, 'got dauup context for user %d: "%s"' % (self.user_id, self.dauup_context))
            if ('dauup2' in gamedata['adnetworks']) and ('dauup2_context' in data) and (not self.dauup2_context):
                self.dauup2_context = data['dauup2_context']
                self.log_adnetwork_event('dauup2', {'user_id':self.user_id, 'kpi':'context_attached',
                                                        'context':self.dauup2_context, 'url':data.get('url','unknown')})
                if gamedata['server'].get('log_dauup2',1):
                    gamesite.exception_log.event(server_time, 'got dauup2 context for user %d: "%s"' % (self.user_id, self.dauup2_context))

            if ('adparlor' in gamedata['adnetworks']) and ('campaign_name' in data) and data['campaign_name'].startswith('7102') and (not self.adparlor_context):
                self.adparlor_context = "1"
                self.log_adnetwork_event('adparlor', {'user_id':self.user_id, 'kpi':'context_attached',
                                                          'context':self.adparlor_context, 'url':data.get('url','unknown')})
                if gamedata['server'].get('log_adparlor',1):
                    gamesite.exception_log.event(server_time, 'got adparlor context for user %d: "%s"' % (self.user_id, self.adparlor_context))

            if ('liniad' in gamedata['adnetworks']) and ('liniad_context' in data) and (self.liniad_context is None):
                self.liniad_context = data['liniad_context']
                self.log_adnetwork_event('liniad', {'user_id':self.user_id, 'kpi':'context_attached',
                                                        'context':self.liniad_context, 'url':data.get('url','unknown')})
                if gamedata['server'].get('log_liniad',1):
                    gamesite.exception_log.event(server_time, 'got liniad context for user %d: "%s"' % (self.user_id, repr(self.liniad_context)))

            if ('fb_conversion_pixels' in gamedata['adnetworks']) and ('fb_conversion_pixels_context' in data) and (self.fb_conversion_pixels_context is None):
                self.fb_conversion_pixels_context = data['fb_conversion_pixels_context']
                self.log_adnetwork_event('fb_conversion_pixels', {'user_id':self.user_id, 'kpi':'context_attached',
                                                                      'context':self.fb_conversion_pixels_context, 'url':data.get('url','unknown')})
                if gamedata['server'].get('log_fb_conversion_pixels',1):
                    gamesite.exception_log.event(server_time, 'got fb_conversion_pixels context for user %d: "%s"' % (self.user_id, repr(self.fb_conversion_pixels_context)))

            if 'skynet_retarget' in data:
                if self.skynet_retargets is None: self.skynet_retargets = []
                # append but do not allow duplicates
                self.skynet_retargets = list(set(self.skynet_retargets + [data['skynet_retarget'],]))

        self.prune_acquisition_data()

        if not self.acquisition_game_version:
            self.acquisition_game_version = SERVER_VERSION

        # try to identify the acquisition campaign - first priority goes
        # to ad clicks ("primary"), then friend invites ("secondary"),
        # then anything else.

        def is_unassigned(camp):
            return (camp in [None, '', 'unknown', 'facebook_app_request', 'feed_level_up', 'feed_thanks'] or \
                    camp.startswith('viral_'))

        # already identified?
        if not is_unassigned(self.acquisition_campaign):
            return

        # search for primary ad clicks
        for d in self.acquisition_data:
            if d['type'] == 'ad_click':
                # primary ad click found
                self.acquisition_secondary = 0
                self.acquisition_campaign = d['campaign_name']
                self.acquisition_type = d['type']
                if 'age_group' in d:
                    self.age_group = d['age_group']
                if 'ad_image' in d:
                    self.acquisition_ad_image = d['ad_image']
                if 'ad_title' in d:
                    self.acquisition_ad_title = d['ad_title']
                if 'ad_text' in d:
                    self.acquisition_ad_text = d['ad_text']
                if 'ad_target' in d:
                    self.acquisition_ad_target = d['ad_target']
                if 'ad_skynet' in d:
                    self.acquisition_ad_skynet = d['ad_skynet']
                return

        # secondary or unknown acquisition source
        # note: facebook_app_request will almost always have a facebook_friend_invite following it,
        # so this will take care of cleaning up facebook_app_requests as well.

        if gamedata['server'].get('trace_secondary_acquisitions',False):
            for d in self.acquisition_data:
                if d['type'] == 'facebook_friend_invite':
                    # find the friend's acquisition campaign
                    if ('sender_user_id' in d) and (int(d['sender_user_id']) != self.user_id):
                        fr = user_table.lookup_sync(int(d['sender_user_id']), self.user_id)
                        if fr and (not is_unassigned(fr.acquisition_campaign)):
                            self.acquisition_secondary = 1
                            self.acquisition_campaign = fr.acquisition_campaign
                            # assume that referees have same age group as referer
                            if fr.age_group is not None:
                                self.age_group = fr.age_group
                            return

            for d in self.acquisition_data:
                if ((d['type'] in ('feed_level_up', 'feed_thanks')) or d['type'].startswith('viral_')) and \
                   ('referring_user_id' in d) and \
                   d['referring_user_id'].isdigit() and \
                   int(d['referring_user_id']) != self.user_id:
                    fr = user_table.lookup_sync(int(d['referring_user_id']), self.user_id)
                    if fr and (not is_unassigned(fr.acquisition_campaign)):
                        self.acquisition_secondary = 1
                        self.acquisition_campaign = fr.acquisition_campaign
                        self.acquisition_type = d['type']
                        if fr.age_group is not None:
                            self.age_group = fr.age_group
                        return

        # unknown acquisition source, just return the type (usually in UNASSIGNED)
        if len(self.acquisition_data) > 0:
            self.acquisition_campaign = self.acquisition_data[0]['type']

    def repopulate_ai_list(self, session):
        # add AI opponents to friends list

        ai_list = set()

        for strid, base in gamedata['ai_bases_server']['bases'].iteritems():
            if not base.get('enable',1): continue
            if 'activation' not in base: continue

            pred = Predicates.read_predicate(base['activation'])
            if not pred.is_satisfied2(session, session.player, None):
                if ('show_if' in base) and Predicates.read_predicate(base['show_if']).is_satisfied2(session, session.player, None):
                    # still show it
                    pass
                else:
                    # skip the base
                    continue

            ai_list.add(int(strid))

        # first remove AIs that are no longer valid from the client
        for id in self.client_ai_friends.difference(ai_list):
            session.send([["REM_FRIEND", id]])
            self.client_ai_friends.remove(id)
            self.client_friends.remove(id)

        # now add new AIs
        for id in ai_list.difference(self.client_ai_friends):
            self.client_ai_friends.add(id)
            self.client_friends.add(id)
            base = gamedata['ai_bases_server']['bases'][str(id)]
            friend_name = base['ui_name']
            friend_level = base['resources']['player_level']

            session.send([["ADD_FRIEND", id, False,
                           [{'user_id': id,
                             'social_id': 'ai',
                             'ui_name': friend_name,
                             'player_level': friend_level
                }]]])


    def populate_friends_who_play(self, session):

        # batch query for game player IDs
        social_id_list = []
        if self.facebook_friends:
            social_id_list += ['fb'+str(friend['id']) for friend in self.facebook_friends]
        if self.kg_friend_ids:
            social_id_list += ['kg'+str(x) for x in self.kg_friend_ids]
        if self.ag_friend_ids:
            social_id_list += ['ag'+str(x) for x in self.ag_friend_ids]

        # note: this call is free if social_id_list is empty, it won't hit the database
        friend_id_list = gamesite.social_id_table.social_id_to_spinpunch_batch(social_id_list)

        if self.bh_mentor_player_id_cache is not None:
            friend_id_list.append(self.bh_mentor_player_id_cache)
        if self.bh_trainee_player_ids_cache is not None:
            friend_id_list += self.bh_trainee_player_ids_cache

        if not friend_id_list:
            return # probably still waiting on the API

        # filter out friends who are not game players, and friends who we've already told the client about
        friend_id_list = filter(lambda x: (x is not None) and (x not in self.client_friends), friend_id_list)

        if friend_id_list:
            # query the player cache
            add_props = gamesite.gameapi.do_query_player_cache(session, friend_id_list, reason = 'populate_friends_who_play')

        for i in xrange(len(friend_id_list)):
            friend_id = friend_id_list[i]
            friend_props = add_props[i]

            self.client_friends.add(friend_id)

            if not friend_props:
                # the friend has a player ID but never created any game state. This is probably because the friend
                # hit our site but was blocked by country or had an unsupported browser, so they never entered the game.
                # print 'warning: no PlayerCache entry for friend player %d' % friend_id
                continue

#            if not friend_props.get('tutorial_complete', False):
#                # do not connect to friends until they have completed the tutorial
#                continue

            self.client_social_friends.add(friend_id)

            relationship = None
            if friend_id == self.bh_mentor_player_id_cache:
                relationship = 'mentor'
            elif self.bh_trainee_player_ids_cache and (friend_id in self.bh_trainee_player_ids_cache):
                relationship = 'trainee'

            session.send([["ADD_FRIEND", friend_id,
                           True, # is a real Facebook friend (not a stranger)
                           [friend_props],
                           relationship
                           ]])

        if not session.player.history.has_key('initial_friends_in_game'):
            session.player.history['initial_friends_in_game'] = len(self.client_social_friends)

        session.setmax_player_metric('friends_in_game', len(self.client_social_friends), bucket = True, bucket_size=60*60)

    def retrieve_kg_info(self, session, retmsg):
        if (None not in (self.kg_username, self.kg_avatar_url, self.kg_friend_ids)) and \
           ((server_time - self.kg_hit_time) < gamedata['server'].get('kongregate_cache_lifetime', 14400)):
            # use cached data
            return
        assert self.kg_auth_token

        if SpinConfig.config.get('enable_kongregate',0):
            self.retrieve_kg_info_start(session)
        else:
            # note: must match proxyserver.py test credentials
            test_response = SpinJSON.dumps({"friends":[],"muted_users":[],"friend_ids":[12345],"muted_user_ids":[],"user_id":12345,"username":"example1","private":False,"page_num":1,"num_pages":1,"success":True,"user_vars":{"username":"example1","level":1,"points":15,"avatar_url":"http://cdn4.kongcdn.com/assets/resize-image/50x50/assets/avatars/defaults/frog.png","chat_avatar_url":"http://cdn4.kongcdn.com/assets/resize-image/16x16/assets/avatars/defaults/frog.png","developer":False,"moderator":False,"admin":False,"gender":None,"age":32,"game_title":"Test Game","game_url":"http://www.kongregate.com/games/example1/test-game"}})
            reactor.callLater(2, lambda _self=self, _session=session, _retmsg=retmsg: _self.retrieve_kg_info_complete(_session, None, test_response)) # delay to expose timing bugs

    def retrieve_kg_info_start(self, session):
        gamesite.AsyncHTTP_Kongregate.queue_request(server_time,
                                                    'http://www.kongregate.com/api/user_info.json?user_id=%s' % self.kg_id,
                                                    lambda result, _session=session: self.retrieve_kg_info_complete(_session, None, result))
    def retrieve_kg_info_complete(self, session, retmsg, result):
        data = SpinJSON.loads(result)
        assert data['success']
        if data['num_pages'] > 1:
            gamesite.exception_log.event(server_time, 'user %d (kgid %s) profile with num_pages>1' % (self.user_id, self.kg_id))

        self.kg_username = data['username']
        self.kg_avatar_url = data['user_vars']['avatar_url']
        self.kg_friend_ids = data['friend_ids']
        if 'age' in data['user_vars'] and type(data['user_vars']['age'] is int):
            # go back N years and 6 months
            self.birthday = int(server_time - (data['user_vars']['age']*365+180)*86400)
        self.kg_hit_time = server_time

        # sync duplicate fields into Player
        if session: session.player.sync_with_user(self)

        if retmsg is None:
            if self.active_session:
                retmsg = self.active_session.outgoing_messages
        if retmsg is not None:
            retmsg.append(["PLAYER_CACHE_UPDATE", [gamesite.gameapi.get_player_cache_props(self, session.player, session.alliance_id_cache)]])
            retmsg.append(["PLAYER_UI_NAME_UPDATE", self.get_ui_name(session.player)])
            retmsg.append(["PLAYER_TRUST_LEVEL_UPDATE", self.get_trust_level()])

        # update portrait
        portrait_d = gamesite.player_portraits.update(server_time, self.user_id, {'kg_avatar_url':self.kg_avatar_url}, 'kg', 'kg'+str(self.kg_id), None)
        if session:
            session.portrait_update_launched(portrait_d)

    def retrieve_mm_info(self, session, retmsg):
        if (None not in (self.mm_username,)) and \
           ((server_time - self.mm_hit_time) < gamedata['server'].get('mattermost_cache_lifetime', 14400)):
            # use cached data
            return

        # note: auth token not required

        if SpinConfig.config.get('enable_mattermost',0):
            self.retrieve_mm_info_start(session)
        else:
            # note: must match proxyserver.py test credentials
            test_response = SpinJSON.dumps({"id":"rh4py9er3b8sf89kyu34braxhe","create_at":1466128021292,"update_at":1466128388312,"delete_at":0,"username":"example1","auth_data":"","auth_service":"","email":"asdf@example.com","nickname":"Example","first_name":"Ex","last_name":"Ample","roles":"system_admin","last_activity_at":1466189487290,"last_ping_at":1466189833741,"allow_marketing":True,"notify_props":{"channel":"true","desktop":"all","desktop_sound":"true","email":"true","first_name":"false","mention_keys":"example1,@example1","push":"mention"},"last_password_update":1466128021292,"locale":"en"})
            reactor.callLater(2, lambda _self=self, _session=session, _retmsg=retmsg: _self.retrieve_mm_info_complete(_session, None, test_response)) # delay to expose timing bugs

    def retrieve_mm_info_start(self, session):
        assert self.mm_auth_token
        gamesite.AsyncHTTP_Mattermost.queue_request(server_time,
                                                     SpinConfig.config['mattermost_api_path']+'/api/v3/users/%s/get' % self.mm_id,
                                                     lambda result, _session=session: self.retrieve_mm_info_complete(_session, None, result),
                                                     headers = {'Authorization': 'Bearer '+self.mm_auth_token})
        # update portrait
        portrait_d = gamesite.player_portraits.update(server_time, self.user_id, {}, 'mm', 'mm'+str(self.mm_id), self.mm_auth_token)
        session.portrait_update_launched(portrait_d)

    def retrieve_mm_info_complete(self, session, retmsg, result):
        data = SpinJSON.loads(result)
        assert data['id'] == self.mm_id

        self.mm_profile = data # store entire profile

        self.mm_username = data['nickname']
        if 'birthday' in data: pass # no birthday data
        self.mm_hit_time = server_time

        # sync duplicate fields into Player
        if session: session.player.sync_with_user(self)

        if retmsg is None:
            if self.active_session:
                retmsg = self.active_session.outgoing_messages
        if retmsg is not None:
            retmsg.append(["PLAYER_CACHE_UPDATE", [gamesite.gameapi.get_player_cache_props(self, session.player, session.alliance_id_cache)]])
            retmsg.append(["PLAYER_UI_NAME_UPDATE", self.get_ui_name(session.player)])
            retmsg.append(["PLAYER_TRUST_LEVEL_UPDATE", self.get_trust_level()])

    def retrieve_bh_info(self, session, retmsg):
        if (None not in (self.bh_username,)) and \
           ((server_time - self.bh_hit_time) < gamedata['server'].get('battlehouse_cache_lifetime', -1)):
            # use cached data
            return defer.succeed(True)

        if SpinConfig.config.get('enable_battlehouse',0):
            return self.retrieve_bh_info_start(session)
        else:
            # note: must match proxyserver.py test credentials
            test_response = SpinJSON.dumps({"user_id":"4d0075c6-e9d9-4b01-b7d0-4cffa7a1e17c", "ui_name": "Dan Maas", "email": "asdf@example.com", "email_verified": True, "creation_time": 1472072770})
            d = make_deferred('retrieve_bh_info')
            reactor.callLater(2, lambda _self=self, _session=session: _self.retrieve_bh_info_complete(_session, d, test_response)) # delay to expose timing bugs
            return d

    def retrieve_bh_info_start(self, session):
        assert self.bh_auth_token
        d = make_deferred('retrieve_bh_info')
        gamesite.AsyncHTTP_Battlehouse.queue_request(server_time,
                                                     SpinConfig.config['battlehouse_api_path']+('/user/%s' % self.bh_id) + '?service=' + SpinConfig.game(),
                                                     lambda result, _session=session, _d=d: self.retrieve_bh_info_complete(_session, _d, result),
                                                     headers = {'Authorization': 'Bearer '+self.bh_auth_token,
                                                                'X-BHLogin-API-Secret': SpinConfig.config['battlehouse_api_secret'].encode('utf-8')})
        # update portrait
        portrait_d = gamesite.player_portraits.update(server_time, self.user_id, {}, 'bh', 'bh'+str(self.bh_id), self.bh_auth_token)
        session.portrait_update_launched(portrait_d)
        return d

    def retrieve_bh_info_complete(self, session, d, result):
        data = SpinJSON.loads(result)
        if data['user_id'] != self.bh_id:
            gamesite.exception_log.event(server_time, 'retrieve_bh_info_complete(%s): mismatched user_id: %r' % \
                                         (self.bh_id, data))
            d.callback(True)
            return

        self.bh_profile = data # store entire profile

        self.bh_username = data['ui_name']
        if 'timezone' in data and isinstance(data['timezone'], int):
            self.timezone = data['timezone']
        # note: locale is updated on login
        if 'birthday' in data: pass # no birthday data
        if 'trust_level' in data:
            self.bh_trust_level = data['trust_level']

        last_hit_time, self.bh_hit_time = self.bh_hit_time, server_time

        # sync duplicate fields into Player
        if session: session.player.sync_with_user(self)

        if last_hit_time < 0:
            # on very first hit, force player cache update to publish ui_name
            gamesite.gameapi.send_player_cache_update(session, 'retrieve_bh_info_complete')

        session.send([["PLAYER_CACHE_UPDATE", [gamesite.gameapi.get_player_cache_props(self, session.player, session.alliance_id_cache)]],
                      ["PLAYER_UI_NAME_UPDATE", self.get_ui_name(session.player), 'retrieve_bh_info_complete'],
                      ["PLAYER_TRUST_LEVEL_UPDATE", self.get_trust_level()]],
                     flush_now = True)

        d.callback(True)

    @inlineCallbacks
    def retrieve_bh_friends(self, session):
        assert self.bh_auth_token
        url = SpinConfig.config['battlehouse_api_path']+ '/user/'+self.bh_id+'/invites?' + \
              urllib.urlencode({'service': SpinConfig.game()})
        headers = {'X-BHLogin-API-Secret': SpinConfig.config['battlehouse_api_secret'].encode('utf-8')}
        response_raw = yield gamesite.AsyncHTTP_Battlehouse.queue_request_deferred(server_time, url, headers = headers)
        response = SpinJSON.loads(response_raw)
        if 'result' in response:
            bh_ids_to_look_up = []
            if response['result']['my_inviter']:
                bh_ids_to_look_up.append(response['result']['my_inviter']['sender_id'])
            for entry in response['result']['my_targets']:
                bh_ids_to_look_up.append(entry['target_id'])
            user_ids = gamesite.social_id_table.social_id_to_spinpunch_batch(['bh'+id for id in bh_ids_to_look_up])
            bh_id_to_user_id = dict(zip(bh_ids_to_look_up, user_ids))

            if response['result']['my_inviter']:
                session.player.mentor_player_id_cache = \
                self.bh_mentor_player_id_cache = bh_id_to_user_id[response['result']['my_inviter']['sender_id']]
            else:
                session.player.mentor_player_id_cache = \
                self.bh_mentor_player_id_cache = None

            session.player.trainee_player_ids_cache = \
            self.bh_trainee_player_ids_cache = [bh_id_to_user_id[entry['target_id']] \
                                                for entry in response['result']['my_targets']]

            assert self.bh_id
            completed_count = sum((1 for entry in response['result']['my_targets'] \
                                   if entry.get('state') == 'complete' and \
                                      entry.get('state_change_sender_id') == self.bh_id), 0)
            if completed_count != session.player.history.get('trainee_completions', 0):
                session.setmax_player_metric('trainee_completions', completed_count)
                session.player.modify_scores({'trainee_completions':completed_count}, method='=', reason='retrieve_bh_friends')

        self.populate_friends_who_play(session)

    @inlineCallbacks
    def accept_bh_invite(self, session, invite_code, is_acquisition):
        assert self.bh_auth_token

        # sometimes invite codes get scrambled when the URL is appended with junk.
        # e.g. "12345678https://www.battlehouse..."
        # clear that out here.
        invite_code = re.compile('http.*').sub('', invite_code)

        url = SpinConfig.config['battlehouse_api_path']+ '/invite_accept?' + \
              urllib.urlencode({'service': SpinConfig.game(),
                                'code': invite_code,
                                'state': 'init'})
        headers = {'Authorization': 'Bearer '+self.bh_auth_token,
                   'X-BHLogin-API-Secret': SpinConfig.config['battlehouse_api_secret'].encode('utf-8')}
        response_raw = yield gamesite.AsyncHTTP_Battlehouse.queue_request_deferred(server_time, url, headers = headers)
        response = SpinJSON.loads(response_raw)

        if 'error' in response:
            # error - local notification only
            notify_client = True

            known_errors = {'AlreadyLinkedError': 'bh_invite_already_linked_error_displayed',
                            'SelfInviteError': 'bh_invite_self_invite_error_displayed'}

            if response.get('error_code') in known_errors:
                # don't show same error repeatedly
                cd_name = known_errors[response['error_code']]
                if session.player.cooldown_active(cd_name):
                    notify_client = False
                else:
                    session.player.cooldown_trigger(cd_name, 3*86400)
            else:
                gamesite.exception_log.event(server_time, 'accept_bh_invite(%s): bad response %r' % (invite_code, response))

            if notify_client:
                session.send([["NOTIFICATION", {"format":"bh", "ui_body": response['error']}]], flush_now = True)

        elif 'result' in response:
            # success
            sender_bh_id = response['result']['creator_id']
            sender_player_id = gamesite.social_id_table.social_id_to_spinpunch('bh'+sender_bh_id, False)
            assert sender_player_id > 0
            self.bh_mentor_player_id_cache = sender_player_id

            metric_event_coded(self.user_id,
                               '7106_invite_friends_hit_acquisition' if is_acquisition else \
                               '7107_invite_friends_hit_redundant',
                               {'attempt_id': invite_code,
                                'request_id': str(sender_player_id),
                                'message': sender_bh_id,
                                'sum': session.player.get_denormalized_summary_props('brief')})

            metric_event_coded(self.user_id, '7121_mentorship_init',
                               {'attempt_id': invite_code,
                                'request_id': str(sender_player_id),
                                'message': sender_bh_id,
                                'sum': session.player.get_denormalized_summary_props('brief')})

            sender_info = gamesite.gameapi.do_query_player_cache(session, [sender_player_id],
                                                                 fields = ['ui_name', 'real_name'],
                                                                 reason = 'accept_bh_invite')[0]

            # local+offline notification to sender and target
            if 'real_name' in sender_info:
                sender_ui_and_real_name = sender_info['ui_name'] + ' (' + sender_info['real_name'] + ')'
            else:
                sender_ui_and_real_name = sender_info['ui_name']
            replacements = SpinJSON.dumps({'%SENDER_UI_NAME': sender_info['ui_name'],
                                           '%SENDER_UI_AND_REAL_NAME': sender_ui_and_real_name,
                                           '%TARGET_UI_NAME': self.get_ui_name(session.player),
                                           '%TARGET_UI_AND_REAL_NAME': self.get_ui_and_real_name(session.player)})

            gamesite.do_CONTROLAPI(session.user.user_id, {'method':'send_notification','reliable':1,'force':1,'multi_per_logout':1,
                                                          'send_ingame':1,'send_offline':1,'format':'bh',
                                                          'user_id':sender_player_id,
                                                          'replacements':replacements,
                                                          'config':'bh_invite_accepted_sender'})
            gamesite.do_CONTROLAPI(session.user.user_id, {'method':'repopulate_friends',
                                                          'user_id':sender_player_id})
            gamesite.do_CONTROLAPI(session.user.user_id, {'method':'send_notification','reliable':1,'force':1,'multi_per_logout':1,
                                                          'send_ingame':1,'send_offline':1,'format':'bh',
                                                          'user_id':self.user_id,
                                                          'replacements':replacements,
                                                          'config':'bh_invite_accepted_target'})

            self.populate_friends_who_play(session)

    @inlineCallbacks
    def complete_bh_invite(self, session):
        assert self.bh_auth_token
        url = SpinConfig.config['battlehouse_api_path']+ '/invite_state?' + \
              urllib.urlencode({'service': SpinConfig.game(),
                                'state': 'complete'})
        headers = {'Authorization': 'Bearer '+self.bh_auth_token,
                   'X-BHLogin-API-Secret': SpinConfig.config['battlehouse_api_secret'].encode('utf-8')}
        response_raw = yield gamesite.AsyncHTTP_Battlehouse.queue_request_deferred(server_time, url, headers = headers)
        response = SpinJSON.loads(response_raw)

        if 'error' in response or ('result' not in response):
            # error - local notification only
            raise Exception(response['error'])

        else:
            # success
            sender_bh_id = response['result']['creator_id']
            sender_player_id = gamesite.social_id_table.social_id_to_spinpunch('bh'+sender_bh_id, False)
            assert sender_player_id > 0

            metric_event_coded(self.user_id, '7122_mentorship_complete',
                               {'request_id': str(sender_player_id),
                                'message': sender_bh_id,
                                'sum': session.player.get_denormalized_summary_props('brief')})

            sender_info = gamesite.gameapi.do_query_player_cache(session, [sender_player_id],
                                                                 fields = ['ui_name', 'real_name'],
                                                                 reason = 'complete_bh_invite')[0]

            # local+offline notification to sender and target
            if 'real_name' in sender_info:
                sender_ui_and_real_name = sender_info['ui_name'] + ' (' + sender_info['real_name'] + ')'
            else:
                sender_ui_and_real_name = sender_info['ui_name']
            replacements = SpinJSON.dumps({'%SENDER_UI_NAME': sender_info['ui_name'],
                                           '%SENDER_UI_AND_REAL_NAME': sender_ui_and_real_name,
                                           '%TARGET_UI_NAME': self.get_ui_name(session.player),
                                           '%TARGET_UI_AND_REAL_NAME': self.get_ui_and_real_name(session.player)})
            gamesite.do_CONTROLAPI(session.user.user_id, {'method':'send_notification','reliable':1,'force':1,'multi_per_logout':1,
                                                          'send_ingame':1,'send_offline':1,'format':'bh',
                                                          'user_id':sender_player_id,
                                                          'replacements':replacements,
                                                          'config':'bh_invite_completed_sender'})

            # update sender's view of the "friend" so it shows as completed
            # (this assumes that the player cache entry is sufficient to determine whether the invite is completed)
            gamesite.do_CONTROLAPI(session.user.user_id, {'method':'player_cache_update',
                                                          'user_id':sender_player_id,
                                                          'props': SpinJSON.dumps([gamesite.gameapi.get_player_cache_props(self, session.player, session.alliance_id_cache)])
                                                          })
            # tell sender to re-query list of trainees
            gamesite.do_CONTROLAPI(session.user.user_id, {'method':'repopulate_friends',
                                                          'user_id':sender_player_id})
            gamesite.do_CONTROLAPI(session.user.user_id, {'method':'send_notification','reliable':1,'force':1,'multi_per_logout':1,
                                                          'send_ingame':1,'send_offline':0,'format':'bh', # note: no email on this one
                                                          'user_id':self.user_id,
                                                          'replacements':replacements,
                                                          'config':'bh_invite_completed_target'})
            returnValue(True)

    def retrieve_ag_info(self, session, retmsg):
        if (None not in (self.ag_username, self.ag_avatar_url, self.ag_friend_ids)) and \
           ((server_time - self.ag_hit_time) < gamedata['server'].get('armorgames_cache_lifetime', 14400)):
            # use cached data
            return

        # note: auth token not required

        if SpinConfig.config.get('enable_armorgames',0):
            self.retrieve_ag_info_start(session)
            self.retrieve_ag_friends_start(session)
        else:
            # note: must match proxyserver.py test credentials
            test_response = SpinJSON.dumps({'version': 1, 'code': 200, 'message': "OK", 'payload': {
                'uid': self.ag_id,
                'username': "test_user2" if self.ag_id == "example2" else "test_user",
                'avatar': "http://armatars.armorgames.com/armatar_149_50.50_c.jpg",
                'email': "test_user@test.com",
                'birthday': "0000-00-00",
                'gender':"Male",
                'created_on': "1335466318" } })
            reactor.callLater(2, lambda _self=self, _session=session, _retmsg=retmsg: _self.retrieve_ag_info_complete(_session, None, test_response)) # delay to expose timing bugs
            friends_response = SpinJSON.dumps({'version': 1, 'code': 200, 'message': "OK", 'payload': [
                {
                'uid':"example2" if self.ag_id == "example1" else "example1",
                'username': "test_user2" if self.ag_id == "example1" else "test_user",
                'avatar': "http://armatars.armorgames.com/armatar_119_50.50_c.jpg",
                'email': "user_one@test.com",
                'birthday': "1987-04-24",
                'gender': "Female",
                'created_on': "1198082452",
                'plays_game': "1"}]})
            reactor.callLater(2, lambda _self=self, _session=session, _retmsg=retmsg: _self.retrieve_ag_friends_complete(_session, None, friends_response)) # delay to expose timing bugs

    def retrieve_ag_info_start(self, session):
        gamesite.AsyncHTTP_ArmorGames.queue_request(server_time,
                                                    'https://services.armorgames.com/services/rest/v1/users/%s.json?api_key=%s' % (self.ag_id, SpinConfig.config['armorgames_api_key']),
                                                    lambda result, _session=session: self.retrieve_ag_info_complete(_session, None, result))
    def retrieve_ag_info_complete(self, session, retmsg, result):
        data = SpinJSON.loads(result)
        assert data['code'] == 200
        payload = data['payload']
        assert payload['uid'] == self.ag_id

        self.ag_profile = payload # store entire profile

        self.ag_username = payload['username']
        self.ag_avatar_url = payload['avatar']
        if 'birthday' in payload:
            y, m, d = map(int, payload['birthday'].split('-'))
            if y != 0:
                self.birthday = SpinConfig.cal_to_unix((y,m,d))
        self.ag_hit_time = server_time

        # sync duplicate fields into Player
        if session: session.player.sync_with_user(self)

        if retmsg is None:
            if self.active_session:
                retmsg = self.active_session.outgoing_messages
        if retmsg is not None:
            retmsg.append(["PLAYER_CACHE_UPDATE", [gamesite.gameapi.get_player_cache_props(self, session.player, session.alliance_id_cache)]])
            retmsg.append(["PLAYER_UI_NAME_UPDATE", self.get_ui_name(session.player)])
            retmsg.append(["PLAYER_TRUST_LEVEL_UPDATE", self.get_trust_level()])

        # update portrait
        portrait_d = gamesite.player_portraits.update(server_time, self.user_id, {'ag_avatar_url':self.ag_avatar_url}, 'ag', 'ag'+str(self.ag_id), None)
        if session:
            session.portrait_update_launched(portrait_d)

    def retrieve_ag_friends_start(self, session, offset = 0, previous_results = None):
        limit = 1
        gamesite.AsyncHTTP_ArmorGames.queue_request(server_time,
                                                    'https://services.armorgames.com/services/rest/v1/friends/%s.json?api_key=%s&limit=%d&offset=%d' % (self.ag_id, SpinConfig.config['armorgames_api_key'], limit, offset),
                                                    lambda result, _session=session, _previous_results=previous_results, _offset=offset, _limit=limit: self.retrieve_ag_friends_complete(_session, None, result, _previous_results, _offset, _limit))

    def retrieve_ag_friends_complete(self, session, retmsg, result, previous_results = None, previous_offset = None, limit = None):
        data = SpinJSON.loads(result)
        assert data['code'] == 200
        payload = data['payload']
        if previous_results is None:
            previous_results = payload
        else:
            previous_results += payload

        if limit and len(payload) >= limit: # query again
            self.retrieve_ag_friends_start(session, offset = previous_offset + limit, previous_results = previous_results)
            return

        # only include friends who play the game
        self.ag_friend_ids = [str(friend['uid']) for friend in previous_results if int(friend['plays_game'])]
        if retmsg is None:
            if self.active_session:
                retmsg = self.active_session.outgoing_messages
        if retmsg is not None:
            self.populate_friends_who_play(session)

    def ping_fbpayments(self, session, retmsg, request_ids):
        # batch this?
        for request_id in request_ids:
            self.ping_fbpayment(session, retmsg, request_id)

    def ping_fbpayment(self, session, retmsg, request_id, signed_request = None):
        # try to finalize the status of one inflight payment
        payment_data = session.player.fbpayments_inflight.get(request_id, None)
        if not payment_data: return
        simulate_purchase = payment_data.get('simulate_purchase',False)

        if simulate_purchase:
            self.ping_fbpayment_complete(None, session, retmsg, request_id, {'data':[{'request_id':request_id,
                                                                                      'id': '0-simulated-%s' % generate_mail_id(),
                                                                                      'items':[{'quantity':payment_data['init_quantity'],
                                                                                                'product': payment_data['product_url']}],
                                                                                      'payout_foreign_exchange_rate': 1,
                                                                                      'tax': 'tax_remitted',
                                                                                      'tax_country': session.user.country,
                                                                                      'actions':[{'type':'charge','status':'completed',
                                                                                                  'currency':payment_data['client_currency'],
                                                                                                  'amount':'%.2f' % (1.0*payment_data['client_price'] + 0.005), # use <1.0 to simulate the odd tax fail purchases
                                                                                                  'tax_amount':'%.2f' % (0.2*payment_data['client_price'])
                                                                                                  }]
                                                                                      }]})
            return
        elif 0 and signed_request:
            # short-circuit path XXX - this can't work reliably, because we don't get the exchange rate/currency/amount data :(
            request_data = SpinFacebook.parse_signed_request(signed_request, SpinConfig.config['facebook_app_secret'])
            if not request_data: raise Exception('bad signature: checksum verification failed')
            if gamedata['server']['log_fbpayments'] >= 2:
                gamesite.exception_log.event(server_time, 'ping_fbpayment user %d request_id %s signed_request %s' % (session.player.user_id, request_id, repr(request_data)))
            assert request_data['request_id'] == request_id
            # call the callback synchronously
            self.ping_fbpayment_complete(None, session, retmsg, request_id, {'data':[{'request_id':request_id,
                                                                                      'items':[{'quantity':request_data['quantity']}],
                                                                                      'actions':[{'type':'charge','status':request_data['status']}]
                                                                                      }]})
            return

        if not SpinConfig.config['enable_facebook']: return

        url = SpinFacebook.versioned_graph_endpoint_secure('payment', str(self.facebook_id)+'/payment_transactions') + '&' + \
              urllib.urlencode({'request_id':request_id, 'fields':SpinFacebook.PAYMENT_FIELDS})

        if gamedata['server']['log_fbpayments'] >= 2:
            gamesite.exception_log.event(server_time, 'ping_fbpayment user %d request_id %s SEND %s' % (session.player.user_id, request_id, url))

        d = make_deferred('ping_fbpayment_complete') # OK - installed into session by caller
        gamesite.AsyncHTTP_Facebook.queue_request(server_time, url, functools.partial(self.ping_fbpayment_complete, d, session, retmsg, request_id), max_tries = 4)
        return d # hold request async until the poll completes

    # return the spellname, spellarg that corresponds to an FB payment on the Open Graph object "url" with quantity "item_quantity"
    def parse_fbpayment_product_url(self, url, item_quantity):
        qs = urlparse.parse_qs(urlparse.urlparse(str(url)).query)
        # look for a SKU slate order
        if ('type' in qs) and (qs['type'][-1] == OGPAPI.object_type('sku')):
            spellname = qs['spellname'][-1]
            spellarg = None
        # look for an order that buys in-game currency directly on the OG currency object, like a payer promo
        elif ('type' in qs) and (qs['type'][-1] == OGPAPI.object_type('gamebucks')):
            spellname = 'FB_GAMEBUCKS_PAYMENT'
            spellarg = int(item_quantity)
        else:
            raise Exception('cannot parse product URL %s qty %d' % (url, item_quantity))
        return spellname, spellarg

    # return the quantity of gamebucks given by this spellname/spellarg pair
    def parse_buy_gamebucks_spell_quantity(self, spellname, spellarg):
        if spellname == 'FB_GAMEBUCKS_PAYMENT':
            assert spellarg > 0
            return spellarg
        elif spellname.startswith('BUY_GAMEBUCKS_') and spellname in gamedata['spells']:
            return gamedata['spells'][spellname]['quantity']
        elif spellname.startswith('BUY_GAMEBUCKS_'):
            return int(spellname.split('_')[2])
        else:
            raise Exception('cannot parse spellname %s spellarg %s' % (spellname, repr(spellarg)))

    # find the spellname, spellarg for a BUY_GAMEBUCKS spell applicable to the player with this currency and amount
    # used to reconstruct the source spell when we lost it during the payments flow
    def find_buy_gamebucks_spell(self, session, real_currency, real_currency_amount, gamebucks_amount):
        for spellname, spell in gamedata['spells'].iteritems():
            if spell.get('quantity',-1) == gamebucks_amount and \
               spell.get('currency') == real_currency and \
               spellname.startswith('BUY_GAMEBUCKS') and \
               spell.get('price_formula') == 'constant':
                match = True
                for PRED in ('show_if','requires'):
                    if PRED in spell and (not Predicates.read_predicate(spell[PRED]).is_satisfied2(session, session.player, None)):
                        match = False; break
                if not match: continue

                # check price equivalence approximately
                if round(spell['price'], 2) != round(real_currency_amount, 2): continue

                return spellname, None # match found!
        gamesite.exception_log.event(server_time, 'player %d find_buy_gamebucks_spell failed for %s %r %d' % (session.user.user_id, real_currency, real_currency_amount, gamebucks_amount))
        return None, None

    # ping an already-completed FB payment to check for chargebacks
    def ping_fbpayment_check_refund(self, session, retmsg, payment_id, result):
        entry = None
        for ent in session.player.history.get('money_purchase_history',[]):
            if ('payment_id' in ent) and str(ent['payment_id']) == str(payment_id):
                entry = ent
                break
        if not entry: return False # never completed

        result = SpinJSON.loads(result) if type(result) is not dict else result
        if len(result['data']) < 1: return False
        payment = result['data'][0]

        refund = False
        refund_type = 'unknown'
        refund_time_string = None
        paid_time_string = None
        paid_amount = 0
        tax_amount = 0
        user_facing_amount = 0
        paid_currency = 'unknown'
        refund_amount = 0
        refund_tax_amount = 0
        refund_currency = 'unknown'
        new_mail = False

        for action in payment['actions']:
            if action['type'] == 'charge' and action['status'] == 'completed':
                paid_time_string = action.get('time_updated', None)
                paid_amount = round(float(action['amount']), 2) # preserve 2 decimal places
                if 'tax_amount' in action and payment.get('tax',None) == 'tax_remitted':
                    tax_amount = round(float(action['tax_amount']), 2)
                    #user_facing_amount = paid_amount + tax_amount
                user_facing_amount = paid_amount
                paid_currency = action['currency']
            if action['type'] in ('chargeback','refund','decline') and action['status'] == 'completed':
                refund = True
                refund_type = action['type']
                refund_time_string = action['time_updated']
                refund_amount = float(action['amount'])
                if 'tax_amount' in action and payment.get('tax',None) == 'tax_remitted':
                    refund_tax_amount = float(action['tax_amount'])
                refund_currency = action['currency']
            elif action['type'] == 'chargeback_reversal' and action['status'] == 'completed':
                refund = False
                gamesite.exception_log.event(server_time, 'ping_fbpayment_post_complete player %d chargeback_reversal payment_id %s' % (session.user.user_id, str(payment_id)))
            elif action['status'] in ('initiated', 'processing'):
                # need to poll again later
                return False
        if refund:
            if entry.get('refunded',0): return False # already refunded
            try:
                usd_equivalent = 0.01*int(100*float(payment['payout_foreign_exchange_rate']) * refund_amount * 0.7 + 0.5) # post FB tax
                item = payment['items'][0]
                spellname, spellarg = self.parse_fbpayment_product_url(item['product'], item['quantity'])
                gamebucks = self.parse_buy_gamebucks_spell_quantity(spellname, spellarg)
                gift_order = entry.get('gift_order', None)
                try:
                    time_struct = time.gmtime(SpinFacebook.parse_fb_time(paid_time_string or refund_time_string))
                except: # don't halt just because time string is unparseable
                    time_struct = time.gmtime(server_time)

                if gamedata['store'].get('enable_refunds', True):
                    gift_refund = 0
                    if gift_order and (gamedata['store'].get('refund_gift_order_from','recipient') == 'recipient'):
                        gift_refund += self.refund_gift_order(session, retmsg, time_struct, str(payment_id), gift_order)
                    if gamebucks > gift_refund:
                        # refund any excess
                        self.refund_gamebucks(session, retmsg, gamebucks - gift_refund, time_struct, str(payment_id), refund_type)
                    entry['refunded'] = 1
                    entry['refunded_at'] = server_time

                    session.increment_player_metric('money_refunded', usd_equivalent)
                    session.increment_player_metric('gamebucks_refunded', gamebucks)

                    gamesite.credits_log.event(server_time, {'user_id':session.user.user_id,
                                                             'summary': session.player.get_denormalized_summary_props('brief'),
                                                             'country_tier': session.player.country_tier,
                                                             'event_name':'1310_order_refunded',
                                                             'code':1310,
                                                             'Billing Amount': usd_equivalent,
                                                             'currency': paid_currency,
                                                             'currency_amount': user_facing_amount,
                                                             'tax_amount': tax_amount,
                                                             'refund_tax_amount': refund_tax_amount,
                                                             'tax_country': payment.get('tax_country',None),
                                                             'country': session.user.country,
                                                             'payout_foreign_exchange_rate':payment.get('payout_foreign_exchange_rate',-1),
                                                             'quantity': item['quantity'],
                                                             'product': item['product'],
                                                             'request_id': payment.get('request_id',None),
                                                             'payment_id': payment['id'],
                                                             'gift_order': gift_order})
                    new_mail = True
                    dry_run = ''
                else:
                    dry_run = '(dry run) '

                gamesite.exception_log.event(server_time, '%sREFUND (%s) payment %s player %d amount %d gamebucks (balance %d) paid_amount %r (incl. %r tax) paid_currency %s refund_amount %f refund_currency %s gift_order %s' % \
                                             (dry_run, refund_type, str(payment['id']), session.player.user_id, gamebucks, session.player.resources.gamebucks,
                                              paid_amount, tax_amount, paid_currency, refund_amount, refund_currency, repr(gift_order)))

            except:
                gamesite.exception_log.event(server_time, ('ping_fbpayment_post_complete player %d payment_id %s error: ' % (session.user.user_id, str(payment_id)))+traceback.format_exc().strip()) # OK
                pass
        return new_mail

    def refund_gift_order(self, session, retmsg, time_struct, payment_id, gift_order):
        refunded = 0
        original_gift_order = copy.deepcopy(gift_order)
        for gift in gift_order['gifts']:
            if not gift.get('success',False): continue # gift was never sent
            amount = gift['gamebucks']
            gamesite.msg_client.msg_send([session.player.make_system_mail(gamedata['strings']['gift_order_refund_mail'],
                                                                          to_user_id = gift['recipient_user_id'],
                                                                          extra_props = {'gift_order_refund':original_gift_order, 'gamebucks': amount},
                                                                          replacements = {'%SENDER': session.user.get_chat_name(session.player),
                                                                                          '%PAYMENT_ID': payment_id,
                                                                                          '%QUANTITY': str(amount),
                                                                                          '%GAMEBUCKS_NAME': gamedata['store']['gamebucks_ui_name'],
                                                                                          '%DAY': time.strftime('%d %b %Y', time_struct),
                                                                                          '%TIME': time.strftime('%H:%S', time_struct)})])
            session.increment_player_metric('gift_orders_refunded', 1)
            gift['refunded'] = 1
            gift['refunded_at'] = server_time
            refunded += amount
        return refunded

    def refund_gamebucks(self, session, retmsg, gamebucks, time_struct, payment_id, refund_type):
        session.player.resources.gain_gamebucks(-gamebucks, reason='payment_refund')
        gamedata_strings = gamesite.get_localized_gamedata('strings', self.locale)
        template = gamedata_strings.get('gamebucks_refund_mail_'+refund_type, gamedata_strings['gamebucks_refund_mail'])
        session.player.mailbox_append(session.player.make_system_mail(template,
                                                                      replacements = {'%PAYMENT_ID': payment_id,
                                                                                      '%QUANTITY': str(gamebucks),
                                                                                      '%GAMEBUCKS_NAME': gamedata['store']['gamebucks_ui_name'],
                                                                                      '%DAY': time.strftime('%d %b %Y', time_struct),
                                                                                      '%TIME': time.strftime('%H:%S', time_struct)}))
        if retmsg is not None: session.player.send_mailbox_update(retmsg)

    def ping_fbpayment_complete(self, d, session, retmsg, request_id, result):
        # note: payment may have been completed asynchronously, look up the request again here and exit if not found in in-flight
        payment_data = session.player.fbpayments_inflight.get(request_id, None)
        if payment_data:
            if gamedata['server']['log_fbpayments'] >= 2:
                gamesite.exception_log.event(server_time, 'ping_fbpayment user %d request_id %s GOT %s' % (session.player.user_id, request_id, result))

            # handles both sync (dict) and async (JSON string) paths
            result = SpinJSON.loads(result) if type(result) is not dict else result
            paid = False
            paid_amount = None
            tax_amount = 0
            user_facing_amount = None

            completed = True
            if len(result['data']) > 0:
                payment = result['data'][0]
                payment_id = payment['id']
                if 'request_id' in payment: # Gift Card orders can come without request_ids
                    assert (payment['request_id'] == request_id)

                # do allow Facebook "test" payment for developers on live server, because they might be Credits Testers flow test payments
                assert (not payment.get('test',False)) or (session.player.is_developer() or (not spin_secure_mode))

                item = payment['items'][0]
                assert int(item['quantity']) == 1 or (payment_data['spellname'] == 'FB_GAMEBUCKS_PAYMENT')

                for action in payment['actions']:
                    if action['type'] == 'charge' and action['status'] == 'completed':
                        paid = True
                        paid_amount = round(float(action['amount']), 2) # preserve 2 decimal places
                        paid_currency = action['currency']
                        if 'tax_amount' in action and payment.get('tax',None) == 'tax_remitted':
                            tax_amount = round(float(action['tax_amount']), 2)
                            #user_facing_amount = round(paid_amount + tax_amount, 2)
                        user_facing_amount = paid_amount
                    elif action['type'] in ('chargeback','refund','decline') and action['status'] == 'completed':
                        paid = False
                    elif action['type'] == 'chargeback_reversal' and action['status'] == 'completed':
                        paid = True
                    elif action['status'] in ('initiated', 'processing'):
                        completed = False # need to poll again later
                        break
            else:
                # result['data'] is empty. If this is a very RECENT
                # payment, do nothing right now, and wait for the
                # webhook callback. (Facebook has started returning blank
                # data for payments for a few seconds after the client
                # completes them!)
                if payment_data.get('time',-1) >= server_time - 60:
                    completed = False
                    if gamedata['server']['log_fbpayments'] >= 2:
                        gamesite.exception_log.event(server_time, 'ping_fbpayment user %d request_id %s empty response on a recent payment, doing nothing' % (session.player.user_id, request_id))
                    else:
                        gamesite.facebook_log.event(server_time, 'ping_fbpayment user %d request_id %s empty response on a recent payment, doing nothing' % (session.player.user_id, request_id))


            # note: if result['data'] is empty for an OLD payment, then drop the inflight request without executing the order
            if completed:
                del session.player.fbpayments_inflight[request_id]
                if paid:
                    # okay to give the stuff now!

                    try:
                        # note: estimate post FB tax order receipts, in USD. This is what will appear in metrics as the receipts amount.
                        # XXX is tax_amount taken before or after the 30% cut?
                        usd_equivalent = 0.01*int(100*float(payment['payout_foreign_exchange_rate']) * (paid_amount * 0.7 - tax_amount) + 0.5)
                        price_description, detail_props = \
                                           Store.execute_order(gamesite.gameapi, session, retmsg, 'fbpayments:'+paid_currency, user_facing_amount,
                                                               payment_data['unit_id'],
                                                               payment_data['spellname'],
                                                               payment_data['spellarg'],
                                                               payment_data['server_time_according_to_client'],
                                                               usd_equivalent = usd_equivalent,
                                                               gift_order = payment_data.get('gift_order',None),
                                                               payment_id = payment_id,
                                                               override_time = payment_data.get('time',server_time))

                        descr = Store.get_description(session, payment_data['unit_id'], payment_data['spellname'], payment_data['spellarg'], price_description)

                        admin_stats.add_revenue(session.user.user_id, usd_equivalent, descr)

                        metric_event_coded(session.user.user_id, '1000_billed', {'Billing Amount': usd_equivalent,
                                                                                 'Billing Description': descr,
                                                                                 'country_tier': session.player.country_tier,
                                                                                 'last_purchase_time': session.player.history.get('last_purchase_time',-1),
                                                                                 'prev_largest_purchase': session.player.history.get('largest_purchase',0),
                                                                                 'num_purchases': session.player.history.get('num_purchases',0),
                                                                                 'currency': paid_currency,
                                                                                 'currency_amount': user_facing_amount,
                                                                                 'tax_amount': tax_amount,
                                                                                 'tax_country': payment.get('tax_country',None),
                                                                                 'payout_foreign_exchange_rate':payment.get('payout_foreign_exchange_rate',-1),
                                                                                 'quantity': item['quantity'],
                                                                                 'product': item['product'],
                                                                                 'request_id': request_id,
                                                                                 'payment_id': payment['id'],
                                                                                 'gift_order': payment_data.get('gift_order',None)})

                        gamesite.credits_log.event(server_time, {'user_id':session.user.user_id,
                                                                 'event_name':'1000_billed',
                                                                 'code':1000,
                                                                 'Billing Amount': usd_equivalent,
                                                                 'Billing Description': descr,
                                                                 'summary': session.player.get_denormalized_summary_props('brief'),
                                                                 'country_tier': session.player.country_tier,
                                                                 'last_purchase_time': session.player.history.get('last_purchase_time',-1),
                                                                 'prev_largest_purchase': session.player.history.get('largest_purchase',0),
                                                                 'num_purchases': session.player.history.get('num_purchases',0),
                                                                 'currency': paid_currency,
                                                                 'currency_amount': user_facing_amount,
                                                                 'tax_amount': tax_amount,
                                                                 'tax_country': payment.get('tax_country',None),
                                                                 'country': session.user.country,
                                                                 'payout_foreign_exchange_rate':payment.get('payout_foreign_exchange_rate',-1),
                                                                 'quantity': item['quantity'],
                                                                 'product': item['product'],
                                                                 'request_id': request_id,
                                                                 'payment_id': payment['id'],
                                                                 'gift_order': payment_data.get('gift_order',None)})

                        session.activity_classifier.spent_money(usd_equivalent, descr)

                        if session.player.history.get('money_spent', 0) == 0:
                            session.player.history['time_of_first_purchase'] = server_time

                        if session.user.account_creation_time > 0:
                            daynum = int((server_time - session.user.account_creation_time)/(60*60*24))
                            if 'money_spent_by_day' not in session.player.history:
                                session.player.history['money_spent_by_day'] = {}
                            dict_increment(session.player.history['money_spent_by_day'], str(daynum), usd_equivalent)
                        dict_setmax(session.player.history, 'last_purchase_time', server_time)

                        # new-style player metrics (redundant with old style above)
                        session.increment_player_metric('money_spent', usd_equivalent)
                        session.increment_player_metric('num_purchases', 1)
                        session.setmax_player_metric('largest_purchase', usd_equivalent)

                        if 'money_purchase_history' not in session.player.history:
                            session.player.history['money_purchase_history'] = []

                        session.player.history['money_purchase_history'].append({'time': server_time,
                                                                                 'age': -1 if session.player.creation_time < 0 else (server_time - session.player.creation_time),
                                                                                 'dollar_amount': usd_equivalent,
                                                                                 'currency': paid_currency,
                                                                                 'currency_amount': user_facing_amount,
                                                                                 'tax_amount': tax_amount,
                                                                                 'tax_country': payment.get('tax_country',None),
                                                                                 'payout_foreign_exchange_rate':payment.get('payout_foreign_exchange_rate',-1),
                                                                                 'quantity': item['quantity'],
                                                                                 'product': item['product'],
                                                                                 'request_id': request_id,
                                                                                 'payment_id': payment['id'],
                                                                                 'gift_order': payment_data.get('gift_order',None),
                                                                                 'spellname': str(payment_data['spellname']), 'spellarg': repr(payment_data['spellarg']),
                                                                                 'description': descr})

                        session.send_adnetwork_purchase_event(retmsg, payment['id'], usd_equivalent)
                        session.send_adnetwork_events(retmsg)

                        # update client's version of spend metrics
                        session.player.send_history_update(retmsg)


                    except:
                        gamesite.exception_log.event(server_time, 'FBPAYMENT_ORDER Exception:\n'+''.join(traceback.format_stack()[-5:-1])+traceback.format_exc().strip()) # OK
                        retmsg.append(["ERROR", "ORDER_PROCESSING"])

                        # write the bad fbpayment data to a file for debugging
                        if gamedata['server']['log_fbpayments'] >= 1:
                            tm = time.gmtime(server_time)
                            with open('/tmp/%04d%02d%02d-fbpayment-%s.json' % (tm.tm_year, tm.tm_mon, tm.tm_mday, payment_id), 'w') as fd:
                                SpinJSON.dump(result, fd, pretty=True, newline=True)

                        # XXX refund?

                    # note: send AFTER executing spell, so that player state is already updated
                    if 'tag' in payment_data:
                        retmsg.append(["FBPAYMENT_ORDER_ACK", payment_data['tag'], True])
                        session.queue_flush_outgoing_messages()

        # fire deferred completion
        if d: d.callback(True)

    def retrieve_facebook_credit_info_start(self):
        if self.credit_info_request_outstanding:
            return
        if not SpinConfig.config['enable_facebook']:
            return

        # Note: as of FB API v2.1, fql is no longer supported, so this won't work.
        # This code is kept here for historical reference only.
        # Do not re-enable the facebook credit balance/gamer_status query.

        if not gamedata['server']['enable_facebook_credit_balance_query']:
            return
        if not SpinConfig.config.has_key('facebook_app_access_token'):
            gamesite.exception_log.event(server_time, 'config.json is missing facebook_app_access_token!')
            return
        query = 'SELECT credit_balance,gamer_status'
        query += ' FROM standard_user_info WHERE uid = '+self.facebook_id
        query_tok = urllib.urlencode(dict(query = query, access_token = SpinConfig.config['facebook_app_access_token']))
        request_url = 'https://api.facebook.com/method/fql.query?'+query_tok

        self.credit_info_request_outstanding = True

        def on_success(result):
            self.credit_info_request_outstanding = False
            self.retrieve_facebook_credit_info_complete(result)

        def on_error(reason):
            self.credit_info_request_outstanding = False

        gamesite.AsyncHTTP_Facebook.queue_request(server_time, request_url, on_success, error_callback = on_error)

    @inlineCallbacks
    def verify_ms_store_receipt_async(self, session, retmsg, receipts_xml, server_tag, microsoft_outcome):
        if 'ms_store_purchase_history' not in session.player.history: session.player.history['ms_store_purchase_history'] = []

        # Pull the certificate we need to verify the receipt XML.
        # This involves an async HTTP request.
        ms_cert_url = SpinMSReceiptParser.validate_receipt_request_url(receipts_xml)
        cert = yield gamesite.AsyncHTTP_Microsoft.queue_request_deferred(server_time, ms_cert_url)

        # Try to validate and parse the receipt XML
        try:
            if 'microsoft_exchange_rates' not in gamedata['store']:
                raise Exception('Cannot process microsoft receipt because microsoft_exchange_rates is not set in store.json')
            ms_receipts = SpinMSReceiptParser.validate_receipt_response(receipts_xml, cert, gamedata['store']['microsoft_exchange_rates'])
        except:
            # if there is an error verifying or parsing the receipt(s), stop and report the error now. Do not send acknowledgement (?).
            gamesite.exception_log.event(server_time, 'Exception Microsoft receipt: %r could not be verified with certificate: %s' % (receipts_xml, traceback.format_exc().strip()))
            returnValue(False)

        for receipt in ms_receipts:
            # execute the order, if possible
            self.verify_ms_store_receipt_one(session, retmsg, receipt)

            # report SKU as fulfilled
            retmsg.append(["REPORT_MS_SKU_FULFILLED", receipt['spellname'], receipt['purchase_id']])

        if server_tag != 'mso_null' and microsoft_outcome == 'send_server_ack':
            retmsg.append(["MSSTORE_ORDER_ACK", server_tag, True])

        returnValue(True)

    def verify_ms_store_receipt_one(self, session, retmsg, receipt):
        purchase_id = receipt['purchase_id']

        # skip purchase if it was already processed
        if any(old_purchase['purchase_id'] == purchase_id for old_purchase in session.player.history['ms_store_purchase_history']):
            return

        new_purchase = {
            'time': server_time,
            'purchase_id': purchase_id,
            'age': -1 if session.player.creation_time < 0 else (server_time - session.player.creation_time),
            }
        session.player.history['ms_store_purchase_history'].append(new_purchase) # add to history so it isn't double-processed

        spell = gamedata['spells'].get(receipt['spellname'])
        if not spell:
            gamesite.exception_log.event(server_time, 'Exception Microsoft order %s: cannot identify SKU spell %s. Player will receive no gamebucks. A CS ticket should be opened ASAP.' % (purchase_id, receipt['spellname']))
            new_purchase['force_fulfilled'] = 1
            return # skip any further processing of this receipt. Do acknowledge it and leave it in history['ms_store_purchase_history'].

        gamebucks_amount = spell.get('quantity', 0)
        if gamebucks_amount == 0:
            gamesite.exception_log.event(server_time, 'Exception Microsoft order %s: spell %s has no quantity value. Defaulting to 0, player will receive no gamebucks. A CS ticket should be opened ASAP.' % (purchase_id, receipt['spellname']))
            new_purchase['force_fulfilled'] = 1
            return # skip any further processing of this receipt. Do acknowledge it and leave it in history['ms_store_purchase_history'].

        new_purchase['gamebucks_amount'] = gamebucks_amount
        new_purchase['gamebucks_balance'] = session.player.resources.gamebucks + gamebucks_amount
        assert (not session.logout_in_progress)
        spellarg = None # Microsoft payments
        spellname = receipt['spellname']
        unit_id = GameObject.VIRTUAL_ID
        currency = receipt['currency'] # e.g. "GBP"
        currency_amount = receipt['price'] # floating-point price in local currency e.g. 9.99
        dollar_amount = receipt['dollar_amount']
        if currency != "USD":
            # SpinMSReceiptParser.py calculates the USD amount based on exchange rates set in store.json
            # This does a sanity check on the actual exchange rate given by Microsoft and notes anything that
            # exceeds a deviation threshold set in store.json (defaults to +- 10%)
            expected_dollar_amount = gamedata['spells'][spellname]['price']
            exchange_rate_deviation = dollar_amount / expected_dollar_amount
            allowed_deviation = gamedata['store'].get("microsoft_exchange_deviation_threshold", 0.10)
            last_exchange_rate_date = gamedata['store'].get("microsoft_exchange_date", 'date not set')
            if exchange_rate_deviation > 1 + allowed_deviation or exchange_rate_deviation < 1 - allowed_deviation:
                gamesite.exception_log.event(server_time, 'Exception Microsoft order %s: receipt price %s currency %s exchange rate exceeded allowed threshold of %s set on %s. store.json may need to be updated with new exchange rates to keep our USD receipts accurate.' % (purchase_id, receipt['price'], currency, str(allowed_deviation), str(last_exchange_rate_date)))

        # Microsoft store returns the local currency regardless of what we set for the price, so
        # this forces Store.execute_order to accept payment by feeding it the price straight from gamedata
        execute_order_currency = "microsoft:USD"
        execute_order_currency_amount = gamedata['spells'][spellname]['price']
        execute_order_dollar_amount = execute_order_currency_amount

        try:
            price_description, detail_props = Store.execute_order(gamesite.gameapi, session, retmsg,
                                                                  execute_order_currency, execute_order_currency_amount,
                                                                  unit_id, spellname, spellarg,
                                                                  new_purchase['time'],
                                                                  usd_equivalent = execute_order_dollar_amount)
        except:
            gamesite.exception_log.event(server_time, 'Exception Microsoft order %s: Store.execute_order failed. Player will receive no gamebucks. A CS ticket should be opened ASAP. %s' % (purchase_id, traceback.format_exc().strip()))
            new_purchase['force_fulfilled'] = 1
            return # skip any further processing of this receipt

        descr = Store.get_description(session, unit_id, spellname, spellarg, price_description)
        admin_stats.add_revenue(session.user.user_id, dollar_amount, descr)

        metric_event_coded(session.user.user_id, '1000_billed', {'Billing Amount': dollar_amount,
                                                                 'Billing Description': descr,
                                                                 'currency': currency,
                                                                 'currency_amount': currency_amount,
                                                                 'country_tier': session.player.country_tier,
                                                                 'last_purchase_time': session.player.history.get('last_purchase_time',-1),
                                                                 'prev_largest_purchase': session.player.history.get('largest_purchase',0),
                                                                 'num_purchases': session.player.history.get('num_purchases',0),
                                                                 'order_id': purchase_id})

        gamesite.credits_log.event(server_time, {'user_id':session.user.user_id,
                                                 'event_name':'1000_billed',
                                                 'code':1000,
                                                 'Billing Amount': dollar_amount,
                                                 'Billing Description': descr,
                                                 'currency': currency,
                                                 'currency_amount': currency_amount,
                                                 'summary': session.player.get_denormalized_summary_props('brief'),
                                                 'country_tier': session.player.country_tier,
                                                 'country': session.user.country,
                                                 'last_purchase_time': session.player.history.get('last_purchase_time',-1),
                                                 'prev_largest_purchase': session.player.history.get('largest_purchase',0),
                                                 'num_purchases': session.player.history.get('num_purchases',0),
                                                 'order_id': purchase_id})

        session.activity_classifier.spent_money(dollar_amount, descr)

        if session.player.history.get('money_spent', 0) == 0:
            session.player.history['time_of_first_purchase'] = server_time

        if session.user.account_creation_time > 0:
            daynum = int((server_time - session.user.account_creation_time)/(60*60*24))
            if 'money_spent_by_day' not in session.player.history:
                session.player.history['money_spent_by_day'] = {}
            dict_increment(session.player.history['money_spent_by_day'], str(daynum), dollar_amount)
        dict_setmax(session.player.history, 'last_purchase_time', server_time)

        # new-style player metrics (redundant with old style above)
        session.increment_player_metric('money_spent', dollar_amount)
        session.increment_player_metric('num_purchases', 1)
        session.setmax_player_metric('largest_purchase', dollar_amount)

        if 'money_purchase_history' not in session.player.history:
            session.player.history['money_purchase_history'] = []

        session.player.history['money_purchase_history'].append({'time': server_time,
                                                                 'age': -1 if session.player.creation_time < 0 else (server_time - session.player.creation_time),
                                                                 'dollar_amount': dollar_amount,
                                                                 'currency_amount': currency_amount,
                                                                 'currency': currency,
                                                                 'order_id': purchase_id,
                                                                 'description': descr})

    @admin_stats.measure_latency('retrieve_facebook_credit_info_complete')
    def retrieve_facebook_credit_info_complete(self, result):
        dom = xml.dom.minidom.parseString(result)
        try:
            self.fb_gamer_status = int(dom.getElementsByTagName('gamer_status')[0].childNodes[0].data)
        except:
            pass # self.fb_gamer_status = -1

        try:
            self.fb_credit_balance = int(dom.getElementsByTagName('credit_balance')[0].childNodes[0].data)
        except:
            pass # self.fb_credit_balance = -1

        if self.fb_credit_balance != -1:
            # update the credit balance for any active sessions
            if self.active_session:
                self.active_session.player.resources.facebook_credits = self.fb_credit_balance
                self.active_session.deferred_player_state_update = True
                self.active_session.queue_flush_outgoing_messages()

        #print 'obtained gamer_status',self.fb_gamer_status,'credit_balance',self.fb_credit_balance,'for user',self.user_id,'fbid',self.facebook_id

    # retrieve friend invites and gifts from other Facebookers
    def retrieve_facebook_requests_start(self):
        if not SpinConfig.config['enable_facebook']:
            return
        self.retrieve_facebook_requests_start_v2() # new /apprequests method

    def retrieve_facebook_requests_start_v2(self):
        request_url = SpinFacebook.versioned_graph_endpoint_secure('apprequests', '%s/apprequests' % self.facebook_id)
        gamesite.AsyncHTTP_Facebook.queue_request(server_time, request_url, lambda result: self.retrieve_facebook_requests_paged_v2(result))

    def retrieve_facebook_requests_paged_v2(self, result, buffer = None):
        if buffer is None:
            buffer = []

        result = SpinJSON.loads(result)

        if result:
            buffer += result['data']

        if result and ('paging' in result) and ('next' in result['paging']) and \
           (('count' not in result) or (len(buffer) < int(result['count']))):
            # fetch next page
            gamesite.AsyncHTTP_Facebook.queue_request(server_time, result['paging']['next'],
                                                      lambda result: self.retrieve_facebook_requests_paged_v2(result, buffer = buffer))
        else:
            # it's complete now
            self.retrieve_facebook_requests_complete_v2(buffer)

    def retrieve_facebook_requests_complete_v2(self, request_list):
        to_delete = [] # list of request IDs to delete

        for req in request_list:
            if gamedata['server'].get('log_fb_apprequests',0) >= 2:
                gamesite.exception_log.event(server_time, 'player %s got FB apprequest %s' % (self.user_id, repr(req)))
            my_data = req.get('data', None)

            # dispatch to different types of requests based on my_data
            if my_data == 'friend_invite':
                sender_id = gamesite.social_id_table.social_id_to_spinpunch('fb'+req['from']['id'], False)
                if sender_id is None:
                    sender_id = -1

                props = {'sender_fb_id':req['from']['id'], 'sender_user_id': sender_id, 'facebook_request_id':req['id'].split('_')[0], 'created_time':req['created_time']}
                metric_event_coded(self.user_id, '7120_friend_invite_accepted', props.copy())

                # record acquisition event
                props['type'] = 'facebook_friend_invite'
                self.update_acquisition_data(props, important = True)

            elif my_data == 'gift':
                # reception of gifts is handled server-side upon login with dbclient gift_receive - the underlyting apprequest actually does nothing!
                pass
            elif my_data is None:
                # this is a "naked" Facebook request that's just a text message
                pass
            else:
                gamesite.exception_log.event(server_time, 'player %d received unhandled Facebook apprequest %s' % (self.user_id, repr(req)))

            # tell Facebook to delete the request (even unhandled ones)
            to_delete.append(req['id'])

        if to_delete:
            if gamedata['server'].get('log_fb_apprequests',0) >= 2:
                gamesite.exception_log.event(server_time, 'player %s deleting %d FB apprequests' % (self.user_id, len(to_delete)))

            batch = [{'method':'DELETE', 'relative_url': str(id)} for id in to_delete]
            limit = 50 # facebook limits batches to 50
            batches = [batch[i:i+limit] for i in xrange(0, len(batch), limit)]
            for this_batch in batches:
                delete_url = SpinFacebook.versioned_graph_endpoint_secure('apprequests', '') + \
                             '&' + urllib.urlencode({'batch':SpinJSON.dumps(this_batch)})
                gamesite.AsyncHTTP_Facebook.queue_request(server_time, delete_url, lambda x: None, method = 'POST')

    @inlineCallbacks
    def retrieve_facebook_invitable_friends(self, session, tag, buffer = None, url = None):
        assert self.facebook_id
        if not SpinConfig.config['enable_facebook']:
            session.send([["FB_INVITABLE_FRIENDS_RESULT", tag, []]])
            return

        if buffer is None:
            buffer = []
        if url is None:
            url = SpinFacebook.versioned_graph_endpoint_secure('invitable_friends', str(self.facebook_id)+'/invitable_friends') + '&' + \
                  urllib.urlencode({'fields': 'name,id,picture', 'limit': '500'})

        result = yield gamesite.AsyncHTTP_Facebook.queue_request_deferred(server_time, url)
        result = SpinJSON.loads(result)
        if result:
            buffer += result['data']

        if result and ('paging' in result) and ('next' in result['paging']) and \
           (('count' not in result) or (len(buffer) < int(result['count']))):
            # fetch next page
            self.retrieve_facebook_invitable_friends(session, tag, buffer = buffer, url = result['paging']['next'])
        else:
            # it's complete now
            if session.logout_in_progress: return # dead session
            session.send([["FB_INVITABLE_FRIENDS_RESULT", tag, buffer]])

    def create_fb_open_graph_action(self, action, params):
        if not SpinConfig.config['enable_facebook']:
            gamesite.exception_log.event(server_time, 'Facebook disabled: create_fb_open_graph_action(%s, %s)' % (action, repr(params)))
            return

        if self.active_session and \
           self.active_session.player.get_any_abtest_value('enable_fb_open_graph', gamedata['enable_fb_open_graph']) and \
           ((not gamedata['fb_open_graph'].get('developer_only', False)) or self.is_developer()) and \
           ((not gamedata['fb_open_graph'].get('check_permissions', False)) or (self.active_session.player.facebook_permissions and \
                                                                                'publish_actions' in self.active_session.player.facebook_permissions)):
            config = gamedata['fb_open_graph'][action]
            if config['enable']:

                params = params.copy()
                params['ref'] = 'og_%s__%d' % (action, self.user_id)
                query = urllib.urlencode(params)
                url = SpinFacebook.versioned_graph_endpoint_secure('open_graph', self.facebook_id+'/'+SpinConfig.config['facebook_app_namespace']+':'+action)

                if gamedata['server']['log_fb_open_graph']:
                    gamesite.exception_log.event(server_time, 'create_fb_open_graph_action("%s", %s)' % (url, repr(params)))
                gamesite.AsyncHTTP_Facebook.queue_request(server_time, url, lambda result: None, method = 'POST', postdata = query)

    def create_fb_open_graph_action_building_upgrade(self, object):
        if gamedata['fb_open_graph']['upgrade_building']['enable'] and \
           (gamedata['fb_open_graph']['upgrade_building'].get('enable_'+object.spec.name,False) or \
            gamedata['fb_open_graph']['upgrade_building'].get('enable_all',False)):
            self.create_fb_open_graph_action('upgrade_building', {OGPAPI.object_type('spec_building'): OGPAPI_instance.get_object_endpoint({'type':OGPAPI.object_type('spec_building'),
                                                                                                                                            'spec': object.spec.name}),
                                                                  'level': object.level})
    def create_fb_open_graph_action_unlock_unit(self, spec_name):
         if gamedata['fb_open_graph']['unlock_unit']['enable'] and \
           (gamedata['fb_open_graph']['unlock_unit'].get('enable_'+spec_name,False) or \
            gamedata['fb_open_graph']['unlock_unit'].get('enable_all',False)):
             self.create_fb_open_graph_action('unlock_unit', {OGPAPI.object_type('spec_unit'): OGPAPI_instance.get_object_endpoint({'type':OGPAPI.object_type('spec_unit'),
                                                                                                                                    'spec': spec_name})
                                                              })

    # called on login to transmit some important like/not-like stus to the client immediately
    # note: we use stale data from the last session here
    def get_fb_likes_preload(self):
        likes = None
        if gamedata.get('fb_likes_preload') and \
           (self.facebook_likes is not None) and \
           (len(self.facebook_likes) >= 1):
            # note: some Facebook users have privacy settings on their Likes, such
            # that no data will ever be returned. In this case, return None instead of a dictionary.
            likes = dict((id, 0) for id in gamedata['fb_likes_preload'])
            for entry in self.facebook_likes:
                if entry['id'] in likes:
                    likes[entry['id']] = 1
        return likes

    # try to obtain the user's Facebook profile, friends and likes
    # this is cached in user_table; if the cache is empty or stale,
    # send asynchronous HTTP requests to Facebook to get the data

    def retrieve_facebook_info(self, session):
        if (self.facebook_profile is not None) and type(self.facebook_profile) == dict and len(self.facebook_profile) > 0 and \
           (self.facebook_friends is not None) and \
           (self.facebook_likes is not None) and \
           (self.facebook_currency is not None) and \
           (self.facebook_first_name is not None) and \
           (self.active_session.player.facebook_permissions is not None) and \
           ((server_time - self.fb_hit_time) < gamedata['server'].get('facebook_cache_lifetime', 14400)):
            # data is present in cache and fresh enough to use
            return

        self.retrieve_facebook_info_start(session)

    # launch the asynchronous HTTP requests to Facebook's servers
    def retrieve_facebook_info_start(self, session):
        #assert self.fb_oauth_token
        #session_tok = self.fb_oauth_token

        endpoint = str(self.facebook_id)

        # Facebook has been messing around with which of the app or user access tokens can be used to retrieve data.

        # Note, if using a user access token, then it is not possible to apply appsecret_proof verification
        # That option seems to be busted as of 2018.

        # note: when using app access token, Facebook has stopped sending: birthday, is_eligible_promo, email
        # and also the /friends endpoint returns nothing.

        PROFILE_FIELDS = 'id,birthday,email,name,first_name,last_name,gender,locale,timezone,third_party_id,currency,is_eligible_promo,permissions'

        # as of 20181108, Facebook doesn't return email here if you use the app_tok instead of the user's fb_oath_token
        if 'facebook_api_token_choice' in SpinConfig.config and SpinConfig.config['facebook_api_token_choice'].get('user') == 'user' and self.fb_oauth_token:
            profile_url = SpinFacebook.versioned_graph_endpoint('user', endpoint)+'?fields='+PROFILE_FIELDS+'&'+urllib.urlencode({'access_token': self.fb_oauth_token})
        else:
            profile_url = SpinFacebook.versioned_graph_endpoint_secure('user', endpoint)+'&fields='+PROFILE_FIELDS

        # as of 20180925, Facebook doesn't return any friends here if you use the app_tok instead of the user's fb_oauth_token
        if 'facebook_api_token_choice' in SpinConfig.config and SpinConfig.config['facebook_api_token_choice'].get('friend') == 'user' and self.fb_oauth_token:
            friends_url = SpinFacebook.versioned_graph_endpoint('friend', endpoint+'/friends')+'?limit=500&offset=0&' + urllib.urlencode({'access_token': self.fb_oauth_token})
        else:
            friends_url = SpinFacebook.versioned_graph_endpoint_secure('friend', endpoint+'/friends')+'&limit=500&offset=0'

        likes_url = SpinFacebook.versioned_graph_endpoint_secure('like', endpoint+'/likes')+'&limit=500&offset=0'

        # keep track of outstanding requests
        self.fb_retrieve_semaphore = set(['profile', 'friends', 'likes'])

        if not SpinConfig.config['enable_facebook']: # mock path
            reactor.callLater(2, functools.partial(self.retrieve_facebook_info_receive, session, 'profile', open("test-facebook-profile.txt").read())) # delay to expose timing bugs
            reactor.callLater(2, functools.partial(self.retrieve_facebook_info_receive_paged, session, 'friends', [], set(), open("test-facebook-friends.txt").read())) # delay to expose timing bugs
            reactor.callLater(2, functools.partial(self.retrieve_facebook_info_receive_paged, session, 'likes', [], set(), open("test-facebook-likes.txt").read())) # delay to expose timing bugs
        else:
            gamesite.AsyncHTTP_Facebook.queue_request(server_time, profile_url, functools.partial(self.retrieve_facebook_info_receive, session, 'profile'))
            gamesite.AsyncHTTP_Facebook.queue_request(server_time, friends_url, functools.partial(self.retrieve_facebook_info_receive_paged, session, 'friends', [], set(friends_url)))
            gamesite.AsyncHTTP_Facebook.queue_request(server_time, likes_url, functools.partial(self.retrieve_facebook_info_receive_paged, session, 'likes', [], set(likes_url)))

            # update portrait
            portrait_d = gamesite.player_portraits.update(server_time, self.user_id, {}, 'fb', 'fb'+str(self.facebook_id), self.fb_oauth_token)
            session.portrait_update_launched(portrait_d)

    def retrieve_facebook_info_receive_paged(self, session, dest, buffer, seen_set, raw_result):
        # note: On 2019 Apr 18, Facebook started sending us in infinite loops, by having the
        # result['paging']['next'] URL point back to a page we'd already seen.
        # Detect and break the cycle by tracking all URLs we've seen.

        result = SpinJSON.loads(raw_result)

        buffer += result['data']

        if ('paging' in result) and ('next' in result['paging']) and \
           (('count' not in result) or (len(buffer) < int(result['count']))) and \
           (result['paging']['next'] not in seen_set): # avoid infinite loop

            next_url = result['paging']['next']
            seen_set.add(next_url)

            # fetch next page
            gamesite.AsyncHTTP_Facebook.queue_request(server_time, next_url, functools.partial(self.retrieve_facebook_info_receive_paged, session, dest, buffer, seen_set))

        else:
            # it's complete now
            self.retrieve_facebook_info_receive(session, dest, None, result = buffer)

    def facebook_permissions_ok(self, wanted):
        if self.active_session.player.facebook_permissions is None: return False
        for perm in wanted.split(','):
            if perm not in self.active_session.player.facebook_permissions:
                return False
        return True

    # prune list of Facebook "Likes" to the ones we care enough about to store in User data
    def filter_facebook_likes(self, likes):
        ids_we_care_about = set(SpinConfig.FACEBOOK_GAME_FAN_PAGES.itervalues())
        if 'fb_likes_preload' in gamedata:
            ids_we_care_about.update(gamedata['fb_likes_preload'])
        return filter(lambda entry: entry['id'] in ids_we_care_about, likes)

    # this callback is called for each URL downloaded asynchronously
    @admin_stats.measure_latency('AsyncHTTP(facebook_profile/friends/likes)')
    def retrieve_facebook_info_receive(self, session, dest, raw_result, result = None):

        self.fb_retrieve_semaphore.remove(dest)
        if len(self.fb_retrieve_semaphore) == 0:
            # all complete (set this before any possible parsing errors to avoid getting "stuck")
            self.fb_hit_time = server_time

        if result is not None:
            pass # caller supplied pre-parsed result
        else:
            result = SpinJSON.loads(raw_result)

        if dest == 'friends':
            self.facebook_friends = result
            self.populate_friends_who_play(session)

        elif dest == 'likes':
            self.facebook_likes = self.filter_facebook_likes(result)
            session.player.user_facebook_likes = self.facebook_likes

        elif dest == 'profile':
            if type(result) == dict and len(result) > 0:
                self.facebook_profile = result

                # only check for promo on non-cached result
                if ('is_eligible_promo' in result) and bool(result['is_eligible_promo']) and \
                   session.player.get_any_abtest_value('enable_payer_promo', gamedata['enable_payer_promo']) and \
                   session.player.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks' and \
                   (server_time - session.player.last_payer_promo) >= gamedata['payer_promo_interval'] and \
                   session.player.tutorial_state == "COMPLETE" and \
                   session.player.history.get('logged_in_times',0) >= gamedata['payer_promo_min_logins']:
                    self.offer_payer_promo(session)

            else:
                gamesite.exception_log.event(server_time, ('Facebook sent bad profile data for user %d: ' % self.user_id)+repr(raw_result))
                # note: continue to use previous profile data

            # set safe defaults in case of failure
            self.facebook_currency = {'user_currency': 'Facebook Credits', 'currency_exchange': 1, 'currency_exchange_inverse': 1, 'currency_offset': 1}
            session.player.facebook_permissions = []

            # pull vital fields out of the cached facebook_profile
            if self.facebook_profile:
                if 'name' in self.facebook_profile:
                    self.facebook_name = self.facebook_profile['name']
                if 'first_name' in self.facebook_profile:
                    self.facebook_first_name = self.facebook_profile['first_name']
                else:
                    self.facebook_first_name = self.facebook_name.split(' ')[0]

                if 'birthday' in self.facebook_profile and len(self.facebook_profile['birthday'].split('/')) == 3:
                    # some Facebook profiles return a yearless birthday - ignore these
                    try:
                        m, d, y = map(int, self.facebook_profile['birthday'].split('/'))
                        self.birthday = SpinConfig.cal_to_unix((y,m,d))
                    except Exception:
                        gamesite.exception_log.event(server_time, 'could not parse player %d FB facebook_profile birthday "%s"' % (self.user_id, self.facebook_profile['birthday']))
                        pass
                if 'currency' in self.facebook_profile:
                    self.facebook_currency = self.facebook_profile['currency']
                if 'timezone' in self.facebook_profile and isinstance(self.facebook_profile['timezone'], int):
                    self.timezone = self.facebook_profile['timezone']
                if 'third_party_id' in self.facebook_profile:
                    self.facebook_third_party_id = self.facebook_profile['third_party_id']
                if ('permissions' in self.facebook_profile) and self.active_session and ('data' in self.facebook_profile['permissions']) and (len(self.facebook_profile['permissions']['data']) > 0):
                    def parse_facebook_permissions(data_list):
                        if 'permission' in data_list[0]: # current API
                            return [x['permission'] for x in data_list if x.get('status',None) == 'granted']
                        else: # legacy data
                            return [k for k,v in data_list[0].iteritems() if v]
                    session.player.facebook_permissions = parse_facebook_permissions(self.facebook_profile['permissions']['data'])
            else:
                self.facebook_name = '(Facebook API error)'
                self.facebook_first_name = 'Unknown(fbapierr)'

            # sync duplicate fields into Player
            session.player.sync_with_user(self)

            session.send([["PLAYER_TRUST_LEVEL_UPDATE", self.get_trust_level()]])
            session.send([["FACEBOOK_NAME_UPDATE", self.facebook_name]])
            session.send([["PLAYER_UI_NAME_UPDATE", self.get_ui_name(session.player)]])
            session.send([["FACEBOOK_CURRENCY_UPDATE", self.facebook_currency]])

            if self.facebook_third_party_id:
                session.send([["FACEBOOK_THIRD_PARTY_ID_UPDATE", self.facebook_third_party_id]])

            # see if we need to ask for more permissions
            want_permissions = SpinConfig.config.get('facebook_auth_scope', 'email')
            if gamedata['server'].get('gameserver_check_auth_scope', False) and \
               (not self.facebook_permissions_ok(want_permissions)) and \
               (server_time - session.player.last_permissions_request) >= gamedata['permissions_request_interval']:
                session.player.last_permissions_request = server_time
                metric_event_coded(self.user_id, '0035_request_permission_add_scope', {'scope': want_permissions, 'method': 'gameserver'})
                session.send([["INVOKE_FACEBOOK_AUTH", want_permissions,
                               'Permission Requested',
                               'Commander, to show your scores on Facebook we need additional authorization.']])


    def offer_payer_promo(self, session):
        session.player.last_payer_promo = server_time
        currency_url = OGPAPI_instance.get_object_endpoint({'type':OGPAPI.object_type('gamebucks')})
        session.increment_player_metric('payer_promo_offered', 1)
        metric_event_coded(session.user.user_id, '4500_payer_promo_offered', {'currency_url':currency_url})
        session.send([["OFFER_PAYER_PROMO", currency_url]])

    def log_adnetwork_event(self, api, props):
        props['account_creation_time'] = self.account_creation_time

        # special case for skynet - write dict version of the target for queries
        if (api == 'fb_conversion_pixels'):
            if self.acquisition_ad_skynet:
                props['dtgt'] = dict((x[0], x[1:]) for x in self.acquisition_ad_skynet.split('_') if len(x) >= 2)

        gamesite.do_log_adnetwork_event(api, props)


# mapping of (player ID, game_id) tuples to Player objects

def write_json_field(pyobj, jsonobj, field):
    name, coerce_write, coerce_read = field
    val = getattr(pyobj, name)
    if coerce_write: val = coerce_write(val)
    jsonobj[name] = val

def read_json_field(jsonobj, pyobj, field, player = None, observer = None):
    assert player
    assert observer
    name, coerce_write, coerce_read = field
    if jsonobj.has_key(name):
        val = jsonobj[name]
        if coerce_read: val = coerce_read(player, observer, val)
        setattr(pyobj, name, val)
        del jsonobj[name]

class PlayerTable:
    PLAYER_WRONLY_FIELDS = [('user_id', int, int)] # for reference/recovery only, not used as database key

    PLAYER_RW_FIELDS = [
              ('generation', None, None),
              ('ai_instance_generations', None, None),
              ('read_only', None, None),
              ('alias', None, None),
              ('title', None, None), # string value of current title to use
              # ('unlocked_titles', None, None), # dictionary of unlocked titles
              ('facebook_permissions', None, None), # needs to be in player rather than user because it is app-specific
              ('last_fb_notification_time', None, None),
              ('last_bh_blog_feed_seen', None, None),
              ('fbpayments_inflight', None, None),
              ('player_preferences', None, None),
              ('chat_seen', None, None),
              ('battle_history_seen', None, None),

              # note: ordering of abtests -> tech -> player_auras -> base objects is important!
              # because A/B tests might alter tech specs, and tech might alter auras, and auras alter my_base reconstitution
              ('abtests', None, None),
              ('tech', None, lambda player, observer, tech: player.load_tech_and_init_stattab(observer, tech)),

              # important! this must come BEFORE player_auras because load_auras_and_init_stattab() may mutate it!
              ('player_auras_recently_expired', None, None),
              ('player_auras', None, lambda player, observer, auras: player.load_auras_and_init_stattab(observer, auras)),

              ('home_region', None, None),
              ('squads', None, None),
              ('travel_state', None, None),

              ('resources', lambda res: res.persist_state(),
               lambda player, observer, data: ResourceState.create_from_persisted(player, data)),

              ('loot_buffer', None, None),
              ('donated_units', None, None),
              ('inventory', None, None),
              ('mailbox', None, None),
              ('map_bookmarks', None, None),
              ('protection_attack_count', None, None), # refers to home base only
              ('protection_attack_time', None, None), # refers to home base only

              ('completed_quests', None,
               lambda player, observer, data: data if type(data) == dict else dict([(name, {'count':1}) for name in data])),
              ('achievements', None, None),
              ('tutorial_state', None, None),
              ('history', None, None),
              ('cooldowns', None, None),
              ('scores2', lambda s: s.serialize(), lambda player, observer, data: Scores2.CurScores(data)),
              ('idle_check', lambda s: s.serialize(), lambda player, observer, data: IdleCheck.IdleCheck(gamedata['server']['idle_check'], data, server_time)),
              ('creation_time', None, None),
              ('lottery_slate', None, None),
              ('lottery_slate_weights', None, None),
              ('ladder_match', None, None),
              ('ladder_match_history', None, None),

              ('last_gift_prompt', None, None),
              ('last_friend_invite_prompt', None, None),
              ('last_iron_deposit', None, None),
              ('last_motd', None, None),
              ('last_rank_update', None, None),
              ('last_fb_score_update', None, None),
              ('last_daily_attack', None, None),
              ('last_payer_promo', None, None),
              ('last_permissions_request', None, None),
              ('attack_cooldown_start', None, None),
              ('received_gifts', None, None),
              ('lock_state', None, None),
              ('lock_time', None, None),
              ('chat_official', None, None),
              ('lockout_until', None, None),
              ('lockout_count', None, None),
              ('last_lockout_end', None, None),
              ('last_lockout_check', None, None),
              ('lockout_message', None, None),
              ('login_pardoned_until', None, None),
              ('banned_until', None, None),
              ('isolate_pvp', None, None),
              ('possible_alt_accounts', None, None),
              ('known_alt_accounts', None, None),

              ('battle_history', None, None),
              ('recent_attacks', None, None),

              ('unit_repair_queue', None, None),
              ('unit_equipment', None, None),

              ('mentor_player_id_cache', None, None), # not authoritative - must query bhlogin server
              ('trainee_player_ids_cache', None, None), # not authoritative - must query bhlogin server
              ]

    # old fields that should be deleted when seen
    PLAYER_DELETE_FIELDS = { 'sent_gifts': 1 }

    BASE_RW_FIELDS = [
                      ('base_id', None, None),
                      ('base_region', None, None),
                      ('base_map_loc', None, None),
                      ('base_type', None, None),
                      ('base_climate', None, None),
                      ('base_ncells', None, None),
                      ('base_ui_name', None, None),
                      ('base_creation_time', None, None),
                      ('base_creator_id', None, None),
                      ('base_landlord_id', None, None),
                      ('base_last_attack_time', None, None),
                      ('base_times_attacked', None, None),
                      ('base_times_conquered', None, None),
                      ('base_last_conquer_time', None, None),
                      ('base_last_landlord_id', None, None),
                      ('base_richness', None, None),
                      ('base_template', None, None),
                      ('base_icon', None, None),
                      ('base_expire_time', None, None),
                      ('base_size', None, None),
                      ('deployment_buffer', None, None),
                      ('deployment_allowed', None, None),
                      ('base_resource_loot', None, None),
                      ('base_res_looter_state', None, None),
                      ('my_base',
                       lambda mybase: [x.persist_state() for x in mybase],
                       lambda player, observer, data: filter(lambda x: x is not None, (reconstitute_object(observer, player, state, context='PlayerTable:parse(home)') for state in PlayerTable.filter_duplicate_obj_ids(data, player.user_id)))
                       ),
                      ]

    @staticmethod
    def filter_duplicate_obj_ids(state_list, user_id):
        # avoid permanent corruption of playerdb when my_base includes duplicate objects
        seen = set()
        for state in state_list:
            if 'obj_id' in state:
                if state['obj_id'] in seen:
                    gamesite.exception_log.event(server_time, 'PlayerTable: player %d dropping duplicate object ID %r (%r)' % \
                                                 (user_id, state['obj_id'], state.get('spec')))
                    continue
                seen.add(state['obj_id'])
            yield state

    def __init__(self):
        # keep track of current in-flight async I/O
        self.current_loads = {} # list of [AsyncRead1,AsyncRead2,...]
        self.current_stores = {} # list of [generation1,generation2,...]

    def store_async(self, player, cb, fsync, reason):
        player.generation += 1

        if player.user_id in self.current_stores:
            # this is generally bad, because with two stores in flight, the generation number of the store that will "win" in S3 is undefined
            gamesite.exception_log.event(server_time, ('PlayerTable: store_async while player %d I/O already in flight: ' % player.user_id)+repr(self.current_stores[player.user_id]))
        else:
            self.current_stores[player.user_id] = []

        self.current_stores[player.user_id].append(player.generation)

        def finisher(self, user_id, generation, cb):
            if user_id in self.current_stores:
                if generation in self.current_stores[user_id]:
                    self.current_stores[user_id].remove(generation)
                else:
                    gamesite.exception_log.event(server_time, 'PlayerTable: store_async completed but %d gen %d I/O not in flight' % (user_id, generation))
                if len(self.current_stores[user_id]) == 0:
                    del self.current_stores[user_id]
            else:
                gamesite.exception_log.event(server_time, 'PlayerTable: store_async completed but %d gen %d I/O not in flight' % (user_id, generation))

            return cb()

        io_system.async_write_player(player.user_id, self.unparse(player), functools.partial(finisher, self, player.user_id, player.generation, cb), fsync)

    class AsyncRead:
        def __init__(self, parent, observer, user_id, live, cb):
            self.parent = parent
            self.observer = observer
            self.user_id = user_id
            self.live = live
            self.cblist = [cb,]
        def remove_from_current_loads(self):
            assert self in self.parent.current_loads[self.user_id]
            self.parent.current_loads[self.user_id].remove(self)
            if len(self.parent.current_loads[self.user_id]) == 0: del self.parent.current_loads[self.user_id]
        def fail(self, reason):
            self.remove_from_current_loads()
            for cb in self.cblist: cb(False, None)
        def success(self, buf):
            self.remove_from_current_loads()
            success = True
            if buf == 'NOTFOUND':
                ret = None
            else:
                try:
                    ret = self.parent.parse(buf, self.observer, self.user_id, self.live)
                except:
                    gamesite.exception_log.event(server_time, 'Error reading playerdb for user %d: %s' % (self.user_id, traceback.format_exc().strip())) # OK
                    ret = None
                    success = False
            for cb in self.cblist: cb(success, ret)

    def lookup_async(self, observer, user_id, live, cb, reason):
        if user_id not in self.current_loads:
            self.current_loads[user_id] = []
        aread = self.AsyncRead(self, observer, user_id, live, cb)
        self.current_loads[user_id].append(aread)
        io_system.async_read_player(user_id, aread.success, aread.fail)

    def jsonize(self, player):
        jsonobj = {}
        for name, val in player.foreign_data.iteritems():
            jsonobj[name] = val

        for field in self.PLAYER_WRONLY_FIELDS + self.PLAYER_RW_FIELDS:
            write_json_field(player, jsonobj, field)
        for field in self.BASE_RW_FIELDS:
#            if field[0] == 'my_base':
#                # ideally, if all server code is correct, this I/O should be unnecessary
#                player.my_home.nosql_pluck('PlayerTable:unparse(XXXunnecessary)') # should be done from drop_object()
#                player.my_home.nosql_plant('PlayerTable:unparse(XXXunnecessary)')
            write_json_field(player.my_home, jsonobj, field)
        return jsonobj

    def unparse(self, player):
        with admin_stats.latency_measurer('player_table:jsonize'):
            jsonobj = self.jsonize(player)

        with admin_stats.latency_measurer('player_table:serialize'):
            ret = SpinJSON.dumps(jsonobj, pretty = True, newline = True, size_hint = 1024*1024, double_precision = 5)

        log_player_io('PLAYER', 'WRITE', player.user_id, player.generation, 'PlayerTable')

        return ret

    def parse(self, buf, observer, user_id, live):
        jsonobj = None
        try:
            with admin_stats.latency_measurer('player_table:deserialize'):
                jsonobj = SpinJSON.loads(buf)
        except:
            pass

        if not jsonobj:
            return None

        with admin_stats.latency_measurer('player_table:parse'):
            player = self.unjsonize(jsonobj, observer, user_id, live)

        log_player_io('PLAYER', 'READ', player.user_id, player.generation, 'PlayerTable')

        return player

    def unjsonize(self, jsonobj, observer, user_id, live):

        if live:
            player = LivePlayer(user_id)
        else:
            player = ProxyPlayer(user_id)

        if observer is None: observer = player

        if jsonobj.has_key('user_id') and jsonobj['user_id'] != user_id:
            gamesite.exception_log.event(server_time, 'warning: PlayerTable lookup for id %d has data from id %d' % (user_id, jsonobj['user_id']))

        for field in self.PLAYER_RW_FIELDS:
            read_json_field(jsonobj, player, field, player = player, observer = observer)
        for field in self.BASE_RW_FIELDS:
            read_json_field(jsonobj, player.my_home, field, player = player, observer = observer)

#            if field[0] == 'my_base':
#                old_base = player.my_home.my_base
#                new_base = player.my_home.nosql_read(observer, player, 'PlayerTable:parse')
#                if new_base is not None:
#                    # verify that contents are identical
#                    if len(old_base) != len(new_base):
#                        gamesite.exception_log.event(server_time, 'PlayerTable: nosql_read for user %d returned %d objects but my_base had %d' % \
#                                                     (user_id, len(new_base), len(old_base)))
#                    #player.my_home.my_base = new_base


        # save all unrecognized data as foreign_data
        for name, coerce_write, coerce_read in self.PLAYER_WRONLY_FIELDS:
            if jsonobj.has_key(name): del jsonobj[name]

        for name, val in jsonobj.iteritems():
            if name in self.PLAYER_DELETE_FIELDS: continue
            if gamedata['server'].get('log_foreign_data', False):
                gamesite.exception_log.event(server_time, 'unrecognized playerdb data ' + name + ': ' + repr(val))
            player.foreign_data[name] = val

        # init stattab AGAIN so that stuff that depends on home base contents (e.g. repair speed) gets updated properly
        player.recalc_stattab(observer, None)

        return player



player_table = PlayerTable()

def safe_unlink(filename):
    try:
        os.unlink(filename)
    except:
        pass

# similar to PlayerTable, but this is a cut-down version for maintaining the temporary
# state of damaged AI bases. Basically like PvE instances in WoW...
class AIInstanceTable:
    def delete_async(self, observer, user_id, ai_id, cb):
        observer.ai_instance_generation_clear(ai_id)
        io_system.async_delete_aistate(user_id, game_id, ai_id, cb)

    @admin_stats.measure_latency('ai_instance_table:parse')
    def parse(self, buf, observer, user_id, ai_id):
        jsonobj = None

        try:
            jsonobj = SpinJSON.loads(buf)
        except:
            pass

        if not jsonobj:
            return None, 'json_error' # corrupt AI file?

        # has it expired?
        if server_time >= jsonobj['expiration_time']:
            # AI present, but expired
            observer.ai_instance_generation_clear(ai_id)
            return None, 'expired'

        # is this a stale generation?
        expected_gen = observer.ai_instance_generation_get(ai_id)
        if expected_gen >= 0:
            if jsonobj.get('ai_generation',0) < expected_gen:
                gamesite.exception_log.event(server_time, 'AIInstanceTable: %d-vs-%d loaded stale generation %d, expected %d' % \
                                             (user_id, ai_id, jsonobj.get('ai_generation',0), expected_gen))
                return None, 'stale_gen'

        player = ProxyPlayer(ai_id)
        player.expiration_time = jsonobj['expiration_time']
        player.resources.unpersist_state(jsonobj['resources'])
        player.tech = jsonobj.get('tech',{})
        player.player_auras = jsonobj.get('player_auras', [])
        player.recalc_stattab(observer, None)
        player.my_home.deployment_buffer = jsonobj.get('deployment_buffer', 1)
        if 'deployment_allowed' in jsonobj: player.my_home.deployment_allowed = jsonobj['deployment_allowed']
        if 'unit_equipment' in jsonobj: player.unit_equipment = jsonobj['unit_equipment']
        if 'base_climate' in jsonobj: player.my_home.base_climate = jsonobj['base_climate']
        if 'base_ncells' in jsonobj: player.my_home.base_ncells = jsonobj['base_ncells']
        if 'base_richness' in jsonobj: player.my_home.base_richness = jsonobj['base_richness']
        if 'base_size' in jsonobj: player.my_home.base_size = jsonobj['base_size']
        if 'ai_generation' in jsonobj: player.ai_generation = jsonobj['ai_generation']
        if 'base_creation_time' in jsonobj: player.my_home.base_creation_time = jsonobj['base_creation_time']
        if 'base_times_attacked' in jsonobj: player.my_home.base_times_attacked = jsonobj['base_times_attacked']
        if 'base_resource_loot' in jsonobj: player.my_home.base_resource_loot = jsonobj['base_resource_loot']
        if 'base_res_looter_state' in jsonobj: player.my_home.base_res_looter_state = jsonobj['base_res_looter_state']

        for state in jsonobj['my_base']:
            obj = reconstitute_object(observer, player, state, context='AIInstanceTable:parse')
            if not obj: continue
            player.home_base_add(obj)

        player.read_only = True # never write into the "real" PlayerTable
        player.my_home.init_production(player)

        log_player_io('AI', 'READ', '%d-vs-%d' % (user_id, ai_id), player.ai_generation, 'AIInstanceTable')
        return player, 'ok'

    class AsyncRead:
        def __init__(self, parent, observer, user_id, ai_id, cb):
            self.parent = parent
            self.observer = observer
            self.user_id = user_id
            self.ai_id = ai_id
            self.cb = cb
        def fail(self, reason): self.cb('io_error', None)
        def success(self, buf):
            if buf == 'NOTFOUND':
                ret = None
                status = 'missing'
            else:
                ret, status = self.parent.parse(buf, self.observer, self.user_id, self.ai_id)
                if status == 'expired':
                    # trash the file
                    self.parent.delete_async(self.observer, self.user_id, self.ai_id, lambda: None)
            self.cb(status, ret)

    def lookup_async(self, observer, user_id, game_id, ai_id, cb, reason):
        request = self.AsyncRead(self, observer, user_id, ai_id, cb)
        io_system.async_read_aistate(user_id, game_id, ai_id, request.success, request.fail)

    def store_async(self, observer, user_id, ai_id, player, cb, fsync, reason):
        # special case - never store Lion Stone state to avoid bloating aistate storage
        # (client is only allowed to visit once during the tutorial)
        if ai_id == LION_STONE_ID:
            reactor.callLater(0, cb)
            return
        buf = self.unparse(observer, user_id, ai_id, player)
        io_system.async_write_aistate(user_id, game_id, ai_id, buf, cb, fsync)

    def unparse(self, observer, user_id, ai_id, player):
        player.ai_generation += 1

        # make sure we don't read an old version within a short period of time
        observer.ai_instance_generation_put(ai_id, player.ai_generation, player.expiration_time)

        jsonobj = { 'expiration_time': player.expiration_time,
                    'ai_generation': player.ai_generation,
                    'my_base': [x.persist_state() for x in player.home_base_iter() if (x is not None)],
                    'resources': player.resources.persist_state(),
                    'tech': player.tech,
                    'unit_equipment': player.unit_equipment,
                    'deployment_buffer': player.my_home.deployment_buffer,
                    'base_climate': player.my_home.base_climate,
                    'base_ncells': player.my_home.base_ncells,
                    'base_richness': player.my_home.base_richness,
                    'base_size': player.my_home.base_size,
                    'base_creation_time': player.my_home.base_creation_time,
                    'base_times_attacked': player.my_home.base_times_attacked,
                    'user_id': ai_id }
        if player.my_home.deployment_allowed not in (None, True): jsonobj['deployment_allowed'] = player.my_home.deployment_allowed
        if player.my_home.base_resource_loot: jsonobj['base_resource_loot'] = player.my_home.base_resource_loot
        if player.my_home.base_res_looter_state: jsonobj['base_res_looter_state'] = player.my_home.base_res_looter_state

        with admin_stats.latency_measurer('ai_instance_table:serialize'):
            ret = SpinJSON.dumps(jsonobj, pretty = True, newline = True, size_hint = 65536, double_precision = 5)

        log_player_io('AI', 'WRITE', '%d-vs-%d' % (user_id, ai_id), player.ai_generation, 'AIInstanceTable')
        return ret

    def collect_garbage(self):
        io_system.collect_aistate_garbage()

    # perform any necessary one-time initialization the first time a fresh AI instance is created for a player
    def init_fresh_instance(self, ai_id, ai_player, observer):

        observer.ai_instance_generation_clear(ai_id)

        base_data = gamedata['ai_bases_server']['bases'][str(ai_player.user_id)]

        # perform auto-leveling of AI base buildings and units
        if base_data.get('auto_level', False):
            ai_player.auto_level_ai(observer)

        # override base_resource_loot with latest value from the template
        if base_data.get('base_resource_loot'):
            ai_player.my_home.base_resource_loot = copy.deepcopy(base_data['base_resource_loot'])
        else:
            ai_player.my_home.base_resource_loot = None

        # apply base_resource_loot_randomness
        loot_randomness = base_data.get('base_resource_loot_randomness', 0)
        if loot_randomness != 0 and ai_player.my_home.base_resource_loot:
            for res in ai_player.my_home.base_resource_loot:
                ai_player.my_home.base_resource_loot[res] = int(ai_player.my_home.base_resource_loot[res] * (1.0 + loot_randomness * (2 * random.random() - 1)))

ai_instance_table = AIInstanceTable()


class BaseTable:
    def delete_async(self, region_id, base_id, cb):
        if gamesite.nosql_client:
            gamesite.nosql_client.drop_all_objects_by_base(region_id, base_id, reason='BaseTable.delete_async')
        reactor.callLater(0, cb)

    # note: deserialization is broken into two parts, preparse() and
    # parse(), because the base must first tell us who the landlord
    # is, THEN we have to look up the landlord's player state, and
    # we need to have the landlord's player state to fully parse the
    # base (e.g. to set tech levels/object auras/ownership/etc)
    # ^ if NoSQL takes over, then we can get rid of this mess and replace
    # it with a simple synchronous path!

    def preparse(self, buf, region_id, base_id):
        jsonobj = None
        try:
            with admin_stats.latency_measurer('base_table:deserialize'):
                jsonobj = SpinJSON.loads(buf)
        except:
            pass

        if not jsonobj:
            return None, False, None # no base present

        if (jsonobj.has_key('base_id') and jsonobj['base_id'] != base_id) or \
           (jsonobj.has_key('base_region') and jsonobj['base_region'] != region_id):
            gamesite.exception_log.event(server_time, 'warning: BaseTable lookup for %s/%s has data from %s/%s' % (region_id, base_id, jsonobj.get('base_region','unknown'), jsonobj.get('base_id',-1)))


        if 'base_landlord_id' not in jsonobj:
            gamesite.exception_log.event(server_time, 'warning: BaseTable lookup for %s/%s has no base_landlord_id' % (region_id, base_id))
            return None, False, None

        return jsonobj, False, jsonobj['base_landlord_id']

    @admin_stats.measure_latency('base_table:parse')
    def parse(self, region_id, base_id, jsonobj, landlord, observer, reason=''):
        # NOTE! SUBTLE!
        # in the NoSQL case, jsonobj is just the 'feature' from MapCache
        # in the legacy backend case (this code was deleted), jsonobj was the entire contents of the BaseTable JSON blob

        assert jsonobj['base_landlord_id'] == landlord.user_id

        base = Base(region_id, base_id, landlord.user_id, jsonobj.get('base_type','hive'))

        # NOTE! read_json_field magically works because the MapCache 'feature' has the same format as BaseTable entries
        for field in PlayerTable.BASE_RW_FIELDS:
            if field[0] == 'my_base':
                base.my_base = base.nosql_read(observer, landlord, 'BaseTable:parse(%s)' % reason)
            else:
                read_json_field(jsonobj, base, field, player = landlord, observer = observer)

        base.base_generation = jsonobj.get('LOCK_GENERATION',-1) # set generation manually based on value written on last release

        # *override* base's own base_richness with current value from hive template, if found
        if base.base_type == 'hive' and base.base_template and base.base_template in gamedata['hives_server']['templates']:
            base.base_richness = gamedata['hives_server']['templates'][base.base_template].get('base_richness', base.base_richness)

        base.init_production(landlord)

        return base

    def lookup_async(self, region_id, base_id, feature, cb, reason):
        if not gamesite.nosql_client:
            reactor.callLater(0, functools.partial(cb, False, None, None))
            return

        if not feature:
            feature = gamesite.nosql_client.get_map_feature_by_base_id(region_id, base_id, reason=reason)
            if ('base_landlord_id' not in feature):
                gamesite.exception_log.event(server_time, 'BaseTable.lookup_async(%s): bad feature for region %s base %s: %s' % \
                                             (reason, region_id, base_id, repr(feature)))
                reactor.callLater(0, functools.partial(cb, False, None, None))
                return

        assert 'base_landlord_id' in feature

        # simulate preparse success - note, we send 'feature' as the preparse result
        reactor.callLater(0, functools.partial(cb, True, feature, feature['base_landlord_id']))

    def store_async(self, base, cb, fsync, reason):
        base.base_generation += 1
        # ideally, if all server code correctly updates objects as they mutate, no I/O should be necessary here
        base.nosql_pluck('BaseTable:unparse(XXXunnecessary:%s)' % str(reason))
        base.nosql_plant('BaseTable:unparse(XXXunnecessary:%s)' % str(reason))
        if cb: reactor.callLater(0, cb)

    def unparse(self, base):
        jsonobj = {}

        with admin_stats.latency_measurer('base_table:unparse'):
            for field in PlayerTable.BASE_RW_FIELDS:
                write_json_field(base, jsonobj, field)

        with admin_stats.latency_measurer('base_table:serialize'):
            ret = SpinJSON.dumps(jsonobj, pretty = True, newline = True, size_hint = 65536, double_precision = 5)

        return ret

base_table = BaseTable()

class DamageLog(object):
    def __init__(self, base_id, observer = None):
        self.state = {}
        self.base_id = base_id # for debug messages only
        self.observer = observer or RogueOwner # default statless observer
    def record_multi(self, iter):
        for obj in iter:
            self.record(obj)
    def init_multi(self, iter):
        for obj in iter:
            self.init(obj)
    def finalize(self):
        ret = {}
        for sowner_id in self.state:
            dmg = self._finalize(self.state[sowner_id])
            if dmg:
                ret[sowner_id] = dmg
        return ret
    def _finalize(self, state):
        ret = {}
        for obj_id, entry in state.iteritems():
            # treat all consumable units used as if they were completely destroyed
            if entry.get('consumable',False): entry['cur_health'] = 0

            # ignore damage to temporary units
            if entry.get('temporary',False): continue

            if ('cur_health' not in entry): continue # no change
            spec = GameObjectSpec.lookup(entry['spec'])
            orig_cost = spec.cost_to_repair(entry['level'], entry['orig_health'], self.observer, obj_id)
            cur_cost = spec.cost_to_repair(entry['level'], entry['cur_health'], self.observer, obj_id)

            # ignore trivial amounts of building damage (<=10sec to repair)
            if spec.kind == 'building' and len(cur_cost) == 1 and cur_cost.get('time',0) <= 10: continue

            key = '%s:L%d' % (entry['spec'], entry['level'])
            any_damage = False
            for res in ['time']+gamedata['resources'].keys():
                orig = orig_cost.get(res,0)
                cur = cur_cost.get(res,0)
                if orig != cur:
                    if key not in ret: ret[key] = {'count':0}
                    ret[key][res] = ret[key].get(res,0) + cur - orig
                    any_damage = True
            if any_damage:
                ret[key]['count'] += 1

        # get rid of 1-counts
        for k, v in ret.iteritems():
            if v['count'] <= 1: del v['count']

        return ret

class GameObjectDamageLog(DamageLog):
    def init(self, obj):
        if (not (obj.is_building() or obj.is_mobile())) or \
           obj.max_hp == 0: return # ignore scenery etc
        sowner_id = str(obj.owner.user_id)
        if sowner_id not in self.state: self.state[sowner_id] = {}
        self._init(self.state[sowner_id], obj)
    def _init(self, state, obj):
        if obj.obj_id in state:
            if gamedata['server'].get('log_damage_log',1) >= 1:
                gamesite.exception_log.event(server_time, 'DamageLog: _init() on already-registered object obs %d owner %d: %s' % (self.observer.user_id, obj.owner.user_id, obj.spec.name))
        state[obj.obj_id] = {'spec':obj.spec.name, 'level':obj.level, 'orig_health': obj.hp/float(obj.max_hp)}
        if obj.spec.consumable: state[obj.obj_id]['consumable'] = 1
        if obj.is_mobile() and obj.temporary: state[obj.obj_id]['temporary'] = 1
    def record(self, obj):
        if (not (obj.is_building() or obj.is_mobile())) or \
           obj.max_hp == 0: return # ignore scenery etc
        sowner_id = str(obj.owner.user_id)
        if sowner_id not in self.state:
            if gamedata['server'].get('log_damage_log',1) >= 1:
                gamesite.exception_log.event(server_time, 'DamageLog: record() on object with unseen owner (have %s) obs %d at %s owner %d: %s' % (repr(self.state.keys()), self.observer.user_id, self.base_id, obj.owner.user_id, obj.spec.name))
            return
        self._record(self.state[sowner_id], obj)
    def _record(self, state, obj):
        if obj.obj_id not in state:
            if gamedata['server'].get('log_damage_log',1) >= 1:
                gamesite.exception_log.event(server_time, 'DamageLog: _record() on unseen object obs %d at %s owner %d: spec %s obj_id %s squad %r' % (self.observer.user_id, self.base_id, obj.owner.user_id, obj.spec.name, obj.obj_id, obj.squad_id if obj.is_mobile() else None))
            return
        state[obj.obj_id]['cur_health'] = obj.hp/float(obj.max_hp)

class ArmyUnitDamageLog(DamageLog):
    # similar to DamageLog, but operates on raw army units instead of GameObjects
    def init(self, unit):
        if (not (unit['spec'] in gamedata['buildings'] or unit['spec'] in gamedata['units'])): return # ignore scenery etc
        sowner_id = str(unit['owner_id'])
        if sowner_id not in self.state: self.state[sowner_id] = {}
        self._init(self.state[sowner_id], unit)
    def _init(self, state, unit):
        if unit['obj_id'] in state:
            if gamedata['server'].get('log_damage_log',1) >= 1:
                gamesite.exception_log.event(server_time, 'DamageLog: _init() on already-registered object owner %d: %s' % (unit['owner_id'], unit['spec']))
        cur_hp, max_hp = army_unit_hp(unit)
        state[unit['obj_id']] = {'spec':unit['spec'], 'level':unit.get('level',1), 'orig_health': cur_hp/float(max_hp)}
        if unit['spec'] in gamedata['units'] and \
           gamedata['units'][unit['spec']].get('consumable',False):
            state[unit['obj_id']]['consumable'] = 1
        if unit.get('temporary',False):
            state[unit['obj_id']]['temporary'] = 1
    def record(self, unit):
        if (not (unit['spec'] in gamedata['buildings'] or unit['spec'] in gamedata['units'])): return # ignore scenery etc
        sowner_id = str(unit['owner_id'])
        if sowner_id not in self.state:
            if gamedata['server'].get('log_damage_log',1) >= 1:
                gamesite.exception_log.event(server_time, 'DamageLog: record() on object with unseen owner (have %s) at %s owner %d: %s' % (repr(self.state.keys()), self.base_id, unit['owner_id'], unit['spec']))
            return
        self._record(self.state[sowner_id], unit)
    def _record(self, state, unit):
        if unit['obj_id'] not in state:
            if gamedata['server'].get('log_damage_log',1) >= 1:
                gamesite.exception_log.event(server_time, 'DamageLog: _record() on unseen object at %s owner %d: spec %s obj_id %s squad %r' % (self.base_id, unit['owner_id'], unit['spec'], unit['obj_id'], unit.get('squad_id')))
            return
        cur_hp, max_hp = army_unit_hp(unit)
        state[unit['obj_id']]['cur_health'] = cur_hp/float(max_hp)

class AttackLog (object):
    @classmethod
    def base_name(cls, log_time, attacker_id, defender_id, base_id):
        if base_id and base_id != home_base_id(attacker_id) and base_id != home_base_id(defender_id):
            return '%d-%d-vs-%d-at-%s.json.gz' % (log_time, attacker_id, defender_id, base_id)
        else:
            return '%d-%d-vs-%d.json.gz' % (log_time, attacker_id, defender_id)

    # inverse of above
    battle_id_re = re.compile('^([0-9]+)-([0-9]+)-vs-([0-9]+)(-at-[0-9a-z]+)?$')

    @classmethod
    def parse_battle_id(cls, battle_id):
        matches = cls.battle_id_re.match(battle_id)
        if not matches:
            return None
        slog_time, sattacker_id, sdefender_id, slocation = matches.groups()
        log_time = int(slog_time)
        attacker_id = int(sattacker_id)
        defender_id = int(sdefender_id)
        location = slocation[5:] if slocation else None
        return (log_time, attacker_id, defender_id, location)

    @classmethod
    def storage_dir(cls, log_time):
        return spin_log_dir+'/'+SpinLog.time_to_date_string(log_time)+'-battles'
    @classmethod
    def storage_path(cls, log_time, attacker_id, defender_id, base_id):
        return os.path.join(cls.storage_dir(log_time), cls.base_name(log_time, attacker_id, defender_id, base_id))

    @classmethod
    def storage_s3_bucket(cls):
        return SpinConfig.config.get('battle_logs_s3_bucket',None)
    @classmethod
    def storage_s3_name(cls, log_time, attacker_id, defender_id, base_id):
        tm = time.gmtime(log_time)
        base_name = cls.base_name(log_time, attacker_id, defender_id, base_id)
        return '%s-battles-%04d%02d/%04d%02d%02d/%s' % (game_id, tm.tm_year, tm.tm_mon, tm.tm_year, tm.tm_mon, tm.tm_mday, base_name)

    def upload(self):
        if not self.log_file: return # ignore null logs
        if not isinstance(io_system, S3IOSystem): return # S3 not enabled
        bucket = self.storage_s3_bucket()
        if bucket:
            # fire-and-forget write
            buf = open(self.local_filename, 'rb').read()
            io_system.do_async_write((bucket,self.s3_filename), buf, lambda : None, False, 0)

    def __init__(self, log_time, attacker_id, defender_id, base_id):
        self.log_time = log_time # server_time when attack log was opened
        self.log_file = None # this will be recorded in battle history, to be used for retrieving the log later
        self.local_filename = None
        self.s3_filename = None

        if (attacker_id < 0) or (defender_id < 0):
            self.log = SpinLog.NullLog()
            return

        self.log_file = self.base_name(self.log_time, attacker_id, defender_id, base_id)
        attack_log_dir = self.storage_dir(self.log_time)

        if not os.path.exists(attack_log_dir):
            try: os.mkdir(attack_log_dir)
            except: pass

        self.local_filename = os.path.join(attack_log_dir, self.log_file)
        self.s3_filename = self.storage_s3_name(log_time, attacker_id, defender_id, base_id)
        self.log = SpinLog.JSONLog(SpinLog.GzipLogFile(self.local_filename))

    def is_active(self): # whether or not we're actually recording, instead of dropping the events
        return self.local_filename is not None

    def event(self, props):
        self.log.event(server_time, props)
    def close(self):
        if self.log:
            self.log.close()
            self.upload()
            self.log = None

class AttackReplayReceiver (object):
    @classmethod
    def base_name(cls, log_time, attacker_id, defender_id, base_id):
        # kind of a hack, just reuse the AttackLog convention
        return AttackLog.base_name(log_time, attacker_id, defender_id, base_id).replace('.json.gz', '-replay.json.gz')
    @classmethod
    def storage_dir(cls, log_time):
        return spin_log_dir+'/'+SpinLog.time_to_date_string(log_time)+'-replays'
    @classmethod
    def ensure_storage_dir(cls, log_time):
        log_dir = cls.storage_dir(log_time)
        if not os.path.exists(log_dir):
            try: os.mkdir(log_dir)
            except: pass
    @classmethod
    def storage_path(cls, log_time, attacker_id, defender_id, base_id):
        return os.path.join(cls.storage_dir(log_time), cls.base_name(log_time, attacker_id, defender_id, base_id))

    @classmethod
    def storage_s3_bucket(cls):
        return SpinConfig.config.get('battle_replays_s3_bucket',None)
    @classmethod
    def storage_s3_name(cls, log_time, attacker_id, defender_id, base_id):
        tm = time.gmtime(log_time)
        base_name = cls.base_name(log_time, attacker_id, defender_id, base_id)
        return '%s-battles-%04d%02d/%04d%02d%02d/%s' % (game_id, tm.tm_year, tm.tm_mon, tm.tm_year, tm.tm_mon, tm.tm_mday, base_name)

    def __init__(self, active_player_id, log_time, expire_time, attacker_id, defender_id, base_id):
        self.active_player_id = active_player_id
        self.attacker_id = attacker_id
        self.defender_id = defender_id
        self.base_id = base_id
        self.log_time = log_time
        self.expire_time = expire_time # time after which we'll give up if the client hasn't finished uploading
        self.log_file = self.base_name(self.log_time, attacker_id, defender_id, base_id)
        self.local_filename = os.path.join(self.storage_dir(self.log_time), self.log_file)
        self.buf = None # allocated lazily
        self.codec = None
        self.next_line = 0
        self.total_raw_length = 0

    def accumulate(self, codec, first_line, n_lines, is_final, raw_length, inbuf):
        # receive a segment of compressed replay data from the client.
        # return true if finished with the last segment

        if self.codec is None:
            assert codec in ('raw', 'gzip')
            self.codec = codec
            self.buf = cStringIO.StringIO()
        else:
            assert codec == self.codec

        if first_line != self.next_line: raise Exception('unexpected first line: %r vs %r' % (first_line, self.next_line))
        if self.codec == 'gzip': # this is base64-encoded as well
            inbuf = base64.b64decode(inbuf)
            # note: we trust the client to generate valid gzip, and also trust it to send
            # us atomic chunks where we can terminate the recording after any chunk.
        self.buf.write(inbuf)
        self.next_line += n_lines
        self.total_raw_length += raw_length

        if is_final:
            self.finalize()
            return True

        # we could write the data received so far to disk immediately, but for now let's just buffer it
        # (will lose data if server stops during a battle, but that will probably mess up the battle result anyway).

        return False

    def finalize(self):
        if self.buf is None: return # received no data

        # decompress what the client sent us
        if self.codec == 'raw':
            raw_buf = self.buf.getvalue()
            gzip_buf = gzip.GzipFile(fileobj=cStringIO.StringIO(raw_buf)).read()
        elif self.codec == 'gzip':
            # we trust the client to generate valid gzip!
            raw_buf = None
            gzip_buf = self.buf.getvalue()

        # check the size of the decompressed raw representation
        if raw_buf is not None and len(raw_buf) != self.total_raw_length:
            gamesite.exception_log.event(server_time, 'replay raw length mismatch: %r vs %r' % (len(raw_buf), self.total_raw_length))

        # fire-and-forget S3 upload
        if isinstance(io_system, S3IOSystem) and self.storage_s3_bucket(): # S3 enabled
            bucket = self.storage_s3_bucket()
            name = self.storage_s3_name(self.log_time, self.attacker_id, self.defender_id, self.base_id)
            io_system.do_async_write((bucket,name), gzip_buf, lambda : None, False, 0)
        else:
            # write to local disk
            self.ensure_storage_dir(self.log_time)
            with AtomicFileWrite.AtomicFileWrite(self.local_filename, 'wb') as atom:
                atom.fd.write(gzip_buf)
                atom.complete()

        metric_event_coded(self.active_player_id, '3832_battle_replay_uploaded', {'battle_time': self.log_time,
                                                                                  'attacker_id': self.attacker_id,
                                                                                  'defender_id': self.defender_id,
                                                                                  'base_id': self.base_id,
                                                                                  'raw_length': self.total_raw_length,
                                                                                  'wire_length': self.buf.tell()
                                                                                  })


class ScreenRecordingReceiver(object):
    @classmethod
    def base_name(cls, log_time, user_id):
        return '%s-%d-%d.jpg' % (game_id, user_id, log_time)
    @classmethod
    def storage_dir(cls, log_time):
        return spin_log_dir+'/'+SpinLog.time_to_date_string(log_time)+'-screen-recordings'
    @classmethod
    def ensure_storage_dir(cls, log_time):
        log_dir = cls.storage_dir(log_time)
        if not os.path.exists(log_dir):
            try: os.mkdir(log_dir)
            except: pass
    @classmethod
    def storage_path(cls, log_time, user_id):
        return os.path.join(cls.storage_dir(log_time), cls.base_name(log_time, user_id))
    @classmethod
    def storage_s3_bucket(cls):
        return SpinConfig.config.get('screen_recordings_s3_bucket',None)
    @classmethod
    def storage_s3_name(cls, log_time, user_id):
        tm = time.gmtime(log_time)
        base_name = cls.base_name(log_time, user_id)
        return '%s-%04d%02d/%04d%02d%02d/%s' % (game_id, tm.tm_year, tm.tm_mon, tm.tm_year, tm.tm_mon, tm.tm_mday, base_name)

    @classmethod
    def upload_frame(cls, log_time, user_id, buf, codec):
        assert codec == 'jpg'
        # check for JPEG magic bytes
        assert (buf[0:2] == b'\xff\xd8') and (buf[-2:] == b'\xff\xd9')
        # make sure file is not too large
        assert len(buf) < 1024*1024

        if isinstance(io_system, S3IOSystem):
            bucket = cls.storage_s3_bucket()
            if bucket:
                s3_filename = cls.storage_s3_name(log_time, user_id)

                # fire and forget
                io_system.do_async_write((bucket,s3_filename), buf, lambda: None, False, 0)

        else: # write locally
            cls.ensure_storage_dir(log_time)
            local_filename = cls.storage_path(log_time, user_id)
            with AtomicFileWrite.AtomicFileWrite(local_filename, 'wb') as atom:
                atom.fd.write(buf)
                atom.complete()

class Session(object):
    class AsyncLogout:
        def __init__(self, parent):
            self.parent = parent
            self.d = make_deferred('AsyncLogout')
            self.wrote_user = False
            self.wrote_player = False
        def user_cb(self):
            self.wrote_user = True
            self.try_finish()
        def player_cb(self):
            self.wrote_player = True
            self.try_finish()
        def try_finish(self):
            if (self.wrote_user) and (self.wrote_player):
                d, self.d = self.d, None
                if d:
                    d.callback(True)

    def __init__(self, session_id, user, player, login_time):
        assert user.active_session is None

        # these are set once at initialization
        self.session_id = session_id
        self.incoming_serial = 0
        self.incoming_acked = 0 # last serial we told the client we acked
        self.outgoing_serial = 0
        self.user = user
        self.user.active_session = self
        self.player = player
        self.login_time = login_time

        # reset each time we hear from the browser;
        # used to detect timed-out clients
        self.last_active_time = login_time

        # for ADMIN purposes only, keep track of the last messages sent
        self.last_action = collections.deque([], gamedata['server']['ADMIN']['last_action_buf'])

        # dict of incoming bundles of game messages {serial: messsages}
        # being held because earlier messages haven't been received or completely handled yet
        self.message_buffer = {}
        self.lagged_out = False

        # array of outgoing bundles of game messages [[serial, message]]
        # stored for retransmission in case the client disconnects
        self.retrans_buffer = []

        # Maintain a list of Deferreds we are waiting on during async message handling.
        self.async_ds = []
        self.async_ds_watchdog = None # IDelayedCall to detect async_ds getting "stuck"
        self.async_ds_watchdog_fired = False
        self.after_async = [] # list of Deferreds to fire once we finish async message handling.

        # park current synchronous HTTP requests here. They will be completed as soon as the session is no longer async.
        self.sync_requests = []

        # park the longpoll HTTP request here
        self.longpoll_request = None
        self.longpoll_request_time = -1 # note! if longpoll_request is not None, and this is <0, that means "reuse the same longpoll_request after flush" (for websockets)

        # list of outgoing game messages to deliver to the client's browser next time it contacts the server
        self.outgoing_messages = []

        # IDelayedCall for immediately pending flush_outgoing_messages
        self.pending_flush_outgoing_messages = None

        # flags that we need to perform a recaculation and send the results to the client on next transmission
        self.deferred_ping_squads = False
        self.deferred_ladder_point_decay_check = False

        # note: this applies to self.player only, not self.viewing_player.
        # stattab updates for viewing_player need to be done and transmitted manually
        self.deferred_stattab_update = False

        self.deferred_history_update = False
        self.deferred_battle_history_update = False
        self.deferred_mailbox_update = False
        self.deferred_power_change = False
        self.deferred_player_state_update = False

        # sends updates for BOTH self.player and self.viewing_player
        self.deferred_player_auras_update = False

        self.deferred_player_cooldowns_update = False
        self.deferred_donated_units_update = False
        self.deferred_object_state_updates = set()
        self.deferred_object_removals = set()
        self.deferred_player_name_update = False
        self.deferred_player_trophies_update = False

        # prevent overlapping SPROBE_RUN requests
        self.sprobe_in_progress = False

        # flag to prevent overlapping VISIT_BASE requests
        self.visit_base_in_progress = False

        # for debugging, keep track of how many SESSION_CHANGE messages we've sent the client this login
        self.debug_session_change_count = 0

        # keep track of last few actions applied to this session for debugging
        self.debug_action_log = collections.deque([], 16)

        # same for complete_attack
        self.complete_attack_in_progress = False
        self.complete_attack_d = None

        # maintains state of asynchronous logout
        self.logout_in_progress = None
        # fired when completely logged out
        self.logout_d = None

        # these are reset each time the connected user views a different base
        self.home_base = True
        self.has_attacked = False
        self.revenge_attack_until = -1 # if the attacker is taking advantage of a revenge_defender cooldown allowance, end time of the allowance, otherwise -1

        self.defender_cc_standing = False # true if the defender's CC was not destroyed at start of battle
        self.defender_protection_expired_at = -1 # set on initial base visit

        self.attack_log = None
        self.attack_replay_receivers = {} # indexed by the replay token
        self.damage_log = None

        self.protection_eligible = None # False/True flag set at start of combat
        self.attack_finish_time = -1 # server_time when attack must conclude (due to attack timer)

        self.incoming_attack_time = -1 # server_time when AI units will be spawned in your base
        self.incoming_attack_wave_time = -1 # server_time for next wave within the attack
        self.incoming_attack_id = -1
        self.incoming_attack_type = None
        self.incoming_attack_data = None
        self.incoming_attack_units = [] # list of waves of incoming AI units [ {'tank_unit': 3}, ... ]
        self.incoming_attack_direction = None # direction from which units will arrive (index into gamedata['ai_attacks_client']['directions'])

        self.defending_squads = {} # XXX merge deployable/defending squads into participating_squads
        self.deployable_squads = {} # dict of base_id -> squads (map features) eligible for deployment into combat this session
        self.deployed_unit_space = 0 # how much "space" worth of units have already been deployed into the attack
        self.deployed_donated_unit_space = 0 # SUBSET of deployed_unit_space for donated units
        self.deployed_units = None # for analytics only, keep track of how many units of each type were deployed
        self.deployed_donated_units = None # for analytics only, keep track of how many units of each type were deployed (SUBSET of deployed_units)

        self.auto_resolved = False # Flag that the current battle has been auto-resolved

        self.res_looter = None # ResLoot state object, set up at the beginning of each session
        self.starting_base_damage = None # copy of viewing_base.calc_base_damage() result made at the beginning of each session
        self.starting_resources = None # resources in storage at beginning of each session (for viewing_player)

        self.resurrectable_objects = [] # list of resurrectable objects destroyed during current attack
        self.loot = {} # how much has been looted during the current attack e.g. {'resource1':123, 'resource2':345}
        self.items_expended = {} # items expended during current attack by str(user_id): {'1111':{'tactical_nuke':2}, ...}

        self.cur_objects = None
        self.viewing_user = None
        self.viewing_player = None
        self.viewing_base = None

        # keep track of the lock we've taken on the player's own home base map feature
        self.player_base_lock = None # tuple of (base_region, base_id)

        # keep track of locks we've taken on viewing_base and squads participating in fights
        self.viewing_base_lock = None # lock_id
        self.viewing_squad_locks = None # dict of {lock_id0: lock_generation0, ...}

        # keep track of locks we are holding across pending asynchronous paths
        self.pre_locks = set() # set of lock_ids

        self.ui_name = None
        self.pvp_balance = None # which party is favored in PvP combat
        self.ladder_state = None # state for PvP ladder battles

        self.last_rival_query = -1 # time of last rival query, for checking cooldown
        self.last_quarry_query = -1 # time of last quarry query, for checking cooldown

        self.activity_classifier = ActivityClassifier.ActivityClassifier(gamedata)
        self.last_activity_sample_time = -1

        self.global_chat_channel = None

        self.alliance_chat_channel = None
        self.alliance_id_cache = -1 # MAY GO OUT OF DATE, DO NOT USE FOR ANYTHING IMPORTANT (CHAT ONLY)
        self.alliance_membership_cache = None # DO NOT USE FOR ANYTHING IMPORTANT (CHAT ONLY)
        self.alliance_info_cache = None # DO NOT USE FOR ANYTHING IMPORTANT (CHAT ONLY)

        self.viewing_alliance_id_cache = -1 # DO NOT USE FOR ANYTHING IMPORTANT (CHAT ONLY)
        self.viewing_alliance_info_cache = None # DO NOT USE FOR ANYTHING IMPORTANT (CHAT ONLY)

        self.region_chat_channel = None

        self.sent_metrics = {} # keep track of once-per-session Consequent metric events we've already sent

        # track ongoing timers used to compare server and client clock speeds
        self.clock_races = {} # mapping of 'tag' -> server-side start time

        gamesite.chat_mgr.join(self, 'BROADCAST')
        if self.player.is_developer():
            gamesite.chat_mgr.join(self, 'DEVELOPER')
            self.do_chat_catchup('DEVELOPER', self.outgoing_messages)

    # transition the session to async waiting on the given Deferred
    # this should be called by any internal function that wants to prevent further message handling
    # on the session until the Deferred completes.
    def start_async_request(self, d):
        if d in self.async_ds: return d # duplicate

        self.async_ds.append(d)
        # ensure we communicate back to the client as soon as async processing finishes
        d.addBoth(self.complete_async_request, d) # OK

        timeout = gamedata['server'].get('async_d_watchdog_timeout',120.0)
        if self.async_ds_watchdog:
            if timeout > 0:
                self.async_ds_watchdog.reset(timeout)
            else:
                self.async_ds_watchdog.cancel()
                self.async_ds_watchdog = None
        elif not self.logout_in_progress and not self.async_ds_watchdog_fired and timeout > 0:
            self.async_ds_watchdog = reactor.callLater(timeout, self.async_ds_timeout)

        return d # for syntactic convenience only

    def resource_allow_instant_upgrade(self, resdata):
        # allow if resource "allow_instant" setting is missing or True or if predicates are satisfied
        return Predicates.eval_pred_or_literal(resdata.get('allow_instant', 1), self, self.player)

    def async_ds_timeout(self):
        self.async_ds_watchdog = None

        if not self.async_ds: return # it got cleared up asynchronously (? XXXXXX not sure why this happens - post-logout?)

        self.async_ds_watchdog_fired = True
        gamesite.exception_log.event(server_time, 'player %d async_ds watchdog timeout! async_ds %r after_async %r' % (self.user.user_id, self.async_ds, self.after_async))

        # dump a ridiculous amount of debugging info
        gamesite.exception_log.event(server_time, SessionChange.debug_dump())
        if isinstance(io_system, S3IOSystem):
            gamesite.exception_log.event(server_time, repr(io_system.s3_req.get_stats()))
        gamesite.exception_log.event(server_time, '\n'.join(map(str, reactor.getDelayedCalls())))

        # not sure what to do here...

        #gamesite.gameapi.log_out_async(self, 'async_ds_timeout', force = True)
        d_list, self.async_ds = self.async_ds, []
        for d in d_list:
            d.cancel()
            #d.errback(failure.Failure(Exception('async_ds watchdog timeout')))

    # exception to pass to after_async_request callbacks that fire after logout has begun
    class AlreadyLoggedOut(Exception): pass

    def complete_async_request(self, result_or_failure, d):
        # note: this is called BY an async_d firing, so don't fire it again!

        if d not in self.async_ds:
            gamesite.exception_log.event(server_time, 'complete_async_request in unexpected state: sync_requests %r async_ds %r %s' % (self.sync_requests, self.async_ds, ''.join(traceback.format_stack())))
        else:
            self.async_ds.remove(d)

        if not self.async_ds: # totally drained - flush now
            if self.async_ds_watchdog:
                self.async_ds_watchdog.cancel()
                self.async_ds_watchdog = None

            d_list, self.after_async = self.after_async, []
            for d in d_list:
                if self.logout_in_progress:
                    # fail the call, since we've started logging out
                    reactor.callLater(0, d.errback, failure.Failure(self.AlreadyLoggedOut('player %d logged out' % self.user.user_id)))
                else:
                    reactor.callLater(0, d.callback, True)

            # and finally respond to the client. If one of the above cbs makes us async again, this will do nothing.
            self.queue_flush_outgoing_messages()

        return result_or_failure # pass along callback chain

    # fire this deferred after we come out of async wait (or immediately if not waiting)
    def after_async_request(self, d):
        if self.async_ds:
            if d in self.async_ds:
                gamesite.exception_log.event(server_time, 'after_async_request deadlock on %r' % (d,))
                reactor.callLater(0, d.errback, failure.Failure(Exception('after_async_request deadlock')))
            self.after_async.append(d)
        else:
            reactor.callLater(0, d.callback, True)
        return d # for syntactic convenience only

    def is_async(self): return bool(self.async_ds)

    def record_activity_sample(self, force = False):
        interval = gamedata['server'].get('activity_classifier_interval',300)
        t = int(server_time/interval)*interval
        if t > self.last_activity_sample_time or force:
            sample = self.activity_classifier.finalize()
            sample['dt'] = interval
            self.activity_classifier = ActivityClassifier.ActivityClassifier(gamedata)
            self.last_activity_sample_time = t
            if (sample['state'] not in ('idle','harvest')) or sample.get('flags'): # don't bother recording idle or harvest time
                if gamedata['server'].get('log_activity_in_player_history', False):
                    hist = self.player.history
                    if 'activity' not in hist: hist['activity'] = {}
                    # note: record at t=(t-interval) because that is the *start* of the sampling period
                    hist['activity'][str(t - interval)] = sample
                if gamedata['server'].get('log_activity_in_nosql', True):
                    props = copy.deepcopy(sample)
                    props['user_id'] = self.user.user_id
                    props.update(self.player.get_denormalized_summary_props('brief'))
                    gamesite.nosql_client.log_record('activity', t-interval, props, log_ident = False, reason='record_activity_sample')

    def is_ladder_battle(self): return self.ladder_state is not None

    def using_squad_deployment(self, deployable_squads = None):
        if not self.viewing_base.deployment_allowed: return False # skill challenges etc
        if deployable_squads is None: deployable_squads = self.deployable_squads
        return (len(deployable_squads) != 1 or (deployable_squads.values()[0]['squad_id'] != SQUAD_IDS.BASE_DEFENDERS))

    # this is exposed so that MetricEventConsequent can call it without depending on the global function from server.py
    def metric_event_coded(self, player, event_name, val):
        if val:
            assert type(val) is dict
            if val.get('attack_event', False):
                # write to attack log instead of main metrics log
                self.attack_event(player.user_id, event_name, val)
                return
            elif val.get('purchase_ui_event', False):
                # write to purchase_ui log instead of main metrics log
                val['user_id'] = player.user_id
                val['event_name'] = event_name
                assert ('alloy' not in val['event_name']) # don't record previous-generation events
                val['code'] = int(event_name[0:4])
                del val['purchase_ui_event']
                gamesite.purchase_ui_log.event(server_time, val)
                return
        metric_event_coded(player.user_id, event_name, val)

    def debug_log_action(self, reason):
        self.debug_action_log.append({'time':server_time, 'reason': reason, 'session': self.debug_session_change_count})

    # just return a string describing the current session state, for exception logging only
    def dump_exception_state(self):
        ui_action_log = '\n'.join('%d %d %s' % (x['time'], x['session'], x['reason']) for x in self.debug_action_log)
        ui_action_log += '\n%d %d %s' % (server_time, self.debug_session_change_count, 'NOW')
        return 'player %d viewing %d at %s (session change count %d), is_async %r complete_attack_in_progress %r visit_base_in_progress %r logout_in_progress %r has_attacked %r viewing_base_lock %r action_log\n%s' % \
               (self.player.user_id, self.viewing_player.user_id, self.viewing_base.base_id, self.debug_session_change_count, self.is_async(), bool(self.complete_attack_in_progress), bool(self.visit_base_in_progress), bool(self.logout_in_progress), self.has_attacked, self.viewing_base_lock, ui_action_log)

    # return current seconds of cumulative play time
    def cur_playtime(self):
        return (server_time - self.login_time) + self.player.history.get('time_in_game',0)

    def prune_attack_replay_receivers(self, force = False):
        # get rid of expired replay receivers so they don't take up memory
        for token, recv in self.attack_replay_receivers.items():
            if server_time >= recv.expire_time or force:
                self.attack_replay_receivers[token].finalize()
                del self.attack_replay_receivers[token]

    def get_alliance_id(self, reason=''):
        if (not gamesite.sql_client) or \
           (not self.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])):
            return -1

        self.alliance_membership_cache = gamesite.sql_client.get_users_alliance_membership(self.user.user_id, reason = reason)
        self.alliance_id_cache = self.alliance_membership_cache['alliance_id'] if self.alliance_membership_cache else -1
        self.player.make_alliance_sticky(self.alliance_id_cache)

        return self.alliance_id_cache

    def get_alliance_info(self, reason=''):
        alliance_id = self.get_alliance_id(reason=reason)
        if alliance_id <= 0: # not in an alliance
            self.alliance_info_cache = None
        else:
            self.alliance_info_cache = gamesite.sql_client.get_alliance_info(alliance_id, member_access = True, get_roles = True, reason = reason)
            if not self.alliance_info_cache:
                # alliance is somehow invalid - get out of it
                gamesite.sql_client.leave_alliance(self.user.user_id, reason = reason)
                self.alliance_id_cache = -1; self.alliance_membership_cache = None
        return self.alliance_info_cache, self.alliance_membership_cache

    # client uses generic chat channel names - translate to/from internal names
    def decode_chat_channel_name(self, channel):
        if channel == 'GLOBAL' and self.global_chat_channel:
            return self.global_chat_channel
        elif channel == 'REGION' and self.region_chat_channel:
            return self.region_chat_channel
        elif channel == 'ALLIANCE' and self.alliance_chat_channel:
            return self.alliance_chat_channel
        elif channel == 'DEVELOPER' and self.player.is_developer():
            return channel
        return None
    def encode_chat_channel_name(self, channel):
        if channel == self.global_chat_channel:
            return 'GLOBAL'
        elif channel == self.alliance_chat_channel:
            return 'ALLIANCE'
        elif channel == self.region_chat_channel:
            return 'REGION'
        return channel

    def do_chat_catchup(self, true_channel, retmsg):
        num_received = 0
        min_time = server_time
        for x in gamesite.nosql_client.chat_catchup(true_channel, limit = gamedata['server']['chat_memory'], reason='catchup'):
            self.chat_recv(true_channel, x.get('id',None), x['sender'], x.get('text',''), retmsg = retmsg)
            num_received += 1
            if 'time' in x['sender']:
                min_time = min(min_time, x['sender']['time'])

        no_more_messages = (num_received < gamedata['server']['chat_memory'])

        # tell client whether we can get more
        self.chat_recv(true_channel, None, {'chat_name':'System',
                                            'type':'cannot_get_more' if no_more_messages else 'can_get_more',
                                            'time': min_time, 'user_id':-1},
                       'cannot_get_more' if no_more_messages else 'can_get_more',
                       retmsg = retmsg, is_prepend = True)

    def do_chat_getmore(self, true_channel, end_time, end_msg_id, retmsg):
        msg_list = gamesite.nosql_client.chat_catchup(true_channel, end_time = end_time, end_msg_id = end_msg_id,
                                                      order = SpinNoSQL.NoSQLClient.CHAT_NEWEST_FIRST,
                                                      limit = gamedata['server']['chat_memory'],
                                                      reason = 'getmore')
        min_time = server_time
        for x in msg_list:
            self.chat_recv(true_channel, x.get('id',None), x['sender'], x.get('text',''), retmsg = retmsg, is_prepend = True)
            if 'time' in x['sender']:
                min_time = min(min_time, x['sender']['time'])

        # if we got fewer messages than chat_memory, that means the next query won't return any at all
        # so tell the client this is the final "getmore"
        no_more_messages = len(msg_list) < gamedata['server']['chat_memory']

        self.chat_recv(true_channel, None, {'chat_name':'System',
                                            'type':'cannot_get_more' if no_more_messages else 'can_get_more',
                                            'time': min_time, 'user_id':-1},
                       'cannot_get_more' if no_more_messages else 'can_get_more',
                       retmsg = retmsg, is_prepend = True)

        return no_more_messages


    def init_alliance(self, retmsg, chat_catchup = True, reason = 'Session.init_alliance'):
        if self.alliance_chat_channel:
             gamesite.chat_mgr.leave(self, self.alliance_chat_channel)
             self.alliance_chat_channel = None

        alliance_info, alliance_membership = self.get_alliance_info(reason=reason)
        if alliance_info is None: return None, None
        alliance_id = alliance_info['id']

        self.alliance_chat_channel = 'a:%d' % alliance_id

        if chat_catchup:
            self.do_chat_catchup(self.alliance_chat_channel, retmsg)
            txt = alliance_info.get('chat_motd', None)
            if not txt:
                txt = "Welcome to \"%s\" chat!" % alliance_info.get('ui_name', 'unknown')
            self.chat_recv(self.alliance_chat_channel, None,
                           {'chat_name': gamedata['strings']['alliance_chat_motd_sender'], 'type': 'alliance_welcome',
                            'time': server_time, 'user_id':-1},
                           txt, retmsg = retmsg)

        gamesite.chat_mgr.join(self, self.alliance_chat_channel)

        # record this here on login/join/etc to catch alliance members at least once a day, but without polluting logs
        self.activity_classifier.set_flag('alliance_member')

        return alliance_info, alliance_membership

    def init_global_chat(self, retmsg):
        assert self.global_chat_channel is None
        self.global_chat_channel = Predicates.eval_cond_or_literal(gamedata['global_chat_channel_assignment'], self, self.player)

        # divert to alternate global chat channel, for A/B testing purposes
        divert = self.player.get_any_abtest_value('divert_chat', None)
        if divert:
            self.global_chat_channel += '_'+divert

        # stuff last few messages into chat and join
        self.do_chat_catchup(self.global_chat_channel, retmsg)
        # put welcome message into chat
        if gamedata['strings']['chat_templates'].get('welcome') and Predicates.read_predicate(gamedata['chat_welcome_if']).is_satisfied(self.player,None):
            self.chat_recv(self.global_chat_channel, None,
                           {'chat_name':'System', 'type':'welcome', 'channel_name': 'Global', 'time': server_time, 'user_id':-1},
                           'Welcome',
                           retmsg = retmsg)
        gamesite.chat_mgr.join(self, self.global_chat_channel)

    def init_region_chat(self, new_region, retmsg):
        if self.region_chat_channel:
            gamesite.chat_mgr.leave(self, self.region_chat_channel)
            self.region_chat_channel = None
        if (not new_region) or (new_region not in gamedata['regions']): return
        self.region_chat_channel = 'r:'+str(new_region)

        # stuff last few messages into chat and join
        self.do_chat_catchup(self.region_chat_channel, retmsg)
        # put welcome message into chat
        if gamedata['strings']['chat_templates'].get('welcome') and Predicates.read_predicate(gamedata['chat_welcome_if']).is_satisfied(self.player,None):
            ui_name = gamedata['regions'][new_region]['ui_name']
            self.chat_recv(self.region_chat_channel, None,
                           {'chat_name':'System', 'type':'welcome', 'channel_name': '%s Region' % ui_name, 'time': server_time, 'user_id':-1},
                           'Welcome',
                           retmsg = retmsg)
        gamesite.chat_mgr.join(self, self.region_chat_channel)

    def shutdown(self, method):
        self.prune_attack_replay_receivers(True)

        if self.region_chat_channel:
            gamesite.chat_mgr.leave(self, self.region_chat_channel)
        if self.alliance_chat_channel:
            gamesite.chat_mgr.leave(self, self.alliance_chat_channel)
        gamesite.chat_mgr.leave(self, self.global_chat_channel)
        gamesite.chat_mgr.leave(self, 'BROADCAST')
        if self.player.is_developer():
            gamesite.chat_mgr.leave(self, 'DEVELOPER')

        assert self.user.active_session is self
        self.user.active_session = None

        if (self.viewing_base_lock is not None) or (self.viewing_squad_locks is not None):
            # shouldn't get here - this violates an invariant
            gamesite.exception_log.event(server_time, 'shutdown() with invalid session state: %s\nviewing_base_lock %r viewing_squad_locks %r pre_locks %r' % (self.dump_exception_state(), self.viewing_base_lock, self.viewing_squad_locks, self.pre_locks))

            # try to clean up - but we might have broken something. Better to release the locks though.
            self.release_base()

        self.release_pre_locks()

        if self.async_ds_watchdog:
            self.async_ds_watchdog.cancel()
            self.async_ds_watchdog = None

        if self.longpoll_request:
            request, self.longpoll_request = self.longpoll_request, None
            gamesite.gameapi.complete_longpoll(request, self)
            if isinstance(request, WSFakeRequest): # XXXXXX nasty hack
                # shut down the connection here so that it won't stick around until the full timeout

                if method != 'onunload' and gamedata['server'].get('log_websocket_events',0) >= 2:
                    gamesite.exception_log.event(server_time, 'Closing WebSocket during session shutdown for %r: %s' % (method, request.proto.peer_ip))
                request.close_connection_aggressively()

        # unlock the player's personal state
        self.player.lock_state = Player.LockState.open
        self.player.lock_time = 0

    def release_pre_locks(self):
        # give up any temporarily held locks
        while self.pre_locks:
            lock_id = self.pre_locks.pop()
            lock_region, lock_base_id = SpinDB.parse_base_lock_id(lock_id)
            gamesite.nosql_client.map_feature_lock_release(lock_region, lock_base_id, self.player.user_id, reason='release_pre_locks')

    # acquire locks on the viewed base and all defending and deployable squads.
    # "errors" is an optional list to append any locking errors to (strings in gamedata['errors'])
    def do_acquire_base(self, viewing_player, viewing_base, deployable_squads, defending_squads, errors = None):

        if (self.viewing_base_lock is not None) or (self.viewing_squad_locks is not None):
            # shouldn't get here - this violates an invariant
            gamesite.exception_log.event(server_time, 'do_acquire_base() with invalid session state: %s\nviewing_base_lock %r viewing_squad_locks %r pre_locks %r' % (self.dump_exception_state(), self.viewing_base_lock, self.viewing_squad_locks, self.pre_locks))

            if errors is not None:
                errors.append('CANNOT_ATTACK_YOUR_SQUAD_LOCKING_ISSUE')
            return Player.LockState.open # unsuccessful

        if (viewing_base and viewing_base.base_region) or deployable_squads: assert gamesite.nosql_client

        state = Player.LockState.being_attacked

        if viewing_base and viewing_base.base_region and (viewing_base is not self.player.my_home):
            base_lock_id = viewing_base.lock_id()
            if base_lock_id in self.pre_locks: # do we have the lock already?
                self.pre_locks.remove(base_lock_id)
                state = Player.LockState.being_attacked
            else:
                state = gamesite.nosql_client.map_feature_lock_acquire(viewing_base.base_region, viewing_base.base_id, self.player.user_id, generation=viewing_base.base_generation, reason='do_acquire_base')
            if state != Player.LockState.being_attacked:
                self.release_base(viewing_base=viewing_base)

                # try to figure out more specifically why we didn't get the lock
                err = "CANNOT_ATTACK_BASE_WHILE_ALREADY_UNDER_ATTACK"
                if viewing_base.base_type == 'squad' and viewing_base.base_landlord_id != self.player.user_id:
                    feature = gamesite.nosql_client.get_map_feature_by_base_id(viewing_base.base_region, viewing_base.base_id, reason='do_acquire_base_err')
                    if feature: # hostile squad still exists, but its generation number was bumped
                        # is it in the same location where we spied it?
                        if ('base_map_loc' in feature) and \
                           (feature['base_map_loc'][0] == viewing_base.base_map_loc[0]) and \
                           (feature['base_map_loc'][1] == viewing_base.base_map_loc[1]) and \
                           (not Region(gamedata, viewing_base.base_region).feature_is_moving(feature, server_time, assume_moving = True)):
                            if feature.get('LOCK_OWNER',-1) == viewing_base.base_landlord_id:
                                err = "CANNOT_ATTACK_THEIR_SQUAD_OFFENSE"
                            else:
                                err = "CANNOT_ATTACK_THEIR_SQUAD_DEFENSE"

                        else:
                            err = "CANNOT_ATTACK_THEIR_SQUAD_MOVED"

                if errors is not None: errors.append(err)
                if gamedata['server'].get('log_nosql',0) >= 2:
                    gamesite.exception_log.event(server_time, '%d failed to acquire lock on viewing_base %s gen %d' % (self.player.user_id, viewing_base.base_id, viewing_base.base_generation))
                return state
            # when acquiring a squad, verify that it hasn't moved or left the map (XXXXXX should be unnecessary now with the generation check)
            if viewing_base.base_type == 'squad':
                feature = gamesite.nosql_client.get_map_feature_by_base_id(viewing_base.base_region, viewing_base.base_id, reason='do_acquire_base')
                if (not feature) or ('base_map_loc' not in feature) or \
                   (feature['base_map_loc'][0] != viewing_base.base_map_loc[0]) or \
                   (feature['base_map_loc'][1] != viewing_base.base_map_loc[1]):
                    # squad moved or left map
                    gamesite.nosql_client.map_feature_lock_release(viewing_base.base_region, viewing_base.base_id, self.player.user_id, generation=-1)
                    state = -Player.LockState.being_attacked
                    self.release_base(viewing_base=viewing_base)
                    if errors is not None: errors.append("CANNOT_ATTACK_THEIR_SQUAD_MOVED" if (viewing_base.base_landlord_id != self.player.user_id) else "CANNOT_ATTACK_YOUR_SQUAD_RACE")
                    if gamedata['server'].get('log_nosql',0) >= 0:
                        gamesite.exception_log.event(server_time, '%d failed to acquire lock on viewing_base %s (squad moved?) gen %d' % (self.player.user_id, viewing_base.base_id, viewing_base.base_generation))
                    return state
            self.viewing_base_lock = base_lock_id

        self.viewing_squad_locks = None
        squads_to_acquire = [(feature1['squad_id'], base_id1, feature1.get('LOCK_GENERATION',-1)) for base_id1, feature1 in deployable_squads.iteritems() if \
                             SQUAD_IDS.is_mobile_squad_id(feature1['squad_id']) and self.player.squad_is_deployed(feature1['squad_id'])] + \
                            [(feature2['squad_id'], base_id2, feature2.get('LOCK_GENERATION',-1)) for base_id2, feature2 in defending_squads.iteritems() if \
                             SQUAD_IDS.is_mobile_squad_id(feature2['squad_id'])]

        for squad_id, squad_base_id, lock_gen in squads_to_acquire:
            squad_lock_id = SpinDB.base_lock_id(self.player.home_region, squad_base_id)
            if viewing_base and (squad_lock_id == viewing_base.lock_id()): continue # don't double-lock if we're viewing this squad
            if squad_lock_id in self.pre_locks: # do we have the lock already?
                self.pre_locks.remove(base_lock_id)
                state = Player.LockState.being_attacked
            else:
                state = gamesite.nosql_client.map_feature_lock_acquire(self.player.home_region, squad_base_id, self.player.user_id, generation = lock_gen, reason='do_acquire_base')
            if state != Player.LockState.being_attacked:
                self.release_base(viewing_base=viewing_base)

                # try to figure out more specifically why we didn't get the lock
                if squad_base_id in deployable_squads:
                    err = "CANNOT_ATTACK_YOUR_SQUAD_RACE"
                else:
                    err = "CANNOT_ATTACK_BASE_WHILE_ALREADY_UNDER_ATTACK"
                if errors is not None: errors.append(err)

                if gamedata['server'].get('log_nosql',0) >= 2:
                    gamesite.exception_log.event(server_time, '%d failed to acquire lock on squad %s gen %d' % (self.player.user_id, squad_base_id, lock_gen))
                return state
            if self.viewing_squad_locks is None: self.viewing_squad_locks = {}
            self.viewing_squad_locks[squad_lock_id] = lock_gen

        return state

    def acquire_base(self, errors = None):
        return self.do_acquire_base(self.viewing_player, self.viewing_base, self.deployable_squads, self.defending_squads, errors = errors)

    def forget_base_lock(self, base_id):
        lock_id = SpinDB.base_lock_id(self.player.home_region, base_id)
        if self.viewing_base_lock == lock_id:
            self.viewing_base_lock = None
        if self.viewing_squad_locks and (lock_id in self.viewing_squad_locks):
            self.viewing_squad_locks[lock_id] = -2 # special tombstone marker that means "we had a lock, but the squad map feature has been dropped"

    def release_base(self, viewing_base = None):
        if viewing_base is None: viewing_base = self.viewing_base

        if self.viewing_base_lock is not None:
            gamesite.nosql_client.map_feature_lock_release(viewing_base.base_region, viewing_base.base_id, self.player.user_id, generation=viewing_base.base_generation + 1, reason='release_base')
            self.viewing_base_lock = None

        if self.viewing_squad_locks is not None:
            for lock_id, lock_gen in self.viewing_squad_locks.iteritems():
                if lock_gen <= -2: continue # special tombstone marker
                gamesite.nosql_client.map_feature_lock_release(self.player.home_region, SpinDB.parse_base_lock_id(lock_id)[1], self.player.user_id,
                                                               generation = lock_gen + 1, reason='release_base')
            self.viewing_squad_locks = None

    def do_chat_report(self, target_uid, target_chat_name, retmsg):
        if self.player.get_any_abtest_value('enable_chat_police', gamedata['enable_chat_police']):
            # give feedback to the sender that the report was sent
            for chan in (self.global_chat_channel, self.region_chat_channel):
                if chan:
                    self.chat_recv(chan, None,
                                   {'chat_name':'System', 'time':server_time,
                                    'type': 'you_sent_chat_report', 'target_user_id':target_uid, 'target_chat_name':target_chat_name},
                                   '', force = True, retmsg = retmsg)

        # check cooldown
        cdname = 'chat_report:%d' % target_uid
        if self.player.cooldown_active(cdname): return
        self.player.cooldown_trigger(cdname, gamedata['chat_report_cooldown'])

        # don't let gagged players make reports
        if (not self.user.chat_can_interact()) or self.player.stattab.get_player_stat('chat_gagged'): return

        if self.player.get_any_abtest_value('enable_chat_police', gamedata['enable_chat_police']):
            report_stack = Predicates.eval_cond_or_literal(gamedata['chat_report_send_stack'], self, self.player)
            if report_stack > 0:
                gamesite.msg_client.msg_send([{'to':[target_uid],
                                               'type': 'chat_report',
                                               'report_stack': report_stack,
                                               'expire_time': server_time + gamedata['chat_warn_duration']}])
                self.do_chat_send('DEVELOPER', '(%s) WARNED user %d x%d' % (self.user.country, target_uid, report_stack))
        else:
            self.do_chat_send('DEVELOPER', '(%s) REPORTED user %d' % (self.user.country, target_uid))

    def do_chat_report2(self, target_uid, channel, context_time, target_message_id):
        # ignore chat reports in prison region channels
        if channel.startswith('r:prison'): return

        # check cooldown
        if not self.player.is_developer():
            cdname = 'chat_report:%d' % target_uid
            if self.player.cooldown_active(cdname): return
            self.player.cooldown_trigger(cdname, gamedata['chat_report_cooldown'])

        # don't let gagged players make reports
        if (not self.user.chat_can_interact()) or self.player.stattab.get_player_stat('chat_gagged'): return

        # retrieve context
        context_list = gamesite.nosql_client.chat_get_context(channel, target_uid, context_time,
                                                              gamedata.get('chat_report_context_time', 120),
                                                              gamedata.get('chat_report_context_limit', 2), reason = 'do_chat_report2')

        ui_context_list = []
        target_chat_name = 'unknown'

        # target_message_id is untrusted client input, so don't pass it along in the report unless it matches something in the context
        found_message_id = None

        for x in context_list:
            if not x.get('text'): continue # system message or non-default template
            if 'chat_name' in x['sender']:
                target_chat_name = x['sender']['chat_name']
            if x['time'] == context_time or (target_message_id and x.get('id',None) == target_message_id):
                ui_text = '*** '+x['text']+' ***'
            else:
                ui_text = x['text']
            ui_context_list.append(ui_text)

            if target_message_id and x.get('id',None) == target_message_id:
                found_message_id = target_message_id

        # no messages found, or bogus message_id
        if (not ui_context_list) or \
           (target_message_id and (not found_message_id)):
            gamesite.exception_log.event(server_time, 'rejecting invalid chat report: message id %r channel %r context_time %r target_uid %r' % \
                                         (target_message_id, channel, context_time, target_uid))
            return

        ui_context = '\n'.join(ui_context_list)
        gamesite.nosql_client.chat_report(channel, self.user.user_id, self.user.get_chat_name(self.player),
                                          target_uid, target_chat_name, server_time, context_time, found_message_id, ui_context,
                                          source = 'player', reason = 'do_chat_report2')
        if 'chat_report_recipients' in SpinConfig.config:
            d = twisted.internet.utils.getProcessValue('./SpinReminders.py',
                                                       args = ['--from', '%s server' % SpinConfig.game_id_long(),
                                                               '--subject', '%s Player Chat Report (see [PCHECK](https://%sprod.spinpunch.com/PCHECK) )' % (SpinConfig.game_id_long().upper(), SpinConfig.game()),
                                                               '--body', ui_context.encode('utf-8'),
                                                               '--recipients', SpinJSON.dumps(SpinConfig.config['chat_report_recipients'])],
                                                       env = os.environ)
            d.addErrback(report_and_absorb_deferred_failure, self)

    def do_chat_send(self, channel, text, retmsg = None, bypass_gag = False, props = None):
        assert channel

        gagged = False
        if not bypass_gag:
            gagged = (not self.user.chat_can_interact()) or self.player.stattab.get_player_stat('chat_gagged')

        sender_info = {'time':server_time,
                       'chat_name': self.user.get_chat_name(self.player),
                       'user_id': self.user.user_id,
                       # summary dimensions for SQL logging. should NOT be revealed to clients!
                       # prefix with '_' to remind us to filter this out.
                       '_sum': self.player.get_denormalized_summary_props('brief')
                       }
        if self.user.facebook_id:
            sender_info['facebook_id'] = self.user.facebook_id

        if props:
            sender_info.update(props)

        if self.alliance_id_cache >= 0:
            sender_info['alliance_id'] = self.alliance_id_cache
            if self.alliance_info_cache and ('chat_tag' in self.alliance_info_cache):
                sender_info['alliance_tag'] = self.alliance_info_cache['chat_tag']

        # attach region info for chatted map coords
        if self.player.home_region:
            sender_info['home_region'] = self.player.home_region

        id = gamesite.nosql_id_generator.generate()

        if gamesite.chat_log:
            gamesite.nosql_client.chat_record(channel, id, sender_info, text, reason='do_chat_send(local)')
            gamesite.chat_log.event(server_time, {'chat_name': sender_info['chat_name'],
                                                  'id': id, 'channel': channel,
                                                  'user_id': self.user.user_id,
                                                  'player_level': self.player.resources.player_level,
                                                  'facebook_id': self.user.facebook_id,
                                                  'social_id': self.user.social_id,
                                                  'text': (u'(MUTED) ' if gagged else u'') + text})
        if gagged:
            if self.player.stattab.get_player_stat('chat_gagged'):
                # new-style gag - let the player know
                sender_info['type'] = 'you_are_gagged'
                self.chat_recv(channel, id, sender_info, '', force = True)
            else:
                # old-style gag - simulate a chat broadcast, but it only goes to the sender.
                self.chat_recv(channel, id, sender_info, text, force = True)

            # privately send to developers
            # gamesite.chat_mgr.send('DEVELOPER', None, sender_info, '(MUTED) '+text)

        else:
            gamesite.chat_mgr.send(channel, id, sender_info, text, exclude_listener = self)
            self.chat_recv(channel, id, sender_info, text, retmsg = retmsg)

        if (not props) or (props.get('type','default') in ('default','turf_winner',)):
            # only increment chat_messages_sent for genuine player-input messages
            # do not increment for automated messages like alliance join/kick/achieve/etc
            dict_increment(self.player.history, 'chat_messages_sent', 1)

    def send(self, msglist, flush_now = False):
        # rudimentary typo-checking
        assert isinstance(msglist, list)
        if len(msglist) > 0:
            assert isinstance(msglist[0], list)
            self.outgoing_messages += msglist
        if flush_now or gamedata['server'].get('deferred_message_coalesce_time',1) < 0:
            self.queue_flush_outgoing_messages()
        else:
            gamesite.gameapi.add_deferred_session(self)

    def queue_flush_outgoing_messages(self):
        if self.pending_flush_outgoing_messages: return
        self.pending_flush_outgoing_messages = reactor.callLater(0, self.do_flush_outgoing_messages)

    def do_flush_outgoing_messages(self):
        self.pending_flush_outgoing_messages = None

        gamesite.gameapi.handle_message_buffer(self, self.outgoing_messages)
        if self.is_async():
            # we're in the middle of further async processing - don't respond yet
            return

        if not self.logout_in_progress:
            gamesite.gameapi.run_deferred_actions(self, self.outgoing_messages, reason = 'flush_outgoing_messages')

        # send outgoing messages with current sync request(s)
        if self.sync_requests:
            while self.sync_requests:
                req = self.sync_requests[0]
                del self.sync_requests[0]
                gamesite.gameapi.complete_deferred_request(req, self, []) # OK - this is the "true" call
            return

        # send outgoing messages via longpoll
        if self.longpoll_request:
            if len(self.outgoing_messages) > 0 or self.logout_in_progress:
                request = self.longpoll_request
                if (not self.logout_in_progress) and self.longpoll_request_time < 0:
                    pass # reuse the same request again!
                else:
                    self.longpoll_request = None
                gamesite.gameapi.complete_longpoll(request, self)

    # function for sending chat messages to the client
    def chat_recv(self, channel, id, sender_info, text, force = False, retmsg = None, is_prepend = False):
        if (not force) and (not self.user.chat_can_interact()):
            return
        # map channel
        channel = self.encode_chat_channel_name(channel)

        # hide sender fields that clients should not know about (_sum table dimensions)
        sender_info_clean = dict((k,v) for k,v in sender_info.iteritems() if not k.startswith('_'))
        msg = ["CHAT_RECV", channel, sender_info_clean, SpinHTTP.wrap_string(text), id, is_prepend]
        if retmsg is not None:
            retmsg.append(msg)
        else:
            self.send([msg], flush_now = False) # coalesce to avoid ping storms

    # "pending" means the client has been notified and the clock is already ticking
    def incoming_attack_pending(self): return (self.incoming_attack_time > 0)

    def clear_objects(self):
        if self.cur_objects:
            for id, obj in self.cur_objects.objects.items():
                if obj.obj_id != id:
                    gamesite.exception_log.event(server_time, ('bad clear_objects id %d (player %d at %s obj %s ID %s)\n' % (id, self.player.user_id, self.viewing_base.base_id, obj.spec.name, repr(obj.obj_id))) + ''.join(traceback.format_stack()))

                self.rem_object(id)

        self.cur_objects = ObjectCollection()

    def num_objects(self): return len(self.cur_objects)

    def add_object(self, obj):
        # we have to set obj.team according to the relationship
        # between the player and the owner of the object

        if obj.team != -1:
            gamesite.exception_log.event(server_time, ('bad add_object team = %s (player %d at %s obj %s ID %s)\n' % (repr(obj.team), self.player.user_id, self.viewing_base.base_id, obj.spec.name, repr(obj.obj_id))) + ''.join(traceback.format_stack()))
            obj.team = -1

        if obj.owner is EnvironmentOwner:
            obj.team = 'environment'
        elif obj.owner is RogueOwner:
            obj.team = 'enemy'
        elif obj.owner is self.player:
            obj.team = 'player'
        else:
            obj.team = 'enemy'

        # set up environmental auras
        if obj.is_mobile():
            climate = gamedata['climates'].get(self.viewing_base.base_climate, None)
            if climate:
                if ('applies_aura' in climate):
                    if obj.auras is None: obj.auras = []
                    Aura.apply_aura(obj.auras, climate['applies_aura'], climate['aura_strength'], session_only = True)
                if obj.spec.climate_auras:
                    for aura in obj.spec.climate_auras:
                        if climate['name'] in aura['required_climates']:
                            if obj.auras is None: obj.auras = []
                            Aura.apply_aura(obj.auras, aura['aura_name'], aura['aura_strength'], session_only = True)

        return self.cur_objects.add_object(obj)

    def rem_object(self, id):
        obj = self.cur_objects.objects[id]

        if obj.obj_id != id:
             gamesite.exception_log.event(server_time, ('bad rem_object id %d (player %d at %s obj %s ID %d)\n' % (id, self.player.user_id, self.viewing_base.base_id, obj.spec.name, repr(obj.obj_id))) + ''.join(traceback.format_stack()))

        # remove environmental auras
        if obj.auras: Aura.prune_auras(obj.auras, is_session_change = True)
        obj.team = -1

        return self.cur_objects.rem_object(id)
    def get_object(self, id):
        return self.cur_objects.objects[id]
    def get_object_if_exists(self, id):
        return self.cur_objects.objects.get(id, None)
    def has_object(self, id):
        return self.cur_objects and self.cur_objects.has_object(id)
    def iter_objects(self): return self.cur_objects.iter_objects()

    def open_attack_log(self, attack_end_time, attacker_id, defender_id, base_id = None):
        if self.player.tutorial_state != "COMPLETE":
            attacker_id = -1
            defender_id = -1
        self.attack_log = AttackLog(server_time, attacker_id, defender_id, base_id)

        if gamedata['server'].get('enable_damage_log',True) and self.player.tutorial_state == "COMPLETE":
            self.damage_log = GameObjectDamageLog(self.viewing_base.base_id, observer = self.player)

        replay_token = None
        if self.attack_log.is_active():
            replay_token = generate_mail_id() # just a random token
            expire_time = attack_end_time + gamedata['server'].get('battle_replay_receive_time',600)
            self.attack_replay_receivers[replay_token] = AttackReplayReceiver(self.user.user_id, server_time, expire_time, attacker_id, defender_id, base_id)
        return replay_token

    def reset_attack_log(self):
        if self.attack_log:
            self.attack_log.close()
            self.attack_log = None
        self.damage_log = None

    def log_attack_units(self, owner_id, obj_list, event_name, props = None):
        for obj in sorted(obj_list, key = lambda obj: (obj.spec.kind, obj.spec.name)):
            if obj.is_mobile() or obj.spec.history_category in ('turrets','turret_emplacements'):
                self.log_attack_unit(owner_id, obj, event_name, props = props)
    def _log_attack_unit_props(self, obj, props = None, fake_xy = None, killer_info = None, method = None):
        if props is None:
            props = {}
        if fake_xy:
            x, y = fake_xy
        else:
            x, y = obj.x, obj.y
        props['unit_type'] = obj.spec.name
        props['x'] = x
        props['y'] = y
        props['level'] = obj.level
        props['hp'] = obj.hp
        props['obj_id'] = obj.obj_id

        if gamedata['server'].get('log_battles',1) >= 2:
            props['state'] = obj.serialize_state()

        # record turret head info
        if obj.is_building():
            for item in Equipment.equip_iter(obj.equipment):
                spec = gamedata['items'].get(item['spec'], None)
                if spec:
                    if Equipment.is_turret_head_item_spec(spec):
                        props['turret_head'] = item
                        break

        attacker_user_id = -1

        if killer_info:
            if (killer_info['spec'] not in gamedata['units']) and (killer_info['spec'] not in gamedata['buildings']) and (killer_info['spec'] not in gamedata['inert']):
                gamesite.exception_log.event(server_time, 'log_attack_unit by %d: unknown spec %s' % (self.player.user_id, killer_info['spec']))
                killer_info = None

        if killer_info:
            if killer_info['team'] == 'player':
                attacker_user_id = self.player.user_id
            elif self.home_base:
                if self.incoming_attack_id > 0:
                    attacker_user_id = self.incoming_attack_id
                else:
                    gamesite.exception_log.event(server_time, 'log_attack_unit by %d: team %s at home but no incoming_attack_id' % (self.player.user_id, killer_info['team']))
                    killer_info = None
            else:
                attacker_user_id = self.viewing_player.user_id

        if killer_info:
            props['attacker_user_id'] = attacker_user_id
            props['attacker_type'] = killer_info['spec']
            props['attacker_level'] = killer_info['level']
            if 'id' in killer_info: props['attacker_obj_id'] = killer_info['id']
            for EXTRA in ('spellname','mine','turret_head','ambush'): # extra metadata on the killer
                if EXTRA in killer_info: props['attacker_'+EXTRA] = killer_info[EXTRA]

        if method:
            props['method'] = method

        return props

    def log_attack_unit(self, owner_id, obj, event_name, props = None, fake_xy = None, killer_info = None, method = None):
        self.attack_event(owner_id, event_name, self._log_attack_unit_props(obj, props = props, fake_xy = fake_xy, killer_info = killer_info, method = method))

    def attack_event(self, user_id, event_name, props = None):
        if self.attack_log is None:
            if gamedata['server']['log_self_attacks']:
                gamesite.exception_log.event(server_time, 'attack_event with no open log! user ' + str(user_id))
            return

        # fake attacking player ID
        if user_id == RogueOwner.user_id and self.incoming_attack_id > 0:
            user_id = self.incoming_attack_id

        if props is None:
            props = {}
        props['code'] = int(event_name[0:4])
        props['event_name'] = event_name
        props['user_id'] = user_id
        self.attack_log.event(props)

    # record the expenditure of a consumable item during the current battle
    def attack_item_expended(self, user_id, specname, stack):
        if str(user_id) not in self.items_expended: self.items_expended[str(user_id)] = {}
        dict_increment(self.items_expended[str(user_id)], specname, stack)

    def increment_player_metric(self, counter, amount, time_series = True, bucket = False, bucket_size = None):
        return record_player_metric(self.player, dict_increment, counter, amount, time_series=time_series, bucket=bucket, bucket_size=bucket_size)
    def setmax_player_metric(self, counter, amount, time_series = True, bucket = False, bucket_size = None):
        return record_player_metric(self.player, dict_setmax, counter, amount, time_series=time_series, bucket=bucket, bucket_size=bucket_size)
    def setvalue_player_metric(self, counter, amount, time_series = True, bucket = False, bucket_size = None):
        return record_player_metric(self.player, dict_setvalue, counter, amount, time_series=time_series, bucket=bucket, bucket_size=bucket_size)

    # call this to record tech progress in player.history when a new tech level is reached
    def do_tech_metric(self, setmax, player, tech):
        # 1) tech:foo_production for individual techs
        setmax('tech:'+tech.name, player.tech[tech.name])

        unit_spec = tech.unlocks_unit()
        if unit_spec:
            # 1a) foo_unlocked for individual units
            setmax('unit:'+unit_spec.name+':unlocked', 1)

            # 2) rovers/transports/gunships_unlocked for tech lines (# of units unlocked)
            category = unit_spec.manufacture_category
            setmax(category+'_unlocked', sum([1 for k, v in player.tech.iteritems() if (k in gamedata['tech'] and v >= 1 and TechSpec.lookup(k).unlocks_unit_category() == category)]))
            setmax(category+'_researched', sum([v for k, v in player.tech.iteritems() if (k in gamedata['tech'] and TechSpec.lookup(k).unlocks_unit_category() == category)]))
            setmax('units_unlocked', sum([1 for k, v in player.tech.iteritems() if (k in gamedata['tech'] and v >= 1 and TechSpec.lookup(k).unlocks_unit())]))
            setmax('units_researched', sum([v for k, v in player.tech.iteritems() if (k in gamedata['tech'] and TechSpec.lookup(k).unlocks_unit())]))

        mod_spec = tech.mods_unit()
        if mod_spec:
            setmax('mod_techs_unlocked', sum([1 for k, v in player.tech.iteritems() if (k in gamedata['tech'] and v >= 1 and TechSpec.lookup(k).mods_unit())]))
            setmax('mod_techs_researched', sum([v for k, v in player.tech.iteritems() if (k in gamedata['tech'] and TechSpec.lookup(k).mods_unit())]))

        # 4) techs_unlocked/researched (overall)
        setmax('techs_unlocked', sum([1 for k, v in player.tech.iteritems() if k in gamedata['tech']]))
        setmax('techs_researched', sum([v for k, v in player.tech.iteritems() if k in gamedata['tech']]))

    def tech_player_metric(self, tech):
        self.do_tech_metric(self.setmax_player_metric, self.player, tech)

    # for debug printing, show ladder state for current battle
    def format_ladder_state(self):
        if not self.ladder_state: return ''
        return '%d (L%d CC%d %dpts) %+d/%+d vs %d (L%d CC%d %dpts) %+d/%+d' % \
               (self.player.user_id, self.player.resources.player_level, self.player.get_townhall_level(), self.player.ladder_points(), self.ladder_state['points']['victory'][str(self.player.user_id)], self.ladder_state['points']['defeat'][str(self.player.user_id)],
                self.viewing_player.user_id, self.viewing_player.resources.player_level, self.viewing_player.get_townhall_level(), self.viewing_player.ladder_points(), self.ladder_state['points']['victory'][str(self.viewing_player.user_id)], self.ladder_state['points']['defeat'][str(self.viewing_player.user_id)])

    def spawn_new_units_for_player(self, player, retmsg, units, temporary = False,
                                   limit_break = False,
                                   limit_reduce_qty = False,
                                   xyloc = None, xyscatter = None, persist = False,
                                   ai_state = None, ai_target = None, ai_aggressive = None,
                                   pack_id = None, behaviors = None, unit_health_modifier = 1.0):
        new_objects = spawn_units(player, self.viewing_base if temporary else player.my_home, units, temporary = temporary, limit_break = limit_break, limit_reduce_qty = limit_reduce_qty, xyloc = xyloc, xyscatter = xyscatter, observer = self.player, persist = persist,
                                  ai_state = ai_state, ai_target = ai_target, ai_aggressive = ai_aggressive, pack_id = pack_id, behaviors = behaviors, unit_health_modifier = unit_health_modifier)
        for obj in new_objects:
            if (not temporary) and (player is self.player):
                player.send_army_update_one(obj, retmsg)
                if(obj.squad_id == SQUAD_IDS.RESERVES):
                    retmsg.append(["MANUFACTURE_OVERFLOW_TO_RESERVES", obj.obj_id])

            # add objects to session, if temp objects, or currently looking at the owner's base
            if (self.has_attacked or gamedata.get('enable_defending_units',True)) and \
               (temporary or (self.viewing_base is player.my_home and ((obj.squad_id or 0) == SQUAD_IDS.BASE_DEFENDERS))):
                self.add_object(obj)
                retmsg.append(["OBJECT_CREATED2", obj.serialize_state()])
                if obj.auras:
                    retmsg.append(["OBJECT_AURAS_UPDATE", obj.serialize_auras()])

        return new_objects

    def take_units_from_player(self, player, retmsg, units):
        taken_objects = []

        togo = copy.deepcopy(units)
        for obj in player.home_base_iter():
            if obj.is_mobile():
                if obj.spec.name in togo:
                    togo[obj.spec.name] -= 1
                    if togo[obj.spec.name] <= 0:
                        del togo[obj.spec.name]
                    taken_objects.append(obj)

        for obj in taken_objects:
            player.unit_repair_cancel(obj)
            player.home_base_remove(obj)

        for obj in taken_objects:
            if self.has_object(obj.obj_id):
                retmsg.append(["OBJECT_REMOVED2", obj.obj_id])
                self.rem_object(obj.obj_id)
            if player is self.player:
                player.send_army_update_destroyed(obj, retmsg) # may be redundant with OBJECT_REMOVED2

        return taken_objects

    def spawn_security_team(self, player, retmsg, source_obj, xyloc, unit_dic, spread, persist,
                            ai_state = None, ai_target = None, ai_aggressive = None,
                            pack_aggro = False, behaviors = None,
                            parent_last_hp = 0,
                            inherit_parent_damage = 0, inherit_parent_damage_threshold = 0):
        if source_obj.is_mobile():
            event_name = '3971_security_team_spawned_from_unit'
            if spread < 0: spread = 0
            scatter = [spread, spread]
        else:
            event_name = '3970_security_team_spawned'
            if spread < 0: spread = 1
            scatter = [spread*gamedata['guard_deploy_spread']*source_obj.spec.unit_collision_gridsize[0]//2,
                       spread*gamedata['guard_deploy_spread']*source_obj.spec.unit_collision_gridsize[1]//2]

        # determine how much health the secteam units should have
        # see Consequents.py for the meaning of these parameters

        unit_health_modifier = 1.0
        if inherit_parent_damage > 0:
            # note: use parent_last_hp instead of source_obj.hp here
            # for peaceful retreats, we want to use the parent's original HP before the retreat code set it to zero
            parent_health = float(parent_last_hp)/source_obj.max_hp
            if parent_health <= inherit_parent_damage_threshold:
                # reduce secteam unit health by inherit_parent_damage as a proportion of the parent's health loss
                unit_health_modifier = 1.0 + inherit_parent_damage * (parent_health - 1.0)

        if pack_aggro:
            # set up pack aggro for the whole team
            pack_id = 'pack-%d-%d-%d' % (server_time, xyloc[0], xyloc[1])
            if behaviors is None:
                behaviors = ['pack_aggro']
            else:
                assert 'pack_aggro' in behaviors

        else:
            pack_id = None

        units = self.spawn_new_units_for_player(player, retmsg, unit_dic, temporary = True, xyloc = xyloc, xyscatter = scatter, persist = persist, ai_state = ai_state, ai_target = ai_target, ai_aggressive = ai_aggressive, pack_id = pack_id, behaviors = behaviors, unit_health_modifier = unit_health_modifier)
        self.log_attack_units(player.user_id, units, event_name,
                              props = {'source_obj_specname': source_obj.spec.name,
                                       'source_obj_level': source_obj.level})
        if self.damage_log: self.damage_log.init_multi(units)

    def give_tech(self, player, retmsg, tech_name, level, lab, method, give_xp = True):
        assert player is self.player
        spec = player.get_abtest_spec(TechSpec, tech_name)

        current = player.tech.get(tech_name, 0)
        if current >= level: return

        # cancel any ongoing research of this tech
        for obj in player.home_base_iter():
            if obj.is_building() and obj.is_researcher():
                if obj.research_item == tech_name:
                    gamesite.gameapi.do_cancel_research(self, retmsg, obj)

        player.tech[tech_name] = level
        self.deferred_stattab_update = True
        player.update_unit_levels(self.player, tech_name, self, retmsg)

        if give_xp:
            # award XP for each level achieved along the way
            xp = 0
            for step in xrange(current+1, level+1):
                override = TechSpec.get_leveled_quantity(spec.upgrade_xp, step)
                if override >= 0:
                    xp += override
                else:
                    xp += int(gamedata['player_xp']['research'] * \
                              sum((TechSpec.get_leveled_quantity(getattr(spec, 'cost_'+res), step) for res in gamedata['resources']), 0))

            gamesite.gameapi.give_xp_to(self, player, retmsg, xp, 'research', [lab.x,lab.y] if lab else None, obj_session_id = lab.obj_id if lab else None)

        if player is self.player:
            tech_reply = "TECH_UPDATE"
            state_reply = "PLAYER_STATE_UPDATE"
        elif player is self.viewing_player:
            tech_reply = "ENEMY_TECH_UPDATE"
            state_reply = "ENEMY_STATE_UPDATE"
        else:
            tech_reply = None
            state_reply = None
        if tech_reply is not None:
            retmsg.append([tech_reply, player.tech])
            retmsg.append([state_reply, player.resources.calc_snapshot().serialize(enemy = (state_reply == "ENEMY_STATE_UPDATE"))])
            if player is self.player:
                retmsg.append(["NEW_TECH", tech_name, self.player.tech[tech_name], lab.obj_id if lab else None])

        self.deferred_stattab_update = True

        # send metrics
        if 0 or LOTS_OF_METRICS: metric_event_coded(object.owner.user_id, '3080_research_tech', {'tech_type':tech_name, 'level':level, 'method':method})
        mevent = TechSpec.get_leveled_quantity(spec.metric_events, level)
        if mevent: metric_event_coded(player.user_id, mevent, {})

        if player is self.player:
            self.tech_player_metric(spec)
            unl = spec.unlocks_unit()
            if unl and level == 1:
                self.user.create_fb_open_graph_action_unlock_unit(unl.name)
        else:
            gamesite.exception_log.event(server_time, 'tech completion for non-session.player! %d' % player.user_id)

    # pass-through apply/remove aura functions that take care of performing stattab and client updates
    def apply_player_aura(self, specname, *args, **kwargs):
        if self.player.apply_aura(specname, *args, **kwargs):
            self.deferred_player_auras_update = True
            self.deferred_stattab_update = True
            return True
        return False

    def remove_player_aura(self, *args, **kwargs):
        if self.player.remove_aura(*args, **kwargs):
            self.deferred_player_auras_update = True
            self.deferred_stattab_update = True
            return True
        return False

    def apply_regional_auras(self):
        attacker_aura_list = gamedata.get('default_player_auras',[])

        if self.player.home_region and (self.player.home_region in gamedata['regions']) and \
           ('auras' in gamedata['regions'][self.player.home_region]):
            attacker_aura_list += gamedata['regions'][self.player.home_region]['auras']

        defender_aura_list = attacker_aura_list + gamedata.get('defender_auras',[])

        # all regional auras should go away on session change
        assert all(gamedata['auras'][data['aura_name']].get('ends_on') == 'session_change' for data in defender_aura_list)

        # apply (attacker) auras to self.player
        for data in attacker_aura_list:
            self.apply_player_aura(data['aura_name'], strength = data.get('aura_strength',1), duration = data.get('aura_duration',-1), level = data.get('aura_level',1
), stack = data.get('stack',-1), ignore_limit = True)

        # apply (defender) auras to self.viewing_player
        if self.viewing_player is not self.player:
            for data in defender_aura_list:
                self.viewing_player.apply_aura(data['aura_name'], strength = data.get('aura_strength',1), duration = data.get('aura_duration',-1), level = data.get('aura_level',1), stack = data.get('stack',-1), ignore_limit = True)

        self.deferred_player_auras_update = True

    def give_enhancement(self, player, retmsg, obj, enh_name, level, method, give_xp = True):
        assert player is self.player
        spec = player.get_abtest_spec(EnhancementSpec, enh_name)

        current = obj.enhancements.get(enh_name,0) if obj.enhancements else 0
        if current >= level: return

        # cancel any ongoing research of this tech
        if obj.is_enhancing() and obj.enhancing.enhance_state['spec'] == enh_name:
            gamesite.gameapi.do_cancel_enhance(self, retmsg, obj)

        if obj.enhancements is None: obj.enhancements = {}
        obj.enhancements[enh_name] = level

        self.viewing_base.nosql_write_one(obj, 'give_enhancement', fields = ['enhancements', 'enhancing'])

        self.deferred_stattab_update = True

        if give_xp:
            # award XP for each level achieved along the way
            xp = 0
            for step in xrange(current+1, level+1):
                override = EnhancementSpec.get_leveled_quantity(spec.xp, step)
                if override >= 0:
                    xp += override
                else:
                    xp += int(gamedata['player_xp'].get('enhance',0) * \
                              sum((EnhancementSpec.get_leveled_quantity(getattr(spec, 'cost_'+res), step) for res in gamedata['resources']), 0))

            gamesite.gameapi.give_xp_to(self, player, retmsg, xp, 'enhance', [obj.x,obj.y], obj.obj_id)

        if player is self.player:
            retmsg.append(["NEW_ENHANCEMENT", obj.obj_id, enh_name, level])
            self.deferred_stattab_update = True

        self.deferred_object_state_updates.add(obj)

    # check for forced expirations of an inventory item by spec
    def get_item_spec_forced_expiration(self, spec, prev_expire_time = -1, ref_time = None):
        expire_time = prev_expire_time
        if ref_time is None: ref_time = self.player.get_absolute_time()
        if 'force_duration' in spec:
            force_duration = Predicates.eval_cond_or_literal(spec['force_duration'], self, self.player)
            if force_duration > 0: expire_time = min(force_duration+ref_time, expire_time) if (expire_time > 0) else force_duration+ref_time
        if 'force_expire_by' in spec:
            expire_by_data = Predicates.eval_cond_or_literal(spec['force_expire_by'], self, self.player)
            if isinstance(expire_by_data, dict): # event-driven
                neg_time_to_end = self.player.get_event_time(expire_by_data.get('event_kind','current_event'), expire_by_data.get('event_name',None), 'end', ignore_activation = True, t_offset = ref_time - self.player.get_absolute_time())
                if neg_time_to_end is None: # event not active!
                    expire_by = -1
                else:
                    expire_by = ref_time + (-neg_time_to_end)
            else: # literal int
                assert isinstance(expire_by_data, int)
                expire_by = expire_by_data
            if expire_by > 0: expire_time = min(expire_by, expire_time) if (expire_time > 0) else expire_by
        return expire_time

    def get_loot_items(self, player, loot_table, item_duration, item_expire_at, duration_ref_time = None, override_time = None):
        assert player is self.player

        absolute_time = player.get_absolute_time()
        if duration_ref_time is None:
            duration_ref_time = absolute_time

        loot = LootTable.get_loot(gamedata['loot_tables'], loot_table,
                                  rand_func = player.random_source.random,
                                  cond_resolver = lambda pred: Predicates.read_predicate(pred).is_satisfied2(self, player, None, override_time = override_time))
        if item_expire_at > 0:
            expire_time = item_expire_at
        elif item_duration > 0:
            expire_time = duration_ref_time + item_duration
        else:
            expire_time = -1

        if (expire_time > 0) and (expire_time < absolute_time): return [] # all items already expired

        to_remove = []
        for item in loot:
            spec = gamedata['items'].get(item['spec'], None)
            if not spec:
                gamesite.exception_log.event(server_time, 'get_loot_items(): player %d got invalid item "%s"' % (player.user_id, item['spec']))
                to_remove.append(item)
                continue

            # check for expiration timers on individual items
            item_expire_time = expire_time
            if item.get('item_expire_at',-1) > 0:
                item_expire_time = min(item['item_expire_at'], item_expire_time) if (item_expire_time > 0) else item['item_expire_at']
                del item['item_expire_at']
            if item.get('item_duration',-1) > 0:
                item_expire_time = min(item['item_duration']+duration_ref_time, item_expire_time) if (item_expire_time > 0) else item['item_duration']+duration_ref_time
                del item['item_duration']

            # allow items.json entry to force expiration
            item_expire_time = self.get_item_spec_forced_expiration(spec, prev_expire_time = item_expire_time, ref_time = duration_ref_time)

            if item_expire_time > 0:
                if item_expire_time < absolute_time: # item already expired
                    to_remove.append(item)
                    continue
                item['expire_time'] = item_expire_time

            # special case: token quantity boost
            if spec.get('category') == 'token':
                stack_mult = player.stattab.get_player_stat('loot_factor_tokens')
                if stack_mult != 1:
                    item['stack'] = int(item.get('stack',1) * stack_mult + 0.5)

        for item in to_remove:
            loot.remove(item)
        return loot

    def give_loot(self, player, retmsg, loot_table, reason, mail_template = None, item_duration = -1, item_expire_at = -1, reason_id = None,
                  force_send_by_mail = False, show_items_discovered = False):
        loot = self.get_loot_items(player, loot_table, item_duration, item_expire_at)
        if not loot: return []

        inventory_log_reason = reason
        if reason == 'ai_base':
            str_reason = 'AI %d (%s L%d)' % (self.viewing_player.user_id, self.viewing_user.get_ui_name(self.viewing_player), self.viewing_player.resources.player_level)
        elif reason == 'ai_attack':
            str_reason = 'AI attack by %d' % self.incoming_attack_id
        elif reason == 'quest':
            str_reason = 'quest:' + str(reason_id)
        elif reason == 'level_up':
            str_reason = 'level_up:' + str(player.resources.player_level)
        elif reason == 'special':
            str_reason = 'special'
        elif reason == 'refund':
            str_reason = 'refund:'+str(reason_id)
        elif reason == 'promo_code':
            str_reason = 'promo_code:'+reason_id
        elif reason == 'login_incentive':
            str_reason = 'login_incentive:'+str(reason_id)
            inventory_log_reason = str_reason # log the day number here
        else:
            gamesite.exception_log.event(server_time, 'unknown give_loot reason %s!' % reason)
            return []

        discovered_where = None

        # send modally?
        if (reason not in ('quest','level_up')) and (not force_send_by_mail) and \
           player.get_any_abtest_value('modal_looting', gamedata['modal_looting']) and \
           player.find_object_by_type(gamedata['inventory_building']):
            discovered_where = 'loot_buffer'
            player.loot_buffer += loot
            for item in loot:
                player.inventory_log_event('5125_item_obtained', item['spec'], item.get('stack',1), item.get('expire_time',-1), level=item.get('level',None), reason=inventory_log_reason)
        elif reason == 'ai_base':
            discovered_where = 'messages'
            player.send_loot_mail(self.viewing_user.get_ui_name(self.viewing_player), self.viewing_player.resources.player_level,
                                  loot, retmsg, mail_template = mail_template)
        elif reason == 'ai_attack':
            discovered_where = 'messages'
            ai_id = self.incoming_attack_id
            if str(ai_id) in gamedata['ai_bases_server']['bases']:
                base = gamedata['ai_bases_server']['bases'][str(ai_id)]
                player.send_loot_mail(base['ui_name'], base['resources']['player_level'],
                                      loot, retmsg, mail_template = mail_template)
            else:
                gamesite.exception_log.event(server_time, 'unknown give_loot ai_attack %s!' % repr(ai_id))
                return []
        elif reason == 'quest':
            discovered_where = 'messages'
            player.send_loot_mail(gamedata['quests'][reason_id]['ui_name'], 0, loot, retmsg, mail_template = mail_template or 'quest_reward_mail')
        elif reason == 'level_up':
            discovered_where = 'messages'
            player.send_loot_mail(str(player.resources.player_level), 0, loot, retmsg, mail_template = 'level_up_reward_mail')

        elif reason == 'special' and all(x['spec'] == 'gamebucks' for x in loot) and show_items_discovered:
            # special case when the only loot given is gamebucks - send "fungibly" instead of by message
            discovered_where = 'inventory'
            player.resources.gain_gamebucks(sum((x.get('stack',1) for x in loot), 0), reason='give_loot')
            retmsg.append(["PLAYER_STATE_UPDATE", player.resources.calc_snapshot().serialize()])

        elif reason in ('special','refund','promo_code'):
            discovered_where = 'messages'
            if mail_template is None:
                gamesite.exception_log.event(server_time, 'give_loot with %s reason must include a mail_template!' % reason)
                return []
            player.send_loot_mail('', 0, loot, retmsg, mail_template = mail_template)

        self.increment_player_metric('items_looted', len(loot), time_series = False)

        if gamedata['server']['log_item_loot'] >= 1:
            metric_event_coded(self.player.user_id, '3870_loot_given', {'items':copy.deepcopy(loot),
                                                                        'where':self.viewing_base.base_id if self.viewing_base else 'unknown',
                                                                        'reason':str_reason})
            if gamedata['server']['log_item_loot'] >= 2:
                gamesite.exception_log.event(server_time, 'player %d looted from %s: %s' % \
                                             (self.player.user_id, str_reason, repr(loot)))

        # for loot earned from AI fights, add to session.loot so that the victory dialog will display it
        add_to_session_loot = (reason in ('ai_base', 'ai_attack'))

        if add_to_session_loot and loot:
            if 'items' not in self.loot:
                self.loot['items'] = []
            self.loot['items'] += copy.deepcopy(loot)

        if show_items_discovered and discovered_where and loot:
            retmsg.append(["ITEMS_DISCOVERED", copy.deepcopy(loot), -1, discovered_where])

        return copy.deepcopy(loot)

    def give_trophies(self, player, kind, amount):
        assert self.has_attacked
        assert kind in ('pve','pvp','pvv')
        key = 'trophies_'+kind

        assert (player is self.player) or (player is self.viewing_player)
        if player is self.player:
            pass
        elif player is self.viewing_player:
            key = 'viewing_'+key

        dict_increment(self.loot, key, amount)

    def claim_battle_star(self, name):
        assert name in gamedata.get('battle_stars',{})
        if name in self.loot.get('battle_stars',{}): return False # already claimed
        if not Predicates.read_predicate(gamedata['battle_stars'][name]).is_satisfied2(self, self.player, None):
            return False
        if 'battle_stars' not in self.loot: self.loot['battle_stars'] = {}
        self.loot['battle_stars'][name] = 1
        return True
    def claim_all_battle_stars(self):
        for name, pred in gamedata.get('battle_stars',{}).iteritems():
            if name not in self.loot.get('battle_stars',{}):
                self.claim_battle_star(name)

    def heal_all_units(self, retmsg):
        for obj in self.player.home_base_iter():
            if obj.is_mobile() and obj.is_damaged():
                self.player.unit_repair_cancel(obj, force_refund = True)
                obj.heal_to_full()
                if self.has_object(obj.obj_id): # don't send updates for zombie units, since they aren't in the session
                    retmsg.append(["OBJECT_STATE_UPDATE2", obj.serialize_state()])
                else:
                    self.player.send_army_update_one(obj, retmsg)

        # heal deployed units (if we can)
        if gamesite.nosql_client and self.player.home_region:
            states = gamesite.nosql_client.get_mobile_objects_by_owner(self.player.home_region, self.player.user_id, reason='heal_all_units')
            for state in states:
                if state.get('hp_ratio',1) < 1 or (state.get('hp',state.get('max_hp',0)) < state.get('max_hp',0)):
                    gamesite.nosql_client.heal_mobile_object_by_id(self.player.home_region, state['obj_id'], reason='heal_all_units')
                    if 'hp_ratio' in state: del state['hp_ratio']
                    if 'hp' in state: del state['hp']
            retmsg.append(["PLAYER_ARMY_UPDATE", filter(lambda x: x is not None, [self.player.strip_fields_for_army_update(state) for state in states])])

        self.player.unit_repair_send(retmsg)

    def heal_all_buildings(self, retmsg):
        for obj in self.player.home_base_iter():
            if obj.is_building() and obj.is_damaged():
                obj.heal_to_full()
                if self.has_object(obj.obj_id):
                    retmsg.append(["OBJECT_STATE_UPDATE2", obj.serialize_state()])

        self.power_changed(self.viewing_base, None, retmsg)

    # send any one-time ad network events whose predicates have become true
    def adnetworks(self):
        ret = []
        for api, context in [('adotomi', self.user.adotomi_context),
                             ('dauup', self.user.dauup_context),
                             ('dauup2', self.user.dauup2_context),
                             ('adparlor', self.user.adparlor_context),
                             ('liniad', self.user.liniad_context),
                             ('battlehouse', self.user.bh_id),
                             ('battlehouse_client', self.user.bh_id if (self.user.frame_platform == 'bh') else None), # only run within BH.com frame
                             ('mailchimp', self.user.get_mailchimp_context()),
                             ('fb_conversion_pixels', self.user.fb_conversion_pixels_context),
                             ('fb_app_events', True if (self.user.frame_platform == 'fb') else None),
                             ('kg_conversion_pixels', self.user.kg_conversion_pixels_context),
                             ]:
            if not context: continue
            if (api not in gamedata['adnetworks']): continue
            if ('master_filter' in gamedata['adnetworks'][api]) and \
               (not Predicates.read_predicate(gamedata['adnetworks'][api]['master_filter']).is_satisfied(self.player, None)):
                continue
            ret.append((api, context))
        return ret

    def send_adnetwork_events(self, retmsg):
        for api, context in self.adnetworks():
            for name in gamedata['adnetworks'][api]['events'].iterkeys():
                self.send_adnetwork_event_conditional(retmsg, api, context, name)

    def send_adnetwork_acquisition_event(self, retmsg):
        for api, context in self.adnetworks():
            self.send_adnetwork_event_conditional(retmsg, api, context, 'acquisition_event')
    def send_adnetwork_visit_event(self, retmsg):
        for api, context in self.adnetworks():
            if 'visit_event' in gamedata['adnetworks'][api]:
                self.do_send_adnetwork_event(retmsg, api, context, 'visit_event', gamedata['adnetworks'][api]['visit_event'])

    def send_adnetwork_purchase_event(self, retmsg, order_id, post_fbtax_dollars):
        for api, context in self.adnetworks():
            if 'purchase_event' in gamedata['adnetworks'][api]:
                self.do_send_adnetwork_event(retmsg, api, context,
                                             'purchase_event', gamedata['adnetworks'][api]['purchase_event'],
                                             order_id = order_id,
                                             post_fbtax_dollars = post_fbtax_dollars,
                                             currency = 'USD')

    def send_adnetwork_event_conditional(self, retmsg, api, context, name):
        if not context: return
        if name not in gamedata['adnetworks'][api]['events']: return

        data = gamedata['adnetworks'][api]['events'][name]
        history_key = api+':'+name
        status = self.player.history.get(history_key, 0)
        if status:
            # already sent the event, don't send it again
            if gamedata['server'].get('log_'+api,1) and 0:
                gamesite.exception_log.event(server_time, '%s API for user %d gen %d: already sent event %s (%s), skipping' % \
                                             (api, self.user.user_id, self.player.generation, name, history_key))
            return

        if not Predicates.read_predicate(data['predicate']).is_satisfied2(self, self.player, None): return

        if gamedata['server'].get('log_'+api,1) and 0:
            gamesite.exception_log.event(server_time, '%s API for user %d gen %d: event %s (%s) status %s' % \
                                         (api, self.user.user_id, self.player.generation, name, history_key, str(status)))

        if self.do_send_adnetwork_event(retmsg, api, context, name, data):
            # mark event as sent
            self.player.history[history_key] = 1

    # send one event to the ad network API. Return false if the send was blocked by the server configuration.
    def do_send_adnetwork_event(self, retmsg, api, context, name, data, *args, **kwargs):
        if not context: return False

        if 'fb_app_event' in data:
            return self.do_send_adnetwork_event_fb_app_event(retmsg, api, context, name, data, *args, **kwargs)
        elif ('client' in data) or ('client_bh' in data):
            return self.do_send_adnetwork_event_clientside(retmsg, api, context, name, data, *args, **kwargs)
        else:
            return self.do_send_adnetwork_event_serverside(retmsg, api, context, name, data, *args, **kwargs)

    def do_send_adnetwork_event_fb_app_event(self, retmsg, api, context, name, data, order_id = None, post_fbtax_dollars = None, currency = None):
        if (retmsg is None):
            if gamedata['server'].get('log_'+api,1):
                gamesite.exception_log.event(server_time, '%s API for user %d (%s): cannot send at logout, will send on next login' % \
                                             (api, self.user.user_id, name))
            return False

        log_props = {'user_id': self.user.user_id, 'kpi': name, 'name': data['fb_app_event']['name']}
        for FIELD in ('value', 'params'):
            if FIELD in data['fb_app_event']:
                log_props[FIELD] = data['fb_app_event'][FIELD]

        if gamedata['server'].get('log_'+api,1):
            gamesite.exception_log.event(server_time, '%s API for user %d (%s): %s' % \
                                         (api, self.user.user_id, name, '(sent)' if gamedata.get('enable_fb_app_events', False) else '(disabled)'))

        if gamedata.get('enable_fb_app_events', False):
            self.user.log_adnetwork_event(api, log_props) # don't bother logging unless enabled
            retmsg.append(["FB_APP_EVENT", data['fb_app_event']['name'], data['fb_app_event'].get('value',None), data['fb_app_event'].get('params',None)])
            return True
        else:
            return False

    def do_send_adnetwork_event_clientside(self, retmsg, api, context, name, data, order_id = None, post_fbtax_dollars = None, currency = None):
        #gamesite.exception_log.event(server_time, "HERE CLIENT %s %s" % (api, name))
        if (retmsg is None):
            if gamedata['server'].get('log_'+api,1):
                gamesite.exception_log.event(server_time, '%s API for user %d (%s): cannot send at logout, will send on next login' % \
                                             (api, self.user.user_id, name))
            return False

        log_props = {'user_id': self.user.user_id, 'kpi': name, 'context': context}
        if post_fbtax_dollars is not None: log_props['post_fbtax_dollars'] = post_fbtax_dollars
        if currency is not None: log_props['currency'] = currency
        self.user.log_adnetwork_event(api, log_props)

        if 'client' in data:
            # just a URL to hit
            msg = "CLIENT_TRACKING_PIXEL_IMAGE"
            arg = data['client']
            if post_fbtax_dollars is not None:
                arg = arg.replace('$POST_FBTAX_DOLLARS', '%.2f' % post_fbtax_dollars)
        elif 'client_bh' in data:
            # bh.com postMessage event
            msg = "CLIENT_TRACKING_PIXEL_BH"
            arg = data['client_bh']

        if gamedata['server'].get('log_'+api,1):
            gamesite.exception_log.event(server_time, '%s API for user %d (%s): %r %s' % \
                                         (api, self.user.user_id, name, arg, '(sent)' if SpinConfig.config.get('enable_'+api,False) else '(disabled)'))

        if SpinConfig.config.get('enable_'+api,False):
            retmsg.append([msg, arg, 0])
            return True
        else:
            return False

    def do_send_adnetwork_event_serverside(self, retmsg, api, context, name, data, order_id = None, post_fbtax_dollars = None, currency = None, extra_qs = {}):
        #gamesite.exception_log.event(server_time, "HERE SERVER %s %s" % (api, name))
        # construct query string
        params = {}

        context_key = data.get('context_key', gamedata['adnetworks'][api].get('context_key',None))
        if context_key:
            if type(context_key) is dict:
                for k, v in context_key.iteritems():
                    params[k] = context.get(v, 'UNKNOWN')
            else:
                params[context_key] = context

        kongregate_api_key_key = gamedata['adnetworks'][api].get('kongregate_api_key_key', None)
        kg_api_key = {'kg': 'kongregate_api_key','k2': 'kongregate2_api_key'}.get(self.user.frame_platform, None)
        if kongregate_api_key_key:
            params[kongregate_api_key_key] = SpinConfig.config.get(kg_api_key, 'unknown')

        facebook_id_key = data.get('facebook_id_key', gamedata['adnetworks'][api].get('facebook_id_key',None))
        if facebook_id_key and self.user.facebook_id:
            params[facebook_id_key] = str(self.user.facebook_id)

        dauup_account_creation_time_key = data.get('dauup_account_creation_time_key', gamedata['adnetworks'][api].get('dauup_account_creation_time_key',None))
        if dauup_account_creation_time_key and self.user.account_creation_time > 0:
            params[dauup_account_creation_time_key] = time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(self.user.account_creation_time))

        if 'qs' in data:
            # inject preformatted key/value pairs (DAU-UP uses these)
            for key, val in data['qs'].iteritems():
                params[key] = val

        if extra_qs:
            for key, val in extra_qs.iteritems():
                 params[key] = val

        if api == 'adotomi':
            # special case, Adotomi has a feature to uniquify requests based on a string
            params['order_id'] = '%d_%s' % (self.user.user_id, game_id)

            if post_fbtax_dollars is not None: params['amount'] = str('%.2f' % post_fbtax_dollars)
            if currency is not None: params['currency'] = str(currency)
        elif api == 'dauup':
            if post_fbtax_dollars is not None: params['q1'] = str('%.2f' % post_fbtax_dollars)
        elif api == 'dauup2':
            if post_fbtax_dollars is not None: params['sb_v'] = str('%d' % int(100*post_fbtax_dollars))
        elif api == 'liniad':
            if post_fbtax_dollars is not None: params['sum'] = str('%.2f' % post_fbtax_dollars)

        postdata = None
        headers = None
        method = 'GET'

        if api == 'battlehouse':
            url = SpinConfig.config['battlehouse_api_path'] + '/metrics_event'
            params['service'] = SpinConfig.game()
            headers = {'X-BHLogin-API-Secret': SpinConfig.config['battlehouse_api_secret'].encode('utf-8')}
            method = 'POST'
        elif api == 'mailchimp':

            # check the address against blacklist
            blackreg = gamedata['adnetworks'][api].get('address_blacklist_regexp')
            if blackreg:
                if re.compile(blackreg).match(context['email_address'].lower()):
                    # address is blacklisted. Tell the caller that we succeeded, but silently drop the request.
                    self.user.log_adnetwork_event(api, {'user_id': self.user.user_id, 'kpi': name, 'context': context, 'status': 'blacklisted'})
                    return True

            api_key = SpinConfig.config['mailchimp_api_key']
            datacenter = api_key.split('-')[1]
            url = data['url'].replace('%DC%', datacenter)
            headers = {'Authorization': b'Bearer '+api_key.encode('utf-8'),
                       'Accept': b'*/*',
                       'Content-Type': b'application/x-www-form-urlencoded'}
            if data['mailchimp_action'] == 'subscribe':
                context['status'] = 'subscribed'
                subscriber_hash = hashlib.md5(context['email_address'].lower()).hexdigest()
                # use "PUT" method so that this is an upsert
                method = 'PUT'
                url += '/' + subscriber_hash
            else:
                gamesite.exception_log.event(server_time, 'unknown mailchimp_action %s for %s' % (data['mailchimp_action'], name))
                return False
            postdata = SpinJSON.dumps(context)

        else:
            url = data['url']

        if params:
            url += '?'+urllib.urlencode(params)

        log_props = {'user_id': self.user.user_id, 'kpi': name, 'context': context, 'url': url}
        if post_fbtax_dollars is not None: log_props['post_fbtax_dollars'] = post_fbtax_dollars
        if currency is not None: log_props['currency'] = currency
        self.user.log_adnetwork_event(api, log_props)

        if gamedata['server'].get('log_'+api,1):
            gamesite.exception_log.event(server_time, '%s API for user %d (%s): %r %s %s' % \
                                         (api, self.user.user_id, name, method, url, '(sent)' if SpinConfig.config.get('enable_'+api,False) else '(disabled)'))

        if SpinConfig.config.get('enable_'+api,False):
            def log_result(api, user_id, name, method, url, body = '', headers = {}, status = 500):
                status = int(status)
                if gamedata['server'].get('log_'+api,1) >= 2:
                    gamesite.exception_log.event(server_time, '%s API for user %d (%s): %r %s RESULT\nHTTP %d\n%r' % \
                                                 (api, user_id, name, method, url, status, body))
                # interpret known errors
                if status >= 200 and status <= 299:
                    return body # good, done!

                if api == 'mailchimp' and status == 400 and 'already a list member' in body:
                    return body # ignore double-adds

                gamesite.exception_log.event(server_time, '%s API for user %d (%s): %r %s RESULT\nnon-OK HTTP status %d\n%r' % \
                                                 (api, user_id, name, method, url, status, body))
                return None

            gamesite.AsyncHTTP_metrics.queue_request(server_time, url,
                                                     functools.partial(log_result, api, self.user.user_id, name, method, url),
                                                     method = method, headers = headers, postdata = postdata,
                                                     callback_type = gamesite.AsyncHTTP_metrics.CALLBACK_FULL,
                                                     accept_http_errors = True)

            return True
        else:
            return False

    def execute_consequent_safe(self, cons, player, retmsg, context=None, reason='unknown', rethrow = False):
        try:
            Consequents.read_consequent(cons).execute(self, player, retmsg, context=context)
        except Exception:
            gamesite.exception_log.event(server_time, 'Consequent exception player %d from %s:\n%s\n%s' % (player.user_id, reason, repr(cons), traceback.format_exc().strip())) # OK
            if rethrow:
                raise

    # FORCED AI ATTACKS
    #
    # States: Normal -> server calls start_ai_attack(), sends AI_ATTACK_WARNING -> session is put into incoming_attack_pending state
    # then either server's background timer or client calls deploy_ai_attack() (BEGIN_AI_ATTACK) to spawn the units


    def start_ai_attack(self, retmsg, attack_type, override_protection = False, verbose = False):
        if (not self.home_base) or self.has_attacked or self.incoming_attack_pending(): return
        if (not override_protection) and self.player.has_damage_protection(): return

        if attack_type == 'daily':
            pass # see below
        elif attack_type in gamedata['ai_attacks']['attack_types']:
            if 'activation' in gamedata['ai_attacks']['attack_types'][attack_type]:
                if (not self.player.is_cheater) and (not Predicates.read_predicate(gamedata['ai_attacks']['attack_types'][attack_type]['activation']).is_satisfied(self.player,None)):
                    retmsg.append(["ERROR", "CANNOT_CALL_INVALID_AI_ATTACK"])
                    return
        elif str(attack_type) in gamedata['ai_bases_server']['bases']:
            if (not self.player.is_cheater) and (not Predicates.read_predicate(gamedata['ai_bases_server']['bases'][str(attack_type)]['activation']).is_satisfied(self.player,None)):
                retmsg.append(["ERROR", "CANNOT_CALL_INVALID_AI_ATTACK"])
                return
        else:
                retmsg.append(["ERROR", "CANNOT_CALL_INVALID_AI_ATTACK"])
                return

        self.incoming_attack_type = attack_type
        self.incoming_attack_data = None

        if attack_type == 'tutorial':
            # it's the Lion Stone attack in the tutorial
            flavor_text_index = 0
            attack_warning_time = gamedata['ai_attacks']['attack_types']['tutorial']['warning_time']
            self.incoming_attack_units = copy.deepcopy(gamedata['ai_attacks']['attack_types']['tutorial']['units'])
            self.incoming_attack_direction = 'tutorial'
            self.incoming_attack_id = gamedata['ai_attacks']['attack_types']['tutorial']['attacker_id']
        else:
            if attack_type == 'daily':
                # decide on attack size
                if (self.player.my_home.calc_base_damage() < gamedata['ai_attacks']['max_base_damage_big_attack']) and \
                   (self.player.resources.player_level >= gamedata['ai_attacks']['min_level_big_attack']):
                    attack_type = 'daily_big'
                else:
                    attack_type = 'daily_small'
                self.incoming_attack_type = attack_type

            if self.incoming_attack_type in gamedata['ai_attacks']['attack_types']:
                self.incoming_attack_data = gamedata['ai_attacks']['attack_types'][self.incoming_attack_type]
                self.incoming_attack_id = self.incoming_attack_data['attacker_id']
            elif str(self.incoming_attack_type) in gamedata['ai_bases_server']['bases']:
                self.incoming_attack_data = gamedata['ai_bases_server']['bases'][str(self.incoming_attack_type)]
                self.incoming_attack_id = int(self.incoming_attack_type)

            flavor_text_index = 0 + int(random.random()*(len(gamedata['ai_attacks_client']['flavor_text'])))
            direction_index = int(random.random()*(len(gamedata['ai_attacks_client']['directions'])))
            self.incoming_attack_direction = gamedata['ai_attacks_client']['directions'].keys()[direction_index]
            attack_warning_time = self.incoming_attack_data.get('warning_time', 0)

            if 'units' in self.incoming_attack_data:
                self.incoming_attack_units = copy.deepcopy(self.incoming_attack_data['units'])
            elif 'waves' in self.incoming_attack_data:
                self.incoming_attack_units = self.player.get_ai_attack_units(self.incoming_attack_data)

        self.incoming_attack_time = server_time + attack_warning_time

        retmsg.append(["AI_ATTACK_WARNING",
                       self.incoming_attack_time,
                       copy.deepcopy(self.incoming_attack_units), # copy AGAIN since deploy_ai_attack() will modify it!
                       gamedata['ai_bases_server']['bases'][str(self.incoming_attack_id)]['ui_name'],
                       flavor_text_index,
                       self.incoming_attack_direction,
                       attack_warning_time,
                       self.incoming_attack_type
                       ])

        if LOTS_OF_METRICS:
            metric_event_coded(self.user.user_id, '3840_ai_attack_warn', {})

        if attack_warning_time <= 0:
            self.deploy_ai_attack(retmsg)

    def deploy_ai_attack(self, retmsg, force = False):
        assert self.home_base
        if not self.incoming_attack_pending():
            return

        # dump loot buffer
        if self.player.loot_buffer:
            if force:
                self.player.loot_buffer_release('deploy_ai_attack')
                retmsg.append(["LOOT_BUFFER_UPDATE", self.player.loot_buffer, False])
            else:
                retmsg.append(["ERROR", "CANNOT_SPY_LOOT_BUFFER_NOT_EMPTY"])
                return

        if gamedata['server']['log_ai_attacks'] and (self.incoming_attack_type != 'tutorial'):
            gamesite.exception_log.event(server_time, 'AI attack on player %d: %s' % \
                                         (self.player.user_id, str(self.incoming_attack_type)))

        if not self.res_looter:
            gamesite.exception_log.event(server_time, 'deploy_ai_attack with no res_looter %s' % (self.dump_exception_state(),))
            self.res_looter = ResLoot.ResLoot(gamedata, self, RogueOwner, self.viewing_player, self.viewing_base, 1)

        self.deployed_units = {}
        self.has_attacked = True
        self.debug_log_action('deploy_ai_attack')

        # add "weak unit" debuffs to player units
        for unit in self.player.home_base_iter():
            if (unit.owner is self.player) and unit.is_mobile() and (not unit.is_destroyed()) and self.has_object(unit.obj_id):
                unit.apply_weak_unit_debuffs(True)
                if unit.auras:
                    retmsg.append(["OBJECT_AURAS_UPDATE", unit.serialize_auras()])

        # need to send this so that enemy units in your base get the right stats
        retmsg.append(["ENEMY_STATTAB_UPDATE", {'player':{},'units':{},'buildings':{}}])

        self.attack_finish_time = server_time + gamedata['ai_attacks']['defense_time']

        self.incoming_attack_time = -1

        if LOTS_OF_METRICS:
            metric_event_coded(self.user.user_id, '3850_ai_attack_start', {})

        if gamedata['server'].get('track_battle_streaks',0) > 0:
            cd_list = ['battle_streak']
            for cd in cd_list:
                self.player.cooldown_trigger(cd, gamedata['server']['track_battle_streaks'], add_stack = 1)

        if self.incoming_attack_data and (not self.incoming_attack_data.get('enable_battle_log', True)):
            replay_token = self.open_attack_log(-1, -1, -1)
        else:
            replay_token = self.open_attack_log(self.attack_finish_time, self.incoming_attack_id if (self.incoming_attack_id > 0) else -1, self.user.user_id)

        self.attack_event(self.user.user_id, '3850_ai_attack_start', {})
        if self.player.player_auras:
            censored_player_auras = self.player.player_auras_censored()
            if censored_player_auras:
                self.attack_event(self.user.user_id, '3901_player_auras', {'player_auras':copy.deepcopy(censored_player_auras)})

        self.log_attack_units(self.user.user_id, [obj for obj in self.player.home_base_iter() if self.has_object(obj.obj_id)], '3900_unit_exists')
        if self.damage_log: self.damage_log.init_multi(obj for obj in self.player.home_base_iter() if self.has_object(obj.obj_id))

        self.activity_classifier.suffered_ai_attack(self.incoming_attack_id)

        self.deploy_ai_attack_wave(retmsg, replay_token = replay_token)

        # add grace period to prevent server and client from both trying to end the attack at the same time
        self.attack_finish_time += 5

        # fire AI on_attack consequent
        if self.incoming_attack_data:
            data = self.incoming_attack_data
            if data and ('on_attack' in data):
                self.execute_consequent_safe(data['on_attack'], self.player, retmsg, reason='on_attack(%d)' % self.incoming_attack_id)

    def deploy_ai_attack_wave(self, retmsg, replay_token = None):
        if len(self.incoming_attack_units) < 1:
            return True

        # spawn units

        units = self.incoming_attack_units.pop(0)

        ncells = self.viewing_base.ncells()
        # mid = self.viewing_base.midcell()
        # rad = self.viewing_base.get_base_radius()

        KEYWORDS = ["direction","delay","spread"]

        movecount = 0

        direction = units.get("direction", self.incoming_attack_direction)

        for specname in units.keys():
            if specname in KEYWORDS: continue
            if specname not in gamedata['units']:
                gamesite.exception_log.event(server_time, 'bad attack unit "%s" from attack "%s"' % (specname, repr(self.incoming_attack_id)))
                continue

            if type(units[specname]) is dict:
                count = units[specname].get('qty',1)
                force_level = units[specname].get('force_level',-1)
            else:
                count = units[specname]
                force_level = -1

            for i in range(count):
                if self.incoming_attack_direction == 'tutorial':
                    spawn_location = gamedata['tutorial']['ai_attack_begin']['spawn_location'] # [mid[0]-10, mid[1]+rad-5]
                    spawn_vector = gamedata['tutorial']['ai_attack_begin'].get('spawn_vector',[5,0])
                    x = spawn_location[0] + spawn_vector[0]*movecount
                    y = spawn_location[1] + spawn_vector[1]*movecount
                else:
                    spawn_location = gamedata['ai_attacks_client']['directions'][direction]
                    spread = units.get('spread', gamedata['ai_attacks']['default_spread'])
                    x = int(ncells[0]*spawn_location[0] + spread*(2*random.random()-1))
                    y = int(ncells[1]*spawn_location[1] + spread*(2*random.random()-1))

                x = min(max(0, x), ncells[0]-1)
                y = min(max(0, y), ncells[1]-1)
                spec = self.player.get_abtest_spec(GameObjectSpec,specname)

                if force_level >= 1:
                    level = force_level
                else:
                    # spawn units at player's tech level minus 1, or 1 if player doesn't have the tech
                    level = max(1, self.player.tech.get(spec.level_determined_by_tech, 0) - 1)

                obj = instantiate_object_for_player(self.player, RogueOwner, specname, x=x, y=y, level=level)

                self.add_object(obj)
                retmsg.append(["OBJECT_CREATED2", obj.serialize_state()])
                if obj.auras:
                    retmsg.append(["OBJECT_AURAS_UPDATE", obj.serialize_auras()])

                self.log_attack_unit(self.incoming_attack_id, obj, '3910_unit_deployed', props = {'method':'ai_attack'})
                self.deployed_units[obj.spec.name] = self.deployed_units.get(obj.spec.name,0) + 1
                if self.damage_log: self.damage_log.init(obj)
                movecount += 1

        # time for next wave to spawn
        if len(self.incoming_attack_units) > 0:
            if 'delay' in self.incoming_attack_units[0]:
                self.incoming_attack_wave_time = server_time + int(self.incoming_attack_units[0]['delay'] / max(1, self.player.stattab.get_player_stat('combat_time_scale')))
            else:
                self.incoming_attack_wave_time = server_time + int(gamedata['ai_attacks']['wave_interval'] / max(1, self.player.stattab.get_player_stat('combat_time_scale')))
        else:
            self.incoming_attack_wave_time = -1

        retmsg.append(["AI_ATTACK_WAVE_DEPLOYED", self.attack_finish_time, self.incoming_attack_units, self.incoming_attack_wave_time, replay_token])
        return (len(self.incoming_attack_units) < 1)

    # call this after any action that may change the player's power production or consumption
    # it re-initializes harvesters with the correct harvesting rate
    def power_changed(self, base, changed_object, retmsg):
        power_factor, power_state, affected_obj_list = base.power_changed(changed_object)
        for obj in affected_obj_list:
            if self.has_object(obj.obj_id):
                retmsg.append(["OBJECT_STATE_UPDATE2", obj.serialize_state(update_hp = False)])

        if (base is self.viewing_base) and (power_state is not None):
            retmsg.append(["BASE_POWER_UPDATE", power_state])
        return power_factor

    def change_player_title(self, new_title_name, retmsg, force = False, chat_announce = True):
        new_title_data = self.player.get_abtest_title(new_title_name)
        assert new_title_data
        if new_title_name != gamedata['default_title']:
            # make sure it is unlocked
            if (not self.player.is_cheater) and (not force):
                for PRED in ('show_if', 'requires'):
                    if (PRED in new_title_data) and (not Predicates.read_predicate(new_title_data[PRED]).is_satisfied(self.player, None)):
                        retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", new_title_data[PRED]])
                        return False

        if self.player.title != new_title_name:
            old_name = self.user.get_ui_name(self.player)
            self.player.title = new_title_name
            self.deferred_player_name_update = True
            if chat_announce and self.alliance_chat_channel:
                self.do_chat_send(self.alliance_chat_channel,
                                  'I have a new title!',
                                  bypass_gag = True, props = {'type':'changed_title',
                                                              'old_name': old_name})
            gamesite.gameapi.send_player_cache_update(self, 'change_title')
        return True

    # call with a Deferred that will fire when the player portrait is updated
    def portrait_update_launched(self, portrait_d):
        portrait_d.addCallbacks(lambda _, self=self: self.send([["PLAYER_PORTRAIT_UPDATE"]], flush_now = True),
                                lambda _, self=self: report_and_absorb_deferred_failure(_, self))

    # for Consequents to access the msg_client
    def msg_send(self, *args, **kwargs):
        return gamesite.msg_client.msg_send(*args, **kwargs)
    def do_CONTROLAPI(self, *args, **kwargs):
        return gamesite.do_CONTROLAPI(*args, **kwargs)

class SessionChange(object):
    # This holds the state of an ongoing asynchronous session change request
    # begin() returns a Deferred that will later fire with a list of arguments
    # to pass to change_session_complete()

    # for debugging overly-long session changes, keep a set of outstanding requests
    master_set = set()
    @classmethod
    def debug_dump(cls):
        now = time.time()
        return ','.join(('%s (%d->%r %r %s)' % (c.__class__.__name__,
                                                c.session.user.user_id, c.dest_user_id, c.dest_base_id,
                                                SpinConfig.pretty_print_time(now - c.start_time))) \
                        for c in cls.master_set)

    def __init__(self, session, retmsg, dest_user_id, dest_base_id, new_ladder_state, delay, pre_attack):

        SessionChange.master_set.add(self)

        self.start_time = server_time
        self.d = make_deferred(self.__class__.__name__) # deferred to fire upon completion
        self.d.add_debug_data('%r %r' % (dest_user_id, dest_base_id))
        self.session = session
        self.retmsg = retmsg
        self.dest_user_id = dest_user_id
        self.dest_base_id = dest_base_id
        self.new_ladder_state = new_ladder_state
        self.delay = delay
        self.pre_attack = pre_attack

    def begin(self):
        self.d.add_debug_data('begin')
        delay = self.delay

        cooldown = self.session.player.get_any_abtest_value('attack_spam_cooldown', gamedata['server']['attack_spam_cooldown'])
        if self.dest_user_id != self.session.user.user_id and (cooldown > 0) and (self.session.player.attack_cooldown_start > 0) and (server_time < (self.session.player.attack_cooldown_start + cooldown)):
            # delay the actual start until the cooldown passes
            spam_delay = gamedata['server']['attack_spam_delay']
            if spam_delay < 0:
                spam_delay = (self.session.player.attack_cooldown_start + cooldown) - server_time
            if spam_delay > 0:
                if gamedata['server']['log_attack_spam']:
                    descr = str(self.dest_user_id if self.dest_user_id else self.dest_base_id)
                    gamesite.exception_log.event(server_time, 'user %d: attack spam, delaying visit_base (%s) by %d sec' % (self.session.user.user_id, descr, spam_delay))
            delay += spam_delay

        reactor.callLater(max(delay, 0), self.really_begin)
        return self.d

    # note: these queries may be called before instantiation to check for existence
    # before we start the full async session change

    @classmethod
    def default_deployable_squads(cls, player):
        deployable_feature = {'base_id': player.squad_base_id(SQUAD_IDS.BASE_DEFENDERS),
                              'base_landlord_id': player.user_id,
                              'squad_id': SQUAD_IDS.BASE_DEFENDERS}
        return {deployable_feature['base_id']: deployable_feature}

    @classmethod
    def default_defending_squads(cls, dest_user_id):
        defending_feature = {'base_id': 's%d_%d' % (dest_user_id, SQUAD_IDS.BASE_DEFENDERS),
                             'base_landlord_id': dest_user_id,
                             'squad_id': SQUAD_IDS.BASE_DEFENDERS}
        return {defending_feature['base_id']: defending_feature}

class SessionChangeHome(SessionChange): # simple case for going back to your own home
    def __init__(self, *args):
        SessionChange.__init__(self, *args)
        assert self.dest_user_id == self.session.user.user_id

    def really_begin(self):
        self.d.add_debug_data('really_begin')
        SessionChange.master_set.remove(self)
        self.d.callback([self.session, self.retmsg, self.dest_user_id, self.session.user, self.session.player,
                         None, None, self.new_ladder_state,
                         self.default_deployable_squads(self.session.player),
                         self.default_defending_squads(self.dest_user_id),
                         self.pre_attack])

class SessionChangeOld(SessionChange): # non-map path
    def __init__(self, *args):
        SessionChange.__init__(self, *args)
        assert self.dest_user_id
        assert not self.dest_base_id
        self.dest_player = None
        self.dest_user = None
        self.got_player = False
        self.got_user = False
        self.is_ai = is_ai_user_id_range(self.dest_user_id)
        self.ai_instance_error_status = None

    def really_begin(self):
        self.d.add_debug_data('really_begin')
        if self.is_ai:
            # check for AI instances first, then fall back to regular player_table
            ai_instance_table.lookup_async(self.session.player,
                                           self.session.user.user_id, game_id, self.dest_user_id,
                                           self.ai_instance_cb, 'change_session')
        else:
            # visiting a human player
            player_table.lookup_async(self.session.player, self.dest_user_id, False, self.player_cb, 'change_session')
        user_table.lookup_async(self.dest_user_id, self.user_cb, 'change_session')

    def ai_instance_cb(self, status, player):
        self.d.add_debug_data('ai_instance_cb(%r)' % bool(player))

        # fails gracefully if player is None
        if player:
            # got instance - do not auto-level
            self.got_player = True
            self.dest_player = player
            self.try_finish()
        elif status == 'stale_gen':
            # stale AI generation. Going to fail back to home base.
            self.ai_instance_error_status = status
            self.got_player = True
            # dest_player stays None
            self.try_finish()
        else:
            # get a fresh copy of the base
            player_table.lookup_async(self.session.player, self.dest_user_id, False, self.player_cb, 'change_session')

    def player_cb(self, success, player):
        self.d.add_debug_data('player_cb(%r)' % bool(player))

        # fails gracefully if player is None
        self.got_player = True
        self.dest_player = player
        if self.is_ai and self.dest_player:
            ai_instance_table.init_fresh_instance(self.dest_user_id, player, self.session.player)
        self.try_finish()

    def user_cb(self, success, user):
        self.d.add_debug_data('user_cb(%r)' % bool(user))

        self.got_user = True
        # will use None if success == False, and fall back gracefully
        self.dest_user = user
        self.try_finish()

    # once user and player requests have both completed, re-enter gameapi and finish the request
    def try_finish(self):
        if (not self.got_player) or (not self.got_user):
            self.d.add_debug_data('try_finish(False)')
            return

        self.d.add_debug_data('try_finish(True)')

        if self.ai_instance_error_status:
            assert self.ai_instance_error_status == 'stale_gen'
            # abort change, return to home base
            SessionChange.master_set.remove(self)
            self.retmsg.append(["ERROR", "CANNOT_SPY_STALE_AI", self.dest_user_id, 'SessionChangeOld'])
            self.d.callback(None)
            return

        if self.dest_player:
            if self.dest_user:
                self.dest_player.sync_with_user(self.dest_user)
            self.dest_player.migrate_proxy()
        SessionChange.master_set.remove(self)

        # compute the deployable squads
        if self.is_ai and self.dest_player and (not self.dest_player.my_home.deployment_allowed):
            deployable_squads = {} # do not allow use of player's ordinary units
        else:
            deployable_squads = self.default_deployable_squads(self.session.player)

        self.d.callback([self.session, self.retmsg, self.dest_user_id, self.dest_user, self.dest_player,
                         None, None, self.new_ladder_state,
                         deployable_squads,
                         self.default_defending_squads(self.dest_user_id),
                         self.pre_attack])

class SessionChangeNew(SessionChange): # new basedb path
    def __init__(self, *args):
        SessionChange.__init__(self, *args)
        assert not self.dest_user_id
        assert self.dest_base_id
        self.dest_base_pre = None
        self.dest_base = None
        self.dest_player = None
        self.dest_user = None
        self.got_base = False
        self.got_player = False
        self.got_user = False
        self.new_defending_squads = None
        self.new_deployable_squads = None

    @classmethod
    def query_dest_feature(cls, player, dest_base_id):
        assert gamesite.nosql_client and player.home_region # map path
        dest_feature = gamesite.nosql_client.get_map_feature_by_base_id(player.home_region, dest_base_id, reason='change_session(query_dest_feature)')
        if (not dest_feature) or \
           Region(gamedata, player.home_region).feature_is_moving(dest_feature, server_time, assume_moving = False) or \
           (dest_feature['base_type'] not in ('hive', 'quarry', 'home', 'squad')) or \
           (dest_feature['base_type'] == 'squad' and (not player.squad_combat_enabled()) or dest_feature.get('raid')) or \
           (dest_feature['base_type'] == 'home' and not player.map_home_combat_enabled()):
            return None
        return dest_feature

    @classmethod
    def query_deployable_squads(cls, player, dest_feature):
        assert gamesite.nosql_client and player.home_region and dest_feature # map path
        new_deployable_squads = {}

        if dest_feature['base_landlord_id'] != player.user_id:
            squad_features = list(gamesite.nosql_client.get_map_features_by_landlord_and_type(player.home_region, player.user_id, 'squad', reason='change_session(query_deployable_squads)'))

            for squad_feature in squad_features:
                if squad_feature.get('raid'): continue # cannot participate in RTS battles
                if Region(gamedata, player.home_region).feature_is_moving(squad_feature, server_time, assume_moving = False): continue # squad not arrived yet
                if squad_feature.get('LOCK_STATE',0) > 0 and \
                   squad_feature.get('LOCK_OWNER',-1) != player.user_id:
#                           ((not session.viewing_squad_locks) or (SpinDB.base_lock_id(player.home_region, player.squad_base_id(squad_id)) not in session.viewing_squad_locks)):
                    continue # squad is already locked
                if hex_distance(squad_feature['base_map_loc'], dest_feature['base_map_loc']) == 1: # note: don't take squads on top of the target
                    squad_id = squad_feature['squad_id'] = int(squad_feature['base_id'].split('_')[1])
                    if str(squad_id) in player.squads:
                        new_deployable_squads[squad_feature['base_id']] = squad_feature

            if hex_distance(dest_feature['base_map_loc'], player.my_home.base_map_loc) == 1:
                # battle is taking place next to home base - allow deployment of squads that are at home
                for squad_data in player.squads.itervalues():
                    if ((SQUAD_IDS.is_mobile_squad_id(squad_data['id']) or gamedata['territory']['base_defenders_can_attack_neighbors']) and \
                        (not player.squad_is_deployed(squad_data['id']))):
                        squad_feature = {'base_id': player.squad_base_id(squad_data['id']),
                                         'base_landlord_id': player.user_id, 'squad_id': squad_data['id']}
                        new_deployable_squads[squad_feature['base_id']] = squad_feature

        return new_deployable_squads

    @classmethod
    def query_defending_squads(cls, player, dest_feature, dest_user_id):
        assert gamesite.nosql_client and player.home_region and dest_feature # map path

        if dest_feature['base_type'] == 'home':
            defending_feature = {'base_id': 's%d_%d' % (dest_feature['base_landlord_id'], SQUAD_IDS.BASE_DEFENDERS),
                                 'base_landlord_id': dest_feature['base_landlord_id'],
                                 'squad_id': SQUAD_IDS.BASE_DEFENDERS}
            new_defending_squads = {defending_feature['base_id']: defending_feature}
        elif dest_feature['base_type'] == 'squad':
            new_defending_squads = {dest_feature['base_id']: {'base_id': dest_feature['base_id'],
                                                              'base_landlord_id': dest_feature['base_landlord_id'],
                                                              'squad_id': int(dest_feature['base_id'].split('_')[1])}}
        elif dest_feature['base_type'] == 'quarry':
            # find guard squad(s)
            new_defending_squads = {}
            defense_features = [x for x in gamesite.nosql_client.get_map_features_by_loc(player.home_region, dest_feature['base_map_loc'], reason='change_session(guards)') if x.get('base_type',None)=='squad']

            for squad_feature in defense_features:
                if squad_feature.get('raid'): continue # cannot participate in RTS battles
                if Region(gamedata, player.home_region).feature_is_moving(squad_feature, server_time, assume_moving = False):
                    continue # squad has not arrived at its destination yet
                if squad_feature['base_landlord_id'] != dest_feature['base_landlord_id']:
                    # "defending" squad, but it's owned by someone other than the quarry owner
                    # this can happen via race condition where the old quarry owner had a squad on the way to the quarry (or left over due to undeployable units hanging around),
                    # but then it got attacked and taken over before it arrives
                    gamesite.exception_log.event(server_time, 'quarry %s (owner %d) has foreign squad %s (owner %d) at same location - recalling it back to base' % \
                                                 (dest_feature['base_id'], dest_feature['base_landlord_id'], squad_feature['base_id'], squad_feature['base_landlord_id']))
                    gamesite.nosql_client.drop_map_feature(player.home_region, squad_feature['base_id'], originator = player.user_id, reason='visit_quarry_guard_race_cleanup')
                    continue
                squad_id = int(squad_feature['base_id'].split('_')[1])
                squad_feature['squad_id'] = squad_id
                new_defending_squads[squad_feature['base_id']] = squad_feature
        else:
            new_defending_squads = {} # hive

        return new_defending_squads

    def really_begin(self):
        self.d.add_debug_data('really_begin')

        # query for target feature (to verify type and location)
        dest_feature = self.query_dest_feature(self.session.player, self.dest_base_id)
        if not dest_feature:
            if gamedata['server'].get('log_nosql',0) < 2 and self.dest_base_id[0]=='s':
                pass # do not bother logging failed attempts to spy on squads that have moved
            else:
                gamesite.exception_log.event(server_time, 'NoSQL spy error: player %d dest_base_id %s: result %s' % (self.session.player.user_id, self.dest_base_id, repr(dest_feature)))
            self.retmsg.append(["ERROR", "CANNOT_SPY_BASE_NOT_FOUND", self.dest_base_id, 'change_session'])
            SessionChange.master_set.remove(self)
            self.d.callback(None) # fail now
            return


        # query for attacker's deployable squads
        self.new_deployable_squads = self.query_deployable_squads(self.session.player, dest_feature)
        if dest_feature and len(self.new_deployable_squads) < 1 and dest_feature['base_landlord_id'] != self.session.player.user_id and \
           hex_distance(dest_feature['base_map_loc'], self.session.player.my_home.base_map_loc) != 1:
            # no squads in range, cannot spy on hostile base
            self.retmsg.append(["ERROR", "CANNOT_SPY_NO_NEARBY_SQUADS"])
            SessionChange.master_set.remove(self)
            self.d.callback(None) # fail now
            return

        # check for defending squads
        self.new_defending_squads = self.query_defending_squads(self.session.player, dest_feature, self.dest_user_id)

        if self.pre_attack and dest_feature and dest_feature['base_type'] == 'squad' and \
           (dest_feature['base_landlord_id'] != self.session.player.user_id):
            # attempt to lock the destination squad immediately,
            # to reduce the time window for the defender to manipulate it before the player can attack
            state = gamesite.nosql_client.map_feature_lock_acquire(self.session.player.home_region, self.dest_base_id, self.session.player.user_id, reason='VISIT_BASE2_pre_attack')
            if state != Player.LockState.being_attacked:
                # try to figure out more specifically why we didn't get the lock
                if dest_feature.get('LOCK_OWNER',-1) == dest_feature['base_landlord_id']:
                    err = "CANNOT_ATTACK_THEIR_SQUAD_OFFENSE"
                elif dest_feature.get('LOCK_OWNER',-1) > 0:
                    err = "CANNOT_ATTACK_THEIR_SQUAD_DEFENSE"
                else:
                    err = "CANNOT_ATTACK_THEIR_SQUAD_MOVED" # probably can't get here (due to the dest_feature check above), but just in case
                self.retmsg.append(["ERROR", err, "VISIT_BASE2_pre_attack"])
                SessionChange.master_set.remove(self)
                self.d.callback(None) # abort the spy attempt
                return

            # record the fact that we're now holding the lock
            # note that we MUST proceed with the attack after spying completes (or fails), or else this could open exploits where you hold a lock on a hostile squad forever
            self.session.pre_locks.add(SpinDB.base_lock_id(self.session.player.home_region, self.dest_base_id))

        if self.dest_base_id[0] == 'h':
            # handle home bases specially, using an ordinary playerdb lookup
            self.dest_user_id = int(self.dest_base_id[1:])
            player_table.lookup_async(self.session.player, self.dest_user_id, False, self.player_cb, 'change_session')
            user_table.lookup_async(self.dest_user_id, self.user_cb, 'change_session')
        elif self.dest_base_id[0] == 's':
            fields = self.dest_base_id[1:].split('_')
            self.dest_user_id = int(fields[0])
            self.dest_squad_id = int(fields[1])

            # in this case, there IS no destination base, need to create a virtual one on the fly to hold the defending squad
            self.got_base = True
            self.dest_base = Base(self.session.player.home_region, self.dest_base_id, self.dest_user_id, 'squad')
            if dest_feature:
                if 'base_map_loc' in dest_feature:
                    self.dest_base.base_map_loc = dest_feature['base_map_loc']
                    self.dest_base.base_climate = Region(gamedata, self.session.player.home_region).read_climate_name(self.dest_base.base_map_loc)
                # apply correct generation count to the virtual base
                self.dest_base.base_generation = dest_feature.get('LOCK_GENERATION',-1)

            self.dest_base.spawn_scenery(self.session.player, self.session.player.user_id + self.dest_squad_id)

            if self.dest_user_id == self.session.player.user_id:
                self.dest_player = self.session.player
                self.got_player = True
                self.dest_user = self.session.user
                self.got_user = True
                reactor.callLater(0, self.try_finish)
            else:
                player_table.lookup_async(self.session.player, self.dest_user_id, False, self.player_cb, 'change_session')
                user_table.lookup_async(self.dest_user_id, self.user_cb, 'change_session')

        else:
            base_table.lookup_async(self.session.player.home_region, self.dest_base_id, None, # do NOT send dest_feature, it's obsoleted by complete_attack!
                                    self.base_cb, 'change_session')
    def base_cb(self, success, base, landlord_id):
        self.d.add_debug_data('base_cb(%r)' % bool(base))

        self.got_base = True
        self.dest_base_pre = base
        if self.dest_base_pre:
            assert landlord_id
            if landlord_id == self.session.player.user_id:
                self.dest_player = self.session.player
                self.got_player = True
                self.dest_user = self.session.user
                self.got_user = True
            else:
                player_table.lookup_async(self.session.player, landlord_id, False, self.player_cb, 'change_session')
                user_table.lookup_async(landlord_id, self.user_cb, 'change_session')
        else:
            self.dest_player = None
            self.dest_user = None
            self.got_player = True
            self.got_user = True
        self.try_finish()
    def player_cb(self, success, player):
        self.d.add_debug_data('player_cb(%r)' % bool(player))
        self.got_player = True
        self.dest_player = player
        self.try_finish()
    def user_cb(self, success, user):
        self.d.add_debug_data('user_cb(%r)' % bool(user))
        self.got_user = True
        self.dest_user = user
        self.try_finish()

    def try_finish(self):
        if self.dest_base_id[0] == 'h':
            return self.try_finish_home()
        else:
            return self.try_finish_remote()

    def try_finish_home(self):
        if self.got_user and self.got_player and (not self.got_base):
            self.got_base = True
            # get the base of the dest player
            if self.dest_player:
                if self.dest_user:
                    self.dest_player.sync_with_user(self.dest_user)

                self.dest_player.migrate_proxy()
                self.dest_base = self.dest_player.my_home
            else:
                self.dest_base = None

        if (not self.got_base) or (not self.got_player) or (not self.got_user):
            self.d.add_debug_data('try_finish_home(notready)')
            return

        SessionChange.master_set.remove(self)

        # note: this actually calls back into the "old" player.my_home path!
        self.d.callback([self.session, self.retmsg, self.dest_user_id, self.dest_user, self.dest_player, None, None, self.new_ladder_state, self.new_deployable_squads, self.new_defending_squads, self.pre_attack])

    def try_finish_remote(self):
        if (not self.got_base) or (not self.got_player) or (not self.got_user):
            self.d.add_debug_data('try_finish_remote(notready)')
            return
        if self.dest_player:
            if self.dest_user:
                self.dest_player.sync_with_user(self.dest_user)
            self.dest_player.migrate_proxy()
            if self.dest_base_id[0] == 's' and self.dest_base: # set squad name
                squad_data = self.dest_player.squads.get(str(self.dest_squad_id), None)
                if squad_data and ('ui_name' in squad_data):
                    self.dest_base.base_ui_name = squad_data['ui_name']

        if self.dest_base_pre and self.dest_player:
            # complete parsing of the base using the landlord Player
            self.dest_base = base_table.parse(self.session.player.home_region, self.dest_base_id, self.dest_base_pre, self.dest_player, self.session.player, reason='visit')

        SessionChange.master_set.remove(self)

        self.d.callback([self.session, self.retmsg, self.dest_user_id, self.dest_user, self.dest_player, self.dest_base_id, self.dest_base, self.new_ladder_state, self.new_deployable_squads, self.new_defending_squads, self.pre_attack])

# A collection of game objects indexed by ID
class ObjectCollection:
    def __init__(self):
        # counter for unique object IDs
        self.objects = {}
    def add_object(self, obj):
        if obj.obj_id in self.objects:
            raise Exception('ObjectCollection: double-added object ID %r' % obj.obj_id)
        self.objects[obj.obj_id] = obj
        return obj
    def rem_object(self, id):
        obj = self.objects[id]
        del self.objects[id]
        return obj
    def has_object(self, id):
        return self.objects.has_key(id)
    def iter_objects(self):
        return self.objects.itervalues()
    def __len__(self):
        return len(self.objects)

# these "Specs" are a parsed form of object or tech specifications read from gamedata.json
class Spec(object):
    # mapping from spec.kind to the name of the dictionary in the abtest group that contains replacement specs
    KEY_MAP = { 'building': 'buildings',
                'mobile': 'units',
                'unit': 'units',
                'inert': 'inert',
                'tech': 'tech',
                'enhancement': 'enhancements',
                'aura': 'auras' }

    # spec quantities that are normally numbers may vary according to object or player level.
    # In this case they are stored as arrays indexed by level-1
    @classmethod
    def get_leveled_quantity(cls, qty, level):
        if type(qty) == list:
            return qty[level-1]
        return qty

    # these can be arrays-of-arrays and need to be handled specially
    @classmethod
    def get_crafting_recipe_ingredients_list(cls, recipe, level):
        if ('ingredients' in recipe) and (type(recipe['ingredients'][0]) is list):
            return cls.get_leveled_quantity(recipe['ingredients'], level)
        else:
            return recipe.get('ingredients', [])
    @classmethod
    def get_crafting_recipe_product_list(cls, recipe, level):
        if ('product' in recipe) and (type(recipe['product'][0]) is list):
            return cls.get_leveled_quantity(recipe['product'], level)
        else:
            return recipe.get('product', [])

    def get_remove_ingredients_list(self, level):
        if isinstance(self.remove_ingredients, list) and len(self.remove_ingredients) >= 1 and \
           isinstance(self.remove_ingredients[0], list):
            return self.remove_ingredients[level-1]
        else:
            return self.remove_ingredients or []
    def get_upgrade_ingredients_list(self, level):
        if isinstance(self.upgrade_ingredients, list) and len(self.upgrade_ingredients) >= 1 and \
           isinstance(self.upgrade_ingredients[0], list):
            return self.upgrade_ingredients[level-1]
        else:
            return self.upgrade_ingredients or []

    def __init__(self, name, data):
        self.name = name

        # read in all the fields from gamedata.jsoon
        for field_name, default_value in self.fields:
            if default_value == "REQUIRED":
                val = data[field_name]
            else:
                val = data.get(field_name, default_value)
            self.__dict__[field_name] = val

        # the 'requires', 'show_if, and 'activation' fields are a special case because we need to instantiate a Predicate object
        if data.has_key('requires'):
            self.requires = self.read_requires(data['requires'])
        else:
            self.requires = None
        if data.has_key('show_if'):
            self.show_if = Predicates.read_predicate(data['show_if'])
        else:
            self.show_if = None
        if data.has_key('activation'):
            self.activation = Predicates.read_predicate(data['activation'])
        else:
            self.activation = None

        self.maxlevel = self.compute_maxlevel()

    def read_requires(self, reqdata):
        if reqdata is None: return None
        if type(reqdata) == list:
            # different requirements for each upgrade level
            return map(lambda(x): Predicates.read_predicate(x), reqdata)
        else:
            return Predicates.read_predicate(reqdata)

    # clone a Spec, applying patches to member fields (for A/B testing)
    def make_patched(self, patch):
        ret = copy.copy(self)
        for key, val in patch.iteritems():
            if key == 'requires':
                ret.requires = ret.read_requires(val)
            else:
                ret.__dict__[key] = val
        return ret

    def compute_maxlevel(self):
        kind = getattr(self, 'kind', None)

        # for buildings and units, we define maxlevel via build_time and max_hp, respectively
        if kind == 'building':
            return len(self.build_time)
        elif kind == 'mobile':
            return len(self.max_hp)
        elif kind == 'inert':
            return self.max_level

        # compute max possible level
        # this is the length of the *shortest* list-valued field in gamedata.json
        maxlevel = 999
        list_seen = False
        for field_name, default_value in self.fields:
            # these list-valued fields don't affect the max level
            if field_name in ("limit", "limit_requires", "spells", "gridsize", "unit_collision_gridsize", "exclusion_zone", "defense_types", "health_bar_dims", "research_categories", "crafting_categories", "max_ui_level","quarry_control_auras"):
                continue
            val = self.__dict__[field_name]
            if type(val) == list:
                list_seen = True
                maxlevel = min(maxlevel, len(val))

        if self.requires and type(self.requires) == list:
            list_seen = True
            maxlevel = min(maxlevel, len(self.requires))

        if not list_seen:
            maxlevel = 1
        #print 'maxlevel for ', self.name, ' is ', self.maxlevel
        return maxlevel

def resource_fields(name, default = 0): return [[name+'_'+resname, default] for resname in gamedata['resources']]

class GameObjectSpec(Spec):
    # global table mapping object spec names to GameObjectSpec instances
    table = {}

    # [ name of each field necessary to be read from gamedata.json, default value if none in file ]
    # "REQUIRED" means that no default is provided and the field must have an explicit value
    fields = [
        ["kind", "REQUIRED"],
        ["max_hp", "REQUIRED"],
        ["armor", 0],
        ["maxvel", 0],
        ["travel_speed", 0],
        ["gridsize", [0,0]],
        ["unit_collision_gridsize", [0,0]],
        ["blocks_buildings", 0],
        ["quantize_location", 0],
        ["exclusion_zone", [0,0]],
        ["ignore_perimeter", 0],
        ["provides_power", 0],
        ["power_shutdown_threshold", 1.0],
        ["damaged_power_output", -1],
        ["consumes_power", 0],
        ["consumes_power_while_building", 0],
        ["provides_space", 0],
        ["provides_donated_space", 0],
        ["max_individual_donation_space", 0],
        ["provides_squads", 0],
        ["provides_deployed_squads", 0],
        ["provides_deployed_raids", 0],
        ["raid_range_pvp", 0],
        ["raid_range_pve", 0],
        ["provides_squad_space", 0],
        ["provides_total_space", 0],
        ["consumes_space", 0],
        ["provides_inventory", 0],
        ["provides_limited_equipped", None],
        ["provides_quarry_control", 0],
        ["quarry_yield", 1], # per-harvester attribute, multiplies regional yield
        ["quarry_movable", False],
        ["quarry_buildable", False],
        ["quarry_upgradable", False],
        ["build_time", 0],
        ["repair_time", 0],
        ] + resource_fields("build_cost") + [
        ["upgrade_ingredients", None],
        ["upgrade_credit_cost", -1],
        ["upgrade_gamebucks_cost", -1],
        ["upgrade_speedup_cost_factor", 1],
        ["upgrade_xp",-1],
        ["proposed_upgrade_xp", -1], # for debug messages only
        ["worth_less_xp", 0],
        ] + resource_fields("produces") + [
        ["production_capacity", 0],
        ] + resource_fields("storage") + [
        ] + resource_fields("vault") + [
        ] + resource_fields("cargo") + [
        ] + resource_fields("specific_pve_loot_fraction", default = -1) + [
        ] + resource_fields("specific_pvp_loot_fraction", default = -1) + [
        ] + resource_fields("remove_cost") + [
        ["remove_reward_gamebucks", 0],
        ["remove_time", 0],
        ["remove_ingredients", None],
        ["remove_requires", None],
        ["spells", []],
        ["level_determined_by_tech", None],
        ["limit", -1],
        ["limit_requires", None],
        ["max_ui_level", None],
        ["max_level", 1], # note: only used by inert objects, others derive max_level from other stats
        ["metric_events", ""],
        ["expires", None],
        ["client_can_create", 0],
#        ["research_category", None],
        ["research_categories", []],
        ["enhancement_categories", []],
        ["manufacture_category", None],
        ["requires_factory_level", 0],
        ["crafting_categories", []],
        ["crafting_speed", 1.0],
        ["crafting_queue_space", -1],
        ["manufacture_speed", 1.0],
        ["manufacture_cost", 1.0],
        ["unit_repair_speed", 1.0],
        ["unit_repair_cost", 1.0],
        ["track_level_in_player_history", False],
        ["history_category", None],
        ["defense_types", []],
        ["damage_taken_from", None], # if present, dictionary of key->multiplier
        ["invisible", False],
        ["invis_on_hold", False],
        ["flying", False],
        ["consumable", False],
        ["resurrectable", False],
        ["resurrectable_without_tech", False],
        ["donatable", True],
        ["developer_only", 0],
        ["quarry_only", 0],
        ["always_free_speedup", False],
        ["no_free_speedup", False],
        ["unit_repair_resources", -1],
        ["unit_repair_time", -1],
        ["quarry_invul", False],
        ["equip_slots", None],
        ["permanent_auras", None],
        ["climate_auras", None],
        ["permanent_modstats", None],
        ["auto_spawn", False],
        ["on_destroy", None],
        ["on_damage", None],
        ["on_approach", None],
        ["upgrade_completion", None],
        ["remove_completion", None],
        ["provides_foremen", 0],
        ["alliance_help_daily_limit", 0]
        ]

    # * note: the worth_less_xp flag has the following consequences for a building:
    # - cannot provide inventory or storage (performance optimization)
    # - has no effect on base damage or havoc calculations
    # - cannot receive stat mod effects from player auras (but can have local equipment - e.g. for minefields)
    # - cannot affect player stat table
    # - will have bucketed time series data in player.history
    # - will only be worth destroy_building_min_xp to attackers
    # - does not contribute to damage_inflicted, buildings_lost, buildings_killed, or destroyed_building_levels in session loot
    # - client-side: does not show aura graphics or building-idle notifications

    @classmethod
    def lookup(cls, name):
        return cls.table[name]
    @classmethod
    def exists(cls, name):
        return (name in cls.table)

    @classmethod
    def get_factory_for(cls, category):
        for name, spec in cls.table.iteritems():
            if spec.kind == 'building' and spec.manufacture_category == category: return name
        return None

    def __init__(self, name, data):
        Spec.__init__(self, name, data)

        # insert ourself into the table
        self.table[self.name] = self

        # perform sanity checks
        for res in gamedata['resources']:
            if getattr(self, 'produces_'+res) > 0:
                assert self.production_capacity > 0

    # compute how much harmful DPS this unit does
    def get_dps(self, level):
        if len(self.spells) < 1:
            return 0
        spell = gamedata['spells'][self.spells[0]]
        if spell['activation'] != 'auto' or spell.get('help', 0):
            return 0
        dps = self.get_leveled_quantity(spell.get('damage',0), level)

        if spell.get('targets_self',0):
            # count suicide attacks as half as much DPS
            dps *= 0.5
        elif 'splash_range' in spell:
            # count splash-capable attacks as twice as much DPS
            dps *= 2

        return dps

    def get_research_categories(self, player):
        return self.research_categories

    # obj_id is needed to look up any building modstats that affect repair time
    # (XXXXXX this awkwardly reaches into player.stattab.modded_buildings - might need to fix later by passing the Building instance itself,
    # or a speed_factor, but that complicates DamageLog.finalize()...)
    COST_MODE_REPAIR = 0
    COST_MODE_RECYCLE = 1
    COST_MODE_MANUFACTURE_CANCEL = 2
    COST_MODE_MANUFACTURE = 3
    def cost_to_repair(self, level, hp_ratio, player, obj_id = None, cost_mode = COST_MODE_REPAIR, builder = None):
        if self.kind == 'mobile':
            if cost_mode == self.COST_MODE_MANUFACTURE_CANCEL: # note: legacy only - now queue entries store their own cost
                cost_ratio = gamedata['manufacture_cancel_refund']
                time_ratio = spd = 1
            elif cost_mode == self.COST_MODE_RECYCLE:
                cost_ratio = player.get_any_abtest_value('unit_recycle_resources', gamedata['unit_recycle_resources'])
                # note: do not bonus this, to avoid exploits where you increase the unit's cost after it's built, then recycle it
                time_ratio = spd = 1
            elif (cost_mode == self.COST_MODE_REPAIR) and (self.resurrectable or hp_ratio > 0):
                cost_ratio = self.unit_repair_resources if self.unit_repair_resources >= 0 else player.get_any_abtest_value('unit_repair_resources', gamedata['unit_repair_resources'])
                time_ratio = self.unit_repair_time if self.unit_repair_time >= 0 else player.get_any_abtest_value('unit_repair_time', gamedata['unit_repair_time'])
                # XXX grab it from the building instead?
                cost_ratio *= player.stattab.get_unit_stat(self.name, 'repair_cost', 1)
                spd = player.stattab.get_unit_stat(self.name, 'repair_speed', 1)
            else:
                # treat destroyed, non-resurrectable units the same as manufacturing from scratch
                cost_ratio = 1
                time_ratio = 1
                # XXX grab it from the building instead?
                cost_ratio *= player.stattab.get_unit_stat(self.name, 'manufacture_cost', 1)
                spd = player.stattab.get_unit_stat(self.name, 'manufacture_speed', 1)

            health_ratio = 1.0 - hp_ratio
            health_ratio = min(max(health_ratio, 0.0), 1.0)

            ret = dict((res, max(0, int(cost_ratio * health_ratio * self.get_leveled_quantity(getattr(self, 'build_cost_'+res), level)))) \
                       for res in gamedata['resources'])

            ret['time'] = max(1, int(time_ratio * health_ratio * self.get_leveled_quantity(self.build_time, level) / float(spd)))
            return ret
        elif self.kind == 'building':
            repair_time = self.get_leveled_quantity(self.repair_time, level)
            speed_factor = 1
            if obj_id and (obj_id in player.stattab.modded_buildings):
                modstats = player.stattab.modded_buildings[obj_id].modstats
                speed_factor = ModChain.get_stat(modstats.get('repair_speed', None), 1)
            return {'time': max(1, int((1.0-hp_ratio)*(repair_time/speed_factor)))}
        else:
            raise Exception('unknown kind '+self.kind)

class TechSpec(Spec):
    table = {}
    fields = [ ["research_credit_cost", 999],
               ["research_gamebucks_cost", 999],
               ] + resource_fields("cost") + [
               ["research_time", 0],
               ["research_ingredients", None],
               ["upgrade_xp", -1],
               ["proposed_upgrade_xp", -1], # for debug messages only
               ["metric_events", ""],
               ["combat_level", 0],
               ["research_category", None],
               ["associated_unit", None],
               ["affects_unit", None],
               ["affects_manufacture_category", None],
               ["applies_aura", None],
               ["effects", None],
               ["completion", None],
               ["max_ui_level", None],
               ["developer_only", 0]
               ]
    @classmethod
    def lookup(cls, name): return cls.table[name]
    def __init__(self, name, data):
        Spec.__init__(self, name, data)
        self.kind = 'tech'
        self.table[self.name] = self

    def compute_maxlevel(self):
        return len(self.research_time)

    # return the spec of the unit this tech unlocks, if nany
    def unlocks_unit(self):
        if self.associated_unit:
            unit_spec = GameObjectSpec.lookup(self.associated_unit)
            if unit_spec.level_determined_by_tech == self.name:
                return unit_spec
        return None
    def unlocks_unit_category(self):
        unit_spec = self.unlocks_unit()
        if unit_spec:
            return unit_spec.manufacture_category
        return None
    def mods_unit(self):
        if self.affects_unit:
            return GameObjectSpec.lookup(self.affects_unit)
        return None

    def get_research_ingredients_list(self, level):
        if isinstance(self.research_ingredients, list) and len(self.research_ingredients) >= 1 and \
           isinstance(self.research_ingredients[0], list):
            return self.research_ingredients[level-1]
        else:
            return self.research_ingredients or []


class EnhancementSpec(Spec):
    table = {}
    fields = [ ["enhance_credit_cost", 999],
               ["enhance_gamebucks_cost", 999],
               ] + resource_fields("cost") + [
               ["enhance_time", 0],
               ["ingredients", None],
               ["refund_ingredients", False],
               ["xp", -1],
               ["enhancement_category", None],
               ["effects", None],
               ["completion", None],
               ["max_ui_level", None],
               # minimum level the host building must have to apply the enhancement
               # (named min_host_level instead of min_level to avoid confusion with max_level of this spec)
               ["min_host_level", 0],
               ["developer_only", 0]
               ]
    @classmethod
    def lookup(cls, name): return cls.table[name]
    def __init__(self, name, data):
        Spec.__init__(self, name, data)
        self.kind = 'enhancement'
        self.table[self.name] = self

    def compute_maxlevel(self):
        return len(self.enhance_time)

    def get_ingredients_list(self, level):
        if isinstance(self.ingredients, list) and len(self.ingredients) >= 1 and \
           isinstance(self.ingredients[0], list):
            return self.ingredients[level-1]
        else:
            return self.ingredients or []

# load specs from data file
for name, data in gamedata["buildings"].iteritems():
    GameObjectSpec(name, data)
for name, data in gamedata["units"].iteritems():
    GameObjectSpec(name, data)
for name, data in gamedata["inert"].iteritems():
    GameObjectSpec(name, data)
for name, data in gamedata["tech"].iteritems():
    TechSpec(name, data)
for name, data in gamedata["enhancements"].iteritems():
    EnhancementSpec(name, data)

def instantiate_object_for_player(observer, owner, specname, x=-1, y=-1, level=1, build_finish_time = -1, metadata = None, obj_id = None, temporary = None, apply_auras = None, unit_health_modifier = 1.0):
    if observer:
        # create a fresh GameObject for this player, taking into account A/B tests and tech auras
        # subtle distinction: "observer" is the person playing the game, "owner" is the player/AI who owns it
        spec = observer.get_abtest_spec(GameObjectSpec, specname)
    else:
        spec = GameObjectSpec.lookup(specname)

    auras = None

    if spec.permanent_auras or apply_auras:
        perm = [] # list to hold auras
        if spec.permanent_auras:
            perm += spec.permanent_auras # adds any permanent auras into the list of auras
        if apply_auras:
            perm += apply_auras # adds any spawn code auras into the list of auras
        if len(perm) >= 1 and (isinstance(perm[0], list) or perm[0] is None): # could be a list of per-level lists, or a plain all-level list
            perm = spec.get_leveled_quantity(perm, level)

        if perm:
            if not auras: auras = []
            for a in perm:
                Aura.apply_aura(auras, a['aura_name'], a.get('aura_strength',1), range = a.get('aura_range',-1), duration = a.get('aura_duration',-1))

    if obj_id is None: obj_id = gamesite.nosql_id_generator.generate() # for on-the-fly creation not associated with file loads - like new unit production

    if spec.kind == 'building':
        obj = Building(obj_id, spec, owner, x, y, -1, level, build_finish_time, auras)
    elif spec.kind == 'mobile':
        obj = Mobile(obj_id, spec, owner, x, y, -1, level, build_finish_time, auras, temporary = temporary)
        if unit_health_modifier < 1:
            # reduce unit's health to this fraction of its full health
            obj.hp = max(1, int(obj.max_hp * unit_health_modifier))
    elif spec.kind == 'inert':
        obj = Inert(obj_id, spec, owner, x, y, -1, level, build_finish_time, auras, metadata = metadata)
    return obj

def reconstitute_object(observer, player, state, context = 'unknown'):
    specname = state['spec']
    if not GameObjectSpec.exists(specname):
        gamesite.exception_log.event(server_time, "warning: obs %d player %d in %s ignoring obsolete object of spec %s" % (observer.user_id, player.user_id, context, specname))
        return None

    if 'owner_id' in state:
        if state['owner_id'] == EnvironmentOwner.user_id:
            owner = EnvironmentOwner
        elif state['owner_id'] == RogueOwner.user_id:
            owner = RogueOwner
        else:
            owner = player
            if state['owner_id'] != player.user_id:
                if specname != 'barrier':
                    gamesite.exception_log.event(server_time, "warning: obs %d player %d in %s loaded object %s (%s) persisted with owner_id %d" % (observer.user_id, player.user_id, context, state.get('obj_id','noid'), state['spec'], state['owner_id']))

    elif 'owner' in state:
        owner_string = state['owner']
        if owner_string == 'environment':
            owner = EnvironmentOwner
        elif owner_string == 'rogue':
            owner = RogueOwner
        elif owner_string == 'player':
            owner = player
        else:
            gamesite.exception_log.event(server_time, "warning: obs %d player %d in %s loaded object with unknown owner_string %s" % (observer.user_id, player.user_id, context, owner_string))
            owner = player

    elif state.get('force_team') == 'attacker':
        # special flag that the object should be owned by the attacking player, not the base owner
        assert observer
        # note: while creating AI bases in DEV edit mode, observer is player here, but that's OK
        owner = observer
    else:
        owner = player

    if ('obj_id' not in state):
        # add missing ID - can happen on AI loads, or legacy player files that have no IDs, or bad IDs
        state['obj_id'] = gamesite.nosql_id_generator.generate()
    else:
        if (not SpinNoSQLId.is_valid(state['obj_id'])):
            #gamesite.exception_log.event(server_time, "fixing invalid obj_id on player %d in %s state %s" % (player.user_id, context, repr(state)))
            state['obj_id'] = gamesite.nosql_id_generator.generate()

    # create fresh object
    # awkward - reach into state to set level
    # this is because permanent_auras might be keyed by level and instantiate_object_for_player needs to know the level
    obj = instantiate_object_for_player(observer, owner, specname, obj_id = state['obj_id'],
                                        level = state.get('force_level', state.get('level', 1)))

    try:
        # apply mutated state (level, hp, etc)
        obj.unpersist_state(state)
    except:
        gamesite.exception_log.event(server_time, ('unpersist_state error reading obs %d player %d in %s:\n' % (observer.user_id, player.user_id, context)) + repr(state))
        raise

    return obj

def player_aura_counts_against_limit(spec):
    # harmful auras don't count
    if spec.get('harm', False): return False
    # otherwise, look at the "limited" flag
    return spec.get('limited', True)

# confusing: player_auras are raw dicts, but object auras are instances of this class
class Aura (object):
    def __init__(self, spec, strength, range = -1, duration = -1, session_only = False, from_stattab = False):
        self.spec = spec
        self.strength = strength
        self.range = range
        self.duration = duration
        self.session_only = session_only
        self.from_stattab = from_stattab
    def serialize_aura(self):
        return {'name':self.spec['name'], 'strength':self.strength, 'duration':self.duration, 'range':self.range}

    @classmethod
    def apply_aura(cls, aura_list, specname, strength, range = -1, duration = -1, session_only = False, from_stattab = False):
        aura = None
        spec = gamedata['auras'][specname]
        for a in aura_list:
            if a.spec['name'] == specname:
                # already applied
                aura = a
                break
        if aura is not None:
            # stack existing aura
            pass
        else:
            # create new aura
            aura_list.append(Aura(spec, strength, range = range, duration = duration,
                                  session_only = session_only, from_stattab = from_stattab))
        return True

    @classmethod
    def prune_auras(cls, aura_list, is_session_change = False, is_stattab_refresh = False):
        to_remove = []
        for aura in aura_list:
            if (is_session_change and aura.session_only) or \
               (is_stattab_refresh and aura.from_stattab):
                to_remove.append(aura)
        for aura in to_remove: aura_list.remove(aura)

    @classmethod
    def has_aura_with_code(cls, aura_list, code):
        for aura in aura_list:
            if 'effects' in aura.spec:
                for eff in aura.spec['effects']:
                    if eff['code'] == code:
                        return True
        return False

class GameObject(object):
    VIRTUAL_ID = 'VIRTUAL' # stand-in obj_id for "virtual" units
    # note that the client also has a DEAD_ID (='DEAD') for dead units,
    # but that corresponds to a unit that simply doesn't exist server-side,
    # so the server does not have an explicit DEAD_ID.

    def __init__(self, obj_id, spec, owner, x, y, hp, level, build_finish_time_XXX_unused, auras):
        self.obj_id = obj_id # unique primary key value (for regional NoSQL database, and client/server wire protocol)

        # 'team' is set by the Session and is ONLY valid in that context
        self.team = -1

        self.spec = spec
        self.owner = owner
        self.x = x
        self.y = y
        self.level = level
        self.auras = auras
        self.equipment = None
        self.behaviors = None

        self.max_hp = self._calc_max_hp()
        if (hp < 0) or (hp > self.max_hp):
            self.hp = self.max_hp
        else:
            self.hp = hp

        # used for AI bases only
        self.force_ai_level = None
        self.force_team = None

        # flag that indicates the on_approach consequent has already been run during this session
        self.on_approach_fired = False

    # (private) calculate current max HP, taking level into account
    def _calc_max_hp(self):
        return self.get_leveled_quantity(self.spec.max_hp)

    # update max_hp according to spec/level/aura changes,
    # moving the absolute HP value proportionately
    def update_max_hp(self):
        old_max_hp = self.max_hp
        self.max_hp = self._calc_max_hp()
        if self.max_hp == old_max_hp: return

        hp_ratio = 1 if (self.hp == old_max_hp) else float(self.hp)/old_max_hp
        new_min_hp = 0 if (self.max_hp == 0 or self.hp == 0) else 1
        self.hp = min(max(int(hp_ratio * self.max_hp + 0.5), new_min_hp), self.max_hp)

    def heal_to_full(self):
        self.hp = self.max_hp

    # for temporary debugging use only - make sure new "self.max_hp" field matches gamedata
    def check_max_hp(self):
        spec_max = self._calc_max_hp()
        soft_assert(self.max_hp == spec_max)
        self.max_hp = spec_max

    # swap out the spec - only to be used for A/B testing, and cannot change "kind"
    def change_spec(self, newspec):
        self.spec = newspec
        self.update_max_hp()

    # update object level, modifying hitpoints proportionally
    def change_level(self, newlevel):
        if newlevel == self.level: return
        if not (newlevel >= 1 and newlevel <= self.spec.maxlevel):
            gamesite.exception_log.event(server_time, 'bad level on %s owned by player %d: %d (max %d)' % \
                                         (self.spec.name, self.owner.user_id if self.owner else -1, newlevel, self.spec.maxlevel))
            return
        self.level = newlevel
        self.update_max_hp()

    # ensure object is at least at "minlevel"
    def ensure_level(self, minlevel):
        if self.level < minlevel:
            self.change_level(minlevel)

    def change_auras(self, newauras):
        self.auras = newauras
        self.update_max_hp()

    def is_on_destroy_enabled(self):
        if self.auras and Aura.has_aura_with_code(self.auras, 'weak_zombie'): return False
        return True

    def apply_weak_unit_debuffs(self, is_offense):
        hp_ratio = self.hp / max(0.01, float(self.max_hp))
        auras_to_apply = []

        # note: historically, zombie debuff only applied to units on offense.
        # it makes more sense to apply unconditionally, but not doing this yet because it might upset players.
        if is_offense and gamedata['zombie_debuff_threshold'] >= 0 and hp_ratio < gamedata['zombie_debuff_threshold']:
            auras_to_apply.append('weak_zombie')

        if gamedata['weak_secteam_debuff_threshold'] >= 0 and hp_ratio < gamedata['weak_secteam_debuff_threshold']:
            # do we actually carry a secteam?
            on_destroy_list = self.owner.stattab.get_unit_stat(self.spec.name, 'on_destroy', self.get_leveled_quantity(self.spec.on_destroy))
            if on_destroy_list:
                for cons in on_destroy_list:
                    if cons['consequent'] == 'SPAWN_SECURITY_TEAM':
                        auras_to_apply.append('weak_secteam')
                        break

        if auras_to_apply:
            if self.auras is None: self.auras = []
            for a in auras_to_apply:
                Aura.apply_aura(self.auras, a, 1, session_only = True)

        return auras_to_apply

    def serialize_state(self, fake_xy = None, update_hp = True, update_xy = True):
        assert self.team != -1
        if fake_xy:
            x, y = fake_xy
        elif not update_xy:
            x, y = -1, -1
        else:
            x, y = self.x, self.y
        return [self.obj_id, self.spec.name, x, y,
                self.hp if update_hp else -1,
                self.max_hp,
                self.team, self.level, self.equipment, self.behaviors, self.force_team]

    def serialize_auras(self):
        ser = [aura.serialize_aura() for aura in self.auras] if self.auras else None
        return [self.obj_id, ser]

    def persist_state(self, nosql = False):
        assert self.obj_id
        props = { 'obj_id': self.obj_id,
                  'spec': self.spec.name,
                  'xy': [self.x, self.y] }
        if self.level != 1:
            props['level'] = self.level

        if (self.hp < self.max_hp) and (self.max_hp != 0):
            props['hp_ratio'] = float(self.hp)/float(self.max_hp)

        if self.equipment:
            props['equipment'] = self.equipment

        if self.behaviors:
            props['behaviors'] = self.behaviors

        if self.force_ai_level is not None:
            props['force_ai_level'] = self.force_ai_level

        if self.force_team is not None:
            props['force_team'] = self.force_team

        if nosql:
            props['owner_id'] = self.owner.user_id
            props['kind'] = self.spec.kind # denormalized for fast queries on owner/kind
        else:
            if self.owner is EnvironmentOwner:
                props['owner'] = 'environment'
            elif self.owner is RogueOwner:
                props['owner'] = 'rogue'
            else:
                pass # defaults to 'player'

        return props

    def unpersist_state(self, state):
        assert self.obj_id # should have already been set up by reconstitute_object() or the constructor
        if 'obj_id' in state: assert state['obj_id'] == self.obj_id

        if 'xy' in state:
            self.x, self.y = state['xy']
        else:
            self.x, self.y = 0, 0

        self.level = min(max(state.get('level',1), 1), self.spec.maxlevel)
        self.equipment = state.get('equipment')
        self.behaviors = state.get('behaviors')
        self.force_team = state.get('force_team')

        self.update_max_hp()
        max_hp = self.max_hp

        if 'hp_ratio' in state:
            hp_ratio = state['hp_ratio']
            self.hp = int(hp_ratio * max_hp + 0.5)
            # if not fully repaired, drop max_hp to make sure is_damaged() doesn't return false
            if hp_ratio < 1: max_hp -= 1
        elif 'hp' in state: # legacy files
            self.hp = int(state['hp'])
        else:
            self.hp = self.max_hp

        self.hp = min(max(self.hp, 0), self.max_hp)

        self.force_ai_level = state.get('force_ai_level', None)

    def is_under_construction(self):
        return False

    def is_damaged(self):
        if self.max_hp == 0: return False # indestructible object
        return (self.hp < self.max_hp)

    def is_destroyed(self):
        if self.max_hp == 0: return False # indestructible object
        return (self.hp == 0)

    # get level-dependent quantity (based on OBJECT level)
    def get_leveled_quantity(self, qty):
        return GameObjectSpec.get_leveled_quantity(qty, self.level)

    def is_building(self):
        return self.spec.kind == 'building'
    def is_mobile(self):
        return self.spec.kind == 'mobile'
    def is_inert(self):
        return self.spec.kind == 'inert'

    def get_auto_spell(self): return None
    def is_shooter(self): return self.get_auto_spell() is not None
    def is_invisible(self, session): return False

    def cost_to_repair(self, player, builder = None):
        return self.spec.cost_to_repair(self.level, self.hp/float(self.max_hp), player, self.obj_id, builder = builder)
    def time_to_repair(self, player, builder = None):
        return self.cost_to_repair(player, builder = builder)['time']

class Mobile(GameObject):
    def __init__(self, obj_id, spec, owner, x, y, hp, level, build_finish_time, auras, temporary = None):
        GameObject.__init__(self, obj_id, spec, owner, x, y, hp, level, build_finish_time, auras)
        self.squad_id = None
        self.orders = None
        self.patrol = None
        self.pack_id = None
        self.temporary = temporary # indicates a "temporary" unit like a security team
    def serialize_state(self, fake_xy = None, update_hp = True):
        return GameObject.serialize_state(self, fake_xy = fake_xy, update_hp = update_hp) + [self.squad_id,self.orders, self.patrol, self.pack_id, self.temporary]
    def persist_state(self, **args):
        ret = GameObject.persist_state(self, **args)
        if self.squad_id is not None:
            ret['squad_id'] = self.squad_id
        if self.orders:
            ret['orders'] = self.orders
        if self.patrol:
            ret['patrol'] = self.patrol
        if self.pack_id:
            ret['pack_id'] = self.pack_id
        if self.temporary:
            ret['temporary'] = self.temporary
        return ret
    def unpersist_state(self, state):
        GameObject.unpersist_state(self, state)
        if 'orders' in state:
            orders = state['orders']
            if type(orders) is list:
                self.orders = state['orders']
            else:
                gamesite.exception_log.event(server_time, 'Mobile orders that are not a list: %s' % repr(orders))
        self.patrol = int(not (not state.get('patrol', None)))
        self.pack_id = state.get('pack_id', None)
        self.squad_id = state.get('squad_id', None)
        self.temporary = state.get('temporary', None)

    def is_temporary(self): return bool(self.temporary)

    def is_on_destroy_enabled(self):
        if not GameObject.is_on_destroy_enabled(self): return False
        if self.auras and Aura.has_aura_with_code(self.auras, 'weak_secteam'): return False
        return True

    # reposition in middle of map, used for deploying squad units that don't have positions yet
    def ensure_mobile_position(self, base_ncells):
        if self.x < 0 or self.y < 0 or self.x >= base_ncells[0] or self.y >= base_ncells[1]:
            self.x = int(base_ncells[0]/2 + (2*random.random()-1)*gamedata['client']['squad_deploy_spread'])
            self.y = int(base_ncells[1]/2 + (2*random.random()-1)*gamedata['client']['squad_deploy_spread'])

    # clean up position and orders to get the unit ready for squad deployment
    def reset_as_squad_unit(self, base_ncells):
        self.x = self.y = -1
        self.ensure_mobile_position(base_ncells)
        self.patrol = None
        self.pack_id = None # ?
        self.orders = copy.copy(gamedata['client']['squad_deploy_ai_orders'])

    def get_auto_spell(self):
        spellname = self.owner.stattab.get_unit_stat(self.spec.name, 'weapon', self.spec.spells[0] if self.spec.spells else None)
        if spellname:
            spell = self.owner.get_abtest_spell(spellname)
            if spell.get('activation') == 'auto':
                return spell
        return None

    def is_invisible(self, session):
        if self.spec.invis_on_hold and self.orders and len(self.orders) == 1 and \
           not self.orders[0].get('aggressive',False) and \
           self.orders[0]['state'] == 4: # ai_states.AI_ATTACK_STATIONARY
            # check if in friendly base
            if self.owner.user_id == session.viewing_base.base_landlord_id:
                if session.viewing_base.base_type not in ('quarry', 'squad'):
                    return True
        return False

class MapBlockingGameObject(GameObject):
    # note: this is a recent addition, Inert/Building used to inherit directly from GameObject
    # not all appropriate fields have been carried over yet
    def __init__(self, *args, **kwargs):
        GameObject.__init__(self, *args, **kwargs)
        self.removing = None
    def serialize_state(self, update_hp = True, update_xy = True):
        return GameObject.serialize_state(self, update_hp = update_hp, update_xy = update_xy) + \
               [self.removing.serialize_state() if self.removing else None]
    def persist_state(self, **args):
        ret = GameObject.persist_state(self, **args)
        if self.removing: ret['removing'] = self.removing.persist_state()
        return ret
    def unpersist_state(self, state):
        GameObject.unpersist_state(self, state)
        if 'removing' in state:
            self.removing = Business.reconstitute(Business.RemoveBusiness, state['removing'])
    def is_removing(self):
        return bool(self.removing)
    def halt_removing(self):
        if self.removing:
            return self.removing.halt(server_time)
        return False
    def update_removing(self, undamaged_time = -1, ref_time = -1):
        if not self.removing: return False
        if ref_time < 0: ref_time = server_time
        return self.removing.resume(undamaged_time, ref_time)
    def activity_finish_time(self):
        if self.is_removing():
            ret = self.removing.total_time - self.removing.done_time
            if self.removing.start_time > 0:
                ret -= max(0, server_time - self.removing.start_time)
            return max(0, ret)
        return -1
    def activity_speedup_kind(self):
        if self.is_removing():
            return 'remove'
        return None
    def activity_description(self, player):
        if self.is_removing():
            return 'remove,' + self.removing.describe_state()
        return 'nothing'
    def update_all(self, undamaged_time = -1, ref_time = -1, power_factor = 1):
        self.update_removing(undamaged_time, ref_time)

class Inert(MapBlockingGameObject):
    def __init__(self, obj_id, spec, owner, x, y, hp, level, build_finish_time, auras, metadata=None):
        MapBlockingGameObject.__init__(self, obj_id, spec, owner, x, y, hp, level, build_finish_time, auras)
        self.metadata = metadata
        self.creation_time = -1
    def serialize_state(self, update_hp = True, update_xy = True):
        return MapBlockingGameObject.serialize_state(self, update_hp = update_hp, update_xy = update_xy) + [self.metadata,]
    def persist_state(self, **args):
        ret = MapBlockingGameObject.persist_state(self, **args)
        if self.metadata:
            ret['metadata'] = self.metadata
        if self.creation_time != -1:
            ret['creation_time'] = self.creation_time
        return ret

    def unpersist_state(self, state):
        MapBlockingGameObject.unpersist_state(self, state)
        self.metadata = state.get('metadata', None)
        self.creation_time = state.get('creation_time', -1)

# note: "produce" means "accumulate resource over time"
# "manufacture" means "make mobile units" (even though this is called "Production" in the GUI)

class Building(MapBlockingGameObject):

    def __init__(self, obj_id, spec, owner, x, y, hp, level, build_finish_time, auras):
        MapBlockingGameObject.__init__(self, obj_id, spec, owner, x, y, hp, level, build_finish_time, auras)
        self.repair_finish_time = -1

        # for turrets, 'disarmed' flag gets set when repairs are initiated, and cleared when fully repaired
        self.disarmed = False

        # TIME CONVENTIONS
        # "total" time = total duration for entire action from start to finish
        # "start" time = server_time at which the building started work. Can be -1 if the work is halted due to battle damage.
        # "done" time = duration of work done so far, *prior to start time activating*
        # actual PROGRESS = "done" time plus (server_time - "start" time IF "start" time is >0)

        self.build_total_time = -1
        self.build_start_time = -1
        self.build_done_time = -1

        if build_finish_time > 0:
            self.build_start_time = server_time
            self.build_total_time = build_finish_time - server_time
            self.build_done_time = 0

        self.upgrade_total_time = -1
        self.upgrade_start_time = -1
        self.upgrade_done_time = -1
        self.upgrade_ingredients = None # doubles as build_ingredients
        self.upgrade_help = None # when upgrading, this becomes an UpgradeHelp instance

        self.research_item = ''
        self.research_total_time = -1
        self.research_start_time = -1
        self.research_done_time = -1
        self.research_ingredients = None

        # harvester production tracking
        # NOTE: in order to minimize the amount of work the server must do to track state,
        # we use the following convention: the number of units held by a harvester is equal
        # to self.contents, plus ((server_time-produce_start_time)/3600)*produce_rate. However, if
        # produce_start_time == -1, then it's just self.contents.

        self.produce_start_time = -1
        self.produce_rate = -1
        self.contents = 0

        # queue of units to be manufactured
        # each entry is a dictionary with fields 'spec_name', 'level' (of the unit), and 'total_time'
        self.manuf_queue = []
        self.manuf_start_time = -1
        self.manuf_done_time = -1

        self.enhancing = None
        self.crafting = None
        self.config = None

        self.modstats = {}
        self.enhancements = None

    def get_stat(self, stat, default_value):
        return ModChain.get_stat(self.modstats.get(stat, None), default_value)

    def heal_to_full(self):
        MapBlockingGameObject.heal_to_full(self)
        self.disarmed = False

    def serialize_state(self, update_hp = True, update_xy = True):
        return MapBlockingGameObject.serialize_state(self, update_hp = update_hp, update_xy = update_xy) + [self.repair_finish_time, self.build_total_time, self.build_start_time, self.build_done_time, self.upgrade_total_time, self.upgrade_start_time, self.upgrade_done_time, self.upgrade_help.persist_state() if self.upgrade_help else -1, self.research_item, self.research_total_time, self.research_start_time, self.research_done_time, self.produce_start_time, self.produce_rate, self.contents, self.manuf_queue, self.manuf_start_time, self.manuf_done_time, self.disarmed, self.crafting.serialize_state() if self.crafting else None, self.config, self.enhancing.serialize_state() if self.enhancing else None, copy.deepcopy(self.enhancements)]

    def persist_state(self, **args):
        ret = MapBlockingGameObject.persist_state(self, **args)
        if self.repair_finish_time > 0:
            ret['repair_finish_time'] = self.repair_finish_time
        if self.build_total_time > 0:
            ret['build_total_time'] = self.build_total_time
            ret['build_start_time'] = self.build_start_time
            ret['build_done_time'] = self.build_done_time
        if self.disarmed:
            ret['disarmed'] = self.disarmed
        if self.research_item:
            ret['research_item'] = self.research_item
            ret['research_total_time'] = self.research_total_time
            ret['research_start_time'] = self.research_start_time
            ret['research_done_time'] = self.research_done_time
            ret['research_ingredients'] = copy.deepcopy(self.research_ingredients)
        if self.upgrade_total_time > 0:
            ret['upgrade_total_time'] = self.upgrade_total_time
            ret['upgrade_start_time'] = self.upgrade_start_time
            ret['upgrade_done_time'] = self.upgrade_done_time
            ret['upgrade_ingredients'] = copy.deepcopy(self.upgrade_ingredients)
            ret['upgrade_help'] = self.upgrade_help.persist_state()
        if self.produce_start_time > 0:
            ret['produce_start_time'] = self.produce_start_time
        if self.produce_rate > 0:
            ret['produce_rate'] = self.produce_rate
        if self.contents > 0:
            ret['contents'] = self.contents
        if len(self.manuf_queue) > 0:
            ret['manuf_queue'] = self.manuf_queue
            ret['manuf_start_time'] = self.manuf_start_time
            ret['manuf_done_time'] = self.manuf_done_time
        if self.crafting: ret['crafting'] = self.crafting.persist_state()
        if self.enhancing: ret['enhancing'] = self.enhancing.persist_state()
        if self.enhancements: ret['enhancements'] = copy.deepcopy(self.enhancements)
        if self.config:
            ret['config'] = copy.deepcopy(self.config)
        return ret

    def unpersist_state(self, state):
        MapBlockingGameObject.unpersist_state(self, state)
        self.repair_finish_time = state.get('repair_finish_time',-1)
        self.disarmed = state.get('disarmed', False)
        self.produce_start_time = state.get('produce_start_time', -1)
        self.produce_rate = state.get('produce_rate', -1)
        self.contents = state.get('contents', 0)

        self.research_item = state.get('research_item', '')
        self.research_ingredients = state.get('research_ingredients', None)

        # migrate old time tracking formats
        if state.get('research_finish_time', -1) > 0:
            assert self.research_item
            self.research_total_time = state['research_finish_time'] - server_time
            if self.research_total_time >= 10:
                self.research_done_time = 0
                self.research_start_time = server_time
            else:
                # call it done
                self.research_done_time = 0
                self.research_total_time = 1
                self.research_start_time = server_time - 10
        else:
            self.research_total_time = state.get('research_total_time', -1)
            self.research_start_time = state.get('research_start_time', -1)
            self.research_done_time = state.get('research_done_time', -1)

        if state.get('build_finish_time', -1) > 0:
            self.build_total_time = state['build_finish_time'] - server_time
            if self.build_total_time >= 10:
                self.build_done_time = 0
                self.build_start_time = server_time
            else:
                self.build_done_time = 0
                self.build_total_time = 1
                self.build_start_time = server_time - 10
        else:
            self.build_total_time = state.get('build_total_time', -1)
            self.build_start_time = state.get('build_start_time', -1)
            self.build_done_time = state.get('build_done_time', -1)

        if state.get('upgrade_finish_time', -1) > 0:
            self.upgrade_total_time = state['upgrade_finish_time'] - server_time
            if self.upgrade_total_time >= 10:
                self.upgrade_done_time = 0
                self.upgrade_start_time = server_time
            else:
                self.upgrade_done_time = 0
                self.upgrade_total_time = 1
                self.upgrade_start_time = server_time - 10
            self.upgrade_help = UpgradeHelp.UpgradeHelp(state.get('upgrade_help', state.get('upgrade_helped', -1)))
        else:
            self.upgrade_total_time = state.get('upgrade_total_time',-1)
            self.upgrade_start_time = state.get('upgrade_start_time',-1)
            self.upgrade_done_time = state.get('upgrade_done_time',-1)
            self.upgrade_ingredients = state.get('upgrade_ingredients', None)
            if self.upgrade_total_time > 0: # upgrade in progress
                self.upgrade_help = UpgradeHelp.UpgradeHelp(state.get('upgrade_help', state.get('upgrade_helped', -1)))
            else: # no upgrade in progress
                self.upgrade_help = None

        self.manuf_queue = state.get('manuf_queue', [])
        if len(self.manuf_queue) > 0 and ('manuf_start_time' not in state):
            # migrate
            self.manuf_start_time = server_time
            self.manuf_done_time = 0
            last_time = server_time
            for item in self.manuf_queue:
                item['total_time'] = item['finish_time'] - last_time
                last_time = item['finish_time']
                del item['finish_time']
        else:
            self.manuf_start_time = state.get('manuf_start_time', -1)
            self.manuf_done_time = state.get('manuf_done_time', -1)

        if 'crafting' in state:
            self.crafting = Business.reconstitute(lambda: Business.QueuedBusiness(Business.CraftingBusiness), state['crafting'])
        if 'enhancing' in state:
            self.enhancing = Business.reconstitute(Business.EnhanceBusiness, state['enhancing'])

        if 'enhancements' in state:
            self.enhancements = state['enhancements']

        if 'config' in state:
            self.config = copy.deepcopy(state['config'])

    def update_repair_hp_only(self, ref_time = -1):
        if ref_time < 0: ref_time = server_time

        # ONLY update hitpoints for client battle purposes
        # do NOT actually set repair_finish_time=-1, let the client trigger that with PING_OBJECT
        # because it needs to go through the power_changed path etc.
        if self.repair_finish_time > 0:
            # bump hp up to what it should be after the elapsed time
            percent_unrepaired = float(self.repair_finish_time - ref_time) / (self.get_leveled_quantity(self.spec.repair_time) / self.get_stat('repair_speed', 1))

            # do not let hp == self.max_hp, since that will make is_damaged() false and throw off other code
            max_hp = self.max_hp - 1

            new_hp = int(min(max(max(self.hp, (1.0-percent_unrepaired)*max_hp), 0), max_hp))

            self.hp = new_hp

    def halt_repair(self):
        self.update_repair_hp_only()
        disrupted = (self.repair_finish_time > 0)
        self.repair_finish_time = -1
        return disrupted

    def update_production(self, player, base_type, base_region, power_factor, undamaged_time = -1, ref_time = -1):
        # base may be None if you are just going to halt immediately

        if not self.is_producer():
            return

        if ref_time < 0: ref_time = server_time

        capacity = self.get_leveled_quantity(self.spec.production_capacity)

        # adjust by A/B test modifier
        yield_rate = 1
        if base_type == 'quarry' and (base_region in gamedata['regions']):
            yield_rate *= self.spec.quarry_yield
            yield_rate *= gamedata['regions'][base_region].get('quarry_yield', 1)

        #capacity = int(capacity * player.get_abtest_value('T001_harvester_cap', 'modifier', 1))

        # update self.contents and reset produce_start_time
        old_start_time = self.produce_start_time
        old_rate = self.produce_rate
        pre_added = 0

        if (self.produce_start_time > 0):
            assert (self.produce_rate > 0)

            pre_added = int((float(self.produce_rate) * (ref_time - self.produce_start_time))/(60.0*60.0))
            self.contents = max(0, min(self.contents + pre_added, capacity))

        # zero out ongoing production
        self.produce_start_time = -1
        self.produce_rate = -1

        # now restart production
        if self.is_damaged() or self.is_upgrading() or self.is_under_construction() or self.is_enhancing() or self.is_removing() or (self.contents >= capacity):
            # can't make anything
            pass
        else:
            units_per_hour = max(
                self.get_stat('produces_'+res, self.get_leveled_quantity(getattr(self.spec, 'produces_'+res))) \
                for res in gamedata['resources'])

            units_per_hour = max(0, int(units_per_hour * power_factor * yield_rate * player.get_any_abtest_value('global_harvest_coeff', gamedata['global_harvest_coeff'])))

            if (units_per_hour > 0):
                self.produce_rate = units_per_hour

                if undamaged_time > 0:
                    self.produce_start_time = undamaged_time
                else:
                    self.produce_start_time = ref_time

        if 0:
            gamesite.exception_log.event(server_time, '%s\nupdate_production(): %d %s L%d OLD start %d rate %d - added %d, power %.2f - NEW start %d rate %d' % \
                                         (''.join(traceback.format_stack()), ref_time, self.spec.name, self.level, old_start_time, old_rate, pre_added, power_factor, self.produce_start_time, self.produce_rate))

    def halt_production(self, player):
        self.update_production(player, None, None, 1)
        disrupted = (self.produce_start_time > 0)
        self.produce_start_time = -1
        self.produce_rate = -1
        return disrupted

    def halt_research(self):
        if self.research_start_time > 0:
            # give credit for time elapsed, then halt
            self.research_done_time += (server_time - self.research_start_time)
            self.research_start_time = -1
            return True
        return False

    def halt_build(self):
        if self.build_start_time > 0:
            self.build_done_time += (server_time - self.build_start_time)
            self.build_start_time = -1
            return True
        return False

    def halt_upgrade(self): # and keep progress
        if self.upgrade_start_time > 0:
            self.upgrade_done_time += (server_time - self.upgrade_start_time)
            self.upgrade_start_time = -1
            return True
        return False

    def cancel_upgrade(self):
        self.upgrade_total_time = -1
        self.upgrade_start_time = -1
        self.upgrade_done_time = -1
        self.upgrade_ingredients = None
        self.upgrade_help = None

    def halt_manuf(self):
        if self.manuf_start_time > 0:
            self.manuf_done_time += (server_time - self.manuf_start_time)
            self.manuf_start_time = -1
            return True
        return False

    def halt_crafting(self, force): # if force is false, do not halt recipes that are marked unhaltable (by damage)
        if self.crafting:
            if self.crafting.queue[0].craft_state['recipe'] in gamedata['crafting']['recipes'] and \
               (not gamedata['crafting']['categories'][gamedata['crafting']['recipes'][self.crafting.queue[0].craft_state['recipe']]['crafting_category']].get('haltable',True)):
                return False # cannot be halted by damage
            return self.crafting.halt(server_time)
        return False

    def halt_enhancing(self):
        if self.enhancing:
            return self.enhancing.halt(server_time)
        return False

    def cancel_enhancing(self):
        self.enhancing = None

    # halt all activity (due to getting damaged). Return True if the halting counts as "havoc".
    def halt_all(self):
        disrupted = False
        self.halt_repair()
        self.halt_production(self.owner)
        disrupted |= self.halt_research()
        disrupted |= self.halt_build()
        disrupted |= self.halt_upgrade()
        disrupted |= self.halt_enhancing()
        disrupted |= self.halt_removing() # halt removing?
        self.halt_manuf()
        self.halt_crafting(False)
        return disrupted

    # try to restart research - assume building reached full health at "undamaged_time" (-1 if it was always at full health)
    def update_research(self, undamaged_time = -1, ref_time = -1):
        if ref_time < 0: ref_time = server_time

        if not self.research_item: return
        if self.repair_finish_time > 0 or self.is_damaged(): return
        if self.research_start_time > 0: return
        if undamaged_time >= 0:
            self.research_done_time += ref_time - undamaged_time
        self.research_start_time = ref_time

    def update_build(self, undamaged_time = -1, ref_time = -1):
        if ref_time < 0: ref_time = server_time

        if self.build_total_time < 0: return
        if self.repair_finish_time > 0 or self.is_damaged(): return
        if self.build_start_time > 0: return
        if undamaged_time >= 0:
            self.build_done_time += ref_time - undamaged_time
        self.build_start_time = ref_time

    def update_upgrade(self, undamaged_time = -1, ref_time = -1):
        if ref_time < 0: ref_time = server_time

        if self.upgrade_total_time < 0: return
        if self.repair_finish_time > 0 or self.is_damaged(): return
        if self.upgrade_start_time > 0: return
        if undamaged_time >= 0:
            self.upgrade_done_time += ref_time - undamaged_time
        self.upgrade_start_time = ref_time

    def update_manuf(self, undamaged_time = -1, ref_time = -1):
        if ref_time < 0: ref_time = server_time

        if len(self.manuf_queue) < 1: return
        if self.repair_finish_time > 0 or self.is_damaged(): return
        if self.manuf_start_time > 0: return
        if undamaged_time >= 0:
            self.manuf_done_time += ref_time - undamaged_time
        self.manuf_start_time = ref_time

    def update_crafting(self, undamaged_time = -1, ref_time = -1):
        if ref_time < 0: ref_time = server_time

        if not self.crafting: return False
        recipe_name = self.crafting.queue[0].craft_state['recipe']
        if recipe_name in gamedata['crafting']['recipes']:
            category_name = gamedata['crafting']['recipes'][recipe_name]['crafting_category']
            if category_name in gamedata['crafting']['categories']:
                if gamedata['crafting']['categories'][category_name].get('haltable',True) and \
                   (self.repair_finish_time > 0 or self.is_damaged()): return False
        return self.crafting.resume(undamaged_time, ref_time)

    def update_enhancing(self, undamaged_time = -1, ref_time = -1):
        if ref_time < 0: ref_time = server_time

        if not self.enhancing: return False
        return self.enhancing.resume(undamaged_time, ref_time)

    # note! does not update_production! that has a more delicate relationship with power and time, so it's handled separately
    def update_all(self, undamaged_time = -1, ref_time = -1, power_factor = 1):
        MapBlockingGameObject.update_all(self, undamaged_time, ref_time, power_factor)
        self.update_repair_hp_only(ref_time = ref_time)
        self.update_research(undamaged_time = undamaged_time, ref_time = ref_time)
        self.update_upgrade(undamaged_time = undamaged_time, ref_time = ref_time)
        self.update_build(undamaged_time = undamaged_time, ref_time = ref_time)
        self.update_manuf(undamaged_time = undamaged_time, ref_time = ref_time)
        self.update_crafting(undamaged_time = undamaged_time, ref_time = ref_time)
        self.update_enhancing(undamaged_time = undamaged_time, ref_time = ref_time)

    # harvest up to 'limit' resources and return # of units harvested
    # must call update_production() afterward to unhalt!
    def harvest(self, player, limit):
        if not self.is_producer():
            return 0

        self.halt_production(player)
        harvested = min(self.contents, limit)
        self.contents -= harvested

        return harvested

    # for storages and harvesters, return dictionary of maximum {"resource":amount} stored (for base_resource_loot computations only)
    def resource_loot_contribution(self):
        ret = None
        for res in gamedata['resources']:
            amount = self.get_leveled_quantity(getattr(self.spec, 'storage_'+res))
            if self.get_leveled_quantity(getattr(self.spec, 'produces_'+res)) > 0:
                amount += self.get_leveled_quantity(self.spec.production_capacity)
            if amount > 0:
                if ret is None: ret = {}
                ret[res] = ret.get(res,0) + amount
        return ret

    # for Specific ResLoot, optionally take a fraction of the base's total loot instead of using a capacity-weighted contribution
    def _specific_loot_fraction(self, pve_or_pvp):
        ret = None
        for res in gamedata['resources']:
            amount = self.get_leveled_quantity(getattr(self.spec, 'specific_'+pve_or_pvp+'_loot_fraction_'+res))
            if amount >= 0: # note: treat -1 as "no effect", 0 as "fraction is zero"
                if ret is None: ret = {}
                ret[res] = amount
        return ret
    def specific_pve_loot_fraction(self): return self._specific_loot_fraction('pve')
    def specific_pvp_loot_fraction(self): return self._specific_loot_fraction('pvp')

    def may_contain_loot(self):
        if self.spec.worth_less_xp: return False
        return self.is_storage() or \
               self.is_producer() or \
               any(getattr(self.spec, 'specific_pve_loot_fraction_'+res) for res in gamedata['resources']) or \
               any(getattr(self.spec, 'specific_pvp_loot_fraction_'+res) for res in gamedata['resources'])

    def affects_power(self):
        return bool(self.spec.provides_power) or \
               bool(self.spec.consumes_power) or \
               (self.equipment and any((item['spec'] in gamedata['items'] and gamedata['items'][item['spec']]['equip'].get('consumes_power',0)>0) \
                                       for item in Equipment.equip_iter(self.equipment))) or \
               (self.is_crafting() and any(entry.craft_state['recipe'] in gamedata['crafting']['recipes'] and \
                                           gamedata['crafting']['recipes'][entry.craft_state['recipe']].get('consumes_power',0)>0 \
                                           for entry in self.crafting.queue))

    def affects_player_stattab(self):
        return self.spec.manufacture_category or self.spec.provides_space or self.spec.provides_squad_space or \
               self.spec.provides_total_space or \
               self.spec.permanent_modstats or \
               self.spec.raid_range_pvp or self.spec.raid_range_pve or \
               self.spec.provides_deployed_squads or self.spec.provides_deployed_raids or \
               self.is_producer() or self.spec.provides_foremen

    def is_producer(self):
        return (self.get_leveled_quantity(self.spec.production_capacity) > 0)

    def is_researcher(self):
        return "RESEARCH_FOR_FREE" in self.spec.spells

    def is_manufacturer(self):
        return "MAKE_DROIDS" in self.spec.spells

    def is_crafter(self):
        return "CRAFT_FOR_FREE" in self.spec.spells

    def is_lottery_building(self):
        return "LOTTERY_SCAN" in self.spec.spells

    def is_storage(self):
        for res in gamedata['resources']:
            if self.get_leveled_quantity(getattr(self.spec, 'storage_'+res)) > 0:
                return True
        return False

    def is_minefield(self):
        return self.spec.equip_slots and ('mine' in self.spec.equip_slots)
    def is_minefield_armed(self):
        return self.equipment and Equipment.equip_has(self.equipment, ('mine',0))
    def minefield_item(self): # note: returns spec name
        item = Equipment.equip_get(self.equipment, ('mine',0))
        if item: return item['spec']
        if self.config and self.config['mine'] and len(self.config['mine']) > 0:
            if isinstance(self.config['mine'], basestring):
                return self.config['mine']
            elif isinstance(self.config['mine'][0], basestring):
                return self.config['mine'][0]
            else:
                return self.config['mine'][0]['spec']
        return None
    def is_emplacement(self):
        return self.spec.equip_slots and ('turret_head' in self.spec.equip_slots)
    def is_emplacement_armed(self):
        return self.equipment and Equipment.equip_has(self.equipment, ('turret_head',0))
    def turret_head_item(self): # note: returns spec name
        item = Equipment.equip_get(self.equipment, ('turret_head',0))
        if item: return item['spec']
        return None

    def is_repairing(self):
        return (self.repair_finish_time > 0)

    def is_under_construction(self):
        return (self.build_total_time > 0)

    def is_upgrading(self):
        return (self.upgrade_total_time > 0)

    def is_enhancing(self):
        return bool(self.enhancing)

    def is_researching(self):
        return (not (not self.research_item))

    def is_manufacturing(self):
        return (len(self.manuf_queue) > 0)

    def is_crafting(self):
        # note: this can be true if there are uncollected products, but no activity taking place
        return bool(self.crafting)

    def crafting_time_left_all(self):
        if not self.crafting: return 0
        ret = 0
        for bus in self.crafting.queue:
            ret += bus.total_time - bus.done_time
            if bus.start_time > 0:
                ret -= max(0, server_time - bus.start_time)
        return max(0, ret)

    def activity_finish_time(self):
        if self.is_repairing():
            return self.repair_finish_time
        elif self.is_upgrading():
            if self.upgrade_start_time > 0:
                return self.upgrade_start_time + (self.upgrade_total_time - self.upgrade_done_time)
            else:
                return -1
        elif self.is_enhancing():
            return self.enhancing.finish_time()
        elif self.is_removing():
            return self.removing.finish_time()
        elif self.is_under_construction():
            if self.build_start_time > 0:
                return self.build_start_time + (self.build_total_time - self.build_done_time)
            else:
                return -1
        elif self.is_researching():
            if self.research_start_time > 0:
                return self.research_start_time + (self.research_total_time - self.research_done_time)
            else:
                return -1
        elif self.is_manufacturing():
            if self.manuf_start_time > 0:
                return self.manuf_start_time + sum([item['total_time'] for item in self.manuf_queue]) - self.manuf_done_time
            else:
                return -1
        elif self.is_crafting():
            return self.crafting.finish_time()
        else:
            return -1
    def activity_description(self, player):
        ret = MapBlockingGameObject.activity_description(self, player)
        if ret != 'nothing': return ret
        if self.is_repairing():
            return 'repair'
        elif self.is_upgrading():
            return 'upgrade,level%d' % (self.level+1)
        elif self.is_enhancing():
            return 'enhance,' + self.enhancing.describe_state()
        elif self.is_under_construction():
            return 'construct'
        elif self.is_researching():
            ret = 'research,' + self.research_item
            cur_level = player.tech.get(self.research_item, 0)
            ret += ',level%d' % (cur_level+1)
            return ret
        elif self.is_manufacturing():
            return 'manufacture,' + self.manuf_queue[0]['spec_name']
        elif self.is_crafting():
            return 'craft,'+self.crafting.describe_state()
        else:
            return 'nothing'
    def activity_speedup_kind(self):
        ret = MapBlockingGameObject.activity_speedup_kind(self)
        if ret: return ret
        if self.is_repairing():
            return 'building_repair'
        elif self.is_upgrading() or self.is_under_construction():
            return 'building_upgrade'
        elif self.is_enhancing():
            return 'building_enhance'
        elif self.is_researching():
            return 'tech_research'
        elif self.is_manufacturing():
            return 'unit_manufacture'
        elif self.is_crafting():
            return 'crafting'
        else:
            return None

    def is_busy(self):
        return self.is_repairing() or \
               self.is_under_construction() or self.is_upgrading() or self.is_enhancing() or self.is_removing() or \
               self.is_researching() or self.is_manufacturing() or \
               (self.is_crafting() and self.crafting_time_left_all() > 0)

    def is_using_foreman(self):
        if self.is_under_construction() or self.is_upgrading() or self.is_enhancing(): return True # removing does not use foreman
        # check for in-progress crafting tasks that need a foreman
        if self.is_crafting():
            for entry in self.crafting.queue:
                if not entry.is_complete(server_time):
                    if entry.craft_state['recipe'] in gamedata['crafting']['recipes']:
                        if gamedata['crafting']['categories'][gamedata['crafting']['recipes'][entry.craft_state['recipe']]['crafting_category']].get('foreman', False):
                            return True
        return False

    def get_auto_spell(self):
        spellname = self.get_stat('weapon', self.spec.spells[0] if self.spec.spells else None)
        if spellname:
            spell = self.owner.get_abtest_spell(spellname)
            if spell.get('activation') == 'auto':
                return spell
        return None

    def is_invisible(self, session): return self.spec.invisible

    # returns list of items destroyed
    def destroy_fragile_equipment_items(self):
        if not self.equipment: return []
        to_destroy = []
        for addr, item in Equipment.equip_enumerate(self.equipment):
            if item['spec'] in gamedata['items']:
                spec = gamedata['items'][item['spec']]
                if spec.get('fragility',0) > 0 and random.random() < spec['fragility']:
                    to_destroy.append((addr, item))
        return [Equipment.equip_remove(self.equipment, addr, item['spec']) for addr, item in to_destroy]

class ResourceStateSnapshot:
    def __init__(self, inventory, res_max, res_cur, gamebucks, facebook_credits, player_level, xp, protection_end_time):
        self.inventory = inventory
        self.res_max = res_max
        self.res_cur = res_cur
        # for legacy code
        for res in gamedata['resources']: setattr(self, res, [res_max[res], res_cur[res]])
        self.gamebucks = gamebucks
        self.facebook_credits = facebook_credits
        self.player_level = player_level
        self.xp = xp
        self.protection_end_time = protection_end_time

    def serialize(self, enemy = False):
        if enemy:
            prot_end_time = conceal_protection_time(self.protection_end_time)
        else:
            prot_end_time = self.protection_end_time
        ret = { "gamebucks": self.gamebucks,
                "facebook_credits": self.facebook_credits,
                "player_level": self.player_level, "xp": self.xp,
                "protection_end_time": prot_end_time }
        for res in gamedata['resources']: ret[res] = getattr(self, res)
        return ret
    def max_res(self, res): return self.res_max[res]
    def cur_res(self, res): return self.res_cur[res]
    def max_inventory(self): return self.inventory[0]
    def cur_inventory(self): return self.inventory[1]
    def reserved_inventory(self): return self.inventory[2]
    def max_usable_inventory(self): return self.max_inventory() - self.reserved_inventory()

# if power usage exceeds the supply, then reduce unit/building
# effectiveness by this factor (in the range 0-1)
def compute_power_factor(power):
    if power[1] <= power[0]:
        return 1
    else:
        return power[0] / (1.0*power[1])


class ResourceState:
    def __init__(self, player):
        self.player = player # used for metrics and home_base_iter
        for res in gamedata['resources']:
            setattr(self, res, gamedata['starting_conditions'].get(res,0))
        self.gamebucks = 0 # given in player.migrate - gamedata['starting_conditions']['gamebucks']
        self.facebook_credits = -1
        self.player_level = 1
        self.xp = gamedata['starting_conditions']['xp']
        self.protection_end_time = -1

        # base_size used to be stored in playerdb but now it is
        # base-specific so it must be migrated to basedb
        self.OLD_base_size = 0

    def get_fungible_amounts(self):
        return dict((res, getattr(self, res)) for res in gamedata['resources'])

    def gain_xp(self, amount, reason='', metadata = None):
        if amount == 0: return

        warn_threshold = gamedata['server'].get('gain_xp_warn_threshold',-1)
        if warn_threshold > 0 and amount >= warn_threshold:
            gamesite.exception_log.event(server_time, 'gain_xp(): player %d unusually large gain of %r (reason %r meta %r)\n%s' % \
                                         (self.player.user_id, amount, reason, metadata, ''.join(traceback.format_stack())))

        self.xp += amount

        if LOTS_OF_METRICS:
            user_id = self.player.user_id
            if not is_ai_user_id_range(user_id):
                if metadata is None:
                    metadata = {}
                metadata['gain_amount'] = amount
                metadata['method'] = reason
                metric_event_coded(user_id, '2400_xp_gain', metadata)

    def gain_gamebucks(self, amount, reason='', subreason=''):
        if amount == 0: return
        self.gamebucks += amount
        dict_setmax(self.player.history, 'peak_gamebucks', self.gamebucks)

        if gamedata['server'].get('log_econ_res', False) and gamedata['server'].get('log_econ_res_gamebucks', True):
            props = {'user_id':self.player.user_id, 'res':{'gamebucks':amount}, 'cat':reason}
            #if subreason: props['sub'] = subreason.split(',')[0] # just get the spellname only
            props.update(self.player.get_denormalized_summary_props('brief'))
            gamesite.nosql_client.log_record('econ_res', server_time, props, log_ident = False, reason = 'gain_gamebucks')

    def gain_res(self, res, reason='', metadata = None, snap = None, break_limit = False):
        total = sum(res.itervalues(),0)
        if total == 0: return {}

        given = res.copy()
        if total > 0 and (not break_limit):
            if not snap:
                snap = self.calc_snapshot()
            for resname in given:
                given[resname] = max(0, min(given[resname], snap.max_res(resname) - snap.cur_res(resname)))
            total = sum(given.itervalues(),0)
            if total == 0:
                return {}

        for resname in given:
            setattr(self, resname, getattr(self, resname) + given[resname])
            dict_setmax(self.player.history, 'peak_'+resname, getattr(self, resname))
            dict_setmax(self.player.history, 'peak_'+resname+'_at_townhall_L'+str(self.player.get_townhall_level_fast()), getattr(self, resname))

        return given

    def calc_snapshot(self):
        inventory = [0,0,0] # max, cur, reserved
        res_max = dict((res,0) for res in gamedata['resources'])
        for obj in self.player.home_base_iter():
            if obj.spec.worth_less_xp or (not obj.is_building()) or obj.is_under_construction():
                pass
            else:
                # XXX move max inventory (and max storage?) over to player.stattab
                inventory[0] += obj.get_leveled_quantity(obj.spec.provides_inventory)

                #if obj.is_crafting() and gamedata['crafting_delivery_method'] == 'reserve_slot_on_start':
                #    # calculate reserved slots
                #    inventory[2] += LootTable.max_slots_needed(gamedata['loot_tables'], gamedata['crafting']['recipes'][obj.crafting.queue[0].craft_state['recipe']]['product'])

                if True or (not obj.is_damaged()):
                    for res in gamedata['resources']:
                        res_max[res] += obj.get_leveled_quantity(getattr(obj.spec, 'storage_'+res))

        inventory[1] = len(self.player.inventory)

        return ResourceStateSnapshot(inventory, res_max, dict((res,getattr(self,res)) for res in gamedata['resources']),
                                     self.gamebucks, self.facebook_credits, self.player_level, self.xp, self.protection_end_time)

    def persist_state(self):
        ret = { 'player_level': self.player_level, 'xp': self.xp,
                'gamebucks': self.gamebucks,
                'protection_end_time': self.protection_end_time, 'base_size': self.OLD_base_size }
        for res in gamedata['resources']: ret[res] = getattr(self, res)
        return ret
    def unpersist_state(self, state):
        for res in gamedata['resources']:
            setattr(self, res, int(state.get(res,0)))
        self.gamebucks = int(state.get('gamebucks', 0))
        self.player_level = int(state.get('player_level', 1))
        self.xp = int(state.get('xp', 0))
        self.protection_end_time = int(state.get('protection_end_time', -1))
        self.OLD_base_size = state.get('base_size', 0)

    @classmethod
    def create_from_persisted(cls, player, state):
        ret = cls(player)
        ret.unpersist_state(state)
        return ret

class Quest:
    def __init__(self, name):
        self.name = name

        # these fields are Predicate objects
        self.goal = None
        self.activation = None
        self.show_if = None

        # Consequent object
        self.completion_server = None

        self.force_claim = False

        for key in gamedata["quests"][name]:
            val = gamedata["quests"][name][key]
            if key == 'goal':
                self.goal = Predicates.read_predicate(val)
            elif key == 'activation':
                self.activation = Predicates.read_predicate(val)
            elif key == 'show_if':
                self.show_if = Predicates.read_predicate(val)
            elif key == 'completion_server':
                self.completion_server = Consequents.read_consequent(val)
            else:
                setattr(self, key, val)

    # clone a Quest, applying patches to member fields (for A/B testing)
    def make_patched(self, patch):
        ret = copy.copy(self)
        for key, val in patch.iteritems():
            if key in ('goal','activation','show_if'):
                setattr(ret, key, Predicates.read_predicate(val))
            elif key == 'completion_server':
                setattr(ret, key, Consequents.read_consequent(val))
            else:
                ret.__dict__[key] = val
        return ret

class Base(object):
    def __init__(self, region_id, base_id, creator_id, base_type, climate = None):
        # fields stored in file:
        self.base_id = base_id
        self.base_region = region_id
        self.base_generation = -1 # for read->write lock consistency checking
        self.base_ui_name = None
        self.base_type = base_type
        self.base_map_loc = None

        if climate:
            self.base_climate = climate
        elif ('default_player_home_climate' in gamedata) and (base_type == 'home') and (not is_ai_user_id_range(creator_id)):
            # special-case override for player bases
            self.base_climate = gamedata['default_player_home_climate']
        else:
            self.base_climate = gamedata.get('default_climate', None)

        self.base_ncells = None
        self.base_creation_time = server_time
        self.base_creator_id = creator_id # user_id of original creator
        self.base_landlord_id = creator_id # user_id of current owner
        self.base_times_attacked = 0
        self.base_times_conquered = 0 # count for conquers (quarries only)
        self.base_last_conquer_time = -1
        self.base_last_attack_time = -1
        self.base_last_landlord_id = -1

        self.base_template = None # for hives only, references hives.json
        self.base_richness = 0 # applies to AI base loot, and quarry GUI
        self.base_icon = None # ditto
        self.base_expire_time = -1
        self.base_size = 0
        self.deployment_buffer = 1 # whether or not to add deployment buffer around base perimeter

        # if false, disables all normal unit deployment methods, and disables item usage (used for skill challenges)
        self.deployment_allowed = True

        # this is used for AI bases that have explicit loot amounts, and player bases to save state across attacks
        self.base_resource_loot = None # dictionary of {"resource": amount} remaining to be looted
        self.base_res_looter_state = None # ResLooter can persist state here

        # list of GameObjects
        self.my_base = []

        # fields only relevant to in-memory usage
        # self.landlord = landlord

    def lock_id(self): return SpinDB.base_lock_id(self.base_region, self.base_id)
    def ncells(self):
        if self.base_ncells is not None: return self.base_ncells
        return gamedata['map']['default_ncells']
    def midcell(self):
        ncells = self.ncells()
        return [int(ncells[0]/2),int(ncells[1]/2)]

    # note: we use "adopt"/"drop" instead of "add"/"remove" in order to distinguish operations
    # on bases versus Session.add_object/rem_object(), which operates on sessions
    def adopt_object(self, obj):
        self.my_base.append(obj)
        self.nosql_write_one(obj, 'adopt_object', add_new = True)
    def drop_object(self, obj):
        self.my_base.remove(obj)
        self.nosql_drop_one(obj, 'drop_object')
    def iter_objects(self):
        for obj in self.my_base: yield obj

    def find_object_by_type(self, specname):
        for obj in self.iter_objects():
            if obj.spec.name == specname:
                return obj
        return None
    def find_object_by_id(self, obj_id):
        for obj in self.iter_objects():
            if obj.obj_id == obj_id:
                return obj
        return None

    def get_power_state(self):
        power = [0,0]
        if gamedata['enable_power']:
            for obj in self.iter_objects():
                if obj.is_building() and (not obj.is_under_construction()):
                    # power production
                    if (not obj.is_upgrading()) and (not obj.is_enhancing()) and (not obj.is_removing()):
                        provides_power = obj.get_leveled_quantity(obj.spec.provides_power)
                        if obj.is_damaged():
                            cur_health = float(obj.hp)
                            max_health = float(obj.max_hp)
                            hp_proportion = float(cur_health / max_health)
                            power_shutdown_threshold = obj.get_leveled_quantity(obj.spec.power_shutdown_threshold)
                            if hp_proportion >= power_shutdown_threshold: # defaults to 100%, so if gamedata has no value, the generator shuts down if damaged
                                power_proportion = obj.get_leveled_quantity(obj.spec.damaged_power_output)
                                if power_proportion < 0: # defaults to -1, so if gamedata has no value, the generator provides power proportionate to remaining health
                                    power_proportion = hp_proportion
                                provides_power = provides_power * power_proportion
                            else:
                                provides_power = 0
                        power[0] += provides_power
                    # power consumption
                    if obj.is_upgrading():
                        power[1] += GameObjectSpec.get_leveled_quantity(obj.spec.consumes_power_while_building, obj.level + 1)
                    else:
                        power[1] += obj.get_leveled_quantity(obj.spec.consumes_power)

                    # items
                    if obj.equipment:
                        for item in Equipment.equip_iter(obj.equipment):
                            if item['spec'] in gamedata['items']:
                                item_spec = gamedata['items'][item['spec']]
                                item_level = 1
                                if 'level' in item:
                                    item_level = item['level']
                                if 'equip' in item_spec:
                                    power[1] += GameObjectSpec.get_leveled_quantity(item_spec['equip'].get('consumes_power', 0), item_level)

                    # in-progress crafting recipes
                    if obj.is_crafting():
                        to_add = 0 # add max() of power consumed by all queued recipes
                        for entry in obj.crafting.queue:
                            if not entry.is_complete(server_time):
                                if entry.craft_state['recipe'] in gamedata['crafting']['recipes']:
                                    recipe_consumes_power = GameObjectSpec.get_leveled_quantity(gamedata['crafting']['recipes'][entry.craft_state['recipe']].get('consumes_power',0), entry.craft_state['level'])
                                    to_add = max(to_add, recipe_consumes_power)
                        power[1] += to_add
        return power

    def get_power_factor(self): return compute_power_factor(self.get_power_state())

    # returns tuple (new_power_factor, power_state (or None if N/A), affected_obj_list)
    def power_changed(self, changed_object):
        if not gamedata['enable_power']: return (1, None, [])
        if changed_object and (not (changed_object.is_building() and changed_object.affects_power())): return (1, None, [])

        power_state = self.get_power_state()
        power_factor = compute_power_factor(power_state)
        affected_obj_list = []

        for obj in self.iter_objects():
            if obj.is_building() and obj.is_producer():
                obj.update_production(obj.owner, self.base_type, self.base_region, power_factor)
                self.nosql_write_one(obj, 'power_changed')
                affected_obj_list.append(obj)

        return (power_factor, power_state, affected_obj_list)

    def simulate_passage_of_time(self):
        # simulate passage of time for repairs, and also kickstart
        # production/research/upgrades/etc if it got stopped for some
        # reason, and the building is at full health.
        # note: does not collect any products - rely on the client to ping us for that.
        # note: assume this is called before the client sees any objects, so it is OK to mutate state without sending messages.

        power_factor = self.get_power_factor()

        # list of (sim time, obj) for each object we need to simulate
        obj_list = [(min(server_time, obj.repair_finish_time if (obj.is_building() and obj.repair_finish_time > 0) else server_time), obj) for obj in self.iter_objects() \
                    if (obj.is_building() or obj.is_inert())]

        # sort by repair_finish_time, so that we can simulate power state changes
        # and halted/running state transitions

        obj_list.sort()

        # walk forward in time
        for t, obj in obj_list:

            if obj.is_building() and obj.is_repairing() and obj.repair_finish_time < server_time:
                # something is fully repaired
                obj.heal_to_full()
                obj.repair_finish_time = -1

                if obj.affects_power():
                    # update the power factor, based on current damage status
                    power_factor = self.get_power_factor()

                    # iterate through harvesters (and anything else affected by power?)
                    for p in self.iter_objects():
                        if p.is_building() and p.is_producer():
                            p.update_production(p.owner, self.base_type, self.base_region, power_factor, ref_time = t)

            obj.update_all(ref_time = t, power_factor = power_factor)

    def get_base_radius(self):
        assert self.base_size >= 0 and self.base_size < len(gamedata['map']['base_perimeter'])
        return int(gamedata['map']['base_perimeter'][self.base_size]/2)

    def quantize_building_location(self, ji, spec):
        if spec.quantize_location:
            q = spec.quantize_location
            if q > 2:
                # new SG-style quantization
                # because of the convention that a building's x,y coordinates are its center, and not its corner,
                # we can't quantize just by snapping the x,y coordinates. We have to do more math to pick the right center.
                gridsize = spec.gridsize
                if (gridsize[0]&1) or (gridsize[1]&1):
                    raise Exception('cannot quantize odd gridsize with q = %d' % q)
                half = [gridsize[0]>>1, gridsize[1]>>1]
                # this is where the corner was BEFORE quantization
                old_corner = [ji[0]-half[0], ji[1]-half[1]]
                # this is where we want the corner to be AFTER quantization
                corner = [q*(old_corner[0]//q),
                          q*(old_corner[1]//q)]
                return [corner[0]+half[0], corner[1]+half[1]]
            else:
                # 2-unit TR-style quantization
                return [q*(ji[0]//q),
                        q*(ji[1]//q)]
        return ji
    # return whether a building of spec 'spec' can be built at location 'xy', disregarding collisions with object 'myself'
    def is_building_location_valid(self, ji, spec, myself, ignore_collision = False, ignore_perimeter = False):
        gridsize = spec.gridsize

        if spec.quantize_location: # enforce quantization
            if ji != self.quantize_building_location(ji, spec):
                return False

        bound = get_grid_bounds(ji, gridsize)

        ncells = self.ncells()
        mid = self.midcell()
        rad = self.get_base_radius()

        if ignore_perimeter:
            # just clamp against entire play area
            if bound[0][0] < 0 or bound[0][1] > ncells[0] or \
               bound[1][0] < 0 or bound[1][1] > ncells[1]:
                return False
        else:
            # clamp against base perimeter
            if bound[0][0] < mid[0]-rad or bound[0][1] > mid[0]+rad or \
               bound[1][0] < mid[1]-rad or bound[1][1] > mid[1]+rad:
                return False

        # expand boundary to include exclusion zone
        excl_bound = [[bound[axis][0]-spec.exclusion_zone[axis], bound[axis][1]+spec.exclusion_zone[axis]] for axis in xrange(2)]

        # check for collisions with other buildings
        if not ignore_collision:
            for obj in self.iter_objects():
                if (obj is not myself) and (obj.is_building() or (obj.is_inert() and obj.spec.blocks_buildings)):
                    hisbound = get_grid_bounds([obj.x,obj.y], obj.spec.gridsize)
                    # if OTHER object has an exclusion zone, then apply OUR exclusion zone
                    if obj.spec.exclusion_zone != [0,0]:
                        b = excl_bound
                    else:
                        b = bound
                    if (b[0][0] < hisbound[0][0] and b[0][1] > hisbound[0][0]) or \
                       (b[0][0] >= hisbound[0][0] and b[0][0] < hisbound[0][1]):

                        if (b[1][0] < hisbound[1][0] and b[1][1] > hisbound[1][0]) or \
                           (b[1][0] >= hisbound[1][0] and b[1][0] < hisbound[1][1]):

                            if gamedata['server']['log_invalid_building_locations']:
                                gamesite.exception_log.event(server_time, 'invalid building location at base %s: %s at %s' % \
                                                             (self.base_id, myself.spec.name if myself else 'unknown', repr(ji)))
                            return False
        return True

    # return whether a deposit can appear at location xy
    def is_deposit_location_valid(self, xy, gridsize):
        mid = self.midcell()
        rad = self.get_base_radius()
        gs = [int(gridsize[0]/2), int(gridsize[1]/2)]
        if (xy[0]-gs[0] < mid[0]-rad) or (xy[0]+gs[0] > mid[0]+rad) or \
           (xy[1]-gs[1] < mid[1]-rad) or (xy[1]+gs[1] > mid[1]+rad):
            # check for collisions with buildings?
            return True
        return False

    def has_deployment_zone(self):
        return bool(self.deployment_buffer and type(self.deployment_buffer) is dict)
    def deployment_zone_centroid(self):
        if not self.has_deployment_zone(): return None
        if self.deployment_buffer['type'] != 'polygon':
            raise Exception('unhandled deployment buffer type %r' % self.deployment_buffer['type'])
        centroid = [0,0]
        for vert in self.deployment_buffer['vertices']:
            centroid = vec_add(centroid, vert)
        centroid = vec_scale(1.0/len(self.deployment_buffer['vertices']), centroid)
        return centroid

    def is_deployment_location_valid(self, player, xy):
        if not self.deployment_allowed:
            return False # everywhere is invalid

        ncells = self.ncells()
        if xy[0] < 0 or xy[0] >= ncells[0] or xy[1] < 0 or xy[1] >= ncells[1]:
            return False

        if player.user_id == self.base_landlord_id:
            # owner can deploy anywhere
            return True

        # check against base perimeter or deployment zone
        if self.has_deployment_zone():
            # Gangnam style
            assert self.deployment_buffer['type'] == 'polygon'
            sign = 0
            for i in xrange(len(self.deployment_buffer['vertices'])):
                iend = ((i+1) % len(self.deployment_buffer['vertices']))
                start = self.deployment_buffer['vertices'][i]
                end = self.deployment_buffer['vertices'][iend]
                seg = vec_sub(end, start)
                point = vec_sub(xy, start)
                k = seg[0]*point[1] - seg[1]*point[0]
                sign_k = 1 if k >= 0 else -1
                if sign == 0:
                    sign = sign_k
                elif sign_k != sign:
                    return False
        elif gamedata['map']['deployment_buffer'] >= 0:
            # old style
            mid = self.midcell()
            rad = [self.get_base_radius(), self.get_base_radius()]

            if self.deployment_buffer:
                rad[0] += gamedata['map']['deployment_buffer']
                rad[1] += gamedata['map']['deployment_buffer']

            for AXIS in (0,1):
                rad[AXIS] += max(0, (ncells[AXIS] - gamedata['map']['default_ncells'][AXIS])/2)

            if (xy[0] >= mid[0]-rad[0]) and (xy[0] <= mid[0]+rad[0]) and (xy[1] >= mid[1]-rad[1]) and (xy[1] <= mid[1]+rad[1]):
                return False

        # check against building blockage?
        return True

    def can_deploy_unit(self, spec):
        # test unit against climate deployment restrictions
        if self.base_climate:
            data = gamedata['climates'][self.base_climate]
            if ('include_manufacture_categories' in data) and (spec.manufacture_category not in data['include_manufacture_categories']): return False
            if ('exclude_manufacture_categories' in data) and (spec.manufacture_category in data['exclude_manufacture_categories']): return False
            if data.get('exclude_air_units',False) and spec.flying: return False
            if data.get('exclude_ground_units',False) and (not spec.flying): return False
            if ('include_units' in data) and (spec.name not in data['include_units']): return False
            if ('exclude_units' in data) and (spec.name in data['exclude_units']): return False
        return True

    # set up production on all production buildings
    # this depends on power state, so it must be done AFTER base objects are fully reconstituted
    def init_production(self, landlord):
        power_factor = compute_power_factor(self.get_power_state())
        for obj in self.iter_objects():
            if obj.is_building():
                obj.update_production(landlord, self.base_type, self.base_region, power_factor)

    def do_calc_base_damage(self, detail = False, count_partial = False):
        damaged_objects = {} if detail else None
        base_hp_total = 0
        base_hp_max = 0.1
        barriers_damaged = 0
        base_repair_time = -1 # server_time at which base will be fully repaired (-1 if already repaired)

        for obj in self.iter_objects():
            if obj.is_building():
                if obj.is_repairing():
                    base_repair_time = max(base_repair_time, obj.repair_finish_time)

                # handle barriers separately
                if obj.spec.worth_less_xp:
                    if obj.is_damaged() and obj.spec.name == 'barrier':
                        barriers_damaged += 1
                else:
                    # XXXXXX obj.hp does not include repairs! should we take ongoing repairs into account here?
                    base_hp_max += obj.max_hp

                    if (not obj.is_destroyed()) and gamedata.get('base_damage_skip_partial',False) and (not count_partial):
                        base_hp_total += obj.max_hp
                    else:
                        base_hp_total += obj.hp

                    if detail and obj.is_damaged():
                        damaged_objects[obj.obj_id] = {'spec': obj.spec.name, 'hp': obj.hp, 'max_hp': obj.max_hp}
                        if obj.is_producer():
                            damaged_objects[obj.obj_id]['repair_finish_time'] = obj.repair_finish_time
                            damaged_objects[obj.obj_id]['produce_rate'] = obj.produce_rate
                            damaged_objects[obj.obj_id]['contents'] = obj.contents

        base_hp_total = int(base_hp_total)
        base_hp_max = int(base_hp_max)
        ret = float(base_hp_max - base_hp_total) / max(1,base_hp_max)
        if barriers_damaged > 0: ret += 0.0001
        ret = min(max(ret, 0), 1)
        return (ret, base_repair_time, damaged_objects)

    def calc_base_damage(self, **kwargs): return self.do_calc_base_damage(detail = False, **kwargs)[0]
    def calc_base_damage_and_repair_time(self, **kwargs): return self.do_calc_base_damage(detail = False, **kwargs)[0:2]

    # if base is so damaged that player cannot be attacked on the ladder, project the future time when they will be available for attack
    # used for writing base_damage and base_repair_time out to PlayerCache
    def report_base_damage_and_repair_time_for_ladder(self, player):
        cur_damage, cur_repair_time = self.calc_base_damage_and_repair_time()
        if player.tutorial_state == 'COMPLETE' and (cur_damage >= gamedata['matchmaking']['ladder_win_damage']):
            # might have a corner case where you're not repairing, but should be resolved on logout
            return 0, max(server_time+1, cur_repair_time)
        else:
            return cur_damage, -1

    # calculate % of damage to storage buildings, for the purpose of PvP attack protection timer
    def calc_resource_damage(self):
        num_ok = 0
        num_max = 0
        weight_table = gamedata['server']['protection_weight']
        for obj in self.iter_objects():
            if not (obj.is_building() and (obj.is_storage() or obj.is_producer())):
                continue
            weight = weight_table.get(obj.spec.name, 1)
            if weight > 0 and gamedata['server']['protection_weight_by_object_level']:
                weight = int(weight * obj.level)
            num_max += weight
            if obj.hp > 0:
                num_ok += weight
        if num_max == 0:
            return 1

        ret = float(num_max - num_ok) / num_max
        ret = min(max(ret, 0), 1)
        return ret

    # calculate ladder damage-based protection time (pass in just-calculated base damage for efficiency)
    def calc_ladder_protection(self, base_damage):
        ladder_protection = 0
        for entry in gamedata['matchmaking']['ladder_protection']:
            if base_damage >= entry[0]:
                ladder_protection = entry[1]
                break
        if ladder_protection > 0 and gamedata['matchmaking'].get('ladder_protection_townhall_destroyed',0):
            cc = self.find_object_by_type(gamedata['townhall'])
            if cc and cc.is_destroyed():
                ladder_protection += gamedata['matchmaking']['ladder_protection_townhall_destroyed']
        return ladder_protection

    # detect win condition in ladder attacks (pass in just-calculated base damage for efficiency)
    def ladder_victory_satisfied(self, session, base_damage):
        condition = gamedata['matchmaking'].get('ladder_win_condition', 'base_damage')
        if condition == 'base_damage':
            return base_damage >= gamedata['matchmaking']['ladder_win_damage']
        elif condition == 'battle_stars':
            return len(session.loot.get('battle_stars',{})) > 0
        else:
            raise Exception('unknown ladder_win_condition '+condition)

    def common_victory_satisfied(self, session, base_damage):
        condition = gamedata.get('common_win_condition', 'townhall_destroyed')
        if condition == 'townhall_destroyed':
            if session.defender_cc_standing: # note: cannot be a "victory" if townhall is already dead (prevents multiple looting of hives)
                for obj in self.iter_objects():
                    if obj.spec.name == gamedata['townhall']:
                        if obj.is_destroyed():
                            return True

            # this override is for hitlist, which is "either townhall or X%+ base damage"
            for aura in session.player.player_auras_iter_const():
                for effect in aura.get('effects',[]): # XXXXXX doesn't this need to indirect via 'spec'?
                    if effect['code'] == 'base_damage_win_condition':
                        if base_damage >= effect['amount']:
                            return True
            return False
        elif condition == 'battle_stars':
            return len(session.loot.get('battle_stars',{})) > 0
        else:
            raise Exception('unknown common_win_condition '+condition)

    # detect victory condition in quarry attacks: no turrets or mobiles left
    def quarry_victory_satisfied(self):
        for obj in self.iter_objects():
            if obj.owner.user_id in (self.base_landlord_id, RogueOwner.user_id):
                if obj.is_building() and (not obj.is_destroyed()) and obj.spec.history_category in ('turrets','turret_emplacements'):
                    return False
                if obj.is_mobile() and (not obj.is_destroyed()) and self.can_deploy_unit(obj.spec):
                    return False
        return True

    def quarry_conquer(self, old_owner, new_owner):
        self.base_last_landlord_id = self.base_landlord_id
        self.base_last_conquer_time = server_time
        self.base_landlord_id = new_owner.user_id

        if gamedata['server'].get('log_nosql',0) >= 2:
            gamesite.exception_log.event(server_time, 'quarry_conquer: %s from %d to %d' % (self.base_id, self.base_landlord_id, new_owner.user_id))

        to_remove = []
        for obj in self.iter_objects():
            if obj.is_mobile(): to_remove.append(obj)
            elif obj.is_building() or obj.is_inert():
                obj.owner = new_owner if obj.is_building() else EnvironmentOwner
                fields = ['owner_id']
                if obj.is_building():
                    # clear some state on conquer
                    if obj.is_producer() and gamedata['territory']['quarry_dump_on_conquer'] and \
                       ((not old_owner.is_ai()) or gamedata['territory'].get('quarry_dump_on_conquer_ai',False)):
                        # note: the following init_production() will restart the harvester
                        obj.produce_start_time = -1
                        obj.produce_rate = -1
                        obj.contents = 0
                        fields += ['produce_start_time', 'produce_rate', 'contents']
                    if obj.is_upgrading():
                        # cancel upgrade immediately, no refund
                        obj.cancel_upgrade()
                        fields += ['upgrade_total_time','upgrade_start_time','upgrade_done_time','upgrade_ingredients','upgrade_help','upgrade_helped']
                    if obj.is_enhancing():
                        # cancel enhancement immediately, no refund
                        obj.cancel_enhancing()
                        fields += ['enhancing']

                self.nosql_write_one(obj, 'quarry_conquer', fields = fields)

        for obj in to_remove: self.drop_object(obj)
        self.init_production(new_owner)
        self.base_times_conquered += 1

    def quarry_abandon(self):
        self.base_last_landlord_id = self.base_landlord_id
        self.base_last_conquer_time = server_time

        if self.base_template in gamedata['quarries_server']['templates']:
            self.base_landlord_id = gamedata['quarries_server']['templates'][self.base_template]['default_landlord_id']
        else:
            self.base_landlord_id = gamedata['territory']['default_quarry_landlord_id']

        to_remove = []
        for obj in self.iter_objects():
            if obj.is_mobile():
                to_remove.append(obj); continue
            elif obj.is_building() or obj.is_inert():
                obj.owner = RogueOwner # XXX really should be a fake player with the ID of base_creator_id
                fields = ['owner_id']
                if obj.is_building():
                    if obj.is_upgrading():
                        # cancel upgrade immediately, no refund
                        obj.cancel_upgrade()
                        fields += ['upgrade_total_time','upgrade_start_time','upgrade_done_time','upgrade_ingredients','upgrade_help','upgrade_helped']
                    if obj.is_enhancing():
                        # cancel enhancement immediately, no refund
                        obj.cancel_enhancing()
                        fields += ['enhancing']
                    if obj.is_crafting():
                        # cancel crafting immediately, no refund
                        # note: this will leave turret emplacements empty - OK?
                        obj.crafting = None
                        fields += ['crafting']
                    if obj.is_damaged() and gamedata['territory'].get('quarry_repair_on_abandon', False):
                        # repair it
                        obj.repair_finish_time = -1
                        obj.heal_to_full()
                        fields += ['repair_finish_time','hp','hp_ratio','disarmed']

                    if obj.is_producer() and gamedata['territory'].get('quarry_dump_on_abandon', False):
                        # note: this will need init_production() to restart, e.g. on next base load
                        obj.produce_start_time = -1
                        obj.produce_rate = -1
                        obj.contents = 0
                        fields += ['produce_start_time', 'produce_rate', 'contents']

                self.nosql_write_one(obj, 'quarry_abandon', fields = fields)
        for obj in to_remove: self.drop_object(obj)

    def reset_to_full_health(self):
        # XXXXXX this does NOT reset landmines or units!
        affected = set()
        # heal first, then restart production, so that repaired powerplants work correctly
        for object in self.iter_objects():
            if object.is_building() and object.is_damaged():
                object.heal_to_full()
                affected.add(object)
        power_factor = compute_power_factor(self.get_power_state())
        for object in affected:
            object.update_production(object.owner, self.base_type, self.base_region, power_factor)
            object.update_all(power_factor = power_factor)

    def get_townhall_level(self):
        for obj in self.iter_objects():
            if obj.spec.name == gamedata['townhall']:
                return obj.level
        return 0


    # returns the AI base entry from which this was instanced, or None for non-AI bases (or map bases)
    def get_ai_base_data(self):
        if self.base_type != 'home': return None
        key = str(self.base_landlord_id)
        return  gamedata['ai_bases_server']['bases'].get(key, None)

    def get_cache_props(self, extra_props = None):
        # note: some of this is duplicated in CustomerSupport.ChangeRegionHandler, so make updates there too.
        props = { 'base_id': self.base_id,
                  'base_landlord_id': self.base_landlord_id }
        assert self.base_type
        props['base_type'] = self.base_type
        if self.base_map_loc is not None: props['base_map_loc'] = self.base_map_loc
        if self.base_climate is not None: props['base_climate'] = self.base_climate
        if self.base_ncells is not None: props['base_ncells'] = self.base_ncells
        if self.base_ui_name is not None: props['base_ui_name'] = self.base_ui_name
        if self.base_creation_time > 0: props['base_creation_time'] = self.base_creation_time
        if self.base_expire_time > 0: props['base_expire_time'] = self.base_expire_time
        if self.base_richness > 0: props['base_richness'] = self.base_richness
        if self.base_template: props['base_template'] = self.base_template
        if self.base_icon: props['base_icon'] = self.base_icon
        if self.base_times_attacked > 0: props['base_times_attacked'] = self.base_times_attacked
        if self.base_times_conquered > 0: props['base_times_conquered'] = self.base_times_conquered
        if self.base_last_attack_time > 0: props['base_last_attack_time'] = self.base_last_attack_time
        if self.base_last_conquer_time > 0: props['base_last_conquer_time'] = self.base_last_conquer_time
        if self.base_last_landlord_id > 0: props['base_last_landlord_id'] = self.base_last_landlord_id
        if self.base_creator_id > 0: props['base_creator_id'] = self.base_creator_id
        if self.base_size != 0: props['base_size'] = self.base_size
        if self.base_resource_loot: props['base_resource_loot'] = self.base_resource_loot
        if self.base_res_looter_state: props['base_res_looter_state'] = self.base_res_looter_state

        if self.base_type == 'home':
            townhall_level = self.get_townhall_level()
            if townhall_level > 0: props[gamedata['townhall']+'_level'] = townhall_level
        if extra_props:
            for k,v in extra_props.iteritems():
                props[k] = v
        return props

    def send_map_feature_update(self, extra_props = None, reason=''):
        if self.base_type == 'squad': return # virtual bases shouldn't be in the cache
        if not self.base_region or not gamesite.nosql_client: return
        props = self.get_cache_props(extra_props = extra_props)
        return gamesite.nosql_client.update_map_feature(self.base_region, self.base_id, props, reason=reason)

    def is_nosql_base(self):
        if not self.base_region: return False
        if (not self.base_type): gamesite.exception_log.event(server_time, 'base_type None for %s' % self.base_id); return False
        if self.base_type == 'home' or self.base_type == 'squad': return False # not storing Player home bases in NoSQL yet, and squads are virtual
        return True
    def nosql_pluck(self, reason):
        if (not gamesite.nosql_client) or (not self.is_nosql_base()): return
        if gamedata['server'].get('log_nosql',0) >= 2:
            gamesite.exception_log.event(server_time, 'nosql_pluck %s from %s reason %s' % (self.base_id, self.base_region, reason))
        gamesite.nosql_client.drop_all_objects_by_base(self.base_region, self.base_id, reason=reason)

    def nosql_plant(self, reason):
        if (not gamesite.nosql_client) or (not self.is_nosql_base()): return
        if gamedata['server'].get('log_nosql',0) >= 2:
            gamesite.exception_log.event(server_time, 'nosql_plant %s into %s reason %s' % (self.base_id, self.base_region, reason))
        for object in self.iter_objects():
            self._nosql_write_one(object, reason, add_new = True, verbose = False)
    def nosql_write_one(self, object, reason, add_new = False, fields = None):
        if (not gamesite.nosql_client) or (not self.is_nosql_base()): return
        self._nosql_write_one(object, reason, add_new = add_new, fields = fields, verbose = True)
    def _nosql_write_one(self, object, reason, add_new = False, fields = None, verbose = True):
        state = object.persist_state(nosql = True)

        if fields: # manually specify fields to write
            newstate = {'obj_id':state['obj_id']}
            unset = []
            for field in fields:
                if field in state:
                    newstate[field] = state[field]
                else:
                    unset.append(field)
            state = newstate
        else:
            unset = None # overwrite, don't unset
            state['base_id'] = self.base_id

        if verbose and gamedata['server'].get('log_nosql',0) >= 3:
            gamesite.exception_log.event(server_time, 'nosql_update %s: %s reason %s' % (self.base_id, repr(state), reason))
        if object.is_mobile():
            return gamesite.nosql_client.update_mobile_object(self.base_region, state, partial = bool(fields), unset = unset, reason=reason)
        else:
            if ('owner_id' in state) and (state['owner_id'] > 0) and (state['owner_id'] != self.base_landlord_id):
                if gamedata['server'].get('log_nosql',0) >= 1 and state.get('spec',None) != 'barrier':
                    gamesite.exception_log.event(server_time, 'nosql_update %s: %s but base_landlord_id = %d, reason %s' % (self.base_id, repr(state), self.base_landlord_id, reason))

            return gamesite.nosql_client.update_fixed_object(self.base_region, state, partial = bool(fields), unset = unset, reason=reason)
    def nosql_read(self, observer, player, reason):
        if (not gamesite.nosql_client) or (not self.is_nosql_base()): return None
        if gamedata['server'].get('log_nosql',0) >= 2:
            gamesite.exception_log.event(server_time, 'nosql_read %s reason %s' % (self.base_id, reason))
        ret = []
        for state in list(gamesite.nosql_client.get_fixed_objects_by_base(self.base_region, self.base_id, reason=reason)) + \
            list(gamesite.nosql_client.get_mobile_objects_by_base(self.base_region, self.base_id, reason=reason)):
            obj = reconstitute_object(observer, player, state, context = 'Base %s (landlord %d observer %d):nosql_read' % (self.base_id, self.base_landlord_id, observer.user_id))
            if obj:
                # for now, just return what the new my_base array would be, instead of actually replacing it
                #self.adopt_object(obj)
                ret.append(obj)
        return ret
    def nosql_drop_one(self, object, reason):
        if (not gamesite.nosql_client) or (not self.is_nosql_base()): return
        state = object.persist_state(nosql = True)
        if gamedata['server'].get('log_nosql',0) >= 3:
            gamesite.exception_log.event(server_time, 'nosql_drop_one %s: %s reason %s' % (self.base_id, repr(state), reason))
        if object.is_mobile():
            gamesite.nosql_client.drop_mobile_object_by_id(self.base_region, state['obj_id'], reason=reason)
        else:
            gamesite.nosql_client.drop_fixed_object_by_id(self.base_region, state['obj_id'], reason=reason)

    def spawn_scenery(self, observer, seed, overwrite = False):
        to_remove = []
        for obj in self.iter_objects():
            if obj.is_inert() and obj.spec.auto_spawn:
                # if any scenery already exists, abort
                if overwrite:
                    to_remove.append(obj)
                else:
                    return [], []
        for obj in to_remove:
            self.drop_object(obj)

        num_to_spawn = gamedata['map']['random_scenery_spawn']
        ncells = self.ncells()
        mid = self.midcell()
        num_to_spawn = int(num_to_spawn*((ncells[0]*ncells[1])/float(180*180)))

        my_climate = self.base_climate or 'normal'
        my_type = 'home'
        speclist = [specname for specname, data in gamedata['inert'].iteritems() if (data.get('auto_spawn',False) and \
                                                                                     (my_type in data.get('base_types',[])) and \
                                                                                     (my_climate in data.get('base_climates',[])))]
        if not speclist: return to_remove, []

        randgen = random.Random(seed+1) # deterministic from the seed

        to_add = []
        for i in range(num_to_spawn):
            index = int(randgen.random()*len(speclist))
            specname = speclist[index]
            spec = GameObjectSpec.lookup(specname)
            rad = gamedata['map'].get('random_scenery_spawn_radius', ncells[0]//2)
            # assumes square map
            xbound = [max(0, mid[0]-rad), min(mid[0]+rad, ncells[0])]
            ybound = [max(0, mid[1]-rad), min(mid[1]+rad, ncells[1])]

            xrange = [xbound[0]+int(spec.gridsize[0]/2), xbound[1]-int(spec.gridsize[0]/2)-1]
            yrange = [ybound[0]+int(spec.gridsize[1]/2), ybound[1]-int(spec.gridsize[1]/2)-1]

            x = int(xrange[0] + randgen.random()*(xrange[1]-xrange[0]))
            y = int(yrange[0] + randgen.random()*(yrange[1]-yrange[0]))
            x = max(0, min(x, ncells[0]-1))
            y = max(0, min(y, ncells[1]-1))
            newobj = instantiate_object_for_player(observer, EnvironmentOwner, specname, x=x, y=y)
            self.adopt_object(newobj)
            to_add.append(newobj)

        return to_remove, to_add

def _min_attackable_level(level_gap_table, attacker_level):
    if type(level_gap_table) is list:
        ind = min(max(attacker_level-1, 0), len(level_gap_table)-1)
        max_gap = level_gap_table[ind]
    else:
        max_gap = level_gap_table
    return max(attacker_level - max_gap, 0)

def in_level_range(x, r):
    if r[0] >= 0 and x < r[0]: return False
    if r[1] >= 0 and x > r[1]: return False
    return True


def get_spawn_location_for_unit(specname, base):
    factory_name = GameObjectSpec.get_factory_for(gamedata['units'][specname]['manufacture_category'])
    builder = base.find_object_by_type(factory_name) if factory_name else None
    if builder:
        return [builder.x+10, builder.y+10]
    else:
        mid = base.midcell()
        return [mid[0], mid[1]+20]

def spawn_units(owner, base, units, temporary = False,
                limit_break = False, # if true, give full quantity of units even if it breaks space limit
                limit_reduce_qty = False, # if true, reduce quantity of units to fit in unit space
                xyloc = None, xyscatter = None, observer = None, persist = False,
                ai_state = None, ai_target = None, ai_aggressive = None,
                pack_id = None, behaviors = None, unit_health_modifier = 1.0):
    if not observer: observer = owner
    if temporary: assert xyloc

    new_objects = []
    ncells = base.ncells()
    cur_space_usage = None

    for name, data in units.iteritems():
        if (name not in gamedata['units']): continue

        spec = observer.get_abtest_spec(GameObjectSpec, name)

        if xyloc:
            x, y = xyloc
        else:
            x, y = get_spawn_location_for_unit(name, base)

        force_level = None
        apply_auras = None
        if type(data) is int:
            qty = data
            min_level = 1
        else:
            qty = data.get('qty',1)
            min_level = data.get('min_level',1)
            force_level = data.get('force_level',None)
            apply_auras = data.get('apply_auras',None)

        if force_level is not None:
            level = force_level
        elif spec.level_determined_by_tech:
            # if player doesn't have prerequisite tech, still give the unit at level 1
            level = max(owner.tech.get(spec.level_determined_by_tech, 1), min_level)
        else:
            level = min_level

        level = min(level, spec.maxlevel) # don't exceed max level

        space = GameObjectSpec.get_leveled_quantity(spec.consumes_space, level)

        for i in range(qty):
            if (not temporary) and cur_space_usage is None:
                cur_space_usage = owner.get_army_space_usage_by_squad() # OK - expensive query

            newobj_x = x
            newobj_y = y
            if xyscatter:
                newobj_x = newobj_x + int(xyscatter[0] * (2*random.random()-1))
                newobj_y = newobj_y + int(xyscatter[1] * (2*random.random()-1))

            newobj_x = min(max(newobj_x, 0), ncells[0]-1)
            newobj_y = min(max(newobj_y, 0), ncells[1]-1)

            destination_squad = SQUAD_IDS.BASE_DEFENDERS

            if (not temporary) and (not limit_break):
                if spec.limit >= 0:
                    if owner.get_army_unit_count_by_specname().get(spec.name, 0) + 1 > spec.limit:
                        if limit_reduce_qty:
                            break # skip adding the unit silently
                        else:
                            gamesite.exception_log.event(server_time, 'player %d not allowed to spawn unit of spec %s due to count limit' % (owner.user_id, spec.name))
                            break # skip adding the unit, and log message


                if (cur_space_usage['ALL'] + space > owner.stattab.total_space):
                    if limit_reduce_qty:
                        break # skip adding the unit
                    else:
                        gamesite.exception_log.event(server_time, 'player %d (CC%d) spawned unit into oversize army! (unit %s space %d limit %d army %s)' % \
                                                     (owner.user_id, owner.get_townhall_level(), name, space, owner.stattab.total_space, repr(cur_space_usage)))

                if (cur_space_usage[str(SQUAD_IDS.BASE_DEFENDERS)] + space > owner.stattab.main_squad_space):
                    if limit_reduce_qty:
                        break # skip adding the unit
                    else:
                        if owner.squads_enabled() and gamedata['produce_to_reserves']:
                            destination_squad = SQUAD_IDS.RESERVES
                        else:
                            gamesite.exception_log.event(server_time, 'player %d (CC%d) spawned unit into oversize base defenders! (unit %s space %d limit %d army %s)' % \
                                                         (owner.user_id, owner.get_townhall_level(), name, space, owner.stattab.main_squad_space, repr(cur_space_usage)))

            newobj_id = gamesite.nosql_id_generator.generate()
            newobj = instantiate_object_for_player(observer, owner, name, x=newobj_x, y=newobj_y, level=level, obj_id = newobj_id, temporary = temporary, apply_auras = apply_auras, unit_health_modifier = unit_health_modifier)
            newobj.squad_id = destination_squad

            if temporary:
                # put object into aggressive state by default
                if ai_aggressive is None:
                    ai_aggressive = 1
                if ai_state is None:
                    ai_state = 2

                newobj.orders = [{'dest':[newobj.x,newobj.y], 'state':ai_state}]
                if ai_aggressive:
                    newobj.orders[0]['aggressive'] = 1
                if ai_target:
                    newobj.orders[0]['target'] = ai_target.obj_id

                if pack_id is not None:
                    newobj.pack_id = pack_id
                if behaviors is not None:
                    if newobj.behaviors is None:
                        newobj.behaviors = []
                    for b in behaviors:
                        if b not in newobj.behaviors:
                            newobj.behaviors.append(b)

            if not temporary:
                assert base is owner.my_home
                assert ai_aggressive is None
                assert ai_state is None
                assert ai_target is None
                assert pack_id is None
                assert behaviors is None
                cur_space_usage['ALL'] += space
                cur_space_usage[str(destination_squad)] += space

            # global setting, can be over-ridden by parameter
            persist_temporary_units = persist or gamedata.get('persist_temporary_units', False)

            # per-base setting
            if base.base_type == 'hive':
                template = gamedata['hives_server']['templates'].get(base.base_template, None)
                if template and template.get('persist_temporary_units', False):
                    persist_temporary_units = True

            if (not temporary) or \
               (persist_temporary_units and base.base_landlord_id == owner.user_id): # don't adopt security teams into foreign bases!
                base.adopt_object(newobj)
            new_objects.append(newobj)

    return new_objects


# A "player" holds the state for a person in one game

class AbstractPlayer(object):
    def __init__(self, user_id):
        self.user_id = user_id
        self.home_region = None
        self.tech = {}
        self.stattab = self.AbstractStattab()
    def get_any_abtest_value(self, key, default_value): return default_value
    def is_ai(self): return True
    def is_ai_user_id_range(self): return is_ai_user_id_range(self.user_id)
    def is_human(self): return not self.is_ai()
    def ai_or_human(self):
        if self.is_ai():
            return 'ai'
        else:
            return 'human'
    def is_developer(self): return False
    class AbstractStattab(object):
        modded_buildings = {}
        vault_res = dict((res,0) for res in gamedata['resources'])
        def get_player_stat(self, stat): raise Exception('AbstractPlayer has no stat table')
        def get_unit_stat(self, specname, stat, default_value): return default_value

    # needed for object.owner.get_weapon_spell()
    # note: precludes override of non-owned object spells
    def get_abtest_spell(self, name):
        return gamedata['spells'].get(name, None)

# These virtual players instances represent the owners of game objects
# that belong to the environment (e.g. landscape decorations) or
# generic "rogue" hostiles (e.g. AIs that do not belong to a named AI player)
# note: user_ids must be unique, for nosql storage!

EnvironmentOwner = AbstractPlayer(-1)
RogueOwner = AbstractPlayer(-2)

# base_id for the home base of a user
def home_base_id(user_id): return 'h'+str(user_id)

# base class for players that have associated state (both human and AI)

class Player(AbstractPlayer):

    # "read/write semaphore" flags to prevent two users from writing changes to the same base at once
    class LockState:
        # NOTE: keep constants in sync with SpinNoSQL.py lock states
        # <= 0 means "open" otherwise "taken"
        open = 0 # anyone can view
        logged_in = 1 # owner is viewing
        being_attacked = 2 # non-owner is attacking

    def __init__(self, user_id):
        super(Player,self).__init__(user_id)
        self.user_id = user_id

        self.home_region = None
        self.my_home = None

        self.history = None
        self.abtests = None

        # note: this seems redundant with userdb's account_creation_time, but in the future if we
        # have more game titles, then the player creation_time will be per-title
        self.creation_time = -1

        # generation number for checking validity of read->write lock transition
        self.generation = 0

        # AI instance generation (of THIS AI player)
        self.ai_generation = 0

        # AI instance generations of this human player's opponents
        # (ai_id -> {'time': 1234567, 'generation': 5})
        # this has nothing to do with the game mechanics of AI base expirations
        # it is only to defend against race conditions (stale reads) in the storage back-end
        self.ai_instance_generations = {}

        # this flag indicates that we have permission to write out updates to Player's state
        self.has_write_lock = True

        # override of current_event time, for debugging purposes
        self.event_time_override = None
        self.force_motd = False # force daily message, regardless of last_motd time (from query string)

        # for debugging purposes
        self.ladder_rival_override = None
        self.travel_override = None
        self.leaderboard_override = None

        # reseed random source on load
        self.random_source = random.Random(server_time)

        # These fields are DUPLICATES of the corresponding User
        # fields, set during the login process. This is necessary for
        # evaluating predicates that depend on them, since the Predicates
        # code only has access to Player, not User.
        self.facebook_id = ''
        self.country = 'unknown'
        self.price_region = 'unknown'
        self.country_tier = 4
        self.frame_platform = None # set during login
        self.birthday = None # UNIX timestamp of midnight of the player's birthday, None if no birthday info available
        self.locale = None
        self.trust_level = None
        self.developer = None

        self.mentor_player_id_cache = None
        self.trainee_player_ids_cache = None

        self.vpn_status = None

        self.reset()

    def reset(self):
        if self.home_region and gamesite.nosql_client:
            # if resetting a player who was placed on the map before, kill the map entry
            gamesite.nosql_client.drop_map_feature(self.home_region, home_base_id(self.user_id), reason = 'reset')

        self.home_region = None
        self.my_home = Base(self.home_region, home_base_id(self.user_id), self.user_id, 'home')

        # SQUADS
        # format is str(squad_id) -> { "id": squad_id,
        #                              "ui_name": user-visible name,
        #                              ONLY IF DEPLOYED TO MAP:
        #                              "map_loc": current (destination) location
        #                              "map_path": (optional) list of waypoints {"xy":[123,456], "eta": server_time}
        #                              "travel_speed": BASE travel speed (can be boosted by Stattab during SQUAD_MOVE) }

        self.squads = {"0": {'id': 0, 'ui_name':gamedata['strings']['squads']['base_defenders']}}

        # prevent login abuse - lock player out until this time (if >0)
        self.lockout_until = -1
        self.lockout_message = None
        self.lockout_count = 0
        self.last_lockout_end = -1
        self.last_lockout_check = -1
        self.login_pardoned_until = -1
        self.banned_until = -1
        self.isolate_pvp = 0
        self.chat_official = None
        self.possible_alt_accounts = {} # dictionary mapping str(user_id) -> # of logins recorded on same IP
        self.known_alt_accounts = {} # dictionary mapping str(user_id) -> {'logins':1234, 'attacks':1234}
        self.facebook_permissions = None
        self.last_fb_notification_time = -1
        self.last_bh_blog_feed_seen = -1
        self.fbpayments_inflight = {} # dictionary mapping request_id -> {'time':12345,'request_id':'abcd',... (see "FBPAYMENT_*" message handlers)}
        self.player_preferences = None
        self.chat_seen = {}
        self.battle_history_seen = -1 # time of latest history entry we've seen

        # list of {'obj_id':xxx,'original_hp':xxx,'res':xxx,'finish_time':xxx}
        self.unit_repair_queue = []


        self.resources = ResourceState(self)

        self.loot_buffer = []
        self.donated_units = {} # same format as player.my_army, i.e. {'DONATED-1234': {'obj_id':'DONATED-1234', 'spec':'asdf', 'level':2}}
        self.inventory = []
        self.mailbox = []
        self.map_bookmarks = {} # { "region_id": [{"ui_name": "yyy", "region": "region_id", "coords": [123,456]}] }

        # quests that have been completed (and reward claimed)
        # dictionary of { "quest_name": {"time":12335, "count":2 }, ...
        # where "time" is last completion time (used for repeatable quests) and "count" is completion count
        self.completed_quests = {}

        # map from name -> { "time": 123456, "fb_published": 1 }
        self.achievements = {}

        self.tutorial_state = 'START'

        self.alias = None
        self.title = None
        # self.unlocked_titles = None # dictionary of {'title':1}

        # dictionary mapping tech name to tech level e.g. { "tank_production": 1 }
        self.tech = {}

        # dictionary mapping unit type to equipment { "foo": { "defense": [{"spec":"foo_armor"}] } }
        self.unit_equipment = {}

        # list of {"spec": "aura_name", "strength": 1234, "start_time": 1234567, "end_time": 1234568 }
        self.player_auras = []

        # auras that expired recently - used for AuraActive predicates with override_time
        self.player_auras_recently_expired = []

        self.stattab = None # this should be initialized in load_auras/load_tech by the parsing code

        self.travel_state = {'dest_loc':None, 'start_time':-1, 'end_time':-1, 'attacks_made': 0}

        # A/B test cohort membership
        # dictionary { "T001_yyy": "group_zzz" }
        if self.abtests is None:
            self.abtests = {}
        else:
            pass # carry over tests across developer restarts

        # 'history': dictionary of historical stats (e.g., 'battles_fought', 'res_collected', etc)
        # used for mission/predicate completion tracking, and some metrics

        # version marker for player.history interface to metrics
        # we must use this because the new time-series metrics imply a value of 0 when daily samples
        # are missing, but we need to distinguish against old players who didn't ever record those metrics
        new_history = {'history_version':3,
                       # also mark this account as not needing an XP migration
                       'xp_gen': gamedata['player_xp'].get('xp_migrate_to', gamedata['player_xp'].get('xp_gen',0))
                       }
        if 'notification2_gen' in gamedata['fb_notifications']:
            new_history['notification2_gen'] = Predicates.eval_cond_or_literal(gamedata['fb_notifications']['notification2_gen'], None, self)
            new_history['notification2_gen_time'] = server_time

        # NOTE: carry over certain metrics even across tutorial restarts
        save_fields = ['logged_in_times', 'time_in_game', 'longest_play_session']
        if self.history:
            for key in save_fields:
                new_history[key] = self.history.get(key, 0)
            # also carry over adnetwork transmission records
            for key, val in self.history.iteritems():
                if key.startswith('adotomi:') or \
                   key.startswith('dauup:') or \
                   key.startswith('dauup2:') or \
                   key.startswith('adparlor:') or \
                   key.startswith('liniad:') or \
                   key.startswith('battlehouse:') or \
                   key.startswith('fb_conversion_pixels:') or \
                   key.startswith('kg_conversion_pixels:'):
                    new_history[key] = val

        self.history = new_history

        # dictionary: {"SPELL_NAME": {"start":2355, "end":23345} }
        self.cooldowns = {}

        self.scores2 = Scores2.CurScores()

        # in-playerdb battle history
        # obsolete now - replaced by SpinNoSQL battles table (and optionally cold SQL storage)
        self.battle_history = {}

        # how many attacks occurred against this player since the last expiration of his protection timer
        self.protection_attack_count = 0

        # time of last attack against player
        self.protection_attack_time = 0

        # time player last deployed units in an attack - used for throttling max attack rate
        self.attack_cooldown_start = -1

        self.idle_check = IdleCheck.IdleCheck(gamedata['server']['idle_check'], None, server_time)

        # available items in the lottery slate
        # dictionary {"slot0": {"spec":"foo"}, "slot1": ... }
        # must NOT be alterable by user action unless 1) scan is conducted or 2) reseed cooldown time passes
        self.lottery_slate = None
        self.lottery_slate_weights = None

        # PvP ladder rival, must not be alterable unless 1) attack is made or 2) time passes or 3) player pays (and waits) to switch
        self.ladder_match = None

        # last N rivals matched (including the current one) - used to prevent repeats
        self.ladder_match_history = []

        self.last_motd = 0 # time of last MOTD notice
        self.last_rank_update = 0 # time of last social network leaderboard rank update
        self.last_fb_score_update = 0 # time of last facebook Scores API call
        self.last_gift_prompt = 0 # time of last gift prompt
        self.last_friend_invite_prompt = 0 # time of last friend-invite prompt
        self.last_payer_promo = 0 # time of last payer promotion offer
        self.last_permissions_request = 0 # time of last social network permissions request
        self.last_daily_attack = 0 # time of last daily attack

        self.last_iron_deposit = 0 # spawn time of last iron deposit

        # list of gifts received recently, used for diminishing returns calc
        self.received_gifts = []

        # list where each element is a dictionary [ {"attacker":1112,"time":13534646,"lost_resources":234234, etc}, ... ]
        self.recent_attacks = []

        self.lock_state = Player.LockState.open

        # time lock_state was last set, used to expire old locks if the session died under a lock
        self.lock_time = 0

        # read-only flag for AI enemy players, which are shared by all users
        self.read_only = 0

        # used for temporary AI instance state persistence
        self.expiration_time = -1

        # persist unrecognized data from JSON file
        self.foreign_data = {}

        self.mentor_player_id_cache = None
        self.trainee_player_ids_cache = None

    def sync_with_user(self, user):
        # grab the fields that need to be copied over from the User
        self.frame_platform = user.frame_platform
        self.facebook_id = user.facebook_id
        self.birthday = user.birthday
        self.country = user.country
        self.price_region = SpinConfig.price_region_map.get(self.country, 'unknown')
        self.country_tier = SpinConfig.country_tier_map.get(self.country, 4)
        self.developer = user.developer
        self.locale = user.locale
        self.trust_level = user.get_trust_level()
        self.mentor_player_id_cache = user.bh_mentor_player_id_cache
        self.trainee_player_ids_cache = user.bh_trainee_player_ids_cache
        self.vpn_status = user.vpn_status
        self.history['last_login_ip'] = user.last_login_ip # copies last login IP for PolicyBot VPN checks

    # call this function right after tutorial_state becomes "COMPLETE" to set up post-tutorial state
    def set_post_tutorial_state(self):
        # do not send a daily attack until the day after the tutorial finish
        self.last_daily_attack = server_time

        # start post-tutorial attack protection timer
        prot_time = Predicates.eval_cond_or_literal(self.get_any_abtest_value('starting_protection_time', gamedata['starting_conditions']['protection_time']), None, self)
        if prot_time > 0:
            self.set_protection_end_time(None, server_time + prot_time, '3880_protection_from_new_account')
        else:
            self.set_protection_end_time(None, -1, None)

        auras = self.get_any_abtest_value('starting_player_auras', gamedata['starting_conditions']['player_auras'])
        for aura in auras:
            self.apply_aura(aura['name'], strength = aura.get('strength',1), duration = aura.get('duration',-1), level = aura.get('level',1), stack = aura.get('stack',-1), ignore_limit = True)

    def is_ai(self): return self.read_only
    def is_ai_user_id_range(self): return is_ai_user_id_range(self.user_id)
    def is_human(self): return not self.is_ai()
    def ai_or_human(self):
        if self.is_ai():
            return 'ai'
        else:
            return 'human'
    def is_developer(self): return bool(self.developer) # use our copy of the usertable field

    def has_alts(self):
        alt_min_logins = gamedata['server'].get('alt_min_logins', 5) # default to 5 logins for an alt to be considered
        alt_ignore_age = gamedata['server'].get('alt_ignore_age', 28*86400) # default to alts in the last 28 days
        alt_ignore_how_many = gamedata['server'].get('alt_ignore_how_many', 0) # optionally allow server to ignore up to an arbitrary number of alts
        total_alts = 0

        for s_other_id, entry in self.known_alt_accounts.iteritems():
            if entry.get('logins', 0) < alt_min_logins: continue
            if entry.get('ignore',False): continue
            if entry.get('last_login', server_time) < (server_time - alt_ignore_age): continue
            if SpinHTTP.is_private_ip(entry.get('last_ip', 'Unknown')): continue
            total_alts += 1
            if total_alts > alt_ignore_how_many:
                return True

        return False

    def squad_base_id(self, squad_id): return 's%d_%d' % (self.user_id, squad_id)
    def squad_is_deployed(self, squad_id):
        squad = self.squads.get(str(squad_id), None)
        return (squad and ('map_loc' in squad))
    def squad_is_moving(self, squad_id, assume_moving = False):
        squad = self.squads[str(squad_id)]
        # add extra fudge time to reduce chance of race conditions
        # "assume_moving" is a hint to favor the most likely case for this check (giving "benefit of the doubt")
        if gamedata['server'].get('map_path_highres_time'):
            # use precise sub-second timing
            fudge_time = (-1 if assume_moving else 1) * (gamedata['server'].get('map_path_fudge_time',0.25))
            return ('map_path' in squad) and \
                   squad['map_path'][-1]['eta'] > time.time() + fudge_time
        else:
            # old algorithm adds at LEAST 1 sec of padding time, because the server_time resolution is integer seconds, while 'eta' can be fractional.
            fudge_time = (-1 if assume_moving else 1) * (gamedata['server'].get('map_path_fudge_time',0.25) + 1.0)
            return ('map_path' in squad) and \
                   squad['map_path'][-1]['eta'] > server_time + fudge_time

    def bust_expired_locks(self):
        if self.lock_state == Player.LockState.open:
            return

        if (server_time - self.lock_time) > gamedata['server']['player_lock_timeout']:
            print 'busting expired lock for user %d !' % self.user_id
            self.lock_state = Player.LockState.open
            self.lock_time = 0

    def last_logout_time(self):
        if self.history.get('sessions', None):
            if self.history['sessions'][-1][1] > 0: # final session is closed
                return self.history['sessions'][-1][1]
            elif len(self.history['sessions']) >= 2: # final session is open
                return self.history['sessions'][-2][1]
        return -1

    def get_titled_alias(self):
        assert self.alias
        ret = self.alias
        title_template = None
        if self.title and gamedata.get('titles') and (self.title in gamedata['titles']):
            title_template = gamedata['titles'][self.title]['ui_template']
        elif gamedata.get('default_title'):
            title_template = gamedata['titles'][gamedata['default_title']]['ui_template']
        if title_template:
            ret = title_template.replace('%s', self.alias)
        return ret

    # temporary functions that skip the basedb indirection
    def home_base_iter(self): return self.my_home.iter_objects()
    def home_base_add(self, obj): return self.my_home.adopt_object(obj)
    def home_base_remove(self, obj): return self.my_home.drop_object(obj)

    def get_object_by_obj_id(self, id, fail_missing = True):
        # index this?
        for obj in self.home_base_iter():
            if obj.obj_id == id:
                return obj
        if fail_missing:
            raise Exception('object not found for obj_id '+repr(id))
        else:
            return None
    def cooldown_reset(self, cd_name, remove_stack = -1):
        if cd_name in self.cooldowns:
            if remove_stack < 0 or self.cooldowns[cd_name].get('stack',1) <= remove_stack:
                del self.cooldowns[cd_name]
            else:
                self.cooldowns[cd_name]['stack'] = self.cooldowns[cd_name].get('stack',1) - remove_stack

    def cooldown_find(self, cd_name, match_data = None):
        if cd_name in self.cooldowns:
            to_go = self.cooldowns[cd_name]['end'] - server_time_high
            if to_go > 0:
                # cooldown has not expired yet
                if match_data: # check metadata
                    data = self.cooldowns[cd_name].get('data',{})
                    for k,v in match_data.iteritems():
                        if data.get(k,None) != v:
                            return None # mismatch
                return self.cooldowns[cd_name]
            del self.cooldowns[cd_name] # get rid of expired cooldown
        return None

    # return seconds to go
    def cooldown_togo(self, cd_name, match_data = None):
        cd = self.cooldown_find(cd_name, match_data = match_data)
        if cd:
            return cd['end'] - server_time
        else:
            return -1

    # return number of active stacks
    def cooldown_active(self, cd_name, match_data = None):
        cd = self.cooldown_find(cd_name, match_data = match_data)
        if cd:
            return cd.get('stack',1)
        else:
            return 0

    def cooldown_trigger(self, cd_name, duration, add_stack = -1, data = None):
        if duration <= 0: return

        if add_stack > 0 and self.cooldown_active(cd_name):
            add_stack += self.cooldowns[cd_name].get('stack',1)

        cd = {'start': server_time, 'end': server_time + duration}
        if data:
            cd['data'] = data
        self.cooldowns[cd_name] = cd

        if add_stack > 0:
            self.cooldowns[cd_name]['stack'] = add_stack

    def prune_cooldowns(self):
        for cd_name in self.cooldowns.keys():
            self.cooldown_active(cd_name) # automatically deletes expired cooldowns

    def prune_ladder_match_history(self, session):
        max_exclude = Predicates.eval_cond_or_literal(gamedata['matchmaking'].get('ladder_match_history_exclude',1), session, self)
        while len(self.ladder_match_history) > max_exclude:
            self.ladder_match_history.remove(self.ladder_match_history[0])

    # modestly censored version of player auras for use in battle logs
    def player_auras_censored(self, deployment_allowed = True):
        ret = []
        for aura in self.player_auras_iter_const():
            spec = gamedata['auras'].get(aura['spec'],{})
            if not spec.get('show_in_battle_log', True): continue
            if (not deployment_allowed) and spec.get('cancelable', True): continue
            ret.append(aura)
        return ret

    def player_auras_iter_const(self):
        for aura in self.player_auras:
            end_time = aura.get('end_time',-1)
            if (end_time > 0) and (server_time >= end_time):
                continue
            if server_time < aura.get('start_time',-1):
                continue
            yield aura

    def prune_player_auras(self, is_session_change = False, is_login = False, is_recalc_stattab = False, is_logout = False):
        to_remove = []
        for aura in self.player_auras:
            end_time = aura.get('end_time',-1)
            if (end_time > 0) and (server_time >= end_time):
                to_remove.append(aura); continue

            spec = gamedata['auras'].get(aura['spec'], None)
            if not spec: # remove obsolete auras
                to_remove.append(aura); continue
            ends_on = spec.get('ends_on',None)

            if is_session_change and ends_on in ('session_change','battle_end'):
                to_remove.append(aura); continue
            if is_recalc_stattab and ends_on == 'recalc_stattab':
                to_remove.append(aura); continue
            if self.has_damage_protection() and ends_on == 'damage_protection':
                to_remove.append(aura)
                metric_event_coded(self.user_id, '5142_dp_cancel_aura_ended', {'aura_name': aura['spec'], 'start_time': aura.get('start_time',-1)}) # XXX hack
                continue
            if is_logout and ends_on == 'logout':
                to_remove.append(aura); continue

        for aura in to_remove:
            self.player_auras.remove(aura)
            if 'end_time' in aura and \
               aura['spec'] in gamedata['auras'] and \
               gamedata['auras'][aura['spec']].get('track_recently_expired',False):
                self.player_auras_recently_expired.append(aura)

        to_remove_expired = []
        for aura in self.player_auras_recently_expired:
            if (server_time - aura.get('end_time',-1)) >= gamedata['server'].get('player_auras_track_recently_expired_for',5*86400): # keep for 5 days
                to_remove_expired.append(aura)
        for aura in to_remove_expired:
            self.player_auras_recently_expired.remove(aura)

        return bool(to_remove)

    def get_player_auras_recently_expired(self, ref_time):
        return filter(lambda aura: aura.get('start_time',-1) <= ref_time and \
                                   aura.get('end_time',-1) > ref_time,
                      self.player_auras_recently_expired)

    def do_remove_aura(self, aura_name, remove_stack = -1, data = None):
        for aura in self.player_auras:
            if aura['spec'] == aura_name and \
               (data is None or \
                all(aura.get('data',{}).get(k,None) == v for k,v in data.iteritems())):
                if remove_stack > 0:
                    new_stack = aura.get('stack',1) - remove_stack
                    if new_stack <= 0:
                        self.player_auras.remove(aura)
                    else:
                        if 'stack' in aura: del aura['stack']
                        if new_stack != 1: aura['stack'] = new_stack
                else:
                    self.player_auras.remove(aura)
                return True
        return False

    # note: if this succeeds, and is operating on the logged-in player,
    # you will also need to perform a deferred stattab update and player_auras update on the session
    def remove_aura(self, aura_name, remove_stack = -1, force = False, data = None):
        spec = gamedata['auras'].get(aura_name, {})
        if (not force) and (not spec.get('cancelable', True)):
            return False

        return self.do_remove_aura(aura_name, remove_stack = remove_stack, data = data)

    def do_apply_aura(self, aura_name, strength = 1, duration = -1, level = 1, stack = -1, data = None, ignore_limit = False, start_time = -1):
        spec = gamedata['auras'][aura_name]
        aura = None

        # to prevent slight client/server clock mismatches from making the client think that
        # just-applied auras are not active, fudge the aura['start_time'] backward a few seconds,
        # UNLESS given a specific (future) starting time
        FUDGE_START_TIME = 10

        # find any existing aura with same spec, level, and data
        for a in self.player_auras:
            if a['spec'] == aura_name and a.get('level',1) == level and \
               (data is None or \
                all(a.get('data',{}).get(k,None) == v for k,v in data.iteritems())):
                aura = a
                break

        if aura is not None:
            # stack existing aura

            # OVERWRITE old strength - necessary so you can't
            # infinitely extend a powerful aura by repeatedly
            # applying cheaper, weaker auras with the same effect.
            if strength != 1:
                aura['strength'] = strength
            elif ('strength' in aura):
                del aura['strength']

            if stack > 0:
                aura['stack'] = aura.get('stack',1) + stack

            new_end_time = server_time + duration if duration > 0 else -1

            if True: # always overwrite aura duration
                aura['start_time'] = server_time - FUDGE_START_TIME
                if start_time > 0:
                    gamesite.exception_log.event(server_time, 'warning: attempt to update current aura "%s" with future start time! player %d' % (aura['spec'], self.user_id))
                if new_end_time < 0 and 'end_time' in aura: del aura['end_time']
                else: aura['end_time'] = new_end_time

            max_stack = spec.get('max_stack',-1)
            if max_stack > 0: aura['stack'] = min(aura['stack'], max_stack)

            # overwrite data (but note match requirement above)
            if (data is None) and 'data' in aura: del aura['data']
            if (data is not None): aura['data'] = data

        else:
            if (not ignore_limit) and player_aura_counts_against_limit(spec):
                aura_count = sum((1 for x in self.player_auras if player_aura_counts_against_limit(gamedata['auras'][x['spec']])), 0)
                if aura_count >= gamedata['player_aura_limit']:
                    return False
            # create new aura
            aura = {'spec': aura_name,
                    'start_time': start_time if start_time > 0 else (server_time - FUDGE_START_TIME)}
            if strength != 1:
                aura['strength'] = strength
            if level != 1:
                aura['level'] = level
            if duration > 0:
                aura['end_time'] = (start_time if start_time > 0 else server_time) + duration
            if stack > 0:
                aura['stack'] = stack
            if data is not None:
                aura['data'] = data
            self.player_auras.append(aura)

        return True

    # note: if this succeeds, and is operating on the logged-in player,
    # you will also need to perform a deferred stattab update and player_auras update on the session
    def apply_aura(self, *args, **kwargs):
        self.prune_player_auras()
        return self.do_apply_aura(*args, **kwargs)

    def run_battle_end_auras(self, outcome, session, retmsg):
        to_remove = []
        for aura in self.player_auras_iter_const():
            spec = gamedata['auras'].get(aura['spec'], None)
            if not spec: continue
            if spec.get('ends_on', None) == 'battle_end':
                to_remove.append(aura)
                cons = spec.get('on_battle_end_'+outcome, spec.get('on_battle_end', None))
                if cons:
                    session.execute_consequent_safe(cons, self, retmsg, reason='on_battle_end')

        for aura in to_remove: self.player_auras.remove(aura)
        return len(to_remove) > 0

    def stored_item_iter(self):
        for item in self.inventory: yield item
        for item in self.loot_buffer: yield item
    def equipped_item_iter(self, base):
        for eqdict in self.unit_equipment.itervalues():
            for item in Equipment.equip_iter(eqdict):
                yield item
        for obj in base.iter_objects():
            if obj.is_building() and obj.equipment:
                for item in Equipment.equip_iter(obj.equipment):
                    yield item
    def equipped_items_serialize(self, base): # similar to equipped_item_iter, but for transmission to the client
        for eqdict in self.unit_equipment.itervalues():
            for ret in Equipment.equip_serialize(eqdict):
                ret['obj_id'] = 'UNIT_EQUIPMENT'
                yield ret
        for obj in base.iter_objects():
            if obj.is_building() and obj.equipment:
                for ret in Equipment.equip_serialize(obj.equipment):
                    ret['obj_id'] = obj.obj_id
                    yield ret

    def count_limited_equipped_items(self, tag, base):
        count = 0
        for item in self.equipped_item_iter(base):
            if item['spec'] in gamedata['items'] and \
               gamedata['items'][item['spec']].get('limited_equipped',None) == tag:
                count += item.get('stack', 1)

        # check current crafting products that are going to be delivered into building slots
        for obj in base.iter_objects():
            if obj.is_building() and obj.is_crafter() and obj.is_crafting():
                for bus in obj.crafting.queue:
                    if bus.craft_state.get('delivery',None) and ('obj_id' in bus.craft_state['delivery']):
                        recipe_name = bus.craft_state['recipe']
                        recipe = gamedata['crafting']['recipes'].get(recipe_name, None)
                        if recipe:
                            for prod in GameObjectSpec.get_crafting_recipe_product_list(recipe, bus.craft_state.get('level', 1)):
                                if ('spec' in prod): # only works with deterministic products!
                                    item_spec = gamedata['items'][prod['spec']]
                                    if item_spec.get('limited_equipped',None) == tag:
                                        count += prod.get('stack', 1)
        return count

    def has_item(self, name, min_count = 1, level = None, min_level = None, check_mail = False, check_crafting = False):
        count = 0
        for item in self.stored_item_iter(): # inventory and loot buffer
            if item['spec'] == name and (level is None or item.get('level',1) == level) and (min_level is None or item.get('level',1) >= min_level):
                count += item.get('stack',1)
                if count >= min_count:
                    return True
        for item in self.equipped_item_iter(self.my_home):
            if item['spec'] == name and (level is None or item.get('level',1) == level) and (min_level is None or item.get('level',1) >= min_level):
                count += 1
                if count >= min_count:
                    return True
        if check_mail:
            for mail in self.mailbox:
                if ('attachments' in mail):
                    for at in mail['attachments']:
                        if at['spec'] == name and (level is None or at.get('level',1) == level) and (min_level is None or at.get('level',1) >= min_level):
                            count += at.get('stack',1)
                            if count >= min_count:
                                return True
        if check_crafting:
            for obj in self.home_base_iter():
                if obj.is_building() and obj.is_crafter() and obj.is_crafting():
                    for bus in obj.crafting.queue:
                        recipe_name = bus.craft_state['recipe']
                        recipe = gamedata['crafting']['recipes'].get(recipe_name, None)
                        if recipe:
                            for prod in GameObjectSpec.get_crafting_recipe_product_list(recipe, bus.craft_state.get('level', 1)):
                                if ('spec' in prod) and prod['spec'] == name and (level is None or prod.get('level',1) == level) and (min_level is None or prod.get('level',1) >= min_level): # only works with deterministic products!
                                    count += prod.get('stack',1)
                                    if count >= min_count:
                                        return True

                            ingr_list = bus.craft_state.get('ingredients',[])
                            if ingr_list and gamedata['crafting']['categories'][recipe['crafting_category']].get('refund_ingredients', False):
                                # only check ingredients if they are refundable and thus available to the player if cancelled
                                for item in ingr_list:
                                    if item['spec'] == name and (level is None or item.get('level',1) == level) and (min_level is None or item.get('level',1) >= min_level):
                                        count += item.get('stack',1)
                                        if count >= min_count:
                                            return True
        return False

    def prune_inventory(self, session):
        ref_time = self.get_absolute_time()
        to_remove = []
        morphed = False
        for item in self.inventory:
            spec = gamedata['items'].get(item['spec'],None)

            # check for forced expirations
            if spec and (item.get('expire_time',-1) < 0):
                expire_time = session.get_item_spec_forced_expiration(spec)
                if expire_time > 0:
                    item['expire_time'] = expire_time

            if (item.get('expire_time',-1) > 0) and (ref_time > item['expire_time']):

                expire_into = Predicates.eval_cond_or_literal(spec.get('expire_into'), session, self)
                if expire_into:
                    # morph instead of expiring
                    new_expire_time = session.get_item_spec_forced_expiration(gamedata['items'][expire_into])
                    if new_expire_time > 0 and ref_time > new_expire_time:
                        # but the morph target expired too, so just remove normally
                        to_remove.append(item)

                    else:
                        # morph it
                        self.inventory_log_event('5132_item_expired', item['spec'], -item.get('stack',1), item.get('expire_time',-1), level = item.get('level',None))

                        item['spec'] = expire_into

                        if new_expire_time > 0:
                            item['expire_time'] = new_expire_time
                        elif 'expire_time' in item:
                            del item['expire_time']

                        self.inventory_log_event('5125_item_obtained', item['spec'], item.get('stack',1), item.get('expire_time',-1), level=item.get('level',None), reason='expire_into')
                        morphed = True

                else:
                    to_remove.append(item)

        for item in to_remove:
            self.inventory.remove(item)
            self.inventory_log_event('5132_item_expired', item['spec'], -item.get('stack',1), item.get('expire_time',-1), level = item.get('level',None))

        return len(to_remove) > 0 or morphed

    def prune_mailbox(self):
        to_remove = []
        seen_ids = set()
        for mail in self.mailbox:

            # fix duplicate IDs
            while mail['msg_id'] in seen_ids:
                gamesite.exception_log.event(server_time, "player %d fixing duplicate msg_id %s" % (self.user_id, mail['msg_id']))
                mail['msg_id'] = generate_mail_id()

            seen_ids.add(mail['msg_id'])

            if ('attachments' in mail) and len(mail['attachments']) < 1:
                del mail['attachments']
            if (mail.get('expire_time',-1) > 0) and (server_time > mail['expire_time']):
                to_remove.append(mail)
        for mail in to_remove:
            self.mailbox.remove(mail)

    def travel_satisfied(self, base):
        if not base or base is self.my_home: return True
        if base.base_region != self.home_region: return False
        return (self.travel_state['dest_loc'] and \
                tuple(self.travel_state['dest_loc']) == tuple(base.base_map_loc) and \
                server_time >= self.travel_state['end_time'] and \
                (self.travel_state['end_time']-self.travel_state['start_time']) >= self.travel_time_to(base.base_map_loc) and \
                self.travel_state['attacks_made'] < gamedata['territory']['deployments_per_travel'])

    def travel_instantly_to(self, base):
        self.travel_begin(base.base_map_loc, self.travel_time_to(base.base_map_loc))
        if self.travel_state['end_time'] > 0:
            self.travel_state['start_time'] = server_time - 1 - (self.travel_state['end_time'] - self.travel_state['start_time'])
            self.travel_state['end_time'] = server_time - 1

    def travel_deploy_at(self, base_id):
        self.travel_state['attacks_made'] += 1
        if self.travel_state['attacks_made'] >= gamedata['territory']['deployments_per_travel']:
            # reset back to home base
            self.travel_state['dest_loc'] = None

    def travel_time_to(self, dest_loc):
        if dest_loc is None or self.my_home.base_map_loc is None: return 0
        dest_loc = tuple(dest_loc)
        if dest_loc == self.my_home.base_map_loc: return 0

        delta = hex_distance(self.my_home.base_map_loc, dest_loc)

        if self.travel_override: # developer-only option for debugging
            delta = min(delta, 1)

        t = delta * gamedata['territory']['travel_time_per_hex']
        if t > 0:
            t = max(1, int(t/self.stattab.get_player_stat('travel_speed')))
        return t

    def travel_begin(self, destination, travel_time):
        #gamesite.exception_log.event(server_time, 'HERE '+str(type(destination))+' '+str(destination)+' '+str((not destination)))
        if self.travel_state['dest_loc'] == destination: return
        if destination is not None:
            destination = tuple(destination)

        if (not destination) or (destination == tuple(self.my_home.base_map_loc)):
            self.travel_state = {'dest_loc': None, 'start_time': -1, 'end_time': -1 }
        else:
            self.travel_state = {'dest_loc': destination, 'start_time': server_time, 'end_time': server_time + travel_time}
        self.travel_state['attacks_made'] = 0

    def eligible_for_quarries(self):
        return self.get_any_abtest_value('enable_region_map', gamedata['enable_region_map']) and \
               Predicates.read_predicate(self.get_any_abtest_value('quarry_requirement', gamedata['territory']['quarry_requirement'])).is_satisfied(self,None)

    def is_on_map(self):
        if (self.history.get('map_placement_gen',0) < gamedata['territory']['map_placement_gen']): return False
        return bool(self.home_region) and self.my_home.base_region == self.home_region and bool(self.my_home.base_map_loc)

    # checks both eligibility and up-to-date map placement
    def can_use_quarries(self):
        return self.eligible_for_quarries() and self.is_on_map()

    # note! you might be able to "resurrect" (keep a dead object whose HP=0) but not repair it! This returns True in that case!
    def can_resurrect_unit(self, obj):
        if obj.spec.resurrectable: return True
        return self.stattab.get_unit_stat(obj.spec.name, 'resurrection', self.stattab.RESURRECT_NEVER) >= self.stattab.RESURRECT_AND_REPAIR_WITH_TECH

    def can_repair_unit(self, obj):
        if obj.hp <= 0 and \
           gamedata['resurrect_requires_tech'] and \
           (not obj.spec.resurrectable_without_tech) and \
           self.stattab.get_unit_stat(obj.spec.name, 'resurrection', self.stattab.RESURRECT_NEVER) < self.stattab.RESURRECT_AND_REPAIR_ALWAYS and \
           obj.spec.level_determined_by_tech and \
           self.tech.get(obj.spec.level_determined_by_tech, 0) < 1:
            return False
        return True

    def squads_enabled(self):
        return Predicates.read_predicate({'predicate': 'LIBRARY', 'name': 'squads_enabled'}).is_satisfied(self, None)


    def get_territory_setting(self, name, default_value = False):
        ret = gamedata['territory'].get(name, default_value)
        if self.home_region in gamedata['regions'] and \
           name in gamedata['regions'][self.home_region]:
            ret = gamedata['regions'][self.home_region][name]
        ret = self.get_any_abtest_value(name, ret)
        return ret

    def squad_block_mode(self):
        mode = self.get_territory_setting('squad_block_mode')
        assert mode in ('after_move', 'always', 'never')
        return mode
    def auto_resolve_enabled(self): return self.get_territory_setting('enable_auto_resolve')
    def squad_combat_enabled(self): return self.get_territory_setting('enable_squad_combat')
    def squad_speedups_enabled(self): return self.get_territory_setting('enable_squad_speedups')
    def squad_speedup_items_enabled(self): return self.get_territory_setting('enable_squad_speedup_items')
    def map_home_combat_enabled(self): return self.get_territory_setting('enable_map_home_combat')
    def quarry_guards_enabled(self): return self.get_territory_setting('enable_quarry_guards')
    def raids_enabled(self): return Predicates.eval_cond_or_literal(self.get_territory_setting('enable_raids'), None, self)

    # alliance raids flag - includes both defensive and offensive raids.
    # valid only when raids_enabled() is true.
    def alliance_raids_enabled(self): return Predicates.eval_cond_or_literal(self.get_territory_setting('enable_alliance_raids'), None, self)
    def squad_bumping_enabled(self): return self.get_territory_setting('enable_squad_bumping')

    def squads_affect_revenge(self): return Predicates.eval_cond_or_literal(self.get_territory_setting('squads_affect_revenge'), None, self)
    def quarries_affect_revenge(self): return Predicates.eval_cond_or_literal(self.get_territory_setting('quarries_affect_revenge'), None, self)

    def unit_speedups_enabled(self):
        return self.is_cheater or gamedata.get('enable_unit_speedups', True)
    def crafting_speedups_enabled(self):
        return self.is_cheater or gamedata.get('enable_crafting_speedups', True)

    def num_mobile_squads(self):
        return len(self.squads)-1 # don't count base defenders
    def num_deployed_squads(self):
        return len([d for d in self.squads.itervalues() if ('map_loc' in d)])
    def num_deployed_raids(self):
        return len([d for d in self.squads.itervalues() if ('map_loc' in d) and d.get('raid')])

    # raid_pvp_attempt cooldown:
    # "start" is the last time a stack was added / attempt was consumed
    # "end" is the time when all stacks will be gone / attempts restored
    def raid_pvp_attempts_left(self):
        cd = self.cooldown_find('raid_pvp_attempt')
        cd_time = self.get_territory_setting('raid_pvp_attempt_cooldown')
        if cd:
            # update stack count
            while server_time - cd['start'] > cd_time:
                cd['stack'] = cd.get('stack',1) - 1
                cd['start'] += cd_time
                assert cd['start'] < server_time
            if cd['stack'] <= 0:
                del self.cooldowns['raid_pvp_attempt']
                cd = None
        attempts_max = self.get_territory_setting('raid_pvp_attempts_max')
        if not cd:
            return attempts_max
        else:
            return max(0, attempts_max - cd.get('stack',1))

    def raid_pvp_attempt_consume(self):
        cd = self.cooldown_find('raid_pvp_attempt')
        if cd:
            cd['stack'] = cd.get('stack',1) + 1
            cd['end'] += gamedata['territory']['raid_pvp_attempt_cooldown']
        else:
            self.cooldown_trigger('raid_pvp_attempt', gamedata['territory']['raid_pvp_attempt_cooldown'], add_stack = 1)

    def which_squad_is_under_repair(self):
        squad_under_repair = None
        for item in self.unit_repair_queue:
            obj = self.get_object_by_obj_id(item['obj_id'], fail_missing = False)
            if (not obj): continue
            squad_id = obj.squad_id or 0
            squad_under_repair = squad_id
            break
        return squad_under_repair
    def squad_is_under_repair(self, squad_id): return squad_id == self.which_squad_is_under_repair()

    # check invariants on the unit repair queue
    def unit_repair_integrity_check(self):
        squad_under_repair = None
        to_cancel = []
        to_remove = []

        for item in self.unit_repair_queue:
            obj = self.get_object_by_obj_id(item['obj_id'], fail_missing = False)
            if (not obj):
                gamesite.exception_log.event(server_time, 'unit_repair_integrity_check() player %d tossing item with bad obj_id %s\n%s' % (self.user_id, repr(item), ''.join(traceback.format_stack())))
                to_remove.append(item)
                continue
            if obj.is_temporary():
                gamesite.exception_log.event(server_time, 'unit_repair_integrity_check() player %d tossing temporary object %s\n%s' % (self.user_id, repr(item), ''.join(traceback.format_stack())))
                to_cancel.append(obj)
                continue
            squad_id = obj.squad_id or 0
            if (not (SQUAD_IDS.is_mobile_squad_id(squad_id) or squad_id == SQUAD_IDS.BASE_DEFENDERS)):
                gamesite.exception_log.event(server_time, 'unit_repair_integrity_check() player %d tossing object %s with bad squad_id %s\n%s' % (self.user_id, repr(item), repr(squad_id), ''.join(traceback.format_stack())))
                to_cancel.append(obj)
                continue

            if squad_under_repair is None:
                squad_under_repair = squad_id
            else:
                if squad_id != squad_under_repair:
                    gamesite.exception_log.event(server_time, 'unit_repair_integrity_check() player %d tossing object %s with squad_id %s mismatched with squad_under_repair %s\n%s' % (self.user_id, repr(item), repr(squad_id), repr(squad_under_repair), ''.join(traceback.format_stack())))
                    to_cancel.append(obj)
                    continue

        for item in to_remove:
            self.unit_repair_queue.remove(item)
        for obj in to_cancel:
            self.unit_repair_cancel(obj, force_refund = True)

    def unit_repair_tick(self):
        self.unit_repair_integrity_check()
        affected = []
        while len(self.unit_repair_queue) > 0:
            if self.unit_repair_queue[0]['finish_time'] > server_time:
                # send estimated HP update for repairs still in progress
                item = self.unit_repair_queue[0]
                obj = self.get_object_by_obj_id(item['obj_id'], fail_missing = False)
                if obj:
                    progress = float(server_time - item['start_time'])/max(item['finish_time']-item['start_time'],1)
                    progress = min(max(progress, 0.0), 1.0)
                    obj.hp = min(obj.max_hp, max(obj.hp, int(item['original_hp'] + progress * (obj.max_hp-item['original_hp']) + 0.5)))
                    affected.append(obj)
                break
            item = self.unit_repair_queue.pop(0)
            obj = self.get_object_by_obj_id(item['obj_id'], fail_missing = False)
            if obj:
                obj.heal_to_full()
                affected.append(obj)
        return affected

    def unit_repair_queued(self, obj):
        for item in self.unit_repair_queue:
            if item['obj_id'] == obj.obj_id:
                return True
        return False

    def unit_repair_cancel(self, obj, force_refund = False):
        item = None
        index = -1
        for i in xrange(len(self.unit_repair_queue)):
            it = self.unit_repair_queue[i]
            if obj.obj_id == it['obj_id']:
                item = it
                index = i
                break
        if item is None:
            return False

        # calculate resources to return
        if index == 0:
            time_remaining = item['finish_time'] - server_time
            progress = float(server_time - item['start_time'])/max(item['finish_time']-item['start_time'],1)
            progress = min(max(progress,0),1)
            # update object's HP
            obj.hp = min(obj.max_hp, max(obj.hp, int(item['original_hp'] + progress * (obj.max_hp-item['original_hp']) + 0.5)))
        else:
            time_remaining = item['finish_time'] - self.unit_repair_queue[index-1]['finish_time']
            progress = 0

        refund = dict((res, max(0, int((1-progress)*item.get(res,0)))) for res in gamedata['resources'])
        self.unit_repair_queue.pop(index)

        # adjust timers on objects that remain in the repair queue
        for i in xrange(index, len(self.unit_repair_queue)):
            self.unit_repair_queue[i]['finish_time'] -= time_remaining
            self.unit_repair_queue[i]['start_time'] -= time_remaining

        # refund resources only on units whose repairs haven't started yet, unless using old generous setting
        if (sum(refund.itervalues(),0) > 0) and \
           (index != 0 or force_refund or gamedata['unit_repair_refund_on_cancel'] or self.squads_enabled()):
            refund = self.resources.gain_res(refund, reason='canceled_unit_repair')
            admin_stats.econ_flow_player(self, 'consumption', 'unit_repair', refund)
            return True
        return False

    def unit_repair_cancel_all(self, force_refund = False):
        while len(self.unit_repair_queue) > 0:
            object = self.get_object_by_obj_id(self.unit_repair_queue[0]['obj_id'], fail_missing = False)
            if object:
                self.unit_repair_cancel(object, force_refund = force_refund)
            else:
                self.unit_repair_queue.pop()

    @admin_stats.measure_latency('ping_squads')
    def ping_squads(self, session, return_army = False, originator = None, reason=''):
        if gamesite.nosql_client and self.home_region:
            map_squad_data = list(gamesite.nosql_client.get_map_features_by_landlord_and_type(self.home_region, self.user_id, 'squad', reason='ping_squads(%s)'%reason))
            map_object_data = list(gamesite.nosql_client.get_mobile_objects_by_owner(self.my_home.base_region, self.user_id, reason='ping_squads(%s)'%reason))
        else:
            map_squad_data = []
            map_object_data = []

        map_squads = dict([(int(data['base_id'].split('_')[1]), data) for data in map_squad_data])
        map_objects_by_squad = {}
        for entry in map_object_data:
            # note: in case of a corrupted map object with no squad_id, default to a mobile ID so that
            # we don't try to return BASE_DEFENDERS (0) to base!
            squad_id = entry.get('squad_id',None)
            if (squad_id is None) or (not SQUAD_IDS.is_mobile_squad_id(squad_id)):
                squad_id = 1 # default "could be valid" mobile squad id
            if (squad_id not in map_objects_by_squad): map_objects_by_squad[squad_id] = []
            map_objects_by_squad[squad_id].append(entry)

        home_objects_by_squad = {}
        for obj in self.home_base_iter():
            if obj.is_mobile() and (obj.owner is self):
                squad_id = obj.squad_id or 0
                if (squad_id not in home_objects_by_squad): home_objects_by_squad[squad_id] = []
                home_objects_by_squad[squad_id].append(obj.persist_state(nosql=True))

        # add any missing squads:
        for squad_id, squad_feature in map_squads.iteritems():
            if str(squad_id) not in self.squads:
                gamesite.exception_log.event(server_time, 'player %d has squad %d on map, but not in player.squads - adding' % \
                                             (self.user_id, squad_id))
                squad_data = {'id':squad_id, 'ui_name': 'Unknown'}
                if squad_feature.get('raid'):
                    squad_data['raid'] = squad_feature['raid']
                if squad_feature.get('ui_name'):
                    squad_data['ui_name'] = squad_feature['ui_name']
                self.squads[str(squad_id)] = squad_data

        to_recall = [] # list of squads to recall to base

        for sid, squad in self.squads.iteritems():
            squad_id = int(sid)
            if squad_id in map_squads:
                # it should be on the map
                map_data = map_squads[int(squad_id)]

                # harmonize local cache of movement data
                squad['map_loc'] = map_data['base_map_loc']
                if 'base_map_path' in map_data:
                    squad['map_path'] = map_data['base_map_path']
                elif 'map_path' in squad:
                    del squad['map_path']

                for FIELD in ('travel_speed','max_cargo','raid'):
                    if FIELD in map_data:
                        squad[FIELD] = map_data[FIELD]
                    elif FIELD in squad:
                        del squad[FIELD]

                must_recall = False
                # check that no objects are at home
                if (squad_id in home_objects_by_squad):
                    if gamedata['server'].get('log_nosql',0) >= 2:
                        gamesite.exception_log.event(server_time, 'player %d squad %d has map_loc %s but has in-base objects: %s' % \
                                                     (self.user_id, squad_id, repr(squad['map_loc']), repr(home_objects_by_squad[squad_id])))
                    must_recall = True
                if (squad_id not in map_objects_by_squad) and not squad.get('raid'): # XXX snap dead raids back to home?
                    if gamedata['server'].get('log_nosql',0) >= 1 and gamedata['game_id'] != 'fs': # This silences a bug warning in Firestrike. This is a bug and should be fixed eventually.
                        gamesite.exception_log.event(server_time, 'player %d squad %d has map_loc %s but no objects in NoSQL' % \
                                                     (self.user_id, squad_id, repr(squad['map_loc'])))
                    must_recall = True

                elif not squad.get('raid'): # XXX snap dead raids back to home?
                    # check if the squad is completely dead
                    if all(army_unit_is_dead(obj) for obj in map_objects_by_squad[squad_id]):
                        if gamedata['server'].get('log_nosql',0) >= 2:
                            gamesite.exception_log.event(server_time, 'player %d squad %d at map_loc %s is dead, recalling to base' % \
                                                         (self.user_id, squad_id, repr(squad['map_loc'])))
                        must_recall = True

                if self.isolate_pvp:
                    if gamedata['server'].get('log_nosql',0) >= 2:
                        gamesite.exception_log.event(server_time, 'player %d squad %d recalled because of pvp isolation' % \
                                                     (self.user_id, squad_id))
                    must_recall = True

                if must_recall:
                    to_recall.append(squad_id)
                else:
                    # squad can remain on the map
                    # recompute squad space stats from the raw data
                    prev_total_space = map_data.get('total_space', -1)
                    prev_alive_space = map_data.get('alive_space', -1)
                    total_space = 0
                    alive_space = 0

                    for obj in map_objects_by_squad[squad_id]:
                        obj_spec = self.get_abtest_spec(GameObjectSpec, obj['spec'])
                        space = obj_spec.get_leveled_quantity(obj_spec.consumes_space, obj.get('level', 1))
                        total_space += space
                        if not army_unit_is_dead(obj):
                            alive_space += space

                    if prev_total_space != total_space or \
                       prev_alive_space != alive_space:

                        # update the map feature
                        feature_update = {'total_space': total_space, 'alive_space': alive_space}

                        if gamedata['server'].get('log_nosql_squad_space',0) >= 2:
                            gamesite.exception_log.event(server_time, 'squad space update - %s/%s - ping_squads(): %r' % \
                                                         (self.home_region, self.squad_base_id(squad_id), feature_update))
                            gamesite.exception_log.event(server_time, 'session.viewing_squad_locks: %r\nsession.viewing_base_lock: %r' % \
                                                         (session.viewing_squad_locks, session.viewing_base_lock))

                        # need to lock it
                        need_to_release_lock = False
                        squad_lock_id = SpinDB.base_lock_id(self.home_region, self.squad_base_id(squad_id))

                        # already in viewing_squad_locks?
                        if session.viewing_base_lock == squad_lock_id or \
                           (session.viewing_squad_locks and squad_lock_id in session.viewing_squad_locks):
                            lock_state = Player.LockState.being_attacked
                        else:
                            lock_state = gamesite.nosql_client.map_feature_lock_acquire(self.home_region, self.squad_base_id(squad_id), self.user_id, do_hook = False, reason='ping_squads')
                            if lock_state == Player.LockState.being_attacked: # we got the lock
                                need_to_release_lock = True

                        if lock_state == Player.LockState.being_attacked:
                            # we own the lock
                            try:
                                gamesite.nosql_client.update_map_feature(self.home_region, self.squad_base_id(squad_id),
                                                                         feature_update, originator = self.user_id, reason = 'ping_squads');
                            finally:
                                if need_to_release_lock:
                                    gamesite.nosql_client.map_feature_lock_release(self.home_region, self.squad_base_id(squad_id), self.user_id, do_hook = False, reason='ping_squads')
                        else:
                            # Could not obtain the lock. This can happen if we ping_squads() while under attack elsewhere on the map.
                            # Not a big deal because the space counts will be updated after the attack.
                            if gamedata['server'].get('log_nosql_squad_space',0) >= 1:
                                gamesite.exception_log.event(server_time, 'player %d squad %d needs space update %r, but unable to lock it' % \
                                                             (self.user_id, squad_id, feature_update))

            else:
                # it should be at home base
                for FIELD in ('map_loc', 'map_path', 'travel_speed', 'raid', 'max_cargo'):
                    if FIELD in squad: del squad[FIELD]
                if (squad_id in map_objects_by_squad):
                    # this can happen after an attack where we lose a squad, but we need the player to log in to recall it into home_base_iter
                    if gamedata['server'].get('log_nosql',0) >= 2:
                        gamesite.exception_log.event(server_time, 'player %d squad %d is not on map but has NoSQL objects: %s' % \
                                                     (self.user_id, squad_id, repr(map_objects_by_squad[squad_id])))
                    if self.has_write_lock:
                        to_recall.append(squad_id)
                # it is OK to have empty squads at home base

        ret_features = [] # list of map features that were changed

        if gamedata['server'].get('log_nosql',0) >= 3:
            gamesite.exception_log.event(server_time, ("player %d ping_squads PRE-RECALL: map_object_data:\n" % self.user_id)+'\n'.join(map(repr, map_object_data))+"\nhome_objects_by_squad:\n"+'\n'.join(map(repr, home_objects_by_squad.values()))+"\nmap_objects_by_squad:\n"+'\n'.join(map(repr, map_objects_by_squad.values())))

        for squad_id in to_recall:
            success, map_features, error_code = self.squad_exit_map(session, squad_id, force = True, originator=originator, reason='ping_squads(%s)'%reason)
            if map_features: ret_features += map_features
            if error_code:
                gamesite.exception_log.event(server_time, 'player %d squad %d recall error: %s' % \
                                             (self.user_id, squad_id, repr(error_code)))
            else:
                # update state accounting
                if squad_id in map_objects_by_squad:
                    map_objects = map_objects_by_squad[squad_id]
                    del map_objects_by_squad[squad_id]
                    if squad_id not in home_objects_by_squad: home_objects_by_squad[squad_id] = []
                    for state in map_objects:
                        # check to make sure we don't have two entries with the same obj_id
                        found = False
                        for obj in home_objects_by_squad[squad_id]:
                            if obj['obj_id'] == state['obj_id']:
                                found = True
                                break
                        if not found:
                            home_objects_by_squad[squad_id].append(state)
                        # remove from map_object_data
                        for obj in map_object_data:
                            if obj['obj_id'] == state['obj_id']:
                                map_object_data.remove(obj)
                                break

        if to_recall and gamedata['server'].get('log_nosql',0) >= 3:
            gamesite.exception_log.event(server_time, ("player %d ping_squads POST-RECALL: map_object_data:\n" % self.user_id) +'\n'.join(map(repr, map_object_data))+"\nhome_objects_by_squad:\n"+'\n'.join(map(repr, home_objects_by_squad.values()))+"\nmap_objects_by_squad:\n"+'\n'.join(map(repr, map_objects_by_squad.values())))

        mailbox_update = self.trim_unit_space(map_object_data, home_objects_by_squad, map_objects_by_squad)

        if return_army:
            # return the data for PLAYER_ARMY_UPDATE, in case the caller wants it
            ret_army = [x for sublist in home_objects_by_squad.itervalues() for x in sublist] + \
                       [x for sublist in map_objects_by_squad.itervalues() for x in sublist]
        else:
            ret_army = None

        return ret_army, ret_features, mailbox_update

    # check for oversized armies
    # note: this can happen on a foreign base that has stale data, but as long as the mutation is kept atomic/idempotent within Player and its local mailbox, it should be OK
    def trim_unit_space(self, map_object_data, home_objects_by_squad, map_objects_by_squad):
        mailbox_update = False
        if (self.tutorial_state == "COMPLETE") and (self.stattab.total_space > 0) and \
           (not self.is_cheater) and Predicates.read_predicate(gamedata['server']['trim_unit_space_if']).is_satisfied(self, None):
            to_remove = []
            attachments = []
            diff = 0

            # check overall army being too large
            space_usage = self.get_army_space_usage_by_squad(map_object_data = map_object_data)
            if space_usage['ALL'] > self.stattab.total_space:
                candidates = sorted(filter(lambda obj: obj.is_mobile() and (obj.owner is self) and (not obj.is_temporary()), self.home_base_iter()), key = lambda obj: obj.get_leveled_quantity(obj.spec.consumes_space))
                for obj in candidates:
                    item_spec = 'packaged_'+obj.spec.name
                    if item_spec not in gamedata['items']:
                        gamesite.exception_log.event(server_time, 'trim_unit_space needs item '+item_spec)
                        continue
                    to_remove.append(obj)
                    found = False
                    for att in attachments:
                        if att['spec'] == item_spec and (att.get('stack',1) < gamedata['items'][item_spec].get('max_stack',1)):
                            att['stack'] = att.get('stack',1)+1
                            found = True
                            break
                    if not found: attachments.append({'spec':item_spec})
                    diff += obj.get_leveled_quantity(obj.spec.consumes_space)
                    if space_usage['ALL']-diff <= self.stattab.total_space:
                        break

            # check spec count limits
            counts = self.get_army_unit_count_by_specname(map_object_data = map_object_data)
            for name, qty in counts.iteritems():
                spec = self.get_abtest_spec(GameObjectSpec, name)
                if spec.limit >= 0 and qty > spec.limit:
                    # pull units out of home base. Note, squad units are not affected!
                    candidates = filter(lambda obj: obj.spec is spec and (obj.owner is self) and (not obj.is_temporary()), self.home_base_iter())
                    for obj in candidates:
                        item_spec = 'packaged_'+obj.spec.name
                        if item_spec not in gamedata['items']:
                            gamesite.exception_log.event(server_time, 'trim_unit_space needs item '+item_spec)
                            continue
                        to_remove.append(obj)
                        found = False
                        for att in attachments:
                            if att['spec'] == item_spec and (att.get('stack',1) < gamedata['items'][item_spec].get('max_stack',1)):
                                att['stack'] = att.get('stack',1)+1
                                found = True
                                break
                        if not found: attachments.append({'spec':item_spec})
                        qty -= 1
                        if qty <= spec.limit:
                            break

                    if qty > spec.limit:
                        # still too many, but can't do anything about squads out on the map
                        if gamedata['server']['log_trim_unit_space']:
                            gamesite.exception_log.event(server_time, 'player %d trim_unit_space spec %s (count %d limit %d) on map, cannot trim' % \
                                                         (self.user_id, name, qty, spec.limit))
            # send units back in the mail
            if to_remove:
                for obj in to_remove:
                    self.unit_repair_cancel(obj)
                    self.home_base_remove(obj)
                    # update objects_by_squad so that the following player_army_update shows the deletion
                    statelist = home_objects_by_squad.get(obj.squad_id or 0, map_objects_by_squad.get(obj.squad_id or 0, []))
                    for state in statelist:
                        if state['obj_id'] == obj.obj_id:
                            statelist.remove(state)
                            break
                    # note! we don't send OBJECT_REMOVED - we trust that this gets caught on login before the first session change!
                self.mailbox_append(self.make_system_mail(gamedata['strings']['trim_unit_space_mail' + ('_reserves' if (self.squads_enabled() and self.find_object_by_type(gamedata['squad_building'])) else '_townhall')], attachments = attachments))
                mailbox_update = True
                if diff >= gamedata['server']['log_trim_unit_space']:
                    gamesite.exception_log.event(server_time, 'player %d trim_unit_space ALL %d (limit %d) -%d %s' % \
                                                 (self.user_id, space_usage['ALL'], self.stattab.total_space, diff, repr(attachments)))

            # check individual squads being too large
            if self.squads_enabled():
                for sid, squad in self.squads.iteritems():
                    squad_id = int(sid)
                    limit = self.stattab.main_squad_space if (squad_id == SQUAD_IDS.BASE_DEFENDERS) else self.stattab.squad_space
                    if space_usage[sid] > limit:
                        diff = 0
                        moved = []
                        if self.squad_is_deployed(squad_id):
                            # can't do anything about squads out on the map
                            if gamedata['server']['log_trim_unit_space']:
                                gamesite.exception_log.event(server_time, 'player %d trim_unit_space squad %d %d (limit %d) on map, cannot trim' % \
                                                             (self.user_id, squad_id, space_usage[sid], limit))
                            continue
                        else:
                            candidates = sorted(filter(lambda obj: obj.is_mobile() and (obj.owner is self) and (not obj.is_temporary()) and obj.squad_id == squad_id, self.home_base_iter()),
                                                key = lambda obj: obj.get_leveled_quantity(obj.spec.consumes_space))

                            for obj in candidates:
                                self.unit_repair_cancel(obj)
                                obj.squad_id = SQUAD_IDS.RESERVES
                                obj.reset_as_squad_unit(self.my_home.ncells())
                                # note! we don't send OBJECT_REMOVED - we trust that this gets caught on login before the first session change!
                                # update objects_by_squad so that the following player_army_update shows the move
                                statelist = home_objects_by_squad.get(squad_id, map_objects_by_squad.get(squad_id, []))
                                for state in statelist:
                                    if state['obj_id'] == obj.obj_id:
                                        statelist.remove(state)
                                        state['squad_id'] = SQUAD_IDS.RESERVES
                                        if (SQUAD_IDS.RESERVES not in home_objects_by_squad): home_objects_by_squad[SQUAD_IDS.RESERVES] = []
                                        home_objects_by_squad[SQUAD_IDS.RESERVES].append(state)
                                        break
                                moved.append(obj.spec.name)
                                diff += obj.get_leveled_quantity(obj.spec.consumes_space)
                                if space_usage[sid]-diff <= limit:
                                    break

                        if moved:
                            self.mailbox_append(self.make_system_mail(gamedata['strings']['trim_unit_space_mail' + ('_base_defenders' if squad_id == SQUAD_IDS.BASE_DEFENDERS else '_squad')],
                                                                      replace_s = '%d' % len(moved), replace_level = squad['ui_name']))
                            mailbox_update = True
                            if gamedata['server']['log_trim_unit_space'] and \
                               ((diff >= gamedata['server']['log_trim_unit_space']) or squad_id != SQUAD_IDS.BASE_DEFENDERS):
                                gamesite.exception_log.event(server_time, 'player %d trim_unit_space squad %d %d (limit %d) -%d %s' % \
                                                             (self.user_id, squad_id, space_usage[sid], limit, diff, repr(moved)))
        return mailbox_update

    def get_manufacture_queue_space_usage(self):
        usage = 0

        for obj in self.home_base_iter():
            if obj.owner is self and obj.is_building() and obj.is_manufacturer():
                for item in obj.manuf_queue:
                    spec = GameObjectSpec.lookup(item['spec_name'])
                    usage += GameObjectSpec.get_leveled_quantity(spec.consumes_space, item.get('level',1))

        return usage

    # optionally supply map_object_data in case you just queried it
    def get_army_unit_count_by_specname(self, map_object_data = None):
        ret = {}

        # count objects at home
        for obj in self.home_base_iter():
            if (obj.owner is self) and obj.is_mobile():
                ret[obj.spec.name] = ret.get(obj.spec.name,0) + 1

            # also count units that are under construction
            elif (obj.owner is self) and obj.is_building() and obj.is_manufacturer():
                for item in obj.manuf_queue:
                    ret[item['spec_name']] = ret.get(item['spec_name'],0) + 1

        # count objects on map
        if gamesite.nosql_client and self.home_region:
            if map_object_data is None: map_object_data = gamesite.nosql_client.get_mobile_objects_by_owner(self.my_home.base_region, self.user_id, reason='get_army_unit_count_by_squad')
            for obj in map_object_data:
                ret[obj['spec']] = ret.get(obj['spec'],0) + 1

        return ret

    # optionally supply map_object_data in case you just queried it
    def get_army_space_usage_by_squad(self, map_object_data = None, exclude_manuf_queue = None):
        ret = dict([(k,0) for k in self.squads.iterkeys()] + [('ALL',0), (str(SQUAD_IDS.RESERVES),0)])
        for obj in self.home_base_iter():
            if (obj.owner is self) and obj.is_mobile():
                squad_id = obj.squad_id or 0
                space = obj.get_leveled_quantity(obj.spec.consumes_space)
                ret[str(squad_id)] += space
                ret['ALL'] += space

            # also add space occupied by units that are under construction
            elif (obj.owner is self) and obj.is_building() and obj.is_manufacturer() and (obj is not exclude_manuf_queue):
                for item in obj.manuf_queue:
                    spec = GameObjectSpec.lookup(item['spec_name'])
                    space = GameObjectSpec.get_leveled_quantity(spec.consumes_space, item.get('level',1))
                    if (not self.squads_enabled()) or (not gamedata['produce_to_reserves']):
                        ret[str(SQUAD_IDS.BASE_DEFENDERS)] += space # count queued units toward base defenders
                    ret['ALL'] += space

        if gamesite.nosql_client and self.home_region:
            if map_object_data is None: map_object_data = gamesite.nosql_client.get_mobile_objects_by_owner(self.my_home.base_region, self.user_id, reason='get_army_space_usage_by_squad')
            for obj in map_object_data:
                squad_id = obj.get('squad_id',0)
                space = GameObjectSpec.get_leveled_quantity(self.get_abtest_spec(GameObjectSpec, obj['spec']).consumes_space, obj.get('level',1))
                if str(squad_id) in ret:
                    ret[str(squad_id)] += space
                    ret['ALL'] += space
                else:
                    # orphan unit - delete it
                    gamesite.exception_log.event(server_time, 'player %d unit %s on map %s with invalid squad_id = %d, dropping' % \
                                                 (self.user_id, obj['obj_id'], self.my_home.base_region, squad_id))
                    gamesite.nosql_client.drop_mobile_object_by_id(self.my_home.base_region, obj['obj_id'], reason='get_army_space_usage_by_squad')

        return ret

    # look up a (non-base-defenders, non-reserve) squad by ID. If it exists and is at home, return the squad, else return None
    def verify_squad(self, squad_id, require_at_home = True, require_away = False):
        squad = self.squads.get(str(squad_id), None)
        if not squad: return None
        is_away = bool(squad.get('map_loc',None))
        if require_at_home and is_away: return None
        if require_away and (not is_away): return None
        return squad

    def squad_get_rollback_props(self, squad_id):
        # Grab the squad's current map feature status, whatever it is, for
        # returning to the client to fix incorrect client-side
        # predictions on all error paths.
        squad = self.squads.get(str(squad_id), None)
        if not squad: return None

        # this is the map feature we'll send back to the client to fix any incorrect predictions
        rollback_feature = {'base_id': self.squad_base_id(squad_id),
                            'preserve_locks':1 # tell the client not to forget lock state!
                            }
        if not squad.get('map_loc'):
            # squad is not on the map
            rollback_feature['DELETED'] = 1
        else:
            rollback_feature['base_map_loc'] = squad.get('map_loc',None) # note: return explicit null to correct client-side non-null field
            rollback_feature['base_map_path'] = squad.get('map_path',None) # same here
        return rollback_feature

    def squad_enter_map(self, session, squad_id, coords, raid_mode):
        if raid_mode and not self.raids_enabled(): return False, [], ["SERVER_PROTOCOL"]
        if self.isolate_pvp: return False, [], ["CANNOT_DEPLOY_SQUAD_YOU_ARE_ISOLATED", squad_id]
        if (not (gamesite.nosql_client and self.home_region)):
            return False, [], ["CANNOT_DEPLOY_SQUAD_NO_NOSQL", squad_id]
        if self.num_deployed_squads() >= self.stattab.max_deployed_squads:
            return False, [], ["CANNOT_DEPLOY_SQUAD_LIMIT_REACHED", squad_id]
        if raid_mode and self.num_deployed_raids() >= self.stattab.max_deployed_raids:
            return False, [], ["CANNOT_DEPLOY_RAID_LIMIT_REACHED", squad_id]
        assert SQUAD_IDS.is_mobile_squad_id(squad_id)
        assert type(coords) is list and len(coords) == 2 and type(coords[0]) is int and type(coords[1]) is int

        rollback_feature = self.squad_get_rollback_props(squad_id)
        if not rollback_feature: return False, [], ["INVALID_SQUAD"] # squad doesn't even exist

        squad = self.verify_squad(squad_id)
        if not squad: return False, [rollback_feature], ["INVALID_SQUAD"] # squad is already deployed

        if self.squad_is_under_repair(squad_id): return False, [rollback_feature], ["CANNOT_DEPLOY_SQUAD_UNDER_REPAIR", squad_id] # cannot deploy squad while under repair

        # raids deploy at base, otherwise squads deploy next to base
        required_dist = 0 if raid_mode else 1

        if coords[0] < 0 or coords[0] >= gamedata['regions'][self.home_region]['dimensions'][0] or \
           coords[1] < 0 or coords[1] >= gamedata['regions'][self.home_region]['dimensions'][1] or \
           hex_distance(self.my_home.base_map_loc, coords) != required_dist or \
           Region(gamedata, self.home_region).obstructs_squads(coords):
            # deployment hex is invalid, or not adjacent to home base
            return False, [rollback_feature], ["INVALID_MAP_LOCATION", squad_id, coords]

        # gather units we are going to deploy
        to_remove = []
        highest_space = -1
        icon_unit_specname = None
        total_hp = 0

        # compute travel speed, space, and max cargo here, while we have all the units in memory
        travel_speed = -1
        max_cargo = {}
        total_space = 0
        alive_space = 0

        for object in self.home_base_iter():
            if object.is_mobile() and (object.squad_id or 0) == squad_id:
                to_remove.append(object)
                total_hp += object.hp

                space = object.get_leveled_quantity(object.spec.consumes_space)
                if (space > highest_space) or (icon_unit_specname is None):
                    highest_space = space
                    icon_unit_specname = object.spec.name

                total_space += space
                if not object.is_destroyed():
                    alive_space += space

                speed = object.get_leveled_quantity(object.spec.travel_speed or object.spec.maxvel)
                assert speed > 0
                travel_speed = min(travel_speed, speed) if (travel_speed > 0) else speed

                for res in gamedata['resources']:
                    amount = object.get_leveled_quantity(getattr(object.spec, 'cargo_'+res))
                    if amount > 0:
                        max_cargo[res] = max_cargo.get(res,0) + amount

        if len(to_remove) < 1: return False, [rollback_feature], ["INVALID_SQUAD"] # cannot deploy empty squad
        if total_hp < 1: return False, [rollback_feature], ["CANNOT_DEPLOY_SQUAD_DEAD", squad_id] # cannot deploy dead squad

        feature = {'base_id': self.squad_base_id(squad_id),
                   'base_type': 'squad',
                   'base_icon': icon_unit_specname,
                   'base_ui_name': squad['ui_name'], # denormalized for ease of querying
                   'base_landlord_id': self.user_id,
                   'base_map_loc': coords,
                   'base_map_path': None, # explicit null for client's benefit
                   'travel_speed': travel_speed,
                   'total_space': total_space,
                   'alive_space': alive_space,
                   }
        if raid_mode:
            feature['raid'] = raid_mode
            feature['max_cargo'] = max_cargo

            # add player data that defenders will need to know to resolve battles/looting
            feature['player_stattab'] = self.stattab.serialize_for_squad()
            feature_player_auras = self.player_auras_censored()
            if feature_player_auras:
                feature['player_auras'] = feature_player_auras
            feature['player_tech'] = self.tech

            exclusive = -1 # no collision checks
            exclude_filter = None
        elif self.squad_block_mode() == 'never':
            exclusive = 0
            exclude_filter = {'base_type': {'$ne': 'squad'}}
        else:
            exclusive = 0
            exclude_filter = None

        # note: to avoid two successive map update broadcasts, wait until after lock release to fire the hook
        attempt = 1
        while not gamesite.nosql_client.create_map_feature(self.home_region, feature['base_id'], feature, exclusive=exclusive, exclude_filter=exclude_filter, originator=self.user_id, do_hook=False, reason='squad_enter_map'):
            # map location already occupied - send update on what's blocking us
            results = list(gamesite.nosql_client.get_map_features_by_loc(self.home_region, coords, reason='squad_enter_map(fail)'))

            if (not self.squad_bumping_enabled()) or (attempt >= 2):
                # give up
                return False, ([rollback_feature]+results), ["INVALID_MAP_LOCATION", squad_id, 'deployment_hex_occupied']

            # try to bump offending squads
            bump_count = 0
            for bumpee in results:
                if bumpee['base_type'] == 'squad' and Region(gamedata, self.home_region).feature_is_moving(bumpee, server_time, assume_moving = False):
                    if not self.squad_bump(session, bumpee):
                        # give up
                        return False, ([rollback_feature]+results), ["INVALID_MAP_LOCATION", squad_id, 'bumping_impossible']
                    bump_count += 1
            if bump_count < 1:
                # give up
                return False, ([rollback_feature]+results), ["INVALID_MAP_LOCATION", squad_id, 'nothing_to_bump']

            attempt += 1

        for object in to_remove:
            self.home_base_remove(object)
            state = object.persist_state(nosql = True)
            state['base_id'] = feature['base_id']
            gamesite.nosql_client.update_mobile_object(self.home_region, state, reason='squad_enter_map')

        squad['map_loc'] = feature['base_map_loc']
        squad['travel_speed'] = travel_speed
        if raid_mode:
            squad['raid'] = raid_mode
            squad['max_cargo'] = max_cargo
        gamesite.nosql_client.map_feature_lock_release(self.home_region, feature['base_id'], self.user_id, do_hook=False, reason='squad_enter_map')
        gamesite.gameapi.broadcast_map_update(self.home_region, feature['base_id'], feature, self.user_id)

        cdtime = self.get_territory_setting('squad_order_cooldown')
        if cdtime > 0:
            cdname = 'squad_order:%d' % squad_id
            self.cooldown_trigger(cdname, cdtime)
            session.deferred_player_cooldowns_update = True

        session.activity_classifier.set_flag('map_move')

        if session.increment_player_metric('squads_deployed', 1, time_series = False):
            pass # session.deferred_history_update = True

        return True, [feature], None

    # limit # of steps to prevent DDOS
    def squad_path_sanitize(self, coords):
        map_dimensions = gamedata['regions'][self.home_region]['dimensions']
        max_steps = map_dimensions[0]+map_dimensions[1]
        return coords[:max_steps]

    def squad_step(self, session, squad_id, coords, raid_mode, path_choices = None, bypass_cooldown = False):
        # path_choices is an optional dictionary of possible paths {"x,y": path...}
        # when the client is not sure exactly where a moving squad will halt before embarking on the new path.
        assert (gamesite.nosql_client and self.home_region)
        assert SQUAD_IDS.is_mobile_squad_id(squad_id)

        # check cooldown for non-halt commands
        if (coords or path_choices) and (not bypass_cooldown):
            cdname = 'squad_order:%d' % squad_id
            if self.cooldown_active(cdname):
                return False, [], ["CANNOT_MOVE_SQUAD_ON_COOLDOWN", squad_id] # squad doesn't even exist

        rollback_feature = self.squad_get_rollback_props(squad_id)
        if not rollback_feature: return False, [], ["INVALID_SQUAD"] # squad doesn't even exist

        squad = self.verify_squad(squad_id, require_at_home = False, require_away = True)
        if not squad: return False, [rollback_feature], ["INVALID_SQUAD"] # squad was not deployed into map yet

        # where is the squad now?
        if self.squad_is_moving(squad_id, assume_moving = False):
            start_point = squad['map_path'][0]['xy']
            for waypoint in squad['map_path']:
                if waypoint['eta'] > server_time:
                    break
                start_point = waypoint['xy']
        else:
            start_point = squad['map_loc']

        # if the client offers multiple paths, pick the one that starts from where the squad is now
        if path_choices is not None:
            assert coords is None
            key = '%d,%d' % (start_point[0], start_point[1])
            if key in path_choices:
                coords = path_choices[key]
                # note: coords might become an empty array here, if squad is to remain where it is now
            else:
                return False, [rollback_feature], ["INVALID_MAP_LOCATION", squad_id, 'no_choice_matches', start_point]

        # additional properties to add to the map feature, if the move succeeds
        # used for raids to tag the raid with extra info for this target
        add_props = {}

        # additional function to call if move succeeds, used for raids
        on_success = None

        if squad.get('raid'):
            if raid_mode:
                # initial map entry. Make sure raid is going somewhere useful.
                if not coords: # None or empty list
                    return False, [rollback_feature], ["INVALID_MAP_LOCATION", squad_id, 'raid_no_destination', None]

                if(hex_distance(coords[-1], self.my_home.base_map_loc) == 0):
                    pass # returning back to base is always allowed
                else:
                    dest_features = list(gamesite.nosql_client.get_map_features_by_loc(self.home_region, coords[-1], reason='squad_step(raid)'))
                    if not any(x.get('base_type') in ('raid','home') for x in dest_features):
                        return False, [rollback_feature], ["INVALID_MAP_LOCATION", squad_id, 'raid_invalid_destination', coords[-1]]
                    range_limit = self.stattab.raid_range_pvp if any(x.get('base_type') == 'home' for x in dest_features) else \
                                  self.stattab.raid_range_pve
                    if hex_distance(coords[-1], self.my_home.base_map_loc) > range_limit:
                        return False, [rollback_feature], ["CANNOT_DEPLOY_RAID_DIST_LIMIT", squad_id, 'raid_destination_too_far', coords[-1]]

                    # check predicates
                    # since the checks only happen at launch time, there's a chance of race conditions here
                    for x in dest_features:
                        if 'base_template' in x:
                            template = gamedata['raids_server']['templates'].get(x['base_template'])
                            if template and ('activation' in template) and (not self.is_cheater):
                                if (not Predicates.read_predicate(template['activation']).is_satisfied(self, None)):
                                    return False, [rollback_feature], ["INVALID_MAP_LOCATION", squad_id, 'raid_destination_activation_false', coords[-1]]
                        if x.get('base_type') == 'home' and x['base_landlord_id'] != self.user_id:
                            # is it a friendly guard action?
                            if self.alliance_raids_enabled() and self.is_same_alliance(x['base_landlord_id']):
                                # guard action
                                if raid_mode != 'guard' and gamedata['prevent_same_alliance_attacks']:
                                    return False, [rollback_feature], ["CANNOT_ATTACK_SAME_ALLIANCE"]
                            else:
                                # hostile action
                                if raid_mode not in ('attack','scout'):
                                    return False, [rollback_feature], ["HARMLESS_RACE_CONDITION"]

                                # perform PvP-specific attacker checks
                                # (better to do defender checks at resolve time, to avoid player-unfriendly races)
                                if self.is_alt_account_unattackable(x['base_landlord_id']) and gamedata['prevent_alt_attacks']:
                                    return False, [rollback_feature], ["CANNOT_ATTACK_ALT_ACCOUNT"]

                                elif self.stattab.sandstorm_max:
                                    return False, [rollback_feature], ["CANNOT_ATTACK_SANDSTORM_MAX"]

                                elif server_time < self.get_repeat_attack_cooldown_expire_time(x['base_landlord_id'], x['base_id']):
                                    return False, [rollback_feature], ["CANNOT_ATTACK_REPEAT_ATTACK_COOLDOWN"]

                                elif self.raid_pvp_attempts_left() < 1:
                                    return False, [rollback_feature], ["CANNOT_ATTACK_RAID_PVP_ATTEMPT_LIMIT"]

                                # init_attack() minus the defender-only parts
                                is_revenge_attack = self.cooldown_active('revenge_defender:%d' % x['base_landlord_id'])
                                if is_revenge_attack:
                                    # tag the feature with info the defender will need to know about us
                                    add_props['is_revenge_attack'] = 1

                                # add ladderable flag
                                if raid_mode == 'attack' and \
                                   (not (gamedata['anti_bullying']['enable_ladder_fatigue'] and \
                                         self.cooldown_active('ladder_fatigue:%d' % x['base_landlord_id']))) and \
                                   Predicates.read_predicate(gamedata['regions'][self.home_region].get('ladder_on_map_if',
                                                                                                       {'predicate':'ALWAYS_FALSE'})).is_satisfied(self, None) and \
                                   not self.is_alt_account_unladderable(x['base_landlord_id']):
                                    add_props['ladderable'] = 1
                                    add_props['ladder_points'] = self.ladder_points()
                                    add_props['sticky_alliances'] = self.get_sticky_alliances()

                                if not on_success:
                                    def on_attack_launch(new_path):
                                        self.raid_pvp_attempt_consume()
                                        self.init_attack_attacker(x['base_landlord_id'], True, True, None, is_revenge_attack)

                                        # remove the protection timer of the player making the attack
                                        self.set_protection_end_time(session, -1,
                                                                     '3884_protection_removed' if self.has_damage_protection() else None,
                                                                     {'defender_id':x['base_landlord_id']})
                                        # create revenge allowance
                                        if gamedata['matchmaking']['revenge_time'] > 0:
                                            self.cooldown_trigger('revenge_attacker:%d' % x['base_landlord_id'], gamedata['matchmaking']['revenge_time'])

                                        session.send([["COOLDOWNS_UPDATE", self.cooldowns]])

                                        record_player_metric(self, dict_setmax, 'last_pvp_aggression_time', server_time, time_series = False)

                                        # send real-time notification to the victim
                                        if raid_mode != 'scout':
                                            config = gamesite.get_localized_gamedata('fb_notifications', gamesite.get_locale_for_player(x['base_landlord_id'], reason = 'squad_step(raid)'))['notifications'].get('incoming_raid',{})
                                            notif_text = config.get('ui_name_home')
                                            if notif_text and new_path:
                                                notif_text = notif_text.replace('%ATTACKER', session.user.get_ui_name(self))
                                                secs_to_arrival = new_path[-1]['eta'] - server_time
                                                mins_to_arrival = max(1, (secs_to_arrival + 30) // 60) # round to nearest whole minute
                                                notif_text = notif_text.replace('%TIME', '%dmin' % mins_to_arrival)
                                                notif_args = {'method': 'send_notification', 'reliable': 1, 'user_id': x['base_landlord_id'],
                                                              'text': notif_text, 'config': 'incoming_raid', 'send_ingame': 1}
                                                gamesite.do_CONTROLAPI(self.user_id, notif_args)

                                    on_success = on_attack_launch


            else:
                # prevent re-directing raids anywhere other than back to home base
                if (coords is None) or \
                   (len(coords) == 0 and hex_distance(start_point, self.my_home.base_map_loc) != 0) or \
                   (len(coords) >= 1 and hex_distance(coords[-1], self.my_home.base_map_loc) != 0):
                    return False, [rollback_feature], ["INVALID_MAP_LOCATION", squad_id, 'raid_cannot_redirect', coords[-1] if coords else None]

        if coords is not None:
            if self.squad_is_moving(squad_id, assume_moving = False) and (path_choices is None):
                return False, [rollback_feature], ["SQUAD_RACE_CONDITION", squad_id] # squad is currently in motion, cannot accept a non-halt path

            check_path = True
            next_eta = server_time
            new_path = [{'xy': start_point, 'eta': next_eta}]

            assert type(coords) is list
            for i in xrange(len(coords)):
                waypoint = coords[i]
                assert type(waypoint) is list and len(waypoint) == 2 and type(waypoint[0]) is int and type(waypoint[1]) is int
                if waypoint[0] < 0 or waypoint[0] >= gamedata['regions'][self.home_region]['dimensions'][0] or \
                   waypoint[1] < 0 or waypoint[1] >= gamedata['regions'][self.home_region]['dimensions'][1] or \
                   (i == 0 and hex_distance(waypoint, start_point) != 1) or \
                   (i > 0 and hex_distance(waypoint, coords[i-1]) != 1) or \
                   Region(gamedata, self.home_region).obstructs_squads(waypoint):
                    # waypoint is outside of map, or not a neighbor of the previous waypoint
                    return False, [rollback_feature], ["INVALID_MAP_LOCATION", squad_id, 'waypoint', waypoint]

                # construct new path
                speed_factor_key = 'raid_travel_speed_factor' if (raid_mode or squad.get('raid')) else 'unit_travel_speed_factor'
                speed_factor = self.get_territory_setting(speed_factor_key)
                next_eta += 0 if self.travel_override else float(1.0/(speed_factor*self.stattab.get_player_stat('travel_speed')*squad.get('travel_speed',1.0)))
                new_path.append({'xy': waypoint, 'eta': next_eta})

        else:
            # player wants to halt the squad - is it halted already?
            if not self.squad_is_moving(squad_id, assume_moving = True):
                return False, [rollback_feature], ["SQUAD_RACE_CONDITION", squad_id] # squad already halted
            # compute path up to where the squad is right now
            new_path = []
            for waypoint in squad['map_path']:
                new_path.append(waypoint)
                if waypoint['eta'] > server_time:
                    break

            check_path = False # do not need to verify intermediate points

        destination = new_path[-1]['xy']

        # acquire squad mutex
        # not going to hold it for an extended period of time, so no need to broadcast
        lock_id = SpinDB.base_lock_id(self.home_region, self.squad_base_id(squad_id))
        state = gamesite.nosql_client.map_feature_lock_acquire(self.home_region, self.squad_base_id(squad_id), self.user_id, do_hook = False, reason='squad_step')
        if state != Player.LockState.being_attacked: # mutex locked
            return False, [rollback_feature], ["CANNOT_ALTER_SQUAD_WHILE_UNDER_ATTACK", squad_id]

        new_lock_gen = -1

        try:
            # verify that the squad in map_cache matches where the playerdb state says it is
            entry = gamesite.nosql_client.get_map_feature_by_base_id(self.home_region, self.squad_base_id(squad_id), reason='squad_step')
            if not entry:
                gamesite.exception_log.event(server_time, 'player %d squad %d trying to step, but not found on map' % \
                                             (self.user_id, squad_id))
                return False, [rollback_feature], ["INVALID_SQUAD"] # in-memory state said it's on the map, but database says no!

            # get rid of lock info, as if we return the feature, it'll definitely be unlocked
            for FIELD in ('LOCK_STATE', 'LOCK_OWNER'):
                if FIELD in entry: del entry[FIELD]

            # add explicit null for the path, to make sure the client takes the update
            if 'base_map_path' not in entry:
                entry['base_map_path'] = None # XXX move this to client-side? (assume a map_loc update without path nulls the path?)

            if entry['base_map_loc'][0] != squad['map_loc'][0] or entry['base_map_loc'][1] != squad['map_loc'][1]:
                gamesite.exception_log.event(server_time, 'player %d squad %d trying to step, but base location mismatches: squad %s map_cache %s' % \
                                             (self.user_id, squad_id, repr(squad['map_loc']), repr(entry['base_map_loc'])))
                return False, [entry], ["INVALID_MAP_LOCATION", squad_id, 'mismatch', squad['map_loc'], entry['base_map_loc']] # database position disagrees with in-memory state

            new_entry = copy.copy(entry)

            squad_block_mode = self.squad_block_mode()

            if entry.get('raid'):
                exclusive = -1 # never blocked at destination
                exclude_filter = {'base_type': {'$ne': 'squad'}} # blocked at intermediate waypoints by non-squads
            elif squad_block_mode == 'never':
                exclusive = 0 # blocked by any feature that's not a squad
                exclude_filter = {'base_type': {'$ne': 'squad'}}
            else:
                exclusive = 0 # blocked by any feature
                exclude_filter = None

            if check_path and coords and (len(coords) > 1) and (not gamedata['server'].get('trust_client_map_path', False)):
                # This is a race-prone check to find conflicting features at intermediate waypoints (not including the final waypoint)
                # We don't really care about squads crossing each other. The final waypoint is checked atomically below.
                if entry.get('raid') or squad_block_mode == 'never':
                    blocked = gamesite.nosql_client.map_feature_occupancy_check(self.home_region, coords[:-1], exclude_filter = exclude_filter, reason = 'squad_step')
                elif squad_block_mode == 'after_move':
                    blocked = gamesite.nosql_client.map_feature_occupancy_check_dynamic(self.home_region, new_path[1:-1], reason = 'squad_step')
                elif squad_block_mode == 'always':
                    blocked = gamesite.nosql_client.map_feature_occupancy_check(self.home_region, coords[:-1], reason = 'squad_step')

                if blocked:
                    return False, [entry], ["INVALID_MAP_LOCATION", squad_id, 'path', coords[:-1]] # map location already occupied

            # try to place squad at its final destination hex
            new_entry['base_map_loc'] = destination
            new_entry['base_map_path'] = new_path
            attempt = 1
            while not gamesite.nosql_client.move_map_feature(self.home_region, new_entry['base_id'], new_entry,
                                                             old_loc=entry['base_map_loc'], old_path=entry.get('base_map_path',None),
                                                             exclusive=exclusive, exclude_filter=exclude_filter, originator=self.user_id, reason='squad_step'):
                # conflict - check if we're moving into a friendly quarry with no other squad there
                if self.quarry_guards_enabled() or self.squad_bumping_enabled():
                    conflict_list = list(gamesite.nosql_client.get_map_features_by_loc(self.home_region, destination, reason='squad_step(conflict)'))
                else:
                    conflict_list = []

                for c in conflict_list: # add explicit nulls for client
                    if 'base_map_path' not in c:
                        c['base_map_path'] = None # XXX move this to client-side? (assume a map_loc update without path nulls the path?)

                if (len(conflict_list) == 1) and (conflict_list[0].get('base_type',None) == 'quarry') and \
                   (conflict_list[0].get('base_landlord_id',None) == self.user_id):
                    # guarding a friendly quarry - force the update
                    assert gamesite.nosql_client.move_map_feature(self.home_region, new_entry['base_id'], new_entry,
                                                                  old_loc=entry['base_map_loc'], old_path=entry.get('base_map_path',None),
                                                                  exclusive=-1, originator=self.user_id, reason='squad_step')
                    break

                if (not self.squad_bumping_enabled()) or (attempt >= 2):
                    # give up
                    return False, [entry] + conflict_list, ["INVALID_MAP_LOCATION", squad_id, 'dest', destination, [c.get('base_id') for c in conflict_list]] # map location already occupied

                # try to bump offending squads
                bump_count = 0
                for bumpee in conflict_list:
                    if bumpee['base_type'] == 'squad' and Region(gamedata, self.home_region).feature_is_moving(bumpee, server_time, assume_moving = False):
                        if not self.squad_bump(session, bumpee):
                            # give up
                            return False, [entry] + conflict_list, ["INVALID_MAP_LOCATION", squad_id, 'dest', destination, [c.get('base_id') for c in conflict_list]]
                        bump_count += 1
                if bump_count < 1:
                    # give up
                    return False, [entry] + conflict_list, ["INVALID_MAP_LOCATION", squad_id, 'dest', destination, [c.get('base_id') for c in conflict_list]]

                attempt += 1

            # success!
            new_lock_gen = entry.get('LOCK_GENERATION',-1)+1
            squad['map_loc'] = new_entry['base_map_loc']
            squad['map_path'] = new_path

            if add_props: # used for raids - add extra properties on success
                # could be integrated with move_map_feature(), or in a combined atomic enter/move step
                gamesite.nosql_client.update_map_feature(self.home_region, self.squad_base_id(squad_id), add_props,
                                                         do_hook = False, reason = 'squad_step')
            if on_success:
                on_success(new_path)

        finally:
            if lock_id:
                gamesite.nosql_client.map_feature_lock_release(self.home_region, self.squad_base_id(squad_id), self.user_id,
                                                               generation = new_lock_gen,
                                                               do_hook = False, reason='squad_step')

        if not bypass_cooldown:
            # adjust squad_order cooldown to finish after end of movement
            cdtime = self.get_territory_setting('squad_order_cooldown')
            if cdtime > 0:
                cdname = 'squad_order:%d' % squad_id
                time_ref = server_time_high if gamedata['server'].get('map_path_highres_time') else server_time
                self.cooldown_trigger(cdname,  new_path[-1]['eta'] + cdtime - time_ref)
                session.deferred_player_cooldowns_update = True

        session.activity_classifier.set_flag('map_move')

        if session.increment_player_metric('squads_moved', 1, time_series = False):
            pass # session.deferred_history_update = True

        return True, [new_entry], None

    def squad_bump(self, session, feature):
        state = gamesite.nosql_client.map_feature_lock_acquire(self.home_region, feature['base_id'], self.user_id, do_hook = False, reason='squad_bump')
        if state != Player.LockState.being_attacked: # mutex locked
            return False # bump unsuccessful - locked

        new_lock_gen = -1
        try:
            # XXX re-query the feature under the lock?
            # get rid of lock info, as if we return the feature, it'll definitely be unlocked
            for FIELD in ('LOCK_STATE', 'LOCK_OWNER'):
                if FIELD in feature: del feature[FIELD]

            squad_block_mode = self.squad_block_mode()

            if feature.get('raid'): return False # can't bump a raid
            elif squad_block_mode == 'never':
                exclusive = 0 # blocked by any feature that's not a squad
                exclude_filter = {'base_type': {'$ne': 'squad'}}
            else:
                exclusive = 0 # blocked by any feature (don't cascade)
                exclude_filter = None

            if ('base_map_path' not in feature):
                return False # bump unsuccessful - path not long enough
            old_path = feature['base_map_path']
            old_loc = feature['base_map_loc']

            while True:
                if len(feature['base_map_path']) < 3: # 2?
                    return False # bump unsuccessful - path not long enough

                # trim off one waypoint
                feature['base_map_path'] = feature['base_map_path'][:-1]
                feature['base_map_loc'] = feature['base_map_path'][-1]['xy']
                if feature['base_map_path'][-1]['eta'] < server_time:
                    return False # bump unsuccessful - already arrived
                if gamesite.nosql_client.move_map_feature(self.home_region, feature['base_id'], feature,
                                                          old_loc=old_loc, old_path=old_path,
                                                          exclusive=exclusive, exclude_filter=exclude_filter,
                                                          originator=None, # note: want the hook to inform the player, so no originator!
                                                          reason='squad_bump'):
                    # success!
                    new_lock_gen = feature.get('LOCK_GENERATION',-1)+1
                    break

            if new_lock_gen < 0:
                return False # bump unsuccessful - ran out of path to try

        finally:
            gamesite.nosql_client.map_feature_lock_release(self.home_region, feature['base_id'], self.user_id,
                                                           generation = new_lock_gen,
                                                           do_hook = False, reason='squad_bump')

        gamesite.gameapi.broadcast_map_attack(self.home_region, feature, self.user_id, feature['base_landlord_id'],
                                              None,
                                              [gamesite.gameapi.get_player_cache_props(session.user,session.player,session.alliance_id_cache),
                                               gamesite.gameapi.do_query_player_cache(session, [feature['base_landlord_id']], reason='squad_bump')[0]],
                                              msg = "REGION_MAP_ATTACK_BUMP")
        return True # bump successful

    def squad_exit_map(self, session, squad_id, force = False, originator = None, reason = ''):
        # note! change_region() splits self.home_region away from self.my_home.base_region temporarily,
        # so in here we MUST use self.home_region only

        assert (gamesite.nosql_client and self.home_region)
        assert SQUAD_IDS.is_mobile_squad_id(squad_id)

        rollback_feature = self.squad_get_rollback_props(squad_id)
        if not rollback_feature: return False, [], ["INVALID_SQUAD"] # squad doesn't even exist

        squad = self.verify_squad(squad_id, require_at_home = False, require_away = (not force))
        if not squad: return False, [rollback_feature], ["INVALID_SQUAD"] # squad is at home and we're only looking for away squads

        entry = gamesite.nosql_client.get_map_feature_by_base_id(self.home_region, self.squad_base_id(squad_id), reason = 'squad_exit_map')
        if not entry:
            if not force:
                if gamedata['server'].get('log_nosql',0) >= 0:
                    gamesite.exception_log.event(server_time, 'player %d squad %d trying to exit, but not found on map' % \
                                                 (self.user_id, squad_id))
                return False, [rollback_feature], ["INVALID_SQUAD"] # database doesn't have the squad
            else:
                entry = {'base_id': self.squad_base_id(squad_id), 'DELETED':1}

        if (not force) and (hex_distance(entry['base_map_loc'], self.my_home.base_map_loc) > 1):
            return False, [entry], ["INVALID_MAP_LOCATION", squad_id, 'out_of_range'] # squad is not adjacent to home base

        if (not force) and Region(gamedata, self.home_region).feature_is_moving(entry, server_time, assume_moving = False):
            return False, [entry], ["INVALID_MAP_LOCATION", squad_id, 'still_moving'] # squad is still moving

        if gamedata['server'].get('log_nosql',0) >= 2:
            gamesite.exception_log.event(server_time, 'player %d squad_exit_map %d has_write_lock %d' % \
                                         (self.user_id, squad_id, int(self.has_write_lock)))

        if (not self.has_write_lock):
            assert force
            # if it's the non-playing owner, the only thing we can do is blow the base off the map
            # the owner has to log in to reclaim the objects into the base
            gamesite.nosql_client.drop_map_feature(self.home_region, self.squad_base_id(squad_id), originator = originator, reason='squad_exit_map')
            return True, [{'base_id': self.squad_base_id(squad_id), 'DELETED':1}], None

        lock_id = SpinDB.base_lock_id(self.home_region, self.squad_base_id(squad_id))
        if session and session.viewing_squad_locks and (lock_id in session.viewing_squad_locks):
            lock_id = None # lock already acquired
        else:
            # not going to hold it for an extended period of time, so no need to broadcast
            lock_state = gamesite.nosql_client.map_feature_lock_acquire(self.home_region, self.squad_base_id(squad_id), self.user_id, do_hook = False, reason='squad_exit_map')
            if lock_state != Player.LockState.being_attacked: # mutex locked
                if not force:
                    return False, [entry], ["CANNOT_ALTER_SQUAD_WHILE_UNDER_ATTACK", squad_id]
                else:
                    # possible cases:
                    # - the squad was killed by an attacker, so that it no longer exists in the map, but its objects do. This is totally normal.
                    # - the squad does still exist in the map, but is locked (e.g. you're leaving a region while one squad is under attack). This is the case that can actually cause orphan units.
                    # check existence of the base to see which case we have.
                    if gamedata['server'].get('log_nosql',0) >= 1 and gamesite.nosql_client.get_map_feature_by_base_id(self.home_region, self.squad_base_id(squad_id), reason='squad_exit_map(check_exist)'):
                        gamesite.exception_log.event(server_time, 'player %d (session %d) squad_exit_map(reason "%s") squad %d with force=1 but squad is locked - may result in orphan units!' % \
                                                     (self.user_id, session.player.user_id if session else -1, reason, squad_id))
                    lock_id = None

        try:
            to_add = list(gamesite.nosql_client.get_mobile_objects_by_base(self.home_region, self.squad_base_id(squad_id), reason='squad_exit_map'))
            self.squad_dock_units(squad_id, to_add, cargo = entry.get('cargo'), cargo_source = entry.get('cargo_source'), force = force)
            if session and entry.get('cargo'):
                session.deferred_player_state_update = True

            gamesite.nosql_client.drop_mobile_objects_by_base(self.home_region, self.squad_base_id(squad_id), reason='squad_exit_map')
            gamesite.nosql_client.drop_map_feature(self.home_region, self.squad_base_id(squad_id), originator=self.user_id, reason='squad_exit_map')
            # lock was blown away
            if session: session.forget_base_lock(SpinDB.base_lock_id(self.home_region, self.squad_base_id(squad_id)))
            lock_id = None

            # reformat map_cache entry for client-side deletion
            entry = {'base_id': self.squad_base_id(squad_id), 'DELETED': 1}

        finally:
            if lock_id: gamesite.nosql_client.map_feature_lock_release(self.home_region, self.squad_base_id(squad_id), self.user_id, do_hook = False, reason='squad_exit_map')

        return True, [entry], None

    # return a list of units from the map (JSON states) into home base
    def squad_dock_units(self, squad_id, state_list, cargo = None, cargo_source = None, force = False):
        squad = self.verify_squad(squad_id, require_at_home = False, require_away = (not force))
        for state in state_list:
            if ('kind' in state and state['kind'] != 'mobile') or ('owner_id' in state and state['owner_id'] != self.user_id):
                gamesite.exception_log.event(server_time, 'player %d squad_dock_units bad state: %r' % (self.user_id, state))
                continue

            # force items with squad_ids not in player.squads into reserves, to avoid accidentally giving the player more squads than allowed
            if 'squad_id' in state:
                if state['squad_id'] != squad_id or str(state['squad_id']) not in self.squads:
                    state['squad_id'] = -1

            if ('obj_id' in state) and self.get_object_by_obj_id(state['obj_id'], fail_missing = False):
                if gamedata['server'].get('log_nosql',0) >= 2:
                    gamesite.exception_log.event(server_time, 'player %d squad_dock_units %d already has object %s at home, skipping' % \
                                                 (self.user_id, state['squad_id'], state['obj_id']))
                continue

            self.home_base_add(reconstitute_object(self, self, state, context = 'player %d squad_dock_units' % (self.user_id,)))

        if squad:
            # update in-memory version of the squad (under player.squads)
            for FIELD in ('map_loc', 'map_path', 'travel_speed', 'raid', 'max_cargo'):
                if FIELD in squad: del squad[FIELD]
        if cargo:
            self.squad_collect_cargo(cargo, cargo_source)

    def squad_collect_cargo(self, cargo, cargo_source):
        gained = self.resources.gain_res(dict((res, cargo.get(res,0)) for res in gamedata['resources']), reason = cargo_source or '')
        if cargo_source:
            admin_stats.econ_flow_player(self, 'loot', cargo_source, gained)

    # get level-dependent quantity (based on PLAYER level)
    def get_leveled_quantity(self, qty, do_clamp = True):
        lev = self.resources.player_level
        if type(qty) is list and do_clamp:
            lev = min(lev, len(qty))
        return GameObjectSpec.get_leveled_quantity(qty, lev)

    # get value from abtest 'group' data, falling back to
    # default_group if this player is not assigned to a group or the
    # test went inactive, and falling back to default_value if the
    # test is missing.
    def get_abtest_value(self, test_name, key, default_value):
        if test_name in gamedata['abtests']:
            if gamedata['abtests'][test_name]['active'] and (test_name in self.abtests):
                group = self.abtests[test_name]
            else:
                group = gamedata['abtests'][test_name]['default_group']
            return gamedata['abtests'][test_name]['groups'][group][key]
        else:
            return default_value

    # same as above but this time we are looking up patches that modify gamedata specs
    # that affect server operation (e.g. unit/tech build costs)

    def get_abtest_spec(self, klass, name):
        ret = klass.lookup(name)
        key = Spec.KEY_MAP[ret.kind]

        for test_name, group in self.abtests.iteritems():
            if test_name in gamedata['abtests'] and \
               group in gamedata['abtests'][test_name]['groups'] and \
               gamedata['abtests'][test_name]['groups'][group].has_key(key) and \
               gamedata['abtests'][test_name]['active'] and \
               gamedata['abtests'][test_name]['groups'][group].get('patches_server_specs',0):
                patches = self.get_abtest_value(test_name, key, {})
                if name in patches:
                    ret = ret.make_patched(patches[name])
        return ret
    def get_abtest_object_spec(self, name): return self.get_abtest_spec(GameObjectSpec, name)

    def get_abtest_quest(self, name):
        ret = Quest(name)
        key = 'quests'
        for test_name, group in self.abtests.iteritems():
            if test_name in gamedata['abtests'] and \
               group in gamedata['abtests'][test_name]['groups'] and \
               gamedata['abtests'][test_name]['groups'][group].has_key(key) and \
               gamedata['abtests'][test_name]['active'] and \
               gamedata['abtests'][test_name]['groups'][group].get('patches_server_specs',0):
                patches = self.get_abtest_value(test_name, key, {})
                if name in patches:
                    ret = ret.make_patched(patches[name])
        return ret

    def get_abtest_predicate(self, name):
        ret = gamedata['predicate_library'][name]
        key = 'predicate_library'
        for test_name, group in self.abtests.iteritems():
            if test_name in gamedata['abtests'] and \
               group in gamedata['abtests'][test_name]['groups'] and \
               gamedata['abtests'][test_name]['groups'][group].has_key(key) and \
               gamedata['abtests'][test_name]['active'] and \
               gamedata['abtests'][test_name]['groups'][group].get('patches_server_specs',0):
                patches = self.get_abtest_value(test_name, key, {})
                if name in patches:
                    ret = patches[name]
        return ret

    def get_abtest_consequent(self, name, fail_missing = True):
        ret = gamedata['consequent_library'].get(name, None) # ret can be None here!
        key = 'consequent_library'
        for test_name, group in self.abtests.iteritems():
            if test_name in gamedata['abtests'] and \
               group in gamedata['abtests'][test_name]['groups'] and \
               gamedata['abtests'][test_name]['groups'][group].has_key(key) and \
               gamedata['abtests'][test_name]['active'] and \
               gamedata['abtests'][test_name]['groups'][group].get('patches_server_specs',0):
                patches = self.get_abtest_value(test_name, key, {})
                if name in patches:
                    ret = patches[name]
        if (ret is None) and fail_missing:
            raise Exception('consequent not found: '+name)
        return ret

    def get_abtest_offer(self, name):
        return gamedata['offers'][name]

    def get_abtest_item(self, name):
        return gamedata['items'].get(name, None)
    def get_abtest_item_set(self, name):
        return gamedata['item_sets'].get(name, None)
    def get_abtest_aura(self, name):
        return gamedata['auras'].get(name, None)
    def get_abtest_region(self, name):
        return gamedata['regions'].get(name, None)
    def get_abtest_ai_base(self, user_id):
        return gamedata['ai_bases_server']['bases'].get(str(user_id), None)
    def get_abtest_title(self, name):
        return gamedata['titles'].get(name, None)
    def get_gamedata_var(self, name): # similar to get_abtest(), for use by Predicates, but does not support overrides
        v = gamedata
        for elem in name.split('.'):
            v = v.get(elem, None)
        return v

    # check for ANY active abtest group we're in that contains a value named 'key'
    # but, do NOT apply "default_group" behavior
    def get_any_abtest_value(self, key, default_value):
        for test_name, group in self.abtests.iteritems():
            if test_name in gamedata['abtests'] and \
               group in gamedata['abtests'][test_name]['groups'] and \
               gamedata['abtests'][test_name]['active'] and \
               gamedata['abtests'][test_name]['groups'][group].has_key(key):
                return gamedata['abtests'][test_name]['groups'][group][key]
        return default_value

    def get_absolute_time(self):
        if self.event_time_override is not None:
            cur_time = self.event_time_override
        else:
            cur_time = server_time
        return cur_time

    # Return the event_schedule entry for an event in progress
    def get_event_schedule(self, event_kind, event_name, ref_time, ignore_activation):
        assert event_kind in ('current_event', 'current_event_store', 'current_event_no_store',
                              'facebook_sale', 'bargain_sale', 'backend_time_event',
                              'current_trophy_pve_challenge', 'current_trophy_pvp_challenge',
                              'current_stat_tournament')
        assert ref_time is not None

        # PvP-isolated players may not get trophies
        if self.isolate_pvp and ('trophy' in event_kind): return None

        extra_items = self.get_any_abtest_value('event_schedule', [])

        # note: event_schedule is assumed to be sorted in order of starting times
        for entry in (gamedata['event_schedule'] + extra_items):
            data = gamedata['events'].get(entry['name'], None)
            if not data: continue
            if ('kind' not in data) or (data['kind'] != event_kind): continue

            # first run of event starts at start_time and ends at end_time
            # if repeat_interval is specified, event re-runs at start_time + repeat_interval
            if entry['start_time'] > ref_time: continue # event is in the future
            if 'repeat_interval' in entry:
                delta = (ref_time - entry['start_time']) % entry['repeat_interval']
                if delta >= (entry['end_time'] - entry['start_time']): continue # we are between runs
            else:
                if entry['end_time'] <= ref_time: continue # event is in the past


            if (event_name and (entry['name'] != event_name)): continue
            if not ignore_activation:
                if ('activation' in entry) and (not Predicates.read_predicate(entry['activation']).is_satisfied(self, None)): continue
                if ('activation' in data) and (not Predicates.read_predicate(data['activation']).is_satisfied(self, None)): continue
            # match
            return entry

# XXX don't handle regional events anymore
#        if self.home_region in gamedata['regions']:
#            regional_event = gamedata['regions'][self.home_region].get('regional_event', None)
#            if regional_event == event_name:
#                return gamedata['events'][regional_event]

        return None

    def get_event_data(self, event_kind, event_name = None, ref_time = None, ignore_activation = False):
        if ref_time is None: ref_time = self.get_absolute_time()
        sched = self.get_event_schedule(event_kind, event_name, ref_time, ignore_activation)
        if sched:
            return gamedata['events'][sched['name']]
        return None

    def get_event_time(self, event_kind, event_name, method, ignore_activation = False, t_offset = 0):
        ref_time = self.get_absolute_time() + t_offset
        entry = self.get_event_schedule(event_kind, event_name, ref_time, ignore_activation)
        if not entry: return None

        if method == 'start': # time since start of current run
            if 'repeat_interval' in entry:
                return (ref_time - entry['start_time']) % entry['repeat_interval']
            else:
                return ref_time - entry['start_time']
        elif method == 'end': # negative time until end of current run
            if 'repeat_interval' in entry:
                delta = (ref_time - entry['start_time']) % entry['repeat_interval']
                return delta - (entry['end_time'] - entry['start_time'])
            else:
                return ref_time - entry['end_time']
        elif method == 'inprogress': # true if event is in progress, false if not
            if 'repeat_interval' in entry:
                if ref_time < entry['start_time']: return False
                delta = (ref_time - entry['start_time']) % entry['repeat_interval']
                return (delta < (entry['end_time'] - entry['start_time']))
            else:
                return (ref_time >= entry['start_time'] and ref_time < entry['end_time'])
        elif method == 'progress': # 0.0-1.0 progress during current run of event
            if 'repeat_interval' in entry:
                if ref_time < entry['start_time']: return 0
                delta = (ref_time - entry['start_time']) % entry['repeat_interval']
                if delta >= (entry['end_time'] - entry['start_time']): return 0
                return delta / float(entry['end_time']-entry['start_time'])
            else:
                if ref_time < entry['start_time']: return 0
                if ref_time >= entry['end_time']: return 0
                return (ref_time - entry['start_time'])/float(entry['end_time']-entry['start_time'])
        elif method == 'enabled':
            return True
        else:
            raise Exception('unknown method '+method)

    def foreman_is_busy(self):
        busy = 0

        for obj in self.home_base_iter():
            if obj.is_building():
                if obj.is_using_foreman():
                    busy += 1
                    if busy >= self.stattab.total_foremen:
                        return True

        return False

    def remover_is_busy(self):
        for obj in self.home_base_iter():
            if (obj.is_building() or obj.is_inert()) and obj.is_removing():
                return True
        return False

    def alliance_building_is_busy(self):
        alliance_building = self.find_object_by_type(gamedata['alliance_building'])
        if (not alliance_building) or alliance_building.is_busy() or alliance_building.is_damaged():
            return True
        return False

    def region_map_building_is_busy(self):
        region_map_building = self.find_object_by_type(gamedata['region_map_building'])
        if (not region_map_building) or \
           ((region_map_building.is_under_construction() or region_map_building.is_upgrading() or region_map_building.is_enhancing() or region_map_building.is_removing()) and (not self.get_any_abtest_value('region_map_available_during_transmitter_upgrade', gamedata['territory']['region_map_available_during_transmitter_upgrade']))) or \
           (region_map_building.is_damaged() and (not self.get_any_abtest_value('region_map_available_during_transmitter_repair', gamedata['territory']['region_map_available_during_transmitter_repair']))):
            return True
        return False
    def warehouse_is_busy(self):
         if self.get_any_abtest_value('enable_inventory', gamedata['enable_inventory']):
             warehouse = self.find_object_by_type(gamedata['inventory_building'])
             if (not warehouse) or \
                ((warehouse.is_under_construction() or warehouse.is_upgrading() or warehouse.is_enhancing() or warehouse.is_removing()) and (not self.get_any_abtest_value('inventory_available_during_warehouse_upgrade', gamedata.get('inventory_available_during_warehouse_upgrade',False)))) or \
                (warehouse.is_damaged() and (not self.get_any_abtest_value('inventory_available_during_warehouse_repair', gamedata.get('inventory_available_during_warehouse_repair',False)))):
                 return True
         return False
    def squad_bay_is_busy(self):
         if self.squads_enabled():
             bay = self.find_object_by_type(gamedata['squad_building'])
             if (not bay) or \
                ((bay.is_under_construction() or bay.is_upgrading() or bay.is_enhancing() or bay.is_removing()) and (not self.get_any_abtest_value('squads_available_during_squad_bay_upgrade', gamedata.get('squads_available_during_squad_bay_upgrade',0)))) or \
                (bay.is_damaged() and (not self.get_any_abtest_value('squads_available_during_squad_bay_repair', gamedata.get('squads_available_during_squad_bay_repair',0)))):
                 return True
         return False
    def lottery_is_busy(self, scanner):
         if self.get_any_abtest_value('enable_lottery', gamedata['enable_lottery']):
             if (not scanner) or \
                ((scanner.is_under_construction() or scanner.is_upgrading() or scanner.is_enhancing() or scanner.is_removing()) and (not self.get_any_abtest_value('lottery_available_during_scanner_upgrade', gamedata.get('lottery_available_during_scanner_upgrade',False)))) or \
                (scanner.is_damaged() and (not self.get_any_abtest_value('lottery_available_during_scanner_repair', gamedata.get('lottery_available_during_scanner_repair',False)))):
                 return True
         return False

    def find_object_by_type(self, specname): return self.my_home.find_object_by_type(specname)

    def find_lottery_building(self):
        for obj in self.home_base_iter():
            if obj.is_building() and obj.is_lottery_building():
                return obj
        return None
    def get_townhall_level(self): return self.my_home.get_townhall_level()
    def get_townhall_level_fast(self): return self.history.get(gamedata['townhall']+'_level', 1) # for analytics only - may be inaccurate

    # NOTE! unlike resources.calc_snapshot(), this function returns
    # the storage you'd have IF ALL STORAGE BUILDINGS WERE HEALTHY
    def get_max_storage(self):
        ret = dict((res,0) for res in gamedata['resources'])
        for obj in self.home_base_iter():
            if obj.is_building() and not obj.is_under_construction():
                for res in gamedata['resources']:
                    ret[res] += obj.get_leveled_quantity(getattr(obj.spec, 'storage_'+res))
        return ret

    def attackable_level_range(self, mode = None):
        attacker_level = self.level()

        if mode is None:
            if self.is_ladder_player():
                mode = 'ladder'
            else:
                mode = 'default'

        # game-global level gap table
        level_gap_table = gamedata['max_pvp_level_gap']

        # optional per-region override
        if self.home_region and (self.home_region in gamedata['regions']):
            level_gap_table = gamedata['regions'][self.home_region].get('max_pvp_level_gap', level_gap_table)

        lower_bound = _min_attackable_level(level_gap_table[mode], attacker_level)
        if gamedata.get('apply_pvp_level_gap_upward',False):
            # stupid algorithm, I know
            upper_bound = lower_bound
            while _min_attackable_level(level_gap_table[mode], upper_bound) <= attacker_level:
                upper_bound += 1
            if upper_bound > lower_bound: upper_bound -= 1
        else:
            upper_bound = -1
        return [lower_bound, upper_bound]

    def in_attackable_level_range(self, defender_level, mode = None):
        return in_level_range(defender_level, self.attackable_level_range(mode = mode))

    def level(self): return self.resources.player_level

    def get_achievement_points(self):
        total = 0
        for name in self.achievements:
            data = gamedata['achievements'].get(name, None)
            if data:
                total += data.get('achievement_points', 0)
        return total

    # the official way to get a player's current ladder point count
    def ladder_points(self): return self.get_master_score('trophies_pvp')
    def trophies_pvv(self): return self.get_master_score('trophies_pvv')
    def get_master_score(self, stat):
        return self.scores2.get(stat, self.scores2_ladder_master_point()) or 0

    # return number of non-destroyed buildings that can yield loot to an attacker
    def get_lootable_buildings(self):
        return sum([1 for obj in self.home_base_iter() if (obj.is_building() and (obj.is_storage() or obj.is_producer()) and (not obj.is_destroyed()))], 0)

    def query_suitable_ladder_match(self, exclude_user_ids = [], exclude_alliance_ids = [], trophy_range = None, townhall_range = None,
                                    min_trophies = None):
        # note: order of fields here is important for query speed
        mtime_filter = None

        if trophy_range or (min_trophies is not None):
            # note: SpinNoSQL translates this into a fake join on player score data - it's not really in player cache
            trophy_field = ('scores2', ('trophies_pvp', self.scores2_ladder_master_point()))

            if trophy_range:
                mycount = self.ladder_points()
                trophy_filter = [trophy_field, mycount - trophy_range[0], mycount + trophy_range[1]]
            else:
                trophy_filter = [trophy_field, -999999, 999999]

            if min_trophies is not None:
                trophy_filter[1] = max(trophy_filter[1], min_trophies) # adjust the min upwards

            trophy_filter_includes_zero = (trophy_filter[1] <= 0 and trophy_filter[2] >= 0)
        else:
            trophy_filter = None

        if townhall_range:
            gamesite.db_client.player_cache_create_index(gamedata['townhall']+'_level') # make sure there's an index
            mycount = self.get_townhall_level_fast()
            townhall_filter = [gamedata['townhall']+'_level', max(1, mycount - townhall_range[0]), max(1, mycount + townhall_range[1])]

            # any query that touches townhall 2 or below is considered "huge" because it's almost accept-all
            townhall_filter_is_huge = (townhall_filter[1] <= 2)

            # also see if we want to add an mtime filter
            if 'ladder_match_mtime_limit_by_townhall' in gamedata['matchmaking']:
                mtime_limit_table = gamedata['matchmaking']['ladder_match_mtime_limit_by_townhall']
                mtime_limit = mtime_limit_table[min(townhall_filter[1]-1, len(mtime_limit_table)-1)]
                if mtime_limit > 0:
                    mtime_filter = ['last_mtime', server_time - mtime_limit, server_time]

        query = []

        # if the trophy filter does NOT include players with 0 trophies, then it's almost a reject-all filter, so put at the beginning
        if (trophy_filter is not None) and (not trophy_filter_includes_zero):
            query.append(trophy_filter)

        if townhall_range and (not townhall_filter_is_huge):
            query.append(townhall_filter)

        if mtime_filter:
            query.append(mtime_filter)

        if not gamedata.get('ladder_pvp', False):
            query.append(['ladder_player',1,1])

        if (not gamedata['predicate_library']['pvp_requirement']['predicate'].startswith('ALWAYS_')):
            query.append(['pvp_player',1,1]) # after some transition time, this should be unnecessary, since ladder_player implies pvp_player

        level_range = [-1,9999]

        r = self.attackable_level_range(mode = 'ladder')
        if r[0] > 0: level_range[0] = max(level_range[0], r[0])
        if r[1] > 0: level_range[1] = min(level_range[1], r[1])

        if gamedata['matchmaking']['ladder_match_up_levels'] > 0:
            level_range[1] = min(level_range[1], self.level() + gamedata['matchmaking']['ladder_match_up_levels'])
        if gamedata['matchmaking']['ladder_match_down_levels'] > 0:
            level_range[0] = max(level_range[0], self.level() - gamedata['matchmaking']['ladder_match_down_levels'])

        if level_range[0] > 0 or level_range[1] < 9999:
            gamesite.db_client.player_cache_create_index('player_level') # make sure there's an index
            query.append(['player_level', level_range[0], level_range[1]])

        if gamedata.get('pvp_repair_on_victory', False) and gamedata.get('pvp_repair_on_defeat', False):
            # no need to query base damage, since there won't be any
            pass
        else:
            query += [['base_damage', 0, gamedata['matchmaking']['ladder_win_damage']-0.001], # note: missing (-1) data is treated as unsuitable
                      ['base_repair_time', -100, server_time],
                      ['lootable_buildings', 1, 9999]]

        if gamedata['starting_conditions'].get('tutorial_state', None) != 'COMPLETE':
            query += [['tutorial_complete',1,1]]

        query += [['protection_end_time', -100, server_time]]

        # if the trophy filter includes players with 0 trophies, then it's almost an accept-all filter, so put it at the end
        if (trophy_filter is not None) and trophy_filter_includes_zero:
            query.append(trophy_filter)

        if townhall_range and townhall_filter_is_huge:
            query.append(townhall_filter)

        query += [['LOCK_STATE', -1, 0], # not locked
                  ['isolate_pvp', -999, 0.1], # not isolated
                  ['user_id', self.user_id, self.user_id, '!in']] # don't fight yourself

        for aid in set(exclude_alliance_ids):
            # don't fight your own alliancemates
            query.append(['alliance_id', aid, aid, '!in'])
        for excl in set(exclude_user_ids):
            # don't fight previously-matched user(s)
            query.append(['user_id', excl, excl, '!in'])

        # don't fight people we have fatigue for
        for cdname, cdata in self.cooldowns.iteritems():
            if cdname.startswith('ladder_fatigue:') or \
               (cdname.startswith('battle_fatigue:') and (cdata.get('stack',1) >= gamedata['anti_bullying']['sandstorm_max_battle_fatigue'])):
                id = int(cdname.split(':')[1])
                query.append(['user_id', id, id, '!in'])

        # don't match AIs
        query.append(['facebook_id', '-1', '-1', '!in'])
        query.append(['social_id', 'ai', 'ai', '!in'])

        if gamedata['server']['log_ladder_pvp'] >= 3:
            start_time = time.time()
            gamesite.exception_log.event(server_time, 'find_suitable_ladder_match: %d query %s' %
                                         (self.user_id, repr(query)))

        candidate_id = gamesite.db_client.player_cache_query_ladder_rival(query,
                                                                          randomize_quality = gamedata['matchmaking'].get('ladder_match_randomize_quality', 1),
                                                                          reason = 'ladder')

        if gamedata['server']['log_ladder_pvp'] >= 3:
            end_time = time.time()
            gamesite.exception_log.event(server_time, 'find_suitable_ladder_match: %d %.0fms candidate %r' %
                                         (self.user_id, 1000.0*(end_time-start_time), repr(candidate_id)))

        return candidate_id

    @admin_stats.measure_latency('find_suitable_ladder_match')
    def find_suitable_ladder_match(self, exclude_user_ids = [], exclude_alliance_ids = []):
        id = None
        min_trophies = None
        if 'ladder_match_min_trophies' in gamedata['matchmaking']:
            min_trophies = Predicates.eval_cond_or_literal(gamedata['matchmaking']['ladder_match_min_trophies'], None, self)
        if gamedata['matchmaking']['ladder_match_by'] == 'trophies':
            for passnum in xrange(len(gamedata['matchmaking']['ladder_match_trophy_range'])):
                id = self.query_suitable_ladder_match(exclude_user_ids = exclude_user_ids, exclude_alliance_ids = exclude_alliance_ids,
                                                      min_trophies = min_trophies,
                                                      trophy_range = gamedata['matchmaking']['ladder_match_trophy_range'][passnum]) # note: may be None/null
                if id: break
        elif gamedata['matchmaking']['ladder_match_by'] == 'townhall':
            for passnum in xrange(len(gamedata['matchmaking']['ladder_match_townhall_range'])):
                id = self.query_suitable_ladder_match(exclude_user_ids = exclude_user_ids, exclude_alliance_ids = exclude_alliance_ids,
                                                      min_trophies = min_trophies,
                                                      townhall_range = gamedata['matchmaking']['ladder_match_townhall_range'][passnum]) # note: may be None/null
                if id: break
        else:
            raise Exception('unknown ladder_match_by method '+gamedata['matchmaking']['ladder_match_by'])
        return id

    @admin_stats.measure_latency('is_suitable_ladder_match')
    def is_suitable_ladder_match(self, other_id):
        if gamedata['anti_bullying']['enable_ladder_fatigue'] and self.cooldown_active('ladder_fatigue:%d' % other_id): return False
        if is_ai_user_id_range(other_id): return True

        data_list = gamesite.pcache_client.player_cache_lookup_batch([other_id],
                                                                     fields = ['player_level', 'LOCK_STATE', 'protection_end_time',
                                                                               'ladder_player', 'home_region', 'base_damage', 'base_repair_time',
                                                                               'lootable_buildings', 'tutorial_complete', gamedata['townhall']+'_level'],
                                                                     reason = '_is_suitable_ladder_match')
        if gamedata['server']['log_ladder_pvp'] >= 3:
            gamesite.exception_log.event(server_time, 'is_suitable_ladder_match: %d checking %d: %s' % \
                                         (self.user_id, other_id, repr(data_list)))

        if not data_list or len(data_list) < 1: return False
        data = data_list[0]

        if (not self.in_attackable_level_range(data.get('player_level',1), mode = 'ladder')): return False
        if (not gamedata['predicate_library']['pvp_requirement']['predicate'].startswith('ALWAYS_')):
            if (not data.get('pvp_player',0)): return False
        if (not gamedata.get('ladder_pvp', False)) and (not data.get('ladder_player',0)): return False
        if gamedata['matchmaking']['ladder_match_by'] == 'townhall' and (None not in gamedata['matchmaking']['ladder_match_townhall_range']):
            # level tolerance not implemented
            if data.get(gamedata['townhall']+'_level', 1) != self.get_townhall_level_fast(): return False
        if data.get('lootable_buildings',-1) < 1: return False
        if data.get('base_damage',1) >= gamedata['matchmaking']['ladder_win_damage']: return False
        if data.get('base_repair_time',-1) > server_time: return False
        if data.get('tutorial_complete',1) < 1: return False
        if data.get('protection_end_time',-1) > server_time: return False
        if data.get('LOCK_STATE',0) != 0: return False
        return True

    @classmethod
    def create_ladder_state_points_scaled_by_trophy_delta(cls, my_id, other_id, delta, tbl):
        ret = {'points': {'victory': {str(my_id): min(max(int(tbl['attacker_victory']['base'] + delta * tbl['attacker_victory']['delta']), tbl['attacker_victory']['min']), tbl['attacker_victory']['max']),
                                      str(other_id):     min(max(int(tbl['defender_victory']['base'] - delta * tbl['defender_victory']['delta']), tbl['defender_victory']['min']), tbl['defender_victory']['max'])},
                          'defeat': {str(my_id):  max(min(int(tbl['attacker_defeat']['base'] + delta * tbl['attacker_defeat']['delta']), tbl['attacker_defeat']['min']), tbl['attacker_defeat']['max']),
                                     str(other_id):      max(min(int(tbl['defender_defeat']['base'] - delta * tbl['defender_defeat']['delta']), tbl['defender_defeat']['min']), tbl['defender_defeat']['max']),
                                     }}}
        for FIELD in ('protection_based_on','victory_condition'):
            if FIELD in tbl:
                ret[FIELD] = tbl[FIELD]
        return ret

    def create_ladder_state_points_constant(self, other_id, tbl):
        ret = {'points': {'victory': {str(self.user_id): tbl['attacker_victory'],
                                      str(other_id): tbl['defender_victory']},
                          'defeat': {str(self.user_id): tbl['attacker_defeat'],
                                     str(other_id): tbl['defender_defeat']}}}
        for FIELD in ('protection_based_on','victory_condition'):
            if FIELD in tbl:
                ret[FIELD] = tbl[FIELD]
        return ret

    @classmethod
    def scale_ladder_state_points(cls, scale_points, ret_points):
        for outcome, data in ret_points.iteritems():
            for sid, incr in data.iteritems():
                if incr > 0:
                    incr = max(int(scale_points*incr), 1)
                elif incr < 0:
                    incr = min(-int(scale_points*-incr), -1)
                data[sid] = incr

    def create_ladder_state(self, other_id, other_player, scale_points = 1, on_map = False):
        if other_player and (not other_player.is_ai()) and (gamedata['matchmaking']['ladder_point_incr_by_trophies'] or on_map):
            delta = other_player.ladder_points() - self.ladder_points()
            tbl = gamedata['matchmaking']['ladder_point_on_map_table' if on_map else 'ladder_point_incr_by_trophies_table']
            ret = self.create_ladder_state_points_scaled_by_trophy_delta(self.user_id, other_id, delta, tbl)
            if on_map and self.home_region and (self.home_region in gamedata['regions']):
                scale_points *= gamedata['regions'][self.home_region].get('ladder_point_scale',1)
        else:
            if (other_player and other_player.is_ai()):
                tbl = gamedata['matchmaking']['ladder_point_incr_ai']
                for entry in gamedata['ai_bases_server']['ladder_pvp_bases']:
                    if entry['base_id'] == other_id:
                        tbl = entry.get('ladder_point_incr', tbl)
                        break
            else:
                tbl = gamedata['matchmaking']['ladder_point_incr']
            ret = self.create_ladder_state_points_constant(other_id, tbl)

        if scale_points != 1: self.scale_ladder_state_points(scale_points, ret['points'])
        return ret

    def num_quarries_controlled(self):
        if not self.home_region or not gamesite.nosql_client: return 0
        result = list(gamesite.nosql_client.get_map_features_by_landlord_and_type(self.home_region, self.user_id, 'quarry', reason='num_quarries_controlled'))
        return len(result)

    def is_pvp_player(self):
        return self.is_ai() or Predicates.read_predicate({'predicate':'LIBRARY', 'name':'pvp_requirement'}).is_satisfied(self, None)

    def is_ladder_player(self, ignore_global = False):
        if (not self.is_pvp_player()): return False
        if (not ignore_global) and gamedata.get('ladder_pvp',False): return True
        return bool(self.home_region and (self.home_region in gamedata['regions']) and gamedata['regions'][self.home_region].get('ladder_pvp',False))

    def is_legacy_pvp_player(self, ignore_global = False):
        if (not self.is_pvp_player()): return False
        if (not ignore_global):
            if ('legacy_pvp' in gamedata) and (not gamedata['legacy_pvp']): return False
        if (self.home_region and (self.home_region in gamedata['regions']) and (not gamedata['regions'][self.home_region].get('legacy_pvp',True))): return False
        return True

    def make_alliance_sticky(self, alliance_id):
        if alliance_id > 0 and gamedata['server']['alliance_stickiness'] > 0:
            self.cooldown_trigger('alliance_sticky:%d'%alliance_id, gamedata['server']['alliance_stickiness'])
    def get_sticky_alliances(self):
        if gamedata['server']['alliance_stickiness'] < 0: return []
        ret = []
        for key, val in self.cooldowns.iteritems():
            if key.startswith('alliance_sticky:') and val['end'] > server_time:
                ret.append(int(key.split(':')[1]))
        return ret

    def is_same_alliance(self, other_player_id):
        if gamesite.sql_client:
            my_alliance_id, other_alliance_id = gamesite.sql_client.get_users_alliance([self.user_id, other_player_id], reason = 'is_same_alliance')
            if my_alliance_id > 0 and my_alliance_id == other_alliance_id:
                return True
        return False

    def is_same_alliance_sticky(self, other_player):
        # check if same alliance, and at the same time, establish stickiness
        my_alliance_id, other_alliance_id = gamesite.sql_client.get_users_alliance([self.user_id, other_player.user_id], reason = 'is_same_alliance_sticky')
        if my_alliance_id > 0:
            self.make_alliance_sticky(my_alliance_id)
        my_alliances = set(self.get_sticky_alliances())
        other_alliances = set(other_player.get_sticky_alliances())
        if my_alliance_id > 0: my_alliances.add(my_alliance_id)
        if other_alliance_id > 0: other_alliances.add(other_alliance_id)
        return bool(my_alliances.intersection(other_alliances)), my_alliances, other_alliances

    def can_spy_despite_map_violation(self, self_user, other_player_id, other_social_id):
        if gamedata['ladder_pvp']: return True # no regional map
        if self.is_developer(): return True
        if self_user.is_friends_with(other_social_id): return True
        if self.is_same_alliance(other_player_id): return True
        return False

    def can_spy_on_home(self, self_user, dest_player, dest_social_id, new_ladder_state, new_deployable_squads):
        if (dest_player is self) or dest_player.is_ai(): return (True, None)
        if new_ladder_state or self.can_take_ladder_revenge(dest_player): return (True, None)
        if self.is_legacy_pvp_player() and (not dest_player.is_legacy_pvp_player()):
            if (not self.can_spy_despite_map_violation(self_user, dest_player.user_id, dest_social_id)):
                return (False, "CANNOT_SPY_MAP_THEM")
        elif (not self.is_legacy_pvp_player()) and dest_player.is_legacy_pvp_player():
            if (not self.can_spy_despite_map_violation(self_user, dest_player.user_id, dest_social_id)):
                return (False, "CANNOT_SPY_MAP_YOU")
        elif (not self.is_legacy_pvp_player()) and (not dest_player.is_legacy_pvp_player()) and \
             ((len(new_deployable_squads) < 1) or (len(new_deployable_squads) == 1 and new_deployable_squads.values()[0]['squad_id']==SQUAD_IDS.BASE_DEFENDERS)):
            # cannot use session.using_squad_deployment() because we haven't set session.deployable_squads yet
            if (not self.can_spy_despite_map_violation(self_user, dest_player.user_id, dest_social_id)):
                return (False, "CANNOT_SPY_MAP_BOTH")
        return (True, None)

    def can_take_ladder_revenge(self, other_player):
        return self.is_ladder_player() and other_player.is_ladder_player() and (not other_player.is_ai()) and \
               self.cooldown_active('revenge_defender:%d' % other_player.user_id) and \
               other_player.my_home.calc_base_damage() < gamedata['matchmaking']['ladder_win_damage']

    def can_ladder_battle_on_map(self, other_player):
        if (not ((self.home_region in gamedata['regions']) and \
                 ('ladder_on_map_if' in gamedata['regions'][self.home_region]) and \
                 Predicates.read_predicate(gamedata['regions'][self.home_region]['ladder_on_map_if']).is_satisfied(self, None))): return False
        if other_player.has_damage_protection(): return False
        apply_level_limit = True
        if (self.home_region in gamedata['regions']) and (not gamedata['regions'][self.home_region].get('enable_pvp_level_gap', True)):
            apply_level_limit = False
        if apply_level_limit and \
           (not self.in_attackable_level_range(other_player.level(), mode = 'default')) and \
           (not self.cooldown_active('revenge_defender:%d' % other_player.user_id)): return False
        if self.cooldown_active('ladder_fatigue:%d' % other_player.user_id): return False
        if other_player.my_home.calc_base_damage() >= gamedata['matchmaking']['ladder_win_damage']: return False
        if self.is_same_alliance_sticky(other_player)[0]: return False
        if self.is_alt_account_unladderable(other_player.user_id): return False
        if (self.home_region in gamedata['regions']) and \
           ('ladder_on_map_if_defender' in gamedata['regions'][self.home_region]) and \
           (not Predicates.read_predicate(gamedata['regions'][self.home_region]['ladder_on_map_if_defender']).is_satisfied(other_player, None)): return False
        return True

    def get_pvp_balance(self, other_player, base):
        if other_player is self: return None
        if other_player.is_ai(): return None
        my_level = self.resources.player_level
        his_level = other_player.resources.player_level

        my_level_range = self.attackable_level_range()

        if gamedata['prevent_same_alliance_attacks'] and \
           self.is_same_alliance(other_player.user_id):
            return 'same_alliance'

        elif (base is not other_player.my_home):
            # quarry/squad - no limit

            # but, if enemy is stronger AND a new revenge allowance is going to be created, then warn!
            if my_level < other_player.attackable_level_range()[0] and \
               (not self.cooldown_active('revenge_attacker:%d' % other_player.user_id)) and \
               ((base.base_type == 'squad' and other_player.squads_affect_revenge()) or \
                (base.base_type == 'quarry' and other_player.quarries_affect_revenge())):
                return 'enemy' # allow attack, but warn

            return None

        elif (self.home_region in gamedata['regions']) and (not gamedata['regions'][self.home_region].get('enable_pvp_level_gap', True)):
            # region has no limits
            return None

        elif (gamedata['matchmaking']['revenge_time'] > 0) and self.cooldown_active('revenge_defender:%d' % other_player.user_id):
            # revenge - no limit
            return None

        elif (my_level_range[0]>=0) and (his_level < my_level_range[0]):
            # we are much stronger
            return 'player'

        elif (my_level_range[1]>=0) and (his_level > my_level_range[1]):
            # we are much weaker - prevent attack
            return 'enemy_strict'

        elif my_level < other_player.attackable_level_range()[0]:
            # we are much weaker - allow attack, but warn
            return 'enemy'

        else:
            # equal strength
            return None

    def ladder_point_decay_check(self, session, base_damage = None, base_repair_time = None):
        if base_damage is not None: assert base_repair_time is not None # must be given together

        mode = gamedata['matchmaking'].get('ladder_point_decay_mode', 'damage')
        assert mode in ('damage', 'protection')
        pred = gamedata['matchmaking'].get('ladder_point_decay_if', None)
        pred_ok = (pred and Predicates.read_predicate(pred).is_satisfied(self, None))

        # apply effects of existing decay aura
        if pred_ok:
            for aura in self.player_auras_iter_const():
                if aura['spec'] == 'trophy_pvp_decay':
                    elapsed = server_time - aura['start_time']
                    # note: aura['end_time'] may be -1 or missing for damaged-and-not-yet-repairing bases

                    # legacy compatibility
                    if ('data' in aura) and aura['data'].get('base_repair_time',-1) >= aura['start_time']:
                        elapsed = min(elapsed, aura['data']['base_repair_time'] - aura['start_time'])

                    # limit by end_time
                    elif aura.get('end_time',-1) >= server_time and aura['end_time'] >= aura['start_time']:
                        elapsed = min(elapsed, aura['end_time'] - aura['start_time'])

                    if elapsed > 0:
                        # exponential decay constant
                        decay_k = -math.log(2)/gamedata['matchmaking'].get('ladder_point_decay_halflife', 86400)
                        self.modify_scores({'trophies_pvp':0}, method = 'decay', trophy_decay_k = decay_k, trophy_decay_elapsed = elapsed, reason = 'ladder_point_decay_check')
                        aura['start_time'] += elapsed # reset start time

        # check if decay aura should be applied
        decay = False
        end_time = -1

        if pred_ok:
            if mode == 'damage':
                if base_damage is None:
                    base_damage, base_repair_time = self.my_home.calc_base_damage_and_repair_time()
                if base_damage >= gamedata['matchmaking']['ladder_win_damage']:
                    decay = True; end_time = base_repair_time
            elif mode == 'protection':
                decay = self.has_damage_protection(); end_time = self.resources.protection_end_time

        if decay:
            if self.apply_aura('trophy_pvp_decay', duration = (end_time - server_time) if (end_time > 0) else -1, ignore_limit = True):
                session.deferred_player_auras_update = True
        else:
            if self.remove_aura('trophy_pvp_decay', force = True):
                session.deferred_player_auras_update = True

    def apply_alliance_leave_point_loss(self, alliance_ui_name):
        fraction = Predicates.eval_cond_or_literal(gamedata['matchmaking'].get('alliance_leave_point_loss',0), None, self)
        if fraction <= 0: return 0
        cur_points = self.ladder_points()
        loss = int(fraction * cur_points)
        if loss <= 0: return 0
        self.modify_scores({'trophies_pvp':-loss}, reason = 'alliance_leave_point_loss')
        self.mailbox_append(self.make_system_mail(gamedata['strings']['alliance_leave_point_loss_mail'],
                                                  replacements = {'%LOSS': '%d' % loss,
                                                                  '%ALLIANCE_NAME': alliance_ui_name}))
        return loss

    def unit_donation_enabled(self):
        return self.get_any_abtest_value('enable_unit_donation', gamedata['enable_unit_donation'])

    def alliance_help_enabled(self):
        return Predicates.eval_cond_or_literal(self.get_territory_setting('enable_alliance_help'), None, self)

    def make_donated_unit(self, specname, level = None):
        # generate bogus ID, ensuring this won't be written to MongoDB
        obj_id = 'DONATED-'+gamesite.nosql_id_generator.generate()
        ret = {'obj_id': obj_id, 'spec': specname, 'source':'donated'}
        if level is not None: ret['level'] = level
        return ret

    def add_donated_unit(self, *args, **kwargs):
        new_entry = self.make_donated_unit(*args, **kwargs)
        self.donated_units[new_entry['obj_id']] = new_entry

    def donated_units_space(self):
        consumes_space = 0
        for item in self.donated_units.itervalues():
            stack = item.get('stack',1)
            consumes_space += stack * GameObjectSpec.get_leveled_quantity(gamedata['units'][item['spec']]['consumes_space'], item.get('level',1))
        return consumes_space

    # this awkwardly has to work in the PlayerTable.parse() code by mutating the player and then returning the argument, to be assigned again
    def load_tech_and_init_stattab(self, observer, tech):
        self.tech = tech
        self.recalc_stattab(observer, None)
        return tech
    def load_auras_and_init_stattab(self, observer, auras):
        self.player_auras = auras
        self.recalc_stattab(observer, None)
        return auras

    def recalc_stattab(self, observer, viewing_base):
        self.stattab = Player.Stattab(self, observer, viewing_base)

    # stattab is a cache of the values that can be affected by the player's tech and auras
    # not persistent, this is regenerated dynamically
    class Stattab (AbstractPlayer.AbstractStattab):
        RESURRECT_NEVER = 1
        RESURRECT_AND_REPAIR_WITH_TECH = 2
        RESURRECT_AND_REPAIR_ALWAYS = 10

        def apply_modstat_to_player(self, stat, method, strength, kind, source, props = None):
            assert stat in self.player_stats
            self.player_stats[stat] = ModChain.add_mod(self.player_stats[stat], method, strength, kind, source, props)

        def apply_modstat_to_building(self, obj, stat, method, strength, kind, source, props = None):
            if stat not in obj.modstats:
                base_value = ModChain.get_base_value(stat, obj.spec, obj.level)
                obj.modstats[stat] = ModChain.make_chain(base_value, {'level':obj.level})
            obj.modstats[stat] = ModChain.add_mod(obj.modstats[stat], method, strength, kind, source, props)
            self.modded_buildings[obj.obj_id] = obj

            # manufacturing-related stats need to flow through transitively to the units this building can work on
            if obj.spec.manufacture_category and (stat in ('unit_repair_speed', 'unit_repair_cost',
                                                           'manufacture_speed', 'manufacture_cost')):
                self.apply_modstat_to_manufacture_category(obj.spec.manufacture_category, {'unit_repair_speed':'repair_speed',
                                                                                           'unit_repair_cost':'repair_cost'}.get(stat,stat), method,
                                                           strength, kind, source, props = props)

        # apply modstat to all units in a specific manufacture category
        # category can be "ALL" to apply to all (unlocked) units
        def apply_modstat_to_manufacture_category(self, category, stat, method, strength, kind, source, props = None):
            for unit_name, unit_spec in gamedata['units'].iteritems():
                if (category == 'ALL') or (unit_spec['manufacture_category'] == category):
                    if (self.player.is_ai() or self.player.tech.get(unit_spec['level_determined_by_tech'],0) > 0) or (stat == 'resurrection'): # special case
                        self.apply_modstat_to_unit(unit_name, stat, method, strength, kind, source, props)

        def apply_modstat_to_unit(self, specname, stat, method, strength, kind, source, props = None):
            if specname not in self.units:
                self.units[specname] = {}
            if stat not in self.units[specname]:
                spec = self.observer.get_abtest_spec(GameObjectSpec, specname)
                prod_level = self.player.tech.get(spec.level_determined_by_tech, 1)
                base_value = ModChain.get_base_value(stat, spec, prod_level)
                self.units[specname][stat] = ModChain.make_chain(base_value, {'level':prod_level})
            self.units[specname][stat] = ModChain.add_mod(self.units[specname][stat], method, strength, kind, source, props)

        def add_set_item(self, item_spec):
            if not item_spec: return
            set_name = item_spec.get('item_set', None)
            if not set_name: return
            if set_name not in self.item_sets: self.item_sets[set_name] = set()
            self.item_sets[set_name].add(item_spec.get('item_set_member', item_spec['name']))

            # apply set-bonus aura
            set_spec = gamedata['item_sets'][set_name]
            if 'bonus_aura' in set_spec:
                has_n = len(self.item_sets[set_name])
                aura_name = set_spec['bonus_aura'][has_n-1]
                if aura_name and (aura_name in gamedata['auras']):
                    self.player.do_apply_aura(aura_name, ignore_limit = True) # stack = has_n?

        # we have to modify get_leveled_quantity() since "concat" values are lists
        @staticmethod
        def get_modstat_strength(effect, level):
            if effect['method'] == 'concat':
                assert type(effect['strength']) is list and len(effect['strength']) >= 1
                if type(effect['strength'][0]) is not list:
                    return effect['strength']
                else:
                    return GameObjectSpec.get_leveled_quantity(effect['strength'], level)
            else:
                return GameObjectSpec.get_leveled_quantity(effect['strength'], level)

        def __init__(self, player, observer, viewing_base):

            # normally, stuff in player.my_home always affects the stattab
            # if we are attacking a base with (not deployment_allowed), then disable effects from player.my_home and auras/tech/etc
            if viewing_base and \
               (viewing_base.base_landlord_id != player.user_id) and \
               (not viewing_base.deployment_allowed):
                enable_home_effects = False
            else:
                enable_home_effects = True

            # and sometimes, we additionally include effects from the viewing_base (if it's friendly to the player)
            if viewing_base and \
               (viewing_base is not player.my_home) and \
               (viewing_base.base_landlord_id == player.user_id) and \
               (player.is_ai() or viewing_base.base_type == 'quarry'): # should work for non-quarries too, but there is no game content using this yet
                additional_base = viewing_base
            else:
                additional_base = None

            # iterator for all the base objects we need to check for stattab effects
            base_iterator = itertools.chain(player.my_home.iter_objects() if enable_home_effects else [],
                                            additional_base.iter_objects() if additional_base else [])

            self.modded_buildings = {}
            self.aura_changed_objects = {}
            self.state_changed_buildings = set()

            self.units = {}
            self.player_stats = {
                'foreman_speed': ModChain.make_chain(1),
                'loot_factor_pvp': ModChain.make_chain(1),
                'loot_factor_pve': ModChain.make_chain(1),
                'loot_factor_tokens': ModChain.make_chain(1),
                'quarry_yield_bonus': ModChain.make_chain(1),
                'turf_quarry_yield_bonus': ModChain.make_chain(1),
                'travel_speed': ModChain.make_chain(1),
                'combat_time_scale': ModChain.make_chain(1),
                'chat_template': ModChain.make_chain('default'),
                'chat_gagged': ModChain.make_chain(0)
                }
            self.item_sets = {}
            self.limited_equipped = {}

            self.player = player
            self.player.stattab = self # must set immediately here so that predicates will work below

            self.observer = observer # A/B test observer

            self.player.prune_player_auras(is_recalc_stattab = True)

            # check for item set completion
            for item in self.player.equipped_item_iter(self.player.my_home):
                self.add_set_item(gamedata['items'].get(item['spec'], None))
            if gamedata['count_unequipped_items_in_sets']:
                for item in self.player.stored_item_iter():
                    self.add_set_item(gamedata['items'].get(item['spec'], None))

            # clear out building modstats and calculate effects of local building equipment
            for obj in base_iterator:
                if obj.is_building():
                    # reset modstats
                    if obj.modstats: obj.modstats = {}
                    if ((not obj.spec.worth_less_xp) or obj.spec.equip_slots):

                        # apply local building permanent_modstats
                        if obj.spec.permanent_modstats:
                            pmlist = obj.spec.permanent_modstats
                            if len(pmlist) >= 1 and (isinstance(pmlist[0], list) or pmlist[0] is None):
                                pmlist = obj.get_leveled_quantity(pmlist)
                            if pmlist:
                                for pm in pmlist:
                                    strength = self.get_modstat_strength(pm, obj.level)
                                    self.apply_modstat_to_building(obj, pm['stat'], pm['method'], strength, 'building', obj.spec.name, {'level':obj.level})

                        # apply local building equipment
                        for item in Equipment.equip_iter(obj.equipment):
                            if item['spec'] in gamedata['items']:
                                equip = gamedata['items'][item['spec']]
                                level = item.get('level', equip.get('level',1))
                                effects = equip['equip']['effects']
                                for i in xrange(len(effects)):
                                    effect = effects[i]
                                    if (not 'apply_if' in effect) or Predicates.read_predicate(effect['apply_if']).is_satisfied2(get_session_by_user_id(self.player.user_id), self.player, {'source_obj':obj}):
                                        if effect['code'] == 'modstat':
                                            strength = self.get_modstat_strength(effect, level)
                                            self.apply_modstat_to_building(obj, effect['stat'], effect['method'], strength, 'equipment', equip['name'], {'effect':i, 'level':level})
                                        elif effect['code'] == 'apply_player_aura':
                                            strength = GameObjectSpec.get_leveled_quantity(effect.get('aura_strength',1), level)
                                            if 'aura_level' in effect:
                                                aura_level = GameObjectSpec.get_leveled_quantity(effect.get('aura_level',1), level)
                                            else:
                                                aura_level = level # same level as item
                                            player.do_apply_aura(effect['aura_name'], strength = strength, duration = -1, level = aura_level,
                                                                 stack = effect.get('stack',-1), data = effect.get('data',None), ignore_limit = True)
                        # apply local building enhancements
                        if obj.enhancements:
                            for enh_name, enh_level in obj.enhancements.iteritems():
                                if enh_name not in gamedata['enhancements']: continue
                                enh_spec = observer.get_abtest_spec(EnhancementSpec, enh_name)
                                if enh_spec.effects:
                                    for i, effect in enumerate(enh_spec.effects):
                                        if effect['code'] == 'modstat':
                                            if (not 'apply_if' in effect) or Predicates.read_predicate(effect['apply_if']).is_satisfied2(get_session_by_user_id(self.player.user_id), self.player, {'source_obj':obj}):
                                                strength = self.get_modstat_strength(effect, enh_level)
                                                if effect.get('affects') == "player":
                                                    # apply to player for mechanical effect, AND to building for GUI stat display
                                                    self.apply_modstat_to_player(effect['stat'], effect['method'], strength, 'enhancement', enh_name, {'effect':i, 'level':enh_level})

                                                self.apply_modstat_to_building(obj, effect['stat'], effect['method'], strength, 'enhancement', enh_name, {'effect':i, 'level':enh_level})

            if enable_home_effects:
                # calculate effect of techs
                for tech_name, level in self.player.tech.iteritems():
                    if not tech_name: continue
                    if tech_name not in gamedata['tech']:
                        # skip unknown techs
                        if tech_name == 'anti_rover_mines':
                            continue # WSE mistake
                        if (not is_ai_user_id_range(self.player.user_id)) or (not tech_name.endswith('_anti_ice')):
                            gamesite.exception_log.event(server_time, 'player %d has unknown tech "%s", ignoring' % (self.player.user_id, tech_name))
                        continue

                    tech_spec = self.observer.get_abtest_spec(TechSpec, tech_name)
                    if tech_spec.effects:
                        for effect in tech_spec.effects:
                            if effect['code'] == 'modstat':
                                if (not 'apply_if' in effect) or Predicates.read_predicate(effect['apply_if']).is_satisfied(self.player, None):
                                    strength = self.get_modstat_strength(effect, level)
                                    if tech_spec.affects_unit:
                                        self.apply_modstat_to_unit(tech_spec.affects_unit, effect['stat'], effect['method'], strength, 'tech', tech_name, {'level':level})
                                    elif tech_spec.affects_manufacture_category:
                                        self.apply_modstat_to_manufacture_category(tech_spec.affects_manufacture_category, effect['stat'], effect['method'], strength, 'tech', tech_name, {'level':level})


                # calculate effects of unit equipment
                for name, equipment in self.player.unit_equipment.iteritems():
                    for item in Equipment.equip_iter(equipment):
                        item_spec = gamedata['items'].get(item['spec'], None)
                        if not item_spec or ('equip' not in item_spec): continue # skip invalid specs
                        effects = item_spec['equip']['effects']
                        level = item.get('level',1)
                        for i in xrange(len(effects)):
                            effect = effects[i]
                            if effect['code'] == 'modstat':
                                if (not 'apply_if' in effect) or Predicates.read_predicate(effect['apply_if']).is_satisfied(self.player, None):
                                    strength = self.get_modstat_strength(effect, level)
                                    self.apply_modstat_to_unit(name, effect['stat'], effect['method'], strength, 'equipment', item_spec['name'], {'effect':i, 'level':level})

            self.quarry_control_limit = 0

            self.max_squads = 0 # max number of mobile squads NOT counting base_defenders or reserves
            self.max_deployed_squads = 0 # max number of deployed mobile squads
            self.max_deployed_raids = 0 # max number of deployed mobile squads that are raids
            self.raid_range_pvp = 0 # max raiding range for PvP
            self.raid_range_pve = 0 # max raiding range for PvE
            self.squad_space = 0 # max space for a mobile squad
            self.main_squad_space = 0 # max space for base_defenders
            self.total_space = 0 # max space for all of the player's units
            self.total_foremen = 0 # max number of foremen
            self.alliance_help_daily_limit = 1 # max number of times player can request alliance/clan help per day
            use_squads = player.squads_enabled()
            self.vault_res = dict((res, 0) for res in gamedata['resources']) # resname -> vault amount

            # calculate unit space and unit repair speeds
            # also look for and apply permanent auras
            for obj in player.home_base_iter():
                if obj.is_building() and (not obj.spec.worth_less_xp):
                    if use_squads:
                        self.max_squads += obj.get_leveled_quantity(obj.spec.provides_squads)
                        self.max_deployed_squads += obj.get_leveled_quantity(obj.spec.provides_deployed_squads)
                        self.max_deployed_raids += obj.get_leveled_quantity(obj.spec.provides_deployed_raids)
                        self.raid_range_pvp = max(self.raid_range_pvp, obj.get_leveled_quantity(obj.spec.raid_range_pvp))
                        self.raid_range_pve = max(self.raid_range_pve, obj.get_leveled_quantity(obj.spec.raid_range_pve))
                        self.squad_space += obj.get_leveled_quantity(obj.spec.provides_squad_space)
                        self.total_space += obj.get_leveled_quantity(obj.spec.provides_total_space)

                    self.main_squad_space += obj.get_leveled_quantity(obj.spec.provides_space)
                    self.alliance_help_daily_limit += obj.get_leveled_quantity(obj.spec.alliance_help_daily_limit)
                    if obj.spec.manufacture_category:
                        if obj.spec.unit_repair_speed:
                            self.apply_modstat_to_manufacture_category(obj.spec.manufacture_category, 'repair_speed', '*=(1+strength)',
                                                                       obj.get_stat('unit_repair_speed', obj.get_leveled_quantity(obj.spec.unit_repair_speed)) - 1.0,
                                                                       'building', obj.spec.name, {'level': obj.level})
                        if obj.spec.manufacture_speed:
                            self.apply_modstat_to_manufacture_category(obj.spec.manufacture_category, 'manufacture_speed', '*=(1+strength)',
                                                                       obj.get_stat('manufacture_speed', obj.get_leveled_quantity(obj.spec.manufacture_speed)) - 1.0,
                                                                       'building', obj.spec.name, {'level': obj.level})
                    self.quarry_control_limit += obj.get_leveled_quantity(obj.spec.provides_quarry_control)

                    self.total_foremen += obj.get_leveled_quantity(obj.spec.provides_foremen)

                    if obj.spec.provides_limited_equipped:
                        for tag, num in obj.spec.provides_limited_equipped.iteritems():
                            if tag not in self.limited_equipped: self.limited_equipped[tag] = 0
                            self.limited_equipped[tag] += obj.get_leveled_quantity(num)

                    for res in gamedata['resources']:
                        self.vault_res[res] += obj.get_leveled_quantity(getattr(obj.spec, 'vault_'+res))

                    if obj.auras is not None:
                        Aura.prune_auras(obj.auras, is_stattab_refresh = True)
                        if len(obj.auras) == 0: obj.auras = None

                    # do not look in obj.spec for permanent auras, since those are handled when the object is instantiated
                    permanent_auras = obj.get_stat('permanent_auras', None)
                    if permanent_auras:
                        if obj.auras is None: obj.auras = []
                        for data in permanent_auras:
                            Aura.apply_aura(obj.auras, data['aura_name'], data.get('aura_strength',1), range = data.get('aura_range',-1), from_stattab = True)
                            if obj.obj_id not in player.stattab.aura_changed_objects:
                                player.stattab.aura_changed_objects[obj.obj_id] = obj

            # even when squads are off, make sure total_space is enough for the whole of base defenders
            self.total_space = max(self.total_space, self.main_squad_space)

            # make sure that players always have at least one foreman, even in weird cases
            self.total_foremen = max(self.total_foremen, 1)

            self.player_stats['deployable_unit_space'] = ModChain.make_chain(int(self.main_squad_space * observer.get_any_abtest_value('deployable_unit_space', gamedata['deployable_unit_space'])))

            self.travel_speed = 1
            self.sandstorm_max = 0

            # calculate effects of player auras

            for aura in player.player_auras_iter_const():
                if aura['spec'] not in gamedata['auras']:
                    gamesite.exception_log.event(server_time, 'player %d has unrecognized aura %s' % (player.user_id, aura['spec']))
                    continue
                spec = gamedata['auras'][aura['spec']]
                if not spec.get('server', False): continue

                # disable effects from cancelable auras when enable_home_effects is off
                if (not enable_home_effects) and spec.get('cancelable', True): continue

                level = aura.get('level',1)

                if 'effects' in spec: # new-style auras
                    for effect in spec['effects']:
                        if ('apply_if' in effect) and (not Predicates.read_predicate(effect['apply_if']).is_satisfied(self.player, None)): continue
                        end_time = aura.get('end_time',-1)
                        if end_time > 0 or level != 1:
                            props = {}
                            if end_time > 0: props['end_time'] = end_time
                            if level != 1: props['level'] = level
                        else:
                            props = None

                        if effect['code'] == 'modstat':
                            # usually we get the strength from the aura, but optionally override from the effect spec
                            if 'strength_per_stack' in effect:
                                strength = effect['strength_per_stack']*aura.get('stack',1)
                            elif 'strength' in effect:
                                strength = self.get_modstat_strength(effect, level)
                            else:
                                strength = aura.get('strength',1)

                            affects_units = effect.get('affects_unit', spec.get('affects_unit', None))
                            if affects_units and type(affects_units) is not list:
                                affects_units = [affects_units,] # single unit

                            affects_buildings = effect.get('affects_building', spec.get('affects_building', None))
                            if affects_buildings and type(affects_buildings) is not list:
                                affects_buildings = [affects_buildings,]
                            affects_manufacture_category = effect.get('affects_manufacture_category', spec.get('affects_manufacture_category', None))
                            affects_kind = effect.get('affects_kind', spec.get('affects_kind', None))
                            affects = effect.get('affects', spec.get('affects', None))

                            if affects_units and ('ALL' in affects_units):
                                affects_units = None
                                affects_manufacture_category = 'ALL' # affect all units
                            if affects_kind in ('mobile','ALL'):
                                affects_manufacture_category = 'ALL' # affect all units

                            if affects_units:
                                for unit in affects_units:
                                    self.apply_modstat_to_unit(unit, effect['stat'], effect['method'], strength, 'aura', spec['name'], props)

                            if affects_buildings:
                                for obj in self.player.home_base_iter():
                                    if obj.is_building() and obj.spec.name in affects_buildings:
                                        self.apply_modstat_to_building(obj, effect['stat'], effect['method'], strength, 'aura', spec['name'], props)
                                        if obj.is_producer():
                                            obj.update_production(player, player.my_home.base_type, player.my_home.base_region, compute_power_factor(player.my_home.get_power_state()))
                                            self.state_changed_buildings.add(obj)

                            if affects_manufacture_category:
                                self.apply_modstat_to_manufacture_category(affects_manufacture_category, effect['stat'], effect['method'], strength, 'aura', spec['name'], props)
                            if affects_kind in ('building', 'ALL'):
                                # apply to all buildings (except worth-less-xp ones)
                                for obj in self.player.home_base_iter():
                                    if obj.is_building() and (not obj.spec.worth_less_xp):
                                        self.apply_modstat_to_building(obj, effect['stat'], effect['method'], strength, 'aura', spec['name'], props)

                            if affects == "player":
                                self.apply_modstat_to_player(effect['stat'], effect['method'], strength, 'aura', spec['name'], props)

                        # a few special-case codes for things that are not really player-visible modded stats
                        elif effect['code'] == 'hold_unit_space':
                            self.total_space -= aura.get('stack',1)
                            self.main_squad_space -= aura.get('stack',1)

                        elif effect['code'] == 'sandstorm_max':
                            self.sandstorm_max = 1

        def get_player_stat(self, stat):
            return ModChain.get_stat(self.player_stats[stat], None)
        def get_unit_stat(self, specname, stat, default_value):
            d = self.units.get(specname, None)
            if d:
                return ModChain.get_stat(d.get(stat, None), default_value)
            return default_value

        # subset of properties needed to resolve attacks remotely
        def serialize_for_squad(self):
            return {'quarry_control_limit': self.quarry_control_limit,
                    'player': dict((key, self.serialize_modchain_for_squad(val)) for key, val in self.player_stats.iteritems() \
                                   if key.startswith('loot_factor_')),
                    'units': dict((specname, dict((key, self.serialize_modchain_for_squad(val)) for key, val in unit_stats.iteritems())) \
                                  for specname, unit_stats in self.units.iteritems()),
                    }
        # drop everything except the final value
        def serialize_modchain_for_squad(self, chain): return {'val': chain['val']}

        def serialize(self):
            return {
                    'max_squads': self.max_squads,
                    'max_deployed_squads': self.max_deployed_squads,
                    'max_deployed_raids': self.max_deployed_raids,
                    'raid_range_pvp': self.raid_range_pvp,
                    'raid_range_pve': self.raid_range_pve,
                    'squad_space': self.squad_space,
                    'main_squad_space': self.main_squad_space,
                    'total_space': self.total_space,
                    'quarry_control_limit': self.quarry_control_limit,
                    'total_foremen': self.total_foremen,
                    'vault_res': copy.copy(self.vault_res),

                    'player': self.player_stats,
                    'units': self.units,
                    'buildings': dict([(obj.obj_id, obj.modstats) for obj in self.modded_buildings.itervalues()]),
                    'item_sets': dict([(name, len(val)) for name, val in self.item_sets.iteritems()]),
                    'limited_equipped': self.limited_equipped
                    }
        def send_update(self, session, retmsg):
            assert self.player in (session.player, session.viewing_player)
            retmsg.append(["PLAYER_STATTAB_UPDATE" if self.player is session.player else "ENEMY_STATTAB_UPDATE", self.serialize()])
            for obj in self.state_changed_buildings:
                if session.has_object(obj.obj_id):
                    retmsg.append(["OBJECT_STATE_UPDATE2", obj.serialize_state()])
            for obj in self.aura_changed_objects.itervalues():
                if session.has_object(obj.obj_id):
                    retmsg.append(["OBJECT_AURAS_UPDATE", obj.serialize_auras()])

    # raise the level/auras of all units affected by tech_name to the current tech level
    def update_unit_levels(self, observer, tech_name, session, retmsg):
        if not gamedata.get('update_unit_levels_on_tech_upgrade', True):
            return

        level = self.tech.get(tech_name, 1)
        for obj in self.home_base_iter():
            if obj.is_building() and obj.is_manufacturing():
                for item in obj.manuf_queue:
                    spec = self.get_abtest_spec(GameObjectSpec, item['spec_name'])
                    if spec.level_determined_by_tech == tech_name:
                        item['level'] = level
                session.deferred_object_state_updates.add(obj)
            elif obj.is_mobile():
                if obj.spec.level_determined_by_tech == tech_name:
                    obj.change_level(max(obj.level, level))
                    session.deferred_object_state_updates.add(obj)

    def space_required_for_units(self, units):
        total = 0
        for name, data in units.iteritems():
            if type(data) is int:
                qty = data
                min_level = 1
            else:
                qty = data.get('qty',1)
                min_level = data.get('min_level',1)

            spec = self.get_abtest_spec(GameObjectSpec, name)
            level = max(min_level, self.tech.get(spec.level_determined_by_tech, 1))
            space = spec.get_leveled_quantity(spec.consumes_space, level)
            total += qty * space
        return total

    # auto-level structures and units in the AI base relative to the progress of the human player passed in
    def auto_level_ai(self, human):
        cache = {} # cache of the levels to assign to each building (since computing them is slow)
        powerplants = [] # list of power-generating buildings
        to_remove = [] # list of objects to remove from the base

        # check every object in the base
        for obj in self.home_base_iter():

            # if "force_level" is found in the JSON, then use that level
            if obj.force_ai_level is not None:
                # set the object's level immediately
                obj.change_level(max(1, min(obj.force_ai_level, obj.spec.maxlevel)))
                continue

            level = -1

            # remember all powerplants
            if obj.get_leveled_quantity(obj.spec.provides_power) > 0:
                powerplants.append(obj)

            # check for this type of building in the ai_bases.json:auto_level tables
            # if found, then use the level from the table
            if obj.spec.name in gamedata['ai_bases_server']['auto_level']:
                ls = gamedata['ai_bases_server']['auto_level'][obj.spec.name]
                # note: table is indexed by the AI's "player_level"
                index = min(self.resources.player_level-1, len(ls)-1)
                level = ls[index]

            # for mobile units, set the level to one level below the player's own research level for this unit
            elif obj.is_mobile():
                tech_name = obj.spec.level_determined_by_tech
                if tech_name in human.tech and human.tech[tech_name] > 1:
                    level = human.tech[tech_name]-1

            elif obj.is_building():
                # for buildings, set the level to one level below the player's highest building of this type
                if obj.spec.name not in cache:
                    highest = -1
                    for h in human.home_base_iter():
                        if h.spec.name == obj.spec.name:
                            highest = max(highest, h.level)
                    if highest > 1:
                        cache[obj.spec.name] = highest-1
                    else:
                        cache[obj.spec.name] = -1
                level = cache[obj.spec.name]

            # set the object's level
            if level != -1:
                obj.change_level(max(1, min(level, obj.spec.maxlevel)))

        # remove any unwanted objects from the base
        for obj in to_remove:
            self.my_home.drop_object(obj)

        # now the buildings have been leveled up. The base might be in a low-power state!
        # automatically increase powerplant levels as necessary to make sure the base
        # is fully powered
        if len(powerplants) > 0:
            # while base does not have 100%+ power
            while compute_power_factor(self.my_home.get_power_state()) < 1:
                incr = False
                for obj in powerplants:
                    if obj.level >= obj.spec.maxlevel:
                        # can't go up any more levels
                        pass
                    else:
                        # increase the level of this powerplant by 1
                        incr = True
                        obj.change_level(obj.level+1)
                if not incr:
                    # no more powerplants to upgrade
                    break

    # new score system

    # which continent are we in (or which one would we be in, if we aren't on the map for some reason)
    def home_continent(self):
        if self.home_region and self.home_region in gamedata['regions']:
            return gamedata['regions'][self.home_region]['continent_id'] # map takes precedence

        # fall back to default assignment
        return Predicates.eval_cond_or_literal(gamedata['continent_assignment'], None, self) # predicates shouldn't need session access here

    # return space scope and location of the widest space the player should see on the leaderboard (continent or ALL)
    def scores2_wide_space(self):
        if self.leaderboard_override:
            if self.leaderboard_override.endswith('ALL'):
                return (Scores2.SPACE_ALL, Scores2.SPACE_ALL_LOC)
            elif self.leaderboard_override.endswith('continent'):
                cont = self.home_continent()
                assert cont
                return (Scores2.SPACE_CONTINENT, cont)
        elif gamedata['matchmaking'].get('scores2_wide_space','ALL') == 'continent':
            cont = self.home_continent()
            assert cont
            return (Scores2.SPACE_CONTINENT, cont)
        return (Scores2.SPACE_ALL, Scores2.SPACE_ALL_LOC)

    # return time/space location of the "master" PvP ladder point value that should be used for matchmaking and competition purposes
    def scores2_ladder_master_point(self):
        time_scope = {'week': Scores2.FREQ_WEEK, 'season': Scores2.FREQ_SEASON}[gamedata['matchmaking']['ladder_point_frequency']]
        time_loc = Scores2.make_time_coords(self.get_absolute_time(),
                                            SpinConfig.get_pvp_season(gamedata['matchmaking']['season_starts'], self.get_absolute_time()),
                                            SpinConfig.get_pvp_week(gamedata['matchmaking']['week_origin'], self.get_absolute_time()),
                                            SpinConfig.get_pvp_day(gamedata['matchmaking']['week_origin'], self.get_absolute_time()))[time_scope]
        space_scope, space_loc = self.scores2_wide_space()
        return Scores2.make_point(time_scope, time_loc, space_scope, space_loc)

    # translate client-side stat name and period to the precise server-side Scores2 (stat,(scope,loc)) coordinates for scores2 lookup
    def scores2_query_addr(self, client_name, period, region = None, time_loc = None):
        if period == 'week':
            time_scope = Scores2.FREQ_WEEK
            if time_loc is None:
                time_loc = SpinConfig.get_pvp_week(gamedata['matchmaking']['week_origin'], self.get_absolute_time())
        elif period == 'season':
            time_scope = Scores2.FREQ_SEASON
            if time_loc is None:
                time_loc = SpinConfig.get_pvp_season(gamedata['matchmaking']['season_starts'], self.get_absolute_time())
        elif period == 'ALL':
            time_scope = Scores2.FREQ_ALL
            time_loc = 0
        else: raise Exception('unhandled period '+period)

        entry = gamedata['leaderboard']['score_fields'].get(client_name, None)
        if region and entry and entry.get('region_specific', False) and entry.get('leaderboard_query_is_region_specific', True):
            space_scope = Scores2.SPACE_REGION
            space_loc = region
        else:
            space_scope, space_loc = self.scores2_wide_space()
        return (client_name, Scores2.make_point(time_scope, time_loc, space_scope, space_loc))

    # given a dictionary like {"time": ["week",300], "space": ["region", "sector201"], ... }
    # check whether player is allowed to query these particular axes coordinates in Scores2, and return the Scores2 query point if so
    # this is the more modern version of scores2_query_addr(), where the time/space coordinates are supplied by the client
    def scores2_query_point(self, axes, allow_cold_history = False):
        if not ('time' in axes and 'space' in axes and len(axes['time']) == 2 and len(axes['space']) == 2):
            return None # mal-formed axes

        time_scope, time_loc = axes['time']
        if time_scope == Scores2.FREQ_WEEK:
            if (not allow_cold_history) and abs(time_loc - SpinConfig.get_pvp_week(gamedata['matchmaking']['week_origin'], self.get_absolute_time())) >= 2:
                return None # too far from current time
        elif time_scope == Scores2.FREQ_SEASON:
            if (not allow_cold_history) and abs(time_loc - SpinConfig.get_pvp_season(gamedata['matchmaking']['season_starts'], self.get_absolute_time())) >= 2:
                return None # too far from current time
        elif time_scope == Scores2.FREQ_ALL:
            if time_loc != 0:
                return None # only the 0 coordinate is valid with FREQ_ALL

        space_scope, space_loc = axes['space']
        if space_scope == Scores2.SPACE_REGION:
            if space_loc not in gamedata['regions']:
                return None # non-existent region
        elif space_scope == Scores2.SPACE_CONTINENT:
            if space_loc != self.home_continent():
                return None # player is not in this continent
        elif space_scope == Scores2.SPACE_ALL:
            if space_loc != Scores2.SPACE_ALL_LOC:
                return None # invalid coordinate for SPACE_ALL

        # parse extra axes
        if 'challenge' in axes:
            if len(axes['challenge']) == 2 and axes['challenge'][0] == 'key':
                extra_axes = {'challenge': axes['challenge']}
            else:
                return None # mal-formed challenge coordinate
        else:
            extra_axes = None

        return Scores2.make_point(axes['time'][0], axes['time'][1], axes['space'][0], axes['space'][1], extra_axes)

    # increment score counters, where "stats" is like {"xp": 35, "trophies_pvp": -2, ...}
    # for extra axes, the "stats" value will be like "battle_duration": { ("challenge",   "key",      "skill_challenge:123"): 32.4 }
    #                                                stat name             extra axis    extra scope   extra loc            value
    # note, the scores2_to_sql script only accepts a single extra axis named "challenge"
    def modify_scores(self, stats, reason='', method = '+=', trophy_decay_k = 0, trophy_decay_elapsed = 0):
        time_coords = Scores2.make_time_coords(self.get_absolute_time(),
                                               SpinConfig.get_pvp_season(gamedata['matchmaking']['season_starts'], self.get_absolute_time()),
                                               SpinConfig.get_pvp_week(gamedata['matchmaking']['week_origin'], self.get_absolute_time()),
                                               SpinConfig.get_pvp_day(gamedata['matchmaking']['week_origin'], self.get_absolute_time()))

        # look for an ongoing stat tournament
        event_data = self.get_event_data('current_stat_tournament')
        if event_data:
            event_stat_name = event_data['stat']['name']
        else:
            event_stat_name = None

        any_changed = False

        for name, value in stats.iteritems():
            entry = gamedata['leaderboard']['score_fields'].get(name, None)
            if entry is None: # note: can be {}, in which case we use it
                continue # this stat not active in this game

            has_extra_axes = isinstance(value, dict)

            if name.startswith('trophies_'):
                assert not has_extra_axes
                kind = name[9:12]; assert kind in ('pve','pvp','pvv')
                floor = gamedata['trophy_floor'].get(kind,0)
                affects_alliance = True
                if trophy_decay_k != 0:
                    assert method == 'decay'
                    assert value == 0

                # first set the one point that represents our "master" trophies value, and read it back
                value = self.scores2.set_point(name, value, self.scores2_ladder_master_point(), method = method, floor = floor, decay_kt = trophy_decay_k * trophy_decay_elapsed, affects_alliance = affects_alliance)

                # then overwrite all other spaces/times with the same value
                if value is None: continue # nothing new was recorded - don't write zeros

                # record peak value in player history (for quests etc)
                dict_setmax(self.history, 'peak_trophies_'+kind, value)

                stat_method = '='
                space_coords = Scores2.make_space_coords(self.home_continent(), self.home_region) # do write personal regional score, but it won't get propagated to alliance

            else:
                floor = None
                affects_alliance = (name == event_stat_name) # record current stat tournament alliance scores
                # disable per-region scores if has_extra_axes
                space_coords = Scores2.make_space_coords(self.home_continent(), self.home_region if (not has_extra_axes) else None)
                stat_method = entry.get('method', method) # allow score_fields entry to override the aggregation method

            # parse extra axes
            if has_extra_axes:
                for extra, raw_value in value.iteritems():
                    assert isinstance(extra, tuple) and len(extra) == 3
                    #             axis:     [  scope,   loc  ]
                    extra_axes = {extra[0]: [extra[1], extra[2]]}
                    any_changed |= self.scores2.set(name, raw_value, time_coords, space_coords, method = stat_method, floor = floor, affects_alliance = affects_alliance,
                                                    extra_axes = extra_axes)
            else:
                any_changed |= self.scores2.set(name, value, time_coords, space_coords, method = stat_method, floor = floor, affects_alliance = affects_alliance)

        self.publish_scores(reason = 'modify_scores')
        return any_changed

    def publish_scores(self, alliance_id = None, reason=''):
        if self.history.get('scores2_migration',0) < SCORES2_MIGRATION_VERSION: return

        # force publish of all scores?
        do_all = self.history.get('scores2_publish_refresh',-1) < gamedata['server'].get('scores2_publish_refresh',-1)
        if do_all:
            it = self.scores2.all_iter()
            event_data = self.get_event_data('current_stat_tournament')
            if event_data:
                event_stat_name = event_data['stat']['name']
            else:
                event_stat_name = None
            it_a = filter(lambda x: x['stat'].startswith('trophies_') or x['stat'] == event_stat_name, it)
        else:
            it = self.scores2.dirty_iter()
            it_a = self.scores2.dirty_alliance_iter()

        reason = 'publish_scores(%s,%s)' % ('full' if do_all else 'incr', reason)

        if it:
            gamesite.mongo_scores2_client.player_scores2_write(self.user_id, it)

        if it_a:
            # recache alliance scores
            if alliance_id is None: alliance_id = gamesite.sql_client.get_users_alliance(self.user_id, reason = reason)
            if alliance_id > 0:
                self.update_alliance_score_cache2(alliance_id, it_a = it_a, reason = reason)

        self.scores2.dirty_clear()
        if do_all and gamedata['server'].get('scores2_publish_refresh',-1) >= 0:
            self.history['scores2_publish_refresh'] = server_time

        if (do_all or it or it_a) and (gamedata['server'].get('log_scores2',0) >= 3):
            gamesite.exception_log.event(server_time, 'player %d %s' % (self.user_id, reason))

    # this gets called when leaving/joining an alliance, to update affected scores
    def update_alliance_score_cache(self, alliance_id, alliance_info = None, reason=''):
        # scores1 API is obsolete now
        self.update_alliance_score_cache2(alliance_id, alliance_info = alliance_info, it_a = None, reason = reason)

    def update_alliance_score_cache2(self, alliance_id, alliance_info = None, it_a = None, reason=''):
        assert alliance_id > 0
        if self.history.get('scores2_migration',0) < SCORES2_MIGRATION_VERSION: return

        if it_a is None:
            # look for an ongoing stat tournament
            event_data = self.get_event_data('current_stat_tournament')
            if event_data:
                event_stat_name = event_data['stat']['name']
            else:
                event_stat_name = None
            it_a = filter(lambda item: item['stat'].startswith('trophies_') or (event_stat_name and (item['stat'] == event_stat_name)), self.scores2.all_iter())

        # do not cache alliance scores regionally
        if it_a:
            it_a = filter(lambda item: item['axes']['space'][0] != Scores2.SPACE_REGION, it_a)

        # do not perform weighted updates on historical scores, only presently-valid scores
        if it_a:
            current_time_coords = Scores2.make_time_coords(self.get_absolute_time(),
                                                           SpinConfig.get_pvp_season(gamedata['matchmaking']['season_starts'], self.get_absolute_time()),
                                                           SpinConfig.get_pvp_week(gamedata['matchmaking']['week_origin'], self.get_absolute_time()),
                                                           SpinConfig.get_pvp_day(gamedata['matchmaking']['week_origin'], self.get_absolute_time()))

            it_a = filter(lambda item: item['axes']['time'][1] >= current_time_coords[item['axes']['time'][0]], it_a)

        # restrict update to only alliance's designated continent
        if it_a:
            if alliance_info is None:
                alliance_info = gamesite.sql_client.get_alliance_info(alliance_id, reason = 'update_alliance_score_cache2')
            allow_continent = alliance_info.get('continent', None)
            it_a = filter(lambda item: item['axes']['space'][0] != Scores2.SPACE_CONTINENT or (allow_continent and item['axes']['space'][1] == allow_continent), it_a)

        if it_a:
            gamesite.mongo_scores2_client.alliance_scores2_update_weighted(alliance_id, it_a,
                                                                           gamedata['alliances']['trophy_weights'][0:gamedata['alliances']['max_members']],
                                                                           {'trophies_pvp':gamedata['trophy_display_offset']['pvp'],
                                                                            'trophies_pve':gamedata['trophy_display_offset']['pve'],
                                                                            'trophies_pvv':gamedata['trophy_display_offset'].get('pvv',0)},
                                                                           reason = reason)

    # after a battle, increment history/time series counters
    # works for both attacking and defending
    def increment_battle_statistics(self, opponent_id, summary):
        if summary['attacker_id'] == self.user_id:
            myrole = 'attacker'
            oprole = 'defender'
        elif summary['defender_id'] == self.user_id:
            myrole = 'defender'
            oprole = 'attacker'
        else:
            gamesite.exception_log.event(server_time, 'increment_battle_statistics: %d is neither defender %d nor attacker %d!' % \
                                         (self.user_id, summary['defender_id'], summary['attacker_id']))
            return

        opponent_type = 'ai' if summary.get(oprole+'_is_ai', False) else 'human'

        # update history counters/time series
        if myrole == 'attacker':
            record_player_metric(self, dict_increment, 'attacks_'+summary[myrole+'_outcome'], 1, time_series = False)
            record_player_metric(self, dict_increment, 'attacks_'+summary[myrole+'_outcome']+'_vs_'+opponent_type, 1, time_series = False)
        elif myrole == 'defender':
            if (('base_id' not in summary) or (summary['base_id'] == home_base_id(self.user_id))): # no quarries
                if opponent_type == 'human':
                    record_player_metric(self, dict_increment, 'attacks_suffered', 1) # note! only includes PvP, not PvE!
                elif opponent_type == 'ai':
                    record_player_metric(self, dict_increment, 'ai_attacks_suffered', 1)
                    if str(summary.get('attack_type','')).startswith('daily'):
                        record_player_metric(self, dict_increment, 'daily_attacks_suffered', 1)

        loot = summary.get('loot', {})

        # update loot/steal counters
        resc_total = 0
        loot_verb = '_looted' if (myrole == 'attacker') else '_stolen'
        loot_prep = '_from_' if (myrole == 'attacker') else '_by_'
        loot_type = '' if (myrole == 'attacker') else '_lost'

        for resc in gamedata['resources']:
            amount = loot.get(resc+loot_type,0)
            resc_total += amount
            record_player_metric(self, dict_increment, resc+loot_verb, amount, time_series = False)
            record_player_metric(self, dict_increment, resc+loot_verb+loot_prep+opponent_type, amount, time_series = False)
        record_player_metric(self, dict_increment, 'resources'+loot_verb, resc_total, time_series = False)
        record_player_metric(self, dict_increment, 'resources'+loot_verb+loot_prep+opponent_type, resc_total, time_series = False)

        # update unit/buildings kill/loss counters
        lost_verb = '_lost' if (myrole == 'attacker') else '_killed'
        killed_verb = '_killed' if (myrole == 'attacker') else '_lost'

        record_player_metric(self, dict_increment, 'units_killed', sum(loot.get('units'+killed_verb, {}).itervalues()), time_series = False)
        record_player_metric(self, dict_increment, 'units_lost', sum(loot.get('units'+lost_verb, {}).itervalues()), time_series = False)

        for spec_name, count in loot.get('units'+killed_verb, {}).iteritems():
            record_player_metric(self, dict_increment, 'unit:'+spec_name+':killed', count, time_series = False)

        for spec_name, count in loot.get('units'+lost_verb, {}).iteritems():
            record_player_metric(self, dict_increment, 'unit:'+spec_name+':lost', count, time_series = False)

        for spec_name, count in loot.get('buildings'+killed_verb, {}).iteritems():
            record_player_metric(self, dict_increment, 'building:'+spec_name+':killed', count, time_series = False)
            if GameObjectSpec.exists(spec_name):
                spec = GameObjectSpec.lookup(spec_name)
                if spec.history_category:
                    record_player_metric(self, dict_increment, spec.history_category+'_killed', count, time_series = False)

        for spec_name, count in loot.get('buildings'+lost_verb, {}).iteritems():
            record_player_metric(self, dict_increment, 'building:'+spec_name+':lost', count, time_series = False)
            if GameObjectSpec.exists(spec_name):
                spec = GameObjectSpec.lookup(spec_name)
                if spec.history_category:
                    record_player_metric(self, dict_increment, spec.history_category+'_lost', count, time_series = False)


    # for legacy reasons, the data sent for "You've been attacked" messages is slightly different
    # from the battle history summary format. This converts from history summary to the you've-been-attacked format.
    @classmethod
    def battle_summary_to_recent_attack(cls, summary):
        ret = {'time':summary['time'],
               'attacker_user_id':summary['attacker_id'],
               'attacker_name':summary['attacker_name'],
               'attacker_level':summary['attacker_level'],
               'defender_outcome':summary['defender_outcome'],
               'base_id': summary['base_id'],
               'base_damage': summary.get('base_damage',0),
               'deployed_units': summary.get('deployed_units',{}),
               'lost_units':sum(summary['loot'].get('units_killed', {}).itervalues()),
               'killed_units':sum(summary['loot'].get('units_lost', {}).itervalues()),
               'defender_xp':summary['loot'].get('defender_xp', 0),
               'viewing_trophies_pvp':summary['loot'].get('viewing_trophies_pvp',0),
               'viewing_trophies_pvv':summary['loot'].get('viewing_trophies_pvv',0),
               'replay_version':summary.get('replay_version', None),

               # begin migration to unify player.recent_attacks to standard battle summary format
               'attacker_id': summary['attacker_id'],
               'loot': summary.get('loot',{}),
               'defender_id': summary['defender_id'],
               }
        for res in gamedata['resources']:
            ret['lost_'+res] = summary['loot'].get(res+'_lost',0)
            ret['killed_units_'+res] = summary['loot'].get('units_lost_'+res,0)

        for FIELD in ('defender_protection_expired_at',
                      'base_ncells',
                      'raid_mode',
                      # obsolete legacy fields, but still might be wanted by client
                      'attacker_facebook_id'):
            if FIELD in summary:
                ret[FIELD] = summary[FIELD]

        return ret

    def migrate_proxy(self):
        # migrate base_size from playerdb to basedb
        self.my_home.base_size = max(self.my_home.base_size, self.resources.OLD_base_size)

        # migrate scenery if regional map tile changed, or if young player's home climate no longer matches the default
        new_climate = None
        scenery_seed = None
        if self.is_human():
            if self.my_home.base_region:
                if self.my_home.base_region in gamedata['regions'] and self.my_home.base_map_loc:
                    region = Region(gamedata, self.my_home.base_region)
                    new_climate = region.read_climate_name(self.my_home.base_map_loc)
                    scenery_seed = self.user_id + self.my_home.base_map_loc[0] + region.dimensions()[0]*self.my_home.base_map_loc[1]
            else: # not on map yet
                if ('default_player_home_climate' in gamedata):
                    new_climate = gamedata['default_player_home_climate']
                    scenery_seed = self.user_id

        if new_climate and (self.my_home.base_climate != new_climate):
            self.my_home.base_climate = new_climate
            self.my_home.spawn_scenery(self, scenery_seed, overwrite = True)

        # fix bad techs
        if ('' in self.tech):
            del self.tech['']

        # donated_units list -> dict migration
        if type(self.donated_units) is list:
            new_donated_units = {}
            for entry in self.donated_units:
                for i in xrange(entry.get('stack',1)):
                    new_entry = self.make_donated_unit(entry['spec'], level = entry.get('level',None))
                    new_donated_units[new_entry['obj_id']] = new_entry
            self.donated_units = new_donated_units

        # do per-object migrations here
        to_delete = []
        for obj in self.home_base_iter():
            # destroy all repair droids
            if obj.is_mobile() and obj.spec.name == 'repair_droid':
                to_delete.append(obj)

            # remove invalid objects from manufacturing queues
            if obj.is_building() and obj.is_manufacturer():
                to_remove = []
                for item in obj.manuf_queue:
                    if item['spec_name'] not in gamedata['units']:
                        to_remove.append(item)
                for item in to_remove:
                    obj.manuf_queue.remove(item)

            if gamedata['server'].get('migrate_landmines_to_leveled_items', False) and not self.history.get('landmine_leveled_item_migrated', False):
                # only minefields need to be processed for mines
                if obj.is_building() and obj.is_minefield():
                    # equip values for armed mines get processed
                    if obj.is_minefield_armed() and '_L' in obj.minefield_item():
                        mine_level = int(obj.minefield_item()[obj.minefield_item().index('_L') + 2:]) # makes int from all characters after _L, which is mine level
                        mine_spec = obj.minefield_item()[:obj.minefield_item().index('_L')] # makes string from all characters before _L, which is mine spec
                        # last check ensures that new object is in the gamedata
                        if mine_spec in gamedata['items']:
                            obj.equipment['mine'][0] = {"spec": mine_spec, "level": mine_level} # replaces old mine with new mine
                    # if the minefield has a config value, it has to be checked item by item since config is an array
                    if obj.config:
                        for key in obj.config:
                            if isinstance(obj.config[key], dict) and 'spec' in obj.config[key] and 'mine_' in obj.config[key]['spec'] and '_L' in obj.config[key]['spec']:
                                mine_level = int(obj.config[key]['spec'][obj.config[key]['spec'].index('_L') + 2:]) # makes int from all characters after _L, which is mine level
                                mine_spec = obj.config[key]['spec'][:obj.config[key]['spec'].index('_L')] # makes string from all characters before _L, which is mine spec
                                if mine_spec in gamedata['items']:
                                    obj.config[key]['spec'] = mine_spec
                                    obj.config[key]['level'] = mine_level
                            elif (isinstance(obj.config[key], str) or isinstance(obj.config[key], unicode)) and 'mine_' in obj.config[key] and '_L' in obj.config[key]:
                                mine_level = int(obj.config[key][obj.config[key].index('_L') + 2:]) # makes int from all characters after _L, which is mine level
                                mine_spec = obj.config[key][:obj.config[key].index('_L')] # makes string from all characters before _L, which is mine spec
                                if mine_spec in gamedata['items']:
                                    obj.config[key] = {'spec':mine_spec, 'level':mine_level}

            if gamedata['server'].get('migrate_turrets_to_leveled_items', False) and not self.history.get('turret_leveled_item_migrated', False):
                # only turret emplacements need to be processed for turret heads
                if obj.is_building() and obj.is_emplacement():
                    if obj.is_emplacement_armed() and '_L' in obj.turret_head_item():
                        turret_level = int(obj.turret_head_item()[obj.turret_head_item().index('_L') + 2:]) # makes int from all characters after _L, which is turret level
                        turret_spec = obj.turret_head_item()[:obj.turret_head_item().index('_L')] # makes string from all characters before _L, which is turret spec
                        # last check ensures that new object is in the gamedata
                        if turret_spec in gamedata['items']:
                            obj.equipment['turret_head'][0] = {"spec": turret_spec, "level": turret_level} # replaces old turret with new mine

            # remove invalid recipes from crafting queues
            if obj.is_building() and obj.is_crafter() and obj.is_crafting():
                to_remove = []
                for entry in obj.crafting.queue:
                    if entry.craft_state['recipe'] not in gamedata['crafting']['recipes']:
                        if gamedata['server'].get('migrate_landmines_to_leveled_items', False) and not self.history.get('landmine_leveled_item_migrated', False) and 'make_mine_' in entry.craft_state['recipe'] and '_L' in entry.craft_state['recipe']:
                            recipe_level = int(entry.craft_state['recipe'][entry.craft_state['recipe'].index('_L') + 2:])
                            recipe_spec = entry.craft_state['recipe'][:entry.craft_state['recipe'].index('_L')]
                            if recipe_spec in gamedata['crafting']['recipes']:
                                entry.craft_state['recipe'] = recipe_spec
                                entry.craft_state['level'] = recipe_level
                            else:
                                to_remove.append(entry)
                        else:
                            to_remove.append(entry)
                if to_remove:
                    for entry in to_remove:
                        obj.crafting.queue.remove(entry)
                    if len(obj.crafting.queue) < 1:
                        obj.crafting = None
                    else:
                        # update times on other queued items
                        obj.halt_crafting(True)
                        obj.update_crafting(-1)

            # find any objects with invalid squad ids
            if obj.is_mobile() and SQUAD_IDS.is_mobile_squad_id(obj.squad_id) and (str(obj.squad_id) not in self.squads):
                self.unit_repair_cancel(obj)
                obj.squad_id = SQUAD_IDS.RESERVES # reassign to reserves

            # bring unit levels up to player tech level
            if obj.is_mobile(): obj.ensure_level(self.tech.get(obj.spec.level_determined_by_tech, 1))

        if (gamedata['server'].get('migrate_unit_equips_to_no_pct_name', False) and not self.history.get('unit_equips_to_no_pct_name_migrated', False)) or (gamedata['server'].get('migrate_unit_equips_to_no_pct_name_again', False) and not self.history.get('unit_equips_to_no_pct_name_migrated_again', False)):
            # legacy unit equips had their boost percentages hard-coded into their names. This migration replaces instances with new instances stripped of the pct value
            pct_detector = re.compile(r'_[0-9]+pct')
            for equipment in self.unit_equipment.itervalues():
                for slot_type in equipment:
                    for i in xrange(len(equipment[slot_type])):
                        if isinstance(equipment[slot_type][i], dict) and pct_detector.sub('', equipment[slot_type][i]['spec']) in gamedata['items']:
                            equipment[slot_type][i]['spec'] = pct_detector.sub('', equipment[slot_type][i]['spec'])
                        elif isinstance(equipment[slot_type][i], basestring) and pct_detector.sub('', equipment[slot_type][i]) in gamedata['items']:
                            equipment[slot_type][i] = pct_detector.sub('', equipment[slot_type][i])

            for item in self.inventory:
                if 'equip_L' in item['spec'] and 'pct' in item['spec'] and pct_detector.sub('', item['spec']) in gamedata['items']:
                    item['spec'] = pct_detector.sub('', item['spec'])

        # after stepping through all base objects, change migration history key if this is not done yet and it's a game that gets migrated
        if gamedata['server'].get('migrate_landmines_to_leveled_items', False) and not self.history.get('landmine_leveled_item_migrated', False):
            self.history['landmine_leveled_item_migrated'] = 1
        if gamedata['server'].get('migrate_turrets_to_leveled_items', False) and not self.history.get('turret_leveled_item_migrated', False):
            self.history['turret_leveled_item_migrated'] = 1
        if gamedata['server'].get('migrate_unit_equips_to_no_pct_name', False) and not self.history.get('unit_equips_to_no_pct_name_migrated', False):
            self.history['unit_equips_to_no_pct_name_migrated'] = 1
        if gamedata['server'].get('migrate_unit_equips_to_no_pct_name_again', False) and not self.history.get('unit_equips_to_no_pct_name_migrated_again', False):
            self.history['unit_equips_to_no_pct_name_migrated_again'] = 1
        if to_delete:
            for obj in to_delete:
                self.home_base_remove(obj)

        # unit_repair_queue migration
        give_free_repair = False
        to_remove = []

        # revise start/end times for units in the repair queue, to account for
        # specs that have changed while the player was logged out

        prev_finish_time = server_time - 2 # to allow finish_time to be equal to (server_time - 1) and still have a nonzero start-end interval

        for item in self.unit_repair_queue:
            if 'tag' in item:
                # legacy repair queue - just dump it all and give free repairs
                give_free_repair = True
                break

            obj = self.get_object_by_obj_id(item['obj_id'], fail_missing = False)
            if (not obj):
                to_remove.append(item)
                continue

            if gamedata['server'].get('rewrite_unit_repair_queue_on_login', True):
                progress = float(server_time - item['start_time'])/max(item['finish_time']-item['start_time'],1)
                progress = min(max(progress, 0.0), 1.0)
                obj.hp = int(item['original_hp'] + progress * (obj.max_hp-item['original_hp']) + 0.5)
                if obj.hp < obj.max_hp:
                    rep_time = obj.time_to_repair(self) # will be at least 1
                else:
                    rep_time = 0
                # rewrite repair queue entry as if it started at prev_finish_time with object at its current HP
                # note! finish_time-start_time must NOT be zero, since other code divides by it
                item['original_hp'] = obj.hp
                item['start_time'] = prev_finish_time
                item['finish_time'] = int(prev_finish_time + max(1,rep_time))
                # note: rep_time may be zero, and in that case we want prev_finish_time NOT to advance for the next entry
                prev_finish_time = int(prev_finish_time + rep_time)

        for item in to_remove:
            self.unit_repair_queue.remove(item)

        if give_free_repair:
            for obj in self.home_base_iter():
                if obj.is_mobile() and obj.owner is self:
                    obj.heal_to_full()
            self.unit_repair_queue = []

        self.migrate_scores2()

    # migrate score counters from the old player.history['score_xp_s3'] = 123 counters to the new Scores2 system
    def migrate_scores2(self):
        if self.is_ai(): return
        if self.history.get('scores2_migration',0) >= SCORES2_MIGRATION_VERSION: return

        creation_week = SpinConfig.get_pvp_week(gamedata['matchmaking']['week_origin'], self.creation_time)
        my_continent = self.home_continent()

        self.scores2.clear()

        for stat, data in gamedata['leaderboard']['score_fields'].iteritems(): # for each tracked legacy stat
            prefix = data.get('history_prefix', None)
            if prefix is None: continue # not present in history
            if stat.endswith('_global'): continue # these are computed by summing region-specific values

            if stat.startswith('trophies_'):
                affects_alliance = True
                space_accum = lambda x,y: max(x,y) # space accumulator - higher wins
                time_accum = lambda x,y: y # time accumulator - later wins
                # "tiebreaker" used when season and week aggregates disagree
                tiebreaker = lambda s,w: {'week':w, 'season':s}[gamedata['matchmaking']['ladder_point_frequency']] # tiebreaker - current frequency wins
            else:
                affects_alliance = False
                space_accum = lambda x,y: x+y # space accumulator - add
                time_accum = lambda x,y: x+y # time accumulator - add
                tiebreaker = lambda s,w: max(s,w) # tiebreaker - higher wins

            if data.get('region_specific', False):
                region_ids = gamedata['regions'].keys()
            else:
                region_ids = [None]

            # for each season
            region_total_s = {}
            total_s = 0
            for season in xrange(0, len(gamedata['matchmaking']['season_starts'])+1):
                season_total = 0
                for region_id in region_ids:
                    key = prefix + (('_%s' % region_id) if region_id else '') + ('_s%d' % season)
                    if self.history.get(key, 0) != 0:
                        season_total = space_accum(season_total, self.history[key])
                        total_s = time_accum(total_s, self.history[key])
                        if region_id:
                            region_total_s[region_id] = time_accum(region_total_s.get(region_id, 0), self.history[key])
                            # per-season / per-region
                            self.scores2.set(stat, self.history[key], {Scores2.FREQ_SEASON: season}, {Scores2.SPACE_REGION: region_id}, method = '=', affects_alliance = affects_alliance)
                if season_total != 0:
                    # per-season / all regions
                    if my_continent:
                        self.scores2.set(stat, season_total, {Scores2.FREQ_SEASON: season}, {Scores2.SPACE_CONTINENT: my_continent}, method = '=', affects_alliance = affects_alliance)
                    self.scores2.set(stat, season_total, {Scores2.FREQ_SEASON: season}, {Scores2.SPACE_ALL: Scores2.SPACE_ALL_LOC}, method = '=', affects_alliance = affects_alliance)

            # for each week
            region_total_w = {}
            total_w = 0
            for week in xrange(creation_week, SpinConfig.get_pvp_week(gamedata['matchmaking']['week_origin'], server_time)+1):
                week_total = 0
                for region_id in region_ids:
                    key = prefix + (('_%s' % region_id) if region_id else '') + ('_wk%d' % week)
                    if self.history.get(key, 0) != 0:
                        week_total = space_accum(week_total, self.history[key])
                        total_w = time_accum(total_w, self.history[key])
                        if region_id:
                            region_total_w[region_id] = time_accum(region_total_w.get(region_id, 0), self.history[key])
                            # per-week / per-region
                            self.scores2.set(stat, self.history[key], {Scores2.FREQ_WEEK: week}, {Scores2.SPACE_REGION: region_id}, method = '=', affects_alliance = affects_alliance)
                if week_total != 0:
                    # per-week / all regions
                    if my_continent:
                        self.scores2.set(stat, week_total, {Scores2.FREQ_WEEK: week}, {Scores2.SPACE_CONTINENT: my_continent}, method = '=', affects_alliance = affects_alliance)
                    self.scores2.set(stat, week_total, {Scores2.FREQ_WEEK: week}, {Scores2.SPACE_ALL: Scores2.SPACE_ALL_LOC}, method = '=', affects_alliance = affects_alliance)

            # all-time / per-region
            if data.get('region_specific', False):
                for region_id in region_ids:
                    s = region_total_s.get(region_id,0)
                    w = region_total_w.get(region_id,0)
                    if s != 0 or w != 0:
#                        if s != w and gamedata['server'].get('log_scores2',0) >= 2:
#                            gamesite.exception_log.event(server_time, 'player %d Scores2 migration: region %s stat %s s %d != w %d' % (self.user_id, region_id, stat, s, w))
                        self.scores2.set(stat, tiebreaker(s, w), {Scores2.FREQ_ALL: 0}, {Scores2.SPACE_REGION: region_id}, method = '=', affects_alliance = affects_alliance)

            # all-time / all regions
            if total_s != 0 or total_w != 0:
#                if total_s != total_w and gamedata['server'].get('log_scores2',0) >= 2:
#                    gamesite.exception_log.event(server_time, 'player %d Scores2 migration: stat %s total_s %d != total_w %d' % (self.user_id, stat, total_s, total_w))
                if my_continent:
                    self.scores2.set(stat, tiebreaker(total_s, total_w), {Scores2.FREQ_ALL: 0}, {Scores2.SPACE_CONTINENT: my_continent}, method = '=', affects_alliance = affects_alliance)
                self.scores2.set(stat, tiebreaker(total_s, total_w), {Scores2.FREQ_ALL: 0}, {Scores2.SPACE_ALL: Scores2.SPACE_ALL_LOC}, method = '=', affects_alliance = affects_alliance)

        if gamedata['server'].get('log_scores2',0) >= 3:
            msg = 'player %d Scores2 migration done' % self.user_id
            if gamedata['server'].get('log_scores2',0) >= 4:
                msg += ':\n%s' % ('\n'.join(map(lambda x: repr(x[1]), sorted(self.scores2.scores.items()))))
            gamesite.exception_log.event(server_time, msg)

        # note: if we're being loaded as a PvP opponent, this migration might happen more than once
        self.history['scores2_migration'] = SCORES2_MIGRATION_VERSION # mark as migrated

    def has_damage_protection(self): return self.resources.protection_end_time > server_time

    def set_protection_end_time(self, session, new_end_time, event_name, extra_event_props = None):
        old_end_time = self.resources.protection_end_time

        if event_name:
            props = {'prev_end_time': old_end_time, 'new_end_time': new_end_time, 'count': self.protection_attack_count}
            if new_end_time > server_time: props['prot_time'] = new_end_time - server_time
            if extra_event_props: props.update(extra_event_props)
            self.record_protection_event(event_name, props)

        self.resources.protection_end_time = new_end_time

        was_active = (old_end_time > server_time)
        is_active = (new_end_time > server_time)

        if was_active != is_active:
            self.protection_attack_count = 0

        # perform external updates
        is_changed = (was_active != is_active) or (is_active and (new_end_time != old_end_time))

        if is_changed and session:
            if self.prune_player_auras():
                session.send([["PLAYER_AURAS_UPDATE" if self is session.player else "ENEMY_AURAS_UPDATE", self.player_auras]])

            gamesite.pcache_client.player_cache_update(self.user_id, {'protection_end_time': new_end_time if new_end_time > server_time else None}, reason = 'set_protection_end_time')

            if self.is_on_map():
                gamesite.nosql_client.update_map_feature(self.my_home.base_region, self.my_home.base_id, {'protection_end_time': new_end_time if new_end_time > server_time else None}, reason = 'set_protection_end_time')

            if (self is session.player): # only run for connected player
                session.deferred_ladder_point_decay_check = True
                session.deferred_player_state_update = True
                session.deferred_stattab_update = True

    def record_protection_event(self, event_name, props):
        if not gamedata['server']['record_protection_history']: return

        # record in playerdb
        if 'protection_history' not in self.history: self.history['protection_history'] = []
        entry = props.copy()
        entry['event'] = event_name
        entry['time'] = server_time
        self.history['protection_history'].append(entry)
        max_age = gamedata['server'].get('record_protection_history_max_age', 30*24*60*60)
        self.history['protection_history'] = filter(lambda x: server_time - x.get('time',0) < max_age, self.history['protection_history'])

        # record metric event
        metric_props = props.copy()
        metric_props['sum'] = self.get_denormalized_summary_props('brief')
        if 'new_end_time' in props:
            if props['new_end_time'] > 0:
                metric_props['delta'] = props['new_end_time'] - max(props['prev_end_time'], server_time)
            else: # lost protection
                metric_props['delta'] = -1 * (max(props['prev_end_time'], server_time) - server_time)
        metric_event_coded(self.user_id, event_name, metric_props)

    def record_ladder_pvp_event(self, event_name, props):
        props['sum'] = self.get_denormalized_summary_props('brief')
        metric_event_coded(self.user_id, event_name, props)

    # log items entering or leaving player inventory
    # item_stack can be positive (item entering inventory) or negative (item exiting inventory)
    def inventory_log_event(self, event_name, item_specname, item_stack, expire_time, level=None, reason=None):
        if not event_name: return
        if item_stack == 0: return
        if not gamedata['server'].get('log_inventory', True): return
        props = {'spec': item_specname, 'stack': item_stack}
        if level is not None: props['level'] = level
        if expire_time and expire_time > 0: props['expire_time'] = expire_time
        if reason: props['reason'] = reason
        props['sum'] = self.get_denormalized_summary_props('brief')
        metric_event_coded(self.user_id, event_name, props)

    def send_fb_score_update(self, facebook_id, value):
        assert self.has_write_lock
        if (server_time - self.last_fb_score_update) < gamedata['fb_scores']['min_interval']:
            return
        if (not self.get_any_abtest_value('enable_fb_scores', gamedata['enable_fb_scores'])):
            return
        if gamedata['fb_scores'].get('check_permissions', True) and \
           (not (self.facebook_permissions and ('publish_actions' in self.facebook_permissions))):
            return

        self.last_fb_score_update = server_time
        params = {'score': str(value) }
        query = urllib.urlencode(params)
        url = SpinFacebook.versioned_graph_endpoint_secure('score', str(facebook_id)+'/scores')
        if SpinConfig.config['enable_facebook']:
            gamesite.AsyncHTTP_Facebook.queue_request(server_time, url, lambda result: None, method = 'POST', postdata = query, max_tries = 1)
        else:
            gamesite.exception_log.event(server_time, 'Facebook disabled: send_fb_score_update(POST %s query %s)' % (url, query))

    # return just enough data about this player to build a SQL summary table without referencing upcache
    def get_denormalized_summary_props(self, format):
        assert format == 'brief'
        ret = {'plat': self.frame_platform,
               'cc': self.get_townhall_level_fast(),
               'rcpt': self.history.get('money_spent', 0),
               'ct': self.country,
               'tier': self.country_tier}
        if self.developer: ret['developer'] = self.developer # also insert "developer" flag here in case ETL scripts want to ignore these
        return ret

    def alt_record_attack(self, other_id): pass

    def init_attack_defender(self, attacker_id, attacker_is_human, is_home_attack, ladder_state, is_revenge_attack):
        if attacker_is_human and is_home_attack:
            self.record_protection_event('3885_i_got_attacked',
                                         {'prev_end_time': self.resources.protection_end_time,
                                          'attacker_id': attacker_id,
                                          'ladder': bool(ladder_state)})
            if is_revenge_attack:
                record_player_metric(self, dict_increment, 'revenge_attacks_suffered', 1, time_series = False)

    def init_attack_attacker(self, defender_id, defender_is_human, is_home_attack, ladder_state, is_revenge_attack):
        if defender_is_human and is_home_attack:
            self.alt_record_attack(defender_id)
        self.attack_cooldown_start = server_time

        if gamedata['server'].get('track_battle_streaks',0) > 0:
            cd_list = ['battle_streak']
            if ladder_state:
                cd_list.append('battle_streak_ladder')
            for cd in cd_list:
                self.cooldown_trigger(cd, gamedata['server']['track_battle_streaks'], add_stack = 1)

        record_player_metric(self, dict_increment, 'attacks_launched', 1, time_series = False)
        record_player_metric(self, dict_increment, 'attacks_launched_vs_'+('human' if defender_is_human else 'ai'), 1, time_series = False)

        if defender_is_human and is_revenge_attack:
            record_player_metric(self, dict_increment, 'revenge_attacks_launched_vs_'+('human' if defender_is_human else 'ai'), 1, time_series = False)

    def mailbox_append(self, msg, safe_not_to_copy = False):
        if 'attachments' in msg:
            dict_increment(self.history, 'mail_attachments_received', len(msg['attachments']))
        if not (safe_not_to_copy):
            # nasty things happen when callers pass in references to gamedata (e.g. item tables get mutated)
            # so be safe by copying everything
            msg = copy.deepcopy(msg)
        msg['received_time'] = server_time

        if 'time' in msg:
            # message has a defined sending time: insert in sorted position
            time_list = [mail.get('time', server_time) for mail in self.mailbox]
            position = bisect.bisect_left(time_list, msg['time'])
            self.mailbox.insert(position, msg)
        else:
            # ensure a (send) "time" field is present, then stick it on the end
            msg['time'] = server_time
            self.mailbox.append(msg)

    # ugly API, needs rework
    def make_system_mail(self, template, duration = None, attachments = None, to_user_id = None, to_user_id_list = None,
                         extra_props = None, sent_time = None,
                         replace_s = '', replace_level = '', replace_time = '', replace_day = '', replacements = None):

        if to_user_id is None and to_user_id_list is None: to_user_id = self.user_id

        # the mail template can be passed in one of two forms:
        # NEW method: if it's a string, then it's the key for an entry in gamedata['strings'] (and thus allows localization)
        # OLD method: if it's a dict, then it's the entry itself (but cannot be localized)
        if isinstance(template, basestring):
            localized_strings = gamesite.get_localized_gamedata('strings', self.locale)
            if template in localized_strings:
                data = localized_strings[template]
            else:
                gamesite.exception_log.event(server_time, 'make_system_mail(): failed to find template %r in gamedata.strings' % template)
                return
        else:
            assert isinstance(template, dict)
            data = template

        # template_name refers to an entry in gamedata['strings']
        # "data" should be an entry in gamedata['strings']
        if duration is None:
            if 'expire_at' in data:
                duration = data['expire_at'] - server_time
            elif 'duration' in data:
                duration = data['duration']
            else:
                duration = 2*365*24*60*60

        ret = {'type':'mail',
               'msg_id': generate_mail_id(),
               'to': to_user_id_list if to_user_id_list is not None else [to_user_id]}
        if sent_time:
            ret['time'] = sent_time

        for src_key, dst_key in (('ui_from','from_name'), ('ui_subject','subject'), ('ui_body','body')):
            ret[dst_key] = data[src_key].replace('%s',replace_s).replace('%level',replace_level).replace('%time',replace_time).replace('%day',replace_day)
            if replacements:
                for k, v in replacements.iteritems():
                    ret[dst_key] = ret[dst_key].replace(k, v)

        if duration < 0:
            ret['expire_time'] = -1
        else:
            ret['expire_time'] = server_time + duration

        if attachments is not None:
            ret['attachments'] = attachments
        elif 'attachments' in data:
            ret['attachments'] = data['attachments']

        if 'attachments_loot_table' in data:
            ret['attachments_loot_table'] = data['attachments_loot_table']

        if 'on_receipt' in data:
            ret['on_receipt'] = data['on_receipt']

        for PRED in ('show_if', 'discard_if'):
            if PRED in data:
                ret[PRED] = data[PRED]

        if extra_props:
            for k, v in extra_props.iteritems():
                ret[k] = v
        return ret

# these are proxy "stubs" that represent players OTHER than the one playing the game
# (e.g., other players whose bases you visit or attack)

class ProxyPlayer(Player): pass

# LivePlayer is used for the "self" player that users are logged in as.
# By putting functions that should only be called for logged-in players here,
# we can catch any mistakes where an attempt is made to call them on
# non-logged-in players.

class LivePlayer(Player):
    def __init__(self, user_id):
        super(LivePlayer,self).__init__(user_id)

        # these fields are DUPLICATES of the corresponding User fields,
        # set during the login process.
        # necessary for evaluating predicates that depend on them
        self.browser_name = 'unknown'
        self.spin_client_platform = 'unknown'
        self.spin_client_vendor = 'unknown'
        self.spin_client_version = 0
        self.browser_os = 'unknown'
        self.browser_version = 'unknown'
        self.browser_hardware = 'unknown'
        self.browser_caps = {}

        # this is a "cross" pointer to the User's facebook likes,
        # added so that Predicates have access to them
        self.user_facebook_likes = None # set during login

        self.flash_offer = None # current offer we are giving the player (entry in gamedata['offers'], valid for the session only)
        self.reset()

    def reset(self):
        super(LivePlayer,self).reset()

        # developer access - ignore resource limits and time delays
        self.is_cheater = False

    def sync_with_user(self, user):
        super(LivePlayer,self).sync_with_user(user)
        # sync additional LivePlayer fields here
        self.browser_name = user.browser_name
        self.browser_os = user.browser_os
        self.browser_version = user.browser_version
        self.browser_hardware = user.browser_hardware
        self.browser_caps = user.browser_caps
        self.user_facebook_likes = user.facebook_likes
        self.spin_client_platform = user.spin_client_platform
        self.spin_client_vendor = user.spin_client_vendor
        self.spin_client_version = user.spin_client_version

    def ai_instance_generation_put(self, ai_id, gen, base_expiration_time):
        gen_expiration_time = server_time + gamedata['server'].get('ai_instance_generation_duration', 60)
        if base_expiration_time > 0:
            gen_expiration_time = min(gen_expiration_time, base_expiration_time)

        self.ai_instance_generations[str(ai_id)] = {'time': server_time, 'expire_time': gen_expiration_time, 'gen': gen}
    def ai_instance_generation_clear(self, ai_id):
        key = str(ai_id)
        if key in self.ai_instance_generations:
            del self.ai_instance_generations[key]
    def prune_ai_instance_generations(self):
        self.ai_instance_generations = dict(filter(lambda k_v: k_v[1]['expire_time'] > server_time,
                                                   self.ai_instance_generations.iteritems()))
    def ai_instance_generation_get(self, ai_id):
        # throw out expired entries while we do this
        self.prune_ai_instance_generations()
        key = str(ai_id)
        if key in self.ai_instance_generations:
            return self.ai_instance_generations[key]['gen']
        return -1

    def unit_repair_send(self, retmsg):
        retmsg.append(["UNIT_REPAIR_UPDATE", self.unit_repair_queue])

    def spawn_deposits(self, seed):
        if self.tutorial_state != "COMPLETE":
            # no deposits until tutorial is over
            return

        config = self.get_any_abtest_value('iron_deposits', gamedata['server']['iron_deposits'])
        if config['max'] < 1: return

        if self.last_iron_deposit < 1:
            num_to_spawn = 1
        else:
            num_to_spawn = int((server_time - self.last_iron_deposit)/config['interval'])

        # count number of deposits currently in base
        cur_deposits = sum([1 for obj in self.home_base_iter() if obj.spec.name == 'iron_deposit'])
        num_to_spawn = max(0, min(num_to_spawn, config['max']-cur_deposits))

        if num_to_spawn < 1:
            return

        self.last_iron_deposit = server_time

        # compute max res manually to include destroyed storage buildings
        max_res = max(self.get_max_storage().itervalues())
        specname = 'iron_deposit'
        spec = self.get_abtest_spec(GameObjectSpec, specname)

        randgen = random.Random(seed) # deterministic from the seed

        for i in range(num_to_spawn):
            ncells = self.my_home.ncells()
            iter = 0

            # rejection sampling for determining spawn location
            while True:
                x = int(randgen.random()*ncells[0])
                y = int(randgen.random()*ncells[1])
                if self.my_home.is_deposit_location_valid([x,y], spec.gridsize) or iter > 100:
                    break
                iter += 1

            metadata = {}
            max_pct = config['worth_range'][0]
            min_pct = config['worth_range'][1]
            amount = max(0, int(max_res * (min_pct + randgen.random() * (max_pct-min_pct))))
            if amount > 0:
                metadata['iron'] = amount

            if self.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks':
                contains_gamebucks = (randgen.random() < config['gamebucks_chance'])
                if contains_gamebucks:
                    gamebucks_amount = config['gamebucks_range'][0] + int(randgen.random() * (config['gamebucks_range'][1]-config['gamebucks_range'][0]))
                    if gamebucks_amount > 0:
                        metadata['gamebucks'] = gamebucks_amount

            newobj = instantiate_object_for_player(self, self, specname, x=x, y=y, metadata = metadata)
            self.home_base_add(newobj)

    # XXX this should probably be a member of Session rather than Player
    def give_quest_rewards(self, quest, session, retmsg):
        reward_res = dict((res,0) for res in gamedata['resources'])

        max_storage = self.get_max_storage()

        repeatable = hasattr(quest, "repeat_interval")
        if repeatable:
            ratio_ratio = self.get_any_abtest_value('daily_quest_reward_ratio', gamedata['daily_quest_reward_ratio'])
        else:
            ratio_ratio = 1.0

        has_ratio_reward = False
        for res in gamedata['resources']:
            if hasattr(quest, "reward_"+res):
                reward_res[res] += getattr(quest, "reward_"+res)
            if hasattr(quest, "reward_"+res+"_ratio"):
                has_ratio_reward = True
                amt = int(ratio_ratio * int(getattr(quest, "reward_"+res+"_ratio") * max_storage[res]))
                reward_res[res] += amt

        reward_res = self.resources.gain_res(reward_res, reason='quest_reward')
        if repeatable:
            econ_type = 'repeatable'
        else:
            econ_type = 'one_time_ratio' if has_ratio_reward else 'one_time_fixed'
        admin_stats.econ_flow_player(self, 'quests', econ_type, reward_res)

        reward_xp = 0

        if ('quest_reward_resources' in gamedata['player_xp']):
            # new formula, resource-based
            orig_rewards = sum((getattr(quest, 'reward_'+res, 0) for res in gamedata['resources']),0)
            reward_xp = int(gamedata['player_xp']['quest_reward_resources'] * orig_rewards)

        elif hasattr(quest, "reward_xp"):
            reward_xp = max(int(quest.reward_xp * gamedata['player_xp']['quests']), gamedata['player_xp']['quests_min'])

        self.resources.gain_xp(reward_xp, reason='quest_reward')

        if hasattr(quest, "reward_gamebucks"):
            self.resources.gain_gamebucks(quest.reward_gamebucks, reason='quest_reward')

        if hasattr(quest, "reward_consequent"):
            # awkward - needs to pass same parameters as the on_login_pre_hello consequent
            snap = self.resources.calc_snapshot()
            session.execute_consequent_safe(quest.reward_consequent, self, retmsg,
                                            {'max_inventory': snap.max_inventory(), 'cur_inventory': snap.cur_inventory(),
                                             'cur_gamebucks': snap.gamebucks,
                                             'largest_purchase': self.history.get('largest_purchase', 0),
                                             'largest_purchase_gamebucks': self.history.get('largest_purchase_gamebucks', 0)},
                                            reason='give_quest_rewards')

        new_objects = []

        if hasattr(quest, "reward_give_units"):
            new_objects += spawn_units(self, self.my_home, quest.reward_give_units, limit_break = True)

        if hasattr(quest, "reward_heal_all_units") and quest.reward_heal_all_units:
            session.heal_all_units(retmsg)
        if hasattr(quest, "reward_heal_all_buildings") and quest.reward_heal_all_buildings:
            session.heal_all_buildings(retmsg)

        return new_objects

    def send_history_update(self, retmsg):
        # filter out parts of player.history that are for metrics use only
        # only send the critical gameplay-relevant values to the client
        msg = dict(filter(lambda (k,v):
                          type(v) != list and \
                          type(v) != dict and \
                          ((':' not in k) or (k.startswith('feature_used')) or (k.startswith('item')) or \
                           (k.startswith('unit') and k.endswith('manufactured')) or \
                           (k.startswith('building') and k.endswith('killed'))
                           ) and \
                          (not k.startswith('score_')),
                          self.history.iteritems()))
        retmsg.append(["PLAYER_HISTORY_UPDATE", msg])

    def send_battle_history_update(self, retmsg):
        # send count of new battles since the last one the client acknowledged seeing
        if gamedata['server'].get('battle_history_source','nosql/sql') in ('nosql','nosql/sql'):
            # get summary data from database
            count = gamesite.nosql_client.battles_get_count(self.user_id, -1, -1, -1, time_range = [max(self.battle_history_seen+1, server_time - gamedata['server'].get('nosql_recent_attackers_time_limit',7*86400)), server_time],
                                                            ai_or_human = SpinNoSQL.NoSQLClient.BATTLES_ALL,
                                                            passive_only = True,
                                                            reason = 'send_battle_history_update')
            if count > 0:
                retmsg.append(["NEW_BATTLE_HISTORIES", count])

    def strip_fields_for_army_update(self, state):
        assert 'obj_id' in state
        if state.get('temporary', None): return None # don't persist temporary objects
        for field in state.keys():
            if field not in ('obj_id','spec','level','owner_id','squad_id','hp','max_hp','hp_ratio'):
                del state[field]
        return state

    def send_army_update_one(self, object, retmsg):
        assert object.owner is self
        assert object.is_mobile()
        if object.is_temporary(): return
        fields = self.strip_fields_for_army_update(object.persist_state(nosql = True))
        if fields is not None:
            retmsg.append(["PLAYER_ARMY_UPDATE", [fields]])
    def send_army_update_destroyed(self, object, retmsg):
        if not object.is_temporary():
            retmsg.append(["PLAYER_ARMY_UPDATE_DESTROYED", object.obj_id])
    def ping_squads_and_send_update(self, session, retmsg, originator=None, reason=''):
        army, map_features, mailbox_update = self.ping_squads(session, return_army = True, originator=originator, reason=reason)
        retmsg.append(["SQUADS_UPDATE", self.squads])
        retmsg.append(["PLAYER_ARMY_UPDATE_FULL", filter(lambda x: x is not None, map(self.strip_fields_for_army_update, army))])
        if self.home_region and map_features: retmsg.append(["REGION_MAP_UPDATES", self.home_region, map_features, server_time])
        if mailbox_update: self.send_mailbox_update(retmsg)

    # used for processing untrusted requests from the client, checks to make sure there is an item in slot 'slot'
    # and that the spec matches what the client thinks it is. Returns spec, item or None, None
    def inventory_verify_item(self, slot, specname, level = None):
        if (slot > (len(self.inventory)-1)) or self.inventory[slot]['spec'] != specname or (level is not None and self.inventory[slot].get('level',1) != level):
            return None
        return self.inventory[slot]

    def loot_buffer_release(self, reason):
        if not self.loot_buffer: return
        for entry in self.loot_buffer:
            self.inventory_log_event('5131_item_trashed', entry['spec'], -entry.get('stack',1), entry.get('expire_time',-1), level = entry.get('level',None), reason=reason)
            metric_name = entry['spec']
            if entry.get('level',None) > 1:
                metric_name += '_L%d' % entry['level']
            record_player_metric(self, dict_increment, 'item:'+metric_name+':trashed', entry.get('stack',1), time_series=False)
        self.loot_buffer = []

    # return how many items in item_list (format of loot_buffer and inventory) match "specname" and are not expired
    def get_item_quantity(self, item_list, specname, level = None):
        return sum([item.get('stack',1) for item in item_list \
                    if ((item['spec'] == specname) and \
                        (level is None or (item.get('level',1) == level)) and \
                        (('expire_time' not in item) or (item['expire_time'] >= server_time)))], 0)

    def inventory_item_quantity(self, specname, level = None): return self.get_item_quantity(self.inventory, specname, level = level)
    def loot_buffer_item_quantity(self, specname, level = None): return self.get_item_quantity(self.loot_buffer, specname, level = level)

    # remove "total" number of items of spec "specname" from item_list (loot_buffer or inventory)
    # throws exception if insufficient quantity is present
    # returns number removed.
    # if "use_priority", then sort items to prefer short expiration times, small stacks, etc XXX not implemented
    def item_remove_by_type(self, item_list, specname, total, event_name, level=None, use_priority=False, reason=None):
        assert self.get_item_quantity(item_list, specname, level=level) >= total
        n_removed = 0
        while total > 0:
            item = None
            for i in item_list:
                if i['spec'] == specname and (level is None or i.get('level',1) == level):
                    item = i
                    break
            if item is None:
                raise Exception('ran out of items: '+specname)
            to_rem = min(total, item.get('stack',1))
            self.item_remove(item_list, item, to_rem, event_name, reason=reason)
            total -= to_rem
            n_removed += to_rem
        return n_removed

    def loot_buffer_remove_by_type(self, specname, total, event_name, level=None, reason=None): return self.item_remove_by_type(self.loot_buffer, specname, total, event_name, level=level, reason=reason)
    def inventory_remove_by_type(self, specname, total, event_name, level=None, use_priority=False, reason=None): return self.item_remove_by_type(self.inventory, specname, total, event_name, level=level, use_priority=use_priority, reason=reason)

    # remove a quantity of "item" from "item_list" (which must contain it), and log inventory metric
    def item_remove(self, item_list, item, qty_to_rem, event_name, reason=None):
        original_count = count = item.get('stack',1)
        count -= qty_to_rem
        if count <= 0:
            item_list.remove(item)
            if count < 0: # probably should flag this somehow
                count = 0
        elif count == 1 and 'stack' in item:
            del item['stack']
        elif count > 1:
            item['stack'] = count
        n_removed = original_count - count
        self.inventory_log_event(event_name, item['spec'], -n_removed, item.get('expire_time',-1), level = item.get('level',None), reason=reason)
        return n_removed

    def loot_buffer_remove(self, item, qty_to_rem, event_name, reason=None): return self.item_remove(self.loot_buffer, item, qty_to_rem, event_name, reason)
    def inventory_remove(self, item, qty_to_rem, event_name, reason=None): return self.item_remove(self.inventory, item, qty_to_rem, event_name, reason)

    def inventory_remove_stack(self, item, event_name, reason=None):
        # remove the entire stack. item must be in self.inventory
        self.inventory.remove(item)
        self.inventory_log_event(event_name, item['spec'], -item.get('stack',1), item.get('expire_time',-1), level = item.get('level',None), reason=reason)
        return item.get('stack',1)

    def inventory_has_space_for(self, item, max_slots):
        spec = gamedata['items'][item['spec']]
        stack = item.get('stack',1)
        assert not spec.get('fungible',False)
        max_stack = spec.get('max_stack',1)

        # join existing stack?
        for existing in self.inventory:
            if existing['spec'] == item['spec'] and \
               existing.get('level',1) == item.get('level',1) and \
               (existing.get('stack',1) + stack) <= max_stack:
                return True

        # make new stack?
        if len(self.inventory) < max_slots:
            return True

        return False

    # Add as much of this one item stack to inventory as
    # possible. Return size of the stack that was added to inventory.
    # this function should NOT throw exceptions, as it would cause item-duping bugs
    @admin_stats.measure_latency('inventory_add_item')
    def inventory_add_item(self, item, max_slots):
        if 'spec' not in item:
            gamesite.exception_log.event(server_time, 'inventory_add_item: invalid item '+repr(item))
            return 0

        if item['spec'] not in gamedata['items']:
            gamesite.exception_log.event(server_time, 'inventory_add_item: unknown spec '+item['spec'])
            return 0

        spec = gamedata['items'][item['spec']]
        max_stack = spec.get('max_stack',1)
        fungible = spec.get('fungible',False)
        stack = item.get('stack',1)
        undiscardable = item.get('undiscardable',False)
        expire_time = item.get('expire_time', -1)

        count = 0
        while stack > 0:
            dest = None

            if max_stack > 1:
                # see if we can join an existing stack
                for existing in self.inventory:
                    if existing['spec'] == item['spec'] and \
                       existing.get('level',1) == item.get('level',1) and \
                       existing.get('stack',1) < max_stack and existing.get('expire_time',-1) == expire_time:
                        dest = existing
                        break
            if dest:
                assert dest.get('stack',1) >= 1
                to_add = min(stack, max_stack - dest.get('stack',1))
                #gamesite.exception_log.event(server_time, 'stack %d max_stack %d to_add %d join existing stack %r' % \
                #                             (stack, max_stack, to_add, dest))
                assert to_add > 0
                dest['stack'] = dest.get('stack',1) + to_add
                if undiscardable: dest['undiscardable'] = 1
                stack -= to_add
                count += to_add
                continue

            if fungible:
                # add as much as possible to resources
                if spec['resource'] == 'gamebucks':
                    self.resources.gain_gamebucks(stack, reason='item')
                    count += stack; stack = 0
                elif spec['resource'] in gamedata['resources']:
                    gained_res = self.resources.gain_res({spec['resource']:stack}, reason='item_fungible')
                    gained = sum(gained_res.itervalues(),0)
                    admin_stats.econ_flow_player(self, 'item', 'fungible', gained_res)
                    count += gained
                    stack -= gained
                elif spec['resource'] == 'lottery_scans':
                    if expire_time < 0 or expire_time > server_time:
                        self.do_apply_aura('lottery_scans', stack = stack,
                                           duration = (expire_time - server_time) if expire_time > 0 else -1,
                                           ignore_limit = True)
                    count += stack; stack = 0
                else:
                    gamesite.exception_log.event(server_time, 'unhandled fungible resource'+spec['resource'])
                    break
                break
            else:
                # out of space?
                if max_slots >= 0 and (len(self.inventory) >= max_slots):
                    #gamesite.exception_log.event(server_time, 'all %s slots used (%d)' % (max_slots, len(self.inventory)))
                    break

                # add whole item to inventory
                new_item = {'spec': item['spec']}
                if item.get('level',1) != 1:
                    new_item['level'] = item['level']
                if stack > 1:
                    new_item['stack'] = stack
                if undiscardable:
                    new_item['undiscardable'] = 1
                if expire_time > 0:
                    new_item['expire_time'] = expire_time
                self.inventory.append(new_item)

                count += stack
                stack = 0


        # update item stack count
        if 'stack' in item:
            del item['stack']
        if stack > 1:
            item['stack'] = stack

        return count

    def send_inventory_update(self, retmsg):
        res = self.resources.calc_snapshot()
        retmsg.append(["INVENTORY_UPDATE", res.max_inventory(), copy.deepcopy(self.inventory), res.reserved_inventory()])

    def inventory_restack(self, sort_order):
        # restack stackable items as compactly as possible

        # transform item into a hashable key, ignoring stack count
        def item_to_key(item):
            return tuple(sorted((k_v[0],k_v[1]) for k_v in item.iteritems() if k_v[0] != 'stack'))

        # transform hashable key back into list of items (limited by max_stack)
        def key_to_items(key, stack):
            item = dict(key)
            assert 'stack' not in item
            if item['spec'] in gamedata['items']:
                max_stack = gamedata['items'][item['spec']].get('max_stack',1)
            else:
                max_stack = 1
            ret = []
            while stack > max_stack:
                inst = copy.deepcopy(item)
                if max_stack != 1: inst['stack'] = max_stack
                ret.append(inst)
                stack -= max_stack

            if stack != 1: item['stack'] = stack
            ret.append(item)
            return ret

        # count items by key
        inv = dict()
        for item in self.inventory:
            key = item_to_key(item)
            inv[key] = inv.get(key,0) + item.get('stack',1)

        # reconstruct compacted inventory
        new_inventory = sum((key_to_items(key, stack) for key, stack in inv.iteritems()), [])

        # sort the items
        def item_sort_key(item):
            if item['spec'] in gamedata['items']:
                spec = gamedata['items'][item['spec']]
                if 'category' in spec:
                    return spec['category']
            return item['spec']
        new_inventory.sort(key = item_sort_key, reverse = (sort_order == -1))

        #gamesite.exception_log.event(server_time, 'OLD: %r\nNEW: %r' % (self.inventory, new_inventory))

        # atomically update inventory
        self.inventory = new_inventory

    # log fishing-related events
    def fishing_log_event(self, event_name, queue_entry, ui_index = None, time_left = None, loot = None):
        slate_id = None
        if self.cooldown_active('fish_slate_assigned'):
            slate_id = self.cooldowns['fish_slate_assigned']['data']['slate']
        props = {'attempt_id': queue_entry.craft_state.get('attempt_id', None),
                 'slate_id': slate_id,
                 'recipe_id': queue_entry.craft_state['recipe']}
        if ui_index is not None: props['ui_index'] = ui_index
        if time_left is not None: props['time_left'] = time_left
        if loot: props['loot'] = loot
        props['sum'] = self.get_denormalized_summary_props('brief')
        metric_event_coded(self.user_id, event_name, props)

    def send_mailbox_update(self, retmsg):
        retmsg.append(["MAIL_UPDATE", None, self.mailbox])

    # return unique player history key for a daily tip or message
    @staticmethod
    def get_daily_tip_key(kind, data, ref_time):
        assert kind in ('daily_tip', 'daily_msg')
        ret = kind+':'+data['name']
        if ('repeat_interval' in data) and ('start_time' in data):
            run_num = (ref_time - data['start_time'])//data['repeat_interval']
            ret += ':run%d' % run_num
        return ret

    def get_daily_tips(self, session, retmsg):
        ref_time = self.get_absolute_time()
        popup_tip = None # only one popup tip is allowed
        pageable_tips = [] # any number of pageable tips are allowed (oldest->newest)
        all_pageable_tips_seen = True

        for tip in gamedata['daily_tips']:
            if ('show_if' in tip) and (not Predicates.read_predicate(tip['show_if']).is_satisfied2(session, self, None)): continue

            key = self.get_daily_tip_key('daily_tip', tip, ref_time)
            already_understood = (self.history.get(key, 0) >= 2)

            kind = tip.get('kind', 'popup')
            if kind == 'pageable':
                data = tip.copy()
                data['understood'] = int(already_understood)
                pageable_tips.append(data)
                if (not already_understood):
                    all_pageable_tips_seen = False
            elif kind == 'popup':
                if popup_tip: continue # already have one
                if already_understood and (not tip.get('recurring',False)): continue # already understood
                popup_tip = tip

        if popup_tip:
            key = self.get_daily_tip_key('daily_tip', popup_tip, ref_time)
            if ('action' in popup_tip) and (self.history.get(key, 0) < 1):
                session.execute_consequent_safe(popup_tip['action'], self, retmsg, reason='get_daily_tips')
                session.setmax_player_metric(key, 1)
            retmsg.append(["DISPLAY_DAILY_TIP", popup_tip['name']])

        if pageable_tips and (not all_pageable_tips_seen):
            pageable_tips.reverse()
            retmsg.append(["DISPLAY_DAILY_TIP_PAGES", pageable_tips])

    def get_daily_messages(self, session, retmsg):
        got_any = False
        ref_time = self.get_absolute_time()

        for tip in gamedata['daily_messages']:
            key = self.get_daily_tip_key('daily_msg', tip, ref_time)
            if self.history.get(key, 0) and (not tip.get('recurring',False)): continue

            if 'expire_at' in tip:
                expire_time = tip['expire_at']
            elif 'end_time' in tip:
                if ('repeat_interval' in tip) and ('start_time' in tip):
                    # time remaining in this run
                    delta = (ref_time - tip['start_time']) % tip['repeat_interval']
                    expire_time = ref_time + (tip['end_time'] - tip['start_time'] - delta)
                else:
                    expire_time = tip['end_time']
            elif 'expire_in' in tip:
                expire_time = ref_time + tip['expire_in']
            else:
                expire_time = -1
            if expire_time > 0 and ref_time >= expire_time: continue

            if 'show_if' in tip and (not Predicates.read_predicate(tip['show_if']).is_satisfied2(session, self, None)): continue
            msg = {'type': 'mail',
                   'expire_time': expire_time,
                   'msg_id': generate_mail_id(),
                   'from_name': tip['ui_sender'],
                   'subject': tip['ui_subject'],
                   'body': tip['ui_body']}

            if 'attachments' in tip: # raw item array
                msg['attachments'] = []
                for a in tip['attachments']:
                    attachment = copy.deepcopy(a)
                    if 'item_duration' in attachment:
                        attachment['expire_time'] = session.get_item_spec_forced_expiration(gamedata['items'][attachment['spec']],
                                                                                            prev_expire_time = attachment['item_duration'] + server_time)
                        del attachment['item_duration']
                    msg['attachments'].append(attachment)
            elif 'attachments_loot' in tip: # loot table
               attachments = session.get_loot_items(self, tip['attachments_loot'], -1, -1)
               if attachments:
                  msg['attachments'] = copy.deepcopy(attachments)

            if 'on_send' in tip:
               session.execute_consequent_safe(tip['on_send'], self, retmsg,
                                               context = {'home_region': self.home_region},
                                               reason='get_daily_messages')
            self.mailbox_append(msg)
            self.history[key] = 1
            got_any = True
        return got_any

    def get_daily_banner(self, session, retmsg):
        for ban in gamedata['daily_banners']:
            key = 'daily_banner:'+ban['name']
            if self.history.get(key, 0) and (not ban.get('recurring',False)): continue
            if 'show_if' in ban and (not Predicates.read_predicate(ban['show_if']).is_satisfied(self, None)): continue
            if 'on_view' in ban:
               session.execute_consequent_safe(ban['on_view'], self, retmsg, reason='get_daily_banner')
            self.history[key] = 1
            return Predicates.eval_cond_or_literal(ban['spin_header_content'], session, self)
        return None

    def apply_promo_code(self, session, retmsg, code):
        if 'enable_promo_codes' in gamedata['predicate_library'] and \
           (not Predicates.read_predicate(gamedata['predicate_library']['enable_promo_codes']).is_satisfied(self, None)):
            return

        data = gamedata['promo_codes'].get(code, None)
        if not data: return
        for PRED in ('show_if', 'requires'):
            if PRED in data and (not Predicates.read_predicate(data[PRED]).is_satisfied(self, None)): return

        key = 'promo_code:'+code

        if 'cooldown' in data: # promo codes with cooldown are tracked via player cooldown
            if self.cooldown_active(key): return
            self.cooldown_trigger(key, data['cooldown'])

        else: # promo codes with no cooldown are once-only and tracked via player history
            if self.history.get(key, 0): return
            self.history[key] = 1

        session.increment_player_metric('promo_codes_applied', 1)
        if 'on_login' in data:
            session.execute_consequent_safe(data['on_login'], self, retmsg, reason='apply_promo_code',
                                            context = {'loot_reason':'promo_code',
                                                       'loot_reason_id': code,
                                                       'loot_mail_template': 'promo_code_mail' })

    # compress player.sessions by collapsing adjacent relogs that occur within a short period of time
    def prune_sessions(self):
        sessions = self.history.get('sessions', None)
        if not sessions: return
        THRESHOLD = gamedata['server']['session_merge_threshold']
        if THRESHOLD < 0: return

        new_sessions = []
        for s in sessions:
            assert s[0] > 0
            if len(new_sessions) > 0:
                last_s = new_sessions[-1]
                if last_s[1] > 0 and (s[0] - last_s[1] < THRESHOLD):
                    # merge onto last session
                    last_s[1] = s[1]
                    continue
            new_sessions.append(s)
        self.history['sessions'] = new_sessions
        #print 'pruned', len(sessions), 'to', len(new_sessions), 'sessions'

    # compress player.activity by removing "idle" and "harvest" entries
    def prune_activity(self):
        activity = self.history.get('activity', None)
        if not activity: return
        if gamedata['server'].get('log_activity_in_player_history', False):
            for stime, data in activity.items():
                if data['state'] in ('idle','harvest'):
                    del activity[stime]
        else:
            # delete it completely
            del self.history['activity']

    # delete oldest entries in the battle history to avoid explosive growth of playerdb files
    def prune_battle_history(self):
        if self.battle_history:
            self.battle_history = {} # blow it away

    def detect_login_abuse(self, cur_session_length = 0):
        # sets lockout_until and lockout_message fields if player is a login abuser
        # use cur_session_length > 0 for checking players who are already logged in

        if self.lockout_until > 0 and server_time < self.lockout_until:
            # already locked out
            return False, None
        if 'sessions' not in self.history:
            return False, None
        sessions = self.history['sessions']

        settings = gamedata['server']['login_abuse_detector']

        if cur_session_length > 0:
            if (server_time - self.last_lockout_check) < settings['live_check_interval']:
                # checked very recently
                return False, None
            else:
                self.last_lockout_check = server_time

        if self.history.get('money_spent', 0.0) >= settings.get('exempt_money_spent_over',9999999):
            return False, None

        # trigger on more than MAX_LOGIN_REPEATS attempts in the last REPEAT_RANGE seconds
        REPEAT_RANGE = settings['repeat_range']
        MAX_LOGIN_REPEATS = settings['max_login_repeats']
        REPEAT_PENALTY_TIME = settings['repeat_penalty_time']

        # trigger on continuous logins of more than CONTINUOUS_LIMIT seconds of the last CONTINUOUS_RANGE seconds
        CONTINUOUS_LIMIT = settings['continuous_limit']
        CONTINUOUS_WARN  = settings['continuous_warn']
        CONTINUOUS_RANGE = settings['continuous_range']
        CONTINUOUS_PENALTY_TIME = settings['continuous_penalty_time']

        CONTINUOUS_LIMIT_SEVERE = settings['continuous_limit_severe']
        CONTINUOUS_RANGE_SEVERE = settings['continuous_range_severe']

        repeat_count = 0
        continuous_time = cur_session_length
        continuous_time_severe = cur_session_length

        for i in xrange(len(sessions)-1, -1, -1):
            s = sessions[i]
            if s[0] < 0 or s[1] < 0: continue

            if s[1] < (server_time-REPEAT_RANGE) and s[1] < (server_time-CONTINUOUS_RANGE) and s[1] < (server_time-CONTINUOUS_RANGE_SEVERE):
                break
            if s[0] >= (server_time-REPEAT_RANGE):
                repeat_count += 1

            if s[0] >= self.last_lockout_end:
                if s[1] >= (server_time-CONTINUOUS_RANGE):
                    continuous_time += s[1]-max(s[0], server_time-CONTINUOUS_RANGE)
                if s[1] >= (server_time-CONTINUOUS_RANGE_SEVERE):
                    continuous_time_severe += s[1]-max(s[0], server_time-CONTINUOUS_RANGE_SEVERE)

        lockout = False
        is_naughty = False
        abuse_warning_msg = []
        reason = []

        pardoned = ((self.login_pardoned_until >= 0) and (server_time < self.login_pardoned_until))

        if repeat_count >= MAX_LOGIN_REPEATS:
            lockout = True
            self.lockout_until = server_time + REPEAT_PENALTY_TIME
            self.lockout_message = "CANNOT_LOG_IN_LOGIN_ABUSE_FREQUENCY"
            reason += ['%s - tried to log in more than %d times in %d min' % (self.lockout_message, MAX_LOGIN_REPEATS, REPEAT_RANGE/60)]
        elif False and ((continuous_time_severe >= CONTINUOUS_LIMIT_SEVERE) and (not pardoned)):
            lockout = True
            self.lockout_until = server_time + CONTINUOUS_PENALTY_TIME
            self.lockout_message = "CANNOT_LOG_IN_LOGIN_ABUSE_SEVERE"
            reason += ['%s - stayed logged in for %d (more than %d) out of the last %d hours' % (self.lockout_message, continuous_time_severe/3600, CONTINUOUS_LIMIT_SEVERE/3600, CONTINUOUS_RANGE_SEVERE/3600)]
        elif (continuous_time >= CONTINUOUS_LIMIT) and (not pardoned):
            lockout = True
            self.lockout_until = server_time + CONTINUOUS_PENALTY_TIME
            self.lockout_message = "CANNOT_LOG_IN_LOGIN_ABUSE"
            reason += ['%s - stayed logged in for %d (more than %d) out of the last %d hours' % (self.lockout_message, continuous_time/3600, CONTINUOUS_LIMIT/3600, CONTINUOUS_RANGE/3600)]
        elif (continuous_time >= CONTINUOUS_WARN) and (not pardoned):
            abuse_warning_msg += [["LOGIN_ABUSE_WARNING", continuous_time + settings['continuous_warn_fudge'], CONTINUOUS_LIMIT + settings['continuous_warn_fudge'], CONTINUOUS_RANGE]]
            if settings.get('log_detail',0) >= 2:
                gamesite.exception_log.event(server_time, 'LOGIN_ABUSE_WARNING user %d continuous_time %d cur_session_length %d' % (self.user_id, continuous_time, cur_session_length))

        if lockout:
            self.lockout_count += 1

        if lockout or reason:
            gamesite.exception_log.event(server_time, ('login abuse detected! user %d ($%0.2f) count %d cur_session_length %d ' % (self.user_id, self.history.get('money_spent',0), self.lockout_count, cur_session_length)) + string.join(reason,', '))

        if lockout:
            metric_event_coded(self.user_id, '0700_login_abuse_detected', {'reason': self.lockout_message})

        if lockout and (cur_session_length <= 0):
            # note: this is now fire-and-forget, not synchronous!
            player_table.store_async(self, lambda: None, False, 'login_abuse_detector')

        return is_naughty, abuse_warning_msg

    def get_alt_data(self, other_id):
        if is_ai_user_id_range(other_id): return False
        key = str(other_id)
        if key not in self.known_alt_accounts: return False
        alt = self.known_alt_accounts[key]
        if SpinHTTP.is_private_ip(alt.get('last_ip', 'Unknown')) or alt.get('logins', 0) < gamedata['server'].get('alt_min_logins', 5): return False
        if alt.get('ignore', False): return False
        if 'last_login' in alt and alt['last_login'] < (server_time - gamedata['server'].get('alt_ignore_age', 28*86400)): return False
        return alt

    def alt_record_attack(self, other_id):
        alt_data = self.get_alt_data(other_id)
        if not alt_data: return
        alt_data['attacks'] = alt_data.get('attacks',0) + 1

    def possible_alt_record_login(self, alt_id, ip = None):
        if alt_id == self.user_id: return
        key = str(alt_id)

        alt_data = self.known_alt_accounts.get(key, None)

        if alt_data is None:
            # move the ID from possible_alt_accounts to known_alt_accounts once detect_threshold logins have happened
            detect_threshold = gamedata['server']['alt_detect_logins']
            if detect_threshold < 0: return

            dict_increment(self.possible_alt_accounts, key, 1)
            if self.possible_alt_accounts[key] >= detect_threshold:
                alt_data = self.known_alt_accounts[key] = {}
                del self.possible_alt_accounts[key]
                if gamedata['server']['log_alt_accounts'] >= 2:
                    gamesite.exception_log.event(server_time, 'user %d identified alt account %d after %d logins' % (self.user_id, alt_id, detect_threshold))
            else:
                if gamedata['server']['log_alt_accounts'] >= 3:
                    gamesite.exception_log.event(server_time, 'user %d has possible alt: %d (%d logins)' % (self.user_id, alt_id, self.possible_alt_accounts[key]))

        if alt_data is not None:
            alt_data['logins'] = alt_data.get('logins',0) + 1
            alt_data['last_login'] = server_time # record time of last simultaneous login
            if ip:
                alt_data['last_ip'] = ip

    def is_alt_account_unattackable(self, other_id):
        if (not spin_secure_mode): return False
        if self.is_developer(): return False
        limit = gamedata['server']['alt_no_attack_after']
        if limit < 0: return False
        alt_data = self.get_alt_data(other_id)
        if alt_data and alt_data.get('ignore', False): return False
        return alt_data and (alt_data.get('attacks',0) >= limit) and (alt_data.get('last_login',server_time) >= server_time - 90*86400)

    def is_alt_account_unprotectable(self, other_id):
        if (not spin_secure_mode): return False
        limit = gamedata['server']['alt_no_protect_after']
        if limit < 0: return False
        alt_data = self.get_alt_data(other_id)
        if alt_data and alt_data.get('ignore', False): return False
        return alt_data and (alt_data.get('attacks',0) >= limit) and (alt_data.get('last_login',server_time) >= server_time - 90*86400)

    def is_alt_account_unladderable(self, other_id):
        if (not spin_secure_mode): return False
        limit = gamedata['server'].get('alt_no_ladder_after',0)
        if limit < 0: return False
        alt_data = self.get_alt_data(other_id)
        if alt_data and alt_data.get('ignore', False): return False
        return alt_data and (alt_data.get('attacks',0) >= limit) and (alt_data.get('last_login',server_time) >= server_time - 90*86400)

    # accept URL parameters to override A/B test cohort assignment, and other developer-only variables
    def read_url_overrides(self, user, q):
        if not q: return
        for test_name in sorted(gamedata['abtests'].iterkeys()):
            data = gamedata['abtests'][test_name]
            if data['active'] and (test_name in q):
                group = q[test_name][0]
                if group in data['groups']:
                    gamesite.exception_log.event(server_time, 'override_abtests_from_url: user %d %s -> %s' % \
                                                 (self.user_id, test_name, group))
                    self.abtests[test_name] = group
                    metric_event_coded(self.user_id, '0800_abtest_joined', {'test_name': test_name, 'group_name': group,
                                                                            'reason': 'manual_override'})
                else:
                    gamesite.exception_log.event(server_time, 'override_abtests_from_url: user %d %s GROUP %s NOT FOUND' % \
                                                 (self.user_id, test_name, group))

        if self.is_developer() or (not spin_secure_mode):
            if ('event_time_override' in q):
                self.event_time_override = int(q['event_time_override'][0])
                gamesite.exception_log.event(server_time, 'event_time_override: user %d -> %d' % \
                                             (self.user_id, self.event_time_override))
            if ('ladder_rival_override' in q):
                id = int(q['ladder_rival_override'][0])
                self.ladder_rival_override = id if id >= 0 else None
                gamesite.exception_log.event(server_time, 'ladder_rival_override: user %d -> %d' % \
                                             (self.user_id, self.ladder_rival_override))
            if ('fast_travel' in q):
                self.travel_override = True
            if ('leaderboard_override' in q):
                self.leaderboard_override = q['leaderboard_override'][0]
            if ('force_motd' in q):
                self.force_motd = True

    # update the player's membership in any ongoing A/B tests
    # called once per login
    def update_abtests(self, session, is_first_visit):
        user = session.user

        want_tests = []
        want_cohorts = []
        want_limits = []
        for test_name in sorted(gamedata['abtests'].iterkeys()):
            data = gamedata['abtests'][test_name]
            if data['active'] and (test_name not in self.abtests):
                if is_first_visit:
                    if not data.get('affect_new_users', 1):
                        #print 'FAILED affect_new'
                        continue
                else: # not first visit
                    if not data.get('affect_old_users', 1):
                        #print 'FAILED affect_old'
                        continue

                if ('eligible_en_locale' in data) and (not data['eligible_en_locale']) and \
                   ((not user.locale) or user.locale.startswith('en_')):
                    continue
                if ('eligible_country' in data) and \
                   ((not user.country) or user.country != data['eligible_country']):
                    continue

                if 'eligible' in data:
                    # predicate-based eligibility
                    if type(data['eligible']) == dict and 'predicate' in data['eligible']:
                        if not Predicates.read_predicate(data['eligible']).is_satisfied2(session,self,None):
                            #print 'FAILED PREDICATE', data['eligible'], self.price_region
                            continue
                    else:
                        gamesite.exception_log.event(server_time, 'unhandled "eligible" value %r' % data['eligible'])
                        continue

                groups = sorted(data['groups'].keys())

                if data.get('assign_by_predicate', False):
                    group = None
                    for grname in groups:
                        if ('assign_if' in data['groups'][grname]) and Predicates.read_predicate(data['groups'][grname]['assign_if']).is_satisfied2(session,self,None):
                            group = grname
                            break
                    if group is None:
                        continue
                else:
                    # assign randomly, with optional weighing
                    group = weighted_random_choice(groups, [data['groups'][g].get('weight',1) for g in groups], random.random())

                want_tests = []
                want_cohorts = []
                want_limits = []
                want_tests.append(test_name)
                want_cohorts.append(group)
                want_limits.append(data['groups'][group].get('N', -1))

                if len(want_tests) > 0 and gamesite.nosql_client:
                    # make query to the database
                    results = [gamesite.nosql_client.abtest_join_cohort(test, cohort, limit) for test, cohort, limit in zip(want_tests, want_cohorts, want_limits)]

                    for i in xrange(len(want_tests)):
                        test_name = want_tests[i]
                        group = want_cohorts[i]
                        if results[i]:
                            self.abtests[test_name] = group # success!
                            metric_event_coded(self.user_id, '0800_abtest_joined', {'test_name': test_name, 'group_name': group})

        # REPLACE OBJECT SPECS WITH A/B TEST VERSIONS
        patch_specs = False
        for test_name, group in self.abtests.iteritems():
            if test_name in gamedata['abtests'] and \
               group in gamedata['abtests'][test_name]['groups'] and \
               gamedata['abtests'][test_name]['active'] and \
               gamedata['abtests'][test_name]['groups'][group].get('patches_server_specs',0):
                patch_specs = True
                break
        if patch_specs:
            for obj in self.home_base_iter():
                obj.change_spec(self.get_abtest_spec(obj.spec.__class__, obj.spec.name))

    def update_inerts(self):
        to_remove = []
        for obj in self.home_base_iter():
            if obj.is_inert():
                if obj.spec.expires == 'session':
                    if obj.creation_time > 0:
                        # expire it
                        to_remove.append(obj)
                    else:
                        # set expiration for next login
                        obj.creation_time = server_time

        for obj in to_remove:
            self.home_base_remove(obj)

    # repair all damage. Used for freshening stale accounts so players aren't re-acquired to a dead base
    # must be called BEFORE session starts - does not send any client updates
    def repair_stale_account(self):
        for object in self.home_base_iter():
            if object.owner is not self: continue
            if object.is_building() and object.is_damaged():
                object.repair_finish_time = server_time - 1
            elif object.is_mobile() and object.is_damaged():
                object.heal_to_full()
        self.unit_repair_queue = []

    # migrate() is called on login, handles all migration of forwards-incompatible player state
    # migrate_proxy() is called when loading a Player other than the one who is currently logged in

    def migrate(self, session, user_id, account_creation_time, is_returning_user):
        # do all proxy steps first
        self.migrate_proxy()

        # update Base Defenders ui_name
        if '0' in self.squads:
            self.squads['0']['ui_name'] = gamesite.get_localized_gamedata('strings', session.user.locale)['squads']['base_defenders']

        # ensure that player has all starting tech levels (if gamedata was changed after player was created)
        for key, start_level in gamedata['starting_conditions']['tech'].iteritems():
            if self.tech.get(key, 0) < start_level:
                self.tech[key] = start_level

        # migrate old user chat_gagged flag to player aura
        if session.user.chat_gagged:
            if self.apply_aura('chat_gagged', duration = -1, ignore_limit = True):
                session.user.chat_gagged = None

        # establish default non-auto-unit control setting on elder accounts
        if SpinConfig.game() == 'mf' and \
           Predicates.read_predicate({'predicate': 'NOT', 'subpredicates': [{'predicate':'LIBRARY', 'name': 'after_T117_merge'}]}).is_satisfied(self, None):
            if type(self.player_preferences) is not dict:
                self.player_preferences = {}
            if ('auto_unit_control' not in self.player_preferences):
                # make an explicit setting of the default the player would have seen upon account creation
                if self.abtests.get('T117_mission_reorg2','') == 'new':
                    value = 1
                else:
                    value = 0
                self.player_preferences['auto_unit_control'] = value

        # make sure old accounts have a free muscle box, if they haven't unlocked the tech yet
        REPAIR_DROID_DATE = 1337558400 # UNIX time when repair system was switched on for everyone (2012 May 21)
        if SpinConfig.game() == 'mf' and \
           account_creation_time < REPAIR_DROID_DATE and \
           self.resources.player_level < 8 and \
           self.tech.get('muscle_box_production',0) < 1 and \
           (not self.history.get('free_muscle_box_given', False)):
            has_muscle_box = False
            for obj in self.home_base_iter():
                if obj.spec.name == 'muscle_box':
                    has_muscle_box = True
                    break
            if not has_muscle_box:
                # give the player a muscle box
                builder = self.find_object_by_type(self.get_abtest_spec(GameObjectSpec, 'muscle_box').manufacture_category)
                if builder:
                    gamesite.exception_log.event(server_time, 'giving muscle box to user_id %d' % user_id)
                    self.history['free_muscle_box_given'] = True
                    newobj = instantiate_object_for_player(self, self, 'muscle_box', x=builder.x+10, y=builder.y+10)
                    self.home_base_add(newobj)

        # ensures object build, upgrade, and research time never exceeds current gamedata values
        for obj in self.home_base_iter():
            # check buildings under construction for time requirements that exceed the current gamedata requirements
            if obj.is_building() and obj.is_under_construction():
                spec_build_total_time = GameObjectSpec.get_leveled_quantity(obj.spec.build_time, 1)
                if obj.build_total_time > spec_build_total_time:
                    obj.build_total_time = spec_build_total_time
            # check buildings being upgraded for time requirements that exceed the current gamedata requirements
            if obj.is_building() and obj.is_upgrading():
                spec_upgrade_total_time = GameObjectSpec.get_leveled_quantity(obj.spec.build_time, obj.level + 1)
                if obj.upgrade_total_time > spec_upgrade_total_time:
                    obj.upgrade_total_time = spec_upgrade_total_time
            # check techs being researched for time requirements that exceed the current gamedata requirements
            if obj.is_building() and obj.is_researching():
                tech_spec = session.player.get_abtest_spec(TechSpec, obj.research_item)
                tech_current_level = session.player.tech.get(obj.research_item, 0)
                tech_research_total_time = int(TechSpec.get_leveled_quantity(tech_spec.research_time, tech_current_level + 1) / obj.get_stat('research_speed', 1))
                if obj.research_total_time > tech_research_total_time:
                    obj.research_total_time = tech_research_total_time

        UNIT_EQUIP_DATE = 1362070800 # UNIX time when mod techs were replaced by unit equipment (2013 Feb 26)
        if SpinConfig.game() == 'mf' and \
           (account_creation_time < UNIT_EQUIP_DATE and \
           (not self.history.get('unit_equip_migration_done',False))) or \
           (account_creation_time < 1362072578 and len(self.unit_equipment) == 0): # temporary - fix mis-migrated accounts

            try:
                def is_mod_tech(name):
                    return (name.endswith('_anti_ice') or name.endswith('_anti_radiation') or name.endswith('_health') or name.endswith('_damage') or name.endswith('_armor'))

                # instantly complete any ongoing research of mod techs
                for obj in self.home_base_iter():
                    if obj.is_building() and obj.is_researcher() and is_mod_tech(obj.research_item):
                        name = obj.research_item
                        obj.research_item = ''
                        obj.research_ingredients = None
                        obj.research_total_time = -1
                        obj.research_start_time = -1
                        obj.research_done_time = -1
                        self.tech[name] = self.tech.get(name,0)+1
                        if gamedata['server']['log_unit_equip_migration']:
                            gamesite.exception_log.event(server_time, 'unit_equip_migration: %d - completing research of %s to L%d' % (user_id, name, self.tech[name]))

                old_techs = {} # old mod techs that need to be retired
                new_tech = {} # new replacement for self.tech
                for name, level in self.tech.iteritems():
                    if not name: continue
                    if is_mod_tech(name):
                        old_techs[name] = level
                    else:
                        new_tech[name] = level

                migrate_radcold = {}
                migrate_damage = {}
                migrate_defense = {}

                for name, level in old_techs.iteritems():
                    tech_spec = gamedata['tech'][name]
                    if name.endswith('_anti_ice') or name.endswith('_anti_radiation'):
                        klass = tech_spec['affects_manufacture_category']
                        migrate_radcold[klass] = max(migrate_radcold.get(klass,0), level)
                    else:
                        unit_name = tech_spec['affects_unit']
                        if name.endswith('_health') or name.endswith('_armor'):
                            migrate_defense[unit_name] = max(migrate_defense.get(unit_name,0), level)
                        elif name.endswith('_damage'):
                            migrate_damage[unit_name] = max(migrate_damage.get(unit_name,0), level)
                        else:
                            gamesite.exception_log.event(server_time, 'unit_equip_migration: %d unhandled tech %s' % (user_id, name))

                # add items
                new_equipment = copy.deepcopy(self.unit_equipment)

                def give_unit_equip(equip, unit_name, item_name):
                    if item_name not in gamedata['items']:
                        raise Exception('bad item name '+item_name)
                    slot_type = gamedata['items'][item_name]['equip']['slot_type']
                    if unit_name not in equip: equip[unit_name] = {}
                    if slot_type not in equip[unit_name]: equip[unit_name][slot_type] = []
                    if item_name in equip[unit_name][slot_type]: return
                    equip[unit_name][slot_type].append(item_name)

                for category, level in migrate_radcold.iteritems():
                    if level > 0:
                        for unit_name, unit_data in gamedata['units'].iteritems():
                            if unit_name == 'repair_droid': continue
                            if self.tech.get(unit_data['level_determined_by_tech'], 0) < 1: continue # not researched
                            if unit_data['manufacture_category'] == category:
                                item_name = unit_name +'_radcold_rare'
                                give_unit_equip(new_equipment, unit_name, item_name)

                for unit_name, level in migrate_damage.iteritems():
                    if level > 0:
                        item_name = unit_name + '_damage_' + ('high' if level >= 5 else 'low')
                        give_unit_equip(new_equipment, unit_name, item_name)
                for unit_name, level in migrate_defense.iteritems():
                    if level > 0:
                        item_name = unit_name + '_armor_' + ('high' if level >= 5 else 'low')
                        give_unit_equip(new_equipment, unit_name, item_name)

                # atomically swap in new techs and unit equipment


                if len(old_techs) > 0:
                    if gamedata['server']['log_unit_equip_migration']:
                        gamesite.exception_log.event(server_time, 'unit_equip_migration: %d success\nOLD TECH:\n%s\nOLD EQUIP:\n%s\nNEW TECH:\n%s\n NEW EQUIP:\n%s\n' % (user_id, repr(self.tech), repr(self.unit_equipment), repr(new_tech), repr(new_equipment)))

                    # make backup copies of the old data just in case there is a problem
                    self.history['unit_equip_migration_old_tech'] = copy.deepcopy(self.tech)
                    self.history['unit_equip_migration_old_equipment'] = copy.deepcopy(self.unit_equipment)

                    self.tech = new_tech
                    self.unit_equipment = new_equipment

                self.history['unit_equip_migration_done'] = 1

            except:
                gamesite.exception_log.event(server_time, 'unit_equip_migration (player %d) Exception: %s' % (user_id, traceback.format_exc().strip())) # OK
                pass

        # remove invalid objects from donated units
        for obj_id, entry in self.donated_units.items():
            if entry['spec'] not in gamedata['units']:
                del self.donated_units[obj_id]

        # give free gamebucks
        if self.get_any_abtest_value('currency', gamedata['currency']) == 'gamebucks' and \
           (not self.history.get('free_gamebucks_given', False)):
            self.history['free_gamebucks_given'] = True
            if self.tutorial_state == "COMPLETE":
                bucks = self.get_any_abtest_value('free_gamebucks_veteran', gamedata['starting_conditions']['veteran_gamebucks'])
                reason = 'veteran'
            else:
                bucks = self.get_any_abtest_value('free_gamebucks_starting', gamedata['starting_conditions']['gamebucks'])
                reason = 'starting'
            self.resources.gain_gamebucks(bucks, reason=reason)
            if gamedata['server']['log_gamebucks_init']:
                gamesite.exception_log.event(server_time, 'giving %s %d gamebucks to user_id %d' % \
                                             (reason, bucks, user_id))

        # migrate XP from old to new system
        old_gen = self.history.get('xp_gen',0)
        cur_gen = gamedata['player_xp'].get('xp_gen',0)
        if old_gen < cur_gen:
            old_xp = self.resources.xp
            old_level = self.resources.player_level
            new_xp, new_level = self.recalculate_xp()
            if gamedata['server']['log_xp_migration']:
                gamesite.exception_log.event(server_time, 'player %d migrate_xp gen %d->%d: OLD xp %d level %d NEW xp %d level %d delta %+d' %
                                             (self.user_id,
                                              old_gen, cur_gen,
                                              old_xp, old_level,
                                              new_xp, new_level, new_level-self.resources.player_level))

            if old_gen < gamedata['player_xp'].get('xp_migrate_to',0):
                self.history['xp_gen'] = gamedata['player_xp'].get('xp_migrate_to',0) # mark as migrated
                if (new_xp > old_xp) or gamedata['player_xp'].get('xp_migrate_allow_loss', False):
                    self.resources.xp = new_xp
                    self.resources.player_level = new_level
                    if ('xp_migration_mail' in gamedata['strings']) and ((new_xp != old_xp) or (new_level != old_level)):
                        self.mailbox_append(self.make_system_mail(gamedata['strings']['xp_migration_mail'],
                                                                  replace_s = '%d' % (new_xp - old_xp), replace_level = '%d' % new_level))

        elif gamedata['player_xp'].get('recalculate_on_load'):
            self.recalculate_player_level(session)

        # fix TR turret head tech XP - we forgot to add upgrade_xp to the MG and Mortar turret head techs
        if gamedata['game_id'] == 'tr' and account_creation_time < 1426718214 and self.history.get('turret_head_mg_mortar_xp_fixed',0) < 1:
            missing_xp = 0
            for techname in ('turret_head_mg','turret_head_mortar'):
                time_series = self.history.get('tech:'+techname+'_at_time',{})
                if len(time_series) > 1: # only give XP for upgrades completed AFTER the initial migration
                    spec = self.get_abtest_spec(TechSpec, techname)
                    migrated_level = min(time_series.values())
                    for stime, level in time_series.iteritems():
                        if level > migrated_level:
                            missing_xp += spec.get_leveled_quantity(spec.upgrade_xp, level)
            if missing_xp > 0:
                self.resources.gain_xp(missing_xp, 'turret_head_mg_mortar_xp_fix')
                self.mailbox_append(self.make_system_mail(gamedata['strings']['turret_head_mg_mortar_xp_fix_mail'],
                                                          replace_s = '%d' % missing_xp))
                if gamedata['server']['log_xp_migration']:
                    gamesite.exception_log.event(server_time, 'player %d turret_head_mg_mortar_xp_fix added %d missing XP' % (self.user_id, missing_xp))
            self.history['turret_head_mg_mortar_xp_fixed'] = 1

        # fix TR building/tech XP added 2015 April 23
        if gamedata['game_id'] == 'tr' and \
           account_creation_time < 1429904541 and \
           len(gamedata['player_xp']['level_xp']) >= 50 and \
           self.history.get('201504_xp_fixed',0) < 1:
            missing_xp = 0
            missing_xp_dict = {}
            for techname in ('turret_head_tow','turret_head_hel_laser','turret_head_artillery'):
                spec = self.get_abtest_spec(TechSpec, techname)
                for level in xrange(1, 1+self.tech.get(techname, 0)):
                    xp = spec.get_leveled_quantity(spec.upgrade_xp, level)
                    missing_xp_dict['%s:L%d' % (techname, level)] = xp
                    missing_xp += xp
            for obj in self.my_home.iter_objects():
                if obj.is_building():
                    if obj.spec.name in ('barrier', 'airfield', 'fishing_factory', 'flight_center', 'hardware_depot', 'hardware_factory',
                                         'leader_factory', 'leader_lab', 'motor_pool', 'squad_bay', 'transmitter', 'warehouse', 'weapon_factory',
                                         'weapon_lab', 'turret_emplacement'):
                        for level in xrange(1, 1+obj.level):
                            xp = obj.spec.get_leveled_quantity(obj.spec.upgrade_xp, level)
                            if xp < 0:
                                coeff = gamedata['player_xp']['buildings'].get(obj.spec.name if level > 1 else 'level_1', 0)
                                cost = sum((obj.spec.get_leveled_quantity(getattr(obj.spec, 'build_cost_'+res), level) for res in gamedata['resources']), 0)
                                xp = int(coeff * cost)
                            if xp > 0:
                                key = '%s:L%d' % (obj.spec.name, level)
                                missing_xp_dict[key] = missing_xp_dict.get(key,0) + xp
                                missing_xp += xp
            self.history['201504_xp_prefix'] = self.resources.xp # save previous XP, in case we mess up
            if missing_xp > 0:
                self.resources.gain_xp(missing_xp, '201504_xp_fix')
                self.mailbox_append(self.make_system_mail(gamedata['strings']['201504_xp_fix_mail'],
                                                          replace_s = '%d' % missing_xp))
                if gamedata['server']['log_xp_migration']:
                    gamesite.exception_log.event(server_time, 'player %d 201504_xp_fix added %d missing XP' % (self.user_id, missing_xp))
                    #gamesite.exception_log.event(server_time, 'player %d 201504_xp_fix added %d missing XP %r' % (self.user_id, missing_xp, missing_xp_dict))
            self.history['201504_xp_fixed'] = 1
            self.history['201504_xp_fixed_at'] = server_time

        if 'destination' in self.travel_state:
            # get rid of legacy destination field
            del self.travel_state['destination']
        if 'dest_loc' not in self.travel_state or (self.travel_state['dest_loc'] is not None and type(self.travel_state['dest_loc']) not in [tuple,list]):
            self.travel_state['dest_loc'] = None
        if 'attacks_made' not in self.travel_state:
            self.travel_state['attacks_made'] = 0


        # dump alt_account data if too old
        if self.history.get('alt_account_data_epoch',-1) < gamedata['server'].get('alt_account_data_epoch',-1):
            self.possible_alt_accounts = {}
            self.known_alt_accounts = {}
        self.history['alt_account_data_epoch'] = server_time

        # change format of known_alt_accounts
        if self.known_alt_accounts is None:
            self.known_alt_accounts = {}
        elif type(self.known_alt_accounts) is list:
            # migrate from old list format
            self.known_alt_accounts = dict([(str(alt_id), {'logins':999,'attacks':999}) for alt_id in self.known_alt_accounts])

        self.update_map_placement(session, None)

        # ensure CC level history value is set up
        if gamedata['townhall']+'_level' not in self.history:
            self.history[gamedata['townhall']+'_level'] = self.get_townhall_level()

        # ensure largest_purchase history value is set up
        if ('money_purchase_history' in self.history) and (('largest_purchase' not in self.history) or ('largest_purchase_gamebucks' not in self.history)):
            largest = 0
            largest_gamebucks = 0
            for x in self.history['money_purchase_history']:
                if 'dollar_amount' in x:
                    largest = max(largest, x['dollar_amount'])

                # note: doesn't handle in-kind payments like payer promos/TrialPay
                spellname = None
                if x.get('spellname','').startswith('BUY_GAMEBUCKS_'):
                    spellname = x['spellname']
                elif x.get('description','').startswith('BUY_GAMEBUCKS_'):
                    spellname = x['description'].split(',')[0]
                if spellname:
                    try:
                        gamebucks = session.user.parse_buy_gamebucks_spell_quantity(spellname, None)
                        largest_gamebucks = max(gamebucks, largest_gamebucks)
                    except:
                        pass

            self.history['largest_purchase'] = largest
            self.history['largest_purchase_gamebucks'] = largest_gamebucks

        # check resource levels
        if gamedata['server'].get('log_storage_limit', True) and gamedata['loot_storage_limit'] > 0:
            snap = self.resources.calc_snapshot()
            for res in gamedata['resources']:
                if snap.cur_res(res) > int(gamedata['loot_storage_limit']*snap.max_res(res)):
                    gamesite.exception_log.event(server_time, 'player %d logged in with %s storage %d > %d max' % (self.user_id, res, snap.cur_res(res), snap.max_res(res)))
                    if gamedata['server'].get('fix_storage_limit', False):
                        self.resources.gain_res({res: -1 * (snap.cur_res(res) - snap.max_res(res))}, reason = 'storage_limit', break_limit = True)

        # reset high/low_gfx mode setting for Firefox players affected by re-enabling high_gfx on Firefox
        if self.browser_name == 'Firefox' and \
           self.browser_version >= 46 and \
           isinstance(self.player_preferences, dict) and \
           'low_gfx' in self.player_preferences and \
           '20160726_firefox_gfx_pref_reset' not in self.history:
                #gamesite.exception_log.event(server_time, 'resetting low_gfx for %r' % self.user_id)
                self.history['20160726_firefox_gfx_pref_reset'] = 1
                del self.player_preferences['low_gfx']

        # get rid of bloated obsolete history fields
        BLOAT = ['logins_by_day', 'purchase_ui_log', 'resources_harvested_at_time', 'resources_looted_at_time', 'stored_iron_at_time', 'stored_water_at_time',
                 'units_manufactured_at_time', 'units_killed_at_time', 'units_lost_at_time', 'items_looted_at_time',
                 'resources_stolen_at_time', 'attacks_launched_at_time', 'attacks_launched_vs_human_at_time', 'attacks_launched_vs_ai_at_time', 'attacks_suffered_at_time',
                 'revenge_attacks_launched_vs_human_at_time', 'revenge_attacks_suffered_at_time',
                 'gamebucks_spent_on_speedups_at_time', 'gamebucks_spent_on_unit_repair_speedups_at_time', 'speedups_purchased_at_time', 'unit_repair_speedups_purchased_at_time',
                 'num_gamebucks_purchases_at_time',
                 ]
        for field in BLOAT:
            if field in self.history: del self.history[field]

        cur_notification2_gen = self.get_any_abtest_value('notification2_gen',
                                                          Predicates.eval_cond_or_literal(gamedata['fb_notifications'].get('notification2_gen',None), session, self))
        notification2_reset_interval = self.get_any_abtest_value('notification2_reset_interval',
                                                                 Predicates.eval_cond_or_literal(gamedata['fb_notifications'].get('notification2_reset_interval', -1), session, self))

        # should we clear the "unacked" state to try sending messages again?
        # only do so if "notification2_gen" is explicitly set, AND
        # 1) the notification2_gen changes, OR 2) notification2_reset_time has passed
        reset_notification2_reason = None

        if cur_notification2_gen is not None:
            if self.history.get('notification2_gen',0) < cur_notification2_gen:
                reset_notification2_reason = 'notification2_gen %r -> %r' % (self.history.get('notification2_gen',0), cur_notification2_gen)
            elif (notification2_reset_interval > 0 and \
                  server_time >= self.history.get('notification2_gen_time',0) + notification2_reset_interval):
                reset_notification2_reason = 'notification2_reset_interval passed (last %r)' % self.history.get('notification2_gen_time',0)

        # get rid of obsolete history fields
        for k in self.history.keys():
            if (obsolete_time_series_re.match(k) or \
                (reset_notification2_reason and notification2_state_re.match(k))):
                del self.history[k]

        if reset_notification2_reason:
            self.history['notification2_gen'] = cur_notification2_gen
            self.history['notification2_gen_time'] = server_time
            metric_event_coded(self.user_id, '7132_fb_notification_reset',
                               {'notification2_gen': cur_notification2_gen,
                                'reason': reset_notification2_reason})

        # fix bad intro mails
        if self.history.get('inventory_intro_mail_sent',0) < 2:
            to_remove = []
            for mail in self.mailbox:
                if mail.get('subject',None) == 'Your First Message' and len(mail.get('attachments',[])) < 1:
                    to_remove.append(mail)
            if len(to_remove) > 0:
                gamesite.exception_log.event(server_time, 'player %d fixing bad intro mail %s' % (self.user_id, repr(to_remove)))
                for mail in to_remove:
                    self.mailbox.remove(mail)

        self.send_inventory_intro_mail(session, None)
        self.reseed_lottery(session, force = False)

        # initialize achievement_points score
        if self.history.get('achievement_points_published',0) < 1:
            points = self.get_achievement_points()
            if points > 0:
                self.modify_scores({'achievement_points':points}, method='=', reason = 'login_migrate')
            self.history['achievement_points_published'] = 1

        # publish any modified scores
        self.publish_scores(reason = 'migrate')

        # prune obsolete Scores2 entries that refer to seasons/weeks/days more than 2 steps into the past
        # note: this means we are relying on the Postgres database for authoritative historical scores
        if gamedata['server'].get('scores2_prune', False):
            self.scores2.prune({Scores2.FREQ_SEASON: SpinConfig.get_pvp_season(gamedata['matchmaking']['season_starts'], self.get_absolute_time()),
                                Scores2.FREQ_WEEK:   SpinConfig.get_pvp_week(gamedata['matchmaking']['week_origin'], self.get_absolute_time()),
                                Scores2.FREQ_DAY:    SpinConfig.get_pvp_day(gamedata['matchmaking']['week_origin'], self.get_absolute_time())})

    def recalculate_xp(self):
        new_player_xp = gamedata['player_xp']

        xp = {'starting_conditions':gamedata['starting_conditions']['xp']}
        xp['loot'] = int(new_player_xp['loot'] * self.history.get('resources_looted',0))

        DEPOSIT_FACTOR = 0.07 # accounts for deposits (not recorded in player history) - based on average amount
        xp['harvesting'] = int(new_player_xp['harvest'] * (1.0+DEPOSIT_FACTOR) * self.history.get('resources_harvested',0))

        xp['research'] = 0
        for name, level in self.tech.iteritems():
            for lev in xrange(1,level+1):
                if name not in gamedata['tech'] or \
                   (name in gamedata['starting_conditions']['tech'] and lev <= gamedata['starting_conditions']['tech'][name]):
                    continue
                spec = self.get_abtest_spec(TechSpec, name)
                override = spec.get_leveled_quantity(spec.upgrade_xp, lev)
                if override >= 0:
                    xp['research'] += override
                else:
                    xp['research'] += int(new_player_xp['research'] * \
                                          sum((spec.get_leveled_quantity(getattr(spec, 'cost_'+res), lev) for res in gamedata['resources']), 0))

        xp['buildings'] = 0
        for obj in self.home_base_iter():
            if obj.is_building() and (obj.spec.name in new_player_xp['buildings']):
                start_lev = 1
                for item in gamedata['starting_conditions']['buildings']:
                    if item['spec'] == obj.spec.name:
                        start_lev = max(start_lev, item.get('level',1)+1)
                        break
                for lev in xrange(start_lev,obj.level+1):
                    override = obj.spec.get_leveled_quantity(obj.spec.upgrade_xp, lev)
                    if override >= 0:
                        xp['buildings'] += override
                    else:
                        coeff = new_player_xp['buildings'][obj.spec.name if lev > 1 else 'level_1']
                        cost = sum((obj.spec.get_leveled_quantity(getattr(obj.spec, 'build_cost_'+res), lev) for res in gamedata['resources']), 0)
                        xp['buildings'] += int(coeff * cost)

        xp['quests'] = 0
        for name, data in self.completed_quests.iteritems():
            if name not in gamedata['quests']: continue
            quest = gamedata['quests'][name]
            if ('quest_reward_resources' in new_player_xp):
                xp['quests'] += int(new_player_xp['quest_reward_resources'] * sum((getattr(quest, 'reward_'+res, 0) for res in gamedata['resources']), 0))
            elif ('reward_xp' in quest):
                xp['quests'] += max(int(quest['reward_xp'] * new_player_xp['quests']), new_player_xp['quests_min'])

        total_xp = sum(xp.itervalues(), 0)

        if new_player_xp.get('level_assignment') == 'townhall_level':
            new_level = self.get_townhall_level()
        else:
            new_level = bisect.bisect(new_player_xp['level_xp'], total_xp) - 1
        return total_xp, new_level

    def recalculate_player_level(self, session): # session can be None for offline use
        new_xp, new_level = self.recalculate_xp()
        if new_xp != self.resources.xp or new_level != self.resources.player_level:
            self.resources.xp = new_xp
            self.resources.player_level = new_level
            if session:
                session.deferred_player_state_update = True

    # reseed lottery, if cooldown is up or 'force' is true
    def reseed_lottery(self, session, force = False):
        slot_tables = self.get_any_abtest_value('lottery_slot_tables', gamedata.get('lottery_slot_tables',None))
        if slot_tables is None: return

        if force or (self.lottery_slate is None) or (len(self.lottery_slate) != len(slot_tables)) or \
           (not self.cooldown_active('lottery_reseed')):

            new_slate = dict((slot_name, session.get_loot_items(self, tab, -1, -1)) for slot_name, tab in slot_tables.iteritems())
            weights = self.get_any_abtest_value('lottery_slot_weights', gamedata.get('lottery_slot_weights', None))

            if weights:
                for slot_name in slot_tables:
                    assert slot_name in weights # sanity check
                new_weights = copy.deepcopy(weights)
            else:
                new_weights = None

            # update atomically, in case there was an exception above
            self.lottery_slate = new_slate
            self.lottery_slate_weights = new_weights
            self.cooldown_trigger('lottery_reseed', gamedata['lottery_reseed_cooldown'])

    # get the current lottery slate
    def get_lottery_slate(self, session):
        # shouldn't need to reseed, since this is set up on login and respin, and otherwise it needs to stay the same so the GUI matches
        # self.reseed_lottery(session, force = False)
        assert self.lottery_slate
        return self.lottery_slate

    def send_inventory_intro_mail(self, session, retmsg):
        # retmsg will be None if called from migrate() on load

        sent = False

        if self.tutorial_state == "COMPLETE" and \
           self.get_any_abtest_value('enable_inventory', gamedata['enable_inventory']) and \
           Predicates.read_predicate({'predicate':'LIBRARY', 'name': 'send_inventory_intro_mail_when'}).is_satisfied2(session, self, None):

            if (self.history.get('inventory_intro_mail_sent', 0) < 2):
                self.history['inventory_intro_mail_sent'] = 2
                self.mailbox_append(self.make_system_mail('inventory_intro_mail'))
                sent = True


            if 'free_transmitter_mail' in gamedata['strings'] and \
               (not self.history.get('free_transmitter_given', False)) and self.get_any_abtest_value('give_free_transmitter', False):
                transmitter_spec = self.get_abtest_spec(GameObjectSpec, 'transmitter')
                if GameObjectSpec.get_leveled_quantity(transmitter_spec.requires,1).is_satisfied2(session, self, None):
                    self.history['free_transmitter_given'] = 1
                    self.mailbox_append(self.make_system_mail(gamedata['strings']['free_transmitter_mail']))
                    sent = True

        if sent and (retmsg is not None):
            self.send_history_update(retmsg)
            self.send_mailbox_update(retmsg)

    def send_loot_mail(self, opponent_name, opponent_level, items, retmsg, mail_template = None):
        self.mailbox_append(self.make_system_mail(mail_template or 'loot_mail',
                                                  attachments = items,
                                                  replace_s = opponent_name,
                                                  replace_level = str(opponent_level),
                                                  replace_time = time.strftime('%H:%S', time.gmtime(server_time)),
                                                  replace_day = time.strftime('%d %b %Y', time.gmtime(server_time)),
                                                  ))
        self.send_mailbox_update(retmsg)

    def send_lottery_mail(self, items, retmsg):
        self.mailbox_append(self.make_system_mail(gamedata['strings']['lottery_mail'],
                                                  attachments = items,
                                                  ))
        self.send_mailbox_update(retmsg)

    def update_map_placement(self, session, retmsg):
        # assign location on world map
        self.my_home.base_landlord_id = self.user_id
        self.my_home.base_ui_name = 'Home Base' # unconditional
        self.my_home.base_type = 'home'
        self.my_home.base_id = home_base_id(self.user_id) # always reset this, in case we mess around with playerdb files

        if self.my_home.base_region != self.home_region:
            gamesite.exception_log.event(server_time, 'player %d my_home.base_region %s != home_region %s' % (self.user_id, repr(self.my_home.base_region), repr(self.home_region)))
            self.my_home.base_region = self.home_region

        if self.home_region and (self.home_region not in gamedata['regions']):
            # pluck from invalid region
            self.home_region = self.my_home.base_region = None
            self.my_home.base_map_loc = None
            self.history['map_placement_gen'] = -1

        force_region = None
        if (not self.home_region):
            force_region = self.get_any_abtest_value('force_initial_region', gamedata['starting_conditions'].get('force_initial_region', None))

            # catch returning vets who were plucked off the map here
            # note: maptool.py now sets map_placement_gen = -1 after being plucked, however we have earlier churned players where it is set 0
            if (force_region is None) and \
               self.eligible_for_quarries() and \
               (self.history.get('map_placement_gen',0) < 0 or \
                (('map_placement_gen' in self.history) and (self.history['map_placement_gen'] == 0))):
                force_region = self.get_any_abtest_value('returning_veteran_region', gamedata['starting_conditions'].get('returning_veteran_region', None))
                if (force_region is not None) and gamedata['server']['log_stale_accounts']:
                    gamesite.exception_log.event(server_time, 'placing returning vet %d into region %s' % (self.user_id, force_region))

        map_placement_too_old = self.history.get('map_placement_gen', 0) < gamedata['territory']['map_placement_gen']
        requires_predicate_not_satisfied = self.home_region in gamedata['regions'] and not Predicates.read_predicate(gamedata['regions'][self.home_region].get('requires',{'predicate':'ALWAYS_TRUE'})).is_satisfied2(session, self, None, override_time = None)

        if (map_placement_too_old or requires_predicate_not_satisfied) and \
           (self.eligible_for_quarries() or (force_region is not None)):
            success = self.change_region(force_region if (force_region is not None) else None, None, None, session, retmsg, reason='update_map_placement')
            if success:
                if retmsg:
                    self.send_history_update(retmsg)

                if session and self.history.get('logged_in_times', 0) < 5:
                    # for early accounts, who get on the map during the
                    # first play session, we need to ensure playerdb and
                    # userdb entries are created so that would-be attackers
                    # aren't blocked from attacking their squads.
                    user_table.store_async(session.user, lambda: None, False, 'update_map_placement')
                    player_table.store_async(session.player, lambda: None, False, 'update_map_placement')

        return True

    def change_region(self, request_region, request_loc, request_precision, session, retmsg, reason = ''):
        with admin_stats.latency_measurer('change_region(%s)' % reason):
            return self._change_region(request_region, request_loc, request_precision, session, retmsg, reason = reason)

    # main region-change function
    # pass None to get a random region
    # returns whether it succeeded or not
    def _change_region(self, request_region, request_loc, request_precision, session, retmsg, reason = ''):
        if (not gamesite.nosql_client):
            return False

        new_region = request_region
        new_region_pop = None
        new_loc = request_loc

        # set up precision with defaults
        precision = { 'min_move': gamedata['territory']['relocate_min_move'],
                      'max_rad': gamedata['territory']['neighbor_search_radius'] }
        if request_precision: # and allow request_precision to override
            precision.update(request_precision)

        if gamedata['server']['log_map']:
            gamesite.exception_log.event(server_time, 'map: player %d change_region %s %s request_precision %s precision %s' % (self.user_id, repr(new_region), repr(new_loc), repr(request_precision), repr(precision)))

        randgen = random.Random(self.user_id ^ gamedata['territory']['map_placement_gen'] ^ int(server_time))

        if (new_region is None) or (type(new_region) is list):
            # load-balance to lowest-population applicable region

            if type(new_region) is list:
                regions = new_region
                new_region = None
            else:
                regions = sorted([x['id'] for x in gamedata['regions'].itervalues() if \
                                  (x.get('auto_join',True) and \
                                   (('auto_join_if' not in x) or Predicates.read_predicate(x['auto_join_if']).is_satisfied(self,None)) and \
                                   (('show_if' not in x) or Predicates.read_predicate(x['show_if']).is_satisfied2(session, session.player, None)) and \
                                   (('requires' not in x) or Predicates.read_predicate(x['requires']).is_satisfied2(session, session.player, None)) and \
                                   ((not x.get('developer_only',0)) or session.player.is_developer()))
                                  ])

            if gamedata['server']['log_map']:
                gamesite.exception_log.event(server_time, 'map: player %d change_region candidates %s' % (self.user_id, repr(regions)))

            populations = dict([(r, gamesite.nosql_client.get_map_feature_population(r,'home',reason='change_region')) for r in regions])

            # remove overpopulated (hard-capped) regions from consideration
            for r in [temp for temp in regions]:
                hard_cap = gamedata['regions'][r].get('pop_hard_cap',-1)
                if (hard_cap >= 0) and populations[r] >= hard_cap:
                    regions.remove(r)

            if len(regions) < 1:
                gamesite.exception_log.event(server_time, 'map: no regions for player %d (all disabled or hard-capped) - pops: %s' % (self.user_id, repr(populations)))
                if self.home_region:
                    # continue with taking player off the map
                    new_region = 'LIMBO'
                else:
                    return False

            else:
                new_region = regions[0]
                new_region_pop = populations.get(new_region, 0)
                for r in regions:
                    # if a region is under soft population cap, and preferred predicate is true, then pick it over all others.
                    # otherwise, just pick the lowest-pop region.
                    pop = populations.get(r, 0)
                    soft_cap = gamedata['regions'][r].get('pop_soft_cap',-1)
                    if pop < new_region_pop:
                        new_region_pop = pop
                        new_region = r
                    elif ('prefer_if' in gamedata['regions'][r]) and (soft_cap < 0 or pop < soft_cap) and Predicates.read_predicate(gamedata['regions'][r]['prefer_if']).is_satisfied(self,None):
                        # if we find a preferred region that has not reached its soft cap yet, immediately choose it
                        new_region = r
                        break

        if (new_region not in gamedata['regions']) and new_region != 'LIMBO':
            if gamedata['server']['log_map']:
                gamesite.exception_log.event(server_time, 'map: player %d change_region picked invalid region %s' % (self.user_id, repr(new_region)))
            return False
        if new_region in gamedata['regions'] and gamedata['regions'][new_region].get('developer_only',0) and (not session.player.is_developer()):
            return False

        # remove from old place
        old_region = None
        old_loc = None

        if self.home_region:
            assert self.my_home.base_region == self.home_region
            old_region = self.home_region
            old_loc = self.my_home.base_map_loc

        if new_region != 'LIMBO':
            # get population
            if new_region_pop is None:
                new_region_pop = gamesite.nosql_client.get_map_feature_population(new_region,'home',reason='change_region_get_pop')

            map_dims = gamedata['regions'][new_region]['dimensions']
            BORDER = gamedata['territory']['border_zone_player']

            if new_loc:
                new_loc = (int(new_loc[0]), int(new_loc[1]))
                assert new_loc[0] >= BORDER and new_loc[0] < map_dims[0]-BORDER and \
                       new_loc[1] >= BORDER and new_loc[1] < map_dims[1]-BORDER


            # place in new region via rejection sampling
            if new_loc:
                # search within a radius around new_loc
                trials_set = set()
                rad = precision['max_rad']
                for i in xrange(100):
                    tr = (new_loc[0] + int((2*randgen.random()-1)*rad),
                          new_loc[1] + int((2*randgen.random()-1)*rad))
                    if tr[0] < BORDER or tr[0] >= map_dims[0]-BORDER or tr[1] < BORDER or tr[1] >= map_dims[1]-BORDER:
                        continue # skip, out of bounds
                    trials_set.add(tr)
                trials = list(trials_set)
            else:
                # search the entire map

                # radius: how far from the center of the map we can place the player
                radius = [map_dims[0]//2 - BORDER, map_dims[1]//2 - BORDER]

                # when entering a low-population region, prefer placing player close to the center of the map
                if new_region_pop is not None:
                    cap = gamedata['regions'][new_region].get('pop_hard_cap',-1)
                    if cap > 0:
                        # "fullness": ratio of the current population to centralize_below_pop * pop_hard_cap
                        fullness = new_region_pop / float(cap * gamedata['territory'].get('centralize_below_pop', 0.5))
                        if fullness < 1:
                            # keep radius above a minimum, and raise it with the square root of fullness since open area grows as radius^2
                            radius = [max(gamedata['territory'].get('centralize_min_radius',10), int(math.sqrt(fullness) * x)) for x in radius]

                # rectangle within which we can place the player
                placement_range = [[map_dims[0]//2 - radius[0], map_dims[0]//2 + radius[0]],
                                   [map_dims[1]//2 - radius[1], map_dims[1]//2 + radius[1]]]
                trials = map(lambda x: (min(max(placement_range[0][0] + int((placement_range[0][1]-placement_range[0][0])*randgen.random()), 2), map_dims[0]-2),
                                        min(max(placement_range[1][0] + int((placement_range[1][1]-placement_range[1][0])*randgen.random()), 2), map_dims[1]-2)), xrange(100))

            # note: this will exclude the currently-occupied location, preventing "non-moves"
            trials = filter(lambda x: not Region(gamedata, new_region).obstructs_bases(x), trials)

            if new_region == old_region and old_loc and precision['min_move'] > 1:
                # exclude locations too near currently-occupied location
                trials = filter(lambda x: hex_distance(x, old_loc) >= precision['min_move'], trials)

            if gamedata['server']['log_map']:
                gamesite.exception_log.event(server_time, 'map: player %d change_region attempting to place in %s' % (self.user_id, repr(new_region)))

            i = 0
            for tr in trials:
                i += 1
                self.my_home.base_region = new_region
                self.my_home.base_map_loc = tr
                props = self.my_home.get_cache_props(extra_props = {'protection_end_time': self.resources.protection_end_time})

                if (new_region == old_region):
                    success = gamesite.nosql_client.move_map_feature(self.my_home.base_region, self.my_home.base_id, props, old_loc = old_loc,
                                                                     exclusive = gamedata['territory']['exclusive_zone_player'], originator=self.user_id, reason='change_region')
                else:
                    success = gamesite.nosql_client.create_map_feature(self.my_home.base_region, self.my_home.base_id, props,
                                                                       exclusive = gamedata['territory']['exclusive_zone_player'], originator=self.user_id, reason='change_region')
                if success:
                    break
                else:
                    self.my_home.base_region = old_region
                    self.my_home.base_map_loc = old_loc
                    # note! temporarily leave self.home_region pointing to the old region, so that we can clear the squads out

            if (not self.my_home.base_region) or ((self.my_home.base_region == old_region) and (self.my_home.base_map_loc == old_loc)):
                if not new_loc: # don't print this warning when player deliberately tries to enter a crowded neighborhood
                    gamesite.exception_log.event(server_time, 'map: failed to place player %d in region %s after %d trials' % (self.user_id, new_region, i))
                return False

            session.player_base_lock = (self.my_home.base_region, self.my_home.base_id)
            self.my_home.base_climate = Region(gamedata, self.my_home.base_region).read_climate_name(self.my_home.base_map_loc)
            scenery_removed, scenery_added = self.my_home.spawn_scenery(self, self.user_id + self.my_home.base_map_loc[0] + map_dims[0]*self.my_home.base_map_loc[1], overwrite = True)

            if gamedata['server']['log_map']:
                gamesite.exception_log.event(server_time, 'map: placed player %d on %s at %s' % (self.user_id,
                                                                                                 self.my_home.base_region,
                                                                                             str(self.my_home.base_map_loc)))
        elif old_region: # going into limbo
            self.my_home.base_region = None
            self.my_home.base_map_loc = None
            scenery_removed = scenery_added = []

        ladder_reset = False

        if old_region:
            # recall squads
            for squad_sid in self.squads.iterkeys():
                squad_id = int(squad_sid)
                if self.squad_is_deployed(squad_id):
                    success, map_features, error_code = self.squad_exit_map(None, squad_id, force = True, originator=self.user_id, reason='change_region')

            if self.my_home.base_region != old_region:
                # remove from old region (drops old lock as well)
                gamesite.nosql_client.drop_map_feature(old_region, self.my_home.base_id, originator=self.user_id, reason='change_region(leave_old)')

                old_is_ladder = gamedata['regions'][old_region].get('ladder_pvp', gamedata.get('ladder_pvp', False))
                new_is_ladder = self.my_home.base_region and gamedata['regions'][self.my_home.base_region].get('ladder_pvp', gamedata.get('ladder_pvp', False))
                new_zero_points = self.my_home.base_region and (gamedata['regions'][self.my_home.base_region].get('zero_points_on_entry', False) or Predicates.read_predicate(gamedata['regions'][self.my_home.base_region].get('zero_points_on_entry_if',{'predicate':'ALWAYS_FALSE'})).is_satisfied(self,None))

                if (old_is_ladder and (not new_is_ladder) and gamedata['matchmaking']['zero_points_on_ladder_exit']) or \
                   new_zero_points:
                    # switching out of ladder - reset scores
                    ladder_reset = True
                    self.modify_scores({'trophies_pvp':gamedata['trophy_floor']['pvp']}, method='=', reason = 'change_region')

                if self.my_home.base_region:
                    cons = gamedata['regions'][self.my_home.base_region].get('on_enter', None)
                    if cons:
                        # be careful about leaving the player in a broken state here!
                        session.execute_consequent_safe(cons, self, retmsg, reason='change_region:on_enter(%s)' % self.my_home.base_region)

                if gamedata.get('unit_donation_restrict_region', False):
                    gamesite.sql_client.invalidate_unit_donation_request(self.user_id)
                    self.donated_units = {}
                    if retmsg:
                        retmsg.append(["DONATED_UNITS_UPDATE", self.donated_units])

            else:
                # changed location within one region - no need to drop old stuff
                pass

        self.history['map_placement_gen'] = gamedata['territory']['map_placement_gen']

        self.home_region = self.my_home.base_region
        self.travel_begin(None, 0) # reset travel

        if retmsg is not None: # only run this code OUTSIDE the pre-first-session-change login path
            retmsg.append(["REGION_CHANGE", self.home_region, self.my_home.base_map_loc, False, self.my_home.base_climate])
            if self.home_region and gamedata['regions'][self.home_region].get('enable_turf_control',False):
                retmsg.append(["REGION_TURF_UPDATE", self.home_region, gamesite.nosql_client.alliance_turf_get_by_region(self.home_region, reason = 'change_region')])
            retmsg.append(["PLAYER_TRAVEL_UPDATE", self.travel_state])
            retmsg.append(["SQUADS_UPDATE", self.squads])

            session.init_region_chat(session.player.home_region, retmsg)

            # note: objects only added/removed to session when this is triggered OUTSIDE the login path
            retmsg += [["OBJECT_REMOVED2", session.rem_object(obj.obj_id).obj_id] for obj in scenery_removed if session.has_object(obj.obj_id)]
            retmsg += [["OBJECT_CREATED2", session.add_object(obj).serialize_state()] for obj in scenery_added]

            if session.player.get_daily_messages(session, retmsg): # may trigger message
                session.player.send_mailbox_update(retmsg)

        # update player cache
        gamesite.pcache_client.player_cache_update(self.user_id, {'home_region':self.home_region, 'home_base_loc':self.my_home.base_map_loc}, reason ='change_region')

        metric_event_coded(self.user_id, '4701_change_region_success', {'request_region':request_region, 'request_loc':request_loc, 'request_precision':request_precision,
                                                                        'new_region': self.home_region, 'new_loc': self.my_home.base_map_loc,
                                                                        'ladder_reset': ladder_reset,
                                                                        'old_region':old_region, 'old_loc':old_loc, 'reason':reason})

        return True

    # returns a list of "waves" where each wave is a dictionary of {unit_spec:quantity},
    # based on the "wave_table" that calibrates units against what the player has unlocked
    def get_ai_attack_units(self, attack_data):
        data = None
        # find table entry based on the highest-tech unit the player already has
        for entry in gamedata['ai_attacks']['wave_table']:
            techname = entry['player_lacks']
            if self.tech.get(techname,0) < 1:
                data = entry
                break
        if not data:
            # use last entry if player is a baller and has everything
            data = gamedata['ai_attacks']['wave_table'][-1]

        wave_size = attack_data['waves']
        waves = [dict([(data[kind],qty) for kind, qty in sz.iteritems() if qty>0]) for sz in wave_size]
        return waves

    # unused for now
    def get_repeat_attack_cooldown_expire_time(self, victim_id, victim_base_id):
        # only applies to legacy PvP
        if self.is_ladder_player() or (not self.is_legacy_pvp_player()): return 0

        ai_or_human = 'ai' if is_ai_user_id_range(victim_id) else 'human'

        config = self.get_any_abtest_value('repeat_attack_cooldown', gamedata['repeat_attack_cooldown'])[ai_or_human]

        if config['base'] <= 0: return 0
        if victim_id == self.user_id: return 0
        if victim_base_id != home_base_id(victim_id): return 0 # no cooldown for quarry/squad attacks

        last_time = -1 # time of very last attack
        last_count = 0 # number of attacks within cooldown reset time

        # XXX calculate based on player.cooldowns

        last_count -= config['freebies']

        if last_count > 0:
            ret = int(last_time + config['base'] * math.pow(config['growth'], last_count-1))
            if gamedata['server']['log_repeat_attack_cooldown_calc']:
                gamesite.exception_log.event(server_time, 'repeat_attack vs %d:%s (%s) last_time %d last_count %d = %d more sec (%s)' % \
                                             (victim_id, victim_base_id, ai_or_human, last_time, last_count, ret - server_time, repr(config)))
            return ret
        return 0

def init_game(player, add_extras):
    override = player.get_any_abtest_value('starting_conditions', {})

    player.tutorial_state = override['tutorial_state'] if ('tutorial_state' in override) else gamedata['starting_conditions'].get('tutorial_state', 'START')
    if player.tutorial_state == "COMPLETE":
        # for games without a rails tutorial, perform post-tutorial state setup here
        player.set_post_tutorial_state()

    tech = override['tech'] if ('tech' in override) else gamedata['starting_conditions']['tech']
    for key, level in tech.iteritems():
        player.tech[key] = level
    player.recalc_stattab(player, None)

    buildings = override['buildings'] if ('buildings' in override) else gamedata['starting_conditions']['buildings']
    for b in buildings:
        obj = instantiate_object_for_player(player, player, b['spec'], x=b['xy'][0], y=b['xy'][1], level = b.get('level',1))

        if obj.is_producer():
            obj.contents = 1 # ensure at least 1 unit for collection

        # begin with damage (note: must be >= the tutorial damage limit in main.js)
        obj.hp = int(b.get('hp_ratio',1) * obj.max_hp)
        player.home_base_add(obj)

        key = 'building:'+obj.spec.name+':num_built'
        dict_increment(player.history, key, 1)

        if obj.spec.history_category:
            key = obj.spec.history_category+'_max_level'
            player.history[key] = max(player.history.get(key,0), obj.level)
            key = obj.spec.history_category+'_built'
            dict_increment(player.history, key, 1)
        if obj.spec.track_level_in_player_history:
            key = obj.spec.name+'_level'
            player.history[key] = max(player.history.get(key,0), obj.level)


    barrier_locs = override['barriers'] if ('barriers' in override) else gamedata['starting_conditions']['barriers']
    for loc in barrier_locs:
        player.home_base_add(instantiate_object_for_player(player, player, 'barrier', x=loc[0], y=loc[1]))

    # starting units
    units = override['units'] if ('units' in override) else gamedata['starting_conditions']['units']
    for u in units:
        player.home_base_add(instantiate_object_for_player(player, player, u['spec'], x=u['xy'][0], y=u['xy'][1]))

    deposit_config = player.get_any_abtest_value('iron_deposits', gamedata['server']['iron_deposits'])
    if deposit_config['max'] > 0:
        loc = deposit_config.get('starting_location', [72,63])
        deposit = instantiate_object_for_player(player, player, 'iron_deposit', x=loc[0], y=loc[1], metadata = deposit_config.get('starting_contents', {'iron': 150}))
        player.home_base_add(deposit)

    player.my_home.init_production(player)

    # completed quests
    quests = override['completed_quests'] if ('completed_quests' in override) else gamedata['starting_conditions']['completed_quests']
    for quest in quests:
        player.completed_quests[quest] = {'count':1, 'time':server_time}
        dict_increment(player.history, 'quests_completed', 1)
        dict_increment(player.history, 'quest:'+quest+':completed', 1)

    # override resource levels
    for res in gamedata['resources']:
        if res in override:
            setattr(player.resources, res, override[res])
    if 'xp' in override: player.resources.xp = override['xp']

    inventory_list = override['inventory'] if ('inventory' in override) else gamedata['starting_conditions'].get('inventory', [])
    if inventory_list:
        player.inventory = copy.deepcopy(inventory_list)

def spawn_tutorial_units(session, retmsg):
    override = session.player.get_any_abtest_value('starting_conditions', {})
    data_list = override['attacking_units'] if ('attacking_units' in override) else gamedata['starting_conditions']['attacking_units']
    if not data_list: return
    for data in data_list:
        obj = instantiate_object_for_player(session.player, RogueOwner, data['spec'], x=data['xy'][0], y=data['xy'][1])
        obj.unpersist_state(data)
        session.viewing_base.adopt_object(obj)
        session.add_object(obj)
        retmsg.append(["OBJECT_CREATED2", obj.serialize_state()])
    # start the tutorial with a null attack log open
    session.open_attack_log(-1, -1, -1)

# FOR TESTING ONLY - create "someone else's" base
def setup_test_user(facebook_id, user_id, ui_name):
    gamesite.exception_log.event(server_time, 'Setting up test user account...')
    user = User(user_id)
    user.facebook_name = ui_name
    user.facebook_id = facebook_id
    #user_table.store_sync(user)
    user_table.store_async(user, lambda: None, False, 'setup_test_user')

    player = LivePlayer(user_id)
    player.alias = ui_name
    init_game(player, 1)
    player.read_only = 0
    for obj in player.home_base_iter():
        obj.heal_to_full()
    player.my_home.init_production(player)
    player.tutorial_state = "COMPLETE"

    player.home_base_add(instantiate_object_for_player(player, EnvironmentOwner, gamedata['default_debris_inert'], x=10, y=10))
    player_table.store_async(player, lambda: None, False, 'setup_test_user')





# new AI base construction

# firing them all at once overloads the OSX file descriptor limit for
# the async stores, so pace it out by doing them a few at a time

def setup_ai_bases():
    strid_list = [strid for strid, data in gamedata['ai_bases_server']['bases'].iteritems() if data.get('enable',1)]
    for i in xrange(10):
        setup_next_ai_base(strid_list)

def setup_next_ai_base(strid_list):
    if len(strid_list) < 1: return
    update_server_time()
    strid = strid_list.pop()
    setup_ai_base(strid, functools.partial(setup_next_ai_base, strid_list))

def setup_ai_base(strid, cb):
    if 'ai_bases' not in gamedata:
        gamesite.exception_log.event(server_time, 'Loading full ai_bases data...')
        gamedata['ai_bases'] = SpinConfig.load(SpinConfig.gamedata_component_filename("ai_bases_compiled.json"))

    data = gamedata['ai_bases']['bases'][strid]
    kind = data.get('kind', 'ai_base')

    gamesite.exception_log.event(server_time, 'Setting up AI %4d: %s L%d' % (int(strid), data['ui_name'], data['resources']['player_level']))

    user = User(int(strid))
    user.facebook_first_name = user.facebook_name = data['ui_name']
    user.facebook_id = -1 # XXX None
    user_table.store_async(user, lambda: None, False, 'setup_ai_bases')

    player = LivePlayer(user.user_id)
    player.read_only = 1
    player.alias = data['ui_name']
    player.tutorial_state = "COMPLETE"
    player.resources.unpersist_state(data['resources'])
    player.my_home.deployment_buffer = data.get('deployment_buffer', 1)
    if 'deployment_allowed' in data: player.my_home.deployment_allowed = data['deployment_allowed']

    if 'base_climate' in data:
        assert (data['base_climate'] in gamedata['climates']) or (data['base_climate'] is None)
        player.my_home.base_climate = data['base_climate'] or gamedata.get('default_climate', None)

    if 'base_richness' in data: player.my_home.base_richness = data['base_richness']
    if 'base_ncells' in data: player.my_home.base_ncells = data['base_ncells']
    if 'base_resource_loot' in data: player.my_home.base_resource_loot = data['base_resource_loot']

    player.tech = copy.copy(gamedata['ai_bases_server']['ai_starting_conditions']['tech'])
    for techname, techlevel in data.get('tech',{}).iteritems():
        player.tech[techname] = techlevel
    if 'unit_equipment' in data:
        player.unit_equipment = copy.copy(data['unit_equipment'])
    player.recalc_stattab(player, None)

    if ('scenery' not in data) or data.get('random_scenery',False):
        player.my_home.spawn_scenery(player, user.user_id, overwrite = True)

    if 'scenery' in data:
        for p in data['scenery']:
            player.home_base_add(instantiate_object_for_player(player, EnvironmentOwner, p['spec'], x=p['xy'][0], y=p['xy'][1]))

    if kind == 'ai_base':
        for p in data['buildings']:
            obj = instantiate_object_for_player(player, player, p['spec'], x=p['xy'][0], y=p['xy'][1], level=p.get('level',1))
            if 'force_level' in p: obj.force_ai_level = int(p['force_level'])
            if 'force_team' in p: obj.force_team = p['force_team']
            if 'equipment' in p: obj.equipment = copy.deepcopy(p['equipment'])
            if 'enhancements' in p: obj.enhancements = copy.deepcopy(p['enhancements'])
            if 'behaviors' in p: obj.behaviors = copy.deepcopy(p['behaviors'])
            if 'hp_ratio' in p: obj.hp = int(obj.hp * p['hp_ratio'])

            # max out harvesters
            if obj.is_producer():
                obj.produce_start_time = 1
                obj.produce_rate = 9999999
            player.home_base_add(obj)

        for p in data['units']:
            obj = instantiate_object_for_player(player, player, p['spec'], x=p['xy'][0], y=p['xy'][1], level=p.get('level',1))
            if 'force_level' in p: obj.force_ai_level = int(p['force_level'])

            if 'force_team' in p: obj.force_team = p['force_team']
            if 'equipment' in p: obj.equipment = copy.deepcopy(p['equipment'])
            if 'orders' in p: obj.orders = p['orders']
            if 'patrol' in p: obj.patrol = p['patrol']
            if 'behaviors' in p: obj.behaviors = copy.deepcopy(p['behaviors'])
            if 'pack_id' in p: obj.pack_id = p['pack_id']
            if 'temporary' in p: obj.temporary = p['temporary']
            player.home_base_add(obj)

        player.my_home.init_production(player)
    else:
        xypos = player.my_home.midcell()
        player.home_base_add(instantiate_object_for_player(player, player, gamedata['townhall'], x=xypos[0], y=xypos[1], level=1))

    # populate cache entry
    gamesite.pcache_client.player_cache_update(user.user_id,
                                               {'player_level': player.resources.player_level,
                                                'ui_name': player.alias, 'social_id': 'ai',
                                                'facebook_id': '-1', # XXX remove later
                                                }, reason = 'setup_ai_base')

    player_table.store_async(player, cb, False, 'setup_ai_bases')

def ai_base_source_file(id):
    if type(id) is int:
        # look in AI bases
        source_file = gamedata['ai_bases_server']['bases'][str(id)]['base_source_file']
        source_file = source_file.replace('$GAME_ID', SpinConfig.game()) # not game_id, because we want to strip 'test' suffix if present
        return SpinConfig.gamedata_component_filename(source_file)
        #return '../gamedata/'+source_file
    else:
        return id # literal path



# pull out acquisition event data from a hit on the site
def get_acquisition_data_from_url(url, user_id):

    # get rid of crap on the end of the URL
    if url.endswith('/'): url = url[:-1]
    elif url.endswith('%2F'): url = url[:-3]

    q = urlparse.parse_qs(urlparse.urlparse(url).query)
    ret = None
    if q.has_key('spin_campaign'):
        ret = {'type':'ad_click', 'url': url, 'campaign_name':q['spin_campaign'][0]}
        MAP = {'spin_ge': 'age_group', 'spin_aimg': 'ad_image',
               'spin_attl': 'ad_title', 'spin_atxt': 'ad_text',
               'spin_tgt': 'ad_target',
               'spin_atgt': 'ad_skynet', # NOTE! skynet uses atgt for targeting
               'spin_rtgt': 'skynet_retarget', # retargeted ads are handled separately
               'spin_ati_context': 'adotomi_context',
               'dauup_id': 'dauup_context', 'pd_id': 'dauup_context', 'da_id': 'dauup2_context',
               'cid': 'liniad', 'dp': 'liniad'}
        for key, val in MAP.iteritems():
            if q.has_key(key):
                v = str(q[key][0])
                if val == 'liniad':
                    if ('liniad' in gamedata['adnetworks']):
                        if ('cid' in q) and ('dp' in q) and ('spin_campaign' in q) and re.compile(gamedata['adnetworks']['liniad']['require_spin_campaign']).match(str(q['spin_campaign'][0])):
                            ret['liniad_context'] = {'cid':str(q['cid'][0]), 'dp':str(q['dp'][0])}
                else:
                    ret[val] = v
                    if key == 'spin_tgt':
                        ret[val] = ret[val].lower()
                    elif key == 'pd_id' and (SpinConfig.game() != 'mf'):
                        # special case for DAU-UP - attach both APIs on a pd_id hit
                        ret['dauup2_context'] = v
                    elif key == 'spin_atgt':
                        # when we see a skynet targeting in the URL, engage our FB conversion pixels
                        ret['fb_conversion_pixels_context'] = v

    elif q.has_key('campaign'):
        ret = {'type':'ad_click', 'url': url, 'campaign_name':q['campaign'][0]}
    elif q.has_key('bh_invite'):
        ret = {'type':'ad_click', 'url': url, 'campaign_name':'bh_invite'}
    elif q.has_key('spin_ref'):
        ret = {'type':q['spin_ref'][0], 'url': url}
        if q.has_key('spin_ref_user_id'):
            ret['referring_user_id'] = q['spin_ref_user_id'][0]
            if ret['referring_user_id'] == str(user_id):
                ret['useless'] = 1 # self-referral
        if q.has_key('spin_gift_id'):
            ret['gift_id'] = q['spin_gift_id'][0]
    elif q.has_key('fb_source'):
        ret = {'type': 'ad_click', 'url': url, 'campaign_name': q['fb_source'][0] }
        if q.has_key('fb_ref'):
            ret['fb_ref'] = q['fb_ref'][0]
        if q['fb_source'][0] == 'notification' and (not q.has_key('app_request_type') or q['app_request_type'][0] != 'user_to_user'):
            ret['useless'] = 1 # app-to-user notification - already acquired
    elif q.has_key('is_arcade') and q['is_arcade'][0] == '1':
        ret = {'type': 'ad_click', 'url': url, 'campaign_name': 'facebook_arcade' }
    elif q.has_key('gclid'):
        ret = {'type': 'ad_click', 'url': url, 'campaign_name': 'google' }
    elif q.has_key('spin_promo_code'):
        ret = {'type': 'ad_click', 'url': url, 'campaign_name': 'promo_code' }
    elif q.has_key('ref'):
        ref = q['ref'][0]
        if ref == 'notif':
            if q.has_key('notif_t'):
                notif_t = q['notif_t'][0]
                if notif_t == 'app_request':
                    if q.has_key('request_ids'):
                        ids = q['request_ids'][0].split(',')
                        ret = {'type': 'facebook_app_request', 'facebook_request_ids': ids,
                               'url': url}
            else:
                # unfortunately, not all request links contain the IDs
                ret = {'type': 'facebook_app_request', 'url': url}
        else:
            ret = {'type': 'unknown', 'url': url}
    if ret:
        ret['time'] = server_time

        # mark super-common FB bookmark clicks as useless for acquisition tracking purposes,
        # to avoid userdb bloat
        if ('fb_source' in q and ('bookmark' in q['fb_source'][0])) or \
           ('app_request_type' in q and q['app_request_type'][0] == 'user_to_user') or \
           ('ref' in q and q['ref'][0] == 'bookmarks'):
            ret['useless'] = 1

    return ret

def metric_event(user_id, event, props = {}, send_to_kissmetrics=True):
    #log.msg(("metric_event(%d, '%s', " % (user_id, event)) +repr(props)+')')

    assert 'code' in props

    if SpinConfig.config['enable_kissmetrics'] and send_to_kissmetrics:
        km = KISSmetrics.KM(SpinConfig.config['kissmetrics_api_key'], async=gamesite.AsyncHTTP_metrics)
        km.identify(str(user_id))
        km.record(event, props.copy())

    props['user_id'] = user_id
    props['event_name'] = event
    gamesite.metrics_log.event(server_time, props)


def metric_event_coded(user_id, event_name, props):
    props['code'] = int(event_name[0:4])
    metric_event(user_id, event_name, props)

def metric_alias(user_id, anon_id):
    if not SpinConfig.config['enable_kissmetrics']:
        return
    km = KISSmetrics.KM(SpinConfig.config['kissmetrics_api_key'], async=gamesite.AsyncHTTP_metrics)
    km.alias(str(user_id), anon_id)

# parse client-supplied canvas_oversample for metrics
def parse_canvas_oversample(v):
    if v is None: return None
    if type(v) not in (int, float):
        assert type(v) in (str, unicode)
        if '.' in v: v = float(v)
        else: v = int(v)
    return v

# Facebook Open Graph object endpoint
class OGPAPI(resource.Resource):
    isLeaf = True
    image_dimensions_re = re.compile(r'^.*([^0-9]+)([0-9]+)x([0-9]+).(jpg|png|gif|mp4|webm)')

    @classmethod
    def object_type(cls, name):
        if name == 'literal': return name
        if name == 'gamebucks' and SpinConfig.game() == 'mf':
            # backwards-compatibility hack
            name = 'alloy'
        return SpinConfig.game()+'_'+name

    def get_object_endpoint(self, params, override_host = None):
        port = SpinConfig.config['proxyserver']['external_http_port']
        port_str = (':%d' % port) if port != 80 else ''
        host = override_host or SpinConfig.config['proxyserver'].get('external_listen_host', socket.gethostname())

        # note: use stable ordering of key/value pairs for the query string, so that the canonical URL is deterministic
        qs = urllib.urlencode(sorted(params.items(), key = lambda k_v: k_v[0]))
        return ("http://%s%s/OGPAPI?" % (host, port_str)) + qs

    # check whether url "equals" the OGPAPI endpoint URL generated with these params
    # the comparison is a little loose to allow for minor variations in the URL
    def matches_object_endpoint(self, url, params):
        to_check = [self.get_object_endpoint(params),]
        # special case to handle orders created on temporary legacy DNS entry
        if SpinConfig.game() == 'tr':
            to_check.append(self.get_object_endpoint(params, override_host = 'trprod10.spinpunch.com'))

        url_parts = urlparse.urlparse(str(url))
        for check in to_check:
            check_parts = urlparse.urlparse(str(check))
            if check_parts.netloc == url_parts.netloc and \
               check_parts.path == url_parts.path and \
               (self.strip_object_endpoint_query(check_parts.query) == \
                self.strip_object_endpoint_query(url_parts.query)):
                return True
        return False

    @staticmethod
    def strip_object_endpoint_query(query):
        # Simplify an OGPAPI query string by stripping out keys/values that
        # should not affect equality matches.
        qs = urlparse.parse_qs(query)

        if 'sp_ogpapi_ver' in qs:
            del qs['sp_ogpapi_ver']

        # note: use stable ordering of key/value pairs for the query string
        return urllib.urlencode(sorted(qs.items()))

    def render_GET(self, request):
        SpinHTTP.set_access_control_headers(request)
        try:
            ret = catch_all('OGPAPI request %s args %r' % (request.uri.decode('utf-8'), dict((k,v[0].decode('utf-8')) for k,v in request.args.iteritems())))(self.handle_request)(request)
        except UnicodeDecodeError:
            gamesite.exception_log.event(server_time, 'OGPAPI call with invalid Unicode request: %s' % (str(request.args)))
            ret = None
        if ret is None:
            request.setResponseCode(http.BAD_REQUEST)
            ret = 'OGPAPI request error'
        return ret

    @admin_stats.measure_latency('OGPAPI')
    def handle_request(self, request):
        if gamedata['server']['log_fb_open_graph']:
            gamesite.exception_log.event(server_time, 'OGPAPI HIT: '+repr(request)+' args '+repr(request.args))

        if 'type' not in request.args:
            # bad hit, like from a web crawler
            request.setResponseCode(http.BAD_REQUEST)
            return 'OGPAPI request error: "type" missing'

        ret = '<!DOCTYPE html>\n<html>\n'
        type = request.args['type'][0]

        req_frame_platform = request.args['frame_platform'][0] if 'frame_platform' in request.args else 'fb'

        admin_stats.ogpapi_calls_by_type[type] = admin_stats.ogpapi_calls_by_type.get(type,0) + 1

        # order of precedence:
        # image_url > art_asset_file > art_asset_s3
        image_url = None
        video_url = None
        art_asset_file = None
        art_asset_s3 = None
        my_extra_prefix = ''
        my_og_type = None
        my_url = None
        my_spin_ref = None
        my_spin_ref_user_id = None
        my_spin_link_qs = None
        my_ui_name = None
        my_ui_description = None
        my_ui_determiner = None
        extra_props = {}
        extra_raw_props = []

        if type in (OGPAPI.object_type('gamebucks'), OGPAPI.object_type('alloy')):
            my_url = self.get_object_endpoint({'type':type})
            my_extra_prefix = ' product: http://ogp.me/ns/product#' # ' fbpayment:http://ogp.me/ns/fb/fbpayment#'
            my_og_type = 'og:product' # 'fbpayment:currency'
            my_ui_name = gamedata['strings']['game_name'] +' ' + gamedata['store']['gamebucks_ui_name']
            my_ui_description = "Can be spent in game on speed-ups, resources, and special items"
            my_ui_determiner = 'the'
            art_asset_s3 = gamedata['store']['fb_open_graph_gamebucks_icon']
            #extra_raw_props.append(('fbpayment:rate', gamedata['store']['gamebucks_per_fbcredit']))
            for currency, amount in gamedata['store']['gamebucks_open_graph_prices']:
                extra_raw_props.append(('product:price:amount', amount))
                extra_raw_props.append(('product:price:currency', currency))

        elif type == OGPAPI.object_type('sku'):
            spellname = request.args['spellname'][0]
            if spellname not in gamedata['spells']:
                request.setResponseCode(http.NOT_FOUND)
                return 'invalid spellname'
            spell = gamedata['spells'][spellname]
            assert spell['price_formula'] == 'constant' # price must be only a function of the URL!
            my_url_props = {'type':type, 'spellname': spellname}
            if 'want_loot' in request.args:
                my_url_props['want_loot'] = request.args['want_loot'][0]
            my_url = self.get_object_endpoint(my_url_props)
            my_extra_prefix = ' product: http://ogp.me/ns/product#'
            my_og_type = 'og:product'
            # note: for localized languages, we'll have to have individual SKUs here
            spellarg = None
            if 'quantity' in request.args:
                spellarg = int(request.args['quantity'][0])
            elif 'want_loot' in request.args: # opt-in to item bundle
                spellarg = {'want_loot': bool(int(request.args['want_loot'][0]))}
            else:
                spellarg = {'want_loot': 0} # default
            my_ui_name = Store.format_ui_string(None, spellname, spellarg, spell, spell['ui_name'])
            my_ui_description = Store.format_ui_string(None, spellname, spellarg, spell, spell['ui_description'])

            art_asset_s3 = spell.get('fb_open_graph_s3_image', gamedata['store']['fb_open_graph_gamebucks_icon'])
            if 'open_graph_prices' in spell:
                for i in xrange(len(spell['open_graph_prices'])):
                    # for details see https://developers.facebook.com/docs/payments/ads_virtual_goods
                    if 'open_graph_original_prices' in spell:
                        currency, amount = spell['open_graph_original_prices'][i]
                        extra_raw_props.append(('product:original_price:amount', amount))
                        extra_raw_props.append(('product:original_price:currency', currency))
                    currency, amount = spell['open_graph_prices'][i]
                    extra_raw_props.append(('product:price:amount', amount))
                    extra_raw_props.append(('product:price:currency', currency))
            if 'open_graph_purchase_limit' in spell:
                extra_raw_props.append(('product:purchase_limit', spell['open_graph_purchase_limit']))

        elif type == OGPAPI.object_type('achievement'):
            name = request.args['name'][0]
            data = gamedata['achievements'][name]
            my_url = self.get_object_endpoint({'type':type, 'name':name})
            my_og_type = data['fb_open_graph'].get('fb_type', 'game.achievement').replace('$APP_NAMESPACE', SpinConfig.config['facebook_app_namespace'])
            my_ui_name = data['fb_open_graph'].get('fb_name', data['ui_name'])
            my_ui_description = data['fb_open_graph'].get('fb_description', data['ui_description'])
            art_asset_s3 = data['fb_open_graph']['s3_image']
            if my_og_type == 'game.achievement':
                extra_raw_props.append(('game:points', data['fb_open_graph']['points']))

        elif type == OGPAPI.object_type('base'):
            user_id = int(request.args['user_id'][0])
            base = gamedata['ai_bases_server']['bases'][str(user_id)]
            #art_asset_file =gamedata['art'][base['portrait']]['states']['normal']['images'][0]
            my_url = self.get_object_endpoint({'type':type,'user_id':user_id})
            if 'fb_open_graph' in base:
                my_ui_name = base['fb_open_graph'].get('name', base['ui_name'])
                my_ui_description = base['fb_open_graph']['description']
                art_asset_s3 = base['fb_open_graph']['s3_image']
            else:
                my_ui_name = "%s Level %d" % (base['ui_name'], base['resources']['player_level'])
                my_ui_description = "A vicious computer opponent" # ui_name

            extra_props['level'] = base['resources']['player_level']
            extra_props['owner'] = base['ui_name']
            extra_props['user_id'] = user_id

        elif type == OGPAPI.object_type('player_level'):
            level = int(request.args['level'][0])
            my_url = self.get_object_endpoint({'type':type, 'level': level})
            my_ui_name = "Level %d" % level
            extra_props['level'] = level

        elif type in [OGPAPI.object_type(x) for x in ('spec_building','spec_unit','spec_mobile','spec_inert','spec_tech','spec_aura')]:
            spec_name = request.args['spec'][0]
            level = int(request.args['level'][0]) if ('level' in request.args) else -1

            spec = GameObjectSpec.lookup(spec_name)
            # need to get the raw gamedata spec for UI strings
            raw_spec = gamedata[Spec.KEY_MAP[spec.kind]][spec_name]
            my_ui_name = "%s" % raw_spec['ui_name']
            my_ui_description = "%s" % raw_spec['ui_description']

            if 'external_art_asset' in raw_spec:
                art_asset_s3 = raw_spec['external_art_asset']

            url_params = {'type':type,'spec':spec_name}
            if level > 0:
                url_params['level'] = str(level)
                my_ui_name += " Level %d" % level
                extra_props['level'] = level

            my_url = self.get_object_endpoint(url_params)

        elif type == OGPAPI.object_type('ranking'):
            #value = int(request.args['value'][0])
            #percentile = str(request.args['percentile'][0])
            #category = str(request.args['category'][0])
            #extra_props['value'] = value
            #extra_props['percentile'] = percentile

            my_ui_name = 'Leaderboard Ranking'
            if 'category' in request.args:
                category = str(request.args['category'][0])
                extra_props['category'] = category
                my_ui_name += ': '+category

            my_url = self.get_object_endpoint(dict([(key, val[0]) for key, val in request.args.iteritems()]))
            #my_ui_description = 'For '+category

        elif type == OGPAPI.object_type('literal'):
            if 'ui_name' not in request.args:
                request.setResponseCode(http.BAD_REQUEST)
                return 'missing ui_name'

            my_ui_name = request.args['ui_name'][0].decode('utf-8')
            if ('ui_description' in request.args):
                my_ui_description = request.args['ui_description'][0].decode('utf-8')
            else:
                my_ui_description = SpinConfig.config['proxyserver'].get('fbexternalhit_description', '')
            if ('spin_ref' in request.args):
                my_spin_ref = str(request.args['spin_ref'][0])
            if ('spin_ref_user_id' in request.args):
                my_spin_ref_user_id = str(request.args['spin_ref_user_id'][0])
            if ('spin_link_qs' in request.args):
                # fix possibly-malformed input JSON from browsers here
                spin_link_qs_raw = MalformedJSON.fix(request.args['spin_link_qs'][0])
                try:
                    my_spin_link_qs = SpinJSON.loads(spin_link_qs_raw)
                except ValueError:
                    gamesite.exception_log.event(server_time, 'OGPAPI request with malformed spin_link_qs:\n%s\n%r' % (request.uri.decode('utf-8'), dict((k,v[0].decode('utf-8')) for k,v in request.args.iteritems())))
                    request.setResponseCode(http.BAD_REQUEST)
                    return 'OGPAPI syntax error'
                assert isinstance(my_spin_link_qs, dict)
            my_url = self.get_object_endpoint(dict([(key, val[0]) for key, val in request.args.iteritems()]))

        else:
            raise Exception('unknown type "%s"' % type)

        if req_frame_platform == 'bh':
            ns = 'battlehouse'
        else:
            ns = SpinConfig.config['facebook_app_namespace']

        ret += '<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# %s: http://ogp.me/ns/fb/%s#%s">\n' % (ns, ns, my_extra_prefix)

        if req_frame_platform == 'bh':
            meta_fb_app_id = SpinConfig.config['battlehouse_fb_app_id']
        else:
            meta_fb_app_id = SpinConfig.config['facebook_app_id']

        ret += '<meta property="fb:app_id" content="%s" />\n' % meta_fb_app_id

        ret += '<meta property="og:type"   content="%s" />\n' % (my_og_type if my_og_type else '%s:%s' % (ns, type))
        #ret += '<meta property="og:url"    content="http://apps.facebook.com/%s?spin_campaign=open_graph" />\n' % (SpinConfig.config['facebook_app_namespace'])
        ret += '<meta property="og:url"    content="%s" />\n' % my_url
        ret += u'<meta property="og:title"  content="'+cgi_escape(my_ui_name,True)+u'" />\n'

        if my_ui_description:
            ret += u'<meta property="og:description"  content="'+cgi_escape(my_ui_description,True)+u'" />\n'
        if my_ui_determiner is not None:
            ret += u'<meta property="og:determiner"  content="'+cgi_escape(my_ui_determiner,True)+u'" />\n'

        if not image_url:
            # add image file, either from in-game art asset (200x200px minimum!),
            # or use a generic default Mars Frontier image if none is specified

            if ('image_url' in request.args): # allow client-provided fallback
                image_url = str(request.args['image_url'][0])
            elif art_asset_file:
                if 'art_cdn_path' in SpinConfig.config['proxyserver']:
                    art_server = SpinConfig.config['proxyserver']['art_cdn_path']
                else:
                    # URL to art asset assumes proxyserver is running on same host if no CDN is in use!
                    art_server = '%s:%d/' %  (SpinConfig.config['proxyserver'].get('external_listen_host', gamesite.config.game_host),
                                              SpinConfig.config['proxyserver']['external_http_port'])
                image_url = 'http://%s%s' % (art_server, art_asset_file)
            elif art_asset_s3:
                image_url = 'https://spinpunch-public.spinpunch.com/facebook_assets/%s' % art_asset_s3
            else:
                image_url = SpinConfig.config['proxyserver'].get('fbexternalhit_image', '')
                if not video_url:
                    video_url = SpinConfig.config['proxyserver'].get('fbexternalhit_video', '')

        # note: Facebook crawler seems to do better with non-https image URLs
        ret += '<meta property="og:image"  content="%s" />\n' % image_url.replace('https://','http://')

        # add image dimensions if we can figure them out from the filename
        dim_match = self.image_dimensions_re.match(image_url)
        if dim_match:
            ret += '<meta property="og:image:width"  content="%s" />\n' % (dim_match.group(2))
            ret += '<meta property="og:image:height"  content="%s" />\n' % (dim_match.group(3))

        if video_url:
            # HTTPS is preferred for videos
            ret += '<meta property="og:video" content="%s" />\n' % video_url
            ret += '<meta property="og:video:type" content="video/mp4" />\n'
            dim_match = self.image_dimensions_re.match(video_url)
            if dim_match:
                video_width, video_height = int(dim_match.group(2)), int(dim_match.group(3))
            else:
                video_width, video_height = 1280, 720 # default
            ret += '<meta property="og:video:width" content="%d" />\n' % video_width
            ret += '<meta property="og:video:height" content="%d" />\n' % video_height

        for key, val in extra_props.iteritems():
            ret += '<meta property="%s:%s"  content="%s" />\n' % (ns, key, cgi_escape(str(val),True))
        for key, val in extra_raw_props:
            ret += '<meta property="%s"  content="%s" />\n' % (key, cgi_escape(str(val),True))

        if not my_spin_ref:
            my_spin_ref = 'open_graph_'+type

        # add JavaScript code to redirect end-user browser hits (not Facebook back-end Open Graph hits) to the game
        game_qs = 'spin_ref='+my_spin_ref
        if my_spin_ref_user_id:
            game_qs += '&spin_ref_user_id='+my_spin_ref_user_id
        if my_spin_link_qs:
            game_qs += '&'+urllib.urlencode(my_spin_link_qs)

        if req_frame_platform == 'bh':
            game_url = 'https://www.battlehouse.com/play/'+SpinConfig.config['battlehouse_app_namespace']
        else:
            game_url = 'https://apps.facebook.com/'+SpinConfig.config['facebook_app_namespace']+'/';

        ret += '</head>\n<body onload="top.location.href = \'%s?%s\';"></body>\n</html>' % \
               (game_url, game_qs)
        return ret.encode('utf-8')

OGPAPI_instance = OGPAPI()

# REST interface for stat queries like leaderboard
class STATSAPI(resource.Resource):
    isLeaf = True
    def __init__(self, gameapi):
        resource.Resource.__init__(self)
        self.gameapi = gameapi
    def render_POST(self, request): return self.render_GET(request)
    def render_GET(self, request):
        update_server_time()
        auth = SpinHTTP.get_twisted_header(request, 'Authorization')
        if not auth or (not auth.startswith('Bearer ')) or \
           (auth.split(' ')[1] != SpinConfig.config['stats_api_secret']):
            request.setResponseCode(http.BAD_REQUEST)
            return u'{"error":"Unauthorized"}\n'.encode('utf-8')

        # get "Referer:" header, for debugging where the request came from
        referer = SpinHTTP.get_twisted_header(request, 'Referer') or 'unspecified'

        if 'method' not in request.args:
            request.setResponseCode(http.BAD_REQUEST)
            return u'{"error":"Missing method"}\n'.encode('utf-8')

        method = request.args['method'][0].decode('utf-8')
        if method == 'leaderboard':
            func = self.render_leaderboard
        elif method == 'player':
            func = self.render_player
        elif method == 'alliance':
            func = self.render_alliance
        elif method == 'battle':
            func = self.render_battle
        elif method == 'gamedata':
            func = self.render_gamedata
        elif method == 'gamedata_ref':
            func = self.render_gamedata_ref
        else:
            request.setResponseCode(http.BAD_REQUEST)
            return u'{"error":"Unknown method"}\n'.encode('utf-8')

        func_args = dict((k, v[0]) for k,v in request.args.iteritems())

        try:
            with admin_stats.latency_measurer('STATSAPI(ALL)'):
                with admin_stats.latency_measurer('STATSAPI(%s)' % method):
                    ret = func(func_args)

        except BaseException:
            gamesite.exception_log.event(server_time, 'STATSAPI error: method=%s referer=%s\n%s' % (method, referer, traceback.format_exc()))
            request.setResponseCode(http.INTERNAL_SERVER_ERROR)
            ret = u'{"error":"Internal server error"}\n'

        return ret.encode('utf-8')

    def render_gamedata_ref(self, args):
        # used to get misc. pieces of gamedata the front-end needs
        data = {'strings':{'modstats':{'stats':gamedata['strings']['modstats']['stats']},
                           'damage_vs_categories': gamedata['strings']['damage_vs_categories'],
                           'object_kinds': gamedata['strings']['object_kinds'],
                           'manufacture_categories': gamedata['strings']['manufacture_categories'],
                           },
                'leaderboard': gamedata['leaderboard'],
                # subset of region data
                'regions': dict((rid, {'ui_name': r['ui_name']}) \
                                for rid, r in gamedata['regions'].iteritems()),
                'resources': gamedata['resources']}
        return SpinJSON.dumps({'result': data}, newline=True, pretty=False)

    def render_gamedata(self, args):
        # responds to 3 types of query:
        # 1. what kinds are available?
        # 2. for a given kind, what specs are available?
        # 3. return a given spec
        kind = args.get('kind', None)
        specname = args.get('spec', None)

        assert kind in (None,'units','buildings','tech','items','enhancements')

        if not kind:
            # return master category list
            data = ['units','buildings','tech']
        elif not specname:
            # directory listing

            # return a subset of properties from each spec
            FIELDS = ['name','ui_name','ui_priority','ui_tier',
                      'manufacture_category','research_category','build_category','enhance_category','category',
                      'associated_unit','quarry_only']

            def get_listing(spec):
                ret = dict((f, spec[f]) for f in FIELDS if f in spec)
                # also compute a "priority" for UI display
                if 'ui_priority' not in ret:
                    prio_field = {'units': 'build_time',
                                  'buildings': 'build_time',
                                  'tech': 'research_time',
                                  'enhacements': 'enhance_time'}.get(kind)
                    if prio_field:
                        ret['ui_priority'] = -1 * GameObjectSpec.get_leveled_quantity(spec[prio_field], 1)
                return ret

            def can_show(spec):
                # note: show_webstats overrides developer_only
                if 'show_webstats' in spec:
                    return bool(spec['show_webstats'])
                if spec.get('developer_only'): return False
                return True

            data = map(get_listing, filter(can_show, gamedata[kind].itervalues()))

        else:
            # one specific object

            # copy, because we might mutate it!
            spec = copy.deepcopy(gamedata[kind][specname])
            data = {kind: {specname: spec}}

            # cross-link techs and units
            if kind == 'tech':
                if 'associated_unit' in spec:
                    spec['ui_description'] = gamedata['units'][spec['associated_unit']]['ui_description']
            elif kind == 'units':
                if 'level_determined_by_tech' in spec:
                    tech = gamedata['tech'][spec['level_determined_by_tech']]
                    spec['research_time'] = tech['research_time']
                    for res in gamedata['resources']:
                        if 'cost_'+res in tech:
                            spec['research_cost_'+res] = tech.get('cost_'+res)

            # cross-link weapon spells
            if kind == 'units' and 'spells' in spec:
                data['spells'] = dict((spellname, gamedata['spells'][spellname]) for spellname in spec['spells'])
            elif 'associated_spell' in spec:
                data['spells'] = {spec['associated_spell']: gamedata['spells'][spec['associated_spell']]}

            # provide ingredient item data, if possible
            for prop in ('ingredients',):
                raw_entry = spec.get(prop)
                if raw_entry:
                    if isinstance(raw_entry, list) and len(raw_entry) >= 1 and \
                       isinstance(raw_entry[0], list):
                        list_of_item_lists = raw_entry
                    else:
                        list_of_item_lists = [raw_entry,]
                    for item_list in list_of_item_lists:
                        for item in item_list:
                            if 'items' not in data:
                                data['items'] = {}
                            if item['spec'] not in data['items']:
                                data['items'][item['spec']] = gamedata['items'][item['spec']]

            # provide art URLs, if possible
            for prop in ('icon','splash_image','art_asset'):
                raw_entry = spec.get(prop)
                if raw_entry:
                    if not isinstance(raw_entry, list):
                        asset_list = [raw_entry]
                    else:
                        asset_list = raw_entry
                    asset_name = asset_list[-1]
                    asset = gamedata['art'].get(asset_name)
                    if asset:
                        found = False
                        for state in ('hero','normal','icon'):
                            state = asset['states'].get(state)
                            if state:
                                if 'images' in state:
                                    index = 0
                                    filename = state['images'][index]
                                    for proto in ('https', 'http'):
                                        key = {'http':'external_http_port','https':'external_ssl_port'}[proto]
                                        if SpinConfig.config['proxyserver'].get(key, -1) > 0:
                                            port = SpinConfig.config['proxyserver'][key]
                                            port_str = (':%d' % port) if port != {'http':80,'https':443}[proto] else ''
                                            host = SpinConfig.config['proxyserver'].get('external_listen_host', socket.gethostname())
                                            spec[prop+'_url'] = '%s://%s%s/%s' % (proto,host, port_str, filename)
                                            spec[prop+'_dimensions'] = state['dimensions']
                                            if 'origins' in state:
                                                spec[prop+'_origin'] = state['origins'][2*index:2*index+2]
                                            found = True
                                            break
                            if found: break

        return SpinJSON.dumps({'result': data}, newline=True, pretty=False)

    def render_player(self, args):
        player_id = int(args.get('player_id', -1))
        player_info = self.gameapi.do_query_player_cache(None, [player_id],
                                                         fields = ['ui_name', 'player_level','alliance_id',
                                                                   'home_region', 'home_base_loc'],
                                                         get_trophies = True,
                                                         reason = 'STATSAPI(player)')[0]
        if not player_info:
            ret = {'error': 'Player %r not found' % player_id}
        else:
            alliance_membership = gamesite.sql_client.get_users_alliance_membership(player_id,
                                                                                    reason = 'STATSAPI(player)')
            alliance_info = None
            alliance_id = alliance_membership['alliance_id'] if alliance_membership else -1

            if alliance_id > 0:
                alinfo = gamesite.sql_client.get_alliance_info([alliance_id],
                                                               get_roles=True,
                                                               reason = 'STATSAPI(player)')[0]
                if alinfo:
                    alliance_info = {'alliance_id': alliance_id,
                                     'logo': alinfo.get('logo'),
                                     'chat_tag': alinfo.get('chat_tag'),
                                     'ui_name': alinfo.get('ui_name'),
                                     'roles': alinfo.get('roles')}
                    player_info['alliance_id'] = alliance_id
                    player_info['alliance_role'] = alliance_membership.get('role',0)
                    player_info['alliance_join_time'] = alliance_membership.get('join_time',-1)

            ret = {'result': {'player': player_info,
                              'alliance': alliance_info,
                              'region': None}}

            if player_info.get('home_region') in gamedata['regions']:
                rdata = gamedata['regions'][player_info['home_region']]
                ret['result']['region'] = {'id': rdata['id'], 'ui_name': rdata['ui_name']}

            if gamedata.get('battle_logs_public',False):
                # look up recent battles
                # note: could use gamesite.gameapi.query_battle_history() here
                summaries = gamesite.nosql_client.battles_get(
                    player_id, -1, -1, -1, limit = 10,
                    ai_or_human = SpinNoSQL.NoSQLClient.BATTLES_HUMAN_ONLY,
                    fields = gamesite.gameapi.BATTLE_HISTORY_FIELDS, # + ['damage',] ?
                    reason = 'render_player')
                ret['result']['recent_battles_pvp'] = map(self.augment_battle_summary, summaries)

        return SpinJSON.dumps(ret, newline=True, pretty=False)

    def render_alliance(self, args):
        alliance_id = int(args.get('alliance_id', -1))
        alinfo = gamesite.sql_client.get_alliance_info([alliance_id],
                                                       get_roles=True,
                                                       reason = 'STATSAPI(alliance)')[0]
        if not alinfo:
            ret = {'error': '%s %r not found' % (gamedata['strings']['alliance'], alliance_id)}
        else:
            members = gamesite.sql_client.get_alliance_members(alliance_id, reason = 'STATSAPI(alliance)')
            # XXX could get scores here

            pcache_data = self.gameapi.do_query_player_cache(None, [m['user_id'] for m in members],
                                                             fields = ['ui_name', 'player_level',
                                                                       'home_region', 'home_base_loc'],
                                                             get_trophies = True,
                                                             reason = 'STATSAPI(alliance)')
            pcache_data = filter(lambda x: bool(x), pcache_data) # throw out null entries
            for i in xrange(len(pcache_data)):
                r = pcache_data[i]
                if r:
                    # fill in alliance_id and role
                    r['alliance_id'] = alliance_id
                    r['alliance_role'] = members[i]['role']

            ALLIANCE_FIELDS = ('alliance_id', 'logo', 'chat_tag', 'ui_name', 'ui_description',
                               'join_type', 'num_members', 'creation_time', 'continent', 'roles')

            ret = {'result': {'ui_alliance': gamedata['strings']['alliance'],
                              'alliance': dict((field, alinfo.get(field)) for field in ALLIANCE_FIELDS),
                              'members': pcache_data}}

            if gamedata.get('battle_logs_public',False):
                # look up recent battles
                # note: could use gamesite.gameapi.query_battle_history() here
                summaries = gamesite.nosql_client.battles_get(
                    -1, -1, alliance_id, -1, limit = 20,
                    ai_or_human = SpinNoSQL.NoSQLClient.BATTLES_HUMAN_ONLY,
                    fields = gamesite.gameapi.BATTLE_HISTORY_FIELDS, # + ['damage',] ?
                    reason = 'render_alliance')
                ret['result']['recent_battles_pvp'] = map(self.augment_battle_summary, summaries)

        return SpinJSON.dumps(ret, newline=True, pretty=False)

    def render_leaderboard(self, args):
        ret = {'game_id': gamedata['game_id'],
               'ui_game_name': SpinConfig.config['proxyserver'].get('fbexternalhit_title',
                                                                    gamedata['strings']['game_name']),
               'season_ui_offset': gamedata['matchmaking'].get('season_ui_offset',0),
               'update_time': server_time,
               'categories': []
               }

        cur_day = SpinConfig.get_pvp_day(gamedata['matchmaking']['week_origin'], server_time)
        cur_week = SpinConfig.get_pvp_week(gamedata['matchmaking']['week_origin'], server_time)
        cur_season = SpinConfig.get_pvp_season(gamedata['matchmaking']['season_starts'], server_time)

        if 'time_scope' not in args:
            args['time_scope'] = Scores2.FREQ_SEASON

        if args['time_scope'] == Scores2.FREQ_ALL:
            time_scope = Scores2.FREQ_ALL
            time_loc = 0
        elif args['time_scope'] == Scores2.FREQ_WEEK:
            time_scope = Scores2.FREQ_WEEK
            if 'time_loc' in args:
                time_loc = int(args['time_loc'])
            else:
                time_loc = cur_week
        elif args['time_scope'] == Scores2.FREQ_SEASON:
            time_scope = Scores2.FREQ_SEASON
            if 'time_loc' in args:
                time_loc = int(args['time_loc'])
            else:
                time_loc = cur_season
        elif args['time_scope'] == Scores2.FREQ_DAY:
            time_scope = Scores2.FREQ_DAY
            if 'time_loc' in args:
                time_loc = int(args['time_loc'])
            else:
                time_loc = cur_day
        else:
            raise Exception('unknown time_scope %r' % args['time_scope'])

        if 'space_scope' not in args:
            args['space_scope'] = Scores2.SPACE_ALL
            args['space_loc'] = Scores2.SPACE_ALL_LOC

        if args['space_scope'] == Scores2.SPACE_ALL:
            space_scope = Scores2.SPACE_ALL
            space_loc = Scores2.SPACE_ALL_LOC
        elif args['space_scope'] == Scores2.SPACE_CONTINENT:
            space_scope = Scores2.SPACE_CONTINENT
            space_loc = args['space_loc']
            assert space_loc in gamedata['continents']
        elif args['space_scope'] == Scores2.SPACE_REGION:
            space_scope = Scores2.SPACE_REGION
            space_loc = args['space_loc']
            assert space_loc in gamedata['regions']
        else:
            raise Exception('unknown space_scope %r' % args['space_scope'])

        # batch all score queries
        score_addr_list = []

        for stat_name, stat_data in gamedata['strings']['leaderboard']['categories'].iteritems():
            if stat_name in ('time_in_game', 'account_age', 'quarry_resources'): continue
            if stat_data.get('statistics_show_if',None) != {'predicate':'ALWAYS_TRUE'}:
                continue

            cat = {'stat_name': stat_name,
                   'ui_stat_name': stat_data['title'],
                   'ui_stat_description': stat_data['description'],
                   'time_scope': time_scope, 'time_loc': time_loc,
                   'space_scope': space_scope, 'space_loc': space_loc,
                   'leaders': None,
                   }

            if space_scope == Scores2.SPACE_CONTINENT:
                cat['ui_space_loc'] = gamedata['continents'][space_loc]['ui_name']
            elif space_scope == Scores2.SPACE_REGION:
                cat['ui_space_loc'] = gamedata['regions'][space_loc]['ui_name']

            ret['categories'].append(cat)
            query_addr = (stat_name, Scores2.make_point(time_scope, time_loc, space_scope, space_loc))
            score_addr_list.append(query_addr)

        if score_addr_list:
            for cat, result in zip( \
                ret['categories'],
                gamesite.mongo_scores2_client.player_scores2_get_leaders(score_addr_list,
                                                                         10, reason = 'STATSAPI')):
                cat['leaders'] = result


        # to minimize the number of player/alliance queries, batch them all at once
        seen_player_ids = set()
        for cat in ret['categories']:
            if cat['leaders']:
                for entry in cat['leaders']:
                    seen_player_ids.add(entry['user_id'])

        if seen_player_ids:
            # decorate results with player cache properties
            seen_player_id_list = list(seen_player_ids)
            player_info_by_id = dict(zip( \
                seen_player_id_list,
                self.gameapi.do_query_player_cache(None, seen_player_id_list,
                                                   fields = ['ui_name','player_level','alliance_id'],
                                                   get_trophies = False, reason = 'STATSAPI(leaderboard)')))

            seen_alliances = set()
            for cat in ret['categories']:
                if cat['leaders']:
                    for entry in cat['leaders']:
                        player_info = player_info_by_id.get(entry['user_id'], None)
                        if player_info:
                            entry.update(player_info)
                            if player_info.get('alliance_id',-1) > 0:
                                seen_alliances.add(player_info['alliance_id'])

            if seen_alliances:
                seen_alliance_list = list(seen_alliances)
                alinfo_by_id = dict(zip( \
                    seen_alliance_list,
                    gamesite.sql_client.get_alliance_info(seen_alliance_list, reason = 'STATSAPI(leaderboard)')))

                for cat in ret['categories']:
                    if cat['leaders']:
                        for entry in cat['leaders']:
                            if entry.get('alliance_id',-1) > 0:
                                al = alinfo_by_id.get(entry['alliance_id'], None)
                                if al:
                                    entry['alliance_chat_tag'] = al.get('chat_tag', None)

        return SpinJSON.dumps({'result':ret}, newline=True, pretty=False)

    def render_battle(self, args):
        battle_id = args.get('battle_id', -1)
        parsed = AttackLog.parse_battle_id(battle_id)
        if not parsed:
            ret = {'error': 'Bad battle ID %s' % (battle_id)}
        else:
            log_time, attacker_id, defender_id, location = parsed
            hot_summaries = gamesite.nosql_client.battles_get(attacker_id, defender_id, -1, -1, limit = 1,
                                                              time_range = [log_time, log_time+1],
                                                              fields = gamesite.gameapi.BATTLE_HISTORY_FIELDS,
                                                              reason = 'STATSAPI(battle)')
            if not hot_summaries:
                ret = {'error': 'Battle %s not found' % (battle_id)}
            else:
                summary = self.augment_battle_summary(hot_summaries[0])
                ret = {'result': {'summary': summary}}

        return SpinJSON.dumps(ret, newline=True, pretty=False)

    def augment_battle_summary(self, s):
        # add a few extra derived fields to the battle summary that front-ends will find useful

        # battle_log_id, for retrieving the battle log or replay
        if s['base_type'] != 'home' and s.get('base_id'):
            s['battle_log_id'] = '%d-%d-vs-%d-at-%s' % (s['time'], s['attacker_id'], s['defender_id'], s['base_id'])
        else:
            s['battle_log_id'] = '%d-%d-vs-%d' % (s['time'], s['attacker_id'], s['defender_id'])

        # total res1-equivalent value of resource loot
        if 'resource_price_formula_by_townhall_level' in gamedata['store'] and \
           'resource_internal_weight' in gamedata['store']:
            # FS-type resources with varying weights
            # (also see GameDataUtil.ResourceValuation)
            cheapest_value = max(gamedata['store']['resource_price_formula_by_townhall_level'][resname][-1] \
                                 for resname in gamedata['resources'])
            relative_res = dict((resname, cheapest_value / gamedata['store']['resource_price_formula_by_townhall_level'][resname][-1]) \
                                for resname in gamedata['resources'])
            res_internal_weight = gamedata['store']['resource_internal_weight']

            res_weights = dict((resname, relative_res[resname]*res_internal_weight[resname]) \
                               for resname in gamedata['resources'])

        else:
            res_weights = dict((resname, 1) for resname in gamedata['resources'])

        # news_* values: see get_news.py for explanation
        if 'loot' in s:
            s['news_loot_value'] = sum(((s['loot'].get(resname,0) * res_weights[resname]) for resname in gamedata['resources']), 0)
        if 'damage' in s:
            s['news_unit_damage'] = 0
            for uid, udamage in s['damage'].iteritems():
                for specname, damage in udamage.iteritems():
                    s['news_unit_damage'] += damage.get('time', 0)

        return s

# REST interface used by proxyserver, PCHECK, and other game servers to communicate with us
class CONTROLAPI(resource.Resource):
    isLeaf = True
    def __init__(self, gameapi):
        resource.Resource.__init__(self)
        self.gameapi = gameapi

    def render_POST(self, request): return self.render_GET(request)
    def render_GET(self, request):
        update_server_time()
        ret = None

        if 'method' in request.args:
            secret = str(request.args['secret'][0]) if 'secret' in request.args else ''
            method = str(request.args['method'][0])

            admin_stats.controlapi_calls_by_method[method] = admin_stats.controlapi_calls_by_method.get(method,0) + 1

            # Twisted gives us request.args in the form of (post-url-decoded) raw bytes
            # I think in most cases we want to immediately convert to Unicode strings here.
            # Though maybe a future bulk-data-transfer call would want to preserve raw bytes?
            args = {}
            for k, v in request.args.iteritems():
                if k not in ('secret','method'):
                    try:
                        args[k] = unicode(v[0].decode('utf-8'))
                    except UnicodeDecodeError:
                        gamesite.exception_log.event(server_time, 'CONTROLAPI call with invalid Unicode arg: %s %r %r' % (k, type(v[0]), v[0]))
                        request.setResponseCode(http.BAD_REQUEST)
                        return SpinJSON.dumps({'error':'Arguments contain invalid Unicode'})

            with admin_stats.latency_measurer('CONTROLAPI(ALL)'):
                with admin_stats.latency_measurer('CONTROLAPI(HTTP:%s)' % method):
                    ret = catch_all('CONTROLAPI (method %r args %r)' % (method, args))(self.handle)(request, secret, method, args)

        if ret is None:
            request.setResponseCode(http.BAD_REQUEST)
            ret = 'error\n'
        return ret

    def kill_session(self, request, session, body = None):
        if not body: body = 'ok\n'
        if not session.logout_in_progress:
            session.send([["ERROR", "KILL_SESSION"]], flush_now = True)
        d = self.gameapi.log_out_async(session, 'forced_relog')
        d.addCallback(lambda _, session=session: ascdebug('kill_session %d %s async end' % (session.user.user_id, session.session_id)))
        d.addCallback(lambda _, body=body, request=request: SpinHTTP.complete_deferred_request(body, request))

        return server.NOT_DONE_YET

    # function for receiving cross-server IPC broadcasts
    def chat_recv(self, channel, id, sender_info, text):
        assert channel == 'CONTROL'
        if gamedata['server']['log_controlapi']:
            gamesite.exception_log.event(server_time, 'CONTROLAPI(CHAT): %s got %s %s' % (spin_server_name, repr(sender_info), text))
        ret = None

        try:
            with admin_stats.latency_measurer('CONTROLAPI(CHAT:%s)' % sender_info['method']):
                ret = self.handle(None, sender_info['secret'], sender_info['method'], sender_info['args'])
        except:
            gamesite.exception_log.event(server_time, 'CONTROL chat_recv exception method %r args %r: %s' % (sender_info['method'], sender_info['args'], traceback.format_exc().strip())) # OK

        return ret

    # encapsulate state needed to load, lock, mutate, then store player and user JSON structs
    class AsyncSupport(object):
        def __init__(self, user_id, method_name, handler, d):
            self.user_id = user_id
            self.method_name = method_name
            self.handler = handler
            self.d = d
            self.player_raw = None
            self.user_raw = None
            self.has_player = False
            self.has_user = False
            self.wrote_player = False
            self.wrote_user = False

            # if not None, we hold the lock (-1 = any generation, otherwise current generation)
            self.player_lock_gen = None

            self.error = None
            self.val = None # return value
        def start(self):
            if self.handler.need_player:
                io_system.async_read_player(self.user_id, self.player_read_success, self.player_read_error, reason='CustomerSupport')
            else:
                self.has_player = True
                self.player_raw = ''
            if self.handler.need_user:
                io_system.async_read_user(self.user_id, self.user_read_success, self.user_read_error, reason='CustomerSupport')
            else:
                self.has_user = True
                self.user_raw = ''
            self.try_mutate()
        def player_read_error(self, reason):
            self.has_player = True
            self.error = reason
            self.try_mutate()
        def player_read_success(self, buf):
            self.has_player = True
            if buf != 'NOTFOUND':
                self.player_raw = buf
            else:
                self.error = 'player not found'
            self.try_mutate()
        def user_read_error(self, reason):
            self.has_user = True
            self.error = reason
            self.try_mutate()
        def user_read_success(self, buf):
            self.has_user = True
            if buf != 'NOTFOUND':
                self.user_raw = buf
            else:
                self.error = 'user not found'
            self.try_mutate()
        def try_mutate(self):
            if (not self.has_player) or (not self.has_user): return # I/O not done yet
            if (self.player_raw is None) or (self.user_raw is None) or self.error:
                # failed reading - stop here, don't write
                self.d.callback(CustomerSupport.ReturnValue(error = 'error on player %d: %s' % (self.user_id, self.error or 'unknown')))
                return
            try:
                if self.handler.want_raw:
                    player_json = None
                    user_json = None
                    self.val = self.handler.exec_offline_raw(self.user_raw, self.player_raw)

                    # note: no lock here - we assume there is no mutation
                    assert self.handler.read_only

                else:
                    if self.handler.need_player:
                        player_json = SpinJSON.loads(self.player_raw)
                        gen = player_json.get('generation', 0)

                        log_player_io('PLAYER', 'READ', self.user_id, gen, 'CustomerSupport')

                        if not self.handler.read_only:
                            state, lock_gen = gamesite.lock_client.player_lock_acquire_detailed(self.user_id, gen, Player.LockState.being_attacked, -1, reason='CustomerSupport')
                            if state != Player.LockState.being_attacked:
                                self.d.callback(CustomerSupport.ReturnValue(error = 'player %d offline but locked, or gen mismatch %r vs %r' % \
                                                                            (self.user_id, gen, lock_gen),
                                                                            http_status = 503, # service unavailable
                                                                            retry_after = 15))
                                return # abort the sequence
                            self.player_lock_gen = gen # we have the lock!

                    else:
                        player_json = None

                    if self.handler.need_user:
                        user_json = SpinJSON.loads(self.user_raw)

                        # grab lock. Don't care about generation counter.
                        if not self.handler.read_only and self.player_lock_gen is None:
                            state = gamesite.lock_client.player_lock_acquire_attack(self.user_id, -1, owner_id=-1, reason='CustomerSupport')
                            if state != Player.LockState.being_attacked:
                                self.d.callback(CustomerSupport.ReturnValue(error = 'player %d offline but locked' % \
                                                                            (self.user_id,),
                                                                            http_status = 503, # service unavailable
                                                                            retry_after = 15))
                                return # abort the sequence
                            self.player_lock_gen = -1 # we have the lock!

                    else:
                        user_json = None
                    self.val = self.handler.exec_offline(user_json, player_json)

                assert self.val and isinstance(self.val, CustomerSupport.ReturnValue)

            except:
                gamesite.exception_log.event(server_time, 'CustomerSupport offline exception player %d method %r args %r: %s' % (self.user_id, self.method_name, self.handler.args, traceback.format_exc().strip())) # OK
                self.unlock()
                self.d.callback(CustomerSupport.ReturnValue(error = traceback.format_exc().strip())) # OK
                return

            if self.val.async:
                assert isinstance(self.val.async, defer.Deferred) # sanity check

                def offline_error(fail, self):
                    gamesite.exception_log.event(server_time, 'CustomerSupport offline async exception player %d method %r args %r: %s' % \
                                                 (self.user_id, self.method_name, self.handler.args, fail.getTraceback().strip())) # OK
                    self.wrote_player = self.wrote_user = True # prevent writes from happening
                    # turn exception into a regular result
                    return CustomerSupport.ReturnValue(error = fail.getTraceback().strip()) # OK

                self.val.async.addErrback(offline_error, self) # and pass though errors to...
                self.val.async.addCallback(self.post_mutate, player_json, user_json) # return value of val.async will then replace self.val
            else:
                self.post_mutate(None, player_json, user_json)

        def post_mutate(self, override_result, player_json, user_json): # handler finished, now perform final I/O
            if override_result is not None: # swap in new result from async code
                self.val = override_result

            if self.handler.read_only:
                self.wrote_player = self.wrote_user = True # prevent writes from happening
            else:
                if self.handler.need_player and not self.wrote_player:
                    assert player_json
                    assert self.player_lock_gen is not None
                    if self.player_lock_gen != -1:
                        self.player_lock_gen = player_json['generation'] = self.player_lock_gen + 1
                    player_buf = SpinJSON.dumps(player_json, pretty = True, newline = True, size_hint = 1024*1024, double_precision = 5)
                    log_player_io('PLAYER', 'WRITE', self.user_id, self.player_lock_gen, 'CustomerSupport')
                    io_system.async_write_player(self.user_id, player_buf, self.player_write_success, False, reason='CustomerSupport')
                else:
                    self.wrote_player = True
                if self.handler.need_user and not self.wrote_user:
                    assert user_json
                    user_buf = SpinJSON.dumps(user_json, pretty = True, newline = True, size_hint = 1024*1024, double_precision = 5)
                    io_system.async_write_user(self.user_id, user_buf, self.user_write_success, False, reason='CustomerSupport')
                else:
                    self.wrote_user = True

            self.try_finish()

        def player_write_success(self):
            self.wrote_player = True
            self.try_finish()
        def user_write_success(self):
            self.wrote_user = True
            self.try_finish()
        def unlock(self):
            if self.player_lock_gen is not None:
                gamesite.lock_client.player_lock_release(self.user_id, self.player_lock_gen, Player.LockState.being_attacked, expected_owner_id = -1)
                self.player_lock_gen = None
        def try_finish(self):
            if (not self.wrote_player) or (not self.wrote_user): return # I/O not done yet
            self.unlock()
            assert isinstance(self.val, CustomerSupport.ReturnValue) and (not self.val.async)
            self.d.callback(self.val)

    def handle(self, request, secret, method_name, args):
        # require proxy_api_secret, but not for method=ping
        if method_name != 'ping':

            # Python 2.6 compatibility - insecure replacement for hmac.compare_digest()
            def compare_digest(a, b):
                if hasattr(hmac, 'compare_digest'):
                    return hmac.compare_digest(a, b)
                return a == b

            if not compare_digest(bytes(secret), bytes(SpinConfig.config['proxy_api_secret'])):
                request.setResponseCode(http.UNAUTHORIZED)
                return 'unauthorized\n'

        if (method_name in CustomerSupport.methods):
            # new-style CustomerSupport handlers that operate on a session or playerdb/userdb backing store
            user_id = None
            if 'user_id' in args:
                user_id = int(args['user_id'])
            elif 'facebook_id' in args:
                user_id = gamesite.social_id_table.social_id_to_spinpunch('fb'+args['facebook_id'], False)
            if not user_id:
                raise Exception('must supply user_id or facebook_id')

            handler = CustomerSupport.methods[method_name](server_time, user_id, gamedata, gamesite, args)

            # see if the user is logged in
            session = get_session_by_user_id(user_id)

            if session:
                # ONLINE edit

                ret = server.NOT_DONE_YET

                def handle_online(request, session, handler, method_name, args, _):
                    try:
                        val = handler.exec_online(session, session.outgoing_messages)
                    except:
                        gamesite.exception_log.event(server_time, 'CustomerSupport online exception player %d method %r args %r: %s' % \
                                                     (session.user.user_id, method_name, args, traceback.format_exc().strip())) # OK
                        val = CustomerSupport.ReturnValue(error = traceback.format_exc().strip()) # OK

                    if val.async:
                        assert isinstance(val.async, defer.Deferred) # sanity check

                        def online_error(fail, session, method_name, args):
                            gamesite.exception_log.event(server_time, 'CustomerSupport online async exception player %d method %r args %r: %s' % \
                                                         (session.user.user_id, method_name, args, fail.getTraceback().strip())) # OK
                            # turn exception into a regular result
                            return CustomerSupport.ReturnValue(error = fail.getTraceback().strip()) # OK

                        val.async.addErrback(online_error, session, method_name, args)

                        session.start_async_request(val.async)
                        val.async.addCallback(lambda async_result, request=request: SpinHTTP.complete_deferred_request(async_result.as_body(), request, http_status = async_result.http_status))

                    else:
                        if val.kill_session:
                            assert not val.http_status # awkward to pass this
                            ret = self.kill_session(request, session, body = val.as_body()) # this adds complete_deferred_request() when necessary
                        else:
                            ret = val.as_body()
                        session.queue_flush_outgoing_messages()
                        SpinHTTP.complete_deferred_request(ret, request, http_status = val.http_status)

                d = make_deferred('CustomerSupport:'+method_name+'(online)')

                # if player logged out, this is going to fail
                def handle_online_race(request, fail):
                    fail.trap(Session.AlreadyLoggedOut)
                    return_val = CustomerSupport.ReturnValue(error = 'Race condition: Player %d just logged out. Please try again.' % user_id,
                                                             http_status = 503, # service unavailable
                                                             retry_after = 15)
                    SpinHTTP.complete_deferred_request(return_val.as_body(), request, http_status = return_val.http_status)

                d.addCallbacks(functools.partial(handle_online, request, session, handler, method_name, args),
                               functools.partial(handle_online_race, request))

                session.after_async_request(d)

            else:
                # OFFLINE edit
                d = make_deferred('CustomerSupport:'+method_name+'(offline)')
                d.addCallback(lambda val, request=request: SpinHTTP.complete_deferred_request(val.as_body(), request, http_status = val.http_status))
                self.AsyncSupport(user_id, method_name, handler, d).start()
                ret = server.NOT_DONE_YET

        else:

            # custom handlers that do not work with live sessions
            # these are more for server-global operations, plus the terminate_session special case

            handler = getattr(self, 'handle_'+method_name, None)
            if handler is None:
                request.setResponseCode(http.BAD_REQUEST)
                return 'badmethod\n'

            self.trim_args(handler, args)
            ret = handler(request, **args)

        # note: can go asynchronous
        return ret if (ret is not None) else 'ok\n'

    # for forwards-compatibity, prevent CONTROLAPI crashes when receiving unexpected keyword arguments from new code
    warned_args = set()
    def trim_args(self, handler, passed_args):
        named_args, var_args, varkw, defaults = inspect.getargspec(handler)
        if varkw: return passed_args # function accepts **kwargs
        for p in passed_args.keys():
            if p not in named_args:
                key = (handler.__name__, p) # unique tuple to only warn once
                if key not in self.warned_args:
                    self.warned_args.add(key)
                    gamesite.exception_log.event(server_time, '%s: Dropping unrecognized arg "%s"' % \
                                                 (handler.__name__, p))
                del passed_args[p]
        return passed_args

    def handle_terminate_session(self, request, session_id = None):
        # remember that this ID is invalid, in case the client tries to use it again
        invalid_sessions[session_id] = invalid_sessions.get(session_id, 0) + 1
        invalid_sessions_by_time.append((server_time, session_id))

        # collect garbage
        while len(invalid_sessions_by_time) > 0 and (server_time - invalid_sessions_by_time[0][0]) >= gamedata['server']['session_signature_time_tolerance']:
            t, sid = invalid_sessions_by_time.popleft()
            invalid_sessions[sid] -= 1
            if invalid_sessions[sid] <= 0:
                del invalid_sessions[sid]

        self.gameapi.AsyncLogin.cancel_existing(None, session_id)

        if session_id in session_table: # note: we DO want to see logout_in_progress sessions here, to wait until they finish logout before responding
            # note: this goes asynchronous
            ascdebug('terminate_session %s async start' % (session_id))
            return self.kill_session(request, session_table[session_id])
        else:
            # still return 'ok' even if session was not found, since it may have timed out
            ascdebug('terminate_session %s ok' % (session_id))
            return 'ok\n'

    def handle_sql_on(self, request):
        gamesite.sql_init()
    def handle_sql_off(self, request):
        gamesite.sql_shutdown()
    def handle_nosql_on(self, request):
        gamesite.nosql_init()
    def handle_nosql_off(self, request):
        gamesite.nosql_shutdown()
    def handle_fail_websockets(self, request):
        # for testing WebSocket interruption
        for session in session_table.itervalues():
            if isinstance(session.longpoll_request, WSFakeRequest):
                session.longpoll_request.proto.close_connection_aggressively(True)
                session.longpoll_request = None

    def handle_maint_kick(self, request):
        return SpinJSON.dumps({'result': gamesite.start_maint_kick()}, newline=True)
    def handle_panic_kick(self, request):
        gamesite.panic_kick(request.channel.transport)
        return SpinJSON.dumps({'result': 'ok'})
    def handle_change_state(self, request, state = None):
        return SpinJSON.dumps({'result':gamesite.change_state(state)}, newline=True)
    def handle_reconfig(self, request):
        return SpinJSON.dumps({'result':gamesite.reconfig()}, newline=True)
    def handle_shutdown(self, request, force = False):
        if (not force) and len(session_table) > 0:
            return SpinJSON.dumps({'error':'not shutting down - %d sessions still active\n' % len(session_table)})

        # redundant with gamesite.shutdown(), but makes the status_json result show correct shutting_down state
        status_json = gamesite.change_state('shutting_down')

        request.setHeader('Connection', 'close')
        reactor.stop()

        return SpinJSON.dumps({'result':status_json}, newline=True)

    def handle_ping(self, request):
        pass
    def handle_sleep(self, request, duration = 5):
        time.sleep(float(duration))
    def handle_admin_stats_reset(self, request):
        admin_stats.reset()
    def handle_reimport(self, request, module = None):
        reload(globals()[module])
        gamesite.exception_log.event(server_time, 'reloaded module %s!' % module)
    def handle_setup_ai_base(self, request, idnum = None):
        setup_ai_base(str(idnum), lambda: SpinHTTP.complete_deferred_request(SpinJSON.dumps({'result':'ok'}), request))
        return server.NOT_DONE_YET
    def handle_server_eval(self, request, expr = None):
        result = eval(expr)
        ui_result = ('\n'+result) if isinstance(result, basestring) else (' '+repr(result))
        gamesite.exception_log.event(server_time, 'eval %s ->%s' % (expr, ui_result))
        return SpinJSON.dumps({'result': repr(result)}, newline=True)
    def handle_system_announcement(self, request, body = None):
        for session in iter_sessions():
            for channel in ('GLOBAL', 'ALLIANCE', 'REGION'):
                session.chat_recv(channel, None, {'chat_name':'System', 'type':'system', 'time': server_time, 'facebook_id':'-1', 'user_id':-1}, body)

    # one server gets this request, and then it goes out to all local sessions and other servers via broadcast
    def handle_censor_chat_message(self, request, channel = None, message_id = None, target_user_id = None, new_type = None):
        assert channel and message_id
        if target_user_id: target_user_id = int(target_user_id)
        gamesite.chat_mgr.send(channel, None,
                               {'time': server_time,
                                'type': 'message_hide', 'new_type': (new_type or 'abuse_violated'),
                                'chat_name': 'System', 'user_id': -1,
                                'target_user_id': target_user_id,
                                'target_message_id': message_id}, '', log = True)
        return SpinJSON.dumps({'result': 'ok'}, newline=True)
    def handle_broadcast_map_update(self, request, region_id = None, base_id = None, data = None, server = None, originator = None, map_time = None):
        assert region_id and base_id and server
        # note: ignore our own broadcasts
        if server != spin_server_name:
            self.gameapi.broadcast_map_update(region_id, base_id, data, originator, send_to_net = False, map_time = map_time)
    def handle_broadcast_map_attack(self, request, msg = None, region_id = None, feature = None,
                                    attacker_id = None, defender_id = None, summary = None, pcache_info = None, server = None, map_time = None):
        # note: ignore our own broadcasts
        if server != spin_server_name:
            self.gameapi.broadcast_map_attack(region_id, feature, attacker_id, defender_id, summary, pcache_info, msg = msg, send_to_net = False, map_time = map_time)
    def handle_broadcast_turf_update(self, request, region_id = None, data = None):
        for session in iter_sessions():
            if session.player.home_region == region_id:
                session.send([["REGION_TURF_UPDATE", session.player.home_region, data]])

class Store(object):

    # given a list of damaged units and/or in-production manuf queue items, return a dictionary mapping
    # from unit specname to rough gamebucks equivalent of speedup cost.
    @classmethod
    def get_unit_cost_detail(cls, session, player, damaged_obj_list = [], manuf_queue = [], manuf_prog = 0):
        ret = {'non_squad':{}, 'squad':{}}
        # note: assumes that object HP values are up to date
        for obj in damaged_obj_list:
            r = ret['squad' if SQUAD_IDS.is_mobile_squad_id(obj.squad_id or 0) else 'non_squad']
            r[obj.spec.name] = r.get(obj.spec.name,0) + obj.cost_to_repair(player)['time']
        for item in manuf_queue:
            t = max(0, item['total_time'] - manuf_prog)
            manuf_prog = max(0, manuf_prog - item['total_time'])
            ret['non_squad'][item['spec_name']] = ret['non_squad'].get(item['spec_name'],0) + t

        # convert from seconds to (fractional) gamebucks
        return dict((kind, dict((specname, Store.get_speedup_price(player, 'unit_repair', seconds, 'gamebucks', quantize = False)) \
                    for specname, seconds in ret[kind].iteritems())) \
                    for kind in ret if ret[kind])

    @classmethod
    def get_free_speedup_time(cls, session, player):
        return Predicates.eval_cond_or_literal(player.get_any_abtest_value('free_speedup_time', gamedata['store']['free_speedup_time']), session, player)

    # for historical reasons, the core time/cost computation is done in units of fbcredits
    @classmethod
    def get_speedup_price_fbcredits(cls, player, kind, seconds):
        mins_per_credit = player.get_any_abtest_value('speedup_minutes_per_credit', gamedata['store']['speedup_minutes_per_credit'])
        if type(mins_per_credit) is dict:
            mins_per_credit = mins_per_credit.get(kind, mins_per_credit['default'])
        return (seconds/60.0)/mins_per_credit

    @classmethod
    def get_speedup_price(cls, player, kind, seconds, currency, quantize = True):
        fbcredits_price = Store.get_speedup_price_fbcredits(player, kind, seconds)
        if currency == 'gamebucks':
            ret = player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) * fbcredits_price
        elif currency == 'fbcredits':
            ret = fbcredits_price
        else:
            raise Exception('unhandled currency '+currency)

        if quantize: # snap to next-highest integer price
            return int(ret) + 1
        return ret

    # get price in either FB credits or user's currency
    # this must match Store.get_price in the game client code, or else there will be trouble!!!
    # return -1 if the order is invalid (e.g. because upgrade/research requirements are not met)
    @classmethod
    def get_price(cls, session, sale_currency, unit_id, spell, spellarg, price_description, error_reason, override_time = None):

        p, p_currency = Store.get_base_price(session, unit_id, spell, spellarg, price_description, error_reason, sale_currency, override_time = override_time)

        if p <= 0:
            return p

        # only check for currency match when price > 0
        if (not (sale_currency.startswith('item:') or sale_currency.startswith('score:') or (sale_currency in gamedata['resources']))):
            spell_currency = spell.get('currency', session.player.get_any_abtest_value('currency', gamedata['currency']) if session else gamedata['currency'])
            # wildcard matches for unknown real currencies
            # note: "fbpayments:*" is actually the currency name, it's not intended to be a regexp or prefix match
            # this currency is on the "FB_GAMEBUCKS_PAYMENT" SKU which is used to represent payments in currencies
            # that our systems do not recognize.
            if spell_currency == 'fbpayments:*' and sale_currency.startswith('fbpayments:') or \
               spell_currency == 'xsolla:*' and sale_currency.startswith('xsolla:'):
                pass
            elif sale_currency != spell_currency:
                error_reason.append('buyer offered %s but spell can only be bought with %s' % (sale_currency, spell_currency))
                return -1

        # convert base price currency to what the buyer wants to pay with
        if sale_currency == p_currency:
            return p
        elif sale_currency == 'fbcredits':
            if p_currency == 'gamebucks':
                return int(p/(session.player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) if session else gamedata['store']['gamebucks_per_fbcredit']))+1
            else:
                error_reason.append('unknown p_currency '+p_currency)
                return -1
        elif sale_currency == 'gamebucks':
            if p_currency == 'fbcredits':
                return p * (session.player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) if session else gamedata['store']['gamebucks_per_fbcredit'])
            else:
                error_reason.append('unknown p_currency '+p_currency)
                return -1
        else:
            error_reason.append('unknown sale currency '+sale_currency)
            return -1

    # look through the store catalog for the SKU representing this BUY_ITEM spellarg
    @classmethod
    def buy_item_find_skudata(cls, spellarg, player):
        catpath = spellarg.get('catpath',None)
        specname = spellarg['skudata'].get('item',None)
        tablename = spellarg['skudata'].get('loot_table',None)
        if (not catpath) or (not specname and not tablename): return None
        stack = spellarg['skudata'].get('stack', 1) if specname else 1
        level = spellarg['skudata'].get('level', 1) if specname else 1
        melt_time = spellarg['skudata'].get('melt_time',-1)
        melt_dur = spellarg['skudata'].get('melt_duration',-1)
        tm = player.get_absolute_time()

        cat = None
        catlist = gamedata['store']['catalog']
        for pat in catpath:
            cat = None
            for entry in catlist:
                if ('name' in entry) and (entry['name'] == pat) and \
                   (('activation' not in entry) or (Predicates.read_predicate(entry['activation']).is_satisfied(player,None))) and \
                   (('start_time' not in entry) or (entry['start_time'] < tm)) and \
                   (('expire_time' not in entry) or (entry['expire_time'] >= tm)):
                    cat = entry
                    break
            if not cat: return None
            catlist = entry.get('skus', [])

        if not cat: return None

        ret = None
        pr = -1

        def sku_match(skudata, player, specname, tablename, level, stack, melt_time, melt_dur, tm):
            assert (specname and not tablename) or (tablename and not specname) # either one, not both
            if ('price' not in skudata): return False
            if (melt_time > 0) and (tm >= melt_time): return False
            if ('expire_time' in skudata) and (tm >= skudata['expire_time']): return False
            if ('start_time' in skudata) and (tm < skudata['start_time']): return False
            if specname:
                if (skudata.get('item',None) != specname) or (skudata.get('stack',1) != stack) or (skudata.get('level',1) != level): return False
            elif tablename:
                if skudata.get('loot_table',None) != tablename: return False
            if (skudata.get('melt_time',-1) != melt_time): return False
            if (skudata.get('melt_duration',-1) != melt_dur): return False
            if ('show_if' in skudata) and (not Predicates.read_predicate(skudata['show_if']).is_satisfied(player, None)): return False
            if ('requires' in skudata) and (not Predicates.read_predicate(skudata['requires']).is_satisfied(player, None)): return False
            return True

        for skudata in cat['skus']:
            if sku_match(skudata, player, specname, tablename, level, stack, melt_time, melt_dur, tm):
                skudata_price = Predicates.eval_cond_or_literal(skudata['price'], None, player)
                if pr < 0 or skudata_price < pr:
                    ret = skudata
                    pr = skudata_price

        # also look in extra_store_specials
        if catpath[0] == 'specials':
            for test_name, group in player.abtests.iteritems():
                if (test_name in gamedata['abtests']) and gamedata['abtests'][test_name]['active']:
                    data = gamedata['abtests'][test_name]['groups'][group]
                    if ('extra_store_specials' in data):
                        extras = data['extra_store_specials'];
                        for skudata in extras:
                            if sku_match(skudata, player, specname, tablename, level, stack, melt_time, melt_dur, tm):
                                skudata_price = Predicates.eval_cond_or_literal(skudata['price'], None, player)
                                if pr < 0 or skudata_price < pr:
                                    ret = skudata
                                    pr = skudata_price

        return ret

    # get_base_price returns the "base" FB credits price before A/B test price caps are applied
    @classmethod
    def get_base_price(cls, session, unit_id, spell, spellarg, price_description, error_reason, sale_currency, override_time = None):
        assert spell.has_key('paid')
        p_currency = 'fbcredits'

        for PRED in ('requires',): # XXXXXX this never checked show_if - should it?
            if PRED in spell:
                if session and (not Predicates.read_predicate(spell[PRED]).is_satisfied2(session, session.player, None, override_time = override_time)):
                    error_reason.append('spell "%s" predicate is not satisfied' % PRED)
                    return -1, p_currency

        if 'cooldown_name' in spell:
            cd_name = spell['cooldown_name']
            if session.player.cooldown_active(cd_name):
                to_go = session.player.cooldowns[cd_name]['end'] - server_time
                error_reason.append('spell cooldown %s has not expired yet (%d sec to go)' % (cd_name, to_go))
                return -1, p_currency

        if spell.get('flash_offer',False) and session and session.player.flash_offer != spell['flash_offer']:
            error_reason.append('offer "%s" is not active' % spell['flash_offer'])
            return -1, p_currency

        formula = spell['price_formula']
        if formula == 'constant':
            if 'currency' in spell: p_currency = spell['currency']
            return spell['price'], p_currency
        elif formula == 'item':
            skudata = Store.buy_item_find_skudata(spellarg, session.player)
            if not skudata or ('price' not in skudata):
                error_reason.append('skudata not found for %s' % repr(spellarg))
                return -1, p_currency

            stack = spellarg.get('stack',1)
            assert stack >= 1

            if 'item' in spellarg['skudata']:
                if spellarg['skudata']['item'] not in gamedata['items']:
                    error_reason.append('item "%s" does not exist' % spellarg['skudata']['item'])
                    return -1, p_currency
                spec = gamedata['items'][spellarg['skudata']['item']]

                if ('store_requires' in spec) and (not Predicates.read_predicate(spec['store_requires']).is_satisfied2(session, session.player, None)):
                    error_reason.append('item "%s" store_requires predicate failed' % spellarg['spec'])
                    return -1, p_currency

            elif 'loot_table' in spellarg['skudata']:
                if spellarg['skudata']['loot_table'] not in gamedata['loot_tables']:
                    error_reason.append('loot table "%s" does not exist' % spellarg['skudata']['loot_table'])
                    return -1, p_currency

            p_currency = skudata.get('price_currency', p_currency)
            return Predicates.eval_cond_or_literal(skudata['price'], session, session.player), p_currency

        elif formula == 'fb_inapp_currency_fbcredits':
            # charge at least as much as the gamebucks are worth in credits
            # OLD fbcredits method
            return max(1, int(math.ceil(spellarg / float(gamedata['store']['gamebucks_per_fbcredit'])))), p_currency
        elif formula == 'fb_inapp_currency_gamebucks':
            p_currency = 'gamebucks'
            return spellarg, p_currency
        elif formula == 'arbitrary_real_currency':
            # NEW fbpayments method
            p_currency = sale_currency
            real_currency = str(sale_currency.split(':')[1])
            for curname, srate in gamedata['store']['gamebucks_open_graph_prices']:
                if curname == real_currency:
                    return spellarg * float(srate), p_currency
            error_reason.append('gamedata.store.gamebucks_open_graph_prices has no entry for currency "%s"' % real_currency)
            return -1, p_currency
        elif formula == 'gamebucks_topup':
            bucks_per_credit = session.player.get_any_abtest_value('gamebucks_per_fbcredit_topup', gamedata['store']['gamebucks_per_fbcredit_topup'])
            if bucks_per_credit < 0:
                error_reason.append('gamebucks topup SKU not enabled for this player')
                return -1, p_currency
            return max(1, int(math.ceil(spellarg / float(bucks_per_credit)))), p_currency
        elif formula.startswith('barrier_upgrade'):
            min_level = 99
            for obj in session.player.home_base_iter():
                if obj.spec.name == 'barrier':
                    min_level = min(min_level, obj.level)
            up_level = int(formula[-1])
            if min_level >= up_level:
                error_reason.append('no barriers are beneath the upgrade level for this purchase')
                return -1, p_currency
            return spell['price'], p_currency
        elif formula.startswith('grow_base_perimeter'):
            to_level = int(formula[-1])
            if session.viewing_base is not session.player.my_home:
                error_reason.append('can only run this SKU at home base')
                return -1, p_currency
            if session.viewing_base.base_size >= to_level:
                error_reason.append('player base is already grown to this size')
                return -1, p_currency
            if 'currency' in spell: p_currency = spell['currency']
            return spell['price'], p_currency
        elif formula == 'speedup' or formula == 'speedup_gamebucks':

            # possible race condition due to unserialized AJAX
            if not session.has_object(unit_id):
                error_reason.append('race condition - object does not exist in session')
                return -1, p_currency
            unit = session.get_object(unit_id)

            if unit.owner is not session.player:
                error_reason.append('player does not own this object')
                return -1, p_currency
            if (not unit.spec.quarry_upgradable) and (unit not in session.player.home_base_iter()):
                error_reason.append('this object is not in the player\'s home base, and is not quarry_upgradable')
                return -1, p_currency

            if unit.is_damaged() and (not unit.is_repairing()):
                error_reason.append('cannot speed up an object that is damaged but not repairing')
                return -1, p_currency

            fin_time = unit.activity_finish_time()
            if fin_time < 0:
                error_reason.append('object is not doing anything')
                return -1, p_currency
            price_description.append(unit.activity_description(session.player))
            time_to_finish = fin_time - server_time

            allow_free_speedup = True
            always_free_speedup = False

            # check permission to speed up something other than a repair or upgrade
            if unit.is_building() and (not unit.is_repairing()) and (not unit.is_upgrading()) and (not unit.is_under_construction()):
                if unit.is_manufacturing():
                    if not session.player.unit_speedups_enabled():
                        return -1, p_currency

                    always_free_speedup = True
                    for item in unit.manuf_queue:
                        item_spec = session.player.get_abtest_spec(GameObjectSpec, item['spec_name'])
                        if item_spec.get_leveled_quantity(item_spec.always_free_speedup, item['level']):
                            continue
                        else:
                            always_free_speedup = False

                        if item_spec.get_leveled_quantity(item_spec.no_free_speedup, item['level']):
                            allow_free_speedup = False

                if unit.is_crafting():
                    if not session.player.crafting_speedups_enabled():
                        return -1, p_currency
                    for entry in unit.crafting.queue:
                        recipe = gamedata['crafting']['recipes'].get(entry.craft_state['recipe'],None)
                        if recipe:
                            cat = gamedata['crafting']['categories'][recipe['crafting_category']]
                            if not cat.get('speedupable', True):
                                return -1, p_currency

            # subtract additional "grace period" to work around
            # fencepost issues when client's clock is just slightly
            # behind server's clock (e.g. 9m59s vs. 10m01s)
            time_to_finish -= 60

            if always_free_speedup:
                error_reason.append('all queued units have always_free_speedup (%d sec)' % time_to_finish)
                return 0, p_currency
            if allow_free_speedup and time_to_finish <= Store.get_free_speedup_time(session, session.player):
                # this isn't really an error, it just means the price should be zero. We still accept
                # the order if the client offers more than zero credits.
                error_reason.append('within free activity speedup time (%d sec)' % time_to_finish)
                return 0, p_currency
            else:
                if allow_free_speedup and (not session.player.get_any_abtest_value('count_free_speedup_time', gamedata['store']['count_free_speedup_time'])):
                    time_to_finish -= Store.get_free_speedup_time(session, session.player)
                time_to_finish = max(time_to_finish, 0)
                price_description.append('%.1fmin' % (time_to_finish/60))

                # apply upgrade_speedup_cost_factor
                if unit.is_building() and (not unit.is_repairing()) and unit.is_upgrading():
                    factor = unit.spec.get_leveled_quantity(unit.spec.upgrade_speedup_cost_factor, unit.level + 1)
                    time_to_finish *= factor

                if formula == 'speedup_gamebucks':
                    p_currency = 'gamebucks'
                price = Store.get_speedup_price(session.player, unit.activity_speedup_kind(), time_to_finish, p_currency)
                return price, p_currency

        elif formula == 'player_aura_speedup_gamebucks':
            aura_name = spellarg
            p_currency = 'gamebucks'

            aura_spec = gamedata['auras'].get(aura_name)
            if (not aura_spec) or not aura_spec.get('speedupable', 0):
                error_reason.append('invalid or non-speedupable aura: %s' % aura_name)
                return -1, p_currency

            aura = None
            for a in session.player.player_auras_iter_const():
                if a['spec'] == aura_name and ('end_time' in a):
                    aura = a
                    break
            if not aura:
                error_reason.append('aura not found: %s' % aura_name)
                return -1, p_currency

            time_to_finish = max(aura['end_time'] - server_time, 0)
            price = Store.get_speedup_price(session.player, 'player_aura', time_to_finish, p_currency)
            return price, p_currency
        elif formula == 'squad_movement_speedup_gamebucks':
            if not session.player.squad_speedups_enabled():
                return -1, p_currency
            squad_id = spellarg
            p_currency = 'gamebucks'
            squad = session.player.verify_squad(squad_id, require_at_home = False, require_away = True)
            if session.player.squad_is_moving(squad_id, assume_moving = True):
                time_to_finish = max(squad['map_path'][-1]['eta'] - server_time, 1)
            else:
                time_to_finish = 1 # minimum time
            price = Store.get_speedup_price(session.player, 'squad_movement', time_to_finish, p_currency)
            return price, p_currency
        elif formula == 'unit_repair_speedup' or formula == 'unit_repair_speedup_gamebucks':
            if not session.player.unit_speedups_enabled():
                return -1, p_currency

            if len(session.player.unit_repair_queue) < 1:
                error_reason.append('repair queue is empty (xp=%d)' % session.player.resources.xp)
                return -1, p_currency

            price_description.append('unit_repair')
            time_to_finish = session.player.unit_repair_queue[-1]['finish_time'] - server_time
            if (not session.player.get_any_abtest_value('count_free_speedup_time', gamedata['store']['count_free_speedup_time'])):
                time_to_finish -= Store.get_free_speedup_time(session, session.player)
            time_to_finish -= 60 # desync grace period
            # NOTE! unit repair speedups do not have the "5 minute instant" option!
            if time_to_finish <= 0: time_to_finish = 0
            price_description.append(session.player.get_object_by_obj_id(session.player.unit_repair_queue[0]['obj_id']).spec.name)
            price_description.append('%.1fmin' % (time_to_finish/60))

            if formula == 'unit_repair_speedup_gamebucks':
                p_currency = 'gamebucks'
            price = Store.get_speedup_price(session.player, 'unit_repair', time_to_finish, p_currency)
            return price, p_currency

        elif formula == 'repair_all' or formula == 'repair_all_gamebucks':
            if formula == 'repair_all_gamebucks': p_currency = 'gamebucks'

            if spellarg == session.player.my_home.base_id:
                base = session.player.my_home
                do_units = True
            elif spellarg == session.viewing_base.base_id:
                assert session.viewing_base.base_landlord_id == session.player.user_id
                base = session.viewing_base
                do_units = False
            else:
                raise Exception('base not in the session: '+spellarg)

            if not session.player.unit_speedups_enabled():
                do_units = False

            sum_price = 0
            sum_time = 0
            n_buildings = 0
            n_units = 0

            for obj in base.iter_objects():
                if obj.is_building() and obj.is_damaged():
                    n_buildings += 1
                    if obj.is_repairing():
                        repair_time = obj.repair_finish_time - server_time
                    else:
                        repair_time = obj.time_to_repair(session.player)

                    if repair_time < 0:
                        repair_time = 0
                    sum_time += repair_time
                    time_to_finish = repair_time - Store.get_free_speedup_time(session, session.player)
                    if time_to_finish <= 0:
                        pass
                    else:
                        sum_price += Store.get_speedup_price(session.player, 'building_repair', time_to_finish, p_currency)

            if session.player.get_any_abtest_value('building_repair_sum_times', gamedata['store']['building_repair_sum_times']):
                # apply pricing function to sum of all repair times rather than summing individual prices
                # this is always <= the sum_price, because of how the time rounding works
                # also do not subtract free time from total calc
                time_to_finish = sum_time
                if time_to_finish <= Store.get_free_speedup_time(session, session.player):
                    sum_price = 0
                else:
                    sum_price = Store.get_speedup_price(session.player, 'building_repair', time_to_finish, p_currency)

            if sum_price == 0:
                error_reason.append('within free (building) repair speedup time')

            # compute unit repair costs
            if do_units:
                # note: ignore the repair queue, but sum unit times before applying formula
                total_rep_time = 0

                for obj in base.iter_objects():
                    if obj.is_mobile() and obj.is_damaged() and session.player.can_repair_unit(obj):
                        n_units += 1
                        total_rep_time += obj.time_to_repair(session.player)

                if total_rep_time > 0:
                    time_to_finish = total_rep_time
                    if (not session.player.get_any_abtest_value('count_free_speedup_time', gamedata['store']['count_free_speedup_time'])):
                        time_to_finish -= Store.get_free_speedup_time(session, session.player)
                    if time_to_finish <= 0: time_to_finish = 0

                    unit_price = Store.get_speedup_price(session.player, 'unit_repair', time_to_finish, p_currency)
                    sum_price += unit_price

            price_description.append('%dbuildings' % n_buildings)
            price_description.append('%dunits' % n_units)
            return sum_price, p_currency

        elif (formula == 'upgrade') or (formula.startswith('research')) or (formula.startswith('enhance')) or (formula == 'craft_gamebucks'):
            unit = None

            if unit_id == GameObject.VIRTUAL_ID and session.player.is_cheater and formula.startswith('research'):
                pass
            else:
                if not session.has_object(unit_id):
                    # possible race condition due to unserialized AJAX
                    error_reason.append('race condition - object does not exist in session')
                    return -1, p_currency
                unit = session.get_object(unit_id)

            if unit:
                if unit.owner is not session.player:
                    error_reason.append('player does not own this object')
                    return -1, p_currency
                if (not ((formula == 'upgrade' or formula.startswith('enhance') or formula == 'craft_gamebucks') and unit.spec.quarry_upgradable)) and (unit not in session.player.home_base_iter()):
                    error_reason.append('this object is not in the player\'s home base, and is not quarry_upgradable')
                    return -1, p_currency

                if (not unit.is_building()):
                    error_reason.append('only buildings can be upgraded or perform research or crafting')
                    return -1, p_currency
                if unit.is_damaged():
                    error_reason.append('cannot upgrade, research, or craft because building is damaged')
                    return -1, p_currency
                # can't upgrade or research while busy, with the one exception that instant research is allowed if building is currently researching
                if unit.is_busy() and (not ((formula.startswith('research') and unit.is_researching()) or (formula.startswith('enhance') and unit.is_enhancing()))):
                    error_reason.append('cannot upgrade, research, or craft while busy with activity: '+unit.activity_description(session.player))
                    return -1, p_currency

            if formula == 'upgrade':
                # check requirements

                max_level = unit.spec.maxlevel
                if unit.spec.max_ui_level and (not session.player.is_cheater):
                    max_level = min(max_level, Predicates.eval_cond_or_literal(unit.spec.max_ui_level, session, session.player))

                if unit.level >= unit.spec.maxlevel:
                    error_reason.append('unit has already reached max level')
                    return -1, p_currency
                if unit.spec.requires and (not session.player.is_cheater):
                    req = GameObjectSpec.get_leveled_quantity(unit.spec.requires, unit.level+1)
                    if (not req.is_satisfied2(session, session.player, None)):
                        error_reason.append('upgrade requirements not satisfied')
                        return -1, p_currency

                if (not session.player.is_cheater):
                    for res, resdata in gamedata['resources'].iteritems():
                        if not session.resource_allow_instant_upgrade(resdata) and \
                           GameObjectSpec.get_leveled_quantity(getattr(unit.spec, 'build_cost_'+res, 0), unit.level+1) > 0:
                            error_reason.append('requires rare resource: %s' % resdata['name'])
                            return -1, p_currency

                    ingr_list = unit.spec.get_upgrade_ingredients_list(unit.level+1)
                    for ingr in ingr_list:
                        if not gamedata['items'].get(ingr['spec'], {}).get('allow_instant', True):
                            error_reason.append('requires ingredient: %r' % ingr)
                            return -1, p_currency

                price_description.append('level'+str(unit.level+1))
                if unit.spec.upgrade_gamebucks_cost is not -1:
                    p_currency = 'gamebucks'
                    price = GameObjectSpec.get_leveled_quantity(unit.spec.upgrade_gamebucks_cost, unit.level+1)
                else:
                    price = GameObjectSpec.get_leveled_quantity(unit.spec.upgrade_credit_cost, unit.level+1)

                if price > 0:
                    factor = session.player.get_any_abtest_value('building_muffin_factor', gamedata['store']['building_muffin_factor'])
                    if factor != 1:
                        price = int((factor*price)+0.5) # round()

            elif formula == 'craft_gamebucks':
                p_currency = 'gamebucks' # more modern JSON now uses gamebucks as the currency unit
                arg = gamesite.gameapi.CraftSpellarg(spellarg)
                recipe = gamedata['crafting']['recipes'][arg.recipe_name]

                if (not session.player.is_cheater):
                    for res, resdata in gamedata['resources'].iteritems():
                        if not session.resource_allow_instant_upgrade(resdata) and ( \
                        (isinstance(GameObjectSpec.get_leveled_quantity(recipe['cost'], arg.recipe_level), dict) and GameObjectSpec.get_leveled_quantity(recipe['cost'], arg.recipe_level).get(res,0) > 0) \
                        or (isinstance(GameObjectSpec.get_leveled_quantity(recipe['cost'], arg.recipe_level), list) and GameObjectSpec.get_leveled_quantity(recipe['cost'].get(res,0), arg.recipe_level) > 0)):
                            error_reason.append('requires rare resource: %s' % resdata['name'])
                            return -1, p_currency

                can_craft_retmsg = []
                if not gamesite.gameapi.can_craft(session, session.player, unit, arg, retmsg = can_craft_retmsg,
                                                  check_predicates = (not session.player.is_cheater), take_resources = False, take_ingredients = False):
                    error_reason.append('cannot craft because: '+repr(can_craft_retmsg))
                    return -1, p_currency

                #if 'level' in spellarg: price_description.append('level'+str(arg.recipe_level))
                price = GameObjectSpec.get_leveled_quantity(recipe.get('craft_gamebucks_cost',-1), arg.recipe_level)

            elif formula.startswith('enhance'):
                enh_name = spellarg[0]
                new_level = spellarg[1]

                spec = session.player.get_abtest_spec(EnhancementSpec, enh_name)
                cur_level = unit.enhancements.get(enh_name,0) if unit.enhancements else 0
                if new_level != cur_level + 1:
                    error_reason.append('wrong level - current %d requested %d' % (cur_level, new_level))
                    return -1, p_currency

                # check requirements
                max_level = spec.maxlevel
                if spec.max_ui_level and (not session.player.is_cheater):
                    max_level = min(max_level, Predicates.eval_cond_or_literal(spec.max_ui_level, session, session.player))

                if new_level > max_level:
                    error_reason.append('enhancement already at max level')
                    return -1, p_currency
                if spec.developer_only and (spin_secure_mode or (not session.player.is_developer())):
                    error_reason.append('enhancement is restricted to developer mode only')
                    return -1, p_currency
                if spec.enhancement_category not in unit.spec.enhancement_categories:
                    error_reason.append(unit.spec.name+' building not capable of this enhancement '+spec.enhancement_category)
                    return -1, p_currency

                if unit.level < EnhancementSpec.get_leveled_quantity(spec.min_host_level, new_level):
                    error_reason.append('host level too low')
                    return -1, p_currency

                if (not session.player.is_cheater):
                    for pred, pred_name in ((spec.requires, 'requirements'),
                                            (spec.show_if, 'show_if')):
                        if pred:
                            req = EnhancementSpec.get_leveled_quantity(pred, new_level)
                            if (not req.is_satisfied2(session, session.player, None)):
                                error_reason.append('enhancement %s not satisfied' % pred_name)
                                return -1, p_currency

                    for res, resdata in gamedata['resources'].iteritems():
                        if not session.resource_allow_instant_upgrade(resdata) and \
                           EnhancementSpec.get_leveled_quantity(getattr(spec, 'cost_'+res, 0), new_level) > 0:
                            error_reason.append('requires rare resource: %s' % resdata['name'])
                            return -1, p_currency

                    ingr_list = spec.get_ingredients_list(new_level)
                    for ingr in ingr_list:
                        if not gamedata['items'].get(ingr['spec'], {}).get('allow_instant', True):
                            error_reason.append('requires ingredient: %r' % ingr)
                            return -1, p_currency

                price_description.append('level'+str(new_level))
                if formula == 'enhance_gamebucks':
                    p_currency = 'gamebucks'
                    price = EnhancementSpec.get_leveled_quantity(spec.enhance_gamebucks_cost, new_level)
                elif formula == 'enhance':
                    price = EnhancementSpec.get_leveled_quantity(spec.enhance_credit_cost, new_level)
                else:
                    raise Exception('unhandled formula/cost %r for %r' % (formula, enh_name))

            else:
                assert formula.startswith('research')
                spec = session.player.get_abtest_spec(TechSpec, spellarg)
                if session.player.tech.has_key(spellarg):
                    new_level = session.player.tech[spellarg] + 1
                else:
                    new_level = 1

                # check requirements
                max_level = spec.maxlevel
                if spec.max_ui_level and (not session.player.is_cheater):
                    max_level = min(max_level, Predicates.eval_cond_or_literal(spec.max_ui_level, session, session.player))

                if new_level > max_level:
                    error_reason.append('tech already at max level')
                    return -1, p_currency
                if spec.developer_only and (spin_secure_mode or (not session.player.is_developer())):
                    error_reason.append('research is restricted to developer mode only')
                    return -1, p_currency
                if unit:
                    if (not unit.is_researcher()):
                        error_reason.append('building is not capable of research')
                        return -1, p_currency
                    if spec.research_category not in unit.spec.get_research_categories(session.player):
                        error_reason.append(unit.spec.name+' building not capable of researching category '+spec.research_category)
                        return -1, p_currency
                if spec.requires and (not session.player.is_cheater):
                    req = TechSpec.get_leveled_quantity(spec.requires, new_level)
                    if (not req.is_satisfied2(session, session.player, None)):
                        error_reason.append('research requirements not satisfied')
                        return -1, p_currency
                if spec.show_if and (not session.player.is_cheater):
                    if not spec.show_if.is_satisfied2(session, session.player, None):
                        error_reason.append('research show_if not satisfied')
                        return -1, p_currency
                if spec.activation and (not session.player.is_cheater):
                    if not spec.activation.is_satisfied2(session, session.player, None):
                        error_reason.append('research activation not satisfied')
                        return -1, p_currency

                if (not session.player.is_cheater):
                    for res, resdata in gamedata['resources'].iteritems():
                        if not session.resource_allow_instant_upgrade(resdata) and \
                           TechSpec.get_leveled_quantity(getattr(spec, 'cost_'+res, 0), new_level) > 0:
                            error_reason.append('requires rare resource: %s' % resdata['name'])
                            return -1, p_currency

                    ingr_list = spec.get_research_ingredients_list(new_level)
                    for ingr in ingr_list:
                        if not gamedata['items'].get(ingr['spec'], {}).get('allow_instant', True):
                            error_reason.append('requires ingredient: %r' % ingr)
                            return -1, p_currency

                price_description.append('level'+str(new_level))

                if formula == 'research_gamebucks':
                    p_currency = 'gamebucks'
                    price = TechSpec.get_leveled_quantity(spec.research_gamebucks_cost, new_level)
                elif formula == 'research':
                    price = TechSpec.get_leveled_quantity(spec.research_credit_cost, new_level)
                else:
                    raise Exception('unhandled formula/cost %r for %r' % (formula, spellarg))

                if price > 0:
                    factor = session.player.get_any_abtest_value('tech_muffin_factor', gamedata['store']['tech_muffin_factor'])
                    if factor != 1:
                        price = int((factor*price)+0.5) # round()
            return price, p_currency

        elif formula in ('resource_boost','resource_boost_gamebucks','resource_boost_constant'):
            if formula == 'resource_boost_gamebucks': p_currency = 'gamebucks'

            snap = session.player.resources.calc_snapshot()
            if spell['resource'] in snap.res_max:
                max_res = snap.max_res(spell['resource'])
                cur_res = snap.cur_res(spell['resource'])
            else:
                raise Exception('Unknown resource type '+spell['resource'])

            if 'give_amount' in spell: # constant boosts
                amount = spell['give_amount']
                if (cur_res + amount) > max_res:
                    error_reason.append('no room for constant boost')
                    return -1, spell['currency']

            elif spell['boost_amount'] < 1: # percentage boosts
                amount = int(spell['boost_amount'] * max_res)
                if (cur_res + amount) > max_res:
                    error_reason.append('no room for partial boost')
                    return -1, p_currency
            else: # full boost
                if cur_res >= max_res:
                    error_reason.append('no room for full boost')
                    return -1, p_currency
                amount = max_res - cur_res

            if formula == 'resource_boost_constant':
                return spell['price'], spell['currency']
            else:
                return ResPrice.get_resource_price(gamedata, session, spell['resource'], amount, p_currency), p_currency

        elif (formula == 'resource_topup'):
            p_currency = 'gamebucks'
            price = 0
            snap = session.player.resources.calc_snapshot()

            # get A/B test overrides for resource parameters
            overrides = session.player.get_any_abtest_value('resources', {})

            for res in spellarg:
                allowed = gamedata['resources'][res].get('allow_topup',False)
                if res in overrides:
                    allowed = overrides[res].get('allow_topup', allowed)
                if not allowed:
                    error_reason.append('topup not allowed for resource '+res)
                    return -1, p_currency

                if snap.cur_res(res) + spellarg[res] > snap.max_res(res):
                    error_reason.append('no room for topup boost')
                    return -1, p_currency
                price += ResPrice.get_resource_price(gamedata, session, res, spellarg[res], p_currency)
            return price, p_currency
        else:
            raise Exception('Unknown price formula')

    # return the abbreviated order description that will be written to log files
    # note: this must coordinate with SpinUpcache.classify_purchase() to return reasonable results for SQL insertion
    @classmethod
    def get_description(cls, session, unit_id, spellname, spellarg, price_description):
        descr = spellname

        # special cases that want to parse the spellarg a bit
        if spellname == 'CRAFT_FOR_MONEY':
            # return format expected by SpinUpcache.classify_purchase(), matching the speedup version
            descr += ','+session.get_object(unit_id).spec.name+','+spellarg['recipe']
            if 'level' in spellarg:
                descr += ','+str(spellarg['level'])

        else: # default case
            if spellarg:
                if type(spellarg) in (dict,list):
                    s = SpinJSON.dumps(spellarg)
                else:
                    s = str(spellarg)
                descr += ','+s

            if unit_id and unit_id != GameObject.VIRTUAL_ID:
                object = session.get_object(unit_id)
                descr += ','+object.spec.name

        if price_description and len(price_description) > 0:
            descr += ','+string.join(price_description, ',')

        return descr

    # convert Facebook Credits to US Dollar receipts
    @classmethod
    def fbcredits_to_dollars(cls, fb_credits_amount):
        return 0.07 * fb_credits_amount
    # convert Kongregate Kreds to US Dollar receipts
    @classmethod
    def kgcredits_to_dollars(cls, kg_credits_amount):
        return 0.07 * kg_credits_amount

    # convert promotional gamebucks amount to US Dollar receipts
    # note: only used for platform offers that pay out in gamebucks, NOT for in-game purchases
    @classmethod
    def promo_gamebucks_to_dollars(cls, gamebucks):
        fb_credits_amount = gamebucks / float(gamedata['store']['gamebucks_per_fbcredit'])
        return 0.07 * fb_credits_amount


    @classmethod
    def format_ui_string(cls, session, spellname, spellarg, spell, s):
        if spell.get('price_formula',None) == 'gamebucks_topup':
            qty = spellarg
        elif ('quantity' in spell):
            qty = spell['quantity']
        else:
            qty = 0

        if '%GAMEBUCKS_QUANTITY' in s:
            divisor = gamedata['store']['gamebucks_display_divisor']
            if session: divisor = session.player.get_any_abtest_value('gamebucks_display_divisor', divisor)
            if divisor == 1:
                s_qty = str(qty)
            else:
                if (qty%divisor) != 0:
                    gamesite.exception_log.event(server_time, 'fractional displayed gamebucks amount for spell %s' % spellname)
                s_qty = str(int(qty/divisor))
            s = s.replace('%GAMEBUCKS_QUANTITY', s_qty)
        if '%GAMEBUCKS_NAME' in s:
            ui_name = gamedata['store']['gamebucks_ui_name']
            if session: ui_name = session.player.get_any_abtest_value('gamebucks_ui_name', ui_name)
            s = s.replace('%GAMEBUCKS_NAME', ui_name)
        if '%GAMEBUCKS_PAYMENT_NAME' in s:
            s = s.replace('%GAMEBUCKS_PAYMENT_NAME', gamedata['store'].get('gamebucks_payment_ui_name', gamedata['store']['gamebucks_ui_name']))
        if '%GAME_NAME' in s:
            s = s.replace('%GAME_NAME', gamedata['strings']['game_name'])
        if '%ITEM_NAME' in s:
            if 'ui_name' in spellarg['skudata']:
                ui_name = spellarg['skudata']['ui_name']
            else:
                spec = gamedata['items'][spellarg['skudata']['item']]
                ui_name = spec['ui_name']
                stack = spellarg.get('stack',1)
                if stack > 1:
                    ui_name = ('%dx ' % stack) + ui_name
            s = s.replace('%ITEM_NAME', ui_name)
        if '%ITEM_BUNDLE' in s:
            ui_bundle = ''
            want_loot = spell.get('loot_table')
            if want_loot and spellarg and (isinstance(spellarg, int) or isinstance(spellarg, basestring)):
                want_loot = False # quantity-based SKU
            if want_loot and spellarg and isinstance(spellarg, dict) and not spellarg.get('want_loot', False):
                want_loot = False
            # session is None for OGPAPI, which makes want_loot opt-in
            if want_loot and ((session is None) or session.get_loot_items(session.player, gamedata['loot_tables'][spell['loot_table']]['loot'], -1, -1)):
                ui_bundle = ' (plus FREE items)'
            s = s.replace('%ITEM_BUNDLE', ui_bundle)
        return s

    # given the order_info passed from the client, return a dictionary with
    # the proper fields for the Credits API filled out ('title', 'description', 'price', 'image_url', etc)
    @classmethod
    def make_credit_order(cls, order_id, order_info, currency):
        assert currency in ('fbcredits', 'kgcredits')
        session_id = str(order_info['session_id'])
        session = get_session_by_session_id(session_id)
        assert session
        unit_id = order_info['unit_id']
        spellname = order_info['spellname']
        spellarg = order_info.get('spellarg', None)
        client_price = order_info['client_price']
        tag = order_info.get('tag', '')
        server_time_according_to_client = order_info.get('server_time_according_to_client', None)
        spell = gamedata['spells'][spellname]
        assert spell['paid']
        assert spell['currency'] == currency

        item = {}
        item[{'fbcredits':'title','kgcredits':'name'}[currency]] = cls.format_ui_string(session, spellname, spellarg, spell, spell['ui_name'])
        price_description = []
        error_reason = []

        if server_time_according_to_client is not None:
            error_reason.append('clock offset %d' % (server_time - server_time_according_to_client))

        price = Store.get_price(session, currency, unit_id, spell, spellarg, price_description, error_reason)

        if price < 0 or client_price <= 0:
            raise Exception(('make_credit_order(%s): Invalid order by user %d: ' % (currency, session.user.user_id)) + repr(order_info) + ' get_price() failed with reason: '+ repr(error_reason))
        elif client_price < price:
            # client thinks price is lower than server does (e.g. due to clock time mismatch)
            raise Exception('make_credit_order(%s): Rejecting lower client price %d < price %d by user %d: ' % (currency, client_price,price,session.user.user_id) + repr(order_info) + ' reason: '+ repr(error_reason))
        elif client_price > price:
            # client thinks price is higher than server does (e.g. due to clock time mismatch)
            if 0:
                gamesite.exception_log.event(server_time, 'make_credit_order(%s): Accepting higher client_price %d > price %d by user %d: ' % (currency, client_price,price,session.user.user_id) + ' reason: ' +repr(error_reason))
            # accept the higher price (!)
            price = client_price

        item['price'] = price
        item['description'] = cls.format_ui_string(session, spellname, spellarg, spell, spell['ui_description'])
        item['image_url'] = order_info['image_url']

        if currency == 'fbcredits':
            item['product_url'] = order_info['product_url']

            # pass session_id so it will be sent back in payment_status_update
            my_data = {'session_id':session_id, 'unit_id':unit_id, 'spellname': spellname, 'spellarg': spellarg, 'client_price': client_price, 'tag':tag}
            if server_time_according_to_client is not None:
                my_data['server_time_according_to_client'] = server_time_according_to_client

            item['data'] = SpinFacebook.order_data_encode(my_data)

        descr = Store.get_description(session, unit_id, spellname, spellarg, price_description)
        dollar_amount = {'fbcredits':Store.fbcredits_to_dollars, 'kgcredits':Store.kgcredits_to_dollars}[currency](price)

        metric_event_coded(session.user.user_id, '4065_order_prompt_response', {'Billing Amount': dollar_amount,
                                                                                'Billing Description': descr,
                                                                                'order_id': order_id,
                                                                                'currency':currency
                                                                                })
        return item

    # the customer has agreed to pay - perform the actions required by the order
    # return the session (to allow for flushing right after this is called)
    # throws exceptions to indicate order errors
    # NOTE: this is only used for (old) FB Credits, Kongregate, Xsolla, and promo (in-kind) Gamebucks orders
    # (new) FB Payments go through a different code path!

    @classmethod
    def execute_credit_order(cls, order_id, gameapi, session, buyer, receiver, currency, credits_amount, my_data):
        assert currency in ('fbcredits', 'kgcredits', 'gamebucks') or currency.startswith('xsolla:')
        # note that gamebucks here is only used for platform offers that pay out in gamebucks, NOT in-game purchases

        tag = None

        # check for in-app currency order (see https://developers.facebook.com/docs/payments/app_currency_orders/)
        if 'modified' in my_data:
            assert currency == 'fbcredits'
            m = my_data['modified']
            if 0:
                gamesite.exception_log.event(server_time, ('in-app currency order (FB buyer %s): ' % buyer) + repr(my_data))
            assert m['credits_amount'] == credits_amount
            assert OGPAPI_instance.matches_object_endpoint(m['product'], {'type':OGPAPI.object_type('gamebucks')})
            assert m['product_amount'] <= gamedata['store']['gamebucks_per_fbcredit'] * m['credits_amount']

            # note: we have to find the session manually, because this request comes from Facebook without passing through the client!
            if session is None:
                session = get_session_by_facebook_id(buyer)
            if session is None: raise Exception(('session not found for in-app currency order! (FB buyer %s)' % buyer)+repr(my_data))
            unit_id = GameObject.VIRTUAL_ID
            spellname = 'FB_PROMO_GAMEBUCKS'
            spellarg = m['product_amount']
            network_id = session.user.facebook_id
            dollar_amount = Store.fbcredits_to_dollars(credits_amount)

        # TrialPay order
        elif my_data.get('spellname') == 'FB_TRIALPAY_GAMEBUCKS':
            assert session
            assert currency == 'gamebucks'
            assert OGPAPI_instance.matches_object_endpoint(my_data['currency_url'], {'type':OGPAPI.object_type('gamebucks')})
            unit_id = GameObject.VIRTUAL_ID
            spellname = 'FB_TRIALPAY_GAMEBUCKS'
            spellarg = credits_amount
            network_id = session.user.facebook_id
            dollar_amount = Store.promo_gamebucks_to_dollars(credits_amount)

        else:
            if session is None:
                session = get_session_by_session_id(my_data['session_id'])
            unit_id = my_data['unit_id']
            spellname = my_data['spellname']
            spellarg = my_data.get('spellarg', None)
            tag = my_data.get('tag', None)
            if currency.startswith('xsolla:'):
                network_id = session.user.get_xsolla_id()
                dollar_amount = my_data['usd_receipts']
            elif currency == 'fbcredits':
                network_id = session.user.facebook_id
                dollar_amount = Store.fbcredits_to_dollars(credits_amount)
            elif currency == 'kgcredits':
                network_id = session.user.kg_id
                dollar_amount = Store.kgcredits_to_dollars(credits_amount)

        server_time_according_to_client = my_data.get('server_time_according_to_client', None)

        assert session
        assert (not session.logout_in_progress)

        if network_id != receiver:
            gamesite.exception_log.event(server_time, 'execute_order: strange, receiver is mismatched (%s %s)' % (network_id, receiver))

        price_description, detail_props = Store.execute_order(gameapi, session, session.outgoing_messages,
                                                              currency, credits_amount,
                                                              unit_id, spellname, spellarg,
                                                              server_time_according_to_client,
                                                              usd_equivalent = dollar_amount)

        descr = Store.get_description(session, unit_id, spellname, spellarg, price_description)

        admin_stats.add_revenue(session.user.user_id, dollar_amount, descr)

        metric_event_coded(session.user.user_id, '1000_billed', {'Billing Amount': dollar_amount,
                                                                 'Billing Description': descr,
                                                                 'currency': currency,
                                                                 'currency_amount': credits_amount,
                                                                 'country_tier': session.player.country_tier,
                                                                 'last_purchase_time': session.player.history.get('last_purchase_time',-1),
                                                                 'prev_largest_purchase': session.player.history.get('largest_purchase',0),
                                                                 'num_purchases': session.player.history.get('num_purchases',0),
                                                                 'order_id': order_id})

        gamesite.credits_log.event(server_time, {'user_id':session.user.user_id,
                                                 'event_name':'1000_billed',
                                                 'code':1000,
                                                 'Billing Amount': dollar_amount,
                                                 'Billing Description': descr,
                                                 'currency': currency,
                                                 'currency_amount': credits_amount,
                                                 'summary': session.player.get_denormalized_summary_props('brief'),
                                                 'country_tier': session.player.country_tier,
                                                 'country': session.user.country,
                                                 'last_purchase_time': session.player.history.get('last_purchase_time',-1),
                                                 'prev_largest_purchase': session.player.history.get('largest_purchase',0),
                                                 'num_purchases': session.player.history.get('num_purchases',0),
                                                 'order_id': order_id})

        session.activity_classifier.spent_money(dollar_amount, descr)

        if session.player.history.get('money_spent', 0) == 0:
            session.player.history['time_of_first_purchase'] = server_time

        if session.user.account_creation_time > 0:
            daynum = int((server_time - session.user.account_creation_time)/(60*60*24))
            if 'money_spent_by_day' not in session.player.history:
                session.player.history['money_spent_by_day'] = {}
            dict_increment(session.player.history['money_spent_by_day'], str(daynum), dollar_amount)
        dict_setmax(session.player.history, 'last_purchase_time', server_time)

        # new-style player metrics (redundant with old style above)
        session.increment_player_metric('money_spent', dollar_amount)
        session.increment_player_metric('num_purchases', 1)
        session.setmax_player_metric('largest_purchase', dollar_amount)

        if 'money_purchase_history' not in session.player.history:
            session.player.history['money_purchase_history'] = []

        session.player.history['money_purchase_history'].append({'time': server_time,
                                                                 'age': -1 if session.player.creation_time < 0 else (server_time - session.player.creation_time),
                                                                 'dollar_amount': dollar_amount,
                                                                 'credit_amount': credits_amount,
                                                                 'currency': currency,
                                                                 'order_id': order_id,
                                                                 'description': descr})

        session.send_adnetwork_purchase_event(session.outgoing_messages, order_id, dollar_amount) # note: post-FB-tax
        session.send_adnetwork_events(session.outgoing_messages)

        # update client's version of spend metrics
        session.deferred_history_update = True
        if tag: # send acknowledgement to client
            session.outgoing_messages.append([{'fbcredits':"FBCREDITS_ORDER_ACK",'kgcredits':"KGCREDITS_ORDER_ACK"}[currency], tag, True])
        session.queue_flush_outgoing_messages()
        return session

    @classmethod
    def execute_gamebucks_order(cls, gameapi, session, retmsg, amount_willing_to_pay,
                                unit_id, spellname, spellarg,
                                server_time_according_to_client):
        price_description, detail_props = Store.execute_order(gameapi, session, retmsg, 'gamebucks', amount_willing_to_pay,
                                                              unit_id, spellname, spellarg,
                                                              server_time_according_to_client)

        descr = Store.get_description(session, unit_id, spellname, spellarg, price_description)

        if amount_willing_to_pay > 0:
            # only record non-free orders
            if 'gamebucks_purchase_history' not in session.player.history:
                session.player.history['gamebucks_purchase_history'] = []

            session.player.history['gamebucks_purchase_history'].append({'time': server_time,
                                                                         'age': -1 if session.player.creation_time < 0 else (server_time - session.player.creation_time),
                                                                         'gamebucks_amount': amount_willing_to_pay,
                                                                         'gamebucks_balance': session.player.resources.gamebucks - amount_willing_to_pay,
                                                                         'description': descr})

            session.increment_player_metric('gamebucks_spent', amount_willing_to_pay, time_series = False)
            #session.increment_player_metric('num_gamebucks_purchases', 1)
            session.setvalue_player_metric('gamebucks_balance', session.player.resources.gamebucks - amount_willing_to_pay, bucket=True, bucket_size=15*60)

        # log zero-gamebucks free orders (e.g. daily expeditions) as well as non-free orders
        metric_event_coded(session.user.user_id, '1400_gamebucks_spent', {'Billing Description': descr,
                                                                          'gamebucks_price': amount_willing_to_pay})
        money_spent = session.player.history.get('money_spent', 0)

        if gamedata['server']['log_gamebucks_spend'] and ((money_spent > 0) or (gamedata['server']['log_gamebucks_spend'] != 'paying_only')):
            props = {'user_id': session.user.user_id,
                     'summary': session.player.get_denormalized_summary_props('brief'),
                     'event_name': '1400_gamebucks_spent',
                     'code': 1400,
                     'gamebucks_price': amount_willing_to_pay,
                     'Billing Description': descr}
            if money_spent > 0:
                props['money_spent'] = money_spent
            props.update(detail_props)
            gamesite.gamebucks_log.event(server_time, props)

        if money_spent > 0 and amount_willing_to_pay > 0:
            admin_stats.add_gamebucks_spend(session.user.user_id, amount_willing_to_pay, descr)
            session.activity_classifier.spent_gamebucks(amount_willing_to_pay, descr)

        return descr

    @classmethod
    def execute_order(cls, gameapi, session, retmsg, currency, amount_willing_to_pay,
                      unit_id, spellname, spellarg,
                      server_time_according_to_client,
                      usd_equivalent = None, gift_order = None, payment_id = None,
                      override_time = None):

        # verify that the order is possible and that amount_willing_to_pay is correct
        spell = gamedata['spells'][spellname]
        assert spell['paid']

        price_description = []
        error_reason = []
        detail_props = {}

        if server_time_according_to_client is not None:
            error_reason.append('clock offset %d' % (server_time - server_time_according_to_client))

        # As of October 2014, Facebook is now sending us fbpayments orders with currencies other than those we publish via gamebucks_open_graph_prices.
        # According to the docs, they "invent" a currency->gamebucks exchange rate into the new currency based on the first published currency (always USD for us)
        # We have no choice but to trust that this is a fair amount (!)
        if spell['price_formula'] == 'arbitrary_real_currency' and \
           currency.startswith('fbpayments:') and \
           (not any(str(currency.split(':')[1]) == curname for curname, srate in gamedata['store']['gamebucks_open_graph_prices'])):
            gamesite.exception_log.event(server_time, 'player %d making %s order (payment_id %r) with unknown currency %s amount %s, trusting Facebook that it is worth %d gamebucks!' % \
                                         (session.player.user_id, spellname, payment_id, currency, repr(amount_willing_to_pay), spellarg))
            store_price = amount_willing_to_pay

        # In 2019, Facebook started sending payments in currencies other than the published SKU, i.e. accepting EUR payments for BRL SKUs.
        # This accepts a payment processed by Facebook regardless of the exchange rate.
        elif currency != spell.get('currency') and spell['price_formula'] == 'constant' and currency.startswith('fbpayments:') and spell.get('currency','').startswith('fbpayments:'):
            gamesite.exception_log.event(server_time, 'player %d making %s order (payment_id %r) with currency %s amount %s when sku wants currency %s, trusting Facebook that purchase is valid!' % \
                                         (session.player.user_id, spellname, payment_id, currency, repr(amount_willing_to_pay), spell['currency']))
            store_price = amount_willing_to_pay

        else:
            store_price = Store.get_price(session, currency, unit_id, spell, spellarg, price_description, error_reason, override_time = override_time)

        if gift_order and (not (spellname.startswith("BUY_GAMEBUCKS_") or spellname == "FB_GAMEBUCKS_PAYMENT")):
            raise Exception('gift_order for a non-gamebucks SKU user %d' % session.user.user_id)

        # for logging only
        unit_description = 'none'
        if session.has_object(unit_id):
            obj = session.get_object(unit_id)
            unit_description = obj.spec.name
            if obj.is_building():
                unit_description += '/' + obj.activity_description(session.player)

        if store_price < 0:
            raise Exception(('execute_order(%r %s): Invalid order by user %d: ' % (amount_willing_to_pay, currency, session.user.user_id)) + repr((unit_description, spellname, spellarg)) + ' get_price() failed with reason: '+repr(error_reason))

        # to avoid exceptions due to slight clock desync, accept payment amounts slightly below the actual server-determined price for time-based gamebucks orders
        if (amount_willing_to_pay < store_price) and (currency == 'gamebucks') and \
           (amount_willing_to_pay > 0) and (amount_willing_to_pay >= store_price - gamedata['server'].get('gamebucks_grace_amount',1)) and \
           (('REPAIR' in spellname) or ('SPEEDUP' in spellname)):
            store_price = amount_willing_to_pay

        if round(amount_willing_to_pay,2) < round(store_price,2):
            raise Exception(('execute_order(%r %s): Rejecting unfavorable price mismatch! (store %r order %r) by user %d payment_id %r ' % \
                             (amount_willing_to_pay, currency, store_price, amount_willing_to_pay, session.user.user_id, payment_id)) + \
                            repr((unit_description, spellname, spellarg)) + \
                            ' get_price() reason: ' + \
                            repr(error_reason)
                            )
        elif round(amount_willing_to_pay,2) > round(store_price,2):
            if (amount_willing_to_pay - store_price) > (10 if currency == 'gamebucks' else 1):
                gamesite.exception_log.event(server_time, (('execute_order(%r %s): Accepting favorable price mismatch! (store %r order %r) by user %d payment_id %r ' % \
                                                            (amount_willing_to_pay, currency, store_price, amount_willing_to_pay, session.user.user_id, payment_id)) + \
                                                           repr((unit_description, spellname, spellarg)) + \
                                                           ' get_price() reason: ' + \
                                                           repr(error_reason)))

        if currency == 'fbcredits':
            record_spend_type = 'money'
            record_price_type = 'fb_price'
            record_amount = Store.fbcredits_to_dollars(amount_willing_to_pay)
        elif currency == 'kgcredits':
            record_spend_type = 'money'
            record_price_type = 'kg_price'
            record_amount = Store.kgcredits_to_dollars(amount_willing_to_pay)
        elif currency.startswith('fbpayments:') or currency.startswith('xsolla:') or currency.startswith('microsoft:'):
            record_spend_type = 'money'
            record_price_type = 'price'
            record_amount = usd_equivalent
        elif currency == 'gamebucks':
            record_spend_type = 'gamebucks'
            record_price_type = 'gamebucks_price'
            record_amount = amount_willing_to_pay
        elif currency.startswith('item:') or currency.startswith('score:'):
            item_name = currency.split(':')[1]
            record_spend_type = item_name
            record_price_type = item_name+'_price'
            record_amount = amount_willing_to_pay
        elif currency in gamedata['resources']:
            record_spend_type = currency
            record_price_type = currency+'_price'
            record_amount = amount_willing_to_pay
        else:
            raise Exception('unknown currency '+currency)

        # note: there is no need for requirements checking here,
        # because Store.get_price() takes care of it (by returning -1
        # if requirements are not met)

        object = None

        if spellname == "SPEEDUP_FOR_MONEY":
            object = session.get_object(unit_id)
            if object.is_building() and object.is_repairing():
                object.repair_finish_time = server_time - 1
                speedup_type = 'repair'
            elif object.is_building() and object.is_upgrading():
                assert object.upgrade_start_time > 0
                object.upgrade_done_time = object.upgrade_total_time
                speedup_type = 'upgrade'
            elif object.is_building() and object.is_enhancing():
                object.enhancing.speedup()
                speedup_type = 'enhance'
            elif object.is_removing():
                object.removing.speedup()
                speedup_type = 'remove'
            elif object.is_building() and object.is_under_construction():
                assert object.build_start_time > 0
                object.build_done_time = object.build_total_time
                speedup_type = 'construct'
            elif object.is_building() and object.is_researching():
                assert object.research_start_time > 0
                object.research_done_time = object.research_total_time
                speedup_type = 'research'
            elif object.is_building() and object.is_manufacturing():
                assert object.manuf_start_time > 0
                detail_props['unit_cost'] = cls.get_unit_cost_detail(session, session.player, manuf_queue = object.manuf_queue,
                                                                     manuf_prog = object.manuf_done_time + server_time - object.manuf_start_time)
                object.manuf_done_time = sum([item['total_time'] for item in object.manuf_queue])
                speedup_type = 'produce'
            elif object.is_building() and object.is_crafting():
                entry = object.crafting.queue[0]
                recipe = gamedata['crafting']['recipes'][entry.craft_state['recipe']]
                time_left = object.crafting.finish_time() - server_time
                object.crafting.speedup()
                speedup_type = 'craft'
                if recipe['crafting_category'] == 'fishing':
                    session.player.fishing_log_event('5151_fish_speedup', entry, time_left = time_left)
            else:
                speedup_type = 'unknown'
            gameapi.ping_object(session, retmsg, object.obj_id, session.viewing_base)

            metric_event_coded(session.user.user_id, '5010_purchase_speedup', {'building_type':object.spec.name,
                                                                               'speedup_type':speedup_type,
                                                                               'currency':currency,
                                                                               record_price_type: amount_willing_to_pay})


            hist_type = speedup_type
            if hist_type == 'upgrade':
                hist_type = 'building_upgrade'
            session.increment_player_metric('speedups_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_speedups', record_amount, time_series = False)
            session.increment_player_metric(hist_type+'_speedups_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_'+hist_type+'_speedups', record_amount, time_series = False)

            session.increment_player_metric('building:'+object.spec.name+':speedups_purchased', 1, time_series = False)
            session.increment_player_metric('building:'+object.spec.name+':'+record_spend_type+'_spent_on_speedups', record_amount, time_series = False)
            session.increment_player_metric('building:'+object.spec.name+':'+hist_type+'_speedups_purchased', 1, time_series = False)
            session.increment_player_metric('building:'+object.spec.name+':'+record_spend_type+'_spent_on_'+hist_type+'_speedups', record_amount, time_series = False)

        elif spellname.startswith("SQUAD_MOVEMENT_SPEEDUP_FOR_"):
            if spellname == 'SQUAD_MOVEMENT_SPEEDUP_FOR_MONEY':
                assert session.player.squad_speedups_enabled()
            elif spellname == 'SQUAD_MOVEMENT_SPEEDUP_FOR_ITEM':
                assert session.player.squad_speedup_items_enabled()

            squad_id = spellarg

            squad = session.player.verify_squad(squad_id, require_at_home = False, require_away = True)
            if 'map_path' not in squad:
                raise Exception('squad is not moving')

            new_lock_gen = -1
            # copy path and set ETAs into the past
            new_path = squad['map_path'][:]
            delta = (server_time - 1) - squad['map_path'][-1]['eta'] # time shift to make squad land at destination now
            for waypt in new_path:
                waypt['eta'] += delta

            state = gamesite.nosql_client.map_feature_lock_acquire(session.player.home_region, session.player.squad_base_id(squad_id), session.player.user_id, do_hook = False, reason=spellname)
            if state != Player.LockState.being_attacked: # mutex locked
                raise Exception('unable to lock squad')

            try:
                # verify that the squad in map_cache matches where the playerdb state says it is
                entry = gamesite.nosql_client.get_map_feature_by_base_id(session.player.home_region, session.player.squad_base_id(squad_id), reason=spellname)
                if not entry:
                    raise Exception('squad not found on map')

                # get rid of lock info, as if we return the feature, it'll definitely be unlocked
                for FIELD in ('LOCK_STATE', 'LOCK_OWNER'):
                    if FIELD in entry: del entry[FIELD]

                if entry['base_map_loc'][0] != squad['map_loc'][0] or entry['base_map_loc'][1] != squad['map_loc'][1]:
                    gamesite.exception_log.event(server_time, 'player %d squad %d trying to speed up, but base location mismatches: squad %s map_cache %s' % \
                                                 (session.player.user_id, squad_id, repr(squad['map_loc']), repr(entry['base_map_loc'])))
                    raise Exception('database position disagrees with in-memory state')

                new_entry = copy.copy(entry)
                new_entry['base_map_path'] = new_path
                if not gamesite.nosql_client.move_map_feature(session.player.home_region, new_entry['base_id'], new_entry,
                                                              old_loc=entry['base_map_loc'], old_path=entry.get('base_map_path',None),
                                                              originator=session.player.user_id, reason=spellname):
                    raise Exception('database update failed')

                new_lock_gen = entry.get('LOCK_GENERATION',-1)+1
                squad['map_path'] = new_path
                session.player.cooldown_reset('squad_order:%d' % squad_id)
                session.deferred_player_cooldowns_update = True
                retmsg.append(["REGION_MAP_UPDATES", session.player.home_region, [new_entry], server_time])
                retmsg.append(["SQUADS_UPDATE", session.player.squads])

            finally:
                gamesite.nosql_client.map_feature_lock_release(session.player.home_region, session.player.squad_base_id(squad_id), session.player.user_id,
                                                               generation = new_lock_gen,
                                                               do_hook = False, reason=spellname)

        elif spellname == "PLAYER_AURA_SPEEDUP_FOR_MONEY":
            aura_name = spellarg
            aura = None
            for a in session.player.player_auras_iter_const():
                if a['spec'] == aura_name and ('end_time' in a):
                    aura = a
                    break
            assert aura
            aura['end_time'] = server_time - 1
            session.player.prune_player_auras()
            session.deferred_player_auras_update = True
            session.increment_player_metric('player_aura_speedups_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_player_aura_speedups', record_amount, time_series = False)

        elif spellname == "UNIT_REPAIR_SPEEDUP_FOR_MONEY":

            damaged_obj_list = [] # for accounting only
            for item in session.player.unit_repair_queue:
                obj = session.player.get_object_by_obj_id(item['obj_id'], fail_missing = False)
                if obj: damaged_obj_list.append(obj)
            detail_props['unit_cost'] = cls.get_unit_cost_detail(session, session.player, damaged_obj_list = damaged_obj_list)

            for item in session.player.unit_repair_queue:
                item['finish_time'] = server_time - 1
            gameapi.do_unit_repair_tick(session, retmsg, must_reply = True)
            session.increment_player_metric('speedups_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_speedups', record_amount, time_series = False)
            session.increment_player_metric('unit_repair_speedups_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_unit_repair_speedups', record_amount, time_series = False)
            retmsg.append(["SQUADS_UPDATE", session.player.squads]) # to unblock GUI

        elif spellname == "REPAIR_ALL_FOR_MONEY":

            if spellarg == session.player.my_home.base_id:
                base = session.player.my_home
                do_units = True
                write_base = False
            elif spellarg == session.viewing_base.base_id:
                assert session.viewing_base.base_landlord_id == session.player.user_id
                base = session.viewing_base
                do_units = False
                write_base = True
            else:
                raise Exception('base not in the session: '+spellarg)

            if not session.player.unit_speedups_enabled():
                do_units = False

            if do_units:
                detail_props['unit_cost'] = cls.get_unit_cost_detail(session, session.player, damaged_obj_list = [object for object in session.player.home_base_iter() if object.is_mobile() and object.is_damaged() and session.player.can_repair_unit(object)])

                # kill the entire repair queue (refunding resources for repairs already queued, because client may have sent REPAIR first)
                if gamedata['unit_repair_refund_on_paid_repair']:
                    session.player.unit_repair_cancel_all()
                else:
                    session.player.unit_repair_queue = []

                session.player.unit_repair_send(retmsg)

                for object in session.player.home_base_iter():
                    if object.is_mobile() and object.is_damaged() and session.player.can_repair_unit(object):
                        object.heal_to_full()
                        if session.has_object(object.obj_id): retmsg.append(["OBJECT_STATE_UPDATE2", object.serialize_state()])
                        session.player.send_army_update_one(object, retmsg)

                retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

            # now handle base buildings

            if write_base and session.viewing_base_lock != base.lock_id():
                # not going to hold it for an extended period of time, so no need to broadcast
                assert gamesite.nosql_client.map_feature_lock_acquire(base.base_region, base.base_id, session.player.user_id,
                                                                      generation=base.base_generation, do_hook=False, reason=spellname) \
                                                                      == Player.LockState.being_attacked # generation=-1?
            to_remove = []
            try:
                for object in base.iter_objects():
                    if object.is_mobile() and object.is_temporary(): # get rid of temporary units
                        to_remove.append(object)
                        continue
                    if object.is_building() and object.is_damaged():
                        object.repair_finish_time = server_time - 1
                        if session.has_object(object.obj_id):
                            gameapi.ping_object(session, retmsg, object.obj_id, base)
                        if write_base:
                            base.nosql_write_one(object, spellname)
                for object in to_remove:
                    base.drop_object(object)
                    if session.has_object(object.obj_id):
                        retmsg.append(["OBJECT_REMOVED2", object.obj_id])
                        session.rem_object(object.obj_id)
            finally:
                if write_base and session.viewing_base_lock != base.lock_id():
                    gamesite.nosql_client.map_feature_lock_release(base.base_region, base.base_id, session.player.user_id, generation=base.base_generation, reason=spellname)

            metric_event_coded(session.user.user_id, '5060_purchase_base_repair', {'currency': currency,
                                                                                   'base_id': spellarg,
                                                                                   record_price_type: amount_willing_to_pay})
            session.increment_player_metric('base_repairs_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_base_repairs', record_amount, time_series = False)

        elif spellname == "UPGRADE_FOR_MONEY":
            object = session.get_object(unit_id)
            assert gameapi.do_upgrade_instant(session, retmsg, object)
            metric_event_coded(session.user.user_id, '5050_purchase_building_upgrade', {'building_type':object.spec.name, 'level':object.level,
                                                                                        'currency': currency,
                                                                                        record_price_type: amount_willing_to_pay
                                                                                        })
            session.increment_player_metric('building_upgrades_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_building_upgrades', record_amount, time_series = False)
            session.increment_player_metric('building:'+object.spec.name+':upgrades_purchased', 1, time_series = False)
            session.increment_player_metric('building:'+object.spec.name+':'+record_spend_type+'_spent_on_upgrades', record_amount, time_series = False)

        elif spellname == "CRAFT_FOR_MONEY":
            object = session.get_object(unit_id)
            assert gameapi.do_craft(session, session.player, retmsg, object, gameapi.CraftSpellarg(spellarg),
                                    check_predicates = (not session.player.is_cheater), take_resources = False, take_ingredients = False, take_time = False)
            # run the completion
            gameapi.ping_object(session, retmsg, object.obj_id, session.viewing_base)

        elif spellname.startswith("UPGRADE_BARRIERS_LEVEL"):
            new_level = int(spellname[-1])
            assert new_level <= GameObjectSpec.lookup('barrier').maxlevel
            res = session.player.resources.calc_snapshot().serialize()
            for obj in session.player.home_base_iter():
                if obj.spec.name == 'barrier':
                    if obj.level < new_level:
                        # heal to full
                        obj.halt_repair()
                        obj.change_level(new_level)
                        obj.heal_to_full()
                        retmsg.append(["OBJECT_STATE_UPDATE", obj.serialize_state(), res])
            metric_event_coded(session.user.user_id, '5070_purchase_barrier_upgrade', {'level':new_level,
                                                                                       'currency':currency,
                                                                                       record_price_type: amount_willing_to_pay})
            session.increment_player_metric('barrier_upgrades_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_barrier_upgrades', record_amount, time_series = False)

        elif spellname.startswith("GROW_BASE_PERIMETER"):
            # accept any spellname of the form GROW_BASE_PERIMETERx_... where "x" is the new level to grow to
            new_level = int(spellname.split('_')[2][-1])
            # ensure the new level exists in gamedata
            assert new_level >= 0 and new_level <= len(gamedata['map']['base_perimeter'])-1
            # ensure the new level is greater than the current level
            assert new_level > session.viewing_base.base_size
            session.viewing_base.base_size = new_level
            retmsg.append(["BASE_SIZE_UPDATE", session.viewing_base.base_size])
            metric_event_coded(session.user.user_id, '5080_purchase_base_boundary_growth', {'level': new_level,
                                                                                            'currency': currency,
                                                                                            record_price_type: amount_willing_to_pay})
            session.increment_player_metric('base_growth_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_base_growth', record_amount, time_series = False)

        elif spellname.startswith("CHANGE_REGION"):
            if not gameapi.execute_spell(session, retmsg, spellname, spellarg, reason = 'purchased_change_region'):
                raise Exception('player %d %s(%s) purchase failure' % (session.player.user_id, spellname, repr(spellarg)))
            session.increment_player_metric('base_relocations_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_base_relocations', record_amount, time_series = False)
            session.player.send_history_update(retmsg)

        elif spellname == "RESEARCH_FOR_MONEY":
            techname = spellarg
            tech = session.player.get_abtest_spec(TechSpec, techname)
            assert tech

            lab = None # identify which lab was responsible for the research

            for obj in session.player.home_base_iter():
                if obj.is_building() and obj.is_researcher():
                    if tech.research_category in obj.spec.get_research_categories(session.player):
                        lab = obj

            session.give_tech(session.player, retmsg, techname, session.player.tech.get(techname,0)+1, lab, 'instant')

            metric_event_coded(session.user.user_id, '5040_purchase_tech', {'tech_type':techname, 'level':session.player.tech[techname],
                                                                    'currency': currency,
                                                                    record_price_type: amount_willing_to_pay,
                                                                    })
            session.increment_player_metric('techs_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_techs', record_amount, time_series = False)
            session.increment_player_metric('tech:'+techname+':purchased', 1, time_series = False)
            session.increment_player_metric('tech:'+techname+':'+record_spend_type+'_spent', record_amount)

            if session.player.tech[techname] == 1:
                session.increment_player_metric('tech_unlocks_purchased', 1, time_series = False)
                session.increment_player_metric(record_spend_type+'_spent_on_tech_unlocks', record_amount, time_series = False)

            session.activity_classifier.researched_tech()

            if tech.completion:
                session.execute_consequent_safe(tech.get_leveled_quantity(tech.completion, session.player.tech[techname]), session.player, retmsg, reason='tech:completion')

        elif spellname == "ENHANCE_FOR_MONEY":
            object = session.get_object(unit_id)
            enh_name = spellarg[0]
            enh_level = spellarg[1]
            enh_spec = session.player.get_abtest_spec(EnhancementSpec, enh_name)
            session.give_enhancement(session.player, retmsg, object, enh_name, enh_level, 'instant')
            session.activity_classifier.built_or_upgraded_building()
            if enh_spec.completion:
                session.execute_consequent_safe(enh_spec.get_leveled_quantity(enh_spec.completion, enh_level), session.player, retmsg, reason='enhancement:completion')

        elif spellname.startswith("BOOST_") or spellname == "BUY_RESOURCES_TOPUP":
            arg = spellarg if spellname == "BUY_RESOURCES_TOPUP" else None
            assert gameapi.execute_spell(session, retmsg, spellname, arg, reason = 'purchased_boost')
            metric_event_coded(session.user.user_id, '5020_purchase_boost', {'sku':spellname,
                                                                             'currency': currency,
                                                                             record_price_type: amount_willing_to_pay,
                                                                             })
            session.increment_player_metric('resource_boosts_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_resource_boosts', record_amount, time_series = False)

        elif spellname.startswith("BUY_GAMEBUCKS_") or spellname in ("FB_PROMO_GAMEBUCKS", "FB_TRIALPAY_GAMEBUCKS", "XSOLLA_PAYMENT", "FB_GAMEBUCKS_PAYMENT"):
            spell = gamedata['spells'][spellname]
            want_loot = spell.get('loot_table') # whether to give loot items

            if spellname in ("FB_PROMO_GAMEBUCKS", "FB_TRIALPAY_GAMEBUCKS", "XSOLLA_PAYMENT", "FB_GAMEBUCKS_PAYMENT", "BUY_GAMEBUCKS_TOPUP"):
                bucks = int(spellarg)
            else:
                bucks = spell['quantity']
                if want_loot:
                    if spellarg:
                        assert isinstance(spellarg, dict)
                        if not spellarg.get('want_loot', True):
                            want_loot = False

            session.player.resources.gain_gamebucks(bucks, reason='payment')
            session.setvalue_player_metric('gamebucks_balance', session.player.resources.gamebucks, bucket=True, bucket_size=15*60)

            session.setmax_player_metric('largest_purchase_gamebucks', bucks)

            session.increment_player_metric('gamebucks_purchased', bucks)
            session.increment_player_metric(record_spend_type+'_spent_on_gamebucks', record_amount, time_series = False)

            if spellname in ("FB_PROMO_GAMEBUCKS", "FB_TRIALPAY_GAMEBUCKS", "FB_GAMEBUCKS_PAYMENT"):
                session.increment_player_metric('promo_gamebucks_earned', bucks)
                props = {'amount_added':bucks,
                         'sku': spellname,
                         'currency': currency,
                         record_price_type: amount_willing_to_pay}
                if session.player.last_payer_promo > session.user.last_login_time:
                    # if a payer promo was offered during this login, assume the gamebucks were awarded by claiming it
                    session.increment_player_metric('payer_promo_gamebucks_earned', bucks)
                    metric_event_coded(session.user.user_id, '4501_payer_promo_claimed', props.copy())
                metric_event_coded(session.user.user_id, '4590_promo_gamebucks_earned', props.copy())

            items = []
            loggable_items = []
            discovered_where = None

            if want_loot: # item bundle
                assert not gift_order # XXX no code path yet for gifted bundles
                loot_table = gamedata['loot_tables'][spell['loot_table']]
                items += session.get_loot_items(session.player, loot_table['loot'], -1, -1, override_time = override_time)
                if items:
                    loggable_items = copy.deepcopy(items) # because inventory operations might mutate it
                    if session.player.get_any_abtest_value('modal_looting', gamedata['modal_looting']) and \
                       session.player.find_object_by_type(gamedata['inventory_building']):

                        # add directly to inventory, allowing over-stuffed warehouse?
                        bypass_pred = session.player.get_any_abtest_value('buy_gamebucks_bypass_loot_buffer', gamedata['store'].get('buy_gamebucks_bypass_loot_buffer', None))

                        if bypass_pred and ((bypass_pred in (1,True)) or Predicates.read_predicate(bypass_pred).is_satisfied2(session, session.player, {})):
                            # go directly into inventory
                            for item in items:
                                session.player.inventory_add_item(item, -1)
                                spec = gamedata['items'].get(item['spec'])
                                if spec and spec.get('fungible') and spec['resource'] == 'lottery_scans':
                                    session.deferred_player_auras_update = True
                            session.player.send_inventory_update(retmsg)
                            discovered_where = 'inventory'

                        else:
                            # use loot buffer

                            # give promo warehouse space? (XXX note: no GUI for this on the client)
                            promo_warehouse_pred = session.player.get_any_abtest_value('buy_gamebucks_promo_warehouse_space_if', gamedata['store'].get('buy_gamebucks_promo_warehouse_space_if',None))
                            if promo_warehouse_pred and ((promo_warehouse_pred in (1,True)) or Predicates.read_predicate(promo_warehouse_pred).is_satisfied2(session, session.player, {})):
                                cls.give_promo_warehouse_space(session, retmsg, items)

                            session.player.loot_buffer += items
                            retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, True])
                            discovered_where = 'loot_buffer'

                        for item in loggable_items:
                            session.player.inventory_log_event('5125_item_obtained', item['spec'], item.get('stack',1), item.get('expire_time',-1), level=item.get('level',None), reason=spellname)

                    else:
                        session.player.send_loot_mail('', 0, items, retmsg, mail_template = 'gamebucks_loot_mail')
                        discovered_where = 'messages'


                if items:
                    extra_description = Store.buy_gamebucks_sku_get_loot_table_parameter(session, session.player, loot_table, 'metrics_description')
                    if extra_description:
                        price_description.append(extra_description)

                # very important to do this last, since it may change the loot/description

                # consequent on a loot table attached to the spell
                on_purchase_cons = Store.buy_gamebucks_sku_get_loot_table_parameter(session, session.player, loot_table, 'on_purchase')
                if on_purchase_cons:
                     session.execute_consequent_safe(on_purchase_cons, session.player, retmsg, reason=spellname+':loot_table')

            # consequent on the spell itself
            if 'on_purchase' in spell:
                session.execute_consequent_safe(spell['on_purchase'], session.player, retmsg, reason=spellname+':on_purchase')


            # show "additional" gamebucks earned for purchase as if it were an item
            if 'nominal_quantity' in spell and spell['nominal_quantity'] < spell['quantity'] and \
               cls.buy_gamebucks_dialog_gamebucks_as_item(session, session.player):
                gamebucks_item = {'spec':'gamebucks', 'stack': spell['quantity'] - spell['nominal_quantity']}
                items = [gamebucks_item,] + items
                loggable_items = [gamebucks_item,] + loggable_items
                if discovered_where is None:
                    discovered_where = 'inventory' # assume already added

            if loggable_items and discovered_where:
                retmsg.append(["ITEMS_DISCOVERED", loggable_items, -1, discovered_where])

            if gift_order:
                # try to send gamebucks gift. On failure, leave the gamebucks in the player's balance
                total_gift_amount = 0
                for entry in gift_order['gifts']:
                    if total_gift_amount > bucks: break
                    entry['success'] = False
                    ui_data = gamedata['strings']['gift_order_mail']
                    item_name = 'alloy' if SpinConfig.game()=='mf' else 'gamebucks'
                    gift_amount = entry['gamebucks']
                    assert gift_amount >= 1
                    if session.player.resources.gamebucks < gift_amount:
                        gamesite.exception_log.event(server_time, 'player %d insufficient gamebucks to send gift' % (session.user.user_id))
                        break
                    recipient_user_id = entry['recipient_user_id']
                    if recipient_user_id == session.user.user_id: continue # just to be safe
                    gamesite.msg_client.msg_send([{'type': 'mail',
                                                   'gift_order': gift_order,
                                                   'from': session.player.user_id,
                                                   'to': [recipient_user_id],
                                                   'expire_time': server_time + gamedata['server']['message_expire_time']['gift_order'],
                                                   'from_fbid': str(session.user.facebook_id),
                                                   'from_name': unicode(session.user.get_chat_name(session.player)),
                                                   'attachments': [{'spec':item_name, 'stack':gift_amount}],
                                                   'subject': ui_data['ui_subject'].replace('%sender', session.user.get_chat_name(session.player)).replace('%GAMEBUCKS_NAME',gamedata['store']['gamebucks_ui_name']),
                                                   'body': ui_data['ui_body'].replace('%sender', session.user.get_chat_name(session.player)).replace('%GAMEBUCKS_NAME',gamedata['store']['gamebucks_ui_name']).replace('%time', time.strftime('%H:%S', time.gmtime(server_time))).replace('%day', time.strftime('%d %b %Y', time.gmtime(server_time)))}])
                    session.player.resources.gain_gamebucks(-gift_amount, reason='gift_order')
                    total_gift_amount += gift_amount
                    entry['success'] = True
                    session.increment_player_metric('gift_orders_sent', 1, time_series = False)
                    session.increment_player_metric('gamebucks_spent_on_gift_orders', gift_amount, time_series = False)

                    # send notifications

                    # to sender
                    config = gamesite.get_localized_gamedata('fb_notifications', session.user.locale)['notifications'].get('you_sent_gift_order',None)
                    if config and session.user.facebook_id:
                        notif_text = config['ui_name'].replace('%GAMEBUCKS_AMOUNT', str(gift_amount)).replace('%RECEIVER', entry['recipient_ui_name']).replace('%GAMEBUCKS_NAME',gamedata['store']['gamebucks_ui_name'])
                        gamesite.gameapi.send_offline_notification(session.user.user_id, session.user.social_id, notif_text, 'you_sent_gift_order', config['ref'], session.player.get_denormalized_summary_props('brief'), locale = session.user.locale) # FB gift order

                    # to recipient
                    config = gamesite.get_localized_gamedata('fb_notifications', gamesite.get_locale_for_player(recipient_user_id, reason = 'you_got_gift_order'))['notifications'].get('you_got_gift_order',None)
                    if config and entry.get('recipient_facebook_id'):
                        notif_text = config['ui_name'].replace('%GAMEBUCKS_AMOUNT', str(gift_amount)).replace('%SENDER', session.user.get_chat_name(session.player)).replace('%GAMEBUCKS_NAME',gamedata['store']['gamebucks_ui_name'])
                        gamesite.do_CONTROLAPI(session.user.user_id, {'method':'send_notification','reliable':1,'user_id':recipient_user_id,'text':notif_text,'config':'you_got_gift_order','force':1})

                retmsg.append(["YOU_SENT_GIFT_ORDER", gift_order])

            if ('give_units' in spell) and (not gift_order):
                if session.player.get_any_abtest_value('reward_units_by_mail', gamedata['reward_units_by_mail']):
                    cc_level = session.player.get_townhall_level() if ('level_by_cc' in spell['give_units']) else -1

                    # pick appropriate packaged item SKU for the unit at the level the player is going to get
                    def item_sku(player, unit_name, cc_level):
                        level = max(player.tech.get(gamedata['units'][unit_name]['level_determined_by_tech'],0),1)
                        if cc_level < 0:
                            # no automatic upgrade by CC - round conservatively
                            if level >= 8: level = 8
                            elif level >= 4: level = 4
                            else: level = 1
                        else:
                            table = gamedata['reward_unit_level_by_cc_level']
                            index = min(max(cc_level-1, 0), len(table)-1)
                            level = max(level, table[index])

                            # round generously
                            if level > 4: level = 8
                            elif level > 1: level = 4
                            else: level = 1

                        return 'packaged_'+unit_name+ (('_L%d' % level) if (level > 1) else '')

                    unit_items = [{'spec':item_sku(session.player, name, cc_level), 'stack':qty} for name, qty in spell['give_units'].iteritems() if (name in gamedata['units'])]
                    session.player.send_loot_mail('', 0, unit_items, retmsg, mail_template = 'buy_gamebucks_bonus_mail')
                    retmsg.append(["YOU_GOT_BONUS_UNITS"])
                else:
                    session.spawn_new_units_for_player(session.player, retmsg, spell['give_units'])

            session.deferred_player_state_update = True

            if 1:
                # the other purchase_ui_log events are all client-side, but we have to do this on the server
                # because Facebook's credit API callback is unreliable :(
                purchase_ui_event_props = {'code':4450, 'event_name': '4450_buy_gamebucks_payment_complete',
                                           'user_id': session.player.user_id,
                                           'sku': Store.get_description(session, unit_id, spellname, spellarg, price_description),
                                           'api': currency.split(':')[0],
                                           'gamebucks': bucks,
                                           'currency': currency, 'currency_price': amount_willing_to_pay,
                                           'usd_equivalent': usd_equivalent,
                                           'last_purchase_time': session.player.history.get('last_purchase_time',-1),
                                           'prev_largest_purchase': session.player.history.get('largest_purchase',0),
                                           'num_purchases': session.player.history.get('num_purchases',0),
                                           'gift_order': gift_order,
                                           'gui_version': Predicates.eval_cond_or_literal(session.player.get_any_abtest_value('buy_gamebucks_dialog_version', gamedata['store'].get('buy_gamebucks_dialog_version',1)), session, session.player),
                                           'gui_look': Predicates.eval_cond_or_literal(session.player.get_any_abtest_value('buy_gamebucks_dialog_look', gamedata['store'].get('buy_gamebucks_dialog_look',None)), session, session.player),
                                           }
                for aura in session.player.player_auras_iter_const():
                    if aura['spec'] in ('null_sale','flash_sale','item_bundles') and aura.get('end_time', -1) > server_time:
                        for FIELD in ('kind', 'duration', 'tag'):
                            if FIELD in aura['data']:
                                purchase_ui_event_props['flash_sale_'+FIELD] = aura['data'][FIELD]
                gamesite.purchase_ui_log.event(server_time, purchase_ui_event_props)

        elif spellname.startswith("BUY_PROTECTION"):
            assert gameapi.execute_spell(session, retmsg, spellname, None, reason = 'purchased_protection')
            session.increment_player_metric('protections_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_protection', record_amount, time_series = False)

        elif spellname.startswith("FREE_RANDOM_") or spellname.startswith("BUY_RANDOM_"):
            # returns item list here for logging
            items = gameapi.execute_spell(session, retmsg, spellname, None, reason = 'purchased_random_item')
            assert items
            price_description.append(SpinJSON.dumps({'items':items}))
            if (not spellname.startswith("FREE_RANDOM_")):
                session.increment_player_metric('random_items_purchased', 1, time_series = False)
                session.increment_player_metric(record_spend_type+'_spent_on_random_items', record_amount, time_series = False)
            else:
                session.increment_player_metric('free_random_items', 1, time_series = False)
            session.player.send_history_update(retmsg)

        elif spellname == "BUY_ITEM":
            assert gameapi.execute_spell(session, retmsg, spellname, spellarg, reason = 'purchased_item')
            if 'item' in spellarg['skudata']:
                session.increment_player_metric('item:'+spellarg['skudata']['item']+':purchased', int(spellarg['skudata'].get('stack',1)), time_series = False)
            session.increment_player_metric('items_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_items', record_amount, time_series = False)

        elif spellname == "CHANGE_ALIAS":
            if not gameapi.execute_spell(session, retmsg, spellname, spellarg, reason = 'purchased_alias_change'):
                try:
                    err_arg = SpinHTTP.unwrap_string(spellarg[0])
                except:
                    err_arg = repr(spellarg)
                raise Exception('player %d %s(%s) purchase failure' % (session.player.user_id, spellname, err_arg))
            session.increment_player_metric('alias_changes_purchased', 1, time_series = False)
            session.player.send_history_update(retmsg)

        elif spellname == "BUY_LOTTERY_TICKET":
            scanner = session.player.find_lottery_building()
            assert scanner
            scanner.contents += 1
            session.increment_player_metric('lottery_tickets_purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_lottery_tickets', record_amount, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_lottery', record_amount, time_series = False)
            retmsg.append(["OBJECT_STATE_UPDATE2", scanner.serialize_state()])

        elif spellname == "LOTTERY_SCAN":
            object = session.get_object(unit_id)
            assert gameapi.do_lottery_scan(session, retmsg, object, spellname, 'paid')

        elif spellname.startswith("OFFER"):
            spell = gamedata['spells'][spellname]
            assert gameapi.execute_spell(session, retmsg, spell['effect']['spellname'], spell['effect']['spellarg'], reason = 'flash_offer')

            # only allow one purchase
            if spell.get('flash_offer',False): session.player.flash_offer = None

            session.increment_player_metric('flash_offers_purchased', 1, time_series = False)
            session.increment_player_metric('flash_offer:'+spellname+':purchased', 1, time_series = False)
            session.increment_player_metric(record_spend_type+'_spent_on_flash_offers', record_amount, time_series = False)

        else:
            raise Exception('Unknown paid spell ' + spellname)

        return price_description, detail_props

    @classmethod
    def give_promo_warehouse_space(cls, session, retmsg, items):
        warehouse = session.player.find_object_by_type(gamedata['inventory_building'])
        if not warehouse: return False
        if warehouse.level >= warehouse.spec.maxlevel: return False
        can_fit = False
        while warehouse.level < warehouse.spec.maxlevel:
            can_fit, extra_slots_needed = inventory_items_can_all_fit(items, session.player.inventory, session.player.resources.calc_snapshot())
            if can_fit: break
            if not gamesite.gameapi.do_upgrade_instant(session, retmsg, warehouse, ignore_requires = True): break
            metric_event_coded(session.user.user_id, '4461_promo_warehouse_upgrade', {'level': warehouse.level})

        return can_fit

    @classmethod
    def buy_gamebucks_dialog_gamebucks_as_item(cls, session, player):
        # whether to show "extra" discount gamebucks in ITEMS_DISCOVERED even though they are just part of the SKU
        # this should happen whenever the "version 2" scrollable buy_gamebucks dialog is in use
        return Predicates.eval_cond_or_literal(player.get_any_abtest_value('buy_gamebucks_dialog_version', gamedata['store'].get('buy_gamebucks_dialog_version',1)), session, player) == 2

    # retrieve a parameter on a loot-bearing BUY_GAMEBUCKS SKU by inspecting its loot table
    # (similar to client's buy_gamebucks_sku2_get_loot_table_parameter())
    @classmethod
    def buy_gamebucks_sku_get_loot_table_parameter(cls, session, player, master_table, param_name):
        # note: this has some opinions about the loot table structure.
        # case 1 - parameter is on the master loot table
        if param_name in master_table:
            return Predicates.eval_cond_or_literal(master_table[param_name], session, player)

        # case 2 - master loot table indirects exactly once to another table
        if len(master_table['loot']) < 1: return None # empty
        if 'multi' in master_table['loot'][0]: return None # literal table
        if 'cond' not in master_table['loot'][0]: raise Exception('unexpected master loot table structure: %r' % master_table['loot'])
        table_ref = Predicates.eval_cond_or_literal(master_table['loot'][0]['cond'], session, player)
        if table_ref:
            if 'table' not in table_ref: raise Exception('unexpected subordinate loot table structure: %r' % table_ref)
            sub_table = gamedata['loot_tables'][table_ref['table']]
            if param_name in sub_table:
                return Predicates.eval_cond_or_literal(sub_table[param_name], session, player)

        return None

def fungible_inventory_item_can_fit(spec, stack, resource_state):
    if spec['resource'] == 'gamebucks': return True
    elif spec['resource'] in resource_state:
        return (stack + resource_state[spec['resource']][1] <= resource_state[spec['resource'][0]])
    return False

# returns (can_fit, extra_slots_needed)
def inventory_items_can_all_fit(items, inventory, snapshot):
    max_usable_inventory = snapshot.max_usable_inventory()
    can_fit = True
    extra_slots_needed = 0

    # operate on a copy of the inventory and resources
    scratch = copy.deepcopy(inventory)
    scratch_resource_state = dict((res,[snapshot.max_res(res), snapshot.cur_res(res)]) for res in gamedata['resources'])

    for item in items:
        spec = gamedata['items'][item['spec']]
        max_stack = spec.get('max_stack', 1)
        togo = item.get('stack', 1)

        if spec.get('fungible'):
            # check for entire fungible amount to fit
            if fungible_inventory_item_can_fit(spec, togo, scratch_resource_state):
                if spec['resource'] in scratch_resource_state:
                    scratch_resource_state[spec['resource']][1] += togo
                continue
            else:
                can_fit = False
                extra_slots_needed += 1
        else:
            # check for stackable item
            for inv in scratch:
                if inv['spec'] == item['spec'] and inv.get('level',1) == item.get('level',1):
                    inv_stack = inv.get('stack',1)
                    if inv_stack < max_stack:
                        added = min(togo, max_stack - inv_stack)
                        togo -= added
                        inv['stack'] = inv_stack + added

            if togo <= 0: continue # able to accommodate everything just by stacking
            if len(scratch) >= max_usable_inventory:
                # now we need another slot
                can_fit = False
                extra_slots_needed += 1
            scratch.append(copy.deepcopy(item))

    return can_fit, extra_slots_needed

class CREDITAPI(resource.Resource):
    isLeaf = True
    def __init__(self, gameapi):
        resource.Resource.__init__(self)
        self.gameapi = gameapi
    def render_GET(self, request):
        return self.render_POST(request)
    def render_POST(self, request):
        SpinHTTP.set_access_control_headers(request)
        ret = catch_all('CREDITAPI')(self.handle_request)(request)
        if ret is None:
            request.setResponseCode(http.BAD_REQUEST)
            ret = 'spinpunch error'
        return ret

    @admin_stats.measure_latency('CREDITAPI')
    def handle_request(self, request):
        SpinHTTP.set_access_control_headers(request)

        signed_request = request.args['signed_request'][0]
        request_data = SpinFacebook.parse_signed_request(signed_request, SpinConfig.config['facebook_app_secret'])
        if request_data is None:
            raise Exception('bad signature: checksum verification failed')

        method = request.args['method'][0]

        #print "PAYMENT REQUEST", method, request_data

        # check expiration time of signed request
        if request_data.has_key('expires') and \
           (server_time >= int(request_data['expires'])) and \
           spin_secure_mode:
            raise Exception('bad signature: timestamp expired')

        retmsg = {}
        retmsg['method'] = method

        if method == 'payments_get_item_price':
            # NEW FB Payments flow (with dynamic pricing)
            if gamedata['server']['log_fbpayments'] >= 3:
                gamesite.exception_log.event(server_time, 'payments_get_item_price %s' % (repr(request_data)))
            payment = request_data['payment']
            #request_id = payment['request_id']
            quantity = int(payment['quantity'])
            product_url = str(payment['product'])
            user_currency = payment['user_currency'] # note: ignore this, because we want to use the spell currency

            # sanity-check the SKU
            query = urlparse.parse_qs(urllib.splitquery(product_url)[1])

            assert (quantity == 1)
            assert len(query) == 2 and ('type' in query) and ('spellname' in query)
            assert str(query['type'][0]) == OGPAPI.object_type('sku')
            spellname = str(query['spellname'][0])
            assert OGPAPI_instance.matches_object_endpoint(product_url, {'type':OGPAPI.object_type('sku'), 'spellname': spellname})
            spell = gamedata['spells'][spellname]
            assert spell['price_formula'] == 'constant' # price must be only a function of the URL!
            assert 'currency' in spell
            assert spell['currency'].startswith('fbpayments:')

            session = get_session_by_facebook_id(request_data['user_id'])
            if session is None:
                gamesite.exception_log.event(server_time, 'payments_get_item_price on unknown session: %s' % repr(request_data))

            # shouldn't depend on these
            user_id = session.user.user_id if session else 0
            unit_id = GameObject.VIRTUAL_ID
            spellarg = None

            price_description = []
            error_reason = []

            price = Store.get_price(session, spell['currency'], unit_id, spell, spellarg, price_description, error_reason)
            if price < 0:
                raise Exception(('make_credit_order(user %s spell %s): Invalid order by user %d: ' % (user_currency, spell['currency'], user_id)) + repr(payment) + ' get_price() failed with reason: '+ repr(error_reason))

            retmsg['content'] = {
                # note: can override title and description here, if necessary, as well as quantity min/max limits
                'product': product_url,
                'amount': price,
                'currency': spell['currency'].split(':')[1]
                }
            metric_event_coded(user_id, '4073_fbpayments_order_prompt_response', copy.deepcopy(retmsg['content']))

        else:
            # OLD FB Credits flow
            payload = request_data['credits']
            order_id = payload['order_id']

            if method == 'payments_get_items':
                buyer = str(payload.get('buyer', -1))
                receiver = str(payload.get('receiver', -1))
                order_info = SpinJSON.loads(payload['order_info'])

                item = Store.make_credit_order(order_id, order_info, 'fbcredits')

                retmsg['content'] = [item]

            elif method == 'payments_status_update':
                order_details = SpinJSON.loads(payload['order_details'])
                # override order_id with value from order_details, according to instructions at http://developers.facebook.com/docs/payments/callback/
                order_id = order_details.get('order_id', order_id)
                buyer = str(order_details.get('buyer', -1))
                receiver = str(order_details.get('receiver', -1))
                fb_credits_amount = order_details['amount']
                status = payload['status']

                if status == 'placed':
                    # okay to actually give the stuff here
                    session = Store.execute_credit_order(order_id, self.gameapi, None, buyer, receiver, 'fbcredits', fb_credits_amount, SpinFacebook.order_data_decode(order_details['items'][0]['data']))

                    if not session: raise Exception('execute_credit_order() returned no session')

                    retmsg['content'] = {}
                    retmsg['content']['order_id'] = order_id
                    retmsg['content']['status'] = 'settled'

                    # do not return HTTP response until player state is fully flushed
                    def complete_settlement(request, session, retmsg):
                        # send mtime/spend update to player cache so upcache will pick it up immediately
                        gamesite.pcache_client.player_cache_update(session.user.user_id,
                                                                   {'last_mtime': server_time,
                                                                    'money_spent': session.player.history.get('money_spent',0.0)}, reason = 'purchase')

                        # update the user's credit balance
                        # (after a delay, to allow time for Facebook to process the order)
                        reactor.callLater(10, session.user.retrieve_facebook_credit_info_start)

                        request.write(SpinJSON.dumps(retmsg))
                        request.finish()

                    player_table.store_async(session.player, functools.partial(complete_settlement, request, session, retmsg), True, 'CREDITAPI')
                    return server.NOT_DONE_YET

                elif status == 'settled':
                    # spurious second call, do nothing
                    retmsg['content'] = {}
                    retmsg['content']['status'] = 'settled'

                elif status == 'disputed':
                    gamesite.exception_log.event(server_time, 'Order disputed! '+ repr(order_id) + ' ' + repr(order_details))
                    #retmsg['content'] = {}
                    #retmsg['content']['status'] = 'refunded'

                    my_data = SpinFacebook.order_data_decode(order_details['items'][0]['data'])

                    session_id = my_data['session_id']
                    session = get_session_by_session_id(session_id)
                    assert session
                    unit_id = my_data['unit_id']

                    # XXX spell may be undefined here when the order is a Facebook payer promo, need to fix this.

                    spellname = my_data['spellname']
                    spell = gamedata['spells'][spellname]
                    spellarg = my_data.get('spellarg', None)



                    price_description = []
                    error_reason = []

                    # just to fill in price_description as a side effect
                    Store.get_price(session, 'fbcredits', unit_id, spell, spellarg, price_description, error_reason)

                    dollar_amount = Store.fbcredits_to_dollars(fb_credits_amount)
                    descr = Store.get_description(session, unit_id, spellname, spellarg, price_description)

                    metric_event_coded(session.user.user_id, '1300_order_disputed', {'Billing Amount': -dollar_amount,
                                                                                     'Billing Description': descr,
                                                                                     'order_id': order_id
                                                                                     })

                    gamesite.credits_log.event(server_time, {'user_id':session.user.user_id,
                                                             'event_name':'1300_order_disputed',
                                                             'code':1300,
                                                             'Billing Amount': -dollar_amount,
                                                             'Billing Description': descr,
                                                             'order_id': order_id
                                                             })



                else:
                    raise Exception('unhandled payment status ' + status)
            else:
                raise Exception('unhandled method ' + method)

        return SpinJSON.dumps(retmsg)

# Kongregate API endpoint, mainly for payments

class KGAPI(resource.Resource):
    isLeaf = True
    def __init__(self, gameapi):
        resource.Resource.__init__(self)
        self.gameapi = gameapi
        self.kg_api_key = SpinConfig.config.get('kongregate_api_key', 'unknown')
        self.kg_api_url = 'KGAPI'
    def render_GET(self, request):
        return self.render_POST(request)
    def render_POST(self, request):
        SpinHTTP.set_access_control_headers(request)
        ret = catch_all(self.kg_api_url)(self.handle_request)(request)
        if ret is None:
            request.setResponseCode(http.BAD_REQUEST)
            ret = 'spinpunch error'
        return ret

    @admin_stats.measure_latency('KGAPI')
    def handle_request(self, request):
        SpinHTTP.set_access_control_headers(request)

        signed_request = request.args['signed_request'][0]
        request_data = SpinKongregate.parse_signed_request(signed_request, self.kg_api_key)
        if not request_data:
            raise Exception('bad signature: checksum verification failed')

        order_id = str(request_data['order_id'])
        order_info = SpinFacebook.order_data_decode(request_data['order_info'])
        retmsg = {}

        if request_data['event'] == 'item_order_request':

            retmsg['items'] = [Store.make_credit_order(order_id, order_info, 'kgcredits')]

        elif request_data['event'] == 'item_order_placed':

            retmsg['status'] = 'canceled' # first set this in case of failure

            # okay to actually give the stuff here
            session = Store.execute_credit_order(order_id, self.gameapi, None,
                                                 str(request_data['buyer_id']),
                                                 str(request_data['recipient_id']),
                                                 'kgcredits', order_info['client_price'], # must trust this?
                                                 order_info)

            if not session: raise Exception('execute_kgcredit_order() returned no session')

            # do not return HTTP response until player state is fully flushed
            def complete_settlement(request, session, retmsg):
                retmsg['state'] = 'completed'
                # send mtime/spend update to player cache so upcache will pick it up immediately
                gamesite.pcache_client.player_cache_update(session.user.user_id,
                                                           {'last_mtime': server_time,
                                                            'money_spent': session.player.history.get('money_spent',0.0)}, reason = 'purchase')
                request.write(SpinJSON.dumps(retmsg))
                request.finish()

            player_table.store_async(session.player, functools.partial(complete_settlement, request, session, retmsg), True, self.kg_api_url)
            return server.NOT_DONE_YET
        else:
            raise Exception('unhandled "event" ' + request_data['event'])

        return SpinJSON.dumps(retmsg)

# Kongregate API endpoint, mainly for payments

class K2API(KGAPI):
    def __init__(self, *args, **kwargs):
        KGAPI.__init__(self, *args, **kwargs)
        self.kg_api_key = SpinConfig.config.get('kongregate2_api_key', 'unknown')
        self.kg_api_url = 'K2API'

# TrialPay API endpoint - see http://help.trialpay.com/facebook/offer-wall/

class TRIALPAYAPI(resource.Resource):
    isLeaf = True
    def __init__(self, gameapi):
        resource.Resource.__init__(self)
        self.gameapi = gameapi
    def render_GET(self, request):
        return self.render_POST(request)
    def render_POST(self, request):
        SpinHTTP.set_access_control_headers(request)
        ret = catch_all('TRIALPAYAPI')(self.handle_request)(request)
        if ret is None:
            request.setResponseCode(http.BAD_REQUEST)
            ret = 'spinpunch error'
        return ret

    @admin_stats.measure_latency('TRIALPAYAPI')
    def handle_request(self, request):
        SpinHTTP.set_access_control_headers(request)
        # find session
        user_id = int(request.args['order_info'][0])
        session = get_session_by_user_id(user_id)
        if not session:
            raise Exception('session not found for TRIALPAYAPI order (user_id %d)' % user_id)
        return self.handle_payment(request, session,
                                   SpinHTTP.get_twisted_header(request, 'TrialPay-HMAC-MD5'),
                                   request.args,
                                   request.content.read())

    def handle_payment(self, request, session, their_hash, request_args, request_body):
        # note: request may be null if this is called asynchronously
        # confirm Facebook App ID matches
        assert str(request_args['app_id'][0]) == SpinConfig.config['facebook_app_id']

        # verify hash
        our_hash = hmac.new(str(SpinConfig.config['trialpay_notification_key']), msg=str(request_body), digestmod=hashlib.md5).hexdigest()
        if their_hash != our_hash:
            raise Exception('TRIALPAYAPI hash mismatch: theirs %s ours %s body %r' % (their_hash, our_hash, request_body))

        gamebucks_amount = int(request_args['reward_amount'][0])

        if gamebucks_amount > 0:
            # we (ab)use the credit order path here to share all of its metrics output
            Store.execute_credit_order(request_args['oid'][0], self.gameapi, session, session.user.facebook_id, session.user.facebook_id,
                                       'gamebucks', gamebucks_amount,
                                       # awkward syntax here
                                       {'spellname': 'FB_TRIALPAY_GAMEBUCKS',
                                        'session_id': session.session_id,
                                        'currency_url': str(request_args['currency_url'][0])})

            # As of September 2015, TrialPay is now doing rapid-fire transactions on small amounts (~2 gamebucks)
            # that cause asynchronous stores to overlap. So, only synchronize on large transactions.

            if gamebucks_amount >= gamedata['server'].get('trialpay_sync_threshold',50):
                # do not return HTTP response until player state is fully flushed

                def complete_settlement(request, session):
                    # send mtime/spend update to player cache so upcache will pick it up immediately
                    gamesite.pcache_client.player_cache_update(session.user.user_id,
                                                               {'last_mtime': server_time,
                                                                'money_spent': session.player.history.get('money_spent',0.0)}, reason = 'purchase')
                    if request:
                        request.write('1')
                        request.finish()

                player_table.store_async(session.player, functools.partial(complete_settlement, request, session), True, 'TRIALPAYAPI')
                return server.NOT_DONE_YET

        return str('1')

# Xsolla API endpoint

class XSAPI(resource.Resource):
    isLeaf = True
    def __init__(self, gameapi):
        resource.Resource.__init__(self)
        self.gameapi = gameapi
    def render_GET(self, request):
        return self.render_POST(request)
    def render_POST(self, request):
        SpinHTTP.set_access_control_headers(request)
        ret = catch_all('XSAPI')(self.handle_request)(request)
        if ret is None:
            request.setResponseCode(http.BAD_REQUEST)
            ret = SpinJSON.dumps({'error': {'code':'FATAL_ERROR', 'message': 'game server exception'}})
        return ret

    @admin_stats.measure_latency('XSAPI')
    def handle_request(self, request):
        request_body = request.content.read()

        # check signature
        their_sig = SpinHTTP.get_twisted_header(request, 'Authorization')[len('Signature '):]
        our_sig = SpinXsolla.make_signature(SpinConfig.config, request_body)
        if their_sig != our_sig:
            gamesite.exception_log.event(server_time, 'XSAPI hash mismatch: theirs %s ours %s body %r' % (their_sig, our_sig, request_body))
            request.setResponseCode(http.BAD_REQUEST)
            return SpinJSON.dumps({'error': {'code':'INVALID_SIGNATURE', 'message': 'XSAPI hash mismatch (by server)'}})

        request_data = SpinJSON.loads(request_body)

        # find session
        xs_id = request_data['user']['id']
        session = get_session_by_xsolla_id(xs_id)
        if not session:
            if 0: # old path, drops order (subject to race condition from proxyserver dispatching here)
                gamesite.exception_log.event(server_time, 'session not found for XSAPI order (xs_id %s)' % xs_id)
                request.setResponseCode(http.BAD_REQUEST)
                # do not send INVALID_USER, because Xsolla caches this, and we don't want to cache "invalid" for a valid
                # user who does not happen to be logged in right now.
                return SpinJSON.dumps({'error': {'code':'INCORRECT_INVOICE', 'message': 'session not found (by server)'}})

            else: # new path, queues
                user_id = gamesite.social_id_table.social_id_to_spinpunch(xs_id, False)
                if user_id:
                    gamesite.exception_log.event(server_time, 'session not found for XSAPI order (xs_id %s user_id %d), queueing' % (xs_id, user_id))
                    gamesite.msg_client.msg_send([{'to':[user_id],
                                                   'type':'XSAPI_' + request_data['notification_type'],
                                                   'time':server_time,
                                                   'expire_time': server_time + SpinConfig.config['proxyserver'].get('XSAPI_payment_msg_duration', 30*24*60*60),
                                                   'response': request_data}])
                    # payment accepted from Xsolla now; will be handled when player logs in
                    request.setResponseCode(http.NO_CONTENT)
                    return ''

                else:
                    gamesite.exception_log.event(server_time, 'session not found for XSAPI order (xs_id %s), NOT queueing!' % xs_id)
                    request.setResponseCode(http.BAD_REQUEST)
                    # do not send INVALID_USER, because Xsolla caches this, and we don't want to cache "invalid" for a valid
                    # user who does not happen to be logged in right now.
                    return SpinJSON.dumps({'error': {'code':'INCORRECT_INVOICE', 'message': 'session not found (by server)'}})

        if request_data['notification_type'] == 'user_validation':
            # since we found the session, the user is already considered valid
            pass
        elif request_data['notification_type'] == 'payment':
            return self.handle_payment(request, session, request_data)
        else:
            raise Exception('unknown XSAPI notification_type '+request_data['notification_type'])

        request.setResponseCode(http.NO_CONTENT)
        return ''

    def handle_payment(self, request, session, request_data):
        if request_data['transaction'].get('dry_run',0) and spin_secure_mode and not SpinConfig.config.get('xsolla_sandbox_mode', False):
            raise Exception('sandbox purchases not allowed in secure mode')

        # find spellname and spellarg
        spellname = None
        spellarg = None

        if 'virtual_currency' in request_data['purchase']:
            real_currency = 'xsolla:'+request_data['purchase']['virtual_currency']['currency']
            real_currency_amount = request_data['purchase']['virtual_currency']['amount']

            # try to find the source SKU this purchase came from
            gamebucks_amount = int(request_data['purchase']['virtual_currency']['quantity'])
            spellname, spellarg = session.user.find_buy_gamebucks_spell(session, real_currency, real_currency_amount, gamebucks_amount)
            if spellname is None: # fallback
                spellname = 'XSOLLA_PAYMENT'
                spellarg = gamebucks_amount

        elif 'checkout' in request_data['purchase']: # simple checkout
            real_currency = 'xsolla:'+request_data['purchase']['checkout']['currency']
            real_currency_amount = request_data['purchase']['checkout']['amount']

            # look for SKU here based on order parameters
            if 'custom_parameters' in request_data and 'spin_spellname' in request_data['custom_parameters']:
                spellname = request_data['custom_parameters']['spin_spellname']
                spin_spellarg = request_data['custom_parameters'].get('spin_spellarg')
                if spin_spellarg:
                    spellarg = SpinJSON.loads(spin_spellarg)

            else:
                # fallback path to determine gamebucks value
                gamesite.exception_log.event(server_time, 'player %d missing custom_parameters for purchase: %r' % (session.user.user_id, request_data['purchase']))

                for entry in gamedata['store']['gamebucks_open_graph_prices']:
                    currency, str_value = entry[0], entry[1]
                    if currency == str(request_data['purchase']['checkout']['currency']):
                        gamebucks_amount = int((real_currency_amount / float(str_value)) + 0.5)
                        spellname, spellarg = session.user.find_buy_gamebucks_spell(session, real_currency, real_currency_amount, gamebucks_amount)
                        if spellname is None: # fallback - raw gamebuck purchase at equivalent value
                            spellname = 'XSOLLA_PAYMENT'
                            spellarg = gamebucks_amount
                        break

        if spellname is None:
            raise Exception('cannot determine spellname for this purchase: %r' % request_data['purchase'])

        if True:
            # we (ab)use the credit order path here to share all of its metrics output
            assert request_data['payment_details']['payout']['currency'] == 'USD'
            usd_receipts = request_data['payment_details']['payout']['amount']

            # take out Armor Games' 40% revenue share from usd_receipts, since it's used for management reporting purposes
            if session.user.frame_platform == 'ag':
                usd_receipts = round(usd_receipts*0.6, 2)

            Store.execute_credit_order(request_data['transaction']['id'], self.gameapi, session,
                                       request_data['user']['id'], request_data['user']['id'],
                                       real_currency,
                                       real_currency_amount,
                                       # awkward syntax here
                                       {'spellname': spellname, 'spellarg': spellarg, 'unit_id': GameObject.VIRTUAL_ID,
                                        'session_id': session.session_id,
                                        'usd_receipts': usd_receipts})

            # do not return HTTP response until player state is fully flushed
            def complete_settlement(request, session):
                # send mtime/spend update to player cache so upcache will pick it up immediately
                gamesite.pcache_client.player_cache_update(session.user.user_id,
                                                           {'last_mtime': server_time,
                                                            'money_spent': session.player.history.get('money_spent',0.0)}, reason = 'purchase')
                if request:
                    request.setResponseCode(http.NO_CONTENT)
                    request.write('')
                    request.finish()

            player_table.store_async(session.player, functools.partial(complete_settlement, request, session), True, 'XSAPI')
            return server.NOT_DONE_YET

        request.setResponseCode(http.NO_CONTENT)
        return ''

    def handle_refund(self, request, session, request_data):
        order_id = request_data['transaction']['id']
        entry = None
        for ent in session.player.history.get('money_purchase_history',[]):
            if ('order_id' in ent) and str(ent['order_id']) == order_id:
                entry = ent
                break
        if not entry: return False # never completed
        if entry.get('refunded',0): return False # already refunded

        real_currency = 'xsolla:'+request_data['purchase']['checkout']['currency']
        real_currency_amount = request_data['purchase']['checkout']['amount']

        # look for SKU here based on order parameters
        if 'custom_parameters' in request_data and 'spin_spellname' in request_data['custom_parameters']:
            spellname = request_data['custom_parameters']['spin_spellname']
            spin_spellarg = request_data['custom_parameters'].get('spin_spellarg')
            if spin_spellarg:
                spellarg = SpinJSON.loads(spin_spellarg)

        else:
            # fallback path to determine gamebucks value
            gamesite.exception_log.event(server_time, 'player %d missing custom_parameters for purchase: %r' % (session.user.user_id, request_data['purchase']))

            for entry in gamedata['store']['gamebucks_open_graph_prices']:
                currency, str_value = entry[0], entry[1]
                if currency == request_data['purchase']['checkout']['currency']:
                    gamebucks_amount = int((real_currency_amount / float(str_value)) + 0.5)
                    spellname, spellarg = session.user.find_buy_gamebucks_spell(session, real_currency, real_currency_amount, gamebucks_amount)
                    if spellname is None: # fallback - raw gamebuck purchase at equivalent value
                        spellname = 'XSOLLA_PAYMENT'
                        spellarg = gamebucks_amount
                    break

        refund_type = 'refund'
        paid_amount = request_data['payment_details']['payment']['amount']
        tax_amount = request_data['payment_details']['sales_tax']['amount']
        user_facing_amount = paid_amount
        paid_currency = request_data['purchase']['payment']['currency']
        refund_amount = paid_amount
        refund_tax_amount = tax_amount
        refund_currency = paid_currency

        try:
            usd_equivalent = request_data['payment_details']['payout']['amount']
            item = spellname
            gamebucks = session.user.parse_buy_gamebucks_spell_quantity(spellname, spellarg)
            gift_order = entry.get('gift_order', None)
            time_struct = time.gmtime(server_time)

            if gamedata['store'].get('enable_refunds', True):
                gift_refund = 0
                if gift_order and (gamedata['store'].get('refund_gift_order_from','recipient') == 'recipient'):
                    gift_refund += session.user.refund_gift_order(session, session.outgoing_messages, time_struct, order_id, gift_order)
                if gamebucks > gift_refund:
                    # refund any excess
                    session.user.refund_gamebucks(session, session.outgoing_messages, gamebucks - gift_refund, time_struct, order_id, refund_type)
                entry['refunded'] = 1
                entry['refunded_at'] = server_time

                session.increment_player_metric('money_refunded', usd_equivalent)
                session.increment_player_metric('gamebucks_refunded', gamebucks)

                gamesite.credits_log.event(server_time, {'user_id':session.user.user_id,
                                                         'summary': session.player.get_denormalized_summary_props('brief'),
                                                         'country_tier': session.player.country_tier,
                                                         'event_name':'1310_order_refunded',
                                                         'code':1310,
                                                         'Billing Amount': usd_equivalent,
                                                         'currency': paid_currency,
                                                         'currency_amount': user_facing_amount,
                                                         'tax_amount': tax_amount,
                                                         'refund_tax_amount': refund_tax_amount,
                                                         'tax_country': 'unknown',
                                                         'country': session.user.country,
                                                         'payout_foreign_exchange_rate':'unknown',
                                                         'quantity': 1,
                                                         'product': item,
                                                         'request_id': request_data['transaction']['id'],
                                                         'order_id': order_id,
                                                         'gift_order': gift_order})
                dry_run = ''
            else:
                dry_run = '(dry run) '

                gamesite.exception_log.event(server_time, '%sREFUND (%s) payment %s player %d amount %d gamebucks (balance %d) paid_amount %r (incl. %r tax) paid_currency %s refund_amount %f refund_currency %s gift_order %s' % \
                                             (dry_run, refund_type, order_id, session.player.user_id, gamebucks, session.player.resources.gamebucks,
                                              paid_amount, tax_amount, paid_currency, refund_amount, refund_currency, repr(gift_order)))

        except:
            gamesite.exception_log.event(server_time, ('XSAPI.handle_refund() player %d payment_id %s error: ' % (session.user.user_id, str(order_id)))+traceback.format_exc().strip()) # OK
            pass

    # not part of the API handler - this is called on behalf of the client via GAMEAPI
    def get_token(self, session, retmsg, spellname, spellarg): # spellname being an xsolla BUY_GAMEBUCKS SKU
        spell = gamedata['spells'][spellname]
        assert spell['currency'].startswith('xsolla:')
        for PRED in ('show_if', 'requires'):
            if (PRED in spell) and (not Predicates.read_predicate(spell[PRED]).is_satisfied2(session, session.player, None)):
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", spell[PRED]])
                return None
        real_currency = spell['currency'].split(':')[1]
        real_currency_price = spell['price']
        gamebucks_quantity = spell['quantity']
        gamebucks_ui_description = Store.format_ui_string(session, spellname, None, spell, spell['ui_name'])
        url, method, headers, body = SpinXsolla.make_token_request(SpinConfig.config, SpinConfig.game(), session.user.frame_platform,
                                                                   session.user.user_id, session.user.social_id,
                                                                   session.user.get_xsolla_id(), session.user.get_email(),
                                                                   real_currency, real_currency_price,
                                                                   session.user.country, session.user.locale.split('_')[0] if session.user.locale else 'en',
                                                                   spellname, spellarg,
                                                                   gamebucks_quantity, gamebucks_ui_description,
                                                                   session.player.level(), session.user.account_creation_time)
        if gamedata['server'].get('log_xsolla', False):
            gamesite.xsolla_log.event(server_time, SpinJSON.dumps({'url':url, 'method':method, 'headers':headers, 'body':body}))
        d = make_deferred('SpinXsolla:get_token') # OK - doesn't block message processing
        gamesite.AsyncHTTP_Xsolla.queue_request(server_time, url,
                                                lambda result, _d=d: _d.callback(SpinJSON.loads(result)['token']),
                                                method=method, headers=headers, postdata=body)
        return d

# handler for game client API calls
class GAMEAPI(resource.Resource):
    isLeaf = True

    # awkward - for use by CustomerSupport.py
    AttackLog_factory = AttackLog
    ArmyUnitDamageLog_factory = ArmyUnitDamageLog

    def __init__(self):
        resource.Resource.__init__(self)
        self.quarry_query_cache = {}
        self.bh_blog_feed_cache = None
        self.bh_blog_feed_time = -1
        self.deferred_sessions = set() # sessions that have pending deferred traffic that needs to be sent out
        self.deferred_session_flusher = None # IDelayedCall for flushing the deferred sessions

    def add_deferred_session(self, session):
        self.deferred_sessions.add(session)
        if not self.deferred_session_flusher:
            self.deferred_session_flusher = reactor.callLater(gamedata['server'].get('deferred_message_coalesce_time',1), self.flush_deferred_sessions)
    def flush_deferred_sessions(self):
        self.deferred_session_flusher = None
        if not self.deferred_sessions: return
        myset = self.deferred_sessions
        self.deferred_sessions = set()
        for session in myset:
            session.do_flush_outgoing_messages()

    def render_OPTIONS(self, request):
        # necessary for FireFox 3.6
        SpinHTTP.set_access_control_headers(request)
        return ''
    def render_GET(self, request):
        return self.render_POST(request)


    # after an attack on another player, clear lock on victim's base and record state
    # unfortunately, this has to be asynchronous. Returns a Deferred instance that will
    # be called when all I/O finishes.

    # wrap complete_attack in an exception trap, because it is part of the logout path -
    # if execution gets aborted, the session will be left in a broken state

    def complete_attack(self, session, retmsg, client_props = None, reason='unknown'):

        try:
            return self._complete_attack(session, retmsg, client_props=client_props, reason=reason)
        except:
            gamesite.exception_log.event(server_time, 'complete_attack exception on player %d at %s: %s' % \
                                         (session.user.user_id,
                                          (session.viewing_base.base_id if session.viewing_base else '-'),
                                          traceback.format_exc().strip()))

        # error path
        session.complete_attack_in_progress = False
        d, session.complete_attack_d = session.complete_attack_d, None
        if not d: d = make_deferred('complete_attack(fail)')
        reactor.callLater(0, d.callback, False)
        return d

    @admin_stats.measure_latency('_complete_attack')
    def _complete_attack(self, session, retmsg, client_props = None, reason='unknown'):
        if session.complete_attack_in_progress:
            assert session.complete_attack_d
            if gamedata['server']['log_abnormal_logins'] >= 2:
                gamesite.exception_log.event(server_time, 're-entered complete_attack() from %s: %d at %s' % (reason, session.user.user_id, session.viewing_base.base_id))
            return session.complete_attack_d

        ascdebug('complete_attack %d' % session.user.user_id)

        assert session.complete_attack_d is None
        assert not session.complete_attack_in_progress

        session.complete_attack_d = make_deferred('_complete_attack')
        session.complete_attack_in_progress = True

        # record last bits of damage
        if session.damage_log:
            session.damage_log.record_multi(session.iter_objects())

        outcome = 'none'
        completion_consequent = None
        timed_challenge = None
        mutated_auras = False
        summary = None

        apm = None
        if client_props and client_props.get('apm',-1) > 0:
            apm = client_props['apm']

        # type of I/O we have to do
        io_type = None

        if (not session.home_base) and session.has_attacked and session.player is session.viewing_player:
            # quarry reinforcement or quarry/squad mutation
            assert session.viewing_base_lock is not None
            io_type = 'store_viewing_base'

        elif (not session.home_base) and session.has_attacked:

            # last-chance check for battle stars
            session.claim_all_battle_stars()

            base_damage = session.viewing_base.calc_base_damage()

            # classify battle outcome as victory or defeat
            outcome = 'defeat'

            if session.is_ladder_battle():
                outcome = 'victory' if session.viewing_base.ladder_victory_satisfied(session, base_damage) else 'defeat'

            elif session.viewing_base.base_type == 'quarry':
                guards_left = False
                # note: check the *session* for map objects not in the *base*
                for object in session.iter_objects():
                    if (object.owner is session.viewing_player) and object.is_mobile() and (not object.is_destroyed()) and session.viewing_base.can_deploy_unit(object.spec):
                        guards_left = True
                        break
                if (not guards_left) and session.viewing_base.quarry_victory_satisfied():
                    outcome = 'victory'
            elif session.viewing_base.base_type == 'squad':
                squad_victory = True
                for object in session.iter_objects():
                    if object.owner is session.viewing_player and object.is_mobile() and (not object.is_destroyed()):
                        squad_victory = False
                        break
                if squad_victory:
                    outcome = 'victory'
            else:
                outcome = 'victory' if session.viewing_base.common_victory_satisfied(session, base_damage) else 'defeat'

            defender_outcome = 'defeat' if (outcome == 'victory') else 'victory'

            is_conquest = (outcome == 'victory' and \
                           session.player.tutorial_state == "COMPLETE" and \
                           session.viewing_base is session.viewing_player.my_home and \
                           (session.viewing_player.resources.player_level >= session.player.resources.player_level) and \
                           (session.viewing_player.is_ai() or (not session.user.is_friends_with(session.viewing_user.social_id))))

            # modify trophy auras depending on bonus damage
            if ('ladder_bonus_damage' in gamedata['matchmaking']):
                bonus = 0
                for entry in gamedata['matchmaking']['ladder_bonus_damage']:
                    if base_damage >= entry[0]:
                        bonus = entry[1]
                        break
                if bonus > 0:
                    for aura in session.player.player_auras_iter_const():
                        if aura['spec'].startswith('trophy_pvp_plus'):
                            winner_pts = aura.get('stack',1)
                            if winner_pts > 0:
                                winner_pts += max(1, int(winner_pts*bonus))
                                aura['stack'] = winner_pts
                    for aura in session.viewing_player.player_auras_iter_const():
                        if aura['spec'].startswith('trophy_pvp_minus'):
                            loser_pts = -aura.get('stack',1)
                            if loser_pts < 0:
                                loser_pts = -(abs(loser_pts) + max(1,int(abs(loser_pts)*bonus)))
                                aura['stack'] = -loser_pts

            if session.is_ladder_battle():

                # reset ladder matchmaking cooldown
                if session.player.is_ladder_player(): session.player.cooldown_reset('ladder_match')

                if gamedata['server']['log_ladder_pvp'] >= 2:
                    gamesite.exception_log.event(server_time, 'ladder attack END: %s %s (DMG %.02f +%dres -%dres +%dunits -%dunits)' % \
                                                 (session.format_ladder_state(),
                                                  outcome, base_damage,
                                                  sum([session.loot.get(resname,0) for resname in gamedata['resources']],0),
                                                  sum([session.loot.get(resname+'_lost',0) for resname in gamedata['resources']],0),
                                                  sum(session.loot.get('units_killed',{}).itervalues(),0),
                                                  sum(session.loot.get('units_lost',{}).itervalues(),0)))

            # run battle end auras for both players
            mutated_auras = session.player.run_battle_end_auras(outcome, session, retmsg)
            session.viewing_player.run_battle_end_auras(defender_outcome, session, retmsg)

            # collect summary info that will be stored in both players' battle histories
            attacker_name = session.user.get_ui_name(session.player)
            defender_name = session.viewing_user.get_ui_name(session.viewing_player)
            facebook_friends = (not session.viewing_player.is_ai()) and session.user.is_friends_with(session.viewing_user.social_id)

            summary = { 'time': session.attack_log.log_time,
                        'duration': int(server_time - session.attack_log.log_time),
                        'logfile': session.attack_log.log_file if session.attack_log.log_file else '',
                        'replay_version': gamedata.get('replay_version', 0),
                        'involved_players': [session.user.user_id, session.viewing_user.user_id],
                        'battle_type': 'attack',
                        'attacker_id': session.user.user_id,
                        'attacker_type': 'human',
                        'attacker_name': attacker_name,
                        'attacker_facebook_id': session.user.facebook_id,
                        'attacker_social_id': session.user.social_id,
                        'attacker_level': session.player.resources.player_level,
                        'attacker_townhall_level': session.player.get_townhall_level(),
                        'attacker_summary': session.player.get_denormalized_summary_props('brief'),
                        'home_base': session.home_base,
                        'base_id': session.viewing_base.base_id,
                        'base_ui_name': session.viewing_base.base_ui_name,
                        'base_type': session.viewing_base.base_type,
                        'base_creation_time': session.viewing_base.base_creation_time,
                        'starting_base_damage': session.starting_base_damage,
                        'starting_resources': session.starting_resources,
                        'base_times_attacked': session.viewing_base.base_times_attacked,
                        'base_ncells': session.viewing_base.ncells(),
                        'base_map_loc': copy.deepcopy(session.viewing_base.base_map_loc),
                        'defender_id': session.viewing_user.user_id,
                        'defender_name': defender_name,
                        'defender_facebook_id': session.viewing_user.facebook_id,
                        'defender_level': session.viewing_player.resources.player_level,
                        'defender_townhall_level': session.viewing_player.get_townhall_level(),
                        'defender_type': session.viewing_player.ai_or_human(),
                        'defender_is_ai': session.viewing_player.is_ai(),
                        'base_damage': base_damage,
                        'attacker_outcome': outcome,
                        'defender_outcome': defender_outcome }
            if session.ladder_state: summary['ladder_state'] = copy.deepcopy(session.ladder_state)
            summary.update(session.res_looter.battle_summary_props())
            if facebook_friends: summary['facebook_friends'] = True
            if session.viewing_user.social_id: summary['defender_social_id'] = session.viewing_user.social_id
            if session.auto_resolved: summary['auto_resolved'] = 1
            if (not session.viewing_player.is_ai()):
                summary['defender_summary'] = session.viewing_player.get_denormalized_summary_props('brief')

            streak_cds = ['battle_streak']
            if session.is_ladder_battle():
                streak_cds.append('battle_streak_ladder')
            for cd in streak_cds:
                cd_stack = session.player.cooldown_active(cd)
                if cd_stack > 0:
                    summary[cd] = cd_stack

            # add cached alliance info for attacker/defender
            # this is denormalized to show players historical data
            for role, id, cache in (('attacker', session.alliance_id_cache, session.alliance_info_cache),
                                    ('defender', session.viewing_alliance_id_cache, session.viewing_alliance_info_cache)):
                if id >= 0 and cache:
                    # update involved_alliances only for PvP battles
                    if (not session.viewing_player.is_ai()) or session.is_ladder_battle():
                        if 'involved_alliances' not in summary: summary['involved_alliances'] = []
                        if id not in summary['involved_alliances']:
                            summary['involved_alliances'].append(id)

                    for FIELD in ('id','ui_name','chat_tag'):
                        if FIELD in cache:
                            summary[role+'_alliance_'+FIELD] = cache[FIELD]

            if apm is not None: summary['attacker_apm'] = apm
            if session.viewing_base.base_template: summary['base_template'] = session.viewing_base.base_template
            if session.viewing_base.base_region:
                summary['base_region'] = session.viewing_base.base_region
                summary['attacker_home_base_loc'] = copy.deepcopy(session.player.my_home.base_map_loc)
            if session.defending_squads: summary['defending_squads'] = session.defending_squads.keys()
            if session.deployable_squads: summary['deployable_squads'] = session.deployable_squads.keys()
            if session.deployed_units: summary['deployed_units'] = session.deployed_units.copy()
            if session.items_expended: summary['items_expended'] = copy.deepcopy(session.items_expended)
            if session.damage_log:
                damage_report = session.damage_log.finalize()
                if damage_report:
                    summary['damage'] = damage_report

            if session.viewing_base.base_type == 'quarry':
                # awkward - the actual conquer happens AFTER this...
                summary['base_times_conquered'] = session.viewing_base.base_times_conquered + (1 if outcome == 'victory' else 0)

            if 'battle_stars' in session.loot:
                summary['battle_stars'] = copy.deepcopy(session.loot['battle_stars'])

            if session.user.last_sprobe_result and session.user.last_sprobe_result.get('viewing_base_id',None) == session.viewing_base.base_id:
                # we got an sprobe result during the battle - record the framerate
                framerate = session.user.last_sprobe_result['tests'].get('graphics',{}).get('framerate',None)
                if framerate is not None: summary['framerate'] = framerate

                # see if we can record a ping sample
                connection_method = session.user.last_sprobe_result['tests'].get('connection',{}).get('method',None)
                if connection_method is not None:
                    ping = session.user.last_sprobe_result['tests'].get(connection_method,{}).get('ping',None)
                    if ping is not None: summary['active_player_ping'] = ping

            if (not session.viewing_player.is_ai()) and (session.defender_protection_expired_at > 0):
                if session.defender_protection_expired_at > server_time:
                    # attacked through protection - this should never happen
                    gamesite.exception_log.event(server_time, 'defender_protection_expired_at > server_time ! player %d vs %d exp %d server_time %d' % \
                                                 (session.player.user_id, session.viewing_player.user_id, session.defender_protection_expired_at, server_time))
                else:
                    summary['defender_protection_expired_at'] = session.defender_protection_expired_at

            if session.viewing_base.base_expire_time and session.viewing_base.base_expire_time > 0:
                summary['base_expire_time'] = session.viewing_base.base_expire_time

            if (not session.viewing_player.is_ai()):

                # REVENGE SYSTEM

                # was this battle a revenge counterattack?
                was_revenge = (session.revenge_attack_until >= 0) and (session.viewing_base is session.viewing_player.my_home)
                prevent_further_revenge = False

                if was_revenge:
                    summary['is_revenge'] = 1

                    # for future reference (i.e. to prove to players who complain...),
                    # record the revenge status AS OF BATTLE START in the battle summary
                    summary['attacker_could_revenge_until'] = session.revenge_attack_until

                    # if this was a revenge counterattack, remove the cooldowns to "settle the score" between these players
                    # but only do this in ladder and legacy PvP, and it must be a home-base attack
                    if (session.player.is_ladder_player() or session.player.is_legacy_pvp_player()) and \
                       (session.viewing_base is session.viewing_player.my_home):
                        prevent_further_revenge = True
                        session.player.cooldown_reset('revenge_defender:%d' % session.viewing_player.user_id)
                        session.viewing_player.cooldown_reset('revenge_attacker:%d' % session.player.user_id)
                        session.attack_event(session.user.user_id, '3891_revenge_cleared')
                        session.deferred_player_cooldowns_update = True

                # Create a new revenge allowance?
                if (not prevent_further_revenge) and \
                   gamedata['matchmaking']['revenge_time'] > 0 and \
                   ((session.viewing_base is session.viewing_player.my_home) or \
                    (session.viewing_base.base_type == 'squad' and session.viewing_player.squads_affect_revenge()) or \
                    (session.viewing_base.base_type == 'quarry' and session.viewing_player.quarries_affect_revenge())):
                    # create a revenge allowance
                    rtime = gamedata['matchmaking']['revenge_time']
                    summary['defender_can_revenge_until'] = server_time + rtime

                    # victim can take revenge against attacker
                    if session.viewing_base is session.viewing_player.my_home:
                        session.viewing_player.cooldown_trigger('revenge_defender:%d' % session.player.user_id, rtime)
                    else: # send by asynchronous message, since we can't write to the player data
                        gamesite.msg_client.msg_send([{'to': [session.viewing_player.user_id],
                                                       'type': 'cooldown_trigger',
                                                       'expire_time': server_time + rtime,
                                                       'end_time': server_time + rtime,
                                                       'from': session.player.user_id,
                                                       'cooldown_name': 'revenge_defender:%d' % session.player.user_id,
                                                       }])

                    # attacker is subject to revenge from victim
                    session.player.cooldown_trigger('revenge_attacker:%d' % session.viewing_player.user_id, rtime)
                    session.attack_event(session.viewing_user.user_id, '3890_revenge_enabled', {'against': session.user.user_id,
                                                                                                'end_time': server_time + rtime})
                    session.deferred_player_cooldowns_update = True

                # END REVENGE SYSTEM

                if (session.viewing_base is session.viewing_player.my_home):
                    # home base PvP attack

                    # determine attack severity
                    precurve_storage_damage = session.viewing_base.calc_resource_damage()

                    # adjust by minimum damage threshold
                    min_damage = session.viewing_player.get_leveled_quantity(session.viewing_player.get_any_abtest_value('protection_min_damage', gamedata['server']['protection_min_damage']))
                    storage_damage = (precurve_storage_damage - min_damage) / (1.0 - min_damage)

                    fatigue_cdname = ('ladder_fatigue' if session.is_ladder_battle() else 'battle_fatigue')

                    # add battle fatigue on attacker against this victim
                    if gamedata['anti_bullying']['enable_'+fatigue_cdname]:
                        # note: for MAP ladder battles, only apply fatigue on victory
                        if (not session.is_ladder_battle()) or (session.player.is_ladder_player() or outcome == 'victory'):
                            duration = Predicates.eval_cond(gamedata['anti_bullying'][fatigue_cdname+'_duration'], session, session.player)
                            if duration > 0:
                                session.player.cooldown_trigger(fatigue_cdname+':%d' % session.viewing_player.user_id, duration, add_stack = 1)

                    # remove battle fatigue on victim against this attacker
                    # XXX this used to be unconditional for ladder battles, it might have let alt-abusing players hit themselves more often
                    if (not session.is_ladder_battle()) or (session.viewing_player.is_ladder_player() and (not was_revenge)):
                        session.viewing_player.cooldown_reset(fatigue_cdname+':%d' % session.player.user_id)

                    # record attack for alt abuse/bullying detection (obsolete)
                    # if (not (session.player.isolate_pvp and session.viewing_player.isolate_pvp)):
                    #     add_recent_attack(session.player.user_id, session.viewing_player.user_id, precurve_storage_damage, server_time, reason='complete_attack')

                    protection_based_on = session.viewing_player.get_any_abtest_value('protection_based_on', gamedata['server']['protection_based_on'])
                    ladder_prot_time = session.viewing_base.calc_ladder_protection(base_damage)

                    # update victim's protection timer
                    if session.is_ladder_battle() and (session.protection_eligible is True):
                        protection_based_on = 'ladder_battle'
                        prot_time = ladder_prot_time
                        if prot_time > 0:
                            session.viewing_player.set_protection_end_time(session, server_time + int(prot_time),
                                                                           '3881_protection_from_ladder_battle',
                                                                           {'attacker_id': session.player.user_id,
                                                                            'base_damage': base_damage,
                                                                            'precurve_storage_damage': precurve_storage_damage})

                            if gamedata['server']['enable_protection_fatigue']:
                                session.player.cooldown_trigger('protection_fatigue:%d'%session.viewing_player.user_id, gamedata['server']['protection_fatigue_duration'], add_stack = 1)
                                if gamedata['server']['enable_alliance_protection_fatigue']:
                                    other_alliance_id = gamesite.sql_client.get_users_alliance(session.viewing_player.user_id, reason = 'complete_attack_protection_fatigue')
                                    for aid in [other_alliance_id,] + session.viewing_player.get_sticky_alliances():
                                        if aid > 0:
                                            session.player.cooldown_trigger('protection_fatigue:a%d' % aid, gamedata['server']['protection_fatigue_duration'], add_stack = 1)

                                if gamedata['server']['global_protection_cooldown'] > 0:
                                    session.viewing_player.cooldown_trigger('global_protection', int(prot_time + gamedata['server']['global_protection_cooldown']*prot_time))
                        else:
                            session.viewing_player.set_protection_end_time(session, -1, None)

                    # ordinary attacks: based on damage suffered (only if the battle_start code made it eligible)
                    elif (session.protection_eligible is True):
                        min_time = session.viewing_player.get_leveled_quantity(session.viewing_player.get_any_abtest_value('protection_time_min', gamedata['server']['protection_time_min']))
                        max_time = session.viewing_player.get_leveled_quantity(session.viewing_player.get_any_abtest_value('protection_time_max', gamedata['server']['protection_time_max']))
                        prot_time = 0

                        if protection_based_on == 'ladder_battle':
                            prot_time = ladder_prot_time
                            damage = base_damage
                        else:
                            if protection_based_on == 'storage_only':
                                damage = storage_damage
                            else:
                                damage = base_damage

                            if damage > 0:
                                damage = min(1.0, max(0.0, damage))
                                prot_time = min_time + damage * (max_time - min_time)

                            if gamedata['server'].get('cap_nonladder_protection_to_ladder', True):
                                # do not give more protection than the ladder would
                                prot_time = min(prot_time, ladder_prot_time)

                        if prot_time > 0:
                            session.viewing_player.set_protection_end_time(session, server_time + int(prot_time),
                                                                           '3882_protection_from_nonladder_battle',
                                                                           {'attacker_id': session.player.user_id,
                                                                            'base_damage': base_damage,
                                                                            'damage':damage,
                                                                            'precurve_storage_damage': precurve_storage_damage})

                            if gamedata['server']['enable_protection_fatigue']:
                                session.player.cooldown_trigger('protection_fatigue:%d'%session.viewing_player.user_id, gamedata['server']['protection_fatigue_duration'], add_stack = 1)
                                if gamedata['server']['enable_alliance_protection_fatigue']:
                                    other_alliance_id = gamesite.sql_client.get_users_alliance(session.viewing_player.user_id, reason = 'complete_attack_protection_fatigue')
                                    for aid in [other_alliance_id,] + session.viewing_player.get_sticky_alliances():
                                        if aid > 0:
                                            session.player.cooldown_trigger('protection_fatigue:a%d' % aid, gamedata['server']['protection_fatigue_duration'], add_stack = 1)
                        else:
                            session.viewing_player.set_protection_end_time(session, -1, None)

                    else:
                        # temp, for tracking how the test works
                        protection_based_on = 'none_given'
                        prot_time = 0
                        session.viewing_player.set_protection_end_time(session, -1, None)

                    summary['prot_time'] = prot_time

                    retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])

                    if gamedata['server']['log_protection_timer']:
                        gamesite.exception_log.event(server_time, 'prot time calc (%s): %6d (L%2d) vs %6d (L%2d) %8s: loot %7d units %3d HP damage %.3f res damage %.3f (curved %.3f) -> %d' % \
                                                     (protection_based_on,
                                                      session.user.user_id,
                                                      session.player.resources.player_level,
                                                      session.viewing_user.user_id,
                                                      session.viewing_player.resources.player_level,
                                                      'friend' if session.viewing_user.is_friends_with(session.user.social_id) else 'stranger',
                                                      sum((session.loot.get(res,0) for res in gamedata['resources']),0),
                                                      sum(session.loot.get('units_killed',{}).itervalues()),
                                                      base_damage,
                                                      precurve_storage_damage,
                                                      storage_damage,
                                                      prot_time))

                    session.viewing_player.ladder_point_decay_check(session, base_damage = base_damage, base_repair_time = -1) # PvP attack victim

                # END is human home base

                # send real-time Facebook notification to the victim
                config = gamesite.get_localized_gamedata('fb_notifications', session.viewing_user.locale)['notifications']['you_got_attacked']
                notif_text = config.get('ui_name_'+session.viewing_base.base_type)
                if notif_text:
                    notif_text = notif_text.replace('%ATTACKER', session.user.get_ui_name(session.player))
                    if '%BASE_UI_NAME' in notif_text:
                        if not session.viewing_base.base_ui_name:
                            pass # gamesite.exception_log.event(server_time, 'BASE_UI_NAME not available for %s' % session.viewing_base.base_id)
                        notif_text = notif_text.replace('%BASE_UI_NAME', session.viewing_base.base_ui_name or '')
                    notif_args = {'method': 'send_notification', 'reliable': 1, 'user_id': session.viewing_user.user_id,
                                  'text': notif_text, 'config': 'you_got_attacked'}

                    # send the notification AFTER the victim's lock is dropped! otherwise it'll just hit an offline-locked error
                    def sendit(result, session, notif_args):
                        # and, delay the call a bit to allow S3 write to propagate, so we don't hit a lock gen error
                        reactor.callLater(io_system.get_post_write_delay(), gamesite.do_CONTROLAPI, session.user.user_id, notif_args)
                        return result # pass through

                    session.complete_attack_d.addCallback(sendit, session, notif_args)

            # END is human

            if is_conquest:
                session.increment_player_metric('conquests', 1, time_series = False)

            session.protection_eligible = None # reset flag

            session.viewing_player.lock_state = Player.LockState.open
            session.viewing_player.lock_time = 0

            # update victim's state record

            if session.viewing_base is not session.viewing_player.my_home:
                assert session.viewing_base_lock is not None

                io_type = 'store_viewing_base'

                # check for victory condition
                if session.viewing_base.base_type == 'quarry' or (not session.viewing_base.base_type):
                    if outcome == 'victory':
                        # give instant travel to first reinforcements
                        session.player.travel_instantly_to(session.viewing_base)
                        retmsg.append(["PLAYER_TRAVEL_UPDATE", session.player.travel_state])

                        # quarry was conquered
                        if gamedata['server']['log_quarries']:
                            gamesite.exception_log.event(server_time, 'player %d\'s quarry %s was conquered by %d!' % \
                                                         (session.viewing_player.user_id, session.viewing_base.base_ui_name, session.player.user_id))
                        session.viewing_base.quarry_conquer(session.viewing_player, session.player)
                        session.increment_player_metric('quarries_conquered', 1, time_series = False)
                        if SpinConfig.game() in ('tr','dv'): # NASTY HACK
                            session.increment_player_metric('quarries_conquered_for_achievement', 1, time_series = False)
                        metric_event_coded(session.user.user_id, '4710_quarry_conquered', {'region': session.viewing_base.base_region,
                                                                                           'base_id': session.viewing_base.base_id,
                                                                                           'last_landlord_id': session.viewing_player.user_id})

                        # check if a strongpoint was conquered
                        template = gamedata['quarries_server']['templates'].get(session.viewing_base.base_template,None)

                        if template and template.get('turf_points',0) > 0:
                            session.increment_player_metric('strongpoints_conquered', 1, time_series = False)

                        # allow instant collection
                        session.player.cooldown_reset('quarry_collect')
                        retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])

                        # get rid of any remaining guard units (including ones that were not deployed due to climate restrictions)
                        # this may be redundant with object_combat_updates etc. for units that were deployed, but I think we need to do this to be fully safe against exploits/weird states
                        if gamesite.nosql_client and session.player.home_region:
                            for base_id, feature in session.defending_squads.iteritems():
                                squad_id = feature['squad_id']
                                if SQUAD_IDS.is_mobile_squad_id(squad_id):
                                    for state in gamesite.nosql_client.get_mobile_objects_by_base(session.player.home_region, session.viewing_player.squad_base_id(squad_id), reason='complete_attack(victory/defending_units)'):
                                        if session.has_object(state['obj_id']): continue # skip objects in session?
                                        if state.get('hp_ratio',1) > 0 or state.get('hp',1) > 0:
                                            if True: # (not session.viewing_base.can_deploy_unit(session.player.get_abtest_spec(GameObjectSpec, state['spec']))):
                                                # gamesite.exception_log.event(server_time, "destroying player %d's defending %s at %s since it is incompatible with the climate" % (session.viewing_player.user_id, spec.name, session.viewing_base.base_id))
                                                gamesite.nosql_client.update_mobile_object(session.player.home_region, {'obj_id':state['obj_id'], 'hp_ratio':0}, partial = True, reason = 'complete_attack(victory/defending_units)')
                                    gamesite.nosql_client.drop_map_feature(session.player.home_region, base_id)
                                    session.forget_base_lock(base_id)

                            if 1:
                                # kick any additional squads at or inbound to here back to home base
                                # this finds any squads that were not in the original defending_squads query, like ones that were on the way but not arrived yet
                                defense_features = [x for x in gamesite.nosql_client.get_map_features_by_loc(session.player.home_region, session.viewing_base.base_map_loc, reason='complete_attack(victory/defending_squads)') if x.get('base_type',None)=='squad']
                                for feature in defense_features:
                                    self.broadcast_map_attack(session.player.home_region, feature, session.player.user_id, session.viewing_player.user_id,
                                                              None,
                                                              [self.get_player_cache_props(u,p,aid) for u,p,aid in ((session.user,session.player,session.alliance_id_cache),(session.viewing_user,session.viewing_player,session.viewing_alliance_id_cache))],
                                                              msg = "REGION_MAP_ATTACK_DIVERT")
                                    gamesite.nosql_client.drop_map_feature(session.player.home_region, feature['base_id'])

                elif session.viewing_base.base_type == 'hive':
                    template = gamedata['hives_server']['templates'].get(session.viewing_base.base_template, None)

                    if outcome == 'victory':
                        # AI hive was defeated
                        io_type = 'del_viewing_base'

                        if gamedata['server']['log_hives']:
                            gamesite.exception_log.event(server_time, 'player %d (L%d)\'s hive %s in %s was conquered by %d!' % \
                                                         (session.viewing_player.user_id, session.viewing_player.resources.player_level,
                                                          session.viewing_base.base_ui_name, str(session.player.home_region), session.player.user_id))
                        session.increment_player_metric('hives_destroyed', 1, time_series = False)
                        session.loot['hives_destroyed'] = 1

                        if template and 'completion' in template:
                            completion_consequent = template['completion']

                    else:
                        # failed to defeat hive
                        if template and 'failure' in template:
                            completion_consequent = template['failure']

                    if (outcome != 'victory' and gamedata.get('pve_repair_on_defeat', False)) or gamedata.get('pve_repair_on_victory', False):
                        session.viewing_base.reset_to_full_health()

                elif session.viewing_base.base_type == 'squad':
                    # this is handled seamlessly because ping_squads will remove dead squads automatically, and the store_viewing_base MapCache update are no-ops
                    pass

                if io_type == 'del_viewing_base':
                    # remove base from the map XXX move into BaseTable.delete()
                    gamesite.nosql_client.drop_map_feature(session.viewing_base.base_region, session.viewing_base.base_id, reason='complete_attack')
                    session.forget_base_lock(session.viewing_base.base_id)

                # check for dead squads
                if session.using_squad_deployment() and session.viewing_player.is_human() and (session.viewing_player is not session.player):
                    if outcome == 'victory':
                        for base_id, feature in session.defending_squads.iteritems():
                            if SQUAD_IDS.is_mobile_squad_id(feature['squad_id']):
                                # note: there's a funky race condition here when the viewing_player is getting weeded off the map for churning,
                                # but has left squads behind. This results in session.viewing_player.home_region being None here. So use player.home_region instead.
                                gamesite.nosql_client.drop_map_feature(session.player.home_region, base_id)
                                session.forget_base_lock(base_id)

                        # note: ping_squads doesn't work here because session.viewing_player's playerdb could be way out of date, and have stuff in my_base that conflicts with the map


            elif session.viewing_player.is_ai():
                base = gamedata['ai_bases_server']['bases'][str(session.viewing_user.user_id)]
                if outcome == 'victory' and (('completion' in base) or session.is_ladder_battle()):
                    # "story" base - use Consequent system
                    completion_consequent = base.get('completion', None)
                    timed_challenge = base.get('timed_challenge', None)

                    if ('fb_open_graph' in base) and base['fb_open_graph'].get('enable', True):
                        session.user.create_fb_open_graph_action('conquer',
                                                                 {OGPAPI.object_type('base'):
                                                                  OGPAPI_instance.get_object_endpoint({'type':OGPAPI.object_type('base'),
                                                                                                       'user_id':session.viewing_user.user_id})})
                    if gamedata.get('pve_repair_on_victory', False):
                        session.viewing_base.reset_to_full_health()
                        # almost always want to persist also, otherwise loot state would be lost!
                        if gamedata.get('pve_persist_on_victory', False):
                            io_type = 'store_ai_instance'
                        else:
                            io_type = 'del_ai_instance'
                    else:
                        # delete garbage AI instance
                        io_type = 'del_ai_instance'

                else:
                    # run failure consequent
                    if 'failure' in base and outcome == 'defeat':
                        completion_consequent = base['failure']

                    if base.get('reset_on_defeat', False):
                        io_type = 'del_ai_instance'
                    else:
                        # store all "trash" bases and uncompleted "story" bases as temporary instances
                        if (outcome != 'victory' and gamedata.get('pve_repair_on_defeat', False)) or \
                           gamedata.get('pve_repair_on_victory', False):
                            session.viewing_base.reset_to_full_health()

                        io_type = 'store_ai_instance'

                    # get rid of Lion Stone
                    if LION_STONE_ID in session.user.client_ai_friends:
                        retmsg.append(["REM_FRIEND", LION_STONE_ID])
                        session.user.client_ai_friends.remove(LION_STONE_ID)
                        session.user.client_friends.remove(LION_STONE_ID)

                if session.is_ladder_battle() and (not gamedata['matchmaking']['ladder_match_ai_persist']):
                    io_type = None

                if not base.get('persistent', True): # do not store bases marked non-persistent
                    io_type = None

                if io_type == 'store_ai_instance':
                    # set expiration time
                    if session.viewing_player.expiration_time < 0:
                        persist_time = -1

                        # use instance cooldown to limit expiration time to this refresh only
                        # XXX NOTE! does not work on L1 bases where the cooldown is not running yet!
                        if ('ui_instance_cooldown' in base):
                            togo = session.player.cooldown_togo(base['ui_instance_cooldown'])
                            if togo > 0:
                                persist_time = togo

                        if persist_time <= 0:
                            mintime, maxtime = session.player.get_any_abtest_value('ai_base_persistence_time', gamedata['ai_base_persistence_time'])
                            persist_time = int(mintime + random.random()*float(maxtime - mintime))

                        session.viewing_player.expiration_time = server_time + persist_time

            else:
                io_type = 'store_viewing_player'

                # update victim's PvP trophy count
                if (not session.viewing_player.isolate_pvp):
                    for stat in ('trophies_pvp', 'trophies_pvv'):
                        session.viewing_player.modify_scores({stat: session.loot.get('viewing_'+stat, 0)}, reason = 'complete_attack(defender)')

                if (outcome != 'victory' and gamedata.get('pvp_repair_on_defeat', False)) or gamedata.get('pvp_repair_on_victory', False):
                    session.viewing_base.reset_to_full_health()

                # update victim's player cache entry
                cache_props = {'lootable_buildings': session.viewing_player.get_lootable_buildings(),
                               'base_damage': session.viewing_player.my_home.calc_base_damage(),
                               'base_repair_time': -1,
                               'last_defense_time': server_time,
                               'last_fb_notification_time': session.viewing_player.last_fb_notification_time
                               }
                gamesite.pcache_client.player_cache_update(session.viewing_user.user_id, cache_props, reason = 'attack_victim')

                if 0 and outcome == 'victory':
                    if session.viewing_user.facebook_id:
                        session.user.create_fb_open_graph_action('defeat', {'profile': session.viewing_user.facebook_id})

            # award bonus XP
            if outcome == 'victory':
                xp = 0
                xp_why = []
                amount = sum((session.loot.get(res,0) for res in gamedata['resources']),0)
                if amount > 0:
                    coeff = gamedata['player_xp']['pve_loot_xp' if session.viewing_player.is_ai() else 'pvp_loot_xp']
                    xp += int(amount*coeff*gamedata['player_xp']['loot_victory_bonus'])
                    xp_why.append('loot_victory_bonus')
                levels = session.loot.get('destroyed_building_levels',0)
                if levels > 0:
                    xp += int(levels*gamedata['player_xp']['destroy_building_victory_bonus'])
                    xp_why.append('destroy_building_victory_bonus')
                self.give_xp(session, retmsg, xp, ','.join(xp_why), None)
                session.loot['xp'] = session.loot.get('xp',0) + xp

            event_props = {'battle_outcome':outcome,
                           'starting_base_damage': session.starting_base_damage,
                           'starting_resources': session.starting_resources,
                           'base_damage': base_damage,
                           'base_id':session.viewing_base.base_id,
                           'opponent_user_id':session.viewing_user.user_id,
                           'opponent_level':session.viewing_player.resources.player_level,
                           'opponent_type':session.viewing_player.ai_or_human(),
                           'loot': session.loot.copy(),
                           'ladder_state': session.ladder_state,
                           'gain_xp':session.loot.get('xp', 0),
                           'units_lost':sum(session.loot.get('units_lost', {}).itervalues()),
                           'units_killed':sum(session.loot.get('units_killed', {}).itervalues()),
                           }
            for res in gamedata['resources']:
                event_props['gain_'+res] = session.loot.get(res,0)
            if 'battle_stars' in session.loot:
                event_props['battle_stars'] = copy.deepcopy(session.loot['battle_stars'])

            if gamedata['server'].get('log_battle_end',False) or LOTS_OF_METRICS:
                metric_event_coded(session.user.user_id, '3830_battle_end', event_props.copy())
            session.attack_event(session.user.user_id, '3830_battle_end', event_props.copy())

            if session.is_ladder_battle() and ((not session.using_squad_deployment()) or gamedata['server'].get('log_ladder_pvp_on_map',False)):
                session.player.record_ladder_pvp_event('3306_ladder_attack_end', {'defender_id': session.viewing_player.user_id,
                                                                                  'outcome': outcome,
                                                                                  'base_damage': base_damage,
                                                                                  'attacker_stars': sum(session.loot.get('battle_stars',{}).itervalues(),0),
                                                                                  'duration': int(server_time - session.attack_log.log_time),
                                                                                  'attacker_pts': session.player.ladder_points(),
                                                                                  'defender_pts': session.viewing_player.ladder_points(),
                                                                                  'attacker_pts_delta': session.loot.get('trophies_pvp',0),
                                                                                  'defender_pts_delta': session.loot.get('viewing_trophies_pvp',0),
                                                                                  'attacker_res': session.player.resources.get_fungible_amounts(),
                                                                                  'defender_res': session.viewing_player.resources.get_fungible_amounts(),
                                                                                  'attacker_res_delta': dict((res,session.loot.get(res,0)) for res in gamedata['resources']),
                                                                                  'defender_res_delta': dict((res,(-1*session.loot.get(res+'_lost',0))) for res in gamedata['resources']),
                                                                                  'items_expended': sum(session.items_expended.get(str(session.player.user_id),{}).itervalues(), 0),
                                                                                  'deployed_donated_unit_space': session.deployed_donated_unit_space,
                                                                                  'battle_streak_ladder': session.player.cooldown_active('battle_streak_ladder'),
                                                                                  'ladder_state': session.ladder_state})
        # after defending against an AI attack at home
        elif session.home_base and session.has_attacked:

            outcome = 'victory'

            # defeat if CC is destroyed
#            for obj in session.player.home_base_iter():
#                if obj.spec.name == gamedata['townhall']:
#                    if obj.is_destroyed():
#                        outcome = 'defeat'
#                        break

            # defeat if attack was not completely deployed
            if session.player.tutorial_state == "COMPLETE":
                if len(session.incoming_attack_units) > 0:
                    if gamedata['server'].get('log_ai_attack_results', False):
                        gamesite.exception_log.event(server_time, '%d defense loss (%s) - more units: %s' % \
                                                     (session.player.user_id, repr(session.incoming_attack_type), repr(session.incoming_attack_units)))
                    outcome = 'defeat'
                else:
                    # defeat if any enemy units remain
                    for obj in session.cur_objects.objects.itervalues():
                        if obj.team == 'enemy' and (not obj.is_destroyed()):
                            if gamedata['server'].get('log_ai_attack_results', False):
                                gamesite.exception_log.event(server_time, '%d defense loss (%s) - undestroyed enemy %s' % \
                                                             (session.player.user_id, repr(session.incoming_attack_type), obj.spec.name))
                            outcome = 'defeat'
                            break

                if outcome == 'defeat':
                    # "surrender" by blowing up CC
                    for obj in session.viewing_base.iter_objects():
                        if obj.spec.name == gamedata['townhall']:
                            assert obj.owner is session.player
                            if obj.is_destroyed(): continue
                            obj.halt_all()
                            obj.hp = max(int(gamedata['ai_attacks_client']['surrender_cc_min_health']*obj.max_hp), min(obj.hp, int(gamedata['ai_attacks_client']['surrender_cc_health']*obj.max_hp)))
                            if session.damage_log: session.damage_log.record(obj)

                            if session.has_object(obj.obj_id):
                                retmsg.append(["OBJECT_STATE_UPDATE2", obj.serialize_state()])

                if gamedata['server'].get('log_ai_attack_results', False):
                    gamesite.exception_log.event(server_time, '%d defense %s (against %s)' % \
                                                             (session.player.user_id, outcome, repr(session.incoming_attack_type)))

            mutated_auras = session.player.run_battle_end_auras(outcome, session, retmsg)

            event_props = {'battle_outcome':outcome,
                           'gain_xp':session.loot.get('xp', 0),
                           'loot':session.loot.copy(),
                           'ladder_state': session.ladder_state,
                           'units_lost':sum(session.loot.get('units_lost', {}).itervalues()),
                           'units_killed':sum(session.loot.get('units_killed', {}).itervalues()),
                           }
            for res in gamedata['resources']:
                event_props['gain_'+res] = -1*session.loot.get(res,0)
            session.attack_event(session.user.user_id, '3860_ai_attack_end', event_props.copy())
            if LOTS_OF_METRICS:
                metric_event_coded(session.user.user_id, '3860_ai_attack_end', event_props.copy())

            base_damage = session.player.my_home.calc_base_damage()

            # update player's battle history
            if session.incoming_attack_id > 0:
                if str(session.incoming_attack_id) not in gamedata['ai_bases_server']['bases']:
                    gamesite.exception_log.event(server_time, '%d defense %s (against %s) - cannot find incoming_attack_id %s in ai_bases!' % \
                                                 (session.player.user_id, outcome, repr(session.incoming_attack_type), repr(session.incoming_attack_id)))
                else:
                    summary = { 'time': session.attack_log.log_time,
                                'duration': int(server_time - session.attack_log.log_time),
                                'logfile': session.attack_log.log_file if session.attack_log.log_file else '',
                                'replay_version': gamedata.get('replay_version', 0),
                                'involved_players': [session.user.user_id],
                                'battle_type': 'defense',
                                'attacker_id': session.incoming_attack_id,
                                'attacker_type': 'ai',
                                'attack_type': session.incoming_attack_type,
                                'attacker_name': gamedata['ai_bases_server']['bases'][str(session.incoming_attack_id)]['ui_name'],
                                'attacker_facebook_id': -1,
                                'attacker_level': gamedata['ai_bases_server']['bases'][str(session.incoming_attack_id)]['resources']['player_level'],
                                'attacker_is_ai': True,
                                'ladder_state': copy.deepcopy(session.ladder_state),
                                'home_base': session.home_base,
                                'base_id': session.viewing_base.base_id,
                                'base_ui_name': session.viewing_base.base_ui_name,
                                'base_type': session.viewing_base.base_type,
                                'base_ncells': session.viewing_base.ncells(),
                                'base_map_loc': copy.deepcopy(session.viewing_base.base_map_loc),
                                'starting_base_damage': session.starting_base_damage, # note, this will ignore repairs since the start of the session
                                'starting_resources': session.starting_resources,
                                'defender_id': session.user.user_id,
                                'defender_type': 'human',
                                'defender_name': session.user.get_ui_name(session.player),
                                'defender_facebook_id': session.user.facebook_id,
                                'defender_social_id': session.user.social_id,
                                'defender_level': session.player.resources.player_level,
                                'defender_townhall_level': session.player.get_townhall_level(),
                                'defender_summary': session.player.get_denormalized_summary_props('brief'),
                                'base_damage': base_damage,
                                'attacker_outcome': 'victory' if (outcome == 'defeat') else 'defeat',
                                'defender_outcome': outcome }
                    if apm is not None: summary['defender_apm'] = apm
                    if session.auto_resolved: summary['auto_resolved'] = 1
                    summary.update(session.res_looter.battle_summary_props())

                    streak_cds = ['battle_streak']
                    if session.is_ladder_battle():
                        streak_cds.append('battle_streak_ladder')
                    for cd in streak_cds:
                        cd_stack = session.player.cooldown_active(cd)
                        if cd_stack > 0:
                            summary[cd] = cd_stack

                    # add cached alliance info for attacker/defender
                    # this is denormalized to show players historical data
                    for role, id, cache in (('defender', session.alliance_id_cache, session.alliance_info_cache),):
                        if id >= 0 and cache:
                            # note: no involved_alliances here, since it's not PvP
                            for FIELD in ('id','ui_name','chat_tag'):
                                if FIELD in cache:
                                    summary[role+'_alliance_'+FIELD] = cache[FIELD]
                    if session.viewing_base.base_region: summary['base_region'] = session.viewing_base.base_region
                    if session.defending_squads: summary['defending_squads'] = session.defending_squads.keys()
                    if session.deployed_units: summary['deployed_units'] = session.deployed_units.copy()
                    if session.deployable_squads: summary['deployable_squads'] = session.deployable_squads.keys()
                    if session.items_expended: summary['items_expended'] = copy.deepcopy(session.items_expended)
                    if session.damage_log:
                        damage_report = session.damage_log.finalize()
                        if damage_report:
                            summary['damage'] = damage_report

                    if session.user.last_sprobe_result and session.user.last_sprobe_result.get('viewing_base_id',None) == session.viewing_base.base_id:
                        # see if we can record a ping sample (no framerate recording because it's the player's own home base)
                        connection_method = session.user.last_sprobe_result['tests'].get('connection',{}).get('method',None)
                        if connection_method is not None:
                            ping = session.user.last_sprobe_result['tests'].get(connection_method,{}).get('ping',None)
                            if ping is not None: summary['active_player_ping'] = ping

            if outcome == 'victory':
                data = session.incoming_attack_data
                if data and ('completion' in data):
                    completion_consequent = data['completion']

        if session.has_attacked:

            if completion_consequent:
                completion_context = {}
                if 'battle_stars' in session.loot:
                    completion_context['battle_stars'] = session.loot['battle_stars']
                    completion_context['n_battle_stars'] = len(session.loot['battle_stars'])
                session.execute_consequent_safe(completion_consequent, session.player, retmsg, context=completion_context, reason='complete_attack')

            # special case - adjust hive kill points by region factor
            if ('hive_kill_points' in session.loot) and session.viewing_base.base_region and (session.viewing_base.base_region in gamedata['regions']):
                session.loot['hive_kill_points'] = max(1, int(gamedata['regions'][session.viewing_base.base_region].get('hive_kill_point_scale',1)*session.loot['hive_kill_points']))

            if mutated_auras:
                session.deferred_player_auras_update = True

            if (session.viewing_player.is_ai() or session.incoming_attack_data) and (outcome == 'victory'):
                session.user.repopulate_ai_list(session)

            # update score_foo history fields for leaderboard rankings
            if (not session.player.isolate_pvp):
                stats = {}

                # collect stats increments that will be added to player score counters
                if (session.viewing_player.is_ai() or \
                    (session.viewing_player is not session.player) and (not session.user.is_friends_with(session.viewing_user.social_id))):
                    stats['xp'] = session.loot.get('xp', 0)
                    stats['conquests'] = 1 if is_conquest else 0
                    stats['resources_looted'] = sum((session.loot.get(res,0) for res in gamedata['resources']),0)
                    stats['havoc_caused'] = session.loot.get('havoc_caused',0) if is_conquest else 0
                    stats['damage_inflicted'] = session.loot.get('damage_inflicted',0)
                    if session.viewing_player.is_ai():
                        stats['damage_inflicted_pve'] = session.loot.get('damage_inflicted',0)
                    stats['hive_kill_points'] = session.loot.get('hive_kill_points',0) # must be set via SESSION_LOOT consequent

                # collect trophy stats - note, trophies can come from AI attacks, but other stats cannot
                for st in ('trophies_pvp', 'trophies_pve', 'trophies_pvv'):
                    stats[st] = session.loot.get(st, 0)

                # collect stats associated with items looted
                for item in session.loot.get('items',[]):
                    spec = gamedata['items'].get(item['spec'])
                    if not spec: continue
                    if spec.get('category') == 'token':
                        stack = item.get('stack',1)

                        # generic token counter
                        stats['tokens_looted'] = stats.get('tokens_looted',0) + stack

                        # type-specific token counter
                        skey = 'tokens_looted:'+item['spec']
                        stats[skey] = stats.get(skey,0) + stack

                # collect timing
                if timed_challenge and outcome == 'victory':
                    # note, the scores2_to_sql script only accepts a single extra axis named "challenge"
                    # "key" roughly corresponds to one AI base, but allows multiple base variations to share one key
                    stats['battle_duration'] = {('challenge', 'key', timed_challenge): int(server_time - session.attack_log.log_time)}

                session.player.modify_scores(stats, reason = 'complete_attack(attacker)')

            # finalize battle summary
            if summary:
                summary['loot'] = copy.deepcopy(session.loot) # grab loot here since completion consequent may have modified it

                if timed_challenge:
                    # should probably be set above, but timed_challenge is undefined until after summary = {} initialization :(
                    summary['timed_challenge'] = timed_challenge

                session.player.increment_battle_statistics(summary['attacker_id'] if summary['battle_type'] == 'defense' else summary['defender_id'], summary)

                # send log to MongoDB
                if gamedata['server'].get('nosql_battle_record',True) and summary.get('attack_type',None) != 'tutorial' and summary['defender_id'] != LION_STONE_ID:
                    gamesite.nosql_client.battle_record(summary, reason=summary['battle_type'])

                # battle history jewel update gets to defender because either
                # 1) we're attacking their home base, and they're logged out - they will see it on login
                # or
                # 2) we're attacking their squad/quarry, and broadcast_map_attack will trigger it

                if summary['battle_type'] == 'attack': # offensive attack
                    if not summary['defender_is_ai']: # PvP
                        # mail the victim a "you've been attacked" message and battle summary
                        gamesite.msg_client.msg_send([{'from': session.player.user_id,
                                                       'to': [summary['defender_id']],
                                                       'type': 'i_attacked_you',
                                                       'expire_time': server_time + gamedata['server']['message_expire_time']['i_attacked_you'],
                                                       'from_fbid': str(summary['attacker_facebook_id']),
                                                       'from_name': unicode(session.user.get_ui_name(session.player)),
                                                       'summary': summary}])

                    if summary['base_type'] != 'home' and 'base_region' in summary:
                        # offense attack against quarry or squad
                        # broadcast map attack to victim
                        self.broadcast_map_attack(summary['base_region'], session.viewing_base.get_cache_props(),
                                                  summary['attacker_id'], summary['defender_id'],
                                                  # The only part of the summary actually used by the client is the defender_outcome.
                                                  # Trim it down to hide sensitive info like analytics summary data. (XXX simplify args)
                                                  {'defender_outcome': summary['defender_outcome']},
                                                  [self.get_player_cache_props(u,p,aid) for u,p,aid in ((session.user,session.player,session.alliance_id_cache),(session.viewing_user,session.viewing_player,session.viewing_alliance_id_cache))],
                                                  msg = "REGION_MAP_ATTACK_COMPLETE")

            session.player.send_history_update(retmsg)

            # check for player's own dead squads, and update squad space stats
            if session.using_squad_deployment():
                session.player.ping_squads_and_send_update(session, retmsg, originator=session.player.user_id, reason='complete_attack(attacker)')

                # update defender's squad space stats (attacker's squad space stats are updated by ping_squads above)
                total_space_by_squad_id = {}
                alive_space_by_squad_id = {}
                for object in itertools.chain(session.iter_objects(), (object for object, death_location in session.resurrectable_objects)):
                    if object.owner is session.viewing_player and object.is_mobile():
                        squad_id = object.squad_id or 0
                        if SQUAD_IDS.is_mobile_squad_id(squad_id):
                            space = object.get_leveled_quantity(object.spec.consumes_space)
                            total_space_by_squad_id[squad_id] = total_space_by_squad_id.get(squad_id, 0) + space
                            if not object.is_destroyed():
                                alive_space_by_squad_id[squad_id] = alive_space_by_squad_id.get(squad_id, 0) + space

                if gamedata['server'].get('log_nosql_squad_space',0) >= 2:
                    gamesite.exception_log.event(server_time, 'defender squad space:\ntotal %r\nalive %r\n\nsession.viewing_squad_locks %r\nsession.viewing_base_lock %r' % (total_space_by_squad_id, alive_space_by_squad_id, session.viewing_squad_locks, session.viewing_base_lock))

                for squad_base_id, squad_feature in session.defending_squads.iteritems():
                    if gamedata['server'].get('log_nosql_squad_space',0) >= 2:
                        gamesite.exception_log.event(server_time, 'squad space scan - %s: %r' % (squad_base_id, squad_feature))

                    squad_id = squad_feature['squad_id']
                    if SQUAD_IDS.is_mobile_squad_id(squad_id):

                        # note: squad may have been kicked off map above.
                        # If so, we don't need to update the space stats.

                        squad_lock_id = SpinDB.base_lock_id(session.player.home_region, squad_base_id)
                        if session.viewing_base_lock == squad_lock_id:
                            # we were attacking this squad. Skip if it's a victory
                            if outcome == 'victory':
                                continue
                        elif (not session.viewing_squad_locks) or \
                             (squad_lock_id not in session.viewing_squad_locks) or \
                             session.viewing_squad_locks[squad_lock_id] <= -2: # tombstone - see forget_base_lock()
                            continue # squad is gone off the map. Skip.

                        # squad is still on the map. update space stats.
                        feature_update = {'total_space': total_space_by_squad_id.get(squad_id, 0),
                                          'alive_space': alive_space_by_squad_id.get(squad_id, 0)}
                        if feature_update:
                            if gamedata['server'].get('log_nosql_squad_space',0) >= 2:
                                gamesite.exception_log.event(server_time, 'squad space update - %s/%s - complete_attack(defender): %r' % \
                                                             (session.player.home_region, squad_base_id, feature_update))
                            gamesite.nosql_client.update_map_feature(session.player.home_region, squad_base_id, feature_update,
                                                                     originator=session.player.user_id, reason='complete_attack(defender)')


            # END has_attacked

        session.has_attacked = False
        session.revenge_attack_until = -1
        session.debug_log_action('_complete_attack')

        session.defender_cc_standing = False
        session.reset_attack_log()
        session.attack_finish_time = -1
        session.loot = {}
        session.res_looter = None
        session.starting_base_damage = None
        session.starting_resources = None
        session.items_expended = {}
        session.auto_resolved = False
        session.resurrectable_objects = []
        session.incoming_attack_type = None
        session.incoming_attack_data = None
        session.incoming_attack_units = []
        session.incoming_attack_time = -1
        session.incoming_attack_wave_time = -1

        # force repairs to start to avoid exploits where you leave your own buildings unrepaired
        # note: not sending updates to retmsg, so we assume a session change will come right after this
        if session.home_base:
            self.do_start_repairs(session, None, session.player.my_home.base_id, repair_units = False)
            session.player.ladder_point_decay_check(session) # after attack - player

        if summary:
            retmsg.append(["BATTLE_ENDED",
                           outcome,
                           summary,
                           session.viewing_base.get_cache_props(), # extra_props = {'deployment_buffer': session.viewing_base.deployment_buffer} ?
                           session.ladder_state,
                           self.sign_battle_history(summary['time'], summary['attacker_id'], summary['defender_id'], summary.get('base_id', None))
                           ])

        # queue the callback (and any future complete_attack()s called before the I/O completes), and call them after I/O completes

        def finish(session, io_type):
            if io_type == 'store_viewing_player':
                # release squads and home map feature lock
                session.release_base()

                # release lock AFTER playerdb store completes
                gamesite.lock_client.player_lock_release(session.viewing_user.user_id,
                                                         session.viewing_player.generation,
                                                         Player.LockState.being_attacked,
                                                         expected_owner_id = session.player.user_id)

            elif io_type == 'store_viewing_base' or io_type == 'del_viewing_base':
                if io_type == 'store_viewing_base':
                    session.viewing_base.send_map_feature_update(reason='complete_attack')
                session.release_base()

            session.complete_attack_in_progress = False
            d, session.complete_attack_d = session.complete_attack_d, None
            if d: d.callback(True)

        post_result = functools.partial(finish, session, io_type)

        if io_type is None:
            reactor.callLater(0, post_result)
        elif io_type == 'store_ai_instance':
            ai_instance_table.store_async(session.player, session.user.user_id, session.viewing_user.user_id, session.viewing_player, post_result, True, 'complete_attack')
        elif io_type == 'del_ai_instance':
            ai_instance_table.delete_async(session.player, session.user.user_id, session.viewing_user.user_id, post_result)
        elif io_type == 'store_viewing_player':
            player_table.store_async(session.viewing_player, post_result, True, 'complete_attack')
        elif io_type == 'store_viewing_base':
            if gamedata['server'].get('nosql_full_store', False):
                # should be unnecessary - all updates should have been written out individually
                base_table.store_async(session.viewing_base, post_result, True, 'complete_attack')
            else:
                reactor.callLater(0, post_result)
        elif io_type == 'del_viewing_base':
            base_table.delete_async(session.viewing_base.base_region, session.viewing_base.base_id, post_result)
        else:
            raise Exception('unknown io_type '+io_type)

        return session.start_async_request(session.complete_attack_d)

    # the outer change_session() function just checks whether the player is eligible to change sessions right now
    def change_session(self, session, retmsg, dest_user_id = None, dest_base_id = None, force = False, new_ladder_state = None, delay = 0, client_props = None):
        assert dest_user_id or dest_base_id
        assert not (dest_user_id and dest_base_id)
        pre_attack = client_props.get('pre_attack', None) if client_props else None

        if dest_user_id:
            # old inline path
            if (not force) and (session.viewing_user is not None) and (session.viewing_user.user_id == dest_user_id) and (session.viewing_base is session.viewing_player.my_home) and (not session.has_attacked):
                return session.start_async_request(defer.succeed(False)) # already viewing this base
        else:
            # new quarry path
            assert gamesite.nosql_client and session.player.home_region
            if (not force) and (session.viewing_base.base_id == dest_base_id) and (not session.has_attacked):
                return session.start_async_request(defer.succeed(False)) # already viewing this base

        if session.home_base and session.has_attacked:
            # reset daily attack timer
            session.player.last_daily_attack = server_time
            # do not do this from complete_attack, because that is called in the logout/relog path

        if dest_user_id == session.user.user_id:
            reason = 'change_session (home) %d' % (session.user.user_id)
            change = SessionChangeHome(session, retmsg, dest_user_id, dest_base_id, new_ladder_state, delay, pre_attack)
        elif dest_user_id:
            reason = 'change_session (old) %d -> %d' % (session.user.user_id, dest_user_id)
            change = SessionChangeOld(session, retmsg, dest_user_id, dest_base_id, new_ladder_state, delay, pre_attack)
        else:
            reason = 'change_session (new) %d:%s -> %s pre_attack %r' % (session.user.user_id, session.viewing_base.base_id, dest_base_id, pre_attack)
            change = SessionChangeNew(session, retmsg, dest_user_id, dest_base_id, new_ladder_state, delay, pre_attack)

        ascdebug(reason)
        session.debug_log_action(reason)

        # it's cleaner to string everything together in one callback chain
        master_d = make_deferred('change_session')

        def set_progress_and_pass_result(result, session, prog):
            #ascdebug('change_session set_progress_and_pass_result in_progress %r result %r' % (prog, result))
            session.visit_base_in_progress = prog
            return result
        master_d.addBoth(set_progress_and_pass_result, session, True) # OK

        master_d.addCallback(lambda _, self=self,session=session,retmsg=retmsg,client_props=client_props:
                             self.complete_attack(session, retmsg, client_props = client_props, reason='change_session'))

        # note: continue even if complete_attack() fails
        master_d.addErrback(report_and_absorb_deferred_failure, session)

        master_d.addCallback(lambda _, change=change: change.begin())

        # if the main session change fails after begin(), we need to insert a forced change back to base
        # (since we already ran complete_attack(), which irreversibly mutates state like res_looter)
        def handle_failed_change(self, session, retmsg):
            session.release_pre_locks()
            # go back home
            new_change = SessionChangeHome(session, retmsg, session.user.user_id, None, None, 0, None)
            reason = 'change_session (home) %d because of failure' % (session.user.user_id)
            ascdebug(reason)
            session.debug_log_action(reason)
            return new_change.begin().addCallback(lambda args, self=self: self.change_session_complete(*args))

        master_d.addCallback(lambda args, self=self, session=session, retmsg=retmsg:
                             # note: receives the list of arguments to pass from change.d's callback
                             # if args is None, that means the change attempt failed
                             self.change_session_complete(*args) if args else handle_failed_change(self, session, retmsg))

        # we DO care about exceptions inside change_session_complete(), since we need to release locks
        master_d.addErrback(report_and_reraise_deferred_failure, session)
        master_d.addErrback(lambda err, session=session: session.release_pre_locks()) # now swallow the exception

        master_d.addBoth(set_progress_and_pass_result, session, False) # OK

        reactor.callLater(0, master_d.callback, True)
        return session.start_async_request(master_d)

    def change_session_complete(self, session, retmsg, dest_user_id, dest_user, dest_player, dest_base_id,
                                dest_base, new_ladder_state, new_deployable_squads, new_defending_squads,
                                pre_attack):

        if dest_base_id:
            reason = 'change_session_complete (new) %d:%s -> %s (%d,%d,%d) pre_attack %r' % (session.user.user_id, session.viewing_base.base_id, dest_base_id, bool(dest_user), bool(dest_player), bool(dest_base), pre_attack)
        else:
            reason = 'change_session_complete (old) %d -> %d (%d,%d) pre_attack %r' % (session.user.user_id, dest_user_id, bool(dest_user), bool(dest_player), pre_attack)

        ascdebug(reason)
        session.debug_log_action(reason)

        cannot_spy = False

        if (not dest_player) or (not dest_user) or (dest_base_id and (not dest_base)):
            # error, revert to home base
            # sometimes playerdb/userdb files are missing when spying on brand new accounts that haven't been flushed yet

            my_filter = gamedata['server'].get('bad_internet_exception_log_filter', None)
            if (not my_filter) or (Predicates.read_predicate(my_filter).is_satisfied2(session, session.player, None)):
                gamesite.exception_log.event(server_time, 'spy error: userdb %d playerdb %d basedb %d entry %s:%s (spied by user %d)' % (bool(dest_user), bool(dest_player), bool(dest_base), str(dest_user_id), str(dest_base_id), session.user.user_id))

            if dest_base_id:
                err_msg = "CANNOT_SPY_BASE_NOT_FOUND"
            elif is_ai_user_id_range(dest_user_id):
                err_msg = "CANNOT_SPY_INVALID_AI"
            else:
                err_msg = "CANNOT_SPY_PLAYER_NOT_FOUND"
            retmsg.append(["ERROR", err_msg, dest_base_id if dest_base_id else dest_user_id, 'change_session_complete'])
            cannot_spy = True

        if dest_base and \
           (not (gamesite.nosql_client and session.player.home_region)):
            if dest_base.base_landlord_id != session.player.user_id and \
               not session.player.travel_satisfied(dest_base) and (not session.player.is_cheater):
                retmsg.append(["ERROR", "CANNOT_SPY_TRAVEL_NOT_ARRIVED"])
                cannot_spy = True

        if dest_base and dest_base.base_type in ('hive','quarry'):
            if dest_base.base_landlord_id == session.player.user_id:
                pass # can always visit your own quarries
            else:
                # check activation predicate
                template = gamedata[{'hive':'hives_server','quarry':'quarries_server'}[dest_base.base_type]]['templates'] \
                           .get(dest_base.base_template, None)
                if template and ('activation' in template) and (not session.player.is_cheater):
                    if (not Predicates.read_predicate(template['activation']).is_satisfied2(session, session.player,None)):
                        retmsg.append(["ERROR", "CANNOT_SPY_INVALID_AI"])
                        cannot_spy = True

        # check for uncollected loot when leaving home base
        if dest_base or (dest_user is not session.user):
            # for safety, abort the session change instead of dumping buffered loot
            if session.player.loot_buffer:
                retmsg.append(["ERROR", "CANNOT_SPY_LOOT_BUFFER_NOT_EMPTY"])
                cannot_spy = True
            # dump buffered loot when leaving home base
            # session.player.loot_buffer_release('change_session_complete')

        # check for map violations

        if (not cannot_spy) and \
           (not dest_base_id) and dest_player and dest_user:
            map_ok, map_violation_error = session.player.can_spy_on_home(session.user, dest_player, dest_user.social_id, new_ladder_state, new_deployable_squads)
            if not map_ok:
                retmsg.append(["ERROR", map_violation_error])
                cannot_spy = True

        # in NoSQL-land when spying on a friendly squad or quarry, grab the lock immediately so that we can mutate objects we own
        if (not cannot_spy) and dest_base and (dest_base.base_type in ('squad','quarry')) and (dest_base.base_landlord_id == session.player.user_id) \
           and (gamesite.nosql_client and session.player.home_region):
            # XXXXXX hack - this is to fix squads in defending_squads dying since the order is query->complete_attack->session_change
            # the real solution is to move query AFTER complete_attack
            new_deployable_squads = {}
            for base_id in new_defending_squads.keys():
                if not gamesite.nosql_client.get_map_feature_by_base_id(dest_base.base_region, base_id, reason='change_session_complete'):
                    #gamesite.exception_log.event(server_time, 'dropping defending_squad %s' % base_id)
                    del new_defending_squads[base_id]

            #gamesite.exception_log.event(server_time, 'about to acquire_base %s deployable %s defending %s' % (dest_base.base_id, repr(new_deployable_squads), repr(new_defending_squads)))
            lock_errors = []
            state = session.do_acquire_base(dest_player, dest_base, new_deployable_squads, new_defending_squads, errors = lock_errors)
            if state != Player.LockState.being_attacked:
                retmsg.append(["ERROR", lock_errors[0], "nosql_spy"])
                cannot_spy = True
            else:
                session.has_attacked = True
                session.debug_log_action('reinforce')
                session.attack_finish_time = server_time + gamedata['reinforce_time']

        if cannot_spy:
            # send back to home base
            dest_user_id = session.user.user_id
            dest_base_id = None
            dest_base = None
            new_deployable_squads = {}
            defending_feature = {'base_id': 's%d_%d' % (dest_user_id, SQUAD_IDS.BASE_DEFENDERS),
                                 'base_landlord_id': dest_user_id,
                                 'squad_id': SQUAD_IDS.BASE_DEFENDERS}
            new_defending_squads = {defending_feature['base_id']: defending_feature}
            new_ladder_state = None
            pre_attack = None
            session.release_pre_locks()

        session.clear_objects()
        session.home_base = ((not dest_base_id) and (dest_user_id == session.user.user_id))

        if session.home_base:
            session.viewing_user = session.user
            session.viewing_player = session.player
        else:
            assert (dest_user and dest_player)
            session.viewing_user = dest_user
            session.viewing_player = dest_player

        if session.viewing_player is not session.player:
            if session.viewing_player.is_human():
                # record the fact that we do not have a write lock on session.viewing_player
                session.viewing_player.has_write_lock = False

            # set player.country here for viewed other players, for so anti-bullying predicate check will work
            if (session.viewing_player.country == 'unknown') and (session.viewing_user.country) and (session.viewing_user.country != 'unknown'):
                session.viewing_player.country = session.viewing_user.country

        debug_prev_base_id = session.viewing_base.base_id if session.viewing_base else 'null'

        if dest_base:
            session.viewing_base = dest_base
        else:
            session.viewing_base = session.viewing_player.my_home

        session.deployable_squads = new_deployable_squads
        session.defending_squads = new_defending_squads
        session.deployed_units = None
        session.deployed_donated_units = None
        session.protection_eligible = None # reset flag

        # simulate passage of time for repairs

        # update unit repairs
        session.viewing_player.unit_repair_tick()

        # update building repairs and production
        session.viewing_base.simulate_passage_of_time()

        base_damage, base_repair_time = session.viewing_base.calc_base_damage_and_repair_time()

        session.starting_base_damage = base_damage

        if session.viewing_player is not session.player and session.viewing_player.is_human():
            session.viewing_player.ladder_point_decay_check(session, base_damage = base_damage, base_repair_time = base_repair_time) # session change - viewing_player

        if new_ladder_state and (not session.viewing_player.is_ai()) and \
           (not \
            ((session.player.is_ladder_player() and session.viewing_player.is_ladder_player()) or \
             (session.using_squad_deployment() and (session.player.home_region in gamedata['regions']) and \
              ('ladder_on_map_if' in gamedata['regions'][session.player.home_region]) and \
              Predicates.read_predicate(gamedata['regions'][session.player.home_region]['ladder_on_map_if']).is_satisfied2(session, session.player, None) \
              ) \
             ) \
            ):
            gamesite.exception_log.event(server_time, 'ladder_state %s but not all players %d, %d are on the ladder - cancelling ladder state' % \
                                         (repr(new_ladder_state), session.player.user_id, session.viewing_player.user_id))
            new_ladder_state = None

            # sometimes we get here because the player cache's ladder_player/home_region is out of sync with viewing player
            # so update it to be safe
            props = {'home_region':session.viewing_player.home_region,
                     'ladder_player': int(session.viewing_player.is_ladder_player(ignore_global=True))}
            if (not gamedata['predicate_library']['pvp_requirement']['predicate'].startswith('ALWAYS_')):
                props['pvp_player'] = int(session.viewing_player.is_pvp_player())
            gamesite.pcache_client.player_cache_update(session.viewing_player.user_id, props, reason = 'fix_ladder_state')

        if new_ladder_state and (session.viewing_player is session.player):
            gamesite.exception_log.event(server_time, 'ladder_state %s but player %d is at home - cancelling ladder state' % \
                                         (repr(new_ladder_state), session.player.user_id))
            new_ladder_state = None

        if new_ladder_state:
            # re-adjust ladder state according to trophy count
            new_ladder_state = session.player.create_ladder_state(session.viewing_player.user_id, session.viewing_player)

        elif (not session.home_base) and (session.viewing_base is session.viewing_player.my_home):

            # possibly create ladder state by other means
            if (not new_ladder_state) and session.using_squad_deployment(new_deployable_squads) and session.player.can_ladder_battle_on_map(session.viewing_player):
                # create ladder state for ladder-on-map battle
                kind = 'MAP'
                new_ladder_state = session.player.create_ladder_state(session.viewing_player.user_id, session.viewing_player, on_map = True)

            if (not new_ladder_state) and session.player.can_take_ladder_revenge(session.viewing_player):
                # create artificial ladder state for revenge battle
                kind = 'REVENGE'
                new_ladder_state = session.player.create_ladder_state(session.viewing_player.user_id, session.viewing_player, scale_points = gamedata['matchmaking']['ladder_point_revenge_scale'])
                new_ladder_state['is_revenge'] = True

            if new_ladder_state and gamedata['server']['log_ladder_pvp'] >= 2:
                gamesite.exception_log.event(server_time, 'ladder %s battle: %d vs. %d %s' % (kind, session.player.user_id, dest_user_id, repr(new_ladder_state)))

        session.ladder_state = new_ladder_state

        # compute resource state for player
        player_snapshot = session.player.resources.calc_snapshot()

        if session.viewing_base is not session.viewing_player.my_home:
            if session.viewing_base.base_landlord_id == session.player.user_id and session.viewing_base.base_ui_name:
                session.ui_name = session.viewing_base.base_ui_name
            elif session.viewing_base.base_type == 'quarry':
                session.ui_name = session.viewing_user.get_ui_name(session.viewing_player) + "'s Quarry" # ui_name
            elif session.viewing_base.base_type == 'squad':
                session.ui_name = session.viewing_user.get_ui_name(session.viewing_player) + "'s "+gamedata['strings']['squads']['squad']
            else:
                session.ui_name = session.viewing_user.get_ui_name(session.viewing_player)

            if session.viewing_player is session.player:
                enemy_snapshot = player_snapshot
            else:
                enemy_snapshot = session.viewing_player.resources.calc_snapshot()
                if session.viewing_base.base_type == 'hive':
                    # always permit hive destruction when CC is dead at the end of the fight
                    session.defender_cc_standing = True

            session.pvp_balance = session.player.get_pvp_balance(session.viewing_player, session.viewing_base)

            if gamesite.nosql_client:
                spyee_lock_state = gamesite.nosql_client.map_feature_lock_get_state_batch(session.player.home_region, [session.viewing_base.base_id], reason = 'spy_quarry')[0][0]
            else:
                spyee_lock_state = Player.LockState.open

            session.defender_protection_expired_at = -1

        elif session.viewing_player is session.player:
            session.ui_name = 'Your base' # ui_name
            enemy_snapshot = player_snapshot
            session.pvp_balance = None
            spyee_lock_state = Player.LockState.open
            session.defender_protection_expired_at = -1

        else:
            props = {'opponent_user_id':session.viewing_user.user_id,
                     'opponent_level':session.viewing_player.resources.player_level,
                     'opponent_type':session.viewing_player.ai_or_human()
                     }

            session.ui_name = session.viewing_user.get_ui_name(session.viewing_player)

            # compute resource state for the adversary
            enemy_snapshot = session.viewing_player.resources.calc_snapshot()

            session.defender_cc_standing = False
            for obj in session.viewing_base.iter_objects():
                if obj.spec.name == gamedata['townhall']:
                    session.defender_cc_standing = (not obj.is_destroyed())
                    break
            session.defender_protection_expired_at = session.viewing_player.resources.protection_end_time if (not session.viewing_player.is_ai()) else -1

            session.pvp_balance = session.player.get_pvp_balance(session.viewing_player, session.viewing_base)

            if session.viewing_player.is_ai():
                spyee_lock_state = Player.LockState.open
            else:
                # do this here so we send an up-to-date guess about lock state to the client upon Spying
                session.viewing_player.bust_expired_locks()
                spyee_lock_state = gamesite.lock_client.player_lock_get_state_batch([session.viewing_user.user_id], reason = 'spy')[0][0]

            props['pvp_balance'] = (session.pvp_balance if session.pvp_balance else 'equal')
            if ((not session.using_squad_deployment()) or gamedata['server'].get('log_ladder_pvp_on_map',False)):
                if session.is_ladder_battle() or (session.viewing_player.is_human() and gamedata['server'].get('log_ladder_peek',False)):
                    session.player.record_ladder_pvp_event('3303_ladder_spy' if session.is_ladder_battle() else '3307_ladder_peek',
                                                           {'defender_id': session.viewing_player.user_id,
                                                            'attacker_pts': session.player.ladder_points(),
                                                            'defender_pts': session.viewing_player.ladder_points(),
                                                            'attacker_res': session.player.resources.get_fungible_amounts(),
                                                            'defender_res': session.viewing_player.resources.get_fungible_amounts(),
                                                            'battle_streak_ladder': session.player.cooldown_active('battle_streak_ladder'),
                                                            'ladder_state': session.ladder_state})

        # add relevant objects into the session
        session.deferred_object_state_updates = set() # no need to send anymore
        obj_states = []
        aura_states = []

        # from current base
        for obj in session.viewing_base.iter_objects():
            if not gamedata.get('enable_defending_units',True) and obj.is_mobile(): continue # no defending units

            # at home base, do not show units belonging to reserves or any squad other than base defenders
            if session.viewing_base.base_type == 'home' and obj.is_mobile() and obj.squad_id and obj.squad_id != SQUAD_IDS.BASE_DEFENDERS: continue

            # don't let non-repair-droid players see repair droids in others' bases
            if obj.spec.name == 'repair_droid': continue

            # reset on_approach flag
            obj.on_approach_fired = False

            # last-chance check on unit level
            if obj.owner: obj.ensure_level(obj.owner.tech.get(obj.spec.level_determined_by_tech, 1))
            if obj.is_mobile():
                obj.ensure_mobile_position(session.viewing_base.ncells())

                # apply zombie debuffs, but only for enemy units (player units get these upon deployment, or, at home base, when AI attack deploys)
                if (not obj.is_destroyed()) and (obj.owner is not session.player):
                    obj.apply_weak_unit_debuffs(False)

            session.add_object(obj)
            obj_states.append(obj.serialize_state())
            if obj.auras: aura_states.append(obj.serialize_auras())

        # from defending squads
        if gamesite.nosql_client and session.player.home_region:
            for base_id, feature in session.defending_squads.iteritems():
                squad_id = feature['squad_id']
                if SQUAD_IDS.is_mobile_squad_id(squad_id):
                    for state in gamesite.nosql_client.get_mobile_objects_by_base(session.player.home_region, session.viewing_player.squad_base_id(squad_id), reason='change_session(defending_squads)'):
                        assert state['kind'] == 'mobile'
                        assert state['owner_id'] == session.viewing_player.user_id
                        obj = reconstitute_object(session.player, session.viewing_player, state, context = '%d vs %d at %s: defending_squads %d' % (session.player.user_id, session.viewing_player.user_id, session.viewing_base.base_id, squad_id))
                        if (not session.viewing_base.can_deploy_unit(obj.spec)): continue # ignore inapplicable units
                        obj.on_approach_fired = False
                        obj.ensure_level(session.viewing_player.tech.get(obj.spec.level_determined_by_tech, 1))
                        obj.ensure_mobile_position(session.viewing_base.ncells())
                        if (not obj.is_destroyed()):
                            obj.apply_weak_unit_debuffs(False)
                        session.add_object(obj)
                        obj_states.append(obj.serialize_state())
                        if obj.auras: aura_states.append(obj.serialize_auras())

        is_alt_account_unattackable = (session.viewing_player is not session.player) and \
                                      session.player.is_alt_account_unattackable(session.viewing_player.user_id)

        # retrieve spyee's alliance info
        session.viewing_alliance_id_cache = -1
        session.viewing_alliance_info_cache = None

        if session.viewing_player is not session.player and (not session.viewing_player.is_ai()) and \
           gamesite.sql_client and session.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances']):
            session.viewing_alliance_id_cache = gamesite.sql_client.get_users_alliance(session.viewing_user.user_id, reason = 'VISIT_BASE')
            if session.viewing_alliance_id_cache > 0:
                session.viewing_alliance_info_cache = gamesite.sql_client.get_alliance_info(session.viewing_alliance_id_cache, reason = 'VISIT_BASE')

        # sanity check
        if session.ladder_state:
            if session.pvp_balance in ('player','enemy_strict','same_alliance'):
                gamesite.exception_log.event(server_time, 'pvp_balance %s disallows ladder attack %s' % \
                                             (session.pvp_balance, repr(new_ladder_state)))
                session.ladder_state = None
            if base_damage >= gamedata['matchmaking']['ladder_win_damage']:
                gamesite.exception_log.event(server_time, 'base already damaged above win threshold (%f) before ladder attack %s' % \
                                             (base_damage, repr(new_ladder_state)))

        # if we're going to immediately auto-resolve, THROW AWAY session change messages so the client doesn't even seen them
        if pre_attack >= 2:
            change_retmsg = []
        else:
            change_retmsg = retmsg

        change_retmsg.append(["SESSION_CHANGE", # XXXXXX clean up these parameters
                       session.viewing_user.user_id,
                       session.viewing_user.facebook_id,
                       session.ui_name,
                       int(session.home_base),
                       obj_states,
                       player_snapshot.serialize(),
                       enemy_snapshot.serialize(enemy = True),
                       -1, # conceal session.viewing_player.expiration_time
                       None, # old_battle_summary - obsolete
                       None, # outcome - obsolete
                       session.pvp_balance,
                       spyee_lock_state,
                       session.viewing_player.isolate_pvp,
                       0, # repeat_attack_cooldown expire time - obsolete
                       session.viewing_base.deployment_buffer,
                       session.viewing_base.base_id,
                       session.viewing_base.base_landlord_id,
                       session.viewing_base.base_climate,
                       session.viewing_base.base_map_loc,
                       session.viewing_base.base_expire_time,
                       session.viewing_base.base_ui_name,
                       session.viewing_base.base_type,
                       session.viewing_base.base_ncells,
                       session.viewing_player.my_home.base_id,
                       session.viewing_player.home_region,
                       is_alt_account_unattackable,
                       session.viewing_base.base_last_attack_time,
                       [x['squad_id'] for x in session.deployable_squads.itervalues()],
                       session.viewing_alliance_id_cache, session.viewing_alliance_info_cache,
                       session.ladder_state,

                       # viewing_trophy_data - obsolete
                       None,
                       session.player.warehouse_is_busy() if (not session.home_base) else False, # [33]

                       [x['squad_id'] for x in session.defending_squads.itervalues()],
                       session.viewing_player.is_pvp_player(),
                       [self.get_player_cache_props(session.user, session.player, session.alliance_id_cache)] + \
                       ([self.get_player_cache_props(session.viewing_user, session.viewing_player, session.viewing_alliance_id_cache)] if ((session.viewing_player is not session.player) and (not session.viewing_player.is_ai())) else []),

                       # list of equipped items AT HOME BASE usable in combat (e.g. missiles), used to drive the combat item bar GUI
                       # this is NOT the list of equipped items in the viewing base!
                       list(session.player.equipped_items_serialize(session.player.my_home)), # [37]

                       session.debug_session_change_count,
                       debug_prev_base_id,
                       session.viewing_base.base_richness, # [40]
                       session.viewing_base.deployment_allowed, # [41]
                       ])
        session.debug_session_change_count += 1
        for astate in aura_states:
            change_retmsg.append(["OBJECT_AURAS_UPDATE", astate])

        if session.player.prune_inventory(session):
            session.player.send_inventory_update(change_retmsg)

        session.player.prune_player_auras(is_session_change = True)
        session.viewing_player.prune_player_auras(is_session_change = True)

        session.apply_regional_auras()

        # apply general-purpose loot malus
        if (session.viewing_player is not session.player) and \
           (session.viewing_base.base_type not in ('quarry', 'squad')):
            malus = gamedata.get('townhall_loot_malus', 1)
            if malus < 1:
                # player townhall minus opponent townhall
                delta = session.player.get_townhall_level() - session.viewing_player.get_townhall_level()
                if delta >= 1:
                    session.player.do_apply_aura('townhall_loot_malus', strength = math.pow(malus, delta), ignore_limit = True)
                    malus_aura_spec = session.player.get_abtest_aura('townhall_loot_malus')
                    # XXX really this should be handled inside do_apply_aura()
                    if ('on_apply' in malus_aura_spec):
                        session.execute_consequent_safe(malus_aura_spec['on_apply'], session.player, change_retmsg, reason='on_apply_townhall_loot_malus')

        # set up PvP point auras
        if session.ladder_state:
            p = session.ladder_state['points']['victory'][str(session.player.user_id)]
            if p > 0: session.player.player_auras.append({'spec':'trophy_pvp_plus_attacker' if ('trophy_pvp_plus_attacker' in gamedata['auras']) else 'trophy_pvp_plus','stack':p})
            p = session.ladder_state['points']['defeat'][str(session.player.user_id)]
            if p < 0: session.player.player_auras.append({'spec':'trophy_pvp_minus_attacker' if ('trophy_pvp_minus_attacker' in gamedata['auras']) else 'trophy_pvp_minus','stack':-p})
            p = session.ladder_state['points']['victory'][str(session.viewing_player.user_id)]
            if p > 0: session.viewing_player.player_auras.append({'spec':'trophy_pvp_plus_defender' if ('trophy_pvp_plus_defender' in gamedata['auras']) else 'trophy_pvp_plus','stack':p})
            p = session.ladder_state['points']['defeat'][str(session.viewing_player.user_id)]
            if p < 0: session.viewing_player.player_auras.append({'spec':'trophy_pvp_minus_defender' if ('trophy_pvp_minus_defender' in gamedata['auras']) else 'trophy_pvp_minus','stack':-p})

            my_townhall, their_townhall = session.player.get_townhall_level(), session.viewing_player.get_townhall_level()

            # look for loot bonus or malus for (attacker,defender) townhall level
            if 'ladder_loot_bonus_by_townhall_level' in gamedata['matchmaking'] and (not session.viewing_player.is_ai()):
                table = gamedata['matchmaking']['ladder_loot_bonus_by_townhall_level']
                stacks = table[my_townhall-1][their_townhall-1]
                if stacks != 0:
                    aura = gamedata['auras']['pvp_loot_bonus' if stacks > 0 else 'pvp_loot_malus']
                    session.player.player_auras.append({'spec':aura['name'], 'stack': abs(stacks), 'strength': abs(aura['effects'][0]['strength_per_stack'])*abs(stacks)})

            if gamedata['server']['log_ladder_pvp'] >= 3:
                gamesite.exception_log.event(server_time, 'ladder spy (DMG %.02f %d vs %d): %s' % \
                                             (base_damage, my_townhall, their_townhall, session.format_ladder_state()))

        elif (session.viewing_player is not session.player) and \
             (session.viewing_base is session.viewing_player.my_home) and \
             (not session.viewing_player.is_ai()) and \
             (base_damage < gamedata['matchmaking']['ladder_win_damage']) and \
             ('ladder_point_minloss_table' in gamedata['matchmaking']) and \
             session.using_squad_deployment() and \
             (session.player.home_region in gamedata['regions']) and \
             ('ladder_on_map_if' in gamedata['regions'][session.player.home_region]) and \
             Predicates.read_predicate(gamedata['regions'][session.player.home_region]['ladder_on_map_if']).is_satisfied2(session, session.player, None):
            # create artificial point loss when crossing ladder_win_damage to punish players for getting so damaged they can't lose more points
            entry = gamedata['matchmaking']['ladder_point_minloss_table']['defender_defeat']
            delta = session.viewing_player.ladder_points() - session.player.ladder_points()
            p = max(min(int(entry['base'] - delta * entry['delta']), entry['min']), entry['max'])
            if session.viewing_player.home_region and session.viewing_player.home_region in gamedata['regions']:
                p *= gamedata['regions'][session.viewing_player.home_region].get('ladder_point_scale', 1) # note: this was not present earlier (by mistake), but players got used to it
                p *= Predicates.eval_cond_or_literal(gamedata['regions'][session.viewing_player.home_region].get('ladder_point_minloss_scale', 1), session, session.viewing_player)
                p = int(p)
            if p < 0:
                session.viewing_player.player_auras.append({'spec':'trophy_pvp_minus_minloss','stack':-p})

        # apply PvP fatigue aura
        if (not session.ladder_state) and \
           session.player.get_any_abtest_value('enable_sandstorm', gamedata['anti_bullying']['enable_sandstorm']) and \
           (session.viewing_player is not session.player) and \
           (session.viewing_base is session.viewing_player.my_home) and \
           (not session.viewing_player.is_ai()):
            cdname = 'battle_fatigue:%d' % session.viewing_user.user_id
            fatigue = session.player.cooldown_active(cdname)
            min_fatigue = gamedata['anti_bullying']['sandstorm_min_battle_fatigue']
            if fatigue > min_fatigue:
                togo = session.player.cooldown_togo(cdname)
                stack = fatigue - min_fatigue
                spec = gamedata['auras']['sandstorm']
                strength = stack * abs(spec['effects'][0]['strength_per_stack'])

                if (strength >= 1.0) or (fatigue >= gamedata['anti_bullying']['sandstorm_max_battle_fatigue']):
                    # switch to different aura that completely prevents attacks
                    spec = gamedata['auras']['sandstorm_max']
                    strength = 1
                    stack = -1

                session.player.do_apply_aura(spec['name'], strength = strength, duration = togo, stack = stack, ignore_limit = True)

        # manually force a stattab update right now, since it can affect ResLooter etc.
        session.player.recalc_stattab(session.player, session.viewing_base)
        session.player.stattab.send_update(session, change_retmsg)
        session.deferred_stattab_update = False

        if session.viewing_player is not session.player:
            session.viewing_player.recalc_stattab(session.player, session.viewing_base)
            session.viewing_player.stattab.send_update(session, change_retmsg)

        power_state = session.viewing_base.get_power_state()

        if session.home_base:
            session.player.unit_repair_send(change_retmsg)
        else:
            change_retmsg.append(["ENEMY_TECH_UPDATE", session.viewing_player.tech])
            change_retmsg.append(["ENEMY_UNIT_EQUIP_UPDATE", session.viewing_player.unit_equipment])

        change_retmsg.append(["BASE_POWER_UPDATE", power_state])
        change_retmsg.append(["BASE_SIZE_UPDATE", session.viewing_base.base_size])

        change_retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, False])
        change_retmsg.append(["DONATED_UNITS_UPDATE", session.player.donated_units])

        session.res_looter = ResLoot.ResLoot(gamedata, session, session.player, session.viewing_player, session.viewing_base,
                                             session.player.stattab.get_player_stat('loot_factor_pve' if session.viewing_player.is_ai() else 'loot_factor_pvp'))
        # tell client about res looter state
        session.res_looter.send_update(change_retmsg)
        session.starting_resources = session.viewing_player.resources.get_fungible_amounts()

        # if visiting a quarry that you own, force repairs to start
        if session.viewing_base.base_landlord_id == session.player.user_id and \
           session.viewing_base is not session.player.my_home:
            self.do_start_repairs(session, change_retmsg, session.viewing_base.base_id, repair_units = False)

        else:
            # fire AI base on_visit consequent
            on_visit_consequent = None

            if (session.viewing_base is session.viewing_player.my_home) and \
               session.viewing_player.is_ai():
                base = gamedata['ai_bases_server']['bases'].get(str(session.viewing_player.user_id), None)
                if base and ('on_visit' in base):
                    on_visit_consequent = base['on_visit']
            elif session.viewing_base.base_type == 'hive':
                template = gamedata['hives_server']['templates'].get(session.viewing_base.base_template, None)
                if template and ('on_visit' in template):
                    on_visit_consequent = template['on_visit']

            if on_visit_consequent:
                session.execute_consequent_safe(on_visit_consequent, session.player, change_retmsg, reason='on_visit')

        if pre_attack and (not cannot_spy): # immediately proceed with attack attempt
            do_attack_retmsg = [] # collect error messages separately
            attack_success = self.do_attack(session, do_attack_retmsg, [None, []])
            if not attack_success:
                session.release_pre_locks() # drop any pre-attack locks immediately

            if pre_attack >= 2: # pre-auto-resolve
                if attack_success:
                    self.auto_resolve(session, change_retmsg) # will be thrown away
                    if True: # dangerous - skips session change on client side
                        # first complete the attack manually so we get the battle-end messages
                        compl_d = self.complete_attack(session, retmsg)
                        compl_d.addErrback(report_and_absorb_deferred_failure, session)
                        # then go home, throwing away the session-change messages
                        compl_d.addCallback(lambda _, self=self, session=session, change_retmsg=change_retmsg: \
                                            self.change_session(session, change_retmsg, dest_user_id = session.player.user_id, force = True))
                        # then let the client know we skipped the session change
                        compl_d.addErrback(report_and_absorb_deferred_failure, session)
                        compl_d.addCallback(lambda _, session=session: session.outgoing_messages.append(["SESSION_CHANGE_SKIPPED"]))
                        return compl_d

                else:
                    retmsg += do_attack_retmsg # send error messages to client

                # safer, but sends ineffective session change to client
                # also necessary in case do_attack() fails
                return self.change_session(session, session.outgoing_messages, dest_user_id = session.player.user_id, force = True)

            else:
                retmsg += do_attack_retmsg

        else:
            assert not session.pre_locks

        return defer.succeed(not cannot_spy) # success

    def query_scout_reports(self, session, retmsg, arg):
        base_id, tag = arg[1], arg[2]
        assert session.player.home_region and base_id

        summary = None
        if gamedata['server'].get('battle_history_source','nosql/sql') in ('nosql','nosql/sql'):
            # get summary data from database
            summaries = gamesite.nosql_client.battles_get(session.user.user_id, -1, -1, -1,
                                                          time_range = [server_time - gamedata['server'].get('nosql_scout_reports_time_limit',8*3600), server_time],
                                                          limit = 1,
                                                          base_region = session.player.home_region,
                                                          base_id = base_id, base_types = ['raid','home'],
                                                          fields = ('time','new_raid_offense','new_raid_defense','new_raid_hp','new_raid_space','base_damage','base_map_loc'), # note: also update BATTLE_HISTORY_FIELDS if necessary
                                                          reason = 'query_scout_reports')
            if summaries:
                summary = summaries[0]

        retmsg.append(["QUERY_SCOUT_REPORTS_RESULT", tag, summary, None])

    def query_recent_attackers(self, session, retmsg, arg):
        tag = arg[1]

        if gamedata['server'].get('battle_history_source','nosql/sql') in ('nosql','nosql/sql'):
            # get summary data from database
            summaries = gamesite.nosql_client.battles_get(session.user.user_id, -1, -1, -1, time_range = [server_time - gamedata['server'].get('nosql_recent_attackers_time_limit',7*86400), server_time],
                                                          limit = gamedata['server'].get('nosql_battle_history_limit',50),
                                                          ai_or_human = SpinNoSQL.NoSQLClient.BATTLES_HUMAN_ONLY,
                                                          fields = ('attacker_id','attacker_type','defender_id'), reason = 'query_recent_attackers')
        else:
            # query ALL opponents
            summaries = sum([entry.get('summary',[]) for entry in session.player.battle_history.itervalues()], [])

        attacker_id_set = set()

        for s in summaries:
            if 'attacker_id' in s and \
               s.get('defender_id') == session.user.user_id and \
               s.get('attacker_type') == 'human': # check for home base attack?
                attacker_id_set.add(s['attacker_id'])

        retmsg.append(["QUERY_RECENT_ATTACKERS_RESULT", tag, list(attacker_id_set), None])

    # fields we care about for battle history (summary) queries
    BATTLE_HISTORY_FIELDS = ('time', 'duration', 'battle_type', 'ladder_state',
                             'attacker_id', 'defender_id', 'base_id', 'base_ui_name', 'base_region', 'base_map_loc', 'base_type',
                             'attacker_alliance_id', 'attacker_alliance_ui_name', 'attacker_alliance_chat_tag',
                             'defender_alliance_id', 'defender_alliance_ui_name', 'defender_alliance_chat_tag',
                             'facebook_friends',
                             'attacker_name', 'defender_name',
                             'attacker_level', 'defender_level',
                             # note: also update query_scout_reports() if necessary
                             'deployed_units', 'defending_units', 'raid_mode', 'new_raid_offense', 'new_raid_defense', 'new_raid_hp', 'new_raid_space',
                             'attacker_auras', 'defender_auras', 'attacker_tech', 'defender_tech',
                             'base_damage', 'loot', 'attacker_outcome', 'defender_outcome', 'prot_time',
                             'is_revenge', 'attacker_could_revenge_until', 'defender_can_revenge_until',
                             'replay_version')

    def query_battle_history(self, session, retmsg, arg):
        target = arg[1] # look up battles against this player (-1 for anyone)
        source = arg[2] # from the perspective of this player (-1 for anyone)
        alliance_A = arg[3] # require involvement from this alliance
        alliance_B = arg[4]
        tag = arg[5]
        ai_or_human = arg[6]
        assert ai_or_human in ('any','ai','human')
        time_range = arg[7]
        if time_range:
            assert isinstance(time_range, list) and len(time_range) == 2 and all(isinstance(x, (int,float)) for x in time_range)

        # sanity check
        assert (source > 0) or (alliance_A > 0) or (alliance_B > 0)

        # permission check
        if source != session.user.user_id and (not session.player.is_developer()) and (not gamedata.get('battle_logs_public',False)):
            # no peeking at others' battle histories unless you are a developer, or in the same alliance
            is_same_alliance = ((alliance_A > 0 or alliance_B > 0) and \
                                session.get_alliance_id(reason='query_battle_history') >= 0 and \
                                session.alliance_id_cache in (alliance_A, alliance_B))

            if (not is_same_alliance):
                retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                retmsg.append(["QUERY_BATTLE_HISTORY_RESULT", tag, [], [], None, True, 'illegal'])
                return

        # "nosql" for hot-only, "nosql/sql" for hot/cold, or "playerdb" (obsolete)
        battle_history_source = gamedata['server'].get('battle_history_source','nosql/sql') # also update query_recent_attackers()!

        battle_history = None
        if battle_history_source == 'playerdb':
            if source == session.user.user_id:
                # get any pending updates
                self.do_receive_mail(session, retmsg)
                battle_history = session.player.battle_history
            elif source == session.viewing_user.user_id:
                battle_history = session.viewing_player.battle_history
            elif (alliance_A > 0) or (alliance_B > 0):
                # alliance queries not supported from playerdb
                retmsg.append(["QUERY_BATTLE_HISTORY_RESULT", tag, [], [], None, True, 'offline'])
                return

        if battle_history_source in ('nosql','nosql/sql'):
            # get summary data from database
            # XXX need token-based paging to avoid infinite re-query if more than "limit" battles happen within one second

            # use "hot" MongoDB and/or "cold" PostgreSQL database depending on how far back in time we want to go

            # to ensure we don't miss any battles, we always do the hot query, and then also do the cold query
            # if the hot query is exhaustive.

            # hot query
            hot_limit = gamedata['server'].get('nosql_battle_history_limit', 50 if time_range else 10) # optimize for fast first range-less query
            hot_summaries = gamesite.nosql_client.battles_get(source, target, alliance_A, alliance_B, limit = hot_limit,
                                                              ai_or_human = {'any': SpinNoSQL.NoSQLClient.BATTLES_ALL,
                                                                             'ai': SpinNoSQL.NoSQLClient.BATTLES_AI_ONLY,
                                                                             'human': SpinNoSQL.NoSQLClient.BATTLES_HUMAN_ONLY}[ai_or_human],
                                                              time_range = time_range,
                                                              fields = self.BATTLE_HISTORY_FIELDS,
                                                              reason = 'query_battle_history(hot)')
            # is_final is true if there are no more battles earlier than this to query
            hot_is_final = len(hot_summaries) < hot_limit
            #gamesite.exception_log.event(server_time, 'HOT %r final %r' % ([x['time'] for x in hot_summaries], hot_is_final))

            # do we also need to do a cold query?
            if hot_is_final and \
               battle_history_source == 'nosql/sql' and \
               gamesite.sql_battles_client:
                # cold query
                cold_limit = gamedata['server'].get('sql_battle_history_limit', 150)
                cold_time_range = [gamedata.get('replay_oldest_timestamp', -1), server_time]
                if time_range and time_range[0] > cold_time_range[0]:
                    cold_time_range[0] = time_range[0]
                if time_range and time_range[1] > 0:
                    cold_time_range[1] = time_range[1]
                # don't overlap with hot data
                if hot_summaries:
                    cold_time_range[1] = min(cold_time_range[1], min(x['time'] for x in hot_summaries))
                cold_d = gamesite.sql_battles_client.battles_get_async(source, target, alliance_A, alliance_B, limit = cold_limit,
                                                                       ai_or_human = {'any': SpinSQLBattles.SQLBattlesClient.BATTLES_ALL,
                                                                                      'ai': SpinSQLBattles.SQLBattlesClient.BATTLES_AI_ONLY,
                                                                                      'human': SpinSQLBattles.SQLBattlesClient.BATTLES_HUMAN_ONLY}[ai_or_human],
                                                                       time_range = cold_time_range,
                                                                       reason = 'query_battle_history(cold)')

                # args we sent to battles_get_async, for debugging purposes
                cold_d_args = 'user_id %d source %r target %r alliance_A %r alliance_B %r limit %r ai_or_human %r time_range %r' % \
                              (session.user.user_id, source, target, alliance_A, alliance_B, cold_limit, ai_or_human, cold_time_range)

                # reformat results from raw summary list to (summaries, is_final, is_error)
                cold_d.addCallback(lambda cold_summaries, cold_limit=cold_limit: (cold_summaries, len(cold_summaries) < cold_limit, None))

                # merge hot and cold summaries, in descending time order
                def merge_hot_and_cold(cold_result, hot_summaries, hot_is_final):
                    cold_summaries, cold_is_final, cold_is_error = cold_result
                    #gamesite.exception_log.event(server_time, 'COLD %r final %r' % ([x['time'] for x in cold_summaries], cold_is_final))
                    #gamesite.exception_log.event(server_time, 'FINAL %r final %r' % ([x['time'] for x in (hot_summaries+cold_summaries)], cold_is_final and hot_is_final))
                    return (hot_summaries + cold_summaries, cold_is_final and hot_is_final, None)
                cold_d.addCallback(merge_hot_and_cold, hot_summaries, hot_is_final)

                # if cold query fails, just return the hot results as if the cold query never happened
                def filter_timeout_exception(e, hot_summaries, hot_is_final, cold_d_args):
                    if isinstance(e, failure.Failure) and e.type is SpinSQLBattles.TimeoutException:
                        gamesite.exception_log.event(server_time, 'SpinSQLBattles %s: %s' % (e.value, cold_d_args))
                        return (hot_summaries, hot_is_final, 'partial')
                    else:
                        raise e # continue down failure chain

                cold_d.addErrback(filter_timeout_exception, hot_summaries, hot_is_final, cold_d_args)
                cold_d.addErrback(report_and_reraise_deferred_failure, session)
                cold_d.addErrback(lambda _, hot_summaries=hot_summaries, hot_is_final=hot_is_final: (hot_summaries, hot_is_final, 'partial'))

                result_d = cold_d

            else:
                # return hot query only
                result_d = defer.succeed((hot_summaries, hot_is_final, None))

        elif battle_history_source == 'playerdb' and battle_history:
            # pull summary data out of player.battle_history
            is_final = True
            is_error = None

            if target < 0:
                # query ALL opponents
                summaries = sum([entry.get('summary',[]) for entry in battle_history.itervalues()], [])
            else:
                # query ONE opponent
                key = str(target)
                if key in battle_history:
                    summaries = battle_history[key].get('summary',[])
                else:
                    summaries = []

            if time_range:
                summaries = filter(lambda x: x['time'] >= time_range[0] and x['time'] < time_range[1], summaries)

            if ai_or_human == 'ai':
                # do not list AI ladder battles here
                summaries = filter(lambda x: (x.get('attacker_type')=='ai' or x.get('defender_type')=='ai') and (not x.get('ladder_state')), summaries)
            elif ai_or_human == 'human':
                # list AI ladder battles here
                summaries = filter(lambda x: (x.get('attacker_type')=='human' and x.get('defender_type')=='human') or x.get('ladder_state'), summaries)
            result_d = defer.succeed((summaries, is_final, is_error))

        else:
            is_final = True
            is_error = None
            summaries = []
            result_d = defer.succeed((summaries, is_final, is_error))

        # on async failure, replace summaries/is_final with blank data, then respond to client
        result_d.addErrback(report_and_reraise_deferred_failure, session)
        result_d.addErrback(lambda _: ([], True, 'offline')) # return blank (summaries, is_final, is_error)
        result_d.addCallback(self.query_battle_history_complete, session, tag, source if (alliance_A <= 0 and alliance_B <= 0) else None)
        result_d.addErrback(report_and_absorb_deferred_failure, session)
        return None # note: asynchronous with other session traffic!

    def query_battle_history_complete(self, summaries_is_final_is_error, session, tag, source):
        if session.logout_in_progress: return
        summaries, is_final, is_error = summaries_is_final_is_error
        assert is_error in (None, 'partial', 'offline') # "partial" means we have some data, "offline" means none
        ret = []
        pcache_data = None

        if not isinstance(summaries, list):
            raise Exception('unexpected summaries: %r ' % summaries)

        if summaries:

            # perform player cache lookups
            qset = set()
            for s in summaries:
                if not isinstance(s, dict):
                    raise Exception('unexpected summary: %r' % s)
                for player_id in (s['attacker_id'], s['defender_id']):
                    if player_id != session.user.user_id:
                        qset.add(player_id)
            if qset:
                pcache_data = self.do_query_player_cache(session, list(qset), reason = 'query_battle_history')

            # extract the fields we want from the summaries
            ret = [dict((k,s[k]) for k in self.BATTLE_HISTORY_FIELDS if k in s) for s in summaries]

            # sort summaries by time
            ret.sort(key = lambda r: -r.get('time',-1))

        session.send([["QUERY_BATTLE_HISTORY_RESULT", tag, ret,
                       [self.sign_battle_history(r.get('time',-1), r.get('attacker_id',-1), r.get('defender_id',-1), r.get('base_id',None)) for r in ret],
                       pcache_data, is_final, is_error]], flush_now = True)

    def query_achievements(self, session, retmsg, arg):
        id = arg[1]; tag = arg[2]

        d = make_deferred('query_achievements')

        def complete_query(self, d, session, retmsg, tag, result):
            retmsg.append(["QUERY_ACHIEVEMENTS_RESULT", tag, result])
            d.callback(True)

        result = None

        # if querying yourself or the viewing player, return immediately
        if id == session.player.user_id:
            result = session.player.achievements
        elif id == session.viewing_player.user_id:
            result = session.viewing_player.achievements

        if result is not None:
            reactor.callLater(0, functools.partial(complete_query, self, d, session, retmsg, tag, result))
        else:
            # otherwise do an async load
            # XXX this could be vulnerable to DDOS
            def player_cb(continuation, success, player):
                result = player.achievements if (success and player) else None
                continuation(result)
            player_table.lookup_async(session.player, id, False,
                                      functools.partial(player_cb, functools.partial(complete_query, self, d, session, retmsg, tag)),
                                      'query_achievements')

        return session.start_async_request(d) # async

    def query_player_alliance_membership_history(self, session, arg):
        tag = arg[1]
        target_id = arg[2]

        # remove fields the client shouldn't see
        def censor_event(event):
            for FIELD in ('sum','code','ident'):
                if FIELD in event: del event[FIELD]
            return event

        hot_events = map(censor_event,
                         gamesite.nosql_client.log_retrieve('log_alliance_members',
                                                            sort_direction = -1,
                                                            extra_qs = {'$or': [{'user_id': target_id},
                                                                                {'target_id': target_id}]}))

        if gamesite.sql_alliance_events_client:
            cold_events_d = gamesite.sql_alliance_events_client.player_alliance_membership_history_get_async(target_id, reason='query_player_alliance_membership_history')
            # censor and return as {'result':...}
            cold_events_d.addCallback(lambda event_list: {'result': map(censor_event, event_list)})
            cold_events_d.addErrback(report_and_reraise_deferred_failure, session)
            cold_events_d.addErrback(lambda _: {'result': [], 'error':'database_error'}) # in case of error, return empty list
        else:
            cold_events_d = defer.succeed({'result': [], 'error':'database_error'})

        def merge_hot_and_cold(cold_result, hot_events):
            # drop cold_events that have duplicate _ids with hot_events
            hot_ids = set(ev['_id'] for ev in hot_events)
            cold_result['result'] = filter(lambda ev: ev['_id'] not in hot_ids, cold_result['result'])
            ret = {'result': hot_events + cold_result['result']}
            if 'error' in cold_result:
                ret['error'] = cold_result['error']
            return ret

        cold_events_d.addCallback(merge_hot_and_cold, hot_events)

        def complete(all_result, tag):
            # query alliance info for all alliances seen
            alid_set = set(ev['alliance_id'] for ev in all_result['result'] if ev.get('alliance_id',-1) >= 0)
            if alid_set:
                alinfo_list = gamesite.sql_client.get_alliance_info(list(alid_set), member_access = False, get_roles = False, reason = 'QUERY_PLAYER_ALLIANCE_MEMBERSHIP_HISTORY')
            else:
                alinfo_list = []
            # query player info for all players seen
            playerid_set = set(ev['inviter_id'] for ev in all_result['result'] if ev.get('inviter_id') and ev['inviter_id'] != session.user.user_id) \
                           .union(ev['user_id'] for ev in all_result['result'] if ev.get('user_id') and ev['user_id'] != session.user.user_id)
            if playerid_set:
                playerinfo_list = self.do_query_player_cache(session, list(playerid_set), reason = 'QUERY_PLAYER_ALLIANCE_MEMBERSHIP_HISTORY')
            else:
                playerinfo_list = None
            session.send([["QUERY_PLAYER_ALLIANCE_MEMBERSHIP_HISTORY_RESULT", tag, all_result, alinfo_list, playerinfo_list]], flush_now = True)

        cold_events_d.addCallback(complete, tag)

        return None # note: asynchronous with other session traffic!

    # simulate player cache query results by just reading from the in-memory player
    def get_player_cache_props(self, user, player, alliance_id):
        #base_damage, base_repair_time = player.my_home.report_base_damage_and_repair_time_for_ladder(player)
        ret =  {'user_id': user.user_id,
                'ui_name': user.get_ui_name(player),
                'real_name': user.get_real_name(),
                'player_level': player.resources.player_level,
                'ladder_player': int(player.is_ladder_player()),
                'pvp_player': int(player.is_pvp_player()),
                'home_region': player.home_region,
                'home_base_loc': player.my_home.base_map_loc,
                'account_creation_time': user.account_creation_time,
                'protection_end_time': conceal_protection_time(player.resources.protection_end_time),
                'base_damage':player.my_home.calc_base_damage(),
#                'base_repair_time':base_repair_time,
                'trophies_pvp': player.ladder_points(),
                'trophies_pvv': player.trophies_pvv()
                }
        ret[gamedata['townhall']+'_level'] = player.get_townhall_level()
        if user.facebook_id: ret['facebook_id'] = user.facebook_id
        if user.ag_id: ret['ag_id'] = user.ag_id
        if user.kg_id: ret['kg_id'] = user.kg_id
        if user.bh_id: ret['bh_id'] = user.bh_id
        if user.mm_id: ret['mm_id'] = user.mm_id
        if user.social_id: ret['social_id'] = user.social_id
        if user.ag_avatar_url: ret['ag_avatar_url'] = user.ag_avatar_url
        if user.kg_avatar_url: ret['kg_avatar_url'] = user.kg_avatar_url
        if alliance_id is not None: ret['alliance_id'] = alliance_id
        return ret

    # handle a client-initiated player cache query
    def do_query_player_cache(self, session, user_ids, fields = None, get_trophies = True, reason = None):
        # only allow retrieval of a few user-visible fields
        manual_fields = (fields is not None)
        if fields is None:
            fields = ['user_id', 'player_level', gamedata['townhall']+'_level',
                      'social_id', 'ui_name', 'real_name', 'kg_avatar_url', 'ag_avatar_url', 'last_defense_time', 'last_login_time', 'uninstalled', # XXXXXX
                      'units_donated_cur_alliance', 'help_responses_cur_alliance', 'home_region', 'home_base_loc', 'ladder_player', 'pvp_player',
                      'LOCK_STATE', 'LOCK_OWNER', 'protection_end_time', 'base_damage', 'base_repair_time', 'account_creation_time',
                      'facebook_id', 'kg_id', 'ag_id', 'bh_id', 'mm_id',
                      'facebook_name', 'facebook_first_name', 'last_fb_notification_time', 'enable_fb_notifications', # remove later
                      'alliance_id'] # note: alliance_id is cached, not ground truth

        result = gamesite.pcache_client.player_cache_lookup_batch(user_ids, fields = fields, reason = reason)

        if gamesite.sql_client and (not manual_fields) and get_trophies:
            # SPECIAL CASE - the client wants the current PvP trophy count as "trophies_pvp" for GUI display of matchmaking info
            scores = gamesite.mongo_scores2_client.player_scores2_get(user_ids,
                                                                      [('trophies_pvp', session.player.scores2_ladder_master_point()),
                                                                       ('trophies_pvv', session.player.scores2_ladder_master_point()),
                                                                       ],
                                                                      rank = False, reason = 'do_query_player_cache(%s)' % reason)
        else:
            scores = [[None,None]] * len(user_ids) # inner array must be same length as score query!

        for i in xrange(len(user_ids)):
            r = result[i]
            if r:
                # ensure backreference is present
                if ('user_id' not in r): r['user_id'] = user_ids[i]

                # prevent info leaks
                if ('protection_end_time' in r): r['protection_end_time'] = conceal_protection_time(r['protection_end_time'])

                # insert trophy info
                if gamesite.sql_client:
                    for stat, idx in (('trophies_pvp',0),('trophies_pvv',1)):
                        if scores[i][idx]:
                            r[stat] = scores[i][idx].get('absolute',0)
                        else:
                            r[stat] = 0

        return result

    def do_quarry_query_uncached(self, session, retmsg, region, updated_since, reason = ''):
        reason += ',incr' if updated_since > 0 else ',full'

        db_time = 1

        with admin_stats.latency_measurer('do_quarry_query_uncached('+reason+':get_map_features)'):
            result = list(gamesite.nosql_client.get_map_features(region, updated_since = updated_since, reason = 'do_quarry_query_uncached('+reason+')'))

        for x in result:
            db_time = max(db_time, x.get('last_mtime',-1))

        if gamedata['server']['enable_map_compression'] and updated_since < 0:
            with admin_stats.latency_measurer('do_quarry_query_uncached('+reason+':encode)'):
                codec, z_result = compress_and_wrap_string(SpinJSON.dumps(result))
        else:
            codec = 'raw'
            z_result = result

        return db_time, codec, z_result

    def sign_battle_history(self, battle_time, attacker, defender, base_id):
        tosign = AttackLog.base_name(battle_time, attacker, defender, base_id)
        return base64.urlsafe_b64encode(hmac.new(str(SpinConfig.config['proxy_api_secret']), msg=tosign, digestmod=hashlib.sha256).digest())

    def get_battle_log3(self, session, retmsg, arg):
        battle_time = arg[1]
        attacker = arg[2]
        defender = arg[3]
        base_id = arg[4]
        client_sig = arg[5]
        tag = arg[6]

        # the battle log itself does not have sufficient information (attacker/defender alliance IDs) to determine
        # access permission. So instead, we use a secure signature of the args from the battle history.
        if not session.player.is_developer() and (not gamedata.get('battle_logs_public',False)):
            if session.user.user_id not in (attacker, defender) and \
               client_sig != self.sign_battle_history(battle_time, attacker, defender, base_id):
                retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                retmsg.append(["GET_BATTLE_LOG3_RESULT", tag, None])
                return

        metric_event_coded(session.user.user_id, '3831_battle_log_viewed', {'battle_time': battle_time,
                                                                            'attacker_id': attacker,
                                                                            'defender_id': defender,
                                                                            'base_id': base_id})

        # look for battle log
        if isinstance(io_system, S3IOSystem) and AttackLog.storage_s3_bucket():
            # try S3 download
            bucket = AttackLog.storage_s3_bucket()
            name = AttackLog.storage_s3_name(battle_time, attacker, defender, base_id)
            d_log_s3 = io_system.async_read_deferred((bucket, name), reason = 'GET_BATTLE_LOG3(log)')
            d_log_local = defer.succeed(None)
        else:
            # try local disk
            log_filename = AttackLog.storage_path(battle_time, attacker, defender, base_id)
            if os.path.exists(log_filename):
                d_log_local = defer.succeed(open(log_filename, 'rb').read())
            else:
                d_log_local = defer.succeed(None)
            d_log_s3 = defer.succeed(None)

        d_log_s3.addErrback(report_and_absorb_deferred_failure, session)
        d_log_local.addErrback(report_and_absorb_deferred_failure, session)

        # query for existence of a replay
        if isinstance(io_system, S3IOSystem) and AttackReplayReceiver.storage_s3_bucket():
            s3_bucket = AttackReplayReceiver.storage_s3_bucket()
            s3_name = AttackReplayReceiver.storage_s3_name(battle_time, attacker, defender, base_id)
            d_replay_exists_s3 = io_system.async_exists_deferred((s3_bucket, s3_name), reason = 'GET_BATTLE_LOG3(replay-exists)')
            d_replay_exists_local = defer.succeed(False)
        else:
            replay_filename = AttackReplayReceiver.storage_path(battle_time, attacker, defender, base_id)
            d_replay_exists_local = defer.succeed(os.path.exists(replay_filename))
            d_replay_exists_s3 = defer.succeed(False)

        d_replay_exists_s3.addErrback(report_and_absorb_deferred_failure, session)
        d_replay_exists_local.addErrback(report_and_absorb_deferred_failure, session)

        # wait for results of all queries
        d_all = defer.DeferredList([d_log_local, d_log_s3, d_replay_exists_local, d_replay_exists_s3])
        def cb(results, session, tag):
            ((success_log_local, data_log_local), (success_log_s3, data_log_s3), \
             (success_replay_exists_local, data_replay_exists_local), (success_replay_exists_s3, data_replay_exists_s3)) = results

            # see if we got valid log data
            raw_buf = None
            for data in (data_log_local, data_log_s3):
                if data and (data != 'NOTFOUND'):
                    raw_buf = data
                    break

            # gunzip and parse line-by-line JSON
            if raw_buf:
                with admin_stats.latency_measurer('GET_BATTLE_LOG3(parse)'):
                    ret = {'log': map(SpinJSON.loads, gzip.GzipFile(fileobj=cStringIO.StringIO(raw_buf)).readlines())}
            else:
                ret = None

            # see if we got any evidence of a replay existing
            if ret:
                ret['replay_exists'] = any(x is True for x in (data_replay_exists_local, data_replay_exists_s3))

            session.send([["GET_BATTLE_LOG3_RESULT", tag, ret]])

        d_all.addCallback(cb, session, tag)
        return session.start_async_request(d_all) # go async

    def get_battle_replay(self, session, retmsg, arg):
        battle_time = arg[1]
        attacker = arg[2]
        defender = arg[3]
        base_id = arg[4]
        client_sig = arg[5]
        tag = arg[6]

        if (not battle_time) or (not attacker) or (not defender):
            retmsg.append(["ERROR", "SERVER_PROTOCOL"]) # cannot be canceled
            return

        # the battle replay itself does not have sufficient information (attacker/defender alliance IDs) to determine
        # access permission. So instead, we use a secure signature of the args from the battle history.
        # this also allows sharing of replays, when the signature is included
        if not session.player.is_developer() and (not gamedata.get('battle_logs_public',False)):
            if session.user.user_id not in (attacker, defender) and \
               client_sig != self.sign_battle_history(battle_time, attacker, defender, base_id):
                retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                retmsg.append(["GET_BATTLE_REPLAY_RESULT", tag, None])
                return

        metric_event_coded(session.user.user_id, '3833_battle_replay_downloaded', {'battle_time': battle_time,
                                                                                   'attacker_id': attacker,
                                                                                   'defender_id': defender,
                                                                                   'base_id': base_id})

        if isinstance(io_system, S3IOSystem) and AttackReplayReceiver.storage_s3_bucket():
            # try S3 download
            bucket = AttackReplayReceiver.storage_s3_bucket()
            name = AttackReplayReceiver.storage_s3_name(battle_time, attacker, defender, base_id)
            d = io_system.async_read_deferred((bucket, name))
        else:
            filename = AttackReplayReceiver.storage_path(battle_time, attacker, defender, base_id)
            if os.path.exists(filename):
                d = defer.succeed(open(filename, 'rb').read())
            else:
                d = defer.succeed('NOTFOUND')

        # failure path
        d.addErrback(report_and_absorb_deferred_failure, session)

        # failure AND success path (failure indicated by buf being None or the 404 'NOTFOUND' value)
        def cb(buf, session, tag, battle_time, attacker_id, defender_id, base_id):
            ret = None

            if buf and (buf != 'NOTFOUND'):
                raw_ret = None
                with admin_stats.latency_measurer('GET_BATTLE_REPLAY(gunzip)'):
                    try:
                        raw_ret = gzip.GzipFile(fileobj=cStringIO.StringIO(buf)).read()
                    except:
                        gamesite.exception_log.event(server_time, 'player %d: error loading replay %d-%d-vs-%d at %s: %s' % (session.player.user_id, battle_time, attacker_id, defender_id, base_id, traceback.format_exc().strip()))

                if raw_ret:
                    with admin_stats.latency_measurer('GET_BATTLE_REPLAY(compress)'):
                        ret = compress_and_wrap_string(raw_ret)

            session.send([["GET_BATTLE_REPLAY_RESULT", tag, ret]])

        d.addCallback(cb, session, tag, battle_time, attacker, defender, base_id)

        return session.start_async_request(d) # go async

    def query_map_log(self, session, retmsg, arg):
        region_id = arg[1]
        time_range = arg[2]
        tag = arg[3]
        ret = list(gamesite.nosql_client.log_retrieve(gamesite.nosql_client.region_table_name(region_id, 'log'), time_range, reason='QUERY_MAP_LOG'))
        retmsg.append(["QUERY_MAP_LOG_RESULT", tag, ret])
        return None

    def do_complete_quest(self, session, retmsg, questname):
        quest = session.player.get_abtest_quest(questname)
        if quest.name in session.player.completed_quests:
            qdata = session.player.completed_quests[quest.name]
            if hasattr(quest, 'repeat_interval'):
                GRACE_PERIOD = 600 # grace period to deal with badly synced client clocks
                if (server_time - qdata['time']) < (quest.repeat_interval - GRACE_PERIOD):
                    # not enough time has passed yet to re-complete the quest
                    return
            else:
                # ignore duplicate request
                return
        else:
            qdata = None

        if (quest.show_if) and (not (quest.show_if.is_satisfied2(session, session.player, qdata))):
            retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED",
                           gamedata['quests'][questname]['show_if']])
            return

        # check quest activation
        if (quest.activation) and (not (quest.activation.is_satisfied2(session, session.player, qdata))):
            retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED",
                           gamedata['quests'][questname]['activation']])
            return

        # check quest goal completion
        if not (quest.goal.is_satisfied2(session, session.player, qdata)):
            retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED",
                           gamedata['quests'][questname]['goal']])
            return

        if not qdata:
            qdata = {'count':0}

        # mutate stored state for the quest
        qdata['count'] += 1
        qdata['time'] = server_time
        quest.goal.remember_state(session.player, qdata)
        session.player.completed_quests[quest.name] = qdata

        new_objects = session.player.give_quest_rewards(quest, session, retmsg)
        if hasattr(quest, 'repeat_interval'):
            session.increment_player_metric('repeatable_quests_completed', 1, time_series = False)
        else:
            session.increment_player_metric('quests_completed', 1, time_series = False)
            session.increment_player_metric('quest:'+questname+':completed', 1, time_series = False)

        for obj in new_objects:
            session.add_object(obj)
            retmsg.append(["OBJECT_CREATED2", obj.serialize_state()])
            if obj.auras:
                retmsg.append(["OBJECT_AURAS_UPDATE", obj.serialize_auras()])
            session.player.send_army_update_one(obj, retmsg)

        # recalculate resources since unit space/resources will have changed
        retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

        # special case - if it's the quest that finishes the extended tutorial, send mail
        # must come BEFORE COMPLETED_QUEST, because otherwise the new mail/history state will not be set up before player.update_quest_cache()
        session.player.send_inventory_intro_mail(session, retmsg)

        retmsg.append(["COMPLETED_QUEST", quest.name, qdata])

        # some quests may reveal new AI enemies on completion
        session.user.repopulate_ai_list(session)

        props = {'quest':quest.name,
                 'sum': session.player.get_denormalized_summary_props('brief')
                 }
        if hasattr(quest, 'repeat_interval'):
            evname = '4011_quest_complete_again'
            props['count'] = session.player.completed_quests[quest.name]['count']
        else:
            evname = '4010_quest_complete'
        metric_event_coded(session.user.user_id, evname, props)

        if quest.completion_server:
            quest.completion_server.execute(session, session.player, retmsg)

    def do_claim_achievement(self, session, retmsg, name):
        if name in session.player.achievements:
            # ignore duplicate request
            return
        data = gamedata['achievements'][name]
        for PRED in ('activation', 'show_if'):
            if ((PRED in data) and (not (Predicates.read_predicate(data[PRED]).is_satisfied2(session, session.player, None)))):
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", data[PRED]])
                return
        if (not Predicates.read_predicate(data['goal']).is_satisfied2(session, session.player, None)):
            retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", data['goal']])
            return
        props = {'time': server_time}
        session.player.achievements[name] = props
        retmsg.append(["ACHIEVEMENT_CLAIMED", name, props])
        metric_event_coded(session.user.user_id, '4055_achievement_claimed', {'name': name, 'sum': session.player.get_denormalized_summary_props('brief')})
        session.player.modify_scores({'achievement_points':session.player.get_achievement_points()}, method='=', reason = 'claim_achievement')

        if data.get('chat_announce', True) and \
           session.alliance_chat_channel and \
           session.player.get_any_abtest_value('chat_alliance_achievements', gamedata['chat_alliance_achievements']):
            session.do_chat_send(session.alliance_chat_channel, 'I got an achievement!', bypass_gag = True, props = {'type':'earned_achievement', 'achievement_name': name})

    def give_xp_to(self, session, player, retmsg, amount, reason, xy, obj_session_id = -1):
        if amount <= 0: return
        player.resources.gain_xp(amount, reason=reason)
        if player is session.player:
            retmsg.append(["GAINED_XP2", amount, obj_session_id, xy if xy else [-1,-1], session.player.resources.xp])

    def give_xp(self, session, retmsg, amount, reason, xy, obj_session_id = -1):
        self.give_xp_to(session, session.player, retmsg, amount, reason, xy, obj_session_id = obj_session_id)

    # eventually move all CAST_SPELL and execute_order() stuff here?
    def execute_spell(self, session, retmsg, spellname, spellarg, reason = None):
        spell = gamedata['spells'][spellname]

        if ('cooldown_name' in spell) and not (session.player.is_cheater):
            cd_name = spell['cooldown_name']
            if session.player.cooldown_active(cd_name):
                to_go = session.player.cooldowns[cd_name]['end'] - server_time
                raise Exception('player %d: spell cooldown %s has not expired yet (%d sec to go)' % (session.player.user_id, cd_name, to_go))

        if ('new_store_requires' in spell) and (not Predicates.read_predicate(spell['new_store_requires']).is_satisfied2(session, session.player, None)):
            raise Exception('player %d: not allowed to cast spell %s' % (session.player.user_id, spellname))

        success_ret = True

        if spellname == "GIVE_UNITS_LIMIT_BREAK":
            session.spawn_new_units_for_player(session.player, retmsg, spellarg, limit_break = True)
        elif spellname == "GIVE_UNITS":
            # see if there is enough space
            req = session.player.space_required_for_units(spellarg)
            cur = session.player.get_army_space_usage_by_squad()

            # check unit count limit
            for name, data in spellarg.iteritems():
                spec = session.player.get_abtest_spec(GameObjectSpec, name)
                if spec.limit >= 0:
                    if type(data) is int:
                        qty = data
                    else:
                        qty = data.get('qty',1)
                    if session.player.get_army_unit_count_by_specname().get(name, 0) + qty > spec.limit:
                        retmsg.append(["ERROR", "UNIT_COUNT_LIMIT"])
                        return False

            if (cur['ALL'] + req > session.player.stattab.total_space):
                retmsg.append(["ERROR", "UNIT_SPACE_LIMIT"])
                return False

            if (not session.player.squads_enabled()) or (not gamedata['produce_to_reserves']):
                if (cur[str(SQUAD_IDS.BASE_DEFENDERS)] + req > session.player.stattab.main_squad_space):
                    retmsg.append(["ERROR", "UNIT_SPACE_LIMIT"])
                    return False

            session.spawn_new_units_for_player(session.player, retmsg, spellarg)

        elif spellname.startswith("BOOST_"):
            res = session.player.resources.calc_snapshot()
            success = True

            if 'boost_amount' in spell:
                if spell['boost_amount'] >= 1:
                    if getattr(session.player.resources, spell['resource']) >= res.max_res(spell['resource']):
                        success = False
                    else:
                        amount_added = res.max_res(spell['resource']) - getattr(session.player.resources, spell['resource'])
                        session.player.resources.gain_res({spell['resource']:amount_added}, reason=reason)

                else:
                    amount_added = int(spell['boost_amount']*res.max_res(spell['resource']))
                    if getattr(session.player.resources, spell['resource']) + amount_added > res.max_res(spell['resource']):
                        success = False
                    else:
                        session.player.resources.gain_res({spell['resource']:amount_added}, reason=reason)

            elif 'give_amount' in spell:
                amount_added = spell['give_amount']
                if getattr(session.player.resources, spell['resource']) + amount_added > res.max_res(spell['resource']):
                    success = False
                else:
                    session.player.resources.gain_res({spell['resource']:amount_added}, reason=reason)
            else:
                raise Exception('Unhandled boost spell '+repr(spell))

            if success:
                admin_stats.econ_flow_player(session.player, reason, 'boost', {spell['resource']:amount_added})
                session.deferred_player_state_update = True

            else:
                retmsg.append(["ERROR", "STORAGE_LIMIT", spell['resource']])
                return False

        elif spellname == "BUY_RESOURCES_TOPUP":
            snap = session.player.resources.calc_snapshot()
            success = True
            for res in spellarg:
                if getattr(session.player.resources, res) >= snap.max_res(res):
                    success = False
                    break
            if success:
                session.player.resources.gain_res(spellarg, reason=reason)
                admin_stats.econ_flow_player(session.player, reason, 'boost', spellarg)
            else:
                return False

        elif spellname == "BUILD_INSTANTLY_FOR_FREE":
            if not self.do_build(session, retmsg, spellarg, True):
                return False

        elif spellname == "UPGRADE_UNIQUE_INSTANTLY_FOR_FREE":
            specname = spellarg
            obj = session.player.find_object_by_type(specname)
            if (not obj) or (not obj.is_building()):
                retmsg.append(["ERROR", "BUILDING_NOT_FOUND", specname])
                return False
            if not self.do_upgrade_instant(session, retmsg, obj, ignore_requires = True):
                return False

        elif spellname == "CHANGE_REGION" or spellname.startswith("CHANGE_REGION_INSTANTLY"):
            if session.has_attacked or (not session.home_base):
                retmsg.append(["ERROR", "CANNOT_TRAVEL_DURING_BATTLE"])
                return False

            new_region = spellarg[0]
            new_loc = spellarg[1]
            if len(spellarg) >= 3:
                new_loc_precision = spellarg[2]
            else:
                new_loc_precision = None

            if new_loc_precision:
                # check validity of precision parameter
                assert isinstance(new_loc_precision, dict)
                # if not developer, then must use canned parameters
                if not session.player.is_cheater:
                    max_rad = new_loc_precision.get('max_rad', gamedata['territory']['neighbor_search_radius'])
                    min_move = new_loc_precision.get('min_move', gamedata['territory']['relocate_min_move'])

                    if max_rad != gamedata['territory']['neighbor_search_radius'] or \
                       min_move < 1 or \
                       min_move*3 >= max_rad*2: # ensure min_move is less than (2/3) of max_rad
                        retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                        return False

            spell = gamedata['spells']['CHANGE_REGION']
            cdname = spell['cooldown_name']

            if (not spellname.startswith("CHANGE_REGION_INSTANTLY")) and session.player.cooldown_active(cdname) and (not session.player.is_cheater):
                retmsg.append(["ERROR", "ON_COOLDOWN"])
                retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])
                return False

            if not session.player.eligible_for_quarries():
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", session.player.get_any_abtest_value('quarry_requirement', gamedata['territory']['quarry_requirement'])])
                return False

            assert (new_region is None) or (new_region in gamedata['regions'])

            # see if this is an ordinary request or a developer request
#            if session.player.is_developer(): # developer request
#                gamesite.exception_log.event(server_time, 'developer %d request to change region: %s %s' % \
#                                             (session.player.user_id, new_region, repr(new_loc)))
#                pass

            requirement = session.player.get_any_abtest_value('change_region_requirement', gamedata['territory']['change_region_requirement'])
            pred = Predicates.read_predicate(requirement)
            if not pred.is_satisfied2(session, session.player, None):
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", requirement])
                return False

            if new_region:
                data = gamedata['regions'][new_region]
                if (session.player.home_region != new_region):
                    if (not data.get('open_join',True)) or \
                       ((not session.player.is_developer()) and data.get('developer_only',0)) or \
                       ((not session.player.is_developer()) and (data.get('pop_hard_cap',-1) >= 0 and gamesite.nosql_client.get_map_feature_population(new_region,'home',reason='change_region_specific') >= data['pop_hard_cap'])) or \
                       (('show_if' in data) and (not Predicates.read_predicate(data['show_if']).is_satisfied2(session, session.player, None))) or \
                       ((spellname != "CHANGE_REGION_INSTANTLY_ANYWHERE") and ('requires' in data) and (not Predicates.read_predicate(data['requires']).is_satisfied2(session, session.player, None))):
                        retmsg.append(["ERROR", "CANNOT_CHANGE_REGION_DESTINATION_FULL"])
                        return False

            reason = 'player_request'
            metric_event_coded(session.user.user_id, '4700_change_region_request', {'request_region':new_region, 'request_loc':new_loc, 'request_precision':new_loc_precision,
                                                                                    'old_region':session.player.home_region, 'old_loc':session.player.my_home.base_map_loc, 'reason':reason})
            success = session.player.change_region(new_region, new_loc, new_loc_precision, session, retmsg, reason=reason)

            if success:
                session.player.cooldown_trigger(cdname, spell['cooldown'])
                retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])
            else:
                retmsg.append(["ERROR", "CANNOT_CHANGE_REGION_DESTINATION_OCCUPIED"])

            return success

        elif spellname == "APPLY_AURA":
            target = spellarg[0]
            aura_name = spellarg[1]
            aura_strength = spellarg[2]
            aura_duration = spellarg[3]
            aura_stack = spellarg[4] if len(spellarg) >= 5 else -1

            assert target == 'player'
            #assert aura_duration > 0

            success = session.apply_player_aura(aura_name, strength = aura_strength, duration = aura_duration, stack = aura_stack)
            if not success:
                retmsg.append(["ERROR", "PLAYER_AURA_LIMIT"])
                return False

        elif spellname in ("ALLIANCE_GIFT_LOOT", "FRIEND_GIFT_LOOT"):
            is_alliance = (spellname == "ALLIANCE_GIFT_LOOT")
            loot_table = spellarg[0]['loot']
            msg = spellarg[0].get('mail_template') or {'ALLIANCE_GIFT_LOOT':'alliance_gift_mail', 'FRIEND_GIFT_LOOT':'friend_gift_mail'}[spellname]
            target_id = spellarg[1]

            if (target_id == session.player.user_id) or \
               (is_alliance and ((not session.player.is_same_alliance(target_id)) or \
                                 (not session.alliance_info_cache))):
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED"])
                return False

            loot = session.get_loot_items(session.player, loot_table, spellarg[0].get('item_duration',-1), spellarg[0].get('item_expire_at',-1))
            if not loot: return True # items already expired

            if isinstance(msg, basestring):
                # follow the reference into (localized) gamedata.strings
                if msg in gamedata['strings']:
                    msg = gamesite.get_localized_gamedata('strings', session.user.locale)[msg]
                else:
                    gamesite.exception_log.event(server_time, '%s with invalid mail_template %r' % (spellname, msg))
                    return False

            # check for expiring items, and ensure the message itself does not persist after the last item expires
            loot_expire_time = -1
            for item in loot:
                if item.get('expire_time',-1) > 0:
                    loot_expire_time = min(loot_expire_time, item['expire_time']) if (loot_expire_time > 0) else item['expire_time']
            message_expire_time = server_time + msg['duration']
            if loot_expire_time > 0:
                message_expire_time = min(message_expire_time, loot_expire_time)
            if server_time >= message_expire_time: return True # already expired

            if is_alliance:
                my_role_info = session.alliance_info_cache['roles'][str(session.alliance_membership_cache.get('role', gamesite.sql_client.ROLE_DEFAULT))]
                sender_role_name = my_role_info['ui_name']
                alliance_name = alliance_display_name(session.alliance_info_cache)
            else:
                sender_role_name = alliance_name = ''

            msg_data = {'type':'mail',
                        'expire_time': message_expire_time,
                        'from': session.player.user_id,
                        'from_name': msg['ui_from'].replace('%SENDER_NAME', session.user.get_ui_name(session.player)).replace('%SENDER_ROLE_NAME', sender_role_name).replace('%ALLIANCE_NAME', alliance_name),
                        'to': [target_id],
                        'subject': msg['ui_subject'].replace('%SENDER_NAME', session.user.get_ui_name(session.player)),
                        'body': msg['ui_body'].replace('%SENDER_NAME', session.user.get_ui_name(session.player)).replace('%SENDER_ROLE_NAME', sender_role_name).replace('%ALLIANCE_NAME', alliance_name).replace('%day', time.strftime('%d %b %Y', time.gmtime(server_time))).replace('%time', time.strftime('%H:%M', time.gmtime(server_time))),
                        'attachments': loot
                        }
            for EXTRA in ('show_if', 'discard_if', 'receipt_duration'):
                if EXTRA in msg: msg_data[EXTRA] = msg[EXTRA]

            gamesite.msg_client.msg_send([msg_data])

            if is_alliance:
                session.activity_classifier.set_flag('alliance_gift')
                pcache_data = self.do_query_player_cache(session, [target_id], reason = spellname, get_trophies = False)[0] or {}
                if session.alliance_chat_channel and pcache_data:
                    def format_item(item):
                        stack = item.get('stack',1)
                        stack_str = ('%dx ' % stack) if stack != 1 else ''
                        return stack_str + gamedata['items'][item['spec']]['ui_name']
                    session.do_chat_send(session.alliance_chat_channel,
                                         '', bypass_gag = True, props = {'type': 'alliance_gift_sent',
                                                                         'target_user_id': target_id,
                                                                         'target_chat_name': pcache_get_chat_name(pcache_data),
                                                                         'item_name': ', '.join([format_item(x) for x in loot])
                                                                         })
            if 'history_key' in spellarg[0]:
                history_key = spellarg[0]['history_key']
            elif is_alliance:
                history_key = 'alliance_gift_items_sent'
            else:
                history_key = 'friend_gift_items_sent'

            if history_key:
                session.increment_player_metric(history_key, len(loot), time_series = False)
                session.player.send_history_update(retmsg)

            if 'event_name' in spellarg[0]:
                event_name = spellarg[0]['event_name']
            elif is_alliance:
                event_name = '4170_alliance_gift_item_sent'
            else:
                event_name = None

            if event_name:
                event_props = {'attachments':loot, 'recipient_id':target_id}
                if is_alliance:
                    event_props['alliance_id'] = session.alliance_id_cache
                metric_event_coded(session.player.user_id, event_name, event_props)

        elif spellname.startswith("BUY_PROTECTION"):
            session.player.set_protection_end_time(session, max(session.player.resources.protection_end_time, server_time) + spell['duration'],
                                                   '3883_protection_from_spell', {'spellname': spellname, 'reason':reason})

        elif spellname.startswith("FREE_RANDOM_") or spellname.startswith("BUY_RANDOM_"):
            items = session.get_loot_items(session.player, gamedata['loot_tables'][spell['loot_table']]['loot'], -1, -1)

            success_ret = copy.deepcopy(items)
            metric_event_coded(session.user.user_id, '5100_free_random_item' if spellname.startswith("FREE_RANDOM_") else '5110_buy_random_item',
                               {'items':items})

            use_modal_looting = (session.player.get_any_abtest_value('modal_looting', gamedata['modal_looting']) and \
                                 session.player.find_object_by_type(gamedata['inventory_building']))

            if use_modal_looting:
                session.player.loot_buffer += items
                for item in items:
                    session.player.inventory_log_event('5125_item_obtained', item['spec'], item.get('stack',1), item.get('expire_time',-1), level=item.get('level',None), reason=spellname)

                retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, True])
            else:
                session.player.send_loot_mail('', 0, items, retmsg, mail_template = spell['mail_template'])

            if isinstance(spell['mail_template'], dict):
                duration = spell['mail_template'].get('duration',-1)
            else:
                duration = -1

            retmsg.append(["ITEMS_DISCOVERED", items, duration, 'loot_buffer' if use_modal_looting else 'messages'])

        elif spellname == "BUY_ITEM":
            skudata = Store.buy_item_find_skudata(spellarg, session.player)
            assert skudata

            on_purchase_cons = None

            if 'loot_table' in skudata:
                loot_table = gamedata['loot_tables'][skudata['loot_table']]
                items = session.get_loot_items(session.player, loot_table['loot'], -1, -1)
                on_purchase_cons = Store.buy_gamebucks_sku_get_loot_table_parameter(session, session.player, loot_table, 'on_purchase')

            elif 'item' in skudata:
                stack = int(skudata.get('stack',1))
                item = {'spec':skudata['item'], 'stack': stack}
                if 'level' in skudata: item['level'] = skudata['level']

                expire_time = -1
                melt_time = int(skudata.get('melt_time',-1))
                melt_dur = int(skudata.get('melt_duration',-1))
                if melt_dur > 0:
                    expire_time = server_time + melt_dur
                elif melt_time > 0:
                    expire_time = melt_time

                expire_time = session.get_item_spec_forced_expiration(gamedata['items'][item['spec']], prev_expire_time = expire_time)
                if expire_time > 0:
                    assert expire_time >= server_time # don't sell an expired item
                    item['expire_time'] = expire_time

                items = [item,]

            # for metrics only
            price = Predicates.eval_cond_or_literal(skudata['price'], session, session.player)
            price_currency = skudata.get('price_currency','fbcredits')
            if price_currency == 'fbcredits':
                price = session.player.get_any_abtest_value('gamebucks_per_fbcredit', gamedata['store']['gamebucks_per_fbcredit']) * price
                price_currency = 'gamebucks'

            if price_currency != 'gamebucks':
                # record noncurrency (token) purchases in gamebucks log
                # currency (gamebucks) purchases will appear in gamebucks log as 1400_gamebucks_spent
                gamesite.gamebucks_log.event(server_time, {'user_id': session.user.user_id,
                                                           'event_name': '5120_buy_item',
                                                           'summary': session.player.get_denormalized_summary_props('brief'),
                                                           'code':5120, 'ui_index':spellarg.get('ui_index',-1),
                                                           'items':items, 'price':price, 'price_currency':price_currency})

            #retmsg.append(["ITEM_PURCHASED", items, -1])
            discovered_where = None

            if session.player.get_any_abtest_value('modal_looting', gamedata['modal_looting']) and \
               session.player.find_object_by_type(gamedata['inventory_building']) and \
               not skudata.get('send_by_mail', False):
                session.player.loot_buffer += items
                for item in items:
                    session.player.inventory_log_event('5125_item_obtained', item['spec'], item.get('stack',1), item.get('expire_time',-1), item.get('level',None), reason='store')
                retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, True])
                discovered_where = 'loot_buffer'

            else:
                purchase_text = string.join([(('%dx ' % item['stack']) if item.get('stack',1) > 1 else '') + gamedata['items'][item['spec']]['ui_name'] for item in items], '\n')
                headline = gamedata['items'][items[0]['spec']]['ui_name']
                if len(items) > 1:
                    headline += '+'
                elif items[0].get('stack',1) > 1:
                    headline = ('%dx ' % items[0]['stack'])+headline

                session.player.send_loot_mail(purchase_text, headline, items, retmsg, mail_template = 'buy_item_mail')
                discovered_where = 'messages'

            if discovered_where:
                retmsg.append(["ITEMS_DISCOVERED", items, -1, discovered_where])

            if 'on_purchase' in skudata: # add to the one in the loot table
                if on_purchase_cons:
                    on_purchase_cons = {'consequent':'AND', 'subconsequents':[on_purchase_cons, skudata['on_purchase']]}
                else:
                    on_purchase_cons = skudata['on_purchase']

            if on_purchase_cons:
                session.execute_consequent_safe(on_purchase_cons, session.player, retmsg, reason='on_purchase')

        elif ('code' in spell) and (spell['code'] == 'projectile_attack'):
            if not session.has_attacked:
                retmsg.append(["ERROR", "CANNOT_USE_ITEM_OUTSIDE_OF_COMBAT"])
                return False
            if (session.viewing_base.base_climate and gamedata['climates'][session.viewing_base.base_climate].get('exclude_missiles', False)):
                retmsg.append(["ERROR", "CANNOT_USE_ITEM_UNDERGROUND"])
                return False
            props = {'spellname': spellname}
            if spellarg:
                props['spellarg'] = spellarg
            session.attack_event(session.player.user_id, '3960_combat_spell_cast', props)

        elif ('code' in spell) and (spell['code'] in ('instant_repair', 'instant_combat_repair')):
            do_units = False
            do_resurrect_units = False
            do_buildings = False

            if spell['code'] == 'instant_repair':
                if session.has_attacked or (not session.home_base):
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_IN_COMBAT"])
                    return False
                do_units = True
                do_resurrect_units = True
                do_buildings = True
            elif spell['code'] == 'instant_combat_repair':
                if (not session.has_attacked) or session.home_base: # important: don't allow use at home base (too many defenders will be repaired)
                    retmsg.append(["ERROR", "CANNOT_USE_ITEM_OUTSIDE_OF_COMBAT"])
                    return False
                do_units = True
                do_resurrect_units = True

            if session.has_attacked: # in combat, home or away
                props = {'spellname': spellname}
                if spellarg: props['spellarg'] = spellarg
                session.attack_event(session.player.user_id, '3960_combat_spell_cast', props)

            recalc_power = False
            for object in session.iter_objects():
                if object.owner is not session.player: continue
                if do_buildings and object.is_building() and object.is_damaged():
                    object.repair_finish_time = server_time - 1
                    self.ping_object(session, retmsg, object.obj_id, session.viewing_base)
                    if object.affects_power():
                        recalc_power = True
                elif do_units and object.is_mobile() and session.player.can_repair_unit(object): # and object.is_damaged():
                    # do this unconditionally, because object combat upates showing damage might be in-flight
                    session.player.unit_repair_cancel(object)
                    object.heal_to_full()
                    retmsg.append(["OBJECT_STATE_UPDATE2", object.serialize_state(fake_xy = [-1,-1])])

            # resurrect dead units
            if do_resurrect_units and session.has_attacked and (not session.home_base):
                to_remove = []
                for entry in session.resurrectable_objects:
                    object, death_location = entry
                    if object.owner is not session.player: continue
                    if not session.player.can_repair_unit(object): continue
                    to_remove.append(entry)
                    try:
                        assert not session.has_object(object.obj_id)
                        session.player.unit_repair_cancel(object)
                        object.heal_to_full()
                        session.add_object(object)
                        retmsg.append(["OBJECT_CREATED2", object.serialize_state(fake_xy = death_location)])
                        session.player.send_army_update_one(object, retmsg)
                    except:
                        gamesite.exception_log.event(server_time, 'player %d: error healing %s: %s' % (session.player.user_id, object.spec.name, traceback.format_exc().strip())) # OK

                for entry in to_remove:
                    session.resurrectable_objects.remove(entry)

            session.player.unit_repair_send(retmsg)
            if recalc_power:
                session.power_changed(session.viewing_base, None, retmsg)

        elif spell.get('code') == 'change_alias':
            new_alias = spellarg[0]
            assert type(new_alias) in (str, unicode)
            new_alias = SpinHTTP.unwrap_string(new_alias)
            new_alias = new_alias.strip()

            if not is_valid_alias(new_alias) or new_alias == session.player.alias:
                retmsg.append(["ERROR", "ALIAS_BAD"])
                return False

            # check uniqueness
            old_alias = session.player.alias
            old_name = session.user.get_ui_name(session.player)

            if gamesite.nosql_client.player_alias_exists(new_alias) or \
               not gamesite.nosql_client.player_alias_claim(new_alias.lower()):
                retmsg.append(["ERROR", "ALIAS_TAKEN"])
                return False
            if old_alias:
                gamesite.nosql_client.player_alias_release(old_alias) # for legacy case-sensitive aliases
                gamesite.nosql_client.player_alias_release(old_alias.lower())

            session.player.alias = new_alias
            # if the server crashes here, playerdb might have the old alias, but only the new alias will be reserved in the DB
            session.deferred_player_name_update = True
            if session.alliance_chat_channel:
                session.do_chat_send(session.alliance_chat_channel,
                                     'I have a new alias!',
                                     bypass_gag = True, props = {'type':'changed_alias',
                                                                 'old_name': old_name})
            self.send_player_cache_update(session, 'change_alias')

        elif spell.get('code') == 'change_title':
            new_title_name = spellarg[0]
            return session.change_player_title(new_title_name, retmsg, force = False, chat_announce = gamedata['server'].get('chat_title_changes',False))

        else:
            raise Exception('unknown spell '+spellname)

        if 'cooldown_name' in spell:
            if 'cooldown_origin' in spell:
                cooldown = spell['cooldown_interval'] - (server_time - spell['cooldown_origin']) % spell['cooldown_interval']
            else:
                cooldown = spell['cooldown']
            session.player.cooldown_trigger(spell['cooldown_name'], cooldown)
            retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])

        return success_ret

    def ping_object(self, session, retmsg, id, base):
        if id == GameObject.VIRTUAL_ID:
            # just ping player resources
            session.deferred_player_state_update = True
        else:
            # possible race condition due to unserialized AJAX
            if not session.has_object(id):
                #print 'race condition in ping_object, ignoring'
                return

            object = session.get_object(id)
            return self.do_ping_object(session, retmsg, object, base)

    @admin_stats.measure_latency('do_ping_object')
    def do_ping_object(self, session, retmsg, object, base, force_write = False):

            if not (object.is_building() or object.is_inert()):
                # no need to ping objects that aren't buildings or inerts
                return

            if object.owner is not session.player:
                # ping should be very cautious on objects not owned by player at his own base
                # since this case is brand new code. Be conservative and only answer "repair" pings.
                if object.is_building() and object.is_repairing():
                    pass
                else:
                    return

            did_a_repair = False
            did_finish_construction = False
            did_an_upgrade = False
            did_a_research = False
            did_a_manufacture = False
            did_a_remove = False

            xp = 0
            xp_why = []

            if object.is_building() and object.is_repairing():
                if server_time >= object.repair_finish_time:
                    # object fully repaired
                    did_a_repair = True
                    object.heal_to_full()
                    undamaged_time = object.repair_finish_time
                    object.repair_finish_time = -1
                    power_factor = compute_power_factor(base.get_power_state())
                    object.update_production(object.owner, base.base_type, base.base_region, power_factor)
                    object.update_all(undamaged_time, power_factor = power_factor)
                elif object.get_leveled_quantity(object.spec.power_shutdown_threshold) > 0:
                    # handles pings from power generators that use power_shutdown_threshold
                    object.update_repair_hp_only()
                    session.deferred_power_change = True

            if object.is_building() and object.is_under_construction() and (object.owner is session.player):
                prog = object.build_done_time
                if object.build_start_time >= 0:
                    prog += (server_time - object.build_start_time)
                if prog >= object.build_total_time:
                    # object fully constructed
                    did_finish_construction = True
                    object.build_total_time = -1
                    object.build_start_time = -1
                    object.build_done_time = -1
                    object.upgrade_ingredients = None
                    object.update_production(object.owner, base.base_type, base.base_region, compute_power_factor(base.get_power_state()))

                    # run metrics for home-base buildings
                    if base is object.owner.my_home:
                        session.deferred_history_update = True
                        num_built = sum([1 for p in object.owner.home_base_iter() if p.spec.name == object.spec.name])
                        session.setmax_player_metric('building:'+object.spec.name+':num_built', num_built, bucket = bool(object.spec.worth_less_xp))
                        if object.spec.history_category:
                            num_cat = sum([1 for p in object.owner.home_base_iter() if p.spec.history_category == object.spec.history_category])
                            session.setmax_player_metric(object.spec.history_category+'_built', num_cat, bucket = bool(object.spec.worth_less_xp))
                        if object.spec.track_level_in_player_history:
                            session.setmax_player_metric(object.spec.name+'_level', object.level, bucket = bool(object.spec.worth_less_xp))

                    if object.spec.upgrade_completion:
                        cons = object.get_leveled_quantity(object.spec.upgrade_completion)
                        if cons:
                            session.execute_consequent_safe(cons, session.player, retmsg, reason='building:upgrade_completion(%d)' % object.level)

            if object.is_building() and object.is_upgrading() and (object.owner is session.player):
                prog = object.upgrade_done_time
                if object.upgrade_start_time >= 0:
                    prog += (server_time - object.upgrade_start_time)
                if prog >= object.upgrade_total_time:
                    # object fully upgraded
                    did_an_upgrade = True
                    if object.is_producer():
                        object.halt_production(object.owner)
                    object.change_level(object.level + 1)
                    object.upgrade_total_time = -1
                    object.upgrade_start_time = -1
                    object.upgrade_done_time = -1
                    object.upgrade_ingredients = None
                    object.upgrade_help = None
                    object.update_production(object.owner, base.base_type, base.base_region, compute_power_factor(base.get_power_state()))

                    if SpinConfig.game() == 'fs':
                        metric_event_coded(object.owner.user_id, '4030_upgrade_building', {'building_type':object.spec.name, 'level':object.level, 'method':'use_resources', 'base_type': session.viewing_base.base_type})

                    # run metrics for home-base buildings
                    if base is object.owner.my_home:
                        session.deferred_history_update = True
                        max_level = max([p.level for p in object.owner.home_base_iter() if p.spec.name == object.spec.name])
                        session.setmax_player_metric('building:'+object.spec.name+':max_level', max_level, bucket = bool(object.spec.worth_less_xp))
                        if object.spec.history_category:
                            max_level = max([p.level for p in object.owner.home_base_iter() if p.spec.history_category == object.spec.history_category])
                            session.setmax_player_metric(object.spec.history_category+'_max_level', max_level, bucket = bool(object.spec.worth_less_xp))
                        if object.spec.track_level_in_player_history:
                            session.setmax_player_metric(object.spec.name+'_level', object.level, bucket = bool(object.spec.worth_less_xp))
                    session.user.create_fb_open_graph_action_building_upgrade(object)

                    if object.spec.upgrade_completion:
                        cons = object.get_leveled_quantity(object.spec.upgrade_completion)
                        if cons:
                            session.execute_consequent_safe(cons, session.player, retmsg, reason='building:upgrade_completion(%d)' % object.level)

            if object.is_building() and object.is_enhancing() and (object.owner is session.player):
                if object.update_enhancing(-1):
                    # enhancing complete
                    enh_state, object.enhancing = object.enhancing.enhance_state, None
                    enh_spec = session.player.get_abtest_spec(EnhancementSpec, enh_state['spec'])
                    enh_level = enh_state['level']
                    session.give_enhancement(session.player, retmsg, object, enh_state['spec'], enh_level, 'use_resources')
                    if enh_spec.completion:
                        session.execute_consequent_safe(enh_spec.get_leveled_quantity(enh_spec.completion, enh_level), session.player, retmsg, reason='enhancement:completion')

            if object.is_removing() and (object.owner is session.player):
                if object.update_removing():
                    # removing complete
                    did_a_remove = True
                    object.removing = None

                    if object.spec.remove_completion:
                        cons = object.get_leveled_quantity(object.spec.remove_completion)
                        if cons:
                            session.execute_consequent_safe(cons, session.player, retmsg, reason='building:remove_completion(%d)' % object.level)

                    if object.is_inert():
                        dict_increment(session.player.history, 'obstacles_removed', 1)

                    reward_gamebucks = object.get_leveled_quantity(object.spec.remove_reward_gamebucks)
                    if reward_gamebucks:
                        session.player.resources.gain_gamebucks(reward_gamebucks, reason='obstacle_removed')
                        dict_increment(session.player.history, 'obstacle_gamebucks', reward_gamebucks)
                        session.setvalue_player_metric('gamebucks_balance', session.player.resources.gamebucks, bucket=True, bucket_size=15*60)

                    map_pos = [object.x, object.y] if session.has_object(object.obj_id) else [-1,-1]
                    retmsg.append(["HARVESTED_RESOURCES", {'gamebucks': reward_gamebucks}, object.obj_id, map_pos, None, None])


            if object.is_building() and object.is_researching() and (object.owner is session.player):
                prog = object.research_done_time
                if object.research_start_time >= 0:
                    prog += (server_time - object.research_start_time)
                is_done = (prog >= object.research_total_time)

                if is_done:
                    # resarch is complete
                    did_a_research = True
                    tech_name = object.research_item
                    current = object.owner.tech.get(tech_name, 0)
                    object.research_item = ''
                    object.research_ingredients = None
                    object.research_total_time = -1
                    object.research_start_time = -1
                    object.research_done_time = -1
                    session.give_tech(object.owner, retmsg, tech_name, current+1, object, 'use_resources')

                    spec = session.player.get_abtest_spec(TechSpec, tech_name)
                    if spec.completion:
                        session.execute_consequent_safe(spec.get_leveled_quantity(spec.completion, current+1), session.player, retmsg, reason='tech:completion')

            if object.is_building() and object.is_crafting() and (object.owner is session.player):
                if object.update_crafting(-1):
                    # crafting is complete
                    # collect now if auto_collect applies
                    if gamedata['crafting']['categories'][gamedata['crafting']['recipes'][object.crafting.queue[0].craft_state['recipe']]['crafting_category']].get('auto_collect',True):
                        self.do_collect_craft(session, retmsg, object)

            if object.is_building() and object.is_manufacturing() and (object.owner is session.player):
                did_a_manufacture |= self.do_ping_manufacturing(session, retmsg, base, object)

            if did_finish_construction or did_an_upgrade:
                # handle any updates to stattab
                if object.is_building() and object.affects_player_stattab():
                    object.owner.recalc_stattab(session.player, session.viewing_base)
                    if object.owner is session.player:
                        object.owner.stattab.send_update(session, retmsg)

            # if the action had any possible impact on power generation, then re-initialize harvesters
            if did_a_repair or did_finish_construction or did_an_upgrade:

                # defer for efficiency
                #session.power_changed(base, object, retmsg)
                session.deferred_power_change = True

                session.deferred_ladder_point_decay_check = True

            if did_finish_construction or did_an_upgrade:
                if object.spec.provides_inventory:
                    session.player.send_inventory_update(retmsg)

                if object.spec.name in (gamedata['townhall'],gamedata['region_map_building'],gamedata.get('squad_building','')):
                    # these buildings can enable regional map features, place player on map if not already there
                    session.player.update_map_placement(session, retmsg)

                if object.spec.name in (gamedata['townhall'], gamedata['inventory_building']):
                    # check if this triggered the inventory intro mail
                    session.player.send_inventory_intro_mail(session, retmsg)

                if object.spec.name == gamedata['townhall']:
                    # may have triggered adnetwork events
                    session.send_adnetwork_events(retmsg)

                    # keep map in sync
                    if session.player.home_region:
                        session.player.my_home.send_map_feature_update(reason='townhall_upgrade')

                    if gamedata['player_xp'].get('recalculate_on_townhall_upgrade'):
                        session.player.recalculate_player_level(session)

                # award XP for construction/upgrade
                if object.spec.name in gamedata['player_xp']['buildings']:
                    override = object.spec.get_leveled_quantity(object.spec.upgrade_xp, object.level)
                    if override >= 0:
                        xp += override
                    else:
                        amount = sum((GameObjectSpec.get_leveled_quantity(getattr(object.spec, 'build_cost_'+res), object.level) for res in gamedata['resources']),0)
                        if object.level == 1 and 'level_1' in gamedata['player_xp']['buildings']:
                            coeff = gamedata['player_xp']['buildings']['level_1']
                        else:
                            coeff = gamedata['player_xp']['buildings'].get(object.spec.name, 0)
                        xp += int(coeff*amount)
                    xp_why.append('building')

            if did_a_repair or did_finish_construction or did_an_upgrade or did_a_research or did_a_manufacture:
                self.give_xp_to(session, object.owner, retmsg, xp, ','.join(xp_why), [object.x,object.y], obj_session_id = object.obj_id)
                session.deferred_player_state_update = True
                base.nosql_write_one(object, 'do_ping_object')
            elif force_write:
                base.nosql_write_one(object, 'do_ping_object')

            if did_a_remove:
                # postpone actual removal since other code in this
                # call chain might rely on the object being in the session
                session.deferred_object_removals.add(object)
            else:
                session.deferred_object_state_updates.add(object)

    def do_speedup_for_free(self, session, retmsg, object):
        assert object.is_building()
        if session.viewing_base is not session.player.my_home:
            if session.viewing_base.is_nosql_base() and object.spec.quarry_upgradable and session.viewing_base.base_landlord_id == session.player.user_id:
                pass # OK to access remotely
            else:
                retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                return

        # max amount of time for which we allow free speed-ups
        free_time = Store.get_free_speedup_time(session, session.player)

        # just set the finish time to a time in the past, then
        # let ping_object handle the rest of the work

        if object.is_repairing():
            time_left = object.repair_finish_time - server_time
            if time_left <= free_time:
                object.repair_finish_time = server_time - 1
        elif object.is_upgrading():
            prog = object.upgrade_done_time
            if object.upgrade_start_time < 0:
                return
            else:
                prog += server_time - object.upgrade_start_time
            time_left = object.upgrade_total_time - prog
            if time_left <= free_time:
                object.upgrade_done_time = object.upgrade_total_time
        elif object.is_under_construction():
            prog = object.build_done_time
            if object.build_start_time < 0:
                return
            else:
                prog += server_time - object.build_start_time
            time_left = object.build_total_time - prog
            if time_left <= free_time:
                object.build_done_time = object.build_total_time
        elif object.is_researching():
            prog = object.research_done_time
            if object.research_start_time < 0:
                return
            else:
                prog += server_time - object.research_start_time
            time_left = object.research_total_time - prog
            if time_left <= free_time:
                object.research_done_time = object.research_total_time
        elif object.is_crafting():
            finish_time = object.crafting.finish_time()
            if finish_time < 0:
                return
            if (finish_time - server_time) <= free_time:
                object.crafting.speedup()
        elif object.is_enhancing():
            finish_time = object.enhancing.finish_time()
            if finish_time < 0:
                return
            if (finish_time - server_time) <= free_time:
                object.enhancing.speedup()
        elif object.is_removing():
            finish_time = object.removing.finish_time()
            if finish_time < 0:
                return
            if (finish_time - server_time) <= free_time:
                object.removing.speedup()
        elif object.is_manufacturing():
            # note: this only speeds up if ALL queued units fit in free_time
            # and there is no unit queued which has the no_free_speedup flag
            allow_free_speedup = True
            always_free_speedup = True
            for item in object.manuf_queue:
                item_spec = session.player.get_abtest_spec(GameObjectSpec, item['spec_name'])
                if item_spec.get_leveled_quantity(item_spec.always_free_speedup, item['level']):
                    continue
                else:
                    always_free_speedup = False

                if item_spec.get_leveled_quantity(item_spec.no_free_speedup, item['level']):
                    allow_free_speedup = False

            if always_free_speedup:
                free_time = 999999999
            elif not allow_free_speedup:
                free_time = 0

            prog = object.manuf_done_time
            if object.manuf_start_time < 0:
                return
            else:
                prog += server_time - object.manuf_start_time
            time_left = sum([item['total_time'] for item in object.manuf_queue]) - prog
            if time_left <= free_time:
                object.manuf_done_time = sum([item['total_time'] for item in object.manuf_queue])

        self.do_ping_object(session, retmsg, object, session.viewing_base, force_write = True)

    def do_cancel_upgrade(self, session, retmsg, object):
        if not object.is_upgrading():
            return # ignore invalid request

        if session.viewing_base is not session.player.my_home:
            if session.viewing_base.is_nosql_base() and object.spec.quarry_upgradable and session.viewing_base.base_landlord_id == session.player.user_id:
                pass # OK to access remotely
            else:
                retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                return

        # figure out how many resources to return to player
        refund = dict((res,int(gamedata['upgrade_cancel_refund']*GameObjectSpec.get_leveled_quantity(getattr(object.spec, 'build_cost_'+res), object.level+1))) for res in gamedata['resources'])
        ingr_list = object.upgrade_ingredients

        object.cancel_upgrade()

        refund = session.player.resources.gain_res(refund, reason='canceled_upgrade')
        admin_stats.econ_flow_player(session.player, 'investment', 'buildings', refund, spec = object.spec.name, level = object.level+1)

        if ingr_list:
            session.player.loot_buffer += ingr_list
            for item in ingr_list:
                session.player.inventory_log_event('5125_item_obtained', item['spec'], item.get('stack',1), item.get('expire_time',-1), level = item.get('level',None), reason='refund')
            session.player.send_inventory_update(retmsg)
            retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, True])

        power_factor = session.power_changed(session.viewing_base, object, retmsg)

        if object.is_producer(): # re-start harvester
            object.update_production(object.owner, session.viewing_base.base_type, session.viewing_base.base_region, power_factor)

        session.viewing_base.nosql_write_one(object, 'do_cancel_upgrade')
        retmsg.append(["OBJECT_STATE_UPDATE", object.serialize_state(), session.player.resources.calc_snapshot().serialize()])

    def do_upgrade(self, session, retmsg, object):
        if object.is_damaged() or object.is_busy():
            return # ignore invalid request

        if session.home_base:
            if session.player.foreman_is_busy() and (GameObjectSpec.get_leveled_quantity(object.spec.build_time, object.level + 1) > 0 or not gamedata.get('foreman_ignore_zero_time_building', False)):
                retmsg.append(["ERROR", "FOREMAN_IS_BUSY"])
                return
        else:
            # quarries
            if any(o.is_building() and o.is_using_foreman() for o in \
                   session.viewing_base.iter_objects()):
                retmsg.append(["ERROR", "FOREMAN_IS_BUSY"])
                return

        max_level = object.spec.maxlevel
        if object.spec.max_ui_level and (not session.player.is_cheater):
            max_level = min(max_level, Predicates.eval_cond_or_literal(object.spec.max_ui_level, session, session.player))

        if object.level >= max_level:
            retmsg.append(["ERROR", "MAX_LEVEL_REACHED", max_level])
            return

        if session.viewing_base is not session.player.my_home:
            if session.viewing_base.is_nosql_base() and object.spec.quarry_upgradable and session.viewing_base.base_landlord_id == session.player.user_id:
                pass # OK to access remotely
            else:
                retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                return

        fail = False

        # check if requirements are satisfied
        if object.spec.requires:
            req = GameObjectSpec.get_leveled_quantity(object.spec.requires, object.level+1)
            if (not session.player.is_cheater) and (not req.is_satisfied2(session, session.player, None)):
                fail = True
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED",
                               gamedata['buildings'][object.spec.name]['requires']])

        # enforce cost constraint
        cost = {}
        for res in gamedata['resources']:
            cost[res] = GameObjectSpec.get_leveled_quantity(getattr(object.spec, 'build_cost_'+res), object.level+1)
            if cost[res] < 0:
                # object CANNOT be upgraded for resources, it must be done via instant purchase
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED"])
                return

            if getattr(session.player.resources, res) < cost[res]:
                fail = True
                retmsg.append(["ERROR", "INSUFFICIENT_"+res.upper(), cost[res]])
        if fail:
            return

        # check for ingredient items
        if object.spec.upgrade_ingredients:
            # have to pre-sum by specname in case there are multiple entries in the array with the same specname
            by_specname_and_level = {}
            ingr_list = object.spec.get_upgrade_ingredients_list(object.level+1)
            for entry in ingr_list:
                key = (entry['spec'], entry.get('level',None))
                by_specname_and_level[key] = by_specname_and_level.get(key,0) + entry.get('stack',1)
            for specname_level, qty in by_specname_and_level.iteritems():
                specname, level = specname_level
                if session.player.inventory_item_quantity(specname, level = level) < qty:
                    retmsg.append(["ERROR", "CRAFT_INGREDIENT_MISSING", {'spec':specname, 'level':level}, qty])
                    fail = True
                    break
        if fail:
            return

        negative_cost = dict((res,-cost[res]) for res in cost)
        session.player.resources.gain_res(negative_cost, reason='building_upgrade')
        admin_stats.econ_flow_player(session.player, 'investment', 'buildings', negative_cost, spec = object.spec.name, level = object.level+1)

        if object.spec.upgrade_ingredients:
            ingr_list = object.spec.get_upgrade_ingredients_list(object.level+1)
            for entry in ingr_list:
                session.player.inventory_remove_by_type(entry['spec'], entry.get('stack',1), '5130_item_activated', level = entry.get('level',None), reason='upgrade_building')
            session.player.send_inventory_update(retmsg)
            object.upgrade_ingredients = copy.deepcopy(ingr_list) # pass ownership

        # stop production
        if object.is_producer():
            object.halt_production(session.player)

        build_time = GameObjectSpec.get_leveled_quantity(object.spec.build_time, object.level+1)
        if build_time > 0:
            build_time = int(build_time / session.player.stattab.get_player_stat('foreman_speed'))

        object.upgrade_start_time = server_time
        if build_time >= 1:
            object.upgrade_total_time = build_time
            object.upgrade_done_time = 0
        else:
            object.upgrade_total_time = 1
            object.upgrade_done_time = 999
        object.upgrade_help = UpgradeHelp.UpgradeHelp()

        # re-evaluate power situation
        session.power_changed(session.viewing_base, object, retmsg)

        retmsg.append(["OBJECT_STATE_UPDATE", object.serialize_state(), session.player.resources.calc_snapshot().serialize()])
        session.viewing_base.nosql_write_one(object, 'do_upgrade')

        if build_time < 1:
            self.ping_object(session, retmsg, object.obj_id, session.viewing_base)
        else:
            if (session.viewing_base is session.player.my_home) and object.spec.track_level_in_player_history:
                session.setmax_player_metric(object.spec.name+'_level_started', object.level+1, time_series = False) # bucket = bool(object.spec.worth_less_xp))

        session.activity_classifier.built_or_upgraded_building()

    def do_upgrade_instant(self, session, retmsg, object, ignore_requires = False):
        if object.owner is not session.player:
            retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
            return False
        if session.viewing_base is not session.player.my_home:
            if session.viewing_base.is_nosql_base() and object.spec.quarry_upgradable and session.viewing_base.base_landlord_id == session.player.user_id:
                pass # OK to access remotely
            else:
                retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                return
        if object.is_damaged() or object.is_repairing():
            retmsg.append(["ERROR", "CANNOT_UPGRADE_BUILDING_WHILE_DAMAGED"])
            return False
        if object.is_busy() and (not object.is_upgrading()):
            retmsg.append(["ERROR", "CANNOT_UPGRADE_BUILDING_WHILE_BUSY"])
            return False
        if object.level >= object.spec.maxlevel:
            retmsg.append(["ERROR", "MAX_LEVEL_REACHED", object.spec.maxlevel])
            return False
        # check if requirements are satisfied
        if (not ignore_requires) and object.spec.requires and (not session.player.is_cheater):
            req = GameObjectSpec.get_leveled_quantity(object.spec.requires, object.level+1)
            if (not session.player.is_cheater) and (not req.is_satisfied2(session, session.player, None)):
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED",
                               gamedata['buildings'][object.spec.name]['requires']])
                return False

        if object.is_producer():
            object.halt_production(session.player)

        object.upgrade_total_time = -1
        object.upgrade_start_time = -1
        object.upgrade_done_time = -1
        object.upgrade_ingredients = None
        object.upgrade_help = None

        object.change_level(object.level+1)

        session.power_changed(session.viewing_base, object, retmsg)

        if object.spec.provides_inventory:
            session.player.send_inventory_update(retmsg)

        if object.affects_player_stattab():
            session.deferred_stattab_update = True

        if object.is_producer():
            object.update_production(session.player, session.player.my_home.base_type, session.player.my_home.base_region, compute_power_factor(session.player.my_home.get_power_state()))

        retmsg.append(["OBJECT_STATE_UPDATE2", object.serialize_state()])
        session.viewing_base.nosql_write_one(object, 'do_upgrade_instant')

        if object.spec.name in gamedata['player_xp']['buildings']:
            override = object.spec.get_leveled_quantity(object.spec.upgrade_xp, object.level)
            if override >= 0:
                xp_amount = override
            else:
                xp_amount = int(gamedata['player_xp']['buildings'].get(object.spec.name, 0) * \
                                sum((GameObjectSpec.get_leveled_quantity(getattr(object.spec, 'build_cost_'+res), object.level) for res in gamedata['resources']), 0))
            if xp_amount:
                self.give_xp_to(session, session.player, retmsg, xp_amount, 'building', [object.x,object.y], obj_session_id = object.obj_id)
                retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

        if SpinConfig.game() == 'fs':
            metric_event_coded(session.user.user_id, '4030_upgrade_building', {'building_type':object.spec.name, 'level':object.level, 'method':'instant', 'base_type': session.viewing_base.base_type})

        if session.viewing_base is session.player.my_home:
            session.deferred_history_update = True
            max_level = max([p.level for p in session.player.home_base_iter() if p.spec.name == object.spec.name])
            session.setmax_player_metric('building:'+object.spec.name+':max_level', max_level, bucket = bool(object.spec.worth_less_xp))

            if object.spec.history_category:
                max_level = max([p.level for p in session.player.home_base_iter() if p.spec.history_category == object.spec.history_category])
                session.setmax_player_metric(object.spec.history_category+'_max_level', max_level, bucket = bool(object.spec.worth_less_xp))
            if object.spec.track_level_in_player_history:
                session.setmax_player_metric(object.spec.name+'_level', object.level, bucket = bool(object.spec.worth_less_xp))

        if object.spec.name in (gamedata['townhall'],gamedata['region_map_building'],gamedata.get('squad_building','')):
            # these buildings can enable regional map features, place player on map if not already there
            session.player.update_map_placement(session, retmsg)

        if object.spec.name == gamedata['townhall']:
            # check if this triggered the inventory intro mail
            session.player.send_inventory_intro_mail(session, retmsg)
            # check for new ad network events
            session.send_adnetwork_events(retmsg)

            if gamedata['player_xp'].get('recalculate_on_townhall_upgrade'):
                session.player.recalculate_player_level(session)

            # keep map in sync
            if session.player.home_region:
                session.player.my_home.send_map_feature_update(reason='townhall_upgrade')

        if object.spec.upgrade_completion:
            cons = object.get_leveled_quantity(object.spec.upgrade_completion)
            if cons:
                session.execute_consequent_safe(cons, session.player, retmsg, reason='building:upgrade_completion(%d)' % object.level)

        session.user.create_fb_open_graph_action_building_upgrade(object)
        session.activity_classifier.built_or_upgraded_building()
        return True

    def do_research(self, session, retmsg, object, spellargs):
        tech_name = spellargs[0]

        if object.is_damaged() or object.is_busy():
            retmsg.append(["ERROR", "LAB_IS_BUSY", object.obj_id])
            return

        spec = session.player.get_abtest_spec(TechSpec, tech_name)

        # get current tech level
        if session.player.tech.has_key(tech_name):
            current = session.player.tech[tech_name]
        else:
            current = 0

        max_level = spec.maxlevel
        if spec.max_ui_level and (not session.player.is_cheater):
            max_level = min(max_level, Predicates.eval_cond_or_literal(spec.max_ui_level, session, session.player))

        if current >= max_level:
            retmsg.append(["ERROR", "MAX_LEVEL_REACHED", max_level])
            return

        if spec.developer_only and (spin_secure_mode or (not session.player.is_developer())):
            retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
            return

        if spec.research_category not in object.spec.get_research_categories(session.player):
            retmsg.append(["ERROR", "OBJECT_IS_NOT_CAPABLE"])
            return

        fail = False

        # check if requirements are satisfied
        for reqname, reqlist in (('show_if', spec.show_if), ('activation', spec.activation), ('requires', spec.requires)):
            if reqlist:
                req = TechSpec.get_leveled_quantity(reqlist, current+1)
                if (not session.player.is_cheater) and (not req.is_satisfied2(session, session.player, None)):
                    fail = True
                    retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED",
                                   TechSpec.get_leveled_quantity(gamedata['tech'][tech_name][reqname], current+1)])
                    break

        cost = {}
        for res in gamedata['resources']:
            cost[res] = TechSpec.get_leveled_quantity(getattr(spec, 'cost_'+res), current+1)
            if (not session.player.is_cheater) and (getattr(session.player.resources, res) < cost[res]):
                fail = True
                retmsg.append(["ERROR", "INSUFFICIENT_"+res.upper(), cost[res]])

        # check for ingredient items
        if spec.research_ingredients:
            # have to pre-sum by specname in case there are multiple entries in the array with the same specname
            by_specname_and_level = {}
            ingr_list = spec.get_research_ingredients_list(current+1)
            for entry in ingr_list:
                key = (entry['spec'], entry.get('level',None))
                by_specname_and_level[key] = by_specname_and_level.get(key,0) + entry.get('stack',1)
            for specname_level, qty in by_specname_and_level.iteritems():
                specname, level = specname_level
                if session.player.inventory_item_quantity(specname, level = level) < qty:
                    retmsg.append(["ERROR", "CRAFT_INGREDIENT_MISSING", {'spec':specname, 'level':level}, qty])
                    fail = True
                    break

        if fail:
            return

        # start the research
        negative_cost = dict((res,-cost[res]) for res in cost)
        session.player.resources.gain_res(negative_cost, reason='tech_research')
        admin_stats.econ_flow_player(session.player, 'investment', 'research', negative_cost, spec = tech_name, level = current+1)

        # subtract ingredients
        if spec.research_ingredients:
            ingr_list = spec.get_research_ingredients_list(current+1)
            for entry in ingr_list:
                session.player.inventory_remove_by_type(entry['spec'], entry.get('stack',1), '5130_item_activated', level = entry.get('level',None), reason='research_tech')
            session.player.send_inventory_update(retmsg)
        else:
            ingr_list = None

        object.research_item = tech_name
        object.research_total_time = int(TechSpec.get_leveled_quantity(spec.research_time, current+1)/object.get_stat('research_speed', 1))
        object.research_start_time = server_time
        object.research_done_time = 0
        object.research_ingredients = copy.deepcopy(ingr_list)

        retmsg.append(["OBJECT_STATE_UPDATE", object.serialize_state(), session.player.resources.calc_snapshot().serialize()])

        session.activity_classifier.researched_tech()

    def do_cancel_research(self, session, retmsg, object):
        if not object.is_researching():
            return # ignore invalid request

        tech_name = object.research_item
        spec = session.player.get_abtest_spec(TechSpec, tech_name)

        if session.player.tech.has_key(tech_name):
            current = session.player.tech[tech_name]
        else:
            current = 0

        level_under_research = min(current + 1, spec.maxlevel)

        # figure out how many resources to return to player
        refund = dict((res, int(gamedata['research_cancel_refund']*TechSpec.get_leveled_quantity(getattr(spec, 'cost_'+res),level_under_research))) for res in gamedata['resources'])
        ingr_list = object.research_ingredients

        object.research_item = ''
        object.research_total_time = -1
        object.research_start_time = -1
        object.research_done_time = -1
        object.research_ingredients = None

        refund = session.player.resources.gain_res(refund, reason='canceled_research')
        admin_stats.econ_flow_player(session.player, 'investment', 'research', refund, spec = tech_name, level = current+1)
        if ingr_list:
            session.player.loot_buffer += ingr_list
            for item in ingr_list:
                session.player.inventory_log_event('5125_item_obtained', item['spec'], item.get('stack',1), item.get('expire_time',-1), level = item.get('level',None), reason='refund')
            session.player.send_inventory_update(retmsg)
            retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, True])

        retmsg.append(["OBJECT_STATE_UPDATE", object.serialize_state(), session.player.resources.calc_snapshot().serialize()])


    def do_enhance(self, session, retmsg, object, spellargs):
        enh_name = spellargs[0]
        enh_level = spellargs[1]

        if object.is_damaged() or object.is_busy():
            retmsg.append(["ERROR", "LAB_IS_BUSY", object.obj_id])
            return

        if session.home_base:
            if session.player.foreman_is_busy():
                retmsg.append(["ERROR", "FOREMAN_IS_BUSY"])
                return
        else:
            # quarries
            if any(o.is_building() and o.is_using_foreman() for o in \
                   session.viewing_base.iter_objects()):
                retmsg.append(["ERROR", "FOREMAN_IS_BUSY"])
                return

        spec = session.player.get_abtest_spec(EnhancementSpec, enh_name)

        # get current level
        if object.enhancements:
            current = object.enhancements.get(enh_name, 0)
        else:
            current = 0

        if enh_level != current+1: # wrong level requested
            retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
            return

        if current >= spec.maxlevel:
            retmsg.append(["ERROR", "MAX_LEVEL_REACHED", spec.maxlevel])
            return

        if spec.developer_only and (spin_secure_mode or (not session.player.is_developer())):
            retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
            return

        if spec.enhancement_category not in object.spec.enhancement_categories:
            retmsg.append(["ERROR", "OBJECT_IS_NOT_CAPABLE"])
            return

        if object.level < EnhancementSpec.get_leveled_quantity(spec.min_host_level, current+1):
            retmsg.append(["ERROR", "OBJECT_IS_NOT_CAPABLE"])
            return

        fail = False

        # check if requirements are satisfied
        for reqname, reqlist in (('show_if', spec.show_if), ('activation', spec.activation), ('requires', spec.requires)):
            if reqlist:
                req = EnhancementSpec.get_leveled_quantity(reqlist, current+1)
                if (not session.player.is_cheater) and (not req.is_satisfied2(session, session.player, None)):
                    fail = True
                    retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED",
                                   EnhancementSpec.get_leveled_quantity(gamedata['enhancements'][enh_name][reqname], current+1)])
                    break

        cost = {}
        for res in gamedata['resources']:
            cost[res] = EnhancementSpec.get_leveled_quantity(getattr(spec, 'cost_'+res), current+1)
            if (not session.player.is_cheater) and (getattr(session.player.resources, res) < cost[res]):
                fail = True
                retmsg.append(["ERROR", "INSUFFICIENT_"+res.upper(), cost[res]])

        # check for ingredient items
        if spec.ingredients:
            # have to pre-sum by specname in case there are multiple entries in the array with the same specname
            by_specname_and_level = {}
            ingr_list = spec.get_ingredients_list(current+1)
            for entry in ingr_list:
                key = (entry['spec'], entry.get('level',None))
                by_specname_and_level[key] = by_specname_and_level.get(key,0) + entry.get('stack',1)
            for specname_level, qty in by_specname_and_level.iteritems():
                specname, level = specname_level
                if session.player.inventory_item_quantity(specname, level = level) < qty:
                    retmsg.append(["ERROR", "CRAFT_INGREDIENT_MISSING", {'spec':specname, 'level':level}, qty])
                    fail = True
                    break

        if fail:
            return

        # start the enhancement
        negative_cost = dict((res,-cost[res]) for res in cost)
        session.player.resources.gain_res(negative_cost, reason='building_enhancement')
        admin_stats.econ_flow_player(session.player, 'investment', 'enhancement', negative_cost, spec = enh_name, level = current+1)

        # subtract ingredients
        if spec.ingredients:
            ingr_list = spec.get_ingredients_list(current+1)
            for entry in ingr_list:
                session.player.inventory_remove_by_type(entry['spec'], entry.get('stack',1), '5130_item_activated', level = entry.get('level',None), reason='enhance_building')
            session.player.send_inventory_update(retmsg)
        else:
            ingr_list = None

        enhance_time = int(EnhancementSpec.get_leveled_quantity(spec.enhance_time, current+1) /
                           object.get_stat('enhance_speed', 1))
        state = {'spec': enh_name, 'level': enh_level, 'cost': cost}
        if ingr_list:
            state['ingredients'] = copy.deepcopy(ingr_list)
        object.enhancing = Business.EnhanceBusiness(state, init_total_time = enhance_time, init_start_time = server_time)
        session.viewing_base.nosql_write_one(object, 'do_enhance', fields = ['enhancing'])

        session.deferred_object_state_updates.add(object)
        session.deferred_player_state_update = True

        session.activity_classifier.built_or_upgraded_building()

    def do_cancel_enhance(self, session, retmsg, object):
        if not object.is_enhancing():
            return # ignore invalid request

        enh_state = object.enhancing.enhance_state
        enh_level = enh_state['level']
        enh_spec = session.player.get_abtest_spec(EnhancementSpec, enh_state['spec'])

        # figure out how many resources to return to player
        refund = dict((res, int(gamedata['upgrade_cancel_refund']*enh_state['cost'].get(res,0))) \
                      for res in gamedata['resources'])
        if enh_spec.refund_ingredients:
            ingr_list = enh_state.get('ingredients', None)
        else:
            ingr_list = None

        object.cancel_enhancing()
        session.viewing_base.nosql_write_one(object, 'cancel_enhance', fields = ['enhancing'])

        refund = session.player.resources.gain_res(refund, reason='canceled_enhancement')
        admin_stats.econ_flow_player(session.player, 'investment', 'enhancement', refund, spec = enh_state['spec'], level = enh_level)
        if ingr_list:
            session.player.loot_buffer += ingr_list
            for item in ingr_list:
                session.player.inventory_log_event('5125_item_obtained', item['spec'], item.get('stack',1), item.get('expire_time',-1), level = item.get('level',None), reason='refund')
            session.player.send_inventory_update(retmsg)
            retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, True])

        session.deferred_object_state_updates.add(object)
        session.deferred_player_state_update = True

    # parse the dictionary of arguments sent by the client for starting a craft operation
    class CraftSpellarg(object):
        def __init__(self, spellarg):
            self.recipe_name = spellarg['recipe']
            self.recipe_level = spellarg.get('level', 1)
            self.delivery_address = spellarg.get('delivery', None)
            self.do_replace = self.delivery_address and self.delivery_address.get('replace', False)
            self.ui_tag = spellarg.get('ui_tag', None)
            self.ui_index = spellarg.get('ui_index',None)
            if self.ui_tag: # sanity-check against DoS
                assert type(self.ui_tag) in (str, unicode)
                assert len(self.ui_tag) < 128

    def can_craft(self, session, player, object, arg, retmsg = None,
                  take_resources = True, take_ingredients = True, check_predicates = True):

        recipe = gamedata['crafting']['recipes'].get(arg.recipe_name, None)
        cat_in_spec = (recipe['crafting_category'] in object.spec.crafting_categories)
        spec_is_leveled = False
        for level in object.spec.crafting_categories:
            if isinstance(level, list):
                spec_is_leveled = True
        if spec_is_leveled:
            cat_in_spec = (recipe['crafting_category'] in GameObjectSpec.get_leveled_quantity(object.spec.crafting_categories, object.level))


        # check recipe sanity
        if (not recipe) or (not object.is_crafter()) or (not cat_in_spec) or \
           (recipe['crafting_category'] not in gamedata['crafting']['categories']):
            if retmsg is not None: retmsg.append(["ERROR", "OBJECT_IS_NOT_CAPABLE"])
            return False

        catdata = gamedata['crafting']['categories'][recipe['crafting_category']]

        # check delivery options
        delivery = recipe.get('delivery', catdata.get('delivery', None))
        if delivery == 'building_slot':
            # check that target building exists, is in player's home base
            if (not arg.delivery_address) or \
               ('obj_id' not in arg.delivery_address) or ('slot_type' not in arg.delivery_address) or \
               (arg.delivery_address['slot_type'] != catdata['delivery_slot_type']) or \
               (not session.has_object(arg.delivery_address['obj_id'])):
                if retmsg is not None: retmsg.append(["ERROR", "OBJECT_IS_NOT_CAPABLE"])
                return False

            target = session.get_object(arg.delivery_address['obj_id'])

            if (target.owner is not player) or \
               (target not in player.home_base_iter() and not target.spec.quarry_upgradable):
                if retmsg is not None: retmsg.append(["ERROR", "OBJECT_IS_NOT_CAPABLE"])
                return False

            # anti-race check #1 - check existing queue for anything that's already targeting this slot
            if object.crafting:
                for entry in object.crafting.queue:
                    addr = entry.craft_state.get('delivery',None)
                    if addr and addr.get('obj_id',None) == arg.delivery_address['obj_id'] and addr.get('slot_type',None) == arg.delivery_address['slot_type'] and addr.get('slot_index',0) == arg.delivery_address.get('slot_index',0):
                        if retmsg is not None: retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
                        return False

            # anti-race check #2 - check if destination slot is already full
            dest_addr = (arg.delivery_address['slot_type'],arg.delivery_address.get('slot_index',0))
            for product in GameObjectSpec.get_crafting_recipe_product_list(recipe, arg.recipe_level):
                if 'spec' in product: # only for deterministic products
                    product_spec = gamedata['items'][product['spec']]

                    if not arg.do_replace:
                        if not Equipment.equip_add(target.equipment or {}, target.spec, target.level, dest_addr, product, product_spec, probe_only = True):
                            if retmsg is not None: retmsg.append(["ERROR", "EQUIP_INVALID"])
                            return False

                    # check unique_equipped constraint
                    if check_predicates and ('unique_equipped' in product_spec):
                        # see if we are replacing an equivalent item
                        replacing_equivalent = False
                        if arg.do_replace:
                            old_item = Equipment.equip_get(target.equipment or {}, dest_addr)
                            if old_item and old_item['spec'] in gamedata['items'] and gamedata['items'][old_item['spec']].get('unique_equipped',None) == product_spec['unique_equipped']:
                                # replacing, no need to count
                                replacing_equivalent = True

                        if not replacing_equivalent:
                            # do need to check existing items
                            for item in session.player.equipped_item_iter(session.viewing_base):
                                item_spec = gamedata['items'].get(item['spec'], None)
                                if item_spec and item_spec.get('unique_equipped',None) == product_spec['unique_equipped']:
                                    if retmsg is not None: retmsg.append(["ERROR", "EQUIP_INVALID_UNIQUE", product_spec['name']])
                                    return False

                    # check limited_equipped constraint
                    if check_predicates and ('limited_equipped' in product_spec):
                        # see if we are replacing an equivalent item
                        replacing_equivalent = False
                        if arg.do_replace:
                            old_item = Equipment.equip_get(target.equipment or {}, dest_addr)
                            if old_item and old_item['spec'] in gamedata['items'] and gamedata['items'][old_item['spec']].get('limited_equipped',None) == product_spec['limited_equipped']:
                                # replacing, no need to count
                                replacing_equivalent = True

                        if not replacing_equivalent:
                            # do need to count existing items
                            if session.player.stattab.limited_equipped.get(product_spec['limited_equipped'],0) < \
                               product.get('stack',1) + session.player.count_limited_equipped_items(product_spec['limited_equipped'], session.viewing_base):
                                if retmsg is not None: retmsg.append(["ERROR", "EQUIP_INVALID_LIMITED", product_spec['name']])
                                return False

        # check workshop business
        if object.is_damaged() or object.is_upgrading() or object.is_enhancing() or object.is_removing() or object.is_under_construction() or object.is_researching() or object.is_manufacturing():
            if retmsg is not None: retmsg.append(["ERROR", "WORKSHOP_IS_BUSY", object.obj_id])
            return False

        # check foreman availability (but not if using "Instant" which will set take_resources false)
        if take_resources and catdata.get('foreman', False) and session.player.foreman_is_busy():
            if retmsg is not None: retmsg.append(["ERROR", "FOREMAN_IS_BUSY"])
            return False

        # check predicates
        if check_predicates:
            for PRED in ('show_if', 'activation','requires'):
                if PRED in recipe:
                    req = Predicates.read_predicate(GameObjectSpec.get_leveled_quantity(recipe[PRED], arg.recipe_level))
                    if (not player.is_cheater) and (not req.is_satisfied2(session, player, None)):
                        if retmsg is not None: retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", GameObjectSpec.get_leveled_quantity(recipe[PRED], arg.recipe_level)])
                        return False

        # check resource cost
        if take_resources and ('cost' in recipe):
            for res, amount_list in GameObjectSpec.get_leveled_quantity(recipe['cost'], arg.recipe_level).iteritems():
                amount = GameObjectSpec.get_leveled_quantity(amount_list, arg.recipe_level)
                if (not player.is_cheater) and (getattr(player.resources, res) < amount):
                    if retmsg is not None: retmsg.append(["ERROR", "INSUFFICIENT_"+res.upper(), amount])
                    return False

        # check inventory slot availability
#        if gamedata['crafting_delivery_method'] == 'reserve_slot_on_start':
#            # check for space
#            slots_needed = LootTable.max_slots_needed(gamedata['loot_tables'], recipe['product'])
#            snap = player.resources.calc_snapshot()
#            if snap.max_usable_inventory() - snap.cur_inventory() < slots_needed:
#                if retmsg is not None: retmsg.append(["ERROR", "INVENTORY_LIMIT"])
#                return

        # check for ingredient items (note: no recipe_level dependence)
        if take_ingredients and ('ingredients' in recipe):
            # have to pre-sum by specname in case there are multiple entries in the array with the same specname
            by_specname_and_level = {}
            ingr_list = GameObjectSpec.get_crafting_recipe_ingredients_list(recipe, arg.recipe_level)
            for entry in ingr_list:
                key = (entry['spec'], entry.get('level',None))
                by_specname_and_level[key] = by_specname_and_level.get(key,0) + entry.get('stack',1)
            for specname_level, qty in by_specname_and_level.iteritems():
                specname, level = specname_level
                if player.inventory_item_quantity(specname, level = level) < qty:
                    if retmsg is not None: retmsg.append(["ERROR", "CRAFT_INGREDIENT_MISSING", {'spec':specname, 'level':level}, qty])
                    return False

        # check for queue usage exclusivity and collection buffer
        if object.is_crafting():
            uncollected = 0
            for bus in object.crafting.queue:

                # exclusivity constraint - cannot start this craft if a recipe belonging to a different category is in the queue
                if catdata.get('exclusive',False):
                    if gamedata['crafting']['recipes'][bus.craft_state['recipe']]['crafting_category'] != recipe['crafting_category']:
                        if retmsg is not None: retmsg.append(["ERROR", "WORKSHOP_IS_BUSY", object.obj_id])
                        return False

                # queueability constraint - if crafting is still in progress, and new recipe is not queuable, then we cannot start it
                if not bus.is_complete(server_time):
                    if not catdata.get('queueable', True):
                        if retmsg is not None: retmsg.append(["ERROR", "WORKSHOP_IS_BUSY", object.obj_id])
                        return False

                # keep track of queue length
                uncollected += 1

            # if crafting buffer space is already full, cannot start a new job
            space = object.get_leveled_quantity(object.spec.crafting_queue_space)
            if (space >= 0) and (uncollected >= space):
                if retmsg is not None: retmsg.append(["ERROR", "WORKSHOP_IS_BUSY", object.obj_id])
                return False

        return True

    def do_craft(self, session, player, retmsg, object, arg,
                 check_predicates = True, take_resources = True, take_ingredients = True, take_time = True):

        if not self.can_craft(session, player, object, arg, retmsg = retmsg,
                              check_predicates = check_predicates, take_resources = take_resources, take_ingredients = take_ingredients):
            return False

        # target object for delivery
        if arg.delivery_address and ('obj_id' in arg.delivery_address) and session.has_object(arg.delivery_address['obj_id']):
            target = session.get_object(arg.delivery_address['obj_id'])
        else:
            target = None

        recipe = gamedata['crafting']['recipes'][arg.recipe_name]
        catdata = gamedata['crafting']['categories'][recipe['crafting_category']]
        delivery = recipe.get('delivery', catdata.get('delivery', None))

        # subtract resources
        if take_resources and recipe.get('cost'):
            cost = dict((res,GameObjectSpec.get_leveled_quantity(amount, arg.recipe_level)) for res, amount in GameObjectSpec.get_leveled_quantity(recipe['cost'], arg.recipe_level).iteritems())
            negative_cost = dict((res,-cost[res]) for res in cost)
            player.resources.gain_res(negative_cost, reason='crafting')
            admin_stats.econ_flow_player(player, recipe.get('econ_category',catdata.get('econ_category','crafting')), recipe.get('econ_subcategory',catdata.get('econ_subcategory','crafting')), negative_cost)
        else:
            cost = {}

        # subtract ingredients (note: no recipe_level dependence)
        if take_ingredients and ('ingredients' in recipe):
            ingr_list = GameObjectSpec.get_crafting_recipe_ingredients_list(recipe, arg.recipe_level)
            for entry in ingr_list:
                player.inventory_remove_by_type(entry['spec'], entry.get('stack',1), '5130_item_activated', level = entry.get('level',None), reason='crafting')
            if player is session.player:
                session.player.send_inventory_update(retmsg)

        if take_time:
            # reduce craft time by structure speed bonus
            speed = object.get_stat('crafting_speed', object.get_leveled_quantity(object.spec.crafting_speed))
            craft_time = max(1, int(GameObjectSpec.get_leveled_quantity(recipe['craft_time'], arg.recipe_level) / speed))
        else:
            craft_time = -1

        # start crafting
        if not object.crafting:
            object.crafting = Business.QueuedBusiness(Business.CraftingBusiness)

        state = {'recipe':recipe['name'], 'cost':cost, 'attempt_id': generate_mail_id()}
        if arg.recipe_level: state['level'] = arg.recipe_level
        if take_ingredients and ('ingredients' in recipe): state['ingredients'] = copy.deepcopy(ingr_list)
        if arg.delivery_address: state['delivery'] = arg.delivery_address
        if arg.ui_tag: state['ui_tag'] = arg.ui_tag
        delay = 0
        for entry in object.crafting.queue:
            d = entry.total_time - entry.done_time
            if entry.start_time > 0:
                d -= min(max(server_time - entry.start_time, 0), entry.total_time)
            delay += d
        object.crafting.queue.append(Business.CraftingBusiness(state, init_total_time = craft_time, init_start_time = server_time + max(0, delay)))

        session.viewing_base.nosql_write_one(object, 'do_craft', fields = ['crafting'])

        if recipe['crafting_category'] == 'fishing':
            player.fishing_log_event('5150_fish_start', object.crafting.queue[0], ui_index = arg.ui_index, time_left = craft_time)

        # destroy currently-equipped item in target slot
        if arg.do_replace and delivery == 'building_slot' and target.equipment and \
           Equipment.equip_has(target.equipment, (arg.delivery_address['slot_type'],arg.delivery_address.get('slot_index',0))):
            removed = Equipment.equip_remove(target.equipment, (arg.delivery_address['slot_type'],arg.delivery_address.get('slot_index',0)))
            if len(target.equipment) < 1:
                target.equipment = None
            assert removed
            session.viewing_base.nosql_write_one(target, 'do_craft', fields = ['equipment'])

            if session.home_base:
                player.inventory_log_event('5131_item_trashed', removed['spec'], -removed.get('stack',1), removed.get('expire_time',-1), level=removed.get('level',None), reason='replaced')

            if target is not object:
                retmsg.append(["OBJECT_STATE_UPDATE2", target.serialize_state()])

            session.deferred_stattab_update = True

        if 'on_start' in recipe:
            session.execute_consequent_safe(GameObjectSpec.get_leveled_quantity(recipe['on_start'], arg.recipe_level),
                                            player, retmsg, reason='crafting_recipe:%s:on_start' % recipe['name'])

        retmsg.append(["OBJECT_STATE_UPDATE2", object.serialize_state()])
        if player is session.player:
            retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

        session.power_changed(session.viewing_base, object, retmsg)
        return True

    def do_cancel_craft(self, session, retmsg, object, spellarg):
        if not object.is_crafting(): return

        # find the queue entry
        bus = None
        if 'ui_tag' in spellarg:
            for entry in object.crafting.queue:
                if entry.craft_state.get('ui_tag', None) == spellarg['ui_tag']:
                    bus = entry; break
        elif 'attempt_id' in spellarg:
            for entry in object.crafting.queue:
                if entry.craft_state.get('attempt_id', None) == spellarg['attempt_id']:
                    bus = entry; break;
        else:
            assert 'index' in spellarg
            if spellarg['index'] < len(object.crafting.queue):
                bus = object.crafting.queue[spellarg['index']]

        if (not bus) or spellarg['recipe'] != bus.craft_state['recipe']: # sanity check
            retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
            return

        recipe = gamedata['crafting']['recipes'].get(bus.craft_state['recipe'],None)
        time_left = object.crafting.finish_time() - server_time

        if recipe and (not gamedata['crafting']['categories'][recipe['crafting_category']].get('cancelable', True)):
            retmsg.append(["ERROR", "SERVER_PROTOCOL"]) # cannot be canceled
            return

        object.crafting.queue.remove(bus)
        if len(object.crafting.queue) < 1:
            object.crafting = None
        else:
            # update times on other queued items
            object.halt_crafting(True)
            object.update_crafting(-1)

        session.viewing_base.nosql_write_one(object, 'do_cancel_craft', fields = ['crafting'])

        # figure out how many resources to return to player
        if recipe:
            cost = bus.craft_state.get('cost',{})
            refund = dict((res, int(gamedata['manufacture_cancel_refund']*cost.get(res,0))) for res in gamedata['resources'])
            refund = session.player.resources.gain_res(refund, reason='canceled_crafting')
            admin_stats.econ_flow_player(session.player, recipe.get('econ_category','crafting') if recipe else 'crafting', 'crafting', refund)

            refund_ingredients = gamedata['crafting']['categories'][recipe['crafting_category']].get('refund_ingredients', False)
            if refund_ingredients:
                ingr_list = bus.craft_state.get('ingredients',[])
                if ingr_list:
                    session.player.loot_buffer += ingr_list
                    for item in ingr_list:
                        session.player.inventory_log_event('5125_item_obtained', item['spec'], item.get('stack',1), item.get('expire_time',-1), level = item.get('level',None), reason='refund')
                    #session.give_loot(session.player, retmsg, ingr_list, 'refund', reason_id = recipe['name'])
                    session.player.send_inventory_update(retmsg)
                    retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, True])

            if 'on_cancel' in recipe:
                session.execute_consequent_safe(recipe['on_cancel'], session.player, retmsg, reason='crafting_recipe:%s:on_cancel' % recipe['name'])

        retmsg.append(["OBJECT_STATE_UPDATE", object.serialize_state(), session.player.resources.calc_snapshot().serialize()])

        if recipe['crafting_category'] == 'fishing':
            session.player.fishing_log_event('5152_fish_cancel', bus, time_left = time_left)

        session.power_changed(session.viewing_base, object, retmsg)

    # collect product(s) for one crafting attempt.
    # returns [need_history_update, list_of_product_items, attempt_id for completed attempt]
    def do_collect_craft_one(self, session, retmsg, object, attempt_id):
        looted = []
        # find the queue entry
        bus = None
        if object.is_crafting() and object.crafting.queue:
            if attempt_id:
                bus_list = filter(lambda x: x.craft_state.get('attempt_id',None) == attempt_id, object.crafting.queue)
                if bus_list:
                    bus = bus_list[0]
            else:
                bus = object.crafting.queue[0]

        if (not bus) or (not bus.is_complete(server_time)): # attempt not found or not complete yet
            retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
            return False, looted, None

        object.crafting.queue.remove(bus)
        if len(object.crafting.queue) < 1:
            object.crafting = None
        session.viewing_base.nosql_write_one(object, 'do_collect_craft_one', fields = ['crafting'])

        recipe = gamedata['crafting']['recipes'].get(bus.craft_state['recipe'],None)
        if recipe:
            if bus.creation_time > 0:
                # approximate time at which results were "produced"
                # XXX this doesn't account for stoppage due to building damage - that will probably require another state variable in Business!
                ref_time = bus.creation_time + bus.total_time
            else:
                ref_time = session.player.get_absolute_time()
            prod_list = GameObjectSpec.get_crafting_recipe_product_list(recipe, bus.craft_state.get('level', 1))
            loot = session.get_loot_items(session.player, prod_list, -1, -1, duration_ref_time = ref_time)
            delivery_method = recipe.get('delivery', gamedata['crafting']['categories'][recipe['crafting_category']].get('delivery', None))

            for item in loot:
                session.increment_player_metric('item:'+item['spec']+':crafted', item.get('stack',1), time_series = False)

            if delivery_method == 'building_slot':
                assert len(loot) == 1
                item = loot[0]
                try:
                    delivery_address = bus.craft_state['delivery']
                    assert self.do_equip_building(session, retmsg, [None, delivery_address['obj_id'], (delivery_address['slot_type'],delivery_address.get('slot_index',0)), -1,
                                                                    item, # XXX do we need to copy this? copy.deepcopy(item)
                                                                    None, None],
                                                  force = True)
                    looted += loot
                    if session.home_base:
                        session.player.inventory_log_event('5125_item_obtained', item['spec'], item.get('stack',1), item.get('expire_time',-1), level = item.get('level',None), reason='crafted')
                except:
                    gamesite.exception_log.event(server_time, 'player %d crafting delivery from %s %r at base_id %r %r target not found for %r, discarding. %s' % \
                                                 (object.owner.user_id, object.spec.name, object.obj_id, session.viewing_base.base_id, bus.craft_state, item, traceback.format_exc().strip())) # OK
            else:

                # returned "looted" list does include fungible items
                looted += loot

                # "direct deposit" fungible loot
                for item in loot:
                    is_fungible = False
                    spec = gamedata['items'].get(item['spec'], None)
                    if spec and spec.get('fungible',False):
                        if spec['resource'] == 'gamebucks':
                            session.player.resources.gain_gamebucks(item.get('stack',1), reason='crafting')
                            is_fungible = True
                        elif spec['resource'] in gamedata['resources']:
                            gained_res = session.player.resources.gain_res({spec['resource']: item.get('stack',1)}, reason='crafting')
                            admin_stats.econ_flow_player(session.player, 'crafting', 'fungible', gained_res)
                            # note: overflow is thrown away!
                            is_fungible = True
                    if is_fungible:
                        pass # already given, do NOT put in loot_buffer
                    else:
                        session.player.loot_buffer += loot
                        session.player.inventory_log_event('5125_item_obtained', item['spec'], item.get('stack',1), item.get('expire_time',-1), level = item.get('level',None), reason='crafted')

            if 'completion' in recipe:
                session.execute_consequent_safe(recipe['completion'], session.player, retmsg, reason='crafting_recipe:%s:completion' % recipe['name'])

            if recipe['crafting_category'] == 'fishing':
                session.player.fishing_log_event('5153_fish_collect', bus, loot = copy.deepcopy(loot))

        return True, looted, bus.craft_state.get('attempt_id', None)

    # collect a list of crafting attempts, or all completed attempts if attempt_id_list is None
    def do_collect_craft(self, session, retmsg, object, attempt_id_list = None):
        if not object.is_crafting():
            retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
            return

        looted = []
        completed_ids = []
        need_history_update = False

        if attempt_id_list is None:
            # create a list that will collect all completed attempts
            attempt_id_list = []
            for bus in object.crafting.queue:
                if bus.is_complete(server_time):
                    # None works here for ID-less entries because do_collect_craft_one() will assume you mean the first entry in the queue
                    attempt_id_list.append(bus.craft_state.get('attempt_id', None))

        for attempt_id in attempt_id_list:
            hist, loot, id = self.do_collect_craft_one(session, retmsg, object, attempt_id)
            need_history_update |= hist
            looted += loot
            if id: completed_ids.append(id)

        #session.player.send_inventory_update(retmsg)
        if session.has_object(object.obj_id):
            retmsg.append(["CRAFT_COMPLETE", object.obj_id, looted if looted else None, completed_ids])
        if looted:
            retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, True])
        if completed_ids:
            retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

        session.power_changed(session.viewing_base, object, retmsg)

        if need_history_update and (object.owner is session.player):
            session.player.send_history_update(retmsg)

    def can_remove_obstacle(self, session, player, object, retmsg = None,
                            take_resources = True, take_ingredients = True, check_predicates = True):

        # check workshop business
        if object.is_removing() or (object.is_building() and (object.is_damaged() or object.is_upgrading() or object.is_enhancing() or object.is_under_construction() or object.is_researching() or object.is_manufacturing())):
            if retmsg is not None: retmsg.append(["ERROR", "OBSTACLE_IS_BUSY", object.obj_id])
            return False

        # check foreman availability (but not if using "Instant" which will set take_resources false)
        if take_resources and session.player.remover_is_busy():
            if retmsg is not None: retmsg.append(["ERROR", "REMOVER_IS_BUSY"])
            return False

        # check predicates
        if check_predicates and object.spec.remove_requires:
            pred = object.get_leveled_quantity(object.spec.remove_requires)
            if (not player.is_cheater) and (not Predicates.read_predicate(pred).is_satisfied2(session, player, None)):
                if retmsg is not None: retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", pred])
                return False

        # check resource cost
        if take_resources:
            for res in gamedata['resources']:
                amount = object.get_leveled_quantity(getattr(object.spec, 'remove_cost_'+res))
                if (not player.is_cheater) and (getattr(player.resources, res) < amount):
                    if retmsg is not None: retmsg.append(["ERROR", "INSUFFICIENT_"+res.upper(), amount])
                    return False

        # check for ingredient items
        if take_ingredients and object.spec.remove_ingredients:
            # have to pre-sum by specname in case there are multiple entries in the array with the same specname
            by_specname_and_level = {}
            ingr_list = object.spec.get_remove_ingredients_list(object.level)
            for entry in ingr_list:
                key = (entry['spec'], entry.get('level',None))
                by_specname_and_level[key] = by_specname_and_level.get(key,0) + entry.get('stack',1)
            for specname_level, qty in by_specname_and_level.iteritems():
                specname, level = specname_level
                if player.inventory_item_quantity(specname, level = level) < qty:
                    if retmsg is not None: retmsg.append(["ERROR", "CRAFT_INGREDIENT_MISSING", {'spec':specname, 'level':level}, qty])
                    return False

        return True

    def do_remove_obstacle(self, session, player, retmsg, object,
                           check_predicates = True, take_resources = True, take_ingredients = True, take_time = True):

        if not self.can_remove_obstacle(session, player, object, retmsg = retmsg,
                                        check_predicates = check_predicates, take_resources = take_resources, take_ingredients = take_ingredients):
            return

        # subtract resources
        if take_resources:
            cost = dict((res, object.get_leveled_quantity(getattr(object.spec, 'remove_cost_'+res))) for res in gamedata['resources'] \
                        if object.get_leveled_quantity(getattr(object.spec, 'remove_cost_'+res)) > 0)
            negative_cost = dict((res,-cost[res]) for res in cost)
            player.resources.gain_res(negative_cost, reason='crafting')
            admin_stats.econ_flow_player(player, 'investment', 'obstacle_removal', negative_cost)
        else:
            cost = {}

        # subtract ingredients
        if take_ingredients and object.spec.remove_ingredients:
            ingr_list = object.spec.get_remove_ingredients_list(object.level)
            for entry in ingr_list:
                player.inventory_remove_by_type(entry['spec'], entry.get('stack',1), '5130_item_activated', level = entry.get('level',None), reason='remove_obstacle')
            if player is session.player:
                session.player.send_inventory_update(retmsg)

        if take_time:
            remove_time = object.get_leveled_quantity(object.spec.remove_time)
        else:
            remove_time = -1

        # start removing
        state = {'cost':cost}
        if take_ingredients and object.spec.remove_ingredients:
            state['ingredients'] = copy.deepcopy(ingr_list)

        object.removing = Business.RemoveBusiness(state, init_total_time = remove_time, init_start_time = server_time)

        session.deferred_object_state_updates.add(object)
        session.deferred_player_state_update = True
        return True

    def do_create_inert(self, session, retmsg, inert_type, coords, metadata):
        # XXX to make inerts work in remote bases, need to prune them
        if session.viewing_base is not session.viewing_player.my_home: return

        base = session.viewing_base
        j, i = coords

        spec = GameObjectSpec.lookup(inert_type)
        assert spec.kind == 'inert'
        assert spec.client_can_create
        if metadata is not None:
            assert type(metadata) == dict

        if not session.has_attacked:
            if gamedata['server'].get('log_combat_race_conditions', False):
                gamesite.exception_log.event(server_time, 'player %d at %s: race condition in do_create_inert()' % (session.player.user_id,
                                                                                                                    session.viewing_base.base_id))
            return

        # limit # of client-creatable inert objects in base
        oldest = None
        current = 0
        for obj in base.iter_objects():
            if obj.is_inert() and obj.spec.client_can_create:
                current += 1
                if not oldest:
                    oldest = obj

        # remove oldest inert object
        if current >= gamedata['inert_limit'] and oldest:
            if session.has_object(oldest):
                retmsg.append(["OBJECT_REMOVED2", oldest.obj_id])
                session.rem_object(oldest)
            base.drop_object(oldest)

        newobj = instantiate_object_for_player(session.player, EnvironmentOwner, inert_type, x=j, y=i, metadata = metadata)

        base.adopt_object(newobj)
        session.add_object(newobj)

        retmsg.append(["OBJECT_CREATED2", newobj.serialize_state()])


    def do_build(self, session, retmsg, spellargs, is_instant):
        building_type = spellargs[0]
        j, i = spellargs[1]
        spec = session.player.get_abtest_spec(GameObjectSpec, building_type)

        if (not is_instant) and (GameObjectSpec.get_leveled_quantity(spec.build_time, 1) > 0 or not gamedata.get('foreman_ignore_zero_time_building', False)) and session.player.foreman_is_busy():
            retmsg.append(["ERROR", "FOREMAN_IS_BUSY"])
            return

        if spec.kind == 'inert':
            if (not session.player.is_cheater):
                retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                return
            is_instant = True # all inert builds are instant
        else:
            assert spec.kind == 'building'

        if (spec.developer_only and (spin_secure_mode or (not session.player.is_developer()))) or \
           (spec.quarry_only and session.viewing_base.base_type != 'quarry'):
            retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
            return

        if session.viewing_base is not session.player.my_home:
            if session.viewing_base.is_nosql_base() and spec.quarry_buildable and session.viewing_base.base_landlord_id == session.player.user_id:
                pass # OK to build remotely
            else:
                retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                return

        if not session.viewing_base.is_building_location_valid([j,i], spec, None, ignore_collision = session.player.is_cheater,
                                                               ignore_perimeter = spec.ignore_perimeter or session.player.is_cheater):
            retmsg.append(["ERROR", "INVALID_BUILDING_LOCATION"])
            return

        fail = False

        # check if requirements are satisfied
        for reqname, reqlist in (('show_if', spec.show_if), ('requires', spec.requires)):
            if reqlist:
                req = GameObjectSpec.get_leveled_quantity(reqlist, 1)
                if (not session.player.is_cheater) and (not req.is_satisfied2(session, session.player, None)):
                    fail = True
                    retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED",
                                   gamedata['buildings'][building_type][reqname]])
                    break

        cost = {}
        for res in gamedata['resources']:
            cost[res] = GameObjectSpec.get_leveled_quantity(getattr(spec, 'build_cost_'+res), 1)
            if (not is_instant) and (not session.player.is_cheater) and (getattr(session.player.resources,res) < cost[res]):
                fail = True
                retmsg.append(["ERROR", "INSUFFICIENT_"+res.upper(), cost[res]])

        # check for ingredient items
        if spec.upgrade_ingredients:
            # have to pre-sum by specname in case there are multiple entries in the array with the same specname
            by_specname_and_level = {}
            ingr_list = spec.get_upgrade_ingredients_list(1)
            for entry in ingr_list:
                key = (entry['spec'], entry.get('level',None))
                by_specname_and_level[key] = by_specname_and_level.get(key,0) + entry.get('stack',1)
            for specname_level, qty in by_specname_and_level.iteritems():
                specname, level = specname_level
                if session.player.inventory_item_quantity(specname, level = level) < qty:
                    retmsg.append(["ERROR", "CRAFT_INGREDIENT_MISSING", {'spec':specname, 'level':level}, qty])
                    fail = True
                    break
        if fail:
            return

        # check power constraint, unless building requires zero power (e.g. it's a power plant)
        consumes_power = GameObjectSpec.get_leveled_quantity(spec.consumes_power_while_building, 1)
        power_state = session.viewing_base.get_power_state()
        if gamedata['enable_power'] and (not is_instant) and (GameObjectSpec.get_leveled_quantity(spec.consumes_power, 1) > 0) and \
           (power_state[1] + consumes_power) > power_state[0]:
            fail = True
            retmsg.append(["ERROR", "POWER_LIMIT"])

        if fail:
            return

        # check quantity constraint
        if (not session.player.is_cheater):
            # how many does the player already have?
            current = 0
            for obj in session.viewing_base.iter_objects():
                if obj.spec.name == spec.name:
                    current += 1

            # check townhall-level-based quantity constraint
            limit = GameObjectSpec.get_leveled_quantity(spec.limit, max(1, session.player.get_townhall_level()))
            if spec.limit_requires:
                limit = min(limit, len(spec.limit_requires))

            if (limit >= 0) and (current >= limit):
                retmsg.append(["ERROR", "BUILDING_LIMIT_EXCEEDED", limit])
                return

            # check predicate quantity constraint
            if spec.limit_requires:
                pred = spec.limit_requires[current]
                if not Predicates.read_predicate(pred).is_satisfied2(session, session.player, None):
                    retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", pred])
                    return

        upgrade_ingredients = None

        if (not is_instant):
            if (not session.player.is_cheater):
                negative_cost = dict((res,-cost[res]) for res in cost)
                session.player.resources.gain_res(negative_cost, reason='building_construction')
                admin_stats.econ_flow_player(session.player, 'investment', 'buildings', negative_cost, spec = building_type, level = 1)

            if spec.upgrade_ingredients:
                ingr_list = object.spec.get_upgrade_ingredients_list(1)
                for entry in ingr_list:
                    session.player.inventory_remove_by_type(entry['spec'], entry.get('stack',1), '5130_item_activated', level = entry.get('level',None), reason='construct_building')
                session.player.send_inventory_update(retmsg)
                upgrade_ingredients = copy.deepcopy(ingr_list) # pass ownership

            build_time = GameObjectSpec.get_leveled_quantity(spec.build_time, 1)
            if build_time > 0:
                build_time = int(build_time / session.player.stattab.get_player_stat('foreman_speed'))
        else:
            build_time = -1

        if build_time < 1:
            # special case for instant finish
            if spec.kind == 'inert':
                finish_time = -1
            else:
                finish_time = server_time + 1
        else:
            finish_time = server_time + build_time

        newobj = instantiate_object_for_player(session.player,
                                               EnvironmentOwner if (spec.kind == 'inert' and "REMOVE_OBSTACLE_FOR_FREE" not in spec.spells) else session.player,
                                               building_type, x=j, y=i, build_finish_time=finish_time)
        newobj.upgrade_ingredients = copy.deepcopy(upgrade_ingredients)

        if build_time < 1 and spec.kind != 'inert':
            newobj.build_done_time = 999 # special case for instant finish, necessary to make ping_object() do the right thing

        session.viewing_base.adopt_object(newobj) # this does the nosql write
        session.add_object(newobj)

        if spec.kind != 'inert':
            newobj.update_production(session.player, session.viewing_base.base_type, session.viewing_base.base_region, compute_power_factor(power_state))

        retmsg.append(["OBJECT_CREATED2", newobj.serialize_state()])
        retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

        # re-evaluate power situation
        session.power_changed(session.viewing_base, newobj, retmsg)

        if build_time < 1 and spec.kind != 'inert':
            self.ping_object(session, retmsg, newobj.obj_id, session.viewing_base)

        session.activity_classifier.built_or_upgraded_building()

    def do_move_building(self, session, retmsg, object, spellargs):
        j, i = spellargs[0]

        if (not object.is_building()) and (not session.player.is_cheater):
            retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
            retmsg.append(["OBJECT_STATE_UPDATE2", object.serialize_state()])
            return

        if object.is_building() and (object.is_repairing() or object.is_under_construction() or object.is_upgrading() or object.is_enhancing() or object.is_removing()) and not gamedata.get('always_allow_move_building',False):
            retmsg.append(["ERROR", "CANNOT_MOVE_BUILDING_WHILE_BUSY"])
            return

        if not session.viewing_base.is_building_location_valid([j,i], object.spec, object, ignore_collision = session.player.is_cheater,
                                                               ignore_perimeter = object.spec.ignore_perimeter or session.player.is_cheater):
            retmsg.append(["ERROR", "INVALID_BUILDING_LOCATION"])
            retmsg.append(["OBJECT_STATE_UPDATE2", object.serialize_state()])
            return

        # in quarry, object can be moved in quarry, object is player's, and player owns the quarry?
        if session.viewing_base.is_nosql_base() and object.spec.quarry_movable and (object.owner is session.player) and session.viewing_base.base_landlord_id == session.player.user_id:
            # do not allow quarry turrets to be moved in airborne quarries
            if (not session.player.is_cheater) and session.viewing_base.base_climate:
                data = gamedata['climates'][session.viewing_base.base_climate]
                if data.get('exclude_ground_units',False):
                    retmsg.append(["ERROR", "INVALID_BUILDING_LOCATION"])
                    return
            pass # OK
        elif session.has_attacked:
            retmsg.append(["ERROR", "CANNOT_CAST_SPELL_IN_COMBAT"])
            return
        elif (object in session.player.home_base_iter()):
            pass # OK
        else:
            retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
            return

        object.x = j
        object.y = i

        retmsg.append(["OBJECT_STATE_UPDATE2", object.serialize_state()])
        session.viewing_base.nosql_write_one(object, 'MOVE_BUILDING', fields = ['xy'])

    def do_make_droids(self, session, retmsg, object, spellargs):
        spec_name = spellargs[0]
        spec = session.player.get_abtest_spec(GameObjectSpec, spec_name)
        assert spec.kind == 'mobile'

        if not object.is_manufacturer():
            return

        if object.is_damaged() or object.is_repairing():
            retmsg.append(["ERROR", "FACTORY_DAMAGED"])
            return

        if object.is_upgrading() or object.is_enhancing() or object.is_removing():
            retmsg.append(["ERROR", "FACTORY_IS_UPGRADING"])
            return

        if spec.developer_only and (spin_secure_mode or (not session.player.is_developer())):
            retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
            return

        # figure out the level of the unit to be built
        if spec.level_determined_by_tech:
            tech_name = spec.level_determined_by_tech
            if (not session.player.tech.has_key(tech_name)):
                # player is missing prerequisite tech
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", tech_name])
                return
            level = session.player.tech[tech_name]
        else:
            level = 1

        assert level >= 1

        if spec.manufacture_category != object.spec.manufacture_category:
            retmsg.append(["ERROR", "OBJECT_IS_NOT_CAPABLE"])
            return
        if object.level < GameObjectSpec.get_leveled_quantity(spec.requires_factory_level, level):
            retmsg.append(["ERROR", "FACTORY_LEVEL_TOO_LOW"])
            return

        # if tech research exceeds max unit level, cap it there
        if level > spec.maxlevel:
            level = spec.maxlevel

        # check if requirements are satisfied
        if spec.requires:
            req = GameObjectSpec.get_leveled_quantity(spec.requires, 1)
            if (not session.player.is_cheater) and (not req.is_satisfied2(session, session.player, None)):
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED",
                               gamedata['units'][spec_name]['requires']])
                return
        for pname, ppred in (('activation', spec.activation), ('show_if', spec.show_if)):
            if ppred:
                if not ppred.is_satisfied2(session, session.player, None):
                    retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", gamedata['units'][spec_name][pname]])
                    return

        if object.is_damaged():
            retmsg.append(["ERROR", "FACTORY_DAMAGED"]); return
        if object.is_under_construction():
            retmsg.append(["ERROR", "FACTORY_UNDER_CONSTRUCTION"]); return

        cost = spec.cost_to_repair(level, 0, session.player, cost_mode = spec.COST_MODE_MANUFACTURE, builder = object)
        for res in gamedata['resources']:
            if (not session.player.is_cheater) and (getattr(session.player.resources,res) < cost[res]):
                retmsg.append(["ERROR", "INSUFFICIENT_"+res.upper(), cost[res]])
                return

        build_time = cost['time']

        space = GameObjectSpec.get_leveled_quantity(spec.consumes_space, level)

        # apply unit capacity constraint
        if (not session.player.is_cheater):
            if spec.limit >= 0:
                if session.player.get_army_unit_count_by_specname().get(spec.name, 0) + 1 > spec.limit:
                    retmsg.append(["ERROR", "UNIT_COUNT_LIMIT"])
                    return

            cur = session.player.get_army_space_usage_by_squad()
            if (cur['ALL'] + space > session.player.stattab.total_space):
                retmsg.append(["ERROR", "UNIT_SPACE_LIMIT"])
                return

            if (not session.player.squads_enabled()) or (not gamedata['produce_to_reserves']):
                if (cur[str(SQUAD_IDS.BASE_DEFENDERS)] + space > session.player.stattab.main_squad_space):
                    retmsg.append(["ERROR", "UNIT_SPACE_LIMIT"])
                    return

        # queue it up
        negative_cost = dict((res,-cost[res]) for res in cost if res != 'time')
        session.player.resources.gain_res(negative_cost, reason='unit_production')
        admin_stats.econ_flow_player(session.player, 'consumption', 'unit_manufacture', negative_cost)

        # note: structure speed bonus has already been applied via unit stat

        if len(object.manuf_queue) < 1:
            object.manuf_start_time = server_time
            object.manuf_done_time = 0

        object.manuf_queue.append({'spec_name': spec_name, 'level': level, 'total_time': build_time, 'cost': dict((res,cost[res]) for res in cost if res != 'time')})
        session.deferred_object_state_updates.add(object)
        session.deferred_player_state_update = True
        session.activity_classifier.manufactured_unit()

    def do_cancel_make_droids(self, session, retmsg, object, spellargs):
        queue_index = spellargs[0]
        # the client also sends the type of unit it thinks it's
        # cancelling, in order to avoid a race condition where a unit
        # gets finished while the message is in flight
        spec_name = spellargs[1]
        if not object.is_manufacturer():
            return
        if (queue_index < 0) or (queue_index >= len(object.manuf_queue)):
            retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
            return
        item = object.manuf_queue[queue_index]
        if item['spec_name'] != spec_name:
            retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
            return
        spec = session.player.get_abtest_spec(GameObjectSpec, spec_name)
        level = item['level']

        # how much resources and time was this construction going to take?
        if 'cost' in item:
            refund = dict((res, int(gamedata['manufacture_cancel_refund']*amount)) for res, amount in item['cost'].iteritems())
        else:
            refund = spec.cost_to_repair(level, 0, session.player, cost_mode = spec.COST_MODE_MANUFACTURE_CANCEL, builder = object)
            refund = dict((res, amount) for res, amount in refund.iteritems() if res != 'time') # filter out time

        # delete the item from the queue
        object.manuf_queue.pop(queue_index)

        if len(object.manuf_queue) < 1:
            object.manuf_start_time = -1
            object.manuf_done_time = -1

        # return resources to the player
        refund = session.player.resources.gain_res(refund, reason='canceled_production')
        admin_stats.econ_flow_player(session.player, 'consumption', 'unit_manufacture', refund)

        # save state
        retmsg.append(["OBJECT_STATE_UPDATE", object.serialize_state(), session.player.resources.calc_snapshot().serialize()])

    def do_ping_manufacturing(self, session, retmsg, base, object):
        assert object.owner is session.player # only handle for self now
        did_a_manufacture = False

        prog = object.manuf_done_time
        if object.manuf_start_time >= 0:
            prog += (server_time - object.manuf_start_time)

        if (len(object.manuf_queue)) > 0 and (prog >= object.manuf_queue[0]['total_time']):
            # manufacture is complete
            did_a_manufacture = True

            # keep track of added objects so we can send a UNIT_MANUFACTURED message to the client
            new_object_ids = []

            # expensive query, so only do it once
            space_usage = session.player.get_army_space_usage_by_squad(exclude_manuf_queue = object)

            # grab items off the manufacturing queue in FIFO order
            while len(object.manuf_queue) > 0:
                if object.manuf_queue[0]['total_time'] > prog:
                    break
                item = object.manuf_queue.pop(0)

                prog -= item['total_time']

                # knock off completed time from done_time
                # this can make done_time go negative!
                object.manuf_done_time -= item['total_time']

                spec = session.player.get_abtest_spec(GameObjectSpec, item['spec_name'])
                space = GameObjectSpec.get_leveled_quantity(spec.consumes_space, item.get('level',1))

                if spec.limit >= 0 and (not session.player.is_cheater):
                    # this is an expensive database query, but we don't expect many units to have this restriction
                    if session.player.get_army_unit_count_by_specname().get(spec.name, 0) + 1 > spec.limit:
                        gamesite.exception_log.event(server_time, 'player %d not allowed to finish unit of spec %s due to count limit' % (session.player.user_id, spec.name))
                        continue # drop the unit

                destination_squad = SQUAD_IDS.BASE_DEFENDERS

                if (not session.player.is_cheater):
                    if space_usage['ALL']+space > session.player.stattab.total_space:
                        # only alert if trim_unit_space_if is enabled
                        if Predicates.read_predicate(gamedata['server']['trim_unit_space_if']).is_satisfied2(session, session.player, None):
                            gamesite.exception_log.event(server_time, 'player %d (CC%d) produced into oversize army! (new %d limit %d army %s)' % (session.player.user_id, session.player.get_townhall_level(), space, session.player.stattab.total_space, repr(space_usage)))

                    if space_usage[str(SQUAD_IDS.BASE_DEFENDERS)] + space > session.player.stattab.main_squad_space:
                        if session.player.squads_enabled() and gamedata['produce_to_reserves']:
                            # overflow production to reserves
                            destination_squad = SQUAD_IDS.RESERVES
                        else:
                            # only alert if trim_unit_space_if is enabled
                            if Predicates.read_predicate(gamedata['server']['trim_unit_space_if']).is_satisfied2(session, session.player, None):
                                gamesite.exception_log.event(server_time, 'player %d (CC%d) produced into oversize base defenders! (new %d limit %d army %s)' % (session.player.user_id, session.player.get_townhall_level(), space, session.player.stattab.main_squad_space, repr(space_usage)))

                session.increment_player_metric('units_manufactured', 1, bucket = True, time_series = False)
                session.increment_player_metric('unit:'+spec.name+':manufactured', 1, bucket = True, time_series = False)
                if spec.manufacture_category:
                    session.increment_player_metric(spec.manufacture_category+'_manufactured', 1, bucket = True, time_series = False)
                session.deferred_history_update = True

                newobj = instantiate_object_for_player(session.player, object.owner, item['spec_name'], x=object.x+10, y=object.y+10, level=item.get('level',1))
                newobj.squad_id = destination_squad

                base.adopt_object(newobj)
                space_usage['ALL'] += space
                space_usage[str(destination_squad)] += space
                session.player.send_army_update_one(newobj, retmsg)

                new_object_ids.append(newobj.obj_id)

                if gamedata.get('enable_defending_units',True) and destination_squad == SQUAD_IDS.BASE_DEFENDERS and (session.viewing_base is object.owner.my_home):
                    session.add_object(newobj)
                    if session.damage_log: session.damage_log.init(newobj)
                    retmsg.append(["OBJECT_CREATED2", newobj.serialize_state()])
                    if newobj.auras:
                        retmsg.append(["OBJECT_AURAS_UPDATE", newobj.serialize_auras()])

                if destination_squad == SQUAD_IDS.RESERVES and object.owner is session.player:
                    retmsg.append(["MANUFACTURE_OVERFLOW_TO_RESERVES", newobj.obj_id])

            retmsg.append(["UNIT_MANUFACTURED", object.obj_id, new_object_ids])

            # stop at end of production line
            if len(object.manuf_queue) < 1:
                object.manuf_start_time = -1
                object.manuf_done_time = -1

        return did_a_manufacture

    def do_start_repairs(self, session, retmsg, base_id, repair_units = True):
        if base_id == session.player.my_home.base_id:
            base = session.player.my_home
            do_units = repair_units
            write_base = False
        elif base_id == session.viewing_base.base_id:
            assert session.viewing_base.base_landlord_id == session.player.user_id
            base = session.viewing_base
            do_units = False
            write_base = True
        else:
            raise Exception('base not in session: '+base_id)

        squad_to_repair = session.player.which_squad_is_under_repair() or SQUAD_IDS.BASE_DEFENDERS
        units_to_repair = [] # list units separately so we can sort them by time
        unit_repair_cost = dict([(res,0) for res in gamedata['resources']])
        units_to_remove = []

        if write_base and session.viewing_base_lock != base.lock_id():
            # not going to hold it for an extended period of time, so no need to broadcast
            if gamesite.nosql_client.map_feature_lock_acquire(base.base_region, base.base_id, session.player.user_id,
                                                                  generation=base.base_generation, do_hook=False, reason='do_start_repairs') \
                                                                  != Player.LockState.being_attacked: # generation=-1?
                retmsg.append(["ERROR", "CANNOT_LOCK_QUARRY", base.base_ui_name])
                return

        try:
            for object in base.iter_objects():
                if object.owner is not session.player: continue
                if object.is_building() and object.is_damaged():
                    if (not object.is_repairing()):
                        repair_time = object.time_to_repair(session.player)
                        object.repair_finish_time = server_time + repair_time
                        object.disarmed = True
                        if session.has_object(object.obj_id) and (retmsg is not None):
                            retmsg.append(["OBJECT_STATE_UPDATE2", object.serialize_state()])
                        if write_base:
                            base.nosql_write_one(object, 'do_start_repairs')
                    else: # check for completed repairs
                        if retmsg is not None: # but not on logout/non-interactive paths
                            if server_time >= object.repair_finish_time:
                                self.do_ping_object(session, retmsg, object, base)
                                if write_base:
                                    base.nosql_write_one(object, 'do_start_repairs')
                if object.is_mobile():
                    if object.is_temporary(): # get rid of temporary units
                        units_to_remove.append(object)
                    elif do_units and object.is_damaged() and session.player.can_repair_unit(object) and \
                       ((object.squad_id or 0) == squad_to_repair) and \
                       (not session.player.unit_repair_queued(object)):
                        units_to_repair.append(object)
                        my_cost = object.cost_to_repair(session.player)
                        for res in gamedata['resources']:
                            unit_repair_cost[res] += my_cost.get(res,0)

            for object in units_to_remove:
                base.drop_object(object)
                if session.has_object(object.obj_id):
                    if retmsg is not None: retmsg.append(["OBJECT_REMOVED2", object.obj_id])
                    session.rem_object(object.obj_id)
        finally:
            if write_base and session.viewing_base_lock != base.lock_id():
                gamesite.nosql_client.map_feature_lock_release(base.base_region, base.base_id, session.player.user_id, generation=base.base_generation, reason='do_start_repairs')

        if units_to_repair:
            assert retmsg is not None # units must be repaired interactively because they cost resources
            units_to_repair.sort(key = lambda obj: obj.time_to_repair(session.player))
            error = None

            if session.player.squads_enabled():
                # only start repairs if we can afford all of them
                for res in gamedata['resources']:
                    if (getattr(session.player.resources,res) < unit_repair_cost[res]):
                        error = ["INSUFFICIENT_RESOURCES_TO_REPAIR", unit_repair_cost.copy(), squad_to_repair]
                        units_to_repair = []
                        break

            for object in units_to_repair:
                this_error = self.do_unit_repair_queue(session, object.obj_id)
                if this_error:
                    if (not error):
                        error = this_error
                    elif error[0] == "INSUFFICIENT_RESOURCES_TO_REPAIR" and this_error[0] == error[0]:
                        # add up the amounts from all units
                        for res in gamedata['resources']:
                            error[1][res] = error[1].get(res,0) + this_error[1].get(res,0)

                # still continue past error though
            if error:
                retmsg.append(["ERROR"] + error)

        if do_units and (retmsg is not None):
            # just to be safe, update all repair queue and resource state on the client, to help against race conditions
            session.player.unit_repair_integrity_check()
            session.player.unit_repair_send(retmsg)
            retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

    def do_unit_repair_queue(self, session, id):
        if not session.home_base or session.has_attacked: return None
        obj = session.player.get_object_by_obj_id(id, fail_missing = False)
        if not obj: return ["HARMLESS_RACE_CONDITION"]
        assert obj.owner is session.player
        assert obj.is_mobile()
        if not obj.is_damaged(): return None
        if obj.is_temporary(): return None

        # see if it's already under repair
        for item in session.player.unit_repair_queue:
            if item['obj_id'] == obj.obj_id:
                return None

        if not session.player.can_repair_unit(obj):
            return ["REQUIREMENTS_NOT_SATISFIED", {'predicate':'TECH_LEVEL','tech':obj.spec.level_determined_by_tech,'min_level':1}]

        cost = obj.cost_to_repair(session.player)
        for res in gamedata['resources']:
            if getattr(session.player.resources, res) < cost.get(res,0):
                return ["INSUFFICIENT_RESOURCES_TO_REPAIR", cost.copy(), obj.squad_id or 0]

        negative_cost = dict((res,-cost[res]) for res in cost if res != 'time')
        session.player.resources.gain_res(negative_cost, reason = 'unit_repair')
        admin_stats.econ_flow_player(session.player, 'consumption', 'unit_repair', negative_cost)

        if len(session.player.unit_repair_queue) > 0:
            prev_finish_time = session.player.unit_repair_queue[-1]['finish_time']
        else:
            prev_finish_time = server_time
        item = {'obj_id':obj.obj_id, 'original_hp': obj.hp,
                'start_time': prev_finish_time, 'finish_time': prev_finish_time + max(cost['time'],1)}
        for res in gamedata['resources']:
            item[res] = cost.get(res,0)
        session.player.unit_repair_queue.append(item)
        return None

    def do_unit_repair_speedup_for_free(self, session, retmsg):
        return # not permitted, code kept for reference only
        if not session.home_base: return
        if len(session.player.unit_repair_queue) < 1: return
        time_left = session.player.unit_repair_queue[-1]['finish_time'] - server_time
        if time_left <= Store.get_free_speedup_time(session, session.player):
            for item in session.player.unit_repair_queue:
                item['finish_time'] = server_time - 1
            self.do_unit_repair_tick(session, retmsg)

    # check on progress of unit repair queue. send OBJECT_STATE_UPDATE for anything that
    # has gained hitpoints. Send new queue state only if the contents of the queue changed,
    # or if must_reply is true.
    def do_unit_repair_tick(self, session, retmsg, must_reply = False):
        if (not session.home_base) or session.has_attacked: return
        old_len = len(session.player.unit_repair_queue)
        affected = session.player.unit_repair_tick()
        if len(affected) > 0:
            for obj in affected:
                if session.has_object(obj.obj_id):
                    # use fake_xy = [-1,-1] to avoid updating the client-side object position
                    retmsg.append(["OBJECT_STATE_UPDATE2", obj.serialize_state(fake_xy = [-1,-1])])
                session.player.send_army_update_one(obj, retmsg)
        # only send the updated queue to the client if something was added or removed
        if must_reply or len(session.player.unit_repair_queue) != old_len:
            session.player.unit_repair_send(retmsg)

    def do_unit_repair_cancel(self, session, retmsg, id):
        if not gamedata['unit_repair_can_cancel']:
            retmsg.append(["ERROR", "SERVER_PROTOCOL"])
            return
        if not session.home_base or session.has_attacked: return
        obj = session.player.get_object_by_obj_id(id, fail_missing = False)
        if not obj: return
        assert obj.owner is session.player
        assert obj.is_mobile()

        session.player.unit_repair_cancel(obj)
        if session.has_object(obj.obj_id):
            retmsg.append(["OBJECT_STATE_UPDATE2", obj.serialize_state(fake_xy = [-1,-1])])
        session.player.unit_repair_send(retmsg)
        retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

    def do_unit_repair_cancel_all(self, session, retmsg):
        obj_id_list = [x['obj_id'] for x in session.player.unit_repair_queue]
        for obj_id in obj_id_list:
            obj = session.player.get_object_by_obj_id(obj_id, fail_missing = False)
            if obj:
                session.player.unit_repair_cancel(obj)
                if session.has_object(obj.obj_id):
                    retmsg.append(["OBJECT_STATE_UPDATE2", obj.serialize_state(fake_xy = [-1,-1])])

        if len(session.player.unit_repair_queue) > 0:
            gamesite.exception_log.event(server_time, 'do_unit_repair_cancel_all(): %d remaining queue %s' % \
                                         (session.player.user_id, repr(session.player.unit_repair_queue)))
            session.player.unit_repair_queue = []

        session.player.unit_repair_send(retmsg)
        retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

    def do_help_request_complete(self, session, retmsg, ui_from_name, req):
        # apply the benefit of the new-complete help request, and tell the player about it
        req_props = req['req_props']
        time_saved = 0

        if req_props['kind'] == 'speedup' and req_props['action'] == 'upgrade':
            obj = session.player.my_home.find_object_by_id(req_props['obj_id'])
            if (not obj) or \
               (not obj.is_building()) or \
               obj.is_damaged() or \
               (not obj.is_upgrading()):
                metric_event_coded(session.player.user_id, '4183_alliance_help_failed',
                                   {'sum':session.player.get_denormalized_summary_props('brief'),
                                    'alliance_id': req.get('alliance_id', None),
                                    'req_id':req['req_id'], 'req_props': req_props})
                if session.alliance_chat_channel:
                    session.do_chat_send(session.alliance_chat_channel,
                                         'My help failed to complete! (req_id %r region %r)' % (req['req_id'], req.get('region_id', None)),
                                         bypass_gag = True, props = {'type':'help_failed', 'req_id': req['req_id'], 'region_id': req.get('region_id',None),
                                                                     'recipient_id': session.player.user_id,
                                                                     'req_props': req['req_props']})

                return

            # min(time left, max(fraction * total_time, min_time))
            time_saved = min(obj.upgrade_total_time - (server_time - obj.upgrade_start_time + obj.upgrade_done_time),
                             max(int(gamedata['alliance_help_speedup_fraction'] * obj.upgrade_total_time),
                                 gamedata['alliance_help_speedup_min_time']))
            if time_saved > 0:
                obj.upgrade_done_time += time_saved
                obj.upgrade_help.help_completed = True
                obj.upgrade_help.time_saved = max(1, time_saved)
                session.deferred_object_state_updates.add(obj)

        else:
            gamesite.exception_log.event(server_time, 'unrecognized help request: %r' % req_props)
            return

        retmsg.append(["HELP_COMPLETE", ui_from_name, req, time_saved])
        metric_event_coded(session.player.user_id, '4182_alliance_help_completed',
                           {'sum':session.player.get_denormalized_summary_props('brief'),
                            'alliance_id': req.get('alliance_id', None), 'time_saved': time_saved,
                            'req_id':req['req_id'], 'req_props': req_props})
        session.increment_player_metric('help_completed', 1, time_series = False)

        if session.alliance_chat_channel:
            session.do_chat_send(session.alliance_chat_channel,
                                 'My help is complete! (req_id %r region %r)' % (req['req_id'], req.get('region_id', None)),
                                 bypass_gag = True, props = {'type':'help_complete', 'req_id': req['req_id'], 'region_id': req.get('region_id',None),
                                                             'recipient_id': session.player.user_id, 'time_saved': time_saved,
                                                             'req_props': req['req_props']})

    def do_equip_building(self, session, retmsg, arg, force = False):
        dest_object_id = arg[1]
        dest_addr = arg[2]
        inventory_slot = arg[3]
        add_item = arg[4]
        remove_item = arg[5]
        #user_tag = arg[6]

        # verify object
        if (not session.has_object(dest_object_id)):
            retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
            return False

        obj = session.get_object(dest_object_id)
        if (not obj) or (obj.owner is not session.player) or (not obj.is_building()) or (obj not in session.player.home_base_iter() and (not obj.spec.quarry_upgradable)):
            retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
            return False
        if (not force) and (obj.is_damaged() or obj.is_busy()):
            retmsg.append(["ERROR", "CANNOT_EQUIP_BUILDING_WHILE_BUSY", dest_object_id])
            return False

        # prepare dict
        if obj.equipment is None: obj.equipment = {}
        ret = self.do_equip(session, retmsg, obj.spec, obj.level, obj.equipment, dest_addr, inventory_slot, add_item, remove_item, force = force)
        if len(obj.equipment) < 1: obj.equipment = None
        session.viewing_base.nosql_write_one(obj, 'do_equip_building', fields = ['equipment'])

        if ret:
            session.power_changed(session.viewing_base, obj, retmsg)
            if obj.is_producer():
                obj.update_production(session.player, session.player.my_home.base_type, session.player.my_home.base_region, compute_power_factor(session.player.my_home.get_power_state()))
            session.deferred_stattab_update = True

        retmsg.append(["OBJECT_STATE_UPDATE2", obj.serialize_state()])
        return ret

    def do_equip_unit(self, session, retmsg, arg):
        dest_spec_name = arg[1]
        dest_addr = arg[2]
        inventory_slot = arg[3]
        add_item = arg[4]
        remove_item = arg[5]
        #user_tag = arg[6]

        # verify spec
        dest_spec = session.player.get_abtest_spec(GameObjectSpec, dest_spec_name)
        if (not dest_spec) or (dest_spec.kind != 'mobile'):
            return False

        tech_name = dest_spec.level_determined_by_tech
        tech_level = session.player.tech.get(tech_name, 0)

        # prepare dict
        if dest_spec_name not in session.player.unit_equipment: session.player.unit_equipment[dest_spec_name] = {}
        ret = self.do_equip(session, retmsg, dest_spec, tech_level, session.player.unit_equipment[dest_spec_name], dest_addr, inventory_slot, add_item, remove_item)
        if len(session.player.unit_equipment[dest_spec_name]) < 1: del session.player.unit_equipment[dest_spec_name]

        if ret:
            session.deferred_stattab_update = True

        retmsg.append(["PLAYER_UNIT_EQUIP_UPDATE", session.player.unit_equipment])
        return ret

    # equip add/remove function that works on BOTH units and buildings, because it operates directly on the destination dictionary
    def do_equip(self, session, retmsg, obj_spec, obj_level, equipment, dest_addr, inventory_slot, add_item, remove_item, force = False):
        assert type(equipment) is dict

        add_specname = add_item['spec'] if add_item else None
        remove_specname = remove_item['spec'] if remove_item else None

        add_spec = gamedata['items'].get(add_specname, None) if add_specname else None
        remove_spec = gamedata['items'].get(remove_specname, None) if remove_specname else None

        # verify item to be added
        if add_specname:
            if force and inventory_slot < 0:
                # item is being generated from someplace other than inventory (e.g. crafting)
                pass
            else:
                # REPLACE passed add_item with whatever is in inventory
                source_item = session.player.inventory_verify_item(inventory_slot, add_specname, level = add_item.get('level',None)) # note: default level to None meaning "don't care" and not 1
                if not source_item: # race condition (or cheat attempt), item not found
                    retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
                    return False
                add_item = copy.deepcopy(source_item)
                if 'stack' in add_item: del add_item['stack'] # only take one

            if (add_item is None) or (add_spec is None):
                retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
                session.player.send_inventory_update(retmsg)
                return False

            if 'requires' in add_spec['equip'] and (not Predicates.read_predicate(add_spec['equip']['requires']).is_satisfied2(session, session.player, None)):
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", add_spec['equip']['requires']])
                return False

            if (not session.player.is_cheater):
                # check unique_equipped constraint
                if ('unique_equipped' in add_spec) and ((not remove_spec) or (remove_spec.get('unique_equipped',None) != add_spec['unique_equipped'])):
                    for item in session.player.equipped_item_iter(session.viewing_base):
                        item_spec = gamedata['items'].get(item['spec'], None)
                        if item_spec and item_spec.get('unique_equipped',None) == add_spec['unique_equipped']:
                            # doubled
                            retmsg.append(["ERROR", "EQUIP_INVALID_UNIQUE", item['spec']])
                            return False

                # check limited_equipped constraint
                if ('limited_equipped' in add_spec) and ((not remove_spec) or (remove_spec.get('limited_equipped',None) != add_spec['limited_equipped'])):
                    if session.player.stattab.limited_equipped.get(add_spec['limited_equipped'],0) < \
                       add_item.get('stack',1) + session.player.count_limited_equipped_items(add_spec['limited_equipped'], session.viewing_base):
                        retmsg.append(["ERROR", "EQUIP_INVALID_LIMITED", add_spec['name']])
                        return False

            if not Equipment.equip_add(equipment, obj_spec, obj_level, dest_addr, add_item, add_spec, probe_only = True, probe_will_remove = bool(remove_specname)):
                retmsg.append(["ERROR", "EQUIP_INVALID"])
                return False

        # verify item to be removed
        if remove_specname:
            if not Equipment.equip_has(equipment, dest_addr, remove_specname, level = remove_item.get('level',None)): # note: default level to None meaning "don't care" and not 1
                retmsg.append(["ERROR", "EQUIP_INVALID"])
                return False
            if 'unequip_requires' in remove_spec['equip'] and (not Predicates.read_predicate(remove_spec['equip']['unequip_requires']).is_satisfied2(session, session.player, None)):
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED",remove_spec['equip']['unequip_requires']])
                return False

        # check warehouse availability for pulling any item out or putting a non-fragile item back in
        if (not force) and (add_spec or (remove_spec and remove_spec.get('remove_fragility',0) < 1)) and \
           session.player.warehouse_is_busy():
            retmsg.append(["ERROR", "WAREHOUSE_IS_BUSY"])
            return False

        max_usable_inventory = session.player.resources.calc_snapshot().max_usable_inventory()

        # need extra warehouse space if removing an item without adding, or if adding from a stack greater than 1
        if remove_specname:
            if add_specname and (source_item.get('stack',1) <= add_item.get('stack',1)):
                # the add step is going to free up a space, so there is definitely room
                inventory_buffer = 1
            elif remove_spec and remove_spec.get('remove_fragility',0) >= 1:
                # the item is going to be destroyed upon removal, so no need to make space
                inventory_buffer = 1
            else:
                # the add step is NOT going to free up a space, need to check for room
                if not session.player.inventory_has_space_for(remove_item, max_usable_inventory):
                    retmsg.append(["ERROR", "INVENTORY_LIMIT"])
                    return False
                inventory_buffer = 0

        # now perform the operation atomically
        # any exceptions here mean item duping bugs!
        if remove_specname:
            # note: replace with actual removed item
            remove_item = Equipment.equip_remove(equipment, dest_addr, remove_specname, level = remove_item.get('level',None))
            if remove_spec and remove_spec.get('remove_fragility',0) >= 1:
                # item destroyed
                if not session.home_base:
                    session.player.inventory_log_event('5131_item_trashed', remove_specname, -remove_item.get('stack',1), remove_item.get('expire_time',-1), level=remove_item.get('level',1), reason='removed')
            else:
                # note: pass inflated max_usable_inventory here as "buffer" space, since we checked for space above
                # in over-full warehouse situtations, we don't want this to fail, so pass -1 instead of the true slot count
                assert session.player.inventory_add_item(remove_item, -1 if inventory_buffer >= 1 else (max_usable_inventory + inventory_buffer)) == 1
                # no need to log - player already had item
            if 'on_unequip' in remove_spec['equip']:
                session.execute_consequent_safe(remove_spec['equip']['on_unequip'], session.player, retmsg, reason='on_unequip')

        if add_specname:
            if force and inventory_slot < 0:
                pass # out of thin air
            else:
                assert session.player.inventory_remove(source_item, add_item.get('stack',1), None) # do not log - player still has item
            assert Equipment.equip_add(equipment, obj_spec, obj_level, dest_addr, add_item, add_spec)
            if 'on_equip' in add_spec['equip']:
                session.execute_consequent_safe(add_spec['equip']['on_equip'], session.player, retmsg, reason='on_equip')

        if force and inventory_slot < 0:
            pass # out of thin air
        else:
            session.player.send_inventory_update(retmsg)
        return True

    def do_lottery_scan(self, session, retmsg, scanner, spellname, source):
        # how we are getting permission to scan
        assert source in ('cooldown', 'contents', 'paid', 'aura')
        spell = session.player.get_abtest_spell(spellname)
        success = True

        if session.player.lottery_is_busy(scanner):
            retmsg.append(["ERROR", "CANNOT_SCAN_BUILDING_BUSY"])
            success = False

        if not scanner.is_lottery_building():
            retmsg.append(["ERROR", "CANNOT_SCAN_NO_BUILDING"])
            success = False

        for PRED in ('show_if', 'requires'):
            if PRED in spell and (not Predicates.read_predicate(spell[PRED]).is_satisfied2(session, session.player, None)):
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", spell[PRED]])
                success = False

        aura = None

        if source == 'cooldown':
            if session.player.cooldown_active('lottery_free'):
                retmsg.append(["ERROR", "CANNOT_SCAN_ON_COOLDOWN"])
                success = False
        elif source == 'contents':
            if scanner.contents < 1:
                retmsg.append(["ERROR", "CANNOT_SCAN_NO_CHARGES"])
                success = False
        elif source == 'aura':
            for a in session.player.player_auras_iter_const():
                if a['spec'] == 'lottery_scans' and ('end_time' not in a or a['end_time'] > server_time):
                    aura = a; break
            if (not aura) or (aura.get('stack',1) < 1):
                retmsg.append(["ERROR", "CANNOT_SCAN_NO_CHARGES"])
                success = False

        # check for inventory space
        snapshot = session.player.resources.calc_snapshot()
        if snapshot.cur_inventory() + 1 > snapshot.max_usable_inventory():
            retmsg.append(["ERROR", "INVENTORY_LIMIT"])
            success = False

        if success:
            slate = session.player.get_lottery_slate(session)
            if session.player.lottery_slate_weights:
                weight_dict = session.player.lottery_slate_weights
            else:
                weight_dict = dict((slot_name, 1) for slot_name in slate)

            slot_names = sorted(slate.keys())
            weight_array = [weight_dict[slot_name] for slot_name in slot_names]
            which_slot = weighted_random_choice(slot_names, weight_array, random.random())

            loot = slate[which_slot]

            assert len(loot) == 1
            item = loot[0]
            stack_to_add = item.get('stack',1)
            spec = gamedata['items'].get(item['spec'])
            if spec and spec.get('fungible') and spec['resource'] == 'lottery_scans':
                session.deferred_player_auras_update = True

            assert session.player.inventory_add_item(item, snapshot.max_usable_inventory()) == stack_to_add

            # item gets mutated by add_item() - restore the original stack here
            item['stack'] = stack_to_add
            session.player.inventory_log_event('5125_item_obtained', item['spec'], stack_to_add, item.get('expire_time',-1), level=item.get('level',None), reason='lottery')
            metric_event_coded(session.user.user_id, '1631_lottery_scan_paid' if source == 'paid' else '1630_lottery_scan_free',
                               {'slot': which_slot, 'spec': item['spec'], 'level': item.get('level',None), 'stack': stack_to_add, 'method': source,
                                'inv_slots': {'total': snapshot.max_usable_inventory(), 'full': snapshot.cur_inventory()}})

            session.deferred_player_state_update = True
            session.player.send_inventory_update(retmsg)

            # note: free and charge scans reset the timer. Paid do not.
            if source != 'paid':
                interval = gamedata.get('lottery_free_interval', 86400)
                origin = session.player.get_any_abtest_value('lottery_free_origin', gamedata.get('lottery_free_origin',-1))
                if origin > 0: # periodic reset at fixed time each day
                    duration = interval - ((session.player.get_absolute_time() - origin) % interval)
                else:
                    duration = interval
                session.player.cooldown_trigger('lottery_free', duration)
                retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])

            # deduct resources
            if source == 'cooldown':
                pass
            elif source == 'contents':
                scanner.contents -= 1
                session.deferred_object_state_updates.add(scanner)
            elif source == 'aura':
                aura['stack'] = aura.get('stack',1) - 1
                if aura['stack'] <= 0: aura['end_time'] = server_time - 1
                session.player.prune_player_auras()
                session.deferred_player_auras_update = True

            session.player.reseed_lottery(session, force = True)
            session.increment_player_metric('lottery_scans', 1, time_series = False)
            session.increment_player_metric('lottery_scans_'+source, 1, time_series = False)

        else: # failure
            which_slot = -1
            loot = None

        retmsg.append(["LOTTERY_SCAN_RESULT", scanner.obj_id, which_slot, loot])

        return True

    def instant_attack(self, my_session, retmsg, spellargs):
        dest_user_id = spellargs[0]
        assert dest_user_id != my_session.user.user_id
        assert not my_session.visit_base_in_progress
        assert not my_session.complete_attack_in_progress
        their_session = get_session_by_user_id(dest_user_id)
        if not their_session:
            retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
            return defer.succeed(False)
        d = make_deferred('instant_attack')
        d.addCallback(lambda _: self.do_instant_attack(my_session, their_session, their_session.player.my_home))
        their_session.after_async_request(d)
        return d

    def do_instant_attack(self, my_session, their_session, base):
        ladder_state = None
        dest_feature = SessionChangeNew.query_dest_feature(my_session.player, base.base_id)
        if not dest_feature or dest_feature['base_landlord_id'] != their_session.player.user_id:
            my_session.send(["ERROR", "CANNOT_SPY_BASE_NOT_FOUND", base.base_id, 'do_instant_attack'])
            return
        deployable_squads = SessionChangeNew.query_deployable_squads(my_session.player, dest_feature)
        if len(deployable_squads) < 1:
            my_session.send(["ERROR", "CANNOT_SPY_NO_NEARBY_SQUADS"])
            return
        map_ok, map_violation_error = my_session.player.can_spy_on_home(my_session.user, their_session.player, their_session.user.social_id, ladder_state, deployable_squads)
        if not map_ok:
            my_session.send(["ERROR", map_violation_error])
            return
        pvp_balance = my_session.player.get_pvp_balance(their_session.player, base)
        attack_ok, attack_error = self.can_attack(my_session.player, their_session.player, base, pvp_balance, deployable_squads, ladder_state)
        if not attack_ok:
            my_session.send(["ERROR", attack_error])
            return

        self.init_attack(my_session, my_session.player, their_session.player, base, ladder_state)
        # XXXXXX remove attacker protection
        gamesite.exception_log.event(server_time, 'HERE! %r' % deployable_squads)
        my_session.deferred_history_update = True

    def can_attack(self, player, other_player, base, pvp_balance, deployable_squads, ladder_state):
        if server_time < player.get_repeat_attack_cooldown_expire_time(other_player.user_id, base.base_id):
            return (False, "CANNOT_ATTACK_REPEAT_ATTACK_COOLDOWN")

        if pvp_balance == 'same_alliance':
            return (False, "CANNOT_ATTACK_SAME_ALLIANCE")

        if (other_player is not player) and \
           player.is_alt_account_unattackable(other_player.user_id) and gamedata['prevent_alt_attacks']:
            return (False, "CANNOT_ATTACK_ALT_ACCOUNT")

        if base is not other_player.my_home:
            # quarry reinforcement or attack

            # check control limit before attacking unowned quarry
            if (other_player is not player) and (base.base_type == 'quarry') and \
               base.base_region and gamedata['regions'][base.base_region].get('limit_quarry_control',True):
                if player.num_quarries_controlled() >= player.stattab.quarry_control_limit:
                    return (False, "CANNOT_ATTACK_QUARRY_LIMIT_REACHED")

        elif other_player.is_human():
            # attack against a human home base

            if pvp_balance == 'player':
                return (False, "CANNOT_ATTACK_WEAKER_PLAYER")

            elif pvp_balance == 'enemy_strict':
                return (False, "CANNOT_ATTACK_STRONGER_PLAYER")

            if player.isolate_pvp and (not other_player.isolate_pvp):
                return (False, "CANNOT_ATTACK_YOU_ARE_ISOLATED")

            if (not player.isolate_pvp) and other_player.isolate_pvp:
                return (False, "CANNOT_ATTACK_THEY_ARE_ISOLATED")

            if other_player.has_damage_protection():
                return (False, "CANNOT_ATTACK_PLAYER_UNDER_PROTECTION")

            # check for PvP ability
            if (not player.is_pvp_player()):
                return (False, "CANNOT_ATTACK_NOPVP_YOU")

            elif (not other_player.is_pvp_player()):
                return (False, "CANNOT_ATTACK_NOPVP_THEM")

            # check for ladder/nonladder firewall violations
            if len(deployable_squads) == 1 and deployable_squads.values()[0]['squad_id'] == SQUAD_IDS.BASE_DEFENDERS:
                if player.is_ladder_player():
                    if (not other_player.is_ladder_player()):
                        return (False, "CANNOT_ATTACK_LADDER_YOU")
                    elif (not ladder_state):
                        return (False, "CANNOT_ATTACK_LADDER_YOU")
                else:
                    if other_player.is_ladder_player():
                        return (False, "CANNOT_ATTACK_LADDER_THEM")

                # check for map/legacy firewall violations
                if (not ladder_state):
                    if (not other_player.is_legacy_pvp_player()):
                        return (False, "CANNOT_ATTACK_MAP_THEM")
                    elif (not player.is_legacy_pvp_player()):
                        return (False, "CANNOT_ATTACK_MAP_YOU")

            if player.stattab.sandstorm_max:
                return (False, "CANNOT_ATTACK_SANDSTORM_MAX")

        return (True, None)

    def is_protection_eligible(self, session, attacker, attacker_user, defender, defender_user, base, ladder_state):
        if defender.is_ai() or (base is not defender.my_home): return False

        if attacker.home_region and (attacker.home_region in gamedata['regions']) and \
           ('enable_battle_protection_if' in gamedata['regions'][attacker.home_region]) and \
           (not Predicates.read_predicate(gamedata['regions'][attacker.home_region]['enable_battle_protection_if']).is_satisfied(defender, None)):
            return False # turned off for this region and this defender

        if gamedata['server']['global_protection_cooldown'] > 0 and defender.cooldown_active('global_protection'):
            return False # turned off by cooldown

        if ('enable_protection_if' in gamedata['server']) and (not Predicates.read_predicate(gamedata['server']['enable_protection_if']).is_satisfied(defender, None)):
            return False # turned off by predicate

        if not gamedata['server'].get('protect_during_revenge', True):
            # deny protection during revenge attacks that take place outside normal level range

            # if defender is not inside attacker's normal level range, AND the revenge cooldown is active...
            if (not attacker.in_attackable_level_range(defender.level())) and \
               attacker.cooldown_active('revenge_defender:%d' % defender.user_id):
                return False

        protect_facebook_friends = defender.get_any_abtest_value('protect_facebook_friends', gamedata['server']['protect_facebook_friends'])
        protect_same_ip = defender.get_any_abtest_value('protect_same_ip', gamedata['server']['protect_same_ip'])
        protect_same_alliance = defender.get_any_abtest_value('protect_same_alliance', gamedata['server']['protect_same_alliance'])

        is_same_ip = ((defender_user.last_login_ip == attacker_user.last_login_ip) and (attacker_user.last_login_ip != 'unknown'))

        # have these two players exchanged DP too much recently?
        max_player_stacks = Predicates.eval_cond_or_literal(gamedata['server']['protection_fatigue_stacks'], session, defender)
        is_fatigued = gamedata['server']['enable_protection_fatigue'] and \
                      (attacker.cooldown_active('protection_fatigue:%d'%defender.user_id) >= max_player_stacks or \
                       (gamedata['server']['bidirectional_protection_fatigue'] and defender.cooldown_active('protection_fatigue:%d'%attacker.user_id) >= gamedata['server']['protection_fatigue_stacks']))

        # are these two players in the same alliance, or have these two players recently exchanged too much DP with members of each others' alliances?
        max_alliance_stacks = Predicates.eval_cond_or_literal(gamedata['server']['alliance_protection_fatigue_stacks'], session, defender)
        if gamedata['server']['alliance_stickiness'] > 0:
            is_same_alliance, my_alliances, other_alliances = attacker.is_same_alliance_sticky(defender)
            if gamedata['server']['enable_protection_fatigue'] and gamedata['server']['enable_alliance_protection_fatigue'] and (not is_same_alliance):
                for aid in my_alliances.union(other_alliances):
                    if attacker.cooldown_active('protection_fatigue:a%d'%aid) >= max_alliance_stacks or \
                       (gamedata['server']['bidirectional_protection_fatigue'] and defender.cooldown_active('protection_fatigue:a%d'%aid) >= gamedata['server']['alliance_protection_fatigue_stacks']):
                        is_fatigued = True
                        break
        else:
            is_same_alliance = attacker.is_same_alliance(defender.user_id)

        # always enable protection for non-secure testing. Otherwise perform checks.
        if (not spin_secure_mode) or \
           ((not attacker.is_alt_account_unprotectable(defender.user_id)) and \
            (not is_fatigued) and \
            (protect_same_ip or (not is_same_ip)) and \
            (protect_same_alliance or (not is_same_alliance)) and \
            (protect_facebook_friends or (not attacker_user.is_friends_with(defender_user.social_id)))):

            # if the last attack was a long time ago, don't count it for purposes of the protection attack counter
            if (server_time - defender.protection_attack_time) >= defender.get_any_abtest_value('protection_backoff_time', gamedata['server']['protection_backoff_time']):
                defender.protection_attack_count = 0

            defender.protection_attack_count += 1 # XXX mutation
            defender.protection_attack_time = server_time

            if ladder_state:
                # for ladder battles, enable directly
                return True
            else:
                # for non-ladder battles, wait for N attacks
                if defender.protection_attack_count >= defender.get_any_abtest_value('protection_attacks', gamedata['server']['protection_attacks']):
                    return True
        else:
            # AI players, and Facebook friends, do not receive attack protection
            if (not protect_same_ip) and is_same_ip and (not attacker_user.is_friends_with(defender_user.social_id)):
                if gamedata['server']['log_alt_accounts'] >= 1:
                    gamesite.exception_log.event(server_time, 'denying protection to same-ip attack: %d vs. %d (%s) friends %d' % \
                                                 (attacker_user.user_id, defender_user.user_id, attacker_user.last_login_ip, int(attacker_user.is_friends_with(defender_user.social_id))))
            elif (not protect_same_alliance) and is_same_alliance and (not attacker_user.is_friends_with(defender_user.social_id)):
                if gamedata['server']['log_alt_accounts'] >= 1:
                    gamesite.exception_log.event(server_time, 'denying protection to same-alliance attack: %d vs. %d (%s) friends %d' % \
                                                 (attacker_user.user_id, defender_user.user_id, attacker_user.last_login_ip, int(attacker_user.is_friends_with(defender_user.social_id))))
            elif attacker.is_alt_account_unprotectable(defender.user_id):
                if gamedata['server']['log_alt_accounts'] >= 1:
                    gamesite.exception_log.event(server_time, 'denying protection to known alt account: %d vs. %d' % (attacker_user.user_id, defender_user.user_id))

        return False

    def init_attack(self, session, attacker, defender, base, ladder_state):
        # perform all necessary mutations at the start of an offensive attack
        # note: assumes all necessary locks are already taken
        is_home_attack = (base.base_type == 'home')
        attacker_is_human = attacker.is_human()
        defender_is_human = defender.is_human()

        if attacker_is_human and defender_is_human:
            revenge_togo = attacker.cooldown_togo('revenge_defender:%d' % defender.user_id)
            if revenge_togo >= 0:
                # record the fact that this is a revenge attack
                session.revenge_attack_until = server_time + revenge_togo

        defender.init_attack_defender(attacker.user_id, attacker_is_human, is_home_attack, ladder_state, session.revenge_attack_until >= 0)
        attacker.init_attack_attacker(defender.user_id, defender_is_human, is_home_attack, ladder_state, session.revenge_attack_until >= 0)

        base.base_last_attack_time = server_time
        base.base_times_attacked += 1

        # record map-attack counts
        if not is_home_attack:
            met_names = {'hive': 'hives', 'quarry': 'quarries', 'squad': 'squads'}
            if base.base_type in met_names:
                record_player_metric(attacker, dict_increment, met_names[base.base_type]+'_attacked', 1, time_series = False)

        # deal with damage protection mutation
        if defender_is_human and \
           (is_home_attack or \
            (base.base_type == 'quarry' and gamedata['territory']['quarries_affect_protection']) or \
            (base.base_type == 'squad' and gamedata['territory']['squads_affect_protection'])):
            # remove the protection timer of the player making the attack
            attacker.set_protection_end_time(session, -1,
                                             '3884_protection_removed' if attacker.has_damage_protection() else None,
                                             {'defender_id':defender.user_id})
            record_player_metric(attacker, dict_setmax, 'last_pvp_aggression_time', server_time, time_series = False)


    # deploy units against a foreign (human or AI) player
    # returns true if successful
    def do_attack(self, session, retmsg, spellargs):
        loc = spellargs[0]
        unit_id_list = spellargs[1]

        if session.home_base:
            retmsg.append(["ERROR", "SERVER_PROTOCOL"])
            return False

        if (not session.has_attacked and (session.viewing_base_lock is not None)):
            retmsg.append(["ERROR", "SERVER_PROTOCOL"])
            gamesite.exception_log.event(server_time, 'do_attack() with invalid session state: %s args [%r,%r]' % (session.dump_exception_state(), loc, unit_id_list))
            return False

        # if unit_id_list is empty, that means the client wants to start the fight but not deploy any units right away
        if len(unit_id_list) and (not session.viewing_base.is_deployment_location_valid(session.player, loc)):
            retmsg.append(["ERROR", "CANNOT_DEPLOY_INVALID_LOCATION"])
            return False

        if not session.has_attacked:
            # first deployment - check for permission to attack, and acquire locks

            attack_ok, attack_error_message = self.can_attack(session.player, session.viewing_player, session.viewing_base, session.pvp_balance, session.deployable_squads, session.ladder_state)
            if not attack_ok:
                retmsg.append(["ERROR", attack_error_message])
                return False

            # get all necessary locks
            if session.viewing_base is not session.viewing_player.my_home:
                lock_errors = []
                state = session.acquire_base(errors = lock_errors)
                if state != Player.LockState.being_attacked:
                    retmsg.append(["ERROR", lock_errors[0], "attack_nonhome"])
                    return False

                if session.viewing_player is not session.player:
                    self.broadcast_map_attack(session.viewing_base.base_region, session.viewing_base.get_cache_props(),
                                              session.player.user_id, session.viewing_player.user_id, None, # no summary -> attack start
                                              [self.get_player_cache_props(u,p,aid) for u,p,aid in ((session.user,session.player,session.alliance_id_cache),(session.viewing_user,session.viewing_player,session.viewing_alliance_id_cache))],
                                              msg = "REGION_MAP_ATTACK_START")

            elif session.viewing_player.is_human():
                state = gamesite.lock_client.player_lock_acquire_attack(session.viewing_user.user_id, session.viewing_player.generation, owner_id=session.player.user_id)
                if state == -Player.LockState.logged_in:
                    retmsg.append(["ERROR", "CANNOT_ATTACK_PLAYER_WHILE_LOGGED_IN", 1])
                    return False
                elif state == -Player.LockState.being_attacked or state < 0:
                    retmsg.append(["ERROR", "CANNOT_ATTACK_PLAYER_WHILE_ALREADY_UNDER_ATTACK"])
                    return False

                lock_errors = []
                state = session.do_acquire_base(session.viewing_player, session.viewing_player.my_home, session.deployable_squads, session.defending_squads, errors = lock_errors)
                if state != Player.LockState.being_attacked:
                    gamesite.lock_client.player_lock_release(session.viewing_user.user_id, session.viewing_player.generation, Player.LockState.being_attacked,
                                                             expected_owner_id = session.player.user_id)
                    retmsg.append(["ERROR", lock_errors[0], "attack_home"])
                    return False

                # make sure we *were* in read-only mode before starting the battle
                assert (not session.viewing_player.has_write_lock)

                # then set the flag, because we have exclusive write permission now
                session.viewing_player.has_write_lock = True

            if session.viewing_player is not session.player:
                self.init_attack(session, session.player, session.viewing_player, session.viewing_base, session.ladder_state)

            session.has_attacked = True
            session.debug_log_action('do_attack')

            session.deployed_units = {}
            session.deployed_donated_units = {}

            # count existing reinforcements
            session.deployed_unit_space = sum([obj.get_leveled_quantity(obj.spec.consumes_space) for obj in session.viewing_base.iter_objects() \
                                               if (obj.owner is session.player) and obj.is_mobile()])
            session.deployed_donated_unit_space = 0

            # look up AI base or hive
            if (session.viewing_base is session.viewing_player.my_home) and session.viewing_player.is_ai():
                ai_data = gamedata['ai_bases_server']['bases'].get(str(session.viewing_player.user_id), None)
            elif session.viewing_base.base_type == 'hive':
                ai_data = gamedata['hives_server']['templates'].get(session.viewing_base.base_template, None)
            else:
                ai_data = None

            if session.player.tutorial_state != "COMPLETE":
                attack_time = gamedata['tutorial_attack_time']
            else:
                if session.viewing_player is session.player:
                    attack_time = gamedata['reinforce_time']
                elif (ai_data and ('attack_time' in ai_data)):
                    attack_time = ai_data['attack_time']
                else:
                    if (session.viewing_base is session.viewing_player.my_home):
                        if session.viewing_player.is_human():
                            entry = 'pvp'
                        else:
                            entry = 'pve'
                    elif session.viewing_base.base_type == 'quarry':
                        entry = 'quarry'
                    elif session.viewing_base.base_type == 'hive':
                        entry = 'hive'
                    else:
                        entry = 'pvp'

                    attack_time = gamedata['attack_time'][entry]

            real_attack_finish_time = server_time + attack_time

            # NOTE: add a few-second "grace period" to prevent the client
            # and server from both trying to change the session at the
            # exact same time
            session.attack_finish_time = real_attack_finish_time + 5

            # open attack log
            replay_token = None

            if session.viewing_player is session.player:
                # reinforcement
                session.open_attack_log(-1, -1,-1)
            else:
                if ai_data and not ai_data.get('enable_battle_log',True):
                    # skip logging
                    replay_token = session.open_attack_log(-1, -1, -1)
                else:
                    replay_token = session.open_attack_log(session.attack_finish_time, session.user.user_id, session.viewing_user.user_id, base_id = session.viewing_base.base_id if (session.viewing_base is not session.viewing_player.my_home) else None)
                props_3820 =  {'attacker_user_id': session.user.user_id,
                               'attacker_level': session.player.resources.player_level,
                               'attacker_deployable_squads': session.deployable_squads.copy(),
                               'base_id': session.viewing_base.base_id,
                               'starting_base_damage': session.starting_base_damage,
                               'starting_resources': session.starting_resources,
                               'opponent_user_id':session.viewing_user.user_id,
                               'opponent_level':session.viewing_player.resources.player_level,
                               'opponent_type':session.viewing_player.ai_or_human()}
                if session.alliance_id_cache >= 0:
                    props_3820['attacker_alliance_id'] = session.alliance_id_cache
                if session.viewing_alliance_id_cache >= 0 and ((not session.viewing_player.is_ai()) or session.is_ladder_battle()):
                    props_3820['opponent_alliance_id'] = session.viewing_alliance_id_cache

                if gamedata['server'].get('log_battles',1) >= 2:
                    # add enough extra info to fully reconstruct the base on the client
                    props_3820['base'] = session.viewing_base.get_cache_props()
                    # note: these fields are not part of the cache_props but are needed to reconstruct the base
                    props_3820['base_region'] = session.viewing_base.base_region
                    props_3820['base_power_state'] = session.viewing_base.get_power_state()
                    props_3820['base_objects'] = [obj.serialize_state() for obj in session.viewing_base.iter_objects()]

                session.attack_event(session.user.user_id, '3820_battle_start', props_3820)

                if session.is_ladder_battle() and ((not session.using_squad_deployment()) or gamedata['server'].get('log_ladder_pvp_on_map',False)):
                    session.player.record_ladder_pvp_event('3305_ladder_attack_start', {'defender_id': session.viewing_player.user_id,
                                                                                        'attacker_pts': session.player.ladder_points(),
                                                                                        'defender_pts': session.viewing_player.ladder_points(),
                                                                                        'attacker_res': session.player.resources.get_fungible_amounts(),
                                                                                        'defender_res': session.viewing_player.resources.get_fungible_amounts(),
                                                                                        'battle_streak_ladder': session.player.cooldown_active('battle_streak_ladder'),
                                                                                        'ladder_state': session.ladder_state})

                censored_viewing_player_auras = session.viewing_player.player_auras_censored()
                if censored_viewing_player_auras:
                    session.attack_event(session.viewing_user.user_id, '3901_player_auras', {'player_auras':copy.deepcopy(censored_viewing_player_auras)})

                # defender's standing army
                session.log_attack_units(session.viewing_user.user_id, filter(lambda obj: obj.owner is session.viewing_player, session.iter_objects()), '3900_unit_exists')
                # for skill challenges, where friendly units are "baked" into the base
                session.log_attack_units(session.user.user_id, filter(lambda obj: obj.owner is session.player, session.iter_objects()), '3900_unit_exists')

                if session.damage_log: session.damage_log.init_multi(session.iter_objects())
                censored_player_auras = session.player.player_auras_censored(deployment_allowed = session.viewing_base.deployment_allowed)
                if censored_player_auras:
                    session.attack_event(session.user.user_id, '3901_player_auras', {'player_auras':copy.deepcopy(censored_player_auras)})

            retmsg.append(["PLAYER_ATTACK_WAVE_DEPLOYED", real_attack_finish_time, replay_token])


            if session.viewing_player is not session.player:
                session.activity_classifier.attacked_base(session.viewing_player, session.viewing_base, using_squads = session.using_squad_deployment())

                if session.using_squad_deployment():
                    if session.increment_player_metric('squad_attacks_launched', 1, time_series = False):
                        pass # session.deferred_history_update = True

            # INITIAL damage protection calculation
            # at the start of the battle, we check whether any damage protection is potentially available (based on recent attacks, who is attacking, etc)
            # if available, set protection_eligible True
            # after the battle, we'll calculate the exact amount of time based on damage done

            session.protection_eligible = self.is_protection_eligible(session, session.player, session.user,
                                                                      session.viewing_player, session.viewing_user,
                                                                      session.viewing_base, session.ladder_state)

            if ai_data and ('on_attack' in ai_data):
                session.execute_consequent_safe(ai_data['on_attack'], session.player, retmsg, reason='on_attack')

            session.deferred_player_state_update = True # for removal of protection time etc

        deployment_limit = session.player.stattab.get_player_stat('deployable_unit_space')

        # dump mobile units from player's base into the session
        units = []

        # unit_id_list takes the form
        # [{'obj_id':'2345sdfg234','source':'home_or_squad'}, # regular home or squad unit
        #  {'obj_id':'DONATED-1234','source':'donated'}, # donated unit
        #  ...]
        for entry in unit_id_list:
            source = entry.get('source', 'home_or_squad')
            obj_id = entry['obj_id']

            if session.has_object(obj_id):
                # already deployed
                retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION_ALREADY_DEPLOYED", obj_id, 'already deployed'])
                continue

            if source == 'donated':
                entry = session.player.donated_units.get(obj_id, None)
                if not entry:
                    retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION_MISSING_DONATED_UNIT", obj_id, 'not found in donated_units'])
                    continue

                spec = session.player.get_abtest_spec(GameObjectSpec, entry['spec'])
                # skip inapplicable units
                if (not session.viewing_base.can_deploy_unit(spec)): continue
                level = entry.get('level', session.player.tech.get(spec.level_determined_by_tech, 1))

                unit = instantiate_object_for_player(session.player, session.player, entry['spec'], x=loc[0], y=loc[1], level=level, obj_id=obj_id)
                space = unit.get_leveled_quantity(unit.spec.consumes_space)

                if gamedata['donated_units_take_space']:
                    if (session.deployed_unit_space + space) > deployment_limit:
                        retmsg.append(["ERROR", "CANNOT_DEPLOY_MORE_UNITS"])
                        break
                    session.deployed_unit_space += space

                session.deployed_donated_unit_space += space # count this regardless of whether they take space

                units.append((unit,{'method':'donated'}))
                entry['stack'] = entry.get('stack', 1) - 1
                if entry['stack'] <= 0:
                    del session.player.donated_units[obj_id]

                session.deferred_donated_units_update = True

            else:
                unit = None

                # when attacking out of home base, you can attack with undeployed squads (acutal deployability is tested below)
                unit = session.player.get_object_by_obj_id(obj_id, fail_missing = False)
                is_squad_object = False

                if not unit: # search squads
                    if gamesite.nosql_client and session.player.home_region:
                        state = gamesite.nosql_client.get_mobile_object_by_id(session.player.home_region, obj_id, reason='do_attack')
                        if state:
                            unit = reconstitute_object(session.player, session.player, state, context = '%d vs %d at %s deploy attack' % (session.player.user_id, session.viewing_player.user_id, session.viewing_base.base_id))
                            is_squad_object = True

                if (not unit) or (unit.hp <= 0) or (session.player.squad_base_id(unit.squad_id or 0) not in session.deployable_squads):
                    # unit might have been destroyed while message was in flight
                    if (not unit):
                        retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION_UNIT_NOT_FOUND", obj_id])
                    elif (unit.hp <= 0):
                        retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION_UNIT_DEAD", obj_id])
                    elif (session.player.squad_base_id(unit.squad_id or 0) not in session.deployable_squads):
                        retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION_UNIT_NOT_DEPLOYABLE", obj_id])
                    continue

                if (not session.viewing_base.can_deploy_unit(unit.spec)):
                    retmsg.append(["ERROR", "CANNOT_DEPLOY_INVALID_LOCATION"])
                    continue

                if (session.deployed_unit_space + unit.get_leveled_quantity(unit.spec.consumes_space)) > deployment_limit:
                    retmsg.append(["ERROR", "CANNOT_DEPLOY_MORE_UNITS"])
                    break

                session.player.unit_repair_cancel(unit)

                session.deployed_unit_space += unit.get_leveled_quantity(unit.spec.consumes_space)
                units.append((unit, {'method':'from_home', 'squad_id':unit.squad_id or 0}))

                if unit.spec.consumable: # dispose the object right here
                    if is_squad_object:
                        gamesite.nosql_client.drop_mobile_object_by_id(session.player.home_region, obj_id, reason='do_attack(consumable)')
                    else:
                        session.player.home_base_remove(unit)
                    session.player.send_army_update_destroyed(unit, retmsg)

        for unit, props in units:
            # last-chance check on unit level
            unit.ensure_level(session.player.tech.get(unit.spec.level_determined_by_tech, 1))

            session.add_object(unit)

            # fake_xy fudges the position of the object to the
            # client's requested attack location. The server won't
            # record the change permanently.

            retmsg.append(["OBJECT_CREATED2", unit.serialize_state(fake_xy = loc)])

            # add "weak unit" debuffs
            unit.apply_weak_unit_debuffs(True)
            if unit.auras:
                retmsg.append(["OBJECT_AURAS_UPDATE", unit.serialize_auras()])

            session.log_attack_unit(session.user.user_id, unit, '3910_unit_deployed', fake_xy = loc, props = props)
            if session.damage_log:
                # need to think about how to track donated units (props['method']=='donated')
                session.damage_log.init(unit)

            # record for analytics
            session.deployed_units[unit.spec.name] = session.deployed_units.get(unit.spec.name,0) + 1
            if props['method'] == 'donated':
                session.deployed_donated_units[unit.spec.name] = session.deployed_donated_units.get(unit.spec.name,0) + 1

        return True # success!

    def push_gamedata(self, session, retmsg):
        data_str = open(SpinConfig.gamedata_filename()).read()
        retmsg.append(["PUSH_GAMEDATA", data_str, session.player.abtests])

    def send_offline_notification(self, to_user_id, to_social_id, text, sp_ref, fb_ref, summary_props,
                                  locale = None, replacements = None, mirror_to_facebook = False):
        # "sp_ref" = our internal ref parameter
        # "fb_ref" = the "ref" URL parameter to send to Facebook - may include _e/_n suffix after sp_ref

        # the individual send_offline_notification_*() calls return Deferreds that resolve to a list
        # of the utm_media names on which notifications were sent, or None if a notification will not be sent.

        if to_social_id.startswith('fb'):
            message = self.NotificationMessage(sp_ref, fb_ref, replacements, text, 'fb', locale = locale)
            d_sent = self.send_offline_notification_fb(to_user_id, to_social_id[2:], message)
        elif to_social_id.startswith('bh'):
            message = self.NotificationMessage(sp_ref, fb_ref, replacements, text, 'bh', locale = locale)
            d_sent = self.send_offline_notification_bh(to_user_id, to_social_id[2:], message, mirror_to_facebook = mirror_to_facebook)
        else:
            d_sent = None

        if d_sent:
            # update last_mtime so ETL script picks up the user next time around
            gamesite.pcache_client.player_cache_update(to_user_id, {'last_mtime': server_time})

            # wait for the notification request to finish, then record which media it was sent on
            d_sent.addCallback(lambda media_list, to_user_id=to_user_id, \
                               summary_props=summary_props, sp_ref=sp_ref, fb_ref=fb_ref: \
                               (not media_list) or \
                               metric_event_coded(to_user_id,
                                                  '7130_fb_notification_sent',
                                                  {'sum': summary_props,
                                                   'ref': sp_ref,
                                                   'fb_ref': fb_ref,
                                                   'media': media_list}))
        return bool(d_sent)

    # pack up the localized ui_* parameters for an outgoing notification
    # messages can have
    # text only, no sp_ref, so sp_ref.email: just a one-line message
    # text and sp_ref, no sp_ref.email: one-line message with extra tracking params
    # text and sp_ref and sp_ref.email: full notification suitable for use with bh.com email system

    class NotificationMessage(object):
        def __init__(self, sp_ref, fb_ref, replacements, text, frame_platform, format = None, locale = None):
            self.sp_ref = sp_ref
            self.fb_ref = fb_ref
            self.format = format or 'game' # 'game' or 'bh', only as a cue to the client for how to display it

            conf = gamesite.get_localized_gamedata('fb_notifications', locale)['notifications'].get(sp_ref)

            if text:
                if isinstance(text, str):
                    text = text.decode('utf-8')
                self.ui_body = self.apply_replacements(replacements, text)
            elif conf:
                self.ui_body = self.apply_replacements(replacements, conf['ui_name'])
            else:
                raise Exception('notification needs either "text" or a valid "ref"')

            self.has_email = False # whether bh notifications should have email method enabled
            self.ui_subject = None
            self.ui_headline = None
            self.ui_cta = None

            if conf:
                email_conf = conf.get('email')
                if email_conf:
                    self.has_email = True
                    self.ui_subject = self.apply_replacements(replacements, email_conf['ui_subject'])
                    self.ui_headline = self.apply_replacements(replacements, email_conf['ui_headline'])
                    self.ui_cta = self.apply_replacements(replacements, email_conf['ui_cta'])
                elif frame_platform == 'bh':
                    if sp_ref != 'bh_web_push_incentive': # special case
                        raise Exception('need full "email" data for notification ref %s' % sp_ref)

        def serialize(self): # return JSON format to send to client
            ret = {'format': self.format,
                   'ui_body': self.ui_body}
            if self.ui_subject: ret['ui_subject'] = self.ui_subject
            if self.ui_headline: ret['ui_headline'] = self.ui_headline
            if self.ui_cta: ret['ui_cta'] = self.ui_cta
            return ret

        @staticmethod
        def apply_replacements(replacements, text):
            if replacements:
                for k, v in replacements.iteritems():
                    text = text.replace(k, v)
            return text

    def send_offline_notification_bh(self, to_user_id, to_bh_id, message, mirror_to_facebook = False):
        params = {'service': SpinConfig.game(),
                  'ui_body': message.ui_body.encode('utf-8'),
                  'query': 'bh_source=notification&ref=%s&fb_ref=%s' % (message.sp_ref, message.fb_ref),
                  'tags': SpinConfig.game()+'_'+message.fb_ref,
                  }
        if message.ui_subject: params['ui_subject'] = message.ui_subject.encode('utf-8')
        if message.ui_headline: params['ui_headline'] = message.ui_headline.encode('utf-8')
        if message.ui_cta: params['ui_cta'] = message.ui_cta.encode('utf-8')

        if mirror_to_facebook:
            params['facebook'] = '1'

        if not message.has_email:
            params['email'] = '0'

        url = SpinConfig.config['battlehouse_api_path'] + '/user/' + to_bh_id + '/notify'

        if not SpinConfig.config['enable_battlehouse']:
            gamesite.exception_log.event(server_time, 'Battlehouse disabled: BH notification POST %s query %r' % (url, params))
            return None

        params['api_secret'] = SpinConfig.config['battlehouse_api_secret'] # add secret at the last moment
        d = gamesite.AsyncHTTP_Battlehouse.queue_request_deferred(server_time, url, method = 'POST', postdata = params)

        # success: return media list
        def on_success(response_raw):
            response = SpinJSON.loads(response_raw)
            if 'result' in response:
                return response['result'].keys() # list of media that succeeded
            return []
        # failure: report and return empty list
        def on_fail(fail):
            gamesite.battlehouse_log.event(server_time, 'send_offline_notification_bh exception: %s\n%s' % \
                                           (fail.getTraceback().strip(), fail.getErrorMessage().strip()))
            return []
        d.addCallbacks(on_success, on_fail)

        return d

    def send_offline_notification_fb(self, to_user_id, to_facebook_id, message):
        # see http://developers.facebook.com/docs/app_notifications/
        params = {'href': '',
                  'ref': message.fb_ref,
                  'template': message.ui_body.encode('utf-8') }
        url = SpinFacebook.versioned_graph_endpoint_secure('notification', str(to_facebook_id)+'/notifications')

        if not SpinConfig.config['enable_facebook']:
            gamesite.exception_log.event(server_time, 'Facebook disabled: FB notification POST %s query %r' % (to_facebook_id, params))
            return None

        d = gamesite.AsyncHTTP_Facebook.queue_request_deferred(server_time, url, method = 'POST',
                                                               postdata = urllib.urlencode(params))

        # failure: report and return empty list
        def on_fail(fail):
            gamesite.facebook_log.event(server_time, 'send_offline_notification_fb exception: %s\n%s' % \
                                        (fail.getTraceback().strip(), fail.getErrorMessage().strip()))
            return []
        d.addCallbacks(lambda _: ['facebook'], on_fail)

        return d

    def do_send_gifts_bh(self, session, client_id_list):
        if session.user.frame_platform != 'bh':
            session.send([["ERROR", "SERVER_PROTOCOL"]])
            return None

        replacements = {'%MY_UI_NAME': session.user.get_ui_name(session.player),
                        '%MY_UI_AND_REAL_NAME': session.user.get_ui_and_real_name(session.player)}

        to_send = []

        # note: check that the client supplies a valid player_id, but do not
        # bother testing whether the recipient qualifies as "bh_invite_complete" -
        # it's not a big deal if players send daily gifts to incomplete trainees.

        # to my mentor
        if session.user.bh_mentor_player_id_cache and \
           (session.user.bh_mentor_player_id_cache in client_id_list) and \
           (not session.player.cooldown_active('send_gift:%d' % session.user.bh_mentor_player_id_cache)):
            to_send.append(session.player.make_system_mail(gamesite.get_localized_gamedata('strings', gamesite.get_locale_for_player(session.user.bh_mentor_player_id_cache, reason = 'bh_invite_mentor_gift_mail'))['bh_invite_mentor_gift_mail'],
                                                           duration = gamedata['gift_interval'],
                                                           to_user_id = session.user.bh_mentor_player_id_cache, replacements = replacements,
                                                           extra_props = {'unique_per_sender': 'bh_invite_daily_gift'}))

            gamesite.do_CONTROLAPI(session.user.user_id, {'method':'send_notification','reliable':1,
                                                          'send_ingame':0,'send_offline':1,'format':'bh',
                                                          'user_id':session.user.bh_mentor_player_id_cache,
                                                          'replacements':SpinJSON.dumps(replacements),
                                                          'config':'bh_invite_daily_gift'})

        # to my trainees
        if session.user.bh_trainee_player_ids_cache:
            recipient_ids = filter(lambda id: id in session.user.bh_trainee_player_ids_cache, client_id_list)
            recipient_ids = filter(lambda id: not session.player.cooldown_active('send_gift:'+str(id)), recipient_ids)
            if recipient_ids:
                # group by language
                recipient_pcaches = gamesite.pcache_client.player_cache_lookup_batch(recipient_ids, fields = ['locale'], reason = 'do_send_gifts_bh')
                recipient_ids_by_locale = {}
                for id, pc in zip(recipient_ids, recipient_pcaches):
                    locale = pc.get('locale') if pc else None
                    if locale not in recipient_ids_by_locale: recipient_ids_by_locale[locale] = []
                    recipient_ids_by_locale[locale].append(id)

                for locale, recipient_ids_this_locale in recipient_ids_by_locale.iteritems():
                    to_send.append(session.player.make_system_mail('bh_invite_trainee_gift_mail',
                                                                   duration = gamedata['gift_interval'],
                                                                   to_user_id_list = recipient_ids_this_locale, replacements = replacements,
                                                                   extra_props = {'unique_per_sender': 'bh_invite_daily_gift'}))
                for recipient_id in recipient_ids:
                    gamesite.do_CONTROLAPI(session.user.user_id, {'method':'send_notification','reliable':1,
                                                                  'send_ingame':0,'send_offline':1,'format':'bh',
                                                                  'user_id':recipient_id,
                                                                  'replacements':SpinJSON.dumps(replacements),
                                                                  'config':'bh_invite_daily_gift'})


        all_recipient_ids = sum((msg['to'] for msg in to_send), [])

        if len(to_send) > 0:
            gamesite.msg_client.msg_send(to_send)

            for recipient_id in all_recipient_ids:
                session.player.cooldown_trigger('send_gift:'+str(recipient_id), gamedata['gift_interval'])
            session.deferred_player_cooldowns_update = True

            session.increment_player_metric('gifts_sent', len(all_recipient_ids), time_series = False, bucket = True)
            session.deferred_history_update = True

            metric_event_coded(session.user.user_id, '4120_send_gift_completed',
                               {'sum': session.player.get_denormalized_summary_props('brief'),
                                'recipients': all_recipient_ids
                                })

        session.send([["SEND_GIFTS_BH_COMPLETE", all_recipient_ids]])
        return None

    def do_send_gifts(self, session, retmsg, arg):
        if session.user.frame_platform == 'bh':
            session.send([["ERROR", "SERVER_PROTOCOL"]])
            return None

        pred_or_literal = session.player.get_any_abtest_value('enable_resource_gifts', gamedata.get('enable_resource_gifts',False))
        if (not pred_or_literal) or \
           (isinstance(pred_or_literal, dict) and \
            (not Predicates.read_predicate(pred_or_literal).is_satisfied2(session, session.player, None))):
            session.send([["ERROR", "SERVER_PROTOCOL"]])
            return

        request_id = arg[1]
        recipient_user_id_list = arg[2]

        db_message = { 'from': session.player.user_id,
                       'to': [], # will be filled in below
                       'type': 'resource_gift',
                       'expire_time': server_time + gamedata['server']['message_expire_time']['resource_gift'],
                       'from_pcache': self.get_player_cache_props(session.user, session.player, session.alliance_id_cache),
                       'unique_per_sender': 'resource_gift'}

        for recipient_user_id in recipient_user_id_list:
            if (not recipient_user_id) or recipient_user_id <= 0 or recipient_user_id == session.user.user_id:
                continue

            # note: this is susceptible to client-side spoofing, sending invalid user_ids, or picking user_ids out of thin air!

            # check if we can still send a gift to this recipient today
            if session.player.cooldown_active('send_gift:'+str(recipient_user_id)):
                continue

            db_message['to'].append(recipient_user_id)

            # the gift will be successfully queued, now remember that we sent it so we can't send one again too quickly
            session.player.cooldown_trigger('send_gift:'+str(recipient_user_id), gamedata['gift_interval'])
            #session.user.create_fb_open_graph_action('sent_gift', {'profile': fbid})
            session.deferred_player_cooldowns_update = True

        if len(db_message['to']) > 0:
            gamesite.msg_client.msg_send([db_message])
            session.increment_player_metric('gifts_sent', len(db_message['to']), time_series = False, bucket = True)
            props = {'recipients':db_message['to']}
            if request_id: props['request_id'] = request_id
            metric_event_coded(session.user.user_id, '4120_send_gift_completed', props)
            session.deferred_history_update = True

    @catch_all('do_receive_mail')
    def do_receive_mail(self, session, retmsg, is_login = False, type_filter = None):
        ret = {
            'was_attacked': False, # True if battle history should be shown upon login
            'new_mail': False # True if player received new in-game mail
            }

        if session.player.tutorial_state != "COMPLETE":
            return ret

        # count number of gifts and resources received within last 24 hours
        interval = gamedata['gift_interval']
        gift_origin = int(server_time/interval) * interval
        gift_count = 0
        gift_total = 0
        to_remove = []
        for gift in session.player.received_gifts:
            if gift['time'] >= gift_origin:
                gift_count += 1
                gift_total += gift['amount']
            else:
                # get rid of old entries
                to_remove.append(gift)
        for gift in to_remove:
            session.player.received_gifts.remove(gift)

        starting_gift_count = gift_count
        max_res = session.player.get_max_storage()


        # for bulletproof atomicity, wrap the code in a try: block and
        # ensure that gifts are dequeued if and only if the resources are given

        messages = gamesite.msg_client.msg_recv(session.user.user_id, type_filter = type_filter)
        to_ack = []

        try:
            for msg in messages:
                if msg['type'] == 'resource_gift':

                    if gamedata.get('gift_mail_template',None):
                        template = gamedata['gift_mail_template'] # XXX should be in gamedata['strings'], and pass as string
                        amount = 1 # for compatibility with metrics below
                        # since we're generating a new mail, we have to set the duration to the original duration minus how long it sat in the queue
                        duration = gamedata['server']['message_expire_time']['resource_gift'] - (server_time - msg['time'])
                        if duration > 0:
                            time_struct = time.gmtime(server_time)
                            if 'from_pcache' in msg:
                                from_ui_name = pcache_get_ui_name(msg['from_pcache'])
                            elif 'from_name' in msg:
                                from_ui_name = msg['from_name']
                            else:
                                from_ui_name = 'Unknown'
                            session.player.mailbox_append(session.player.make_system_mail(template,
                                                                                          duration = duration,
                                                                                          replacements = {'%SENDER': from_ui_name,
                                                                                                          '%DAY': time.strftime('%d %b %Y', time_struct),
                                                                                                          '%TIME': time.strftime('%H:%S', time_struct)}))
                            ret['new_mail'] = True

                    else:
                        if not is_login: continue # only retrieve fungible resource gifts on login

                        # legacy resource gift: fungible resources
                        gift = {}

                        gift_amount_ratio = gamedata['gift_amount_base']
                        decay = gamedata['gift_amount_decay']
                        if decay < 1:
                            gift_amount_ratio *= math.pow(decay, gift_count)

                        noise = gamedata['gift_amount_randomness']
                        if noise > 0:
                            gift_amount_ratio = gift_amount_ratio * (1 + noise * (2*random.random()-1))

                        gift_amount_ratio = min(max(gift_amount_ratio, 0), 1)

                        res = 'water' if random.random() >= 0.5 else 'iron'
                        gift[res] = max(int(gift_amount_ratio * max_res[res]), 1)

                        original_gift = gift # save uncapped amounts for the UI display
                        gift = session.player.resources.gain_res(gift, reason='received_gift')
                        session.deferred_player_state_update = True
                        amount = sum(gift.itervalues(),0)
                        admin_stats.econ_flow_player(session.player, 'gifts', 'gifts', gift)
                        retmsg.append(["RECEIVED_GIFT2", msg['from'], msg.get('from_pcache',None), original_gift])

                    to_ack.append(msg['msg_id'])
                    session.increment_player_metric('gifts_received', 1, time_series = False, bucket = True)
                    session.player.received_gifts.append({'time':server_time, 'from':msg['from'], 'amount':amount})
                    gift_count += 1
                    gift_total += amount

                elif msg['type'] == 'system_refund':
                    loot = msg['loot']
                    loot = session.player.resources.gain_res(loot, reason=msg['type'])
                    to_ack.append(msg['msg_id'])
                    admin_stats.econ_flow_player(session.player, 'consumption', msg.get('reason', msg['type']), loot)
                    retmsg.append(["SYSTEM_REFUND", loot, msg['ui_reason']])

                elif msg['type'] == 'alliance_status_changed':
                    # this is an async notification that your request to join an alliance was accepted by the leader, or you were kicked
                    to_ack.append(msg['msg_id'])
                    ret['new_alliance'] = True

                    # reset donation counters here, since it may be asynchronous with ALLIANCE_JOIN
                    session.setvalue_player_metric('units_donated_cur_alliance', 0, time_series = False)
                    session.setvalue_player_metric('help_responses_cur_alliance', 0, time_series = False)

                    if (not is_login):
                        # async alliance status change - update cached state and notify player
                        my_alliance_info, my_alliance_membership = session.init_alliance(retmsg, chat_catchup = False, reason='do_receive_mail')
                        retmsg.append(["ALLIANCE_UPDATE", my_alliance_info['id'] if my_alliance_info else -1, False, my_alliance_info, my_alliance_membership, False])

                elif msg['type'] == 'alliance_role_changed':
                    to_ack.append(msg['msg_id'])
                    ret['new_alliance_role'] = True
                    my_alliance_info, my_alliance_membership = session.init_alliance(retmsg, chat_catchup = False, reason='do_receive_mail')
                    retmsg.append(["ALLIANCE_UPDATE", my_alliance_info['id'] if my_alliance_info else -1, False, my_alliance_info, my_alliance_membership, True])

                elif msg['type'] == 'cooldown_trigger':
                    end_time = msg['end_time']
                    if end_time > server_time:
                        session.player.cooldown_trigger(msg['cooldown_name'], end_time - server_time)
                        retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])
                    to_ack.append(msg['msg_id'])

                elif msg['type'] == 'apply_aura':
                    end_time = msg['end_time']
                    if end_time > server_time:
                        if msg['aura_name'] in gamedata['auras']:
                            if msg.get('remove_by_name_first'):
                                session.remove_player_aura(msg['aura_name'], force = True)
                            session.apply_player_aura(msg['aura_name'],
                                                      strength = msg.get('aura_strength',1),
                                                      level = msg.get('aura_level',1),
                                                      data = msg.get('aura_data',None),
                                                      duration = end_time - server_time, ignore_limit = True)

                    to_ack.append(msg['msg_id'])

                elif msg['type'] == 'chat_report':
                    if session.player.cooldown_active('chat_reportable') and (msg['expire_time'] > server_time):
                        cons = gamedata.get('chat_report_recv_action', None)
                        if cons:
                            session.execute_consequent_safe(cons, session.player, retmsg, context = {'report_stack':msg.get('report_stack',1)}, reason='chat_report_recv_action')
                    to_ack.append(msg['msg_id'])

                elif msg['type'] == 'squad_cargo':
                    session.player.squad_collect_cargo(msg['cargo'], msg['cargo_source'])
                    session.deferred_player_state_update = True
                    to_ack.append(msg['msg_id'])

                elif msg['type'] == 'i_attacked_you':
                    summary = msg['summary']

                    # write battle summary into both recent_attacks and the battle history
                    if ('base_id' not in summary) or summary['base_id'] == home_base_id(session.player.user_id):
                        # only put home-base attacks into recent_attacks
                        session.player.recent_attacks.append(Player.battle_summary_to_recent_attack(summary))
                    else:
                        # show battle history upon login when there are new entries NOT reflected in the "You've been Attacked" message
                        ret['was_attacked'] = False # disable this for now, let the client do it

                    session.player.increment_battle_statistics(summary['attacker_id'], summary)
                    if not is_login: # login path sends this unconditionally
                        session.deferred_battle_history_update = True

                    to_ack.append(msg['msg_id'])

                elif msg['type'] == 'you_attacked_me':
                    summary = msg['summary']
                    stats = msg['stats']

                    # increment XP here
                    if stats.get('xp'):
                        self.give_xp(session, retmsg, stats['xp'], 'you_attacked_me_mail', None)

                    session.player.increment_battle_statistics(summary['defender_id'], summary)
                    if not is_login: # login path sends this unconditionally
                        session.deferred_battle_history_update = True
                    session.player.modify_scores(stats, reason = 'you_attacked_me mail(attacker)')

                    # send trophy update to attacker
                    retmsg.append(["PLAYER_CACHE_UPDATE", [self.get_player_cache_props(session.user, session.player, session.alliance_id_cache)]])

                    # add battle fatigue on attacker against this victim
                    fatigue_cdname = ('ladder_fatigue' if summary['loot'].get('trophies_pvp') else 'battle_fatigue')
                    if gamedata['anti_bullying']['enable_'+fatigue_cdname]:
                        # for MAP ladder battles, only apply fatigue on victory
                        if fatigue_cdname != 'ladder_fatigue' or summary['attacker_outcome'] == 'victory':
                            duration = Predicates.eval_cond(gamedata['anti_bullying'][fatigue_cdname+'_duration'], session, session.player)
                            if duration > 0:
                                session.player.cooldown_trigger(fatigue_cdname+':%d' % summary['defender_id'], duration, add_stack = 1)
                                session.deferred_player_cooldowns_update = True

                    to_ack.append(msg['msg_id'])

                elif msg['type'] == 'mail':
                    if 'discard_if' in msg and (msg['discard_if'] in gamedata['predicate_library']):
                        if Predicates.read_predicate({'predicate':'LIBRARY', 'name':msg['discard_if']}).is_satisfied2(session, session.player, None):
                            # ack and discard
                            to_ack.append(msg['msg_id'])
                            continue

                    if 'receipt_duration' in msg:
                        if msg['receipt_duration'] < 0:
                            if 'expire_time' in msg:
                                del msg['expire_time']
                        else:
                            msg['expire_time'] = server_time + msg['receipt_duration']

                    if 'attachments_loot_table' in msg:
                        # add attachments with result from a loot table
                        if msg['attachments_loot_table'] in gamedata['loot_tables']:
                            loot_items = session.get_loot_items(session.player, gamedata['loot_tables'][msg['attachments_loot_table']]['loot'], -1, -1)
                            if isinstance(msg.get('attachments'), list):
                                msg['attachments'] += loot_items
                            else:
                                msg['attachments'] = loot_items

                        else:
                            gamesite.exception_log.event(server_time, 'mail referenced invalid attachments_loot_table %s' % msg['attachments_loot_table'])

                        del msg['attachments_loot_table']

                    session.player.mailbox_append(msg, safe_not_to_copy = True)
                    ret['new_mail'] = True

                    gift_order = msg.get('gift_order', None)
                    if gift_order:
                        item_name = 'alloy' if SpinConfig.game()=='mf' else 'gamebucks'
                        gift_amount = sum([x.get('stack',1) for x in msg.get('attachments',[]) if x['spec'] == item_name])
                        session.increment_player_metric('gift_orders_received', 1)
                        session.increment_player_metric('gamebucks_received_from_gift_orders', gift_amount)

                        config = gamesite.get_localized_gamedata('fb_notifications', gamesite.get_locale_for_player(msg['from'], reason = 'do_receive_mail(gift_order)'))['notifications'].get('your_gift_order_was_received',None)
                        if config and msg.get('from_fbid'):
                            notif_text = config['ui_name'].replace('%GAMEBUCKS_AMOUNT', str(gift_amount)).replace('%RECEIVER', session.user.get_chat_name(session.player)).replace('%GAMEBUCKS_NAME',gamedata['store']['gamebucks_ui_name'])
                            gamesite.do_CONTROLAPI(session.user.user_id, {'method':'send_notification','reliable':1,'user_id':msg['from'],'text':notif_text,'config':'your_gift_order_was_received','force':1})

                    gift_order_refund = msg.get('gift_order_refund', None)
                    if gift_order_refund:
                        gift_amount = msg.get('gamebucks',0)
                        if gift_amount != 0:
                            session.player.resources.gain_gamebucks(-gift_amount, reason='gift_order_refund')
                            session.increment_player_metric('gift_orders_received_then_refunded', 1)
                            session.increment_player_metric('gamebucks_refunded_from_received_gift_orders', gift_amount)

                    to_ack.append(msg['msg_id'])

                    if 'on_receipt' in msg and msg['on_receipt'] in gamedata['consequent_library']:
                        context = {}
                        if 'from' in msg: context['sender_id'] = msg['from']
                        session.execute_consequent_safe({'consequent':'LIBRARY', 'name':msg['on_receipt']}, session.player, retmsg,
                                                        context = context, reason='mail_on_receipt')

                elif msg['type'] == 'donated_units':
                    # XXX check for capacity limit?
                    units = msg['attachments']
                    for entry in units: # these come in the form [{'spec':'asdf','stack':3},...]
                        for i in xrange(entry.get('stack',1)):
                            session.player.add_donated_unit(entry['spec'], level = entry.get('level', None))
                    retmsg.append(["DONATED_UNITS_UPDATE", session.player.donated_units])
                    retmsg.append(["DONATED_UNITS_RECEIVED", units, msg.get('from',-1), msg.get('from_fbid','-1'), msg.get('from_name','unknown')])
                    to_ack.append(msg['msg_id'])
                    session.increment_player_metric('donated_units_received', sum([item.get('stack',1) for item in units]), time_series = False)
                    metric_event_coded(session.player.user_id, '4160_unit_donation_received', {'units':units,'from':msg['from']})

                elif msg['type'] == 'help_complete':
                    self.do_help_request_complete(session, retmsg, msg['from_name'], msg['req'])
                    to_ack.append(msg['msg_id'])

                elif msg['type'] == 'TRIALPAYAPI_payment':
                    try:
                        gamesite.trialpayapi.handle_payment(None, session, msg['their_hash'], msg['request_args'], msg['request_body'])
                    except:
                        gamesite.exception_log.event(server_time, 'TRIALPAYAPI_payment API fail on user %d payment %r: ' % (session.user.user_id, msg.get('request_args')) + traceback.format_exc().strip()) # OK
                        pass
                    to_ack.append(msg['msg_id'])

                elif msg['type'] == 'FBRTAPI_payment':
                    try:
                        status = 'UNKNOWN'
                        response = msg['response']
                        payment_id = msg['payment_id']
                        request_id = response.get('request_id', 'UNKNOWN_REQUEST_'+str(payment_id))
                        if request_id in session.player.fbpayments_inflight:
                            status = 'INFLIGHT'
                        else:
                            for entry in session.player.history.get('money_purchase_history',[]):
                                if ('payment_id' in entry) and str(entry['payment_id']) == str(payment_id):
                                    status = 'COMPLETED'
                                    break

                        if status == 'INFLIGHT':
                            # ping and return
                            session.user.ping_fbpayment_complete(None, session, retmsg, request_id, {'data':[response]})
                        elif status == 'COMPLETED':
                            # check for chargebacks
                            if session.user.ping_fbpayment_check_refund(session, retmsg, payment_id, {'data':[response]}):
                                ret['new_mail'] = True

                        else:
                            # hmm, looks like Facebook created an order out of thin air, or brought an old order back from the dead.

                            url = str(response['items'][0]['product'])
                            qs = urlparse.parse_qs(urlparse.urlparse(url).query)
                            payment_data = None

                            client_price = client_currency = None
                            for action in reversed(response['actions']):
                                if action['type'] == 'charge' and action['status'] == 'completed':
                                    client_price = float(action['amount'])
                                    client_currency = action['currency']
                                    break
                                elif action['type'] == 'charge' and action['status'] == 'failed':
                                    status = 'FAILED'
                                    break

                            spellname = spellarg = None
                            if client_price and client_currency:
                                # look for a zombie SKU slate order
                                if ('type' in qs) and (qs['type'][0] == OGPAPI.object_type('sku')):
                                    spellname = qs['spellname'][0]
                                    url_props = {'type':OGPAPI.object_type('sku'), 'spellname': spellname}
                                    if 'want_loot' in qs:
                                        url_props['want_loot'] = qs['want_loot'][0]
                                        spellarg = {'want_loot': bool(int(qs['want_loot'][0]))}
                                    if not OGPAPI_instance.matches_object_endpoint(url, url_props):
                                        gamesite.exception_log.event(server_time, 'fbpayment URL mismatch: got %s expected %s' % \
                                                                     (url, OGPAPI_instance.get_object_endpoint(url_props)))
                                        raise Exception('fbpayment URL mismatch')

                                # look for an order that buys in-game currency directly on the OG currency object, like a payer promo
                                elif OGPAPI_instance.matches_object_endpoint(url, {'type':OGPAPI.object_type('gamebucks')}):
                                    spellname = 'FB_GAMEBUCKS_PAYMENT'
                                    spellarg = response['items'][0]['quantity']

                            if spellname:
                                status = 'SYNTHESIZED'
                                payment_data = { 'id': payment_id,
                                                 'request_id': request_id,
                                                 'synthesized': 1,
                                                 'unit_id': GameObject.VIRTUAL_ID,
                                                 'spellname': spellname,
                                                 'spellarg': spellarg,
                                                 'client_price': client_price, 'client_currency': client_currency,
                                                 'product_url': url,
                                                 'init_quantity': response['items'][0]['quantity'],
                                                 'time': server_time, 'server_time_according_to_client': server_time,
                                                 'state': 'new' }
                                session.player.fbpayments_inflight[request_id] = payment_data
                                session.user.ping_fbpayment_complete(None, session, retmsg, request_id, {'data':[response]})

                        if (status not in ('INFLIGHT','COMPLETED','FAILED','SYNTHESIZED')) or gamedata['server']['log_fbpayments'] >= 2:
                            gamesite.exception_log.event(server_time, 'FBRTAPI_payment API call on user %d payment %s request_id %s: items %s actions %s status %s' % (session.user.user_id, payment_id, request_id, str(response['items']), str(response['actions']), status)) # OK

                    except:
                        gamesite.exception_log.event(server_time, 'FBRTAPI_payment API fail on user %d payment %s: ' % (session.user.user_id, msg['payment_id']) + traceback.format_exc().strip()) # OK
                        pass
                    to_ack.append(msg['msg_id'])

                elif msg['type'] == 'XSAPI_payment':
                    try:
                        request_data = msg['response'] # note: we don't check the signature, assuming proxyserver checked it already.
                        payment_id = request_data['transaction']['id']
                        # don't re-run an already-completed payment
                        found = False
                        for entry in session.player.history.get('money_purchase_history',[]):
                            if ('order_id' in entry) and str(entry['order_id']) == str(payment_id):
                                found = True
                                break

                        if not found: # run the payment
                            gamesite.xsapi.handle_payment(None, session, request_data)
                            gamesite.exception_log.event(server_time, 'XSAPI_payment API success on user %d payment %s' % (session.user.user_id, payment_id))
                    except:
                        gamesite.exception_log.event(server_time, 'XSAPI_payment API fail on user %d payment %s: ' % (session.user.user_id, payment_id) + traceback.format_exc().strip()) # OK
                        pass
                    to_ack.append(msg['msg_id'])
                elif msg['type'] == 'XSAPI_refund':
                    try:
                        request_data = msg['response'] # note: we don't check the signature, assuming proxyserver checked it already.
                        payment_id = request_data['transaction']['id']
                        # don't re-run an already-completed payment
                        found = False
                        for entry in session.player.history.get('money_purchase_history',[]):
                            if ('order_id' in entry) and str(entry['order_id']) == str(payment_id) and entry.get('refunded',0):
                                found = True
                                break

                        if found: # run the refund
                            gamesite.xsapi.handle_refund(None, session, request_data)
                            gamesite.exception_log.event(server_time, 'XSAPI_refund API success on user %d refund %s' % (session.user.user_id, payment_id))
                    except:
                        gamesite.exception_log.event(server_time, 'XSAPI_refund API fail on user %d refund %s: ' % (session.user.user_id, payment_id) + traceback.format_exc().strip()) # OK
                        pass
                    to_ack.append(msg['msg_id'])


                else:
                    gamesite.exception_log.event(server_time, 'user %d: unhandled msg type %s' % (session.user.user_id, msg['type']))

        finally:
            gamesite.msg_client.msg_ack(session.user.user_id, to_ack)

        if 0:
            if gamedata['server']['log_gifts'] and (gift_count > starting_gift_count):
                gamesite.exception_log.event(server_time, 'GIFTS: user %d count %d amount %d' % (session.user.user_id, gift_count, gift_total))

        return ret

    def add_bh_blog_feed_to_mail(self, session):
        feed = gamesite.gameapi.bh_blog_feed_cache
        if not feed: return
        if 'bh_blog_mail' not in gamedata['strings']: return
        if 'bh_blog_feed_to_mail_enabled_if' not in gamedata: return
        if (not Predicates.read_predicate(gamedata['bh_blog_feed_to_mail_enabled_if']).is_satisfied2(session, session.player, None)): return

        latest_time = -1 # time of latest entry, to update player seen counter

        for entry in feed.entries:

            # ignore entries created before this system was enabled
            if entry.published_time < gamedata.get('bh_blog_feed_start_time',-1):
                continue

            latest_time = max(latest_time, entry.published_time)
            if entry.published_time > session.player.last_bh_blog_feed_seen:
                # add it!
                time_struct = time.gmtime(entry.published_time)
                session.player.mailbox_append(
                    session.player.make_system_mail(
                    gamesite.get_localized_gamedata('strings', session.user.locale)['bh_blog_mail'],
                    replacements = {'%TITLE': entry.title,
                                    '%LINK_URL': entry.link_url,
                                    '%DAY': time.strftime('%d %b %Y', time_struct),
                                    '%TIME': time.strftime('%H:%S', time_struct)},
                    sent_time = entry.published_time
                    ))

        session.player.last_bh_blog_feed_seen = latest_time

    def do_level_up(self, session, retmsg, arg):
        want_level = int(arg[1])
        old_level = session.player.resources.player_level

        if session.has_attacked: # don't level up during combat
            return

        xp_table = gamedata['player_xp']['level_xp']

        want_level = max(2, min(want_level, len(xp_table)))

        while session.player.resources.player_level < want_level:
            next_level = session.player.resources.player_level+1
            if session.player.resources.xp < xp_table[next_level]:
                # not enough XP to promote
                break

            session.player.resources.player_level = next_level

            if LOTS_OF_METRICS:
                metric_event_coded(session.user.user_id, '%04d_player_level_%d' % (2400+next_level, next_level), {})

            level_up_rewards = session.player.get_any_abtest_value('level_up_reward', gamedata['player_xp']['level_up_reward'])
            reward = level_up_rewards[min(next_level, len(level_up_rewards)-1)]
            if reward:
                session.execute_consequent_safe(reward, session.player, retmsg, reason='do_level_up')

        if session.player.resources.player_level > old_level:
            session.setmax_player_metric('player_level', session.player.resources.player_level)
            session.user.create_fb_open_graph_action('level_up', {OGPAPI.object_type('player_level'): OGPAPI_instance.get_object_endpoint({'type':OGPAPI.object_type('player_level'),
                                                                                                                                           'level':session.player.resources.player_level})})

        retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

    def auto_resolve(self, session, retmsg):
        if not session.has_attacked or \
           ((not session.home_base) and session.player is session.viewing_player): # quarry reinforcement
            retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
            return

        # only allow in squad battles, unless DEV edit mode is on
        if (session.viewing_base.base_type != 'squad') and (not session.player.is_cheater):
            retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
            return

        if not session.player.auto_resolve_enabled():
            retmsg.append(["ERROR", "SERVER_PROTOCOL"])
            return

        # attempt to deploy all of player's un-deployed units
        if not session.home_base:
            deploy_list = [] # match format of argument to do_attack()
            deployment_limit = session.player.stattab.get_player_stat('deployable_unit_space')
            deployed_space = session.deployed_unit_space
            do_home_units = False

            # query for squad units
            for base_id, feature in session.deployable_squads.iteritems():
                if (not SQUAD_IDS.is_mobile_squad_id(feature['squad_id'])):
                    do_home_units = True # probably base defenders
                    continue

                elif (not session.player.squad_is_deployed(feature['squad_id'])):
                    do_home_units = True # mobile, but not deployed
                    continue

                elif session.player.home_region: # mobile, deployed
                    for state in gamesite.nosql_client.get_mobile_objects_by_base(session.player.home_region, session.player.squad_base_id(feature['squad_id']), reason='auto_resolve'):
                        if (not session.has_object(state['obj_id'])) and \
                           (not army_unit_is_dead(state)) and \
                           session.viewing_base.can_deploy_unit(session.player.get_abtest_spec(GameObjectSpec, state['spec'])):
                            assert state['squad_id'] == feature['squad_id']
                            assert session.player.squad_base_id(state['squad_id']) in session.deployable_squads
                            space = GameObjectSpec.get_leveled_quantity(session.player.get_abtest_spec(GameObjectSpec, state['spec']).consumes_space, state.get('level',1))
                            if deployed_space + space > deployment_limit: break
                            deploy_list.append({'obj_id':state['obj_id'], 'spec': state['spec'], 'squad_id': feature['squad_id'], 'source':'home_or_squad'})
                            deployed_space += space

            if do_home_units:
                for obj in session.player.home_base_iter():
                    if (not session.has_object(obj.obj_id)) and obj.is_mobile() and \
                       (not obj.is_destroyed()) and \
                       session.player.squad_base_id(obj.squad_id or 0) in session.deployable_squads and \
                       session.viewing_base.can_deploy_unit(obj.spec):
                        space = obj.get_leveled_quantity(obj.spec.consumes_space)
                        if deployed_space + space > deployment_limit: break
                        deploy_list.append({'obj_id': obj.obj_id, 'spec': obj.spec.name, 'source':'home_or_squad'})
                        deployed_space += space

            for donated_obj_id, state in session.player.donated_units.iteritems():
                if session.viewing_base.can_deploy_unit(session.player.get_abtest_spec(GameObjectSpec, state['spec'])):
                    if gamedata['donated_units_take_space']:
                        space = GameObjectSpec.get_leveled_quantity(session.player.get_abtest_spec(GameObjectSpec, state['spec']).consumes_space, state.get('level',1))
                    else:
                        space = 0
                    if deployed_space + space > deployment_limit: break
                    deploy_list.append({'obj_id':donated_obj_id, 'spec': state['spec'], 'source':'donated'})
                    deployed_space += space

            if deploy_list:
                if session.viewing_base.deployment_buffer and type(session.viewing_base.deployment_buffer) is dict:
                    # deployment zone
                    deploy_location = session.viewing_base.deployment_zone_centroid()
                else:
                    deploy_location = [1,1] # just throw the units into a corner

                if gamedata['server'].get('log_auto_resolve', 0) >= 2:
                     gamesite.exception_log.event(server_time, 'player %d at %s auto-resolve deploying at %r: %r' % \
                                                  (session.player.user_id, session.viewing_base.base_id, deploy_location, deploy_list))

                self.do_attack(session, retmsg, [deploy_location, deploy_list])

        # now, with all available units deployed, check the relative space requirement
        # if it fails, bail out now

        auto_resolve_max_relative_space = session.player.get_territory_setting('auto_resolve_max_relative_space', default_value = -1)
        if auto_resolve_max_relative_space > 0:
            my_alive_space = 0
            other_alive_space = 0
            for obj in session.iter_objects():
                if obj.is_mobile() and not obj.is_destroyed():
                    space = obj.get_leveled_quantity(obj.spec.consumes_space)
                    if obj.owner is session.player:
                        my_alive_space += space
                    else:
                        other_alive_space += space

            if other_alive_space >= auto_resolve_max_relative_space * my_alive_space:
                # note! pre-attack/pre-resolve path throws away retmsg, but we still want this one
                # to go through to the client, so use session.send() instead of writing to retmsg
                session.send([["ERROR", "CANNOT_AUTO_RESOLVE_DEFENDER_TOO_MUCH_SPACE", int(100*auto_resolve_max_relative_space+0.5)]])
                return

        session.attack_event(session.player.user_id, '3829_battle_auto_resolved', {})
        session.auto_resolved = True

        if gamedata['server'].get('log_auto_resolve', 0) >= 3:
            log_func = lambda x: gamesite.exception_log.event(server_time, x)
        else:
            log_func = None

        resolve_iter = 0

        while True: # iterate, because object destruction can spawn new objects (security teams)
            action_list = AutoResolve.resolve(session, log_func = log_func)

            if gamedata['server'].get('log_auto_resolve', 0) >= 2:
                gamesite.exception_log.event(server_time, "player %d at %s auto-resolve iter %d destroys: %r ... updates: %r" % (session.player.user_id, session.viewing_base.base_id, resolve_iter, [x[0] for x in action_list if x[0]], [x[1] for x in action_list if x[1]]))

            if not action_list:
                break # nothing happened

            resolve_iter += 1

            # compare number of objects before and after submitting
            # the changes, to pick up new security team objects
            num_before = session.num_objects()
            destroyed_count = 0
            for objects_destroyed_arg, combat_updates_arg in action_list:
                if objects_destroyed_arg:
                    self.destroy_object(session, retmsg, *objects_destroyed_arg)
                    destroyed_count += 1
                if combat_updates_arg:
                    self.object_combat_updates(session, retmsg, [combat_updates_arg,])

            # check for security team spawning
            num_after = session.num_objects()

            if num_after <= num_before - destroyed_count:
                break # nothing new spawned

    def object_combat_updates(self, session, retmsg, arg):
        # update hitpoints and (for mobile units only) XY position and movement orders
        ncells = session.viewing_base.ncells()

        # Processes many object updates together in a batch in order
        # to minimize the number of player state updates we have to do.

        # flags to indicate whether we need to record state changes
        update_player = False
        update_viewing_player = False
        recalc_resources = False
        recalc_power = False

        # for each affected object
        for a in arg:
            id, client_specname, newxy, newhp, neworders, killer_info, newpatrol = a

            # possible race condition due to unserialized AJAX - DSTROY_OBJECT comes first
            if (not session.has_object(id)):
                if gamedata['server'].get('log_combat_race_conditions', False):
                    gamesite.exception_log.event(server_time, 'object_combat_updates: player %d session is missing object %s %s' % \
                                                 (session.player.user_id, str(id), str(client_specname)))
                continue

            obj = session.get_object(id)

            # do not accept hp updates when not in battle
            if not session.has_attacked:
                newhp = -1

            # HP=-1 means that the client doesn't want to touch the HP value
            if newhp == -1:
                newhp = obj.hp

            # figure out who owns it and who shot at it
            # curse this complicated code :(. Need to rethink at some point...
            if (obj.owner is RogueOwner) or (obj.owner is EnvironmentOwner):
                owning_user = None
                owning_player = None
                attacker = session.player
            elif obj.owner is session.player:
                owning_user = session.user
                owning_player = session.player
                update_player = True
                if session.home_base:
                    attacker = RogueOwner
                else:
                    attacker = session.viewing_player
            elif obj.owner is session.viewing_player:
                owning_user = session.viewing_user
                owning_player = session.viewing_player
                update_player = True # for XP gain
                update_viewing_player = True
                attacker = session.player
            else:
                gamesite.exception_log.event(server_time, 'Unexpected object owner '+repr(obj.owner)+' - possible bad race condition')
                owning_user = None
                owning_player = None
                attacker = session.player

            # update XY coordinates, movement orders, and patrol flag (for mobile objects only, and not for attackers)
            if obj.is_mobile() and (owning_user is session.viewing_user):
                def clean_xy(xy):
                    return [min(max(int(xy[0]),0),ncells[0]-1),
                            min(max(int(xy[1]),0),ncells[1]-1)]
                if newxy:
                    obj.x, obj.y = clean_xy(newxy)
                if neworders is not None:
                    if type(neworders) is list:
                        obj.orders = neworders[0:gamedata['client']['max_unit_orders']]
                        for order in obj.orders:
                            if ('dest' in order) and (order['dest'] is not None):
                                order['dest'] = clean_xy(order['dest'])
                    else:
                        gamesite.exception_log.event(server_time, 'player %d received object orders for %d\'s %s not a list: %s' % \
                                                     (session.user.user_id, owning_user.user_id if owning_user else -1, obj.spec.name, repr(neworders)))
                if newpatrol is not None:
                    obj.patrol = int(not (not newpatrol))

            # handle battle damage
            if newhp != obj.hp:

                max_hp = obj.max_hp
                if newhp > obj.hp:
                    if obj.is_building():
                        # see if raised HP is just the result of ongoing repair since obj.hp was updated
                        obj.update_repair_hp_only()
                    if newhp > obj.hp:
                        if session.player.tutorial_state == "COMPLETE": # this is a known harmless race condition during the initial rails tutorial, so don't bother logging it
                            gamesite.exception_log.event(server_time, 'rejecting object_combat_update that raises object HP: user %d owner %d type %s hp %d->%d max %d STATE %s' % (session.user.user_id, owning_user.user_id if owning_user else -1, obj.spec.name, obj.hp, newhp, max_hp, repr(obj.serialize_state())))
                        newhp = obj.hp
                elif newhp < obj.hp:
                    if obj.spec.quarry_invul and (session.viewing_base.base_type == 'quarry'):
                        gamesite.exception_log.event(server_time, 'rejecting object_combat_update that lowers invul object HP: user %d owner %d type %s hp %d->%d max %d STATE %s' % (session.user.user_id, owning_user.user_id if owning_user else -1, obj.spec.name, obj.hp, newhp, max_hp, repr(obj.serialize_state())))
                        newhp = obj.hp

                newhp = int(max(0, min(newhp, max_hp)))
                if newhp == obj.hp: continue

                # cancel repair
                if obj.is_mobile() and owning_player:
                    if owning_player.unit_repair_cancel(obj):
                        recalc_resources = True

                if obj.is_building():
                    disrupted = obj.halt_all()
                    if disrupted and (not obj.spec.worth_less_xp) and (attacker is session.player) and (obj.owner is not session.player):
                        session.loot['havoc_caused'] = session.loot.get('havoc_caused',0) + 1

                # if a building is completely destroyed, perform looting
                if (obj.hp > 0) and \
                   ((newhp == 0) or gamedata.get('gradual_loot',-1) > 0) and \
                   (obj.is_building()) and owning_player:

                    event_props = {} # these will eventually be passed along with the 3920_building_destroyed event

                    # when using gradual loot and not logging it to battle log, don't include ANY loot in event_props, because it would only show
                    # the loot for the final 0hp tick on building destruction
                    event_props_include_loot = (gamedata.get('gradual_loot',-1) <= 0 or gamedata['server'].get('battle_log_gradual_loot',False))

                    # compute loot amounts and perform resource transfers
                    looted, looted_uncapped, lost = session.res_looter.loot_building(gamedata, session, obj, obj.hp, newhp, owning_player, attacker)

                    # record amounts in session.loot and in the event_props
                    if looted or looted_uncapped or lost:
                        for res in looted:
                            if looted[res] > 0:
                                session.loot[res] = session.loot.get(res,0) + looted[res]
                                if event_props_include_loot:
                                    event_props['looted_'+res] = looted[res]
                                recalc_resources = True

                        for res in looted_uncapped:
                            if looted_uncapped[res] > 0:
                                # this is for metrics and GUI display only, no game mechanics influence
                                session.loot['looted_uncapped_'+res] = session.loot.get('looted_uncapped_'+res,0) + looted_uncapped[res]
                                if event_props_include_loot:
                                    event_props['looted_uncapped_'+res] = looted_uncapped[res]

                        for res in lost:
                            if lost[res] > 0:
                                session.loot[res+'_lost'] = session.loot.get(res+'_lost',0) + lost[res]
                                if event_props_include_loot:
                                    event_props['lost_'+res] = lost[res]
                                recalc_resources = True

                        if gamedata.get('show_uncapped_loot', False):
                            client_looted = looted_uncapped
                        else:
                            client_looted = looted

                        if (sum(client_looted.itervalues(),0) > 0):
                            update_player = True
                            retmsg.append(["LOOTED_RESOURCES", client_looted, obj.obj_id, [obj.x,obj.y], None])
                            retmsg.append(["SESSION_LOOT_UPDATE", copy.deepcopy(session.loot)])

                        # tell client about the change
                        session.res_looter.send_update(retmsg)

                        # record econ flow
                        flow_suffix = '_'+session.viewing_base.base_type if (session.viewing_base is not session.viewing_player.my_home) else ''
                        if ((not owning_player) or owning_player.is_ai()) and attacker.is_human():
                            # human attacking AI - all resources generated from thin air
                            admin_stats.econ_flow_player(session.player, 'loot', 'ai'+flow_suffix, looted)
                        elif (owning_player and owning_player.is_human()) and attacker.is_ai():
                            # AI attacking human - all resources destroyed
                            admin_stats.econ_flow_player(session.player, 'loot', 'ai_attack'+flow_suffix, dict((res, -lost[res]) for res in lost))
                        elif (owning_player and owning_player.is_human()) and attacker.is_human():
                            # human attacking human - log the frictional loss only, because the rest is a transfer
                            # EXCEPT for harvesters, which generate from "thin air" because the owner hadn't collected the resources yet
                            if obj.is_producer():
                                econ_delta = looted
                                econ_reason = 'human'+flow_suffix
                            else:
                                econ_delta = dict((res,looted.get(res,0)-lost.get(res,0)) for res in gamedata['resources'])
                                econ_reason = 'friction'+flow_suffix
                            admin_stats.econ_flow_player(session.player, 'loot', econ_reason, econ_delta)

                    if newhp == 0:
                        # give XP for destroying and looting the building
                        if attacker is session.player:
                            xp_why = 'destroy_building'

                            if obj.spec.worth_less_xp:
                                # only give 1 XP, and do not count towards the destroyed_building_levels victory bonus
                                xp = gamedata['player_xp']['destroy_building_min_xp']
                            else:
                                xp = int(obj.level * gamedata['player_xp']['destroy_building'])

                                # keep track of total levels of destroyed buildings for awarding victory bonus XP
                                session.loot['destroyed_building_levels'] = session.loot.get('destroyed_building_levels',0) + obj.level

                            if lost and sum(lost.itervalues(),0) > 0:
                                coeff = gamedata['player_xp']['pve_loot_xp' if owning_player.is_ai() else 'pvp_loot_xp']
                                xp_why += ','+'looted_from_ai' if owning_player.is_ai() else 'looted_from_human'
                                xp += int(coeff * gamedata['player_xp']['loot'] * sum(lost.itervalues(),0))

                            self.give_xp(session, retmsg, xp, xp_why, [obj.x,obj.y], obj_session_id = obj.obj_id)
                            session.loot['xp'] = session.loot.get('xp',0) + xp

                        if not obj.spec.worth_less_xp:
                            if owning_player is session.player:
                                if 'buildings_lost' not in session.loot: session.loot['buildings_lost'] = {}
                                dict_increment(session.loot['buildings_lost'], obj.spec.name, 1)
                            elif owning_player is session.viewing_player:
                                if 'buildings_killed' not in session.loot: session.loot['buildings_killed'] = {}
                                dict_increment(session.loot['buildings_killed'], obj.spec.name, 1)

                        if obj.is_on_destroy_enabled():
                            # check for equipment that has on_destroy consequents (such as security team spawning)
                            on_destroy_cons_list = copy.deepcopy(obj.get_stat('on_destroy', obj.get_leveled_quantity(obj.spec.on_destroy)))
                            if on_destroy_cons_list:
                                secteam_behavior = None
                                if obj.is_building() and obj.config:
                                    secteam_behavior = obj.config.get('on_destroy_behavior', None);
                                for cons in on_destroy_cons_list:
                                    if secteam_behavior:
                                        cons['ai_state'] = secteam_behavior['ai_state']
                                        cons['ai_aggressive'] = secteam_behavior['ai_aggressive']
                                    session.execute_consequent_safe(cons, obj.owner, retmsg,
                                                                    # for buildings last_hp is always the POST-damage HP value
                                                                    context = {'source_obj': obj, 'xy': [obj.x,obj.y], 'last_hp': newhp},
                                                                    reason='on_destroy(%s)' % obj.spec.name)

                        # check for fragile equipment
                        items_destroyed = obj.destroy_fragile_equipment_items()

                        # record expenditure of the items (e.g. landmines)
                        for removed_item in items_destroyed:
                            if owning_player:
                                session.attack_item_expended(owning_player.user_id, removed_item['spec'], removed_item.get('stack',1))
                                owning_player.inventory_log_event('5131_item_trashed', removed_item['spec'], -removed_item.get('stack',1), removed_item.get('expire_time',-1), level=removed_item.get('level',1), reason='destroyed')

                        if items_destroyed:
                            event_props['items_destroyed'] = [x['spec'] for x in items_destroyed]

                        session.log_attack_unit(owning_user.user_id if owning_user else 0, obj, '3920_building_destroyed', props = event_props, killer_info = killer_info)

                        # END destroyed a building
                    else:
                        if gamedata['server'].get('battle_log_gradual_loot',False):
                            session.log_attack_unit(owning_user.user_id if owning_user else 0, obj, '3921_building_damaged', props = event_props, killer_info = killer_info)

                        # END damaged, but did not destroy, a building

                    # note: damage log updates at end of battle

                    # END damaged a building

                if (attacker is session.player) and (obj.owner is not session.player) and (not obj.spec.worth_less_xp):
                    session.loot['damage_inflicted'] = session.loot.get('damage_inflicted',0) + max(0, int(obj.hp-newhp))

                obj.hp = newhp

                if obj.is_building() and obj.affects_power():
                    recalc_power = True

                # client initiated the damage - do not send OBJECT_STATE_UPDATE

                update_viewing_player = True

            # END handle damage

            # write object state to NoSQL, if it's stored there
            if session.viewing_base.is_nosql_base() and (obj in session.viewing_base.iter_objects()): # XXX inefficient
                # this will write (for hives/quarries) or not write (for player homes), as appropriate
                session.viewing_base.nosql_write_one(obj, 'OBJECT_COMBAT_UPDATES')
                # XXXXXX need to audit fields that we write - persist_state omits the -1 for x_start_time on buildings fields = ['xy','hp_ratio','orders','patrol','contents','equipment','pack_id','behaviors','force_team','repair_finish_time','disarmed','build_start_time','research_start_time','upgrade_start_time','produce_start_time','manuf_start_time'])

            elif owning_player and obj.is_mobile() and (not obj.spec.consumable) and SQUAD_IDS.is_mobile_squad_id(obj.squad_id or 0) and \
                 ((owning_player is not session.player) or owning_player.squad_is_deployed(obj.squad_id or 0)):
                #assert owning_player.squad_is_deployed(obj.squad_id) may be false due to out-of-date player state
                # note - second part of the "and" above handles the case when attacking out of your home base to an enemy squad that is next door
                # this is the only time when UN-DEPLOYED mobile units are seen in combat
                # un-deployed enemy mobile units are NEVER seen in combat
                assert gamesite.nosql_client
                nosql_state = obj.persist_state(nosql = True)
                nosql_state['base_id'] = owning_player.squad_base_id(obj.squad_id)
                if gamedata['server'].get('log_nosql',0) >= 3:
                    gamesite.exception_log.event(server_time, 'nosql_update player %d for %d: OBJECT_COMBAT_UPDATES %s' % \
                                                 (session.player.user_id, owning_player.user_id, repr(nosql_state)))
                # XXX should probably manually specify fields to update
                gamesite.nosql_client.update_mobile_object(session.viewing_base.base_region, nosql_state, reason='OBJECT_COMBAT_UPDATES')
            else:
                # it should be a "free" object, like a secteam
                pass

        # END for each object

        # update HP values across the board
        self.do_unit_repair_tick(session, retmsg)

        # record state changes to affected players
        if recalc_power:
            # note: this sends OBJECT_STATE_UPDATE for harvesters as well as BASE_POWER_UPDATE
            session.power_changed(session.viewing_base, None, retmsg)

        if recalc_resources:
            with admin_stats.latency_measurer('OBJECT_COMBAT_UPDATES_state'):
                if update_player:
                    retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])
                if update_viewing_player and session.has_attacked:
                    retmsg.append(["ENEMY_STATE_UPDATE", session.viewing_player.resources.calc_snapshot().serialize(enemy = True)])

    def fire_on_approach(self, session, retmsg, id, xy, trigger_obj_id, client_time):
        if not session.has_object(id): return
        obj = session.get_object(id)
        if obj.on_approach_fired: return
        if obj.is_destroyed(): return

        trigger_obj = None
        if trigger_obj_id and session.has_object(trigger_obj_id):
            trigger_obj = session.get_object(trigger_obj_id)

        cons_list = None
        if obj.is_building():
            cons_list = copy.deepcopy(obj.get_stat('on_approach', obj.get_leveled_quantity(obj.spec.on_approach)))
        elif obj.is_mobile():
            cons_list = copy.deepcopy(obj.owner.stattab.get_unit_stat(obj.spec.name, 'on_approach', obj.get_leveled_quantity(obj.spec.on_approach)))

        if cons_list:
            secteam_behavior = None
            if obj.is_building() and obj.config:
                secteam_behavior = obj.config.get('on_approach_behavior', None);
            obj.on_approach_fired = True
            for cons in cons_list:
                if secteam_behavior:
                    cons['ai_state'] = secteam_behavior['ai_state']
                    cons['ai_aggressive'] = secteam_behavior['ai_aggressive']
                session.execute_consequent_safe(cons, obj.owner, retmsg, context = {'source_obj': obj, 'xy': [obj.x,obj.y] if obj.is_building() else map(int, xy), 'last_hp': obj.hp, 'trigger_obj': trigger_obj}, reason='on_approach(%s)' % obj.spec.name)

        retmsg.append(["ON_APPROACH_RESULT", obj.owner.user_id, id, client_time, server_time])

    def recycle_unit(self, session, retmsg, id):
        obj = session.player.get_object_by_obj_id(id, fail_missing = False)
        if not obj:
            return
        if SQUAD_IDS.is_mobile_squad_id(obj.squad_id) and (not session.player.verify_squad(obj.squad_id)):
            return # cannot recycle units that are not at home base

        assert obj.owner is session.player
        assert obj.is_mobile()

        health_ratio = float(obj.hp)/float(obj.max_hp)
        health_ratio = min(max(health_ratio, 0.0), 1.0)

        # for better accounting, this should really be stored on the object itself
        refund = dict((res, amount) for res, amount in obj.spec.cost_to_repair(obj.level, 1.0 - health_ratio, session.player, cost_mode = obj.spec.COST_MODE_RECYCLE).iteritems() if res != 'time')

        if session.has_object(id): session.rem_object(id)
        session.player.unit_repair_cancel(obj)
        session.player.home_base_remove(obj)
        refund = session.player.resources.gain_res(refund, reason='recycled_unit')
        admin_stats.econ_flow_player(session.player, 'consumption', 'unit_recycling', refund)

        session.increment_player_metric('units_recycled', 1, bucket = True, time_series = False)
        session.increment_player_metric('unit:'+obj.spec.name+':recycled', 1, bucket = True, time_series = False)
        if obj.spec.manufacture_category:
            session.increment_player_metric(obj.spec.manufacture_category+'_recycled', 1, bucket=True, time_series = False)

        # client initiated the removal - do not send OBJECT_REMOVED or PLAYER_ARMY_UPDATE
        retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

    def destroy_object(self, session, retmsg, id, death_location, killer_info, method = 'hostile'):

        if (not session.has_object(id)):
            if gamedata['server'].get('log_combat_race_conditions', False):
                gamesite.exception_log.event(server_time, 'destroy_object: player %d session is missing object %s' % (session.player.user_id,str(id)))
            return

        obj = session.get_object(id)

        # only mobile units get destroyed permanently
        assert obj.is_mobile()

        original_hp = obj.hp
        xp = 0
        xp_reason = ''

        is_home_object = False
        is_base_object = False
        is_squad_object = False
        squad_id = (obj.squad_id or 0)

        if (obj.owner is RogueOwner) or (obj.owner is EnvironmentOwner):
            owning_player = None
            owning_user_id = session.incoming_attack_id
            is_base_object = (obj in session.viewing_base.iter_objects()) # XXX inefficient
        else:
            if (obj.owner is not session.player) and (obj.owner is not session.viewing_player):
                gamesite.exception_log.event(server_time, 'Unexpected object owner '+repr(obj.owner)+' - possible bad race condition')
                owning_player = None
                owning_user_id = -1
            else:
                owning_player = obj.owner
                owning_user_id = owning_player.user_id

                is_home_object = (obj in owning_player.home_base_iter()) # XXX inefficient
                if not is_home_object:
                    is_base_object = (obj in session.viewing_base.iter_objects()) # XXX inefficient
                    if not is_base_object:
                        is_squad_object = SQUAD_IDS.is_mobile_squad_id(squad_id)
                        if is_squad_object:
                            #assert owning_player.squad_is_deployed(squad_id) - not always true if our version of the Player state is out of date
                            assert gamesite.nosql_client

        loot_stat = None
        if owning_player is session.player:
            loot_stat = 'units_lost'
        else:
            loot_stat = 'units_killed'

            if session.home_base:
                xp_reason = 'destroy_unit_defense'
            else:
                xp_reason = 'destroy_unit_offense'

        can_resurrect = obj.spec.resurrectable or (owning_player and owning_player.can_resurrect_unit(obj))

        if loot_stat:
            if loot_stat not in session.loot:
                session.loot[loot_stat] = {}
            dict_increment(session.loot[loot_stat], obj.spec.name, 1)

            if owning_player:
                cost = obj.spec.cost_to_repair(obj.level, 0, owning_player, cost_mode = obj.spec.COST_MODE_REPAIR)
                for res in gamedata['resources']:
                    dict_increment(session.loot, loot_stat+'_'+res, cost[res])

        # must come before rem_object() since it needs obj.team
        session.log_attack_unit(owning_user_id, obj, '3930_unit_destroyed',
                                fake_xy = death_location, killer_info = killer_info,
                                method = method)

        on_destroy_enabled = obj.is_on_destroy_enabled()

        # note: this invalidates obj.team and removes session-only auras
        session.rem_object(id)

        if owning_player:
            owning_player.unit_repair_cancel(obj)

        obj.hp = 0

        if owning_player:
            if is_home_object:
                owning_player.home_base_remove(obj)
                if can_resurrect:
                    # add back as zombie unit
                    # NOTE! does not participate in the current session, it will be sent to the client on the NEXT session change!
                    # unless it's a home attack!
                    owning_player.home_base_add(obj)
                    if session.home_base and gamedata.get('enable_defending_units',True):
                        session.add_object(obj)
                        retmsg.append(["OBJECT_CREATED2", obj.serialize_state()])
                        if obj.auras:
                            retmsg.append(["OBJECT_AURAS_UPDATE", obj.serialize_auras()])
                    else:
                        # remember in case we need to heal it later
                        session.resurrectable_objects.append([obj, death_location])
                else: # cannot resurrect, it's gone permanently
                    if owning_player is session.player: session.player.send_army_update_destroyed(obj, retmsg)

        if is_base_object:
            # NOTE! no resurrection possible for objects in BaseTable (in a base, not attached to a squad)
            session.viewing_base.drop_object(obj)

        if is_squad_object:
            # Squad's total_space/alive_space are going to go out of sync here,
            # but we'll fix it in _complete_attack before dropping the lock.
            # We do not update the feature here to cut down on broadcast traffic.
            if not can_resurrect:
                gamesite.nosql_client.drop_mobile_object_by_id(session.viewing_base.base_region, obj.obj_id, reason='DSTROY_OBJECT')
            else:
                nosql_state = obj.persist_state(nosql = True)
                nosql_state['base_id'] = owning_player.squad_base_id(squad_id)
                if gamedata['server'].get('log_nosql',0) >= 3:
                    gamesite.exception_log.event(server_time, 'nosql_update player %d for %d: DSTROY_OBJECT %s' % \
                                                 (session.player.user_id, owning_player.user_id, repr(nosql_state)))
                gamesite.nosql_client.update_mobile_object(session.viewing_base.base_region, nosql_state, reason='DSTROY_OBJECT')
                if not gamedata.get('resurrectable_squad_objects_bug', False):
                    session.resurrectable_objects.append([obj, death_location])

        if xp_reason:
            xp = int(obj.level * gamedata['player_xp'][xp_reason])
            # note: no saving of player state here, it will be saved at the end of the battle
            self.give_xp(session, retmsg, xp, xp_reason, death_location, obj_session_id = obj.obj_id)
            session.loot['xp'] = session.loot.get('xp',0) + xp

            if (obj.owner is not session.player):
                session.loot['damage_inflicted'] = session.loot.get('damage_inflicted',0) + int(original_hp)

        # client initiated the removal - do not send OBJECT_REMOVED

        if session.damage_log:
            # NOTE: obj.hp must be set to zero before here!
            # record immediately since it may leave the session and/or bases
            session.damage_log.record(obj)

        if on_destroy_enabled:
            on_destroy_cons_list = copy.deepcopy(obj.owner.stattab.get_unit_stat(obj.spec.name, 'on_destroy', obj.get_leveled_quantity(obj.spec.on_destroy)))

            if on_destroy_cons_list:
                secteam_behavior = None
                if obj.is_building() and obj.config:
                    secteam_behavior = obj.config.get('on_destroy_behavior', None);
                for cons in on_destroy_cons_list:
                    if secteam_behavior:
                        cons['ai_state'] = secteam_behavior['ai_state']
                        cons['ai_aggressive'] = secteam_behavior['ai_aggressive']
                    session.execute_consequent_safe(cons, obj.owner, retmsg,
                                                    # for mobile units, last_hp is the HP it has AFTER damage but BEFORE retreating
                                                    context = {'source_obj':obj, 'last_hp': original_hp if method == 'retreat' else 0,
                                                               'xy':death_location, 'method': method},
                                                    reason='on_destroy(%s)' % obj.spec.name)

    def do_harvest_all(self, session, retmsg, base_type, region_id, base_id, object_list, power_factor, base_info):
        base_loot = {} if base_id != session.viewing_base.base_id else None

        total_harvested = 0
        for object in object_list:
            if object.is_building() and object.is_producer() and \
               (not object.is_damaged()) and (not object.is_busy()):
                total_harvested += self.do_harvest_one(session, retmsg, base_type, region_id, base_id, object, power_factor, base_info, base_loot)

        if total_harvested > 0:
            if base_info:
                # send all remote harvesters in one big message
                retmsg.append(["HARVESTED_RESOURCES", base_loot, -1, None, base_info['base_type'], base_info['base_ui_name']])

        return total_harvested

    # collect from a harvester, covers both home and quarry cases
    # 'base_info' triggers the quarry behavior, where all harvesters are coalesced into one HARVESTED_RESOURCES message
    def do_harvest_one(self, session, retmsg, base_type, region_id, base_id, object, power_factor, base_info, base_loot):
        if not object.is_producer(): return 0
        assert object.owner is session.player

        if object.is_damaged():
            retmsg.append(["ERROR", "HARVESTER_DAMAGED"])
            return 0
        if object.is_busy():
            retmsg.append(["ERROR", "HARVESTER_UNDER_CONSTRUCTION"])
            return 0

        # calculate max storage capacity
        snapshot = session.player.resources.calc_snapshot()

        # at most how many units can be harvested?
        resource = None
        for res in gamedata['resources']:
            if object.get_leveled_quantity(getattr(object.spec, 'produces_'+res)) > 0:
                limit = snapshot.max_res(res) - snapshot.cur_res(res)
                resource = res
                break
        assert resource

        bonus = 0
        if limit > 0:
            harvested = object.harvest(object.owner, limit)
            object.update_production(object.owner, base_type, region_id, power_factor)
            if base_type == 'quarry':
                assert gamesite.nosql_client
                state = object.persist_state(nosql = True)
                newstate = {'obj_id': state['obj_id'], 'contents':state.get('contents',0),
                            'produce_start_time':state.get('produce_start_time',-1), 'produce_rate': state.get('produce_rate',-1)}
                gamesite.nosql_client.update_fixed_object(region_id, newstate, partial = True, reason='QUARRY_COLLECT')
                yield_factor = session.player.stattab.get_player_stat('quarry_yield_bonus')
                if base_info and base_info['base_template'] and (base_info['base_template'] in gamedata['quarries_server']['templates']):
                    template = gamedata['quarries_server']['templates'][base_info['base_template']]
                    if template.get('turf_points',0) > 0:
                        yield_factor *= session.player.stattab.get_player_stat('turf_quarry_yield_bonus')
                if yield_factor > 1:
                    bonus = min(int((yield_factor-1.0)*harvested), limit-harvested)
        else:
            harvested = 0

        if harvested > 0:
            session.increment_player_metric('resources_harvested', harvested+bonus, bucket = True, time_series = False) # avoid history bloat
            session.player.resources.gain_res({resource:harvested+bonus}, reason='harvested', break_limit = True) # amounts already capped
            session.increment_player_metric('harvested_'+resource+'_total', harvested+bonus, time_series = False, bucket = True)
            dict_setmax(session.player.history, 'harvested_'+resource+'_at_once', harvested+bonus)

            admin_stats.econ_flow_player(session.player, 'harvesting', 'harvesters_'+base_type, {resource:harvested})
            if bonus > 0:
                admin_stats.econ_flow_player(session.player, 'harvesting', 'harvesters_'+base_type+'_bonus', {resource:bonus})

            loot = {resource:harvested}
            if bonus > 0:
                loot[resource+'_bonus'] = bonus

            map_pos = [object.x, object.y] if session.has_object(object.obj_id) else [-1,-1]

            if base_loot is not None:
                base_loot[resource] = base_loot.get(resource,0) + harvested
                if bonus > 0:
                    base_loot[resource+'_bonus'] = base_loot.get(resource+'_bonus',0) + bonus

            if base_type == 'quarry' and region_id:
                session.player.modify_scores({'quarry_resources': harvested+bonus}, reason = 'QUARRY_COLLECT(do_harvest_one)')
                if base_info and base_info['base_template'] and (base_info['base_template'] in gamedata['quarries_server']['templates']):
                    template = gamedata['quarries_server']['templates'][base_info['base_template']]
                    if template.get('turf_points',0) > 0:
                        session.player.modify_scores({'strongpoint_resources': harvested+bonus}, reason = 'QUARRY_COLLECT(do_harvest_one)')

            if base_id == session.viewing_base.base_id:
                retmsg.append(["HARVESTED_RESOURCES", loot, object.obj_id, map_pos, base_type, base_info['base_ui_name'] if base_info else None])

            self.give_xp(session, retmsg, int(gamedata['player_xp']['harvest'] * (harvested+bonus)), 'harvest', map_pos, obj_session_id = object.obj_id)
            if session.has_object(object.obj_id):
                retmsg.append(["OBJECT_STATE_UPDATE2", object.serialize_state(update_xy = False)])
        return harvested

    def do_collect_one_deposit(self, session, retmsg, object):
        assert object.is_inert()
        assert object.owner is session.player
        if "COLLECT_DEPOSIT" not in object.spec.spells: return
        snap = session.player.resources.calc_snapshot()
        resource = 'iron'
        harvested = object.metadata.get(resource,0)
        descr = 'home' if (object in session.player.home_base_iter()) else 'quarry'
        loot = session.player.resources.gain_res({resource:harvested}, reason='collect_deposit', snap = snap)

        admin_stats.econ_flow_player(session.player, 'harvesting', 'outcrops_'+descr, loot)

        if 'gamebucks' in object.metadata:
            loot['gamebucks'] = object.metadata['gamebucks']
            session.player.resources.gain_gamebucks(loot['gamebucks'], reason='iron_deposit')
            dict_increment(session.player.history, 'iron_deposit_gamebucks', loot['gamebucks'])
            session.setvalue_player_metric('gamebucks_balance', session.player.resources.gamebucks, bucket=True, bucket_size=15*60)

        map_pos = [object.x, object.y] if session.has_object(object.obj_id) else [-1,-1]
        retmsg.append(["HARVESTED_RESOURCES", loot, object.obj_id, map_pos, None, None])

        dict_increment(session.player.history, 'iron_deposits_collected', 1)

        self.give_xp(session, retmsg, int(gamedata['player_xp']['collect_deposit'] * harvested), 'collect_deposit', map_pos, obj_session_id = object.obj_id)

        if session.has_object(object.obj_id):
            retmsg.append(["OBJECT_REMOVED", object.obj_id, session.player.resources.calc_snapshot().serialize()])
            session.rem_object(object.obj_id)

        if descr == 'home':
            session.player.my_home.drop_object(object)
        else:
            session.viewing_base.drop_object(object)

    # outermost wrapper - perform HTTP request processing
    def render_POST(self, request):
        update_server_time()
        SpinHTTP.set_access_control_headers(request)
        if gamedata['server']['use_http_keep_alive'] and SpinHTTP.get_twisted_header(request, 'connection').lower() == 'keep-alive':
            request.setHeader('Connection', 'keep-alive')
            request.setHeader('Keep-Alive', 'timeout=%d' % gamedata['server']['http_connection_timeout'])

        client_ip = SpinHTTP.get_twisted_client_ip(request, proxy_secret = SpinConfig.config['proxy_api_secret'])
        user_agent = SpinHTTP.get_twisted_header(request, 'user-agent')
        args_dict = dict((k, request.args[k][0]) for k in request.args)

        return self.render_request(request, args_dict, client_ip, user_agent)[0]

    def render_request(self, http_request, args_dict, client_ip, user_agent):
        error_response = None
        try:
            response = self.do_render_request(http_request, args_dict, client_ip, user_agent)

        except:
            # try to determine user id
            suser_id = 'unknown'
            if 'session' in args_dict:
                session_id = args_dict['session']
                session = get_session_by_session_id(session_id, include_logout_in_progress = True)
                if session:
                    suser_id = str(session.user.user_id)

            gamesite.exception_log.event(server_time, 'GAMEAPI Exception (user '+suser_id+'): '+traceback.format_exc().strip()) # OK

            # return a formatted error for the client
            http_request.setHeader('Connection', 'close') # stop keepalive
            error_response = SpinJSON.dumps({'serial':-1, 'clock': server_time, 'msg': [["ERROR", "SERVER_EXCEPTION"]]})

        reply = error_response or response
        is_error = (error_response is not None)
        return (reply, is_error)

    def do_render_request(self, http_request, args_dict, client_ip, user_agent):
        if 'proxy_keepalive_only' in args_dict:
            # note: this is for the PROXYSERVER keepalive, so don't bother looking at session
            return "true\n"
        elif 'ping_only' in args_dict: # respond to latency probe
            return "ok\n"

        arg = None

        # parse list of messages sent by client
        if ('myarg' in args_dict):
            try:
                if type(args_dict['myarg']) is list: # websocket literal
                    arg = args_dict['myarg']
                else:
                    arg = SpinJSON.loads(args_dict['myarg'])
            except:
                arg = None
                # only log exception if it's not an empty request
                if True or len(args_dict) > 1:
                    gamesite.exception_log.event(server_time, 'bad client message! ' + repr(http_request) + ' args ' + repr(args_dict) + ' from '+repr(client_ip) + ' User-Agent "'+ user_agent +'" Exception: ' + traceback.format_exc().strip()) # OK

        if arg is None:
            http_request.setHeader('Connection', 'close') # stop keepalive
            return SpinJSON.dumps({'serial':-1, 'clock': server_time, 'msg': [["ERROR","UNKNOWN_SESSION"]]})

        session_id = args_dict["session"]
        serial = int(args_dict["serial"])
        keepalive = ('nokeepalive' not in args_dict)

        if gamesite.raw_log:
            if session_id and session_table.has_key(session_id):
                client_str = 'user %d' % session_table[session_id].user.user_id
            else:
                client_str = 'sid %s' % pretty_print_session(session_id)
            log.msg(('from client (%s:%d): ' % (client_str, serial)) +repr(arg))

        session = None

        # CLIENT_HELLO message is handled as a special case, because it does not have a session yet
        if arg[0][0] == "CLIENT_HELLO":

            retmsg = [] # to trap errors only - will be connected to session.outgoing_messages after session set-up
            go_async = self.handle_client_hello(http_request, client_ip, user_agent, arg[0], retmsg)

            arg = arg[1:]

            if go_async:
                # go asynchronous, breaking out of message processing here
                # eventually the relevant async callback should call complete_deferred_request()
                return server.NOT_DONE_YET

            # some kind of error happened
            http_request.setHeader('Connection', 'close') # stop keepalive
            return SpinJSON.dumps({'serial':-1, 'clock': server_time, 'msg': retmsg})

        # not CLIENT_HELLO...

        session = get_session_by_session_id(session_id)
        if not session:
            http_request.setHeader('Connection', 'close') # stop keepalive
            return SpinJSON.dumps({'serial':-1, 'clock': server_time, 'msg': [["ERROR", "UNKNOWN_SESSION"]]})

        # after this point, session is guaranteed to be valid

        if keepalive:
            session.last_active_time = server_time

        if 'ack' in args_dict:
            # trim retrans buffer
            ack = int(args_dict["ack"])
            while len(session.retrans_buffer) > 0 and session.retrans_buffer[0][0] <= ack:
                session.retrans_buffer.pop(0)

        if arg[0][0] == "LONGPOLL":
            assert len(arg) == 1 and len(arg[0]) == 1
            return self.handle_longpoll(http_request, session)

        # compare serial number of incoming message vs. the next expected serial number
        if (serial < session.incoming_serial) or (serial in session.message_buffer):
            # discard retransmission
            pass
        else:
            session.message_buffer[serial] = arg

        if len(session.message_buffer) >= gamedata['server']['session_message_buffer']:
            # client is too far ahead of us
            if not session.lagged_out:
                session.lagged_out = True
                metric_event_coded(session.user.user_id, '0955_lagged_out', {'method': 'message_buffer',
                                                                             'len': len(session.message_buffer),
                                                                             'idle_for': server_time - session.last_active_time,
                                                                             'ip': session.user.last_login_ip,
                                                                             'browser_OS': session.user.browser_os,
                                                                             'browser_name': session.user.browser_name,
                                                                             'browser_version': session.user.browser_version,
                                                                             'browser_hardware': session.user.browser_hardware,
                                                                             'spin_client_platform': session.user.spin_client_platform,
                                                                             'spin_client_vendor': session.user.spin_client_vendor,
                                                                             'spin_client_version': session.user.spin_client_version,
                                                                             'country': session.user.country })
            http_request.setHeader('Connection', 'close') # stop keepalive
            return SpinJSON.dumps({'serial':-1, 'clock': server_time, 'msg': [["ERROR", "TOO_LAGGED_DOWNSTREAM"]]})


        if isinstance(http_request, WSFakeRequest): # XXXXXX nasty hack
            # XXXXXX nasty hack - remember the WebSocket we should use to talk back to the client
            if ((session.longpoll_request is None) or \
                (not isinstance(session.longpoll_request, WSFakeRequest)) or \
                (http_request.proto is not session.longpoll_request.proto)):
                # park this request as the longpoll request so we have something to write the client back on
                if session.longpoll_request:
                    if isinstance(session.longpoll_request, WSFakeRequest):
                        session.longpoll_request.close_connection_aggressively()
                session.longpoll_request = http_request
                session.longpoll_request_time = -1 # no need to force a keepalive, and reuse this request multiple times

        session.sync_requests.append(http_request)
        session.queue_flush_outgoing_messages()
        return server.NOT_DONE_YET

    # process as many bundles of AJAX messages on a session as possible
    # may terminate early if bundles are out of order, or may go asynchronous
    # returns True if going asynchronous, otherwise False.

    def handle_message_buffer(self, session, retmsg):
        # look through the message buffer for a processable message bundle
        start_time = -1

        while session.incoming_serial in session.message_buffer:
            if session.is_async():
                # prevent re-entry of handle_message_buffer() on a subsequent client message while an async request is still happening
                # the client will get its answer from complete_deferred_message after the async request completes
                #gamesite.exception_log.event(server_time, 'user %d: skipping message processing while async in flight, in %d out %d buf %s' % (session.user.user_id, session.incoming_serial, session.outgoing_serial, repr(session.message_buffer)))
                break

            if session.logout_in_progress: # allow no further message processing after logout begins
                break

            # ok, we got the next expected message bundle
            serial_arg = session.message_buffer[session.incoming_serial]

            # process as many messages as we can in this budle
            # for each message in the bundle
            while len(serial_arg) > 0:
                # pull the message off the queue
                # (throughout this entire function, we leave the session in a valid state, in case
                # we have to go asynchronous and come back later)
                msg = serial_arg.pop(0)

                if msg[0] == "CAST_SPELL":
                    latency_tag = msg[0] + '('+msg[2]+')'
                elif msg[0] == "INVENTORY_USE":
                    latency_tag = msg[0] + '('+msg[2]['spec']+')'
                elif msg[0] == "LOOT_BUFFER_TAKE":
                    latency_tag = msg[0] + '('+('single' if msg[2] >= 0 else 'all')+')'
                elif 0 and msg[0] == "QUARRY_QUERY":
                    latency_tag = msg[0] + ('_FULL' if msg[2]<=0 else '_INCREMENTAL')
                elif msg[0] == "SEARCH_PLAYER_CACHE":
                    latency_tag = msg[0] + ' ' + SpinHTTP.unwrap_string(msg[1]).strip()[0:64]
                else:
                    latency_tag = msg[0]

                session.debug_log_action(latency_tag)

                try:
                    if start_time < 0: start_time = time.time()

                    go_async = self.handle_message_guts(session, msg, retmsg)

                    end_time = time.time()


                    admin_stats.record_latency(latency_tag, end_time-start_time)
                    start_time = end_time # ends up including the list-processing stuff below in the next message, but that should be fast

                    if True or latency_tag not in ('PING_PLAYER', 'PLAYER_STATE_QUERY',
                                                   'UNIT_REPAIR_TICK', 'OBJECT_COMBAT_UPDATES',
                                                   'REPORT_METRIC'):
                        session.last_action.append({'tag':latency_tag, 'time':server_time, 'keepalive':session.last_active_time == server_time})

                    if go_async:
                        assert isinstance(go_async, defer.Deferred)
                        if not deferred_is_finished(go_async):
                            # go asynchronous, breaking out of message processing here
                            if (not session.logout_in_progress) and (go_async not in session.async_ds):
                                gamesite.exception_log.event(server_time, 'handle_message_guts did not install async_d: %s' % (latency_tag))
                                session.start_async_request(go_async)
                            return

                except Exception:
                    gamesite.exception_log.event(server_time, 'handle_message_guts exception %s msg %s: %s' % (session.dump_exception_state(), latency_tag, traceback.format_exc().strip())) # OK
                    retmsg.append(["ERROR", "SERVER_EXCEPTION"])
                    break

            if len(serial_arg) == 0:
                # processed one complete bundle. Advance to next.
                del session.message_buffer[session.incoming_serial]
                session.incoming_serial += 1


    # we're about to send a response to the client. Run any pending batched actions.
    @admin_stats.measure_latency('run_deferred_actions')
    def run_deferred_actions(self, session, retmsg, reason = 'unknown'):
        do_player_cache_update = False

        if session.deferred_ping_squads:
            session.deferred_ping_squads = False
            session.player.ping_squads_and_send_update(session, retmsg, originator = session.player.user_id, reason='run_deferred_actions(%s)' % reason)

        if session.deferred_ladder_point_decay_check:
            session.deferred_ladder_point_decay_check = False
            session.player.ladder_point_decay_check(session)

        if session.deferred_stattab_update:
            session.deferred_stattab_update = False
            session.player.recalc_stattab(session.player, session.viewing_base)
            session.player.stattab.send_update(session, retmsg)

        if session.deferred_mailbox_update:
            session.deferred_mailbox_update = False
            session.player.send_mailbox_update(retmsg)

        if session.deferred_power_change: # probably needs to come after stattab
            session.deferred_power_change = False
            session.power_changed(session.viewing_base, None, retmsg)

        if session.deferred_history_update:
            session.deferred_history_update = False
            session.player.send_history_update(retmsg)

        if session.deferred_battle_history_update:
            session.deferred_battle_history_update = False
            session.player.send_battle_history_update(retmsg)

        if session.deferred_object_removals:
            removals = session.deferred_object_removals
            session.deferred_object_removals = set()
            for obj in removals:
                if obj in session.deferred_object_state_updates:
                    session.deferred_object_state_updates.remove(obj)
                if session.viewing_base.find_object_by_id(obj.obj_id):
                    session.viewing_base.drop_object(obj)
                if session.has_object(obj.obj_id):
                    retmsg.append(["OBJECT_REMOVED2", obj.obj_id])
                    session.rem_object(obj.obj_id)
                if obj.is_building():
                    session.power_changed(session.viewing_base, obj, retmsg)
                    session.deferred_player_state_update = True

        if session.deferred_object_state_updates:
            updates = session.deferred_object_state_updates
            session.deferred_object_state_updates = set()
            for obj in updates:
                if session.has_object(obj.obj_id):
                    retmsg.append(["OBJECT_STATE_UPDATE2", obj.serialize_state()])

        if session.deferred_player_state_update:
            session.deferred_player_state_update = False
            retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

        if session.deferred_player_auras_update:
            session.deferred_player_auras_update = False
            retmsg.append(["PLAYER_AURAS_UPDATE", session.player.player_auras])
            if session.viewing_player is not session.player:
                retmsg.append(["ENEMY_AURAS_UPDATE", session.viewing_player.player_auras])

        if session.deferred_player_cooldowns_update:
            session.deferred_player_cooldowns_update = False
            retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])

        if session.deferred_donated_units_update:
            session.deferred_donated_units_update = False
            retmsg.append(["DONATED_UNITS_UPDATE", session.player.donated_units])

        if session.deferred_player_name_update:
            session.deferred_player_name_update = False
            retmsg.append(["PLAYER_UI_NAME_UPDATE", session.user.get_ui_name(session.player)])
            retmsg.append(["PLAYER_ALIAS_UPDATE", session.player.alias])
            retmsg.append(["PLAYER_TITLES_UPDATE", session.player.title])
            do_player_cache_update = True

        if session.deferred_player_trophies_update:
            session.deferred_player_trophies_update = False
            do_player_cache_update = True

        if do_player_cache_update:
            retmsg.append(["PLAYER_CACHE_UPDATE", [self.get_player_cache_props(session.user, session.player, session.alliance_id_cache)]])

    def complete_deferred_request(self, request, session, retmsg):
        # works for both standard HTTP request and WSFakeRequest

        if request and hasattr(request, '_disconnected') and request._disconnected: return

        # note: retmsg is ONLY used to convey error messages that happen prior to session set-up
        # once the session is alive, only session.outgoing_messages is used for transmission

        if not session: # can happen on async login failure
            assert request
            # DO pay attention to retmsg here
            r = SpinJSON.dumps({'serial':-1, 'clock': server_time, 'msg': retmsg})
            request.setHeader('Connection', 'close') # stop keepalive
            request.write(r)
            request.finish()
            return

        # note: IGNORE retmsg here - all traffic is on session.outgoing_messages
        if gamesite.raw_log:
            client_str = 'sid %s' % pretty_print_session(session.session_id)
            log.msg(('to   client (%s:%d): ' % (client_str, session.outgoing_serial))+repr(retmsg))

        self.put_on_wire(session, request, False)

    def complete_longpoll(self, request, session):
        if hasattr(request, '_disconnected') and request._disconnected: return
        self.put_on_wire(session, request, True)

    def put_on_wire(self, session, request, is_longpoll):
        # works for both standard HTTP request and WSFakeRequest
        msg = session.outgoing_messages[:]
        del session.outgoing_messages[:] # note: do not create a new array, since in-flight async requests may reference it

        if len(msg) == 0 and \
           (not isinstance(request, WSFakeRequest) or \
            (session.incoming_serial - session.incoming_acked >= gamedata['server']['session_message_buffer']//2)):
            # HTTP requests always need a response
            # WS requests don't, but still respond with an "ack" occasionally to keep client retrans buffer size down
            msg.append(["NOMESSAGE"])

        if len(msg) > 0:
            contents = {'serial': session.outgoing_serial,
                        'ack': session.incoming_serial-1,
                        'clock': time.time() if gamedata['server'].get('send_high_precision_time',True) else server_time,
                        'msg': msg}
            if is_longpoll:
                contents['longpoll'] = 1
            r = SpinJSON.dumps(contents)

            session.incoming_acked = session.incoming_serial-1
            session.retrans_buffer.append([session.outgoing_serial, msg])
            session.outgoing_serial += 1

            if len(session.retrans_buffer) >= gamedata['server']['session_message_buffer']:
                # client hasn't acked enough
                if not session.lagged_out:
                    session.lagged_out = True
                    metric_event_coded(session.user.user_id, '0955_lagged_out', {'method':'retrans_buffer',
                                                                                 'len': len(session.retrans_buffer),
                                                                                 'idle_for': server_time - session.last_active_time,
                                                                                 'ip': session.user.last_login_ip,
                                                                                 'browser_OS': session.user.browser_os,
                                                                                 'browser_name': session.user.browser_name,
                                                                                 'browser_version': session.user.browser_version,
                                                                                 'browser_hardware': session.user.browser_hardware,
                                                                                 'spin_client_platform': session.user.spin_client_platform,
                                                                                 'spin_client_vendor': session.user.spin_client_vendor,
                                                                                 'spin_client_version': session.user.spin_client_version,
                                                                                 'country': session.user.country })
                    reactor.callLater(0, self.log_out_async, session, 'timeout')
                request.setHeader('Connection', 'close') # stop keepalive
                request.write(SpinJSON.dumps({'serial':-1, 'clock': server_time, 'msg': [["ERROR", "TOO_LAGGED_DOWNSTREAM"]]}))
            else:
                request.write(r)

        request.finish()

    def handle_longpoll(self, request, session):
        if session.longpoll_request: # overlapped request, respond to the previous one immediately
            self.complete_longpoll(session.longpoll_request, session)
        session.longpoll_request = request
        session.longpoll_request_time = server_time
        if len(session.outgoing_messages) > 0 or session.logout_in_progress:
            # plan to respond immediately if messages are pending, or if we're on our way out
            session.queue_flush_outgoing_messages()
        return server.NOT_DONE_YET # park the request

    # the login process is broken into two parts:
    # 1) handle_client_hello(): pre-user/player lookup
    #    (lock acquired here)
    # --- asynchronous userdb/playerdb read happens here ---
    # 2) complete_client_hello(): post-user/player lookup

    # AsyncLogin encapsulates the state that needs to be carried over between steps 1) and 2)
    #
    # If another login or a termination request comes in between 1) and 2), AsyncLogin is responsible
    # for dropping the lock and nullifying the request it is responding to.

    class AsyncLogin (object):
        # table of currently "live" AsyncLogins that have locks and will end successfully unless cancelled
        in_progress_by_user_id = {}
        in_progress_by_session_id = {}

        @classmethod
        def cancel_existing(cls, user_id, session_id):
            for aslogin in (cls.in_progress_by_user_id.get(user_id, None), cls.in_progress_by_session_id.get(session_id, None)):
                if aslogin and (not aslogin.cancel_reason):
                    if gamedata['server']['log_abnormal_logins'] >= 2:
                        gamesite.exception_log.event(server_time, 'canceling pending login for user %s session %s' % (repr(user_id),repr(session_id)))
                    aslogin.cancel("CANNOT_LOG_IN_SIMULTANEOUS")

        def __init__(self, api, request, retmsg, session_id, frame_platform, social_id, auth_token,
                     user_id, lockgen, metrics_anon_id, user_demographics, client_browser_caps,
                     client_session_data, query_string, client_permissions, client_login_country,
                     client_ip, user_agent):
            self.api = api
            self.request = request
            self.retmsg = retmsg
            self.session_id = session_id
            self.frame_platform = frame_platform
            self.social_id = social_id
            self.auth_token = auth_token
            self.user_id = user_id
            self.lockgen = lockgen
            self.metrics_anon_id = metrics_anon_id
            self.user_demographics = user_demographics
            self.client_browser_caps = client_browser_caps
            self.client_session_data = client_session_data
            self.query_string = query_string
            self.client_permissions = client_permissions
            self.client_login_country = client_login_country
            self.client_ip = client_ip
            self.user_agent = user_agent

            self.cancel_reason = None
            self.user = None
            self.player = None
            # need separate flags because "None" is a valid return value for user/player retrieval
            self.got_user = False
            self.got_player = False
            self.has_lock = True

            self.in_progress_by_user_id[user_id] = self
            self.in_progress_by_session_id[session_id] = self

        # called once userdb entry is retrieved
        def user_cb(self, success, user):
            self.got_user = True
            if success:
                self.user = user
            else:
                self.cancel("CANNOT_LOG_IN_IO_FAIL")
                gamesite.exception_log.event(server_time, 'userdb lookup for %d failed on login, cancelling' % self.user_id)
            self.try_finish()

        # called once playerdb entry is retrieved
        def player_cb(self, success, player):
            self.got_player = True
            if success:
                self.player = player
            else:
                self.cancel("CANNOT_LOG_IN_IO_FAIL")
                gamesite.exception_log.event(server_time, 'playerdb lookup for %d failed on login, cancelling' % self.user_id)
            self.try_finish()

        # mark login attempt as cancelled and release the lock
        def cancel(self, cancel_reason):
            self.cancel_reason = cancel_reason
            if self.has_lock:
                ascdebug('UNLOCKED player %d (cancel)' % self.user_id)
                gamesite.lock_client.player_lock_release(self.user_id, -1, Player.LockState.logged_in, expected_owner_id = self.user_id)
                self.has_lock = False
            if self.user_id in self.in_progress_by_user_id:
                del self.in_progress_by_user_id[self.user_id]
            if self.session_id in self.in_progress_by_session_id:
                del self.in_progress_by_session_id[self.session_id]

        def try_finish(self):
            if (not self.got_user) or (not self.got_player): return
            if self.cancel_reason:
                # just send back the error and quit, do not overwrite userdb/playerdb data!
                assert not self.has_lock
                if gamedata['server']['log_abnormal_logins'] >= 2:
                    gamesite.exception_log.event(server_time, 'ignoring user/player data for cancelled login %d: %s' % (self.user_id, self.cancel_reason))
                self.retmsg.append(["ERROR", self.cancel_reason])
                return self.api.complete_deferred_request(self.request, None, self.retmsg) # OK - do want to work with the raw request here
            assert self.has_lock
            del self.in_progress_by_user_id[self.user_id]
            del self.in_progress_by_session_id[self.session_id]
            return self.api.complete_client_hello(self.request, self.retmsg, self.user_id, self.frame_platform, self.social_id, self.auth_token, self.lockgen, self.user, self.player, self.session_id, self.metrics_anon_id, self.user_demographics, self.client_browser_caps, self.client_session_data, self.query_string, self.client_permissions, self.client_login_country, self.client_ip, self.user_agent)

    # handle initial handshake message from client
    # returns whether or not to go async
    @admin_stats.measure_latency('handle_client_hello')
    def handle_client_hello(self, request, client_ip, user_agent, arg, retmsg):
        # check IP bans
        if client_ip and str(client_ip) in gamedata['server']['banned_ips']:
            gamesite.exception_log.event(server_time, 'prevented banned IP %s from logging in' % client_ip)
            retmsg.append(["ACCOUNT_BANNED"])
            return False

        # check arguments
        if len(arg) != 18:
            retmsg.append(["ERROR", "CANNOT_LOG_IN_VERSION_MISMATCH_GAMECODE"])
            return False

        query_string = SpinHTTP.unwrap_string(arg[1])
        #not_used = arg[2]
        client_social_id = arg[3]
        metrics_anon_id = arg[4]
        client_session_id = arg[5]
        user_demographics = arg[6]
        client_browser_caps = arg[7]
        client_gamedata_build_info = arg[8]
        client_gamecode_build_date = arg[9]
        client_session_time = int(arg[10])
        client_session_data = arg[11]
        client_auth_token = arg[12]
        client_session_sig = arg[13]
        client_permissions = arg[14]
        client_gamedata_checksums = arg[15]  # noqa : F841
        client_login_country = arg[16]
        client_user_id = arg[17]

        # check that the session id has not been invalidated by a previous call to CONTROLAPI
        if client_session_id in invalid_sessions:
            if gamedata['server']['log_abnormal_logins'] >= 2:
                gamesite.exception_log.event(server_time, 'user %d logged in with invalidated session %s' % \
                                             (client_user_id, client_session_id))
            retmsg.append(["ERROR", "CANNOT_LOG_IN_SIMULTANEOUS"])
            return False

        # check that proxyserver session signature is valid
        server_session_sig = SpinSignature.sign_session(client_user_id, client_login_country, client_session_id, client_session_time, spin_server_name, client_social_id, client_auth_token, client_session_data, SpinConfig.config['proxy_api_secret'])
        if client_session_sig != server_session_sig:
            gamesite.exception_log.event(server_time, 'user %d logged in with invalid proxy signature: ID %s time %d servername %s data "%s" client "%s" server "%s" from IP %s user-agent "%s"' % \
                                         (client_user_id, client_session_id, client_session_time, spin_server_name, client_session_data, client_session_sig, server_session_sig, repr(client_ip),
                                          user_agent))
            retmsg.append(["ERROR", "CANNOT_LOG_IN_PROXY_SIGNATURE_INVALID"])
            return False

        # check that proxyserver session signature is recent
        if (server_time >= client_session_time + gamedata['server']['session_signature_time_tolerance']):
            if gamedata['server']['log_abnormal_logins'] >= 2:
                gamesite.exception_log.event(server_time, 'user %d logged in with outdated proxy signature (%d sec old)' % \
                                             (client_user_id, server_time - client_session_time))
            retmsg.append(["ERROR", "CANNOT_LOG_IN_PROXY_SIGNATURE_OUTDATED"])
            return False

        # we can now trust the client_ params that are in the session signature
        user_id = client_user_id

        # throttle logins if IO system is overloaded
        if io_system.overloaded() and (user_id not in SpinConfig.config.get('developer_user_id_list',[])):
            retmsg.append(["ERROR", "CANNOT_LOG_IN_SERVER_OVERLOAD"])
            gamesite.exception_log.event(server_time, 'I/O overload! denied login to %d' % user_id)
            return False

        frame_platform = client_social_id[0:2]
        assert frame_platform in ('fb','kg','k2','ag','bh','mm')

        # check gamedata against server version
        client_gamedata_date = client_gamedata_build_info.get('date','nodate') if client_gamedata_build_info else 'none'
        if client_gamedata_date != gamedata['gamedata_build_info']['date']:
            gamesite.exception_log.event(server_time, 'user %d logged in with mismatched gamedata build date: client "%s" server "%s"' % \
                                         (user_id, client_gamedata_date, gamedata['gamedata_build_info']['date']))
            retmsg.append(["ERROR", "CANNOT_LOG_IN_VERSION_MISMATCH_GAMEDATA"])
            return False

        # check compiled client against server version
        if SpinConfig.config.get('use_compiled_client', False) and client_gamecode_build_date != gameclient_build_date:
            gamesite.exception_log.event(server_time, 'user %d logged in with mismatched compiled-client.js build: client "%s" server "%s"' % \
                                         (user_id, client_gamecode_build_date, gameclient_build_date))
            retmsg.append(["ERROR", "CANNOT_LOG_IN_VERSION_MISMATCH_GAMECODE"])
            return False

        # if there are any pre-existing sessions for this user, wait until they log out completely
        wait_for_session = None
        wait_reason = None

        if client_session_id in session_table:
            wait_for_session = session_table[client_session_id]
            wait_reason = 'double_login'
        else:
            sess = get_session_by_user_id(user_id, include_logout_in_progress = True)
            if sess:
                wait_for_session = sess
                wait_reason = 'relog'

        if wait_for_session:

            # best to just stop the login attempt right here.
            if gamedata['server']['log_abnormal_logins'] >= 2:
                gamesite.exception_log.event(server_time, 'stopping login for user %d after %s' % (user_id, wait_reason))
            retmsg.append(["ERROR", "CANNOT_LOG_IN_SIMULTANEOUS"])
            return False

        # ensure that only one login on a user_id runs to successful completion
        self.AsyncLogin.cancel_existing(user_id, client_session_id)

        # not sure if there's a race window right here...

        # acquire player lock
        lockret, lockgen = gamesite.lock_client.player_lock_acquire_login(user_id, owner_id = user_id)
        if lockret == -Player.LockState.being_attacked or lockret == -Player.LockState.logged_in or lockret < 0:
            retmsg.append(["ERROR", "CANNOT_LOG_IN_WHILE_UNDER_ATTACK"])
            return False

        ascdebug('LOCKED player %d in session %s' % (user_id, client_session_id))

        # open a new session, using the ID passed in by the client
        aslogin = self.AsyncLogin(self, request, retmsg, client_session_id, frame_platform, client_social_id, client_auth_token,
                                  user_id, lockgen, metrics_anon_id, user_demographics, client_browser_caps,
                                  client_session_data, query_string, client_permissions, client_login_country, client_ip, user_agent)

        # begin async lookups into userdb and playerdb
        user_table.lookup_async(user_id, aslogin.user_cb, 'login')
        player_table.lookup_async(None, user_id, True, aslogin.player_cb, 'login')

        # send active session count to server status table
        if gamesite.nosql_client and gamedata['server'].get('update_server_status_on_login', True):
            gamesite.nosql_client.server_status_update(spin_server_name, {'active_sessions':admin_stats.get_active_sessions()}, reason='login')

        return True

    @admin_stats.measure_latency('complete_client_hello')
    def complete_client_hello(self, request, retmsg, user_id, *args):
        d = None # deferred for completion

        try:
            d = self.do_complete_client_hello(request, retmsg, user_id, *args)
            if d is not None:
                # note: if complete_client_hello2() fails, the session arg here will be None
                d.addBoth(lambda session, d=d, request=request, retmsg=retmsg: session.complete_async_request(None, d) if session else self.complete_deferred_request(request, None, retmsg)) # OK

        except:
            retmsg[:] = [["ERROR", "SERVER_EXCEPTION"]] # blow away old message, because session is not going to be set up
            gamesite.exception_log.event(server_time, ('complete_client_hello Exception (player %d): ' % user_id) + traceback.format_exc().strip()) # OK

        if d is None: # failure path
            ascdebug('UNLOCKED player %d (client_hello failure)' % user_id)
            gamesite.lock_client.player_lock_release(user_id, -1, Player.LockState.logged_in, expected_owner_id = user_id)
            self.complete_deferred_request(request, None, retmsg) # OK - failure path

    def do_complete_client_hello(self, request, retmsg, user_id, frame_platform, social_id, auth_token, lockgen, user, player, session_id,
                                 metrics_anon_id, user_demographics, client_browser_caps, client_session_data, query_string, client_permissions, client_login_country,
                                 client_ip, user_agent):

        d = make_deferred('do_complete_client_hello') # OK - login path is special - we'll return this for the caller

        # parse query string
        url_qs = urlparse.parse_qs(query_string)

        acq_data = None

        if not acq_data:
            try:
                acq_data = get_acquisition_data_from_url('/?'+query_string, user_id)
            except:
                gamesite.exception_log.event(server_time, ('error in get_acquisition_data_from_url user %d "%s": ' % (user_id, query_string)) + traceback.format_exc().strip()) # OK
                pass

        # prep user ###############################

        if user is None:
            # person has never played our game before
            user = User(user_id)
            user.account_creation_time = server_time
            if not spin_secure_mode: # mark new accounts as developers
                user.developer = 1

            if 'account_creation_flow' in url_qs:
                user.account_creation_flow = url_qs['account_creation_flow'][0]

        user.frame_platform = frame_platform
        user.social_id = social_id
        user.last_login_time = server_time
        user.last_login_ip = client_ip
        user.vpn_status = None
        if ip_rep_checker:
            ip_rep_result = ip_rep_checker.query(client_ip)
            if ip_rep_result:
                user.vpn_status = repr(ip_rep_result) # this becomes a string that describes what is going on
        user.uninstalled = 0
        user.uninstalled_reason = None

        # update profile fields
        if frame_platform == 'fb':
            # ideally we should extend this token, in case the gameplay session lasts longer than the normal 2-hour expiration
            # https://developers.facebook.com/docs/facebook-login/access-tokens/refreshing/
            user.fb_oauth_token = auth_token

            user.facebook_id = social_id[2:]
            if not user.facebook_name:
                user.facebook_name = '(waiting for Facebook)'
            if not user.facebook_first_name:
                user.facebook_first_name = 'unknown'

        elif frame_platform in ('kg','k2'):
            user.kg_auth_token = auth_token
            user.kg_id = social_id[2:]
            if not user.kg_username:
                user.kg_username = '(waiting for Kongregate)'

            if ('kg_conversion_pixels' in gamedata['adnetworks']) and (not user.kg_conversion_pixels_context):
                user.kg_conversion_pixels_context = user.kg_id
                user.log_adnetwork_event('kg_conversion_pixels', {'user_id':user_id, 'kpi':'context_attached',
                                                                  'context':user.kg_conversion_pixels_context})
        elif frame_platform == 'ag':
            user.ag_auth_token = auth_token
            user.ag_id = social_id[2:]
            if not user.ag_username:
                user.ag_username = '(waiting for Armor Games)'

        elif frame_platform == 'bh':
            user.bh_auth_token = auth_token
            user.bh_id = social_id[2:]
            if not user.bh_username:
                user.bh_username = '(waiting for Battlehouse)'

        elif frame_platform == 'mm':
            user.mm_auth_token = auth_token
            user.mm_id = social_id[2:]
            if not user.mm_username:
                user.mm_username = '(waiting for Mattermost)'


        user.browser_name = str(user_demographics[0]) if user_demographics[0] != 'unknown' else None
        try:
            user.browser_version = int(user_demographics[1]) if user_demographics[1] != 'unknown' else None
        except ValueError:
            user.browser_version = None
        user.browser_os = str(user_demographics[2]) if user_demographics[2] != 'unknown' else None
        user.locale = str(user_demographics[3]) if user_demographics[3] != 'unknown' else None
        if len(user_demographics) >= 5:
            user.browser_hardware = str(user_demographics[4]) if user_demographics[4] != 'unknown' else None
        if len(user_demographics) >= 8:
            # demographics[5] is screen resoution '123x456'
            # demographics[6] is canvas resolution '123x456'
            # demographics[7] is devicePixelRatio
            user.screen_width, user.screen_height = map(int, user_demographics[5].split('x'))
            user.canvas_width, user.canvas_height = map(int, user_demographics[6].split('x'))
            # note: canvas_oversample is not determined until after receiving SERVER_HELLO
            user.devicePixelratio = parse_canvas_oversample(user_demographics[7])
        if len(user_demographics) >= 9:
            spin_client_platform = user_demographics[8]
            # only accept values we expect, in case the client lies to us
            if isinstance(spin_client_platform, basestring) and (spin_client_platform == 'web' or spin_client_platform.startswith('electron_') or spin_client_platform == 'electron'):
                user.spin_client_platform = spin_client_platform
            else:
                # default to web if there is no valid data
                user.spin_client_platform = 'web'
        if len(user_demographics) >= 10:
            spin_client_vendor = user_demographics[9]
            if isinstance(spin_client_platform, basestring):
                user.spin_client_vendor = spin_client_vendor
            else:
                # default to 'unknown' if there is no valid data
                user.spin_client_vendor = 'unknown'
        if len(user_demographics) >= 11:
            spin_client_version = user_demographics[10]
            # only accept values we expect, in case the client lies to us
            if isinstance(spin_client_version, int) and (spin_client_version > 0):
                user.spin_client_version = spin_client_version
            else:
                # default to web if there is no valid data
                user.spin_client_version = 0

        for cap in gamedata['browser_caps']:
            if cap in client_browser_caps:
                user.browser_caps[cap] = int(client_browser_caps[cap])

        user.browser_user_agent = user_agent

        user.country = client_login_country

        if ('country_override' in url_qs) and user.is_developer():
            user.country = str(url_qs['country_override'][0])

        # prep player ###############################

        if not player:
            # person has never played THIS game before
            player = LivePlayer(user.user_id)
            player.creation_time = server_time
        else:
            # check generation number to make sure we do not have stale data
            if lockgen >= 0 and player.generation < lockgen:
                if gamedata['server']['log_abnormal_logins'] >= 1:
                    gamesite.exception_log.event(server_time, 'aborting login for user %d, got stale data (file %d dbserver %d)' % (user.user_id, player.generation, lockgen))
                retmsg.append(["ERROR", "CANNOT_LOG_IN_BACKEND_RACE_CONDITION"])
                return None

        # migrate some fields from userdb to playerdb

        # fill in creation time field for legacy players
        if player.creation_time < 0:
            player.creation_time = user.account_creation_time

        # fill in preferences for legacy players
        if player.player_preferences is None:
            player.player_preferences = user.preferences

        if client_permissions: player.facebook_permissions = client_permissions.split(',')

        # note: some fields are redundant with User, but are necessary to copy on to the Player so that Predicates etc. have access to them
        player.sync_with_user(user)

        player.bust_expired_locks()

        player_is_naughty, abuse_warning_msg = player.detect_login_abuse()

        if player.lockout_until > 0:
            if server_time < player.lockout_until:
                # prevent abusers from logging in
                m = player.lockout_message if (player.lockout_message and (player.lockout_message in gamedata['errors'])) else gamedata['server']['login_abuse_error_code']
                retmsg.append(["ERROR", m])
                return None
            else:
                # abuser WAS locked out, but isn't anymore
                player.last_lockout_end = player.lockout_until
                player.lockout_until = -1

        if player.banned_until > 0 and server_time < player.banned_until:
            # prevent banned users from logging in
            gamesite.exception_log.event(server_time, 'prevented banned user %d from logging in' % player.user_id)
            retmsg.append(["ACCOUNT_BANNED"])
            return None

        # perform optional mobile browser punt
        if (not SpinConfig.config.get('always_allow_mobile', False)):
            if Predicates.read_predicate(gamedata['server']['mobile_detect']).is_satisfied(player, None):
                if (not Predicates.read_predicate(gamedata['server']['mobile_allow_if']).is_satisfied(player, None)):
                    if gamedata['server']['log_mobile_fails']:
                        almost = Predicates.read_predicate(gamedata['server']['mobile_almost_allow_if']).is_satisfied(player, None)
                        gamesite.exception_log.event(server_time, 'mobile hit from player %d (CC L%d) redirected (%s - %s)' % \
                                                     (player.user_id, player.history.get(gamedata['townhall']+'_level',1),
                                                      player.browser_hardware, 'HARDWARE/CC OK' if almost else 'HARDWARE NOT OK'))
                    retmsg.append(["UNSUPPORTED_BROWSER_REDIRECT", gamedata['server']['mobile_fail_url']])
                    return None
                else:
                    if gamedata['server']['log_mobile_successes']:
                        gamesite.exception_log.event(server_time, 'mobile hit from player %d ACCEPTED' % player.user_id)

        if abuse_warning_msg:
            retmsg += abuse_warning_msg

        # if player is new or didn't finish the tutorial, or stale, reset
        # their state to the starting conditions

        stale_msg = None

        if Predicates.read_predicate(gamedata['server']['stale_account_reset_criteria']).is_satisfied(player, None):
            stale_msg = 'RESET'
            player.tutorial_state = "START"
        elif Predicates.read_predicate(gamedata['server']['stale_account_repair_criteria']).is_satisfied(player, None):
            stale_msg = 'REPAIR'
            player.repair_stale_account()

        if stale_msg and gamedata['server']['log_stale_accounts']:
            if 'sessions' in player.history and len(player.history['sessions']) > 0:
                last_login_date = '%d days ago' % ((server_time - player.history['sessions'][-1][0]) / (24*60*60))
            else:
                last_login_date = 'UNKNOWN'

            gamesite.exception_log.event(server_time, 'player %d account is stale (last login %s) - %s' % \
                                         (player.user_id, last_login_date, stale_msg))

        if player.tutorial_state != "COMPLETE":
            player.reset()

        # record that the player is logged in now
        player.lock_state = Player.LockState.logged_in
        player.lock_time = server_time

        if player.creation_time == server_time:
            is_returning_user = 0
        else:
            is_returning_user = 1

        if player.history.get('money_spent', 0) > 0:
            is_paying_user = 1
        else:
            is_paying_user = 0

        # create the new session
        session = Session(session_id, user, player, server_time)

        # assign player to A/B test cohorts
        player.read_url_overrides(user, url_qs)
        player.update_abtests(session, not is_returning_user)

        if player.tutorial_state != "COMPLETE":
            # note: this must come AFTER abtests are set up, since they may override starting conditions
            init_game(player, 0)

        player.my_home.spawn_scenery(player, user.user_id) # time-constant seed

        # upon success, retmsg will be ignored, and future client messages should go via session.outgoing_messages
        session.outgoing_messages = retmsg # !!!
        # kick-start HTTP request processing
        session.sync_requests.append(request)
        session.async_ds.append(d) # caller will attach complete_async_request()

        # get rid of old combat debris
        player.update_inerts()
        player.prune_ai_instance_generations()
        player.prune_inventory(session)
        player.prune_mailbox()
        player.prune_cooldowns()
        player.prune_sessions()
        player.prune_activity()
        player.prune_battle_history()
        player.spawn_deposits(user.user_id ^ int(server_time)) # time-varying seed
        player.migrate(session, user.user_id, user.account_creation_time, is_returning_user)
        player.prune_player_auras(is_session_change = True, is_login = True)

        player.my_home.base_resource_loot = None # reset base_resource_loot state on login
        player.my_home.base_res_looter_state = None # dump ResLooter state on login

        # check the data proxyserver attached to the session to see if there are other players logging in from the same IP
        # note: must be done AFTER migrate() since the format of known_alt_accounts has changed
        if client_session_data:
            possible_alts = map(int, client_session_data.split(','))
            for alt in possible_alts:
                player.possible_alt_record_login(alt, ip = client_ip)

        on_login_cons = player.get_abtest_consequent('on_login_pre_hello', fail_missing = False)
        if on_login_cons:
            snap = session.player.resources.calc_snapshot()
            session.execute_consequent_safe(on_login_cons, session.player, retmsg,
                                            context = {'max_inventory': snap.max_inventory(), 'cur_inventory': snap.cur_inventory(),
                                                       'cur_gamebucks': snap.gamebucks,
                                                       'largest_purchase': session.player.history.get('largest_purchase', 0),
                                                       'largest_purchase_gamebucks': session.player.history.get('largest_purchase_gamebucks', 0)},
                                            reason='on_login_pre_hello')

        admin_stats.add_visit(user.user_id, not is_returning_user, is_paying_user)

        session.increment_player_metric('logged_in_times', 1, time_series = False)
        if 'sessions' not in player.history:
            player.history['sessions'] = []
        player.history['sessions'].append([server_time,-1])

        self.log_record_session(session, session.login_time, -1, 'CLIENT_HELLO')

        needs_daily_attack = False

        if player.tutorial_state == "COMPLETE" and \
           (not player.has_damage_protection()) and \
           (server_time - session.player.last_daily_attack) > player.get_any_abtest_value('daily_attack_interval', gamedata['daily_attack_interval']):
            base_damage = player.my_home.calc_base_damage()
            # conventional daily attack
            if player.get_any_abtest_value('enable_daily_attacks', gamedata['enable_daily_attacks']) and \
               player.resources.player_level >= gamedata['ai_attacks']['min_level'] and \
               random.random() < player.get_any_abtest_value('daily_attack_chance', gamedata['daily_attack_chance']) and \
               base_damage < gamedata['ai_attacks']['max_base_damage']:
                needs_daily_attack = True

            if gamedata['server']['login_abuse_detector']['enable_auto_attack'] and player_is_naughty:
                gamesite.exception_log.event(server_time, 'player %d has logged in excessively - triggering AI attack!' % player.user_id)
                needs_daily_attack = True

        if session.user.frame_platform == 'fb':
            user.retrieve_facebook_info(session)
            user.retrieve_facebook_requests_start()
            user.retrieve_facebook_credit_info_start()

            # note: as of 2016 August 22, Facebook changed the query string for App Request hits
            # it's a bit ambiguous now - I think the only way to be SURE what kind of request
            # it was would be to actually ping the request_id objects and inspect them!

            # record FB notification hits
            if ('fb_source' in url_qs) and (url_qs['fb_source'][0] == 'notification') and \
               ('app_request_type' not in url_qs or url_qs['app_request_type'][0] != 'user_to_user') and \
               ('fb_ref' in url_qs):

                medium = url_qs['utm_medium'][0] if 'utm_medium' in url_qs else None
                fb_ref = url_qs['fb_ref'][0]

                # strip suffixes applied by retention_newbie.py
                ref = fb_ref

                # strip A/B test suffix
                if len(ref) >= 3 and ref[-2] == '_' and ref[-1] >= 'A' and ref[-1] <= 'Z': ref = ref[:-2]
                # strip n2_class suffix
                if ref.endswith('_n') or ref.endswith('_e') or ref.endswith('_m'): ref = ref[:-2]

                metric_event_coded(user.user_id, '7131_fb_notification_hit',
                                   {'sum': session.player.get_denormalized_summary_props('brief'),
                                    'fb_ref': fb_ref, 'ref': ref, 'medium': medium})

                Notification2.ack(server_time, Notification2.ref_to_stream(ref), ref, session.player.history)

                # legacy ack tracking
                for IGNORE in ('_24h', '_168h'):
                    ref = ref.replace(IGNORE, '')

                dict_increment(session.player.history, 'fb_notification:'+ref+':clicked', 1)
                # reset unacked counter
                if 'notification:'+ref+':unacked' in session.player.history:
                    del session.player.history['notification:'+ref+':unacked']

            # record FB request (invite or gift) hits
            if ('fb_source' in url_qs) and (url_qs['fb_source'][0] == 'notification') and \
               ('app_request_type' in url_qs) and (url_qs['app_request_type'][0] == 'user_to_user') and \
               ('request_ids' in url_qs):
                request_event = None

                if 'content' in url_qs and url_qs['content'][0].startswith('send'): # this is *probably* a gift
                    request_event = '4107_send_gifts_hit_redundant' if is_returning_user else '4106_send_gifts_hit_acquisition'
                    request_id = url_qs['request_ids'][0].split(',')[0]

                elif ('content' not in url_qs): # this is *probably* a friend invite
                    request_event = '7107_invite_friends_hit_redundant' if is_returning_user else '7106_invite_friends_hit_acquisition'

                    for request_id in url_qs['request_ids'][0].split(','):
                        if (not is_returning_user):
                            # update acquisition data - we need to rewrite retrieve_facebook_requests_complete(), it's old and creaky
                            user.update_acquisition_data({'facebook_request_id': request_id.split('_')[0], 'type': 'facebook_friend_invite'})


                if request_event:
                    metric_event_coded(user.user_id, request_event,
                                       {'sum': session.player.get_denormalized_summary_props('brief'),
                                        'request_id': request_id,
                                        'message': query_string
                                        })

            # check status of any unhandled inflight payments
            user.ping_fbpayments(session, retmsg, [data['request_id'] for key, data in player.fbpayments_inflight.items()])
        elif session.user.frame_platform in ('kg','k2'):
            user.retrieve_kg_info(session, retmsg)
        elif session.user.frame_platform == 'ag':
            user.retrieve_ag_info(session, retmsg)
        elif session.user.frame_platform == 'bh':
            bh_deferred = user.retrieve_bh_info(session, retmsg)

            # record BH notification hits
            if ('bh_source' in url_qs) and (url_qs['bh_source'][0] == 'notification') and \
               ('ref' in url_qs) and ('fb_ref' in url_qs) and url_qs['ref'][0]:
                ref = url_qs['ref'][0]
                fb_ref = url_qs['fb_ref'][0]
                medium = url_qs['utm_medium'][0] if 'utm_medium' in url_qs else None

                metric_event_coded(user.user_id, '7131_fb_notification_hit',
                                   {'sum': session.player.get_denormalized_summary_props('brief'),
                                    'fb_ref': fb_ref, 'ref': ref, 'medium': medium})
                dict_increment(player.history, 'fb_notification:'+ref+':clicked', 1)
                # reset unacked counter
                if 'notification:'+ref+':unacked' in player.history:
                    del player.history['notification:'+ref+':unacked']
                Notification2.ack(server_time, Notification2.ref_to_stream(ref), ref, player.history)

            if ('bh_invite' in url_qs):
                # delay this until the first info query finishes, so that bh_username is valid
                bh_deferred.addCallback(lambda result, _session=session, _url_qs=url_qs, _is_returning_user=is_returning_user: \
                                        _session.user.accept_bh_invite(_session, _url_qs['bh_invite'][-1],
                                                                       not _is_returning_user))

            # this can proceed asynchronously
            user.retrieve_bh_friends(session)

        elif session.user.frame_platform == 'mm':
            user.retrieve_mm_info(session, retmsg)

        # record acquisition or reacquisition
        acq_event_props = {'anon_id': metrics_anon_id,
                           'social_id': social_id,
                           'session_id':session_id,
                           'frame_platform': frame_platform,
                           'country': user.country or client_login_country,
                           'country_tier': SpinConfig.country_tier_map.get(user.country or client_login_country, 4),
                           'query_string': query_string,
                           'ip':client_ip,
                           'browser_OS':user.browser_os,
                           'browser_name':user.browser_name,
                           'browser_version':user.browser_version,
                           'spin_client_platform':user.spin_client_platform,
                           'spin_client_vendor':user.spin_client_vendor,
                           'spin_client_version':user.spin_client_version,
                           'browser_hardware':user.browser_hardware}

        if client_permissions: acq_event_props['scope'] = client_permissions
        if acq_data:
            acq_event_props['method'] = acq_data['type']
            # set acquisition_campaign exactly as it will be set in user.acquisition_campaign
            acq_event_props['acquisition_campaign'] = acq_data['campaign_name'] if acq_data['type']=='ad_click' else acq_data['type']
            for FIELD in ('campaign_name', 'age_group', 'ad_image', 'ad_title', 'ad_text', 'ad_target', 'ad_skynet', 'referring_user_id'):
                if FIELD in acq_data:
                    acq_event_props[FIELD] = acq_data[FIELD]
            if 'facebook_request_ids' in acq_data: # only include first request ID
                acq_event_props['facebook_request_id'] = acq_data['facebook_request_ids'][0]

        if (frame_platform == 'fb') and ('fb_source' in url_qs): # record fb_source parameter
            acq_event_props['fb_source'] = url_qs['fb_source'][0]


        # send the events
        metric_event_coded(user.user_id, '0115_logged_in', copy.deepcopy(acq_event_props))

        is_reacquisition = False

        if user.account_creation_time == server_time:
            metric_event_coded(user.user_id, '0110_created_new_account', acq_event_props)
        elif (player.last_logout_time() > 0) and (server_time - player.last_logout_time() >= SpinConfig.ACCOUNT_LAPSE_TIME):
            acq_event_props['sum'] = player.get_denormalized_summary_props('brief')
            acq_event_props['lapse_time'] = server_time - player.last_logout_time()
            metric_event_coded(user.user_id, '0112_account_reacquired', acq_event_props)
            is_reacquisition = True

        session.send_adnetwork_acquisition_event(retmsg)
        session.send_adnetwork_visit_event(retmsg)
        session.send_adnetwork_events(retmsg)

        # record acquisition data (for this visit)
        user.update_acquisition_data(acq_data, important = ((not is_returning_user) or is_reacquisition))

        retmsg.append(["SERVER_HELLO",
                       gamedata["version"],
                       session.user.user_id,
                       session_id,
                       server_time, # not used anymore!
                       session.user.facebook_name,
                       session.player.tutorial_state,
                       session.player.player_preferences,
                       needs_daily_attack,
                       session.user.country,
                       session.player.country_tier,
                       session.player.price_region,
                       session.player.history['logged_in_times'],
                       session.player.abtests,
                       session.player.is_developer(),
                       session.user.is_suspicious(),
                       session.player.isolate_pvp,
                       session.user.acquisition_campaign,
                       session.player.my_home.base_id,
                       session.player.history.get('money_spent',0),
                       session.player.creation_time,
                       session.player.chat_seen,
                       session.user.is_chat_mod(),
                       session.player.get_daily_banner(session, retmsg),
                       session.user.get_fb_likes_preload(),
                       session.user.vpn_status
                       ])
        retmsg.append(["PLAYER_UI_NAME_UPDATE", session.user.get_ui_name(session.player)])
        retmsg.append(["PLAYER_ALIAS_UPDATE", session.player.alias])
        retmsg.append(["PLAYER_TITLES_UPDATE", session.player.title])
        retmsg.append(["PLAYER_PRIVACY_CONSENT_UPDATE", session.user.privacy_consent])

        # check for promo codes
        if ('spin_promo_code' in url_qs):
            for code in url_qs['spin_promo_code']:
                session.player.apply_promo_code(session, retmsg, code)

        if session.player.tutorial_state == "COMPLETE":
            # force repairs to start to avoid exploits where you leave your own buildings unrepaired
            self.do_start_repairs(session, None, session.player.my_home.base_id, repair_units = False)

            session.player.ladder_point_decay_check(session) # login

        if session.user.frame_platform == 'fb':
            retmsg.append(["FACEBOOK_CURRENCY_UPDATE", session.user.facebook_currency])
            if session.user.facebook_third_party_id:
                retmsg.append(["FACEBOOK_THIRD_PARTY_ID_UPDATE", session.user.facebook_third_party_id])

        # note: sends both SQUADS_UPDATE and PLAYER_ARMY_UPDATE
        session.player.ping_squads_and_send_update(session, retmsg, originator=session.player.user_id, reason='SERVER_HELLO')

        self.change_session(session, retmsg, dest_user_id = user.user_id, force = True).addCallbacks(lambda success, self=self, session=session, retmsg=retmsg, d=d: self.complete_client_hello2(success, d, session, retmsg), lambda err, self=self, session=session, retmsg=retmsg, d=d: self.complete_client_hello2(False, d, session, retmsg))
        return d

    @admin_stats.measure_latency('complete_client_hello2')
    def complete_client_hello2(self, success, d, session, retmsg):
        # there's a race window where terminate_session() is called between change_session() and here,
        # and the invalidation doesn't work since we past CLIENT_HELLO but not in the session table yet.
        # XXX band-aid fix for now - need to untangle the login path later...
        if session.session_id in invalid_sessions:
            if gamedata['server']['log_abnormal_logins'] >= 2:
                gamesite.exception_log.event(server_time, 'user %d almost logged in with invalidated session %s' % (session.user.user_id, session.session_id))
            retmsg.append(["ERROR", "CANNOT_LOG_IN_SIMULTANEOUS"])
            ascdebug('UNLOCKED player %d (complete_client_hello2 invalidated)' % session.user.user_id)
            gamesite.lock_client.player_lock_release(session.user.user_id, -1, Player.LockState.logged_in, expected_owner_id = session.user.user_id)
            d.callback(session) # return session so that complete_async_request gets called
            return

        if success:
            try:
                self.do_complete_client_hello2(d, session, retmsg)
                return
            except:
                gamesite.exception_log.event(server_time, ('complete_client_hello2 Exception (player %d): ' % session.user.user_id) + traceback.format_exc().strip()) # OK

        # failure path
        retmsg[:] = [["ERROR", "SERVER_EXCEPTION"]] # blow away old message, because session is not going to be set up
        ascdebug('UNLOCKED player %d (complete_client_hello2 failure)' % session.user.user_id)
        gamesite.lock_client.player_lock_release(session.user.user_id, -1, Player.LockState.logged_in, expected_owner_id = session.user.user_id)
        d.callback(None) # return error instead of session

    def do_complete_client_hello2(self, d, session, retmsg):
        user = session.user
        player = session.player

        if player.tutorial_state != "COMPLETE":
            spawn_tutorial_units(session, retmsg)

        retmsg.append(["TECH_UPDATE", session.player.tech])
        retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])
        session.player.send_inventory_update(retmsg)

        retmsg.append(["PLAYER_UNIT_EQUIP_UPDATE", session.player.unit_equipment])
        assert session.player.stattab.player is session.player
        session.player.stattab.send_update(session, retmsg) # should be up to date from load_tech/auras_and_init_stattab()

        retmsg.append(["QUEST_STATE_UPDATE", session.player.completed_quests])

        retmsg.append(["PLAYER_TRAVEL_UPDATE", session.player.travel_state])

        # set up alliance state
        alliance_info = None
        alliance_membership = None
        alliance_chat_catchup_messages = []
        alliance_join_requests = None

        alliance_info, alliance_membership = session.init_alliance(alliance_chat_catchup_messages, reason = 'SERVER_HELLO')

        # fix missing alliances_joined count in player_history, for quest purposes
        if alliance_info and ('alliances_joined' not in session.player.history): session.player.history['alliances_joined'] = 1

        # for leaders, get pending join requests
        if alliance_info and (alliance_info.get('leader_id', -1) == session.player.user_id):
            alliance_join_requests = gamesite.sql_client.poll_join_requests(session.player.user_id, alliance_info['id'], server_time, reason='SERVER_HELLO')

        if session.alliance_chat_channel and gamedata['server']['chat_alliance_logins']:
            session.do_chat_send(session.alliance_chat_channel, 'I logged in!', bypass_gag = True, props = {'type':'logged_in'})

        if alliance_info:
            gamesite.sql_client.alliance_activity(alliance_info['id'], reason = 'SERVER_HELLO')

        # accept any queued messages the user has received
        mail_stat = self.do_receive_mail(session, retmsg, is_login = True)
        show_battle_history = mail_stat and mail_stat.get('was_attacked', False)

        # add new BH blog feed entries to mailbox
        self.add_bh_blog_feed_to_mail(session)

        # send alliance state
        retmsg.append(["ALLIANCE_UPDATE", alliance_info['id'] if alliance_info else -1, (not mail_stat.get('new_alliance', False)), alliance_info, alliance_membership, mail_stat.get('new_alliance_role', False)])
        if alliance_join_requests:
            pcache_data = self.do_query_player_cache(session, alliance_join_requests, reason = 'ALLIANCE_JOIN_REQUESTS')
            retmsg.append(["ALLIANCE_JOIN_REQUESTS", alliance_join_requests, pcache_data])

        # check cache and begin background retrieval of user's Facebook info
        user.repopulate_ai_list(session)
        user.populate_friends_who_play(session)

        # send applicable daily messages
        session.player.get_daily_messages(session, retmsg)

        session.player.send_mailbox_update(retmsg)

        # note: history update should come AFTER receiving mail and promo codes, since that updates history
        session.player.send_history_update(retmsg)

        # queue battle history jewel update
        session.player.send_battle_history_update(retmsg)

        # note: achievements update should come AFTER history update, so that client will resolve PLAYER_HISTORY predicates in achievements correctly
        retmsg.append(["ACHIEVEMENTS_UPDATE", session.player.achievements])

        if session.player.tutorial_state == "COMPLETE" and Predicates.read_predicate(gamedata['client']['motd_filter']).is_satisfied2(session, session.player,None):
            # check if player is due for various popups
            force_time = session.player.get_any_abtest_value('motd_refresh_time', gamedata['server']['message_of_the_day'].get('refresh_time',-1))
            if ((server_time - session.player.last_motd) > gamedata['client']['motd_interval']) or \
               (session.player.last_motd < force_time) or \
               session.player.force_motd:
                session.player.last_motd = server_time
                session.player.get_daily_tips(session, retmsg)

            # check if we should prompt the player to invite friends
            if ((server_time - session.player.last_friend_invite_prompt) > gamedata['client']['friend_invite_prompt_interval']):
                session.player.last_friend_invite_prompt = server_time
                retmsg.append(["INVITE_FRIENDS_PROMPT"])

            # check if we should prompt the player to send gifts
            if ((server_time - session.player.last_gift_prompt) > gamedata['client']['gift_prompt_interval']):
                session.player.last_gift_prompt = server_time
                retmsg.append(["GIFT_PROMPT"])


        session.init_global_chat(retmsg)

        # notify player about recent attacks
        if len(session.player.recent_attacks) > 0:
            retmsg.append(["YOU_WERE_ATTACKED", session.player.recent_attacks])
            session.player.recent_attacks = []
        if show_battle_history:
            retmsg.append(["SHOW_BATTLE_HISTORY"])

        retmsg.append(["HAS_ALTS_UPDATE", session.player.has_alts()])

        if gamedata['server'].get('track_countries_seen', False):
            if 'country_history' not in session.player.history:
                session.player.history['country_history'] = {}
            if session.user.country != 'unknown':
                session.player.history['country_history'][session.user.country] = server_time
            countries_seen = 0
            for country, last_login in session.player.history['country_history'].iteritems():
                if server_time - last_login < gamedata['server'].get('track_countries_interval', 7*86400):
                    countries_seen += 1
            ip_rep_result = None
            if ip_rep_checker:
                ip_rep_result = ip_rep_checker.query(session.user.last_login_ip) # only log 'suspicious' IPs if they are not already known VPNs
            log_ip = False
            if ip_rep_result:
                if not ip_rep_result.is_proxy() and not ip_rep_result.is_datacenter():
                    log_ip = True

            if log_ip and countries_seen >= gamedata['server'].get('track_countries_limit', 2):
                metric_event_coded(session.player.user_id, '7400_suspicious_ip_activity', {'ip': session.user.last_login_ip,
                                                                                           'reason': 'country-hopping'})

        if session.player.alias and not is_valid_alias(session.player.alias):
            metric_event_coded(session.player.user_id, '0990_invalid_alias_detected', {'alias': session.player.alias,
                                                                                       'receipts': session.player.history.get('money_spent', 0.00)})

        if session.player.alias and Predicates.read_predicate(gamedata['server'].get('warn_invalid_alias_on_login',{'predicate':'ALWAYS_FALSE'})).is_satisfied2(session, session.player, None, override_time = None) and gamedata['strings'].get('warn_invalid_alias_mail', False) and not is_valid_alias(session.player.alias):
            session.player.mailbox_append(session.player.make_system_mail(gamedata['strings']['warn_invalid_alias_mail'], replace_s = '%s' % session.player.alias))
            try:
                gamesite.exception_log.event(server_time, 'Invalid alias, %s, detected for player ID %d. Sending warning email.' % (session.player.alias, session.player.user_id ))
            except:
                gamesite.exception_log.event(server_time, 'Invalid alias detected for player ID %d. Sending warning email.' % (session.player.user_id ))
            session.player.history['invalid_alias_warned'] = 1
            metric_event_coded(session.player.user_id, '0991_invalid_alias_warned', {'alias': session.player.alias,
                                                                                       'receipts': session.player.history.get('money_spent', 0.00)})

        if session.player.alias and Predicates.read_predicate(gamedata['server'].get('reset_invalid_alias_on_login',{'predicate':'ALWAYS_FALSE'})).is_satisfied2(session, session.player, None, override_time = None) and not is_valid_alias(session.player.alias):
            old_ui_name = session.player.alias
            session.player.alias = None
            new_ui_name = session.user.get_real_name()
            gamesite.pcache_client.player_cache_update(session.player.user_id, {'ui_name': new_ui_name, 'ui_name_searchable': new_ui_name.lower()})
            change_alias_log = {'time':server_time, 'spin_user':'login_process', 'method':'clear_alias', 'ui_reason':'Invalid alias, met requirements for reset_invalid_alias_on_login in game settings.'}
            if 'customer_support' not in session.player.history:
                session.player.history['customer_support'] = []
            session.player.history['customer_support'].append(change_alias_log)
            if gamedata['strings'].get('notify_invalid_alias_reset_mail'):
                session.player.mailbox_append(session.player.make_system_mail(gamedata['strings']['notify_invalid_alias_reset_mail'], replace_s = '%s' % old_ui_name))
                try:
                    gamesite.exception_log.event(server_time, 'Invalid alias, %s, detected for player ID %d. Reset alias to none and notified player via game message.' % (old_ui_name, session.player.user_id))
                except:
                    gamesite.exception_log.event(server_time, 'Invalid alias detected for player ID %d. Reset alias to none and notified player via game message.' % session.player.user_id)
            else:
                try:
                    gamesite.exception_log.event(server_time, 'Invalid alias, %s, detected for player ID %d. Reset alias to none. Warning: player notification message not found in gamedata["strings"]["notify_invalid_alias_reset_mail"].' % (old_ui_name, session.player.user_id))
                except:
                    gamesite.exception_log.event(server_time, 'Invalid alias detected for player ID %d. Reset alias to none. Warning: player notification message not found in gamedata["strings"]["notify_invalid_alias_reset_mail"].' % session.player.user_id)
            metric_event_coded(session.player.user_id, '0992_invalid_alias_reset', {'alias': session.player.alias,
                                                                                    'receipts': session.player.history.get('money_spent', 0.00)})

        if session.player.frame_platform == 'bh' and session.player.history.get('money_spent', 0.00) > 0.00:
            bh_id = session.user.bh_id
            bh_token = session.user.bh_auth_token
            update_bh_user_spend(bh_id, session.player.history['money_spent'], session.player.user_id, bh_token)

        if session.player.is_on_map():
            assert session.player.home_region and (session.player.my_home.base_region == session.player.home_region)

            # if we're in a region that zeros out trophy points, ensure we're at zero here.
            if session.player.home_region in gamedata['regions'] and \
               gamedata['regions'][session.player.home_region].get('zero_points_on_entry', False) and \
               session.player.ladder_points() != gamedata['trophy_floor']['pvp']:
                session.player.modify_scores({'trophies_pvp':gamedata['trophy_floor']['pvp']}, method='=', reason = 'zero_points_on_entry_login')

            # optional zero out trophy points if predicate is met, ensure we're at zero here.
            if session.player.home_region in gamedata['regions'] and \
               Predicates.read_predicate(gamedata['regions'][session.player.home_region].get('zero_points_on_entry_if',{'predicate':'ALWAYS_FALSE'})).is_satisfied2(session, session.player, None, override_time = None) and \
               session.player.ladder_points() != gamedata['trophy_floor']['pvp']:
                session.player.modify_scores({'trophies_pvp':gamedata['trophy_floor']['pvp']}, method='=', reason = 'zero_points_on_entry_if_login')

            # ping the map to update login status for the player's home base (sends broadcast of lock acquire)
            if not session.player_base_lock:
                if gamesite.nosql_client.map_feature_lock_acquire(session.player.my_home.base_region, session.player.my_home.base_id, session.player.user_id,
                                                                  desired_state = Player.LockState.logged_in, reason = 'SERVER_HELLO') == Player.LockState.logged_in:
                    session.player_base_lock = (session.player.my_home.base_region, session.player.my_home.base_id)

                    # XXXXXX only necessary during migration, shouldn't be necessary once all updates are sent in real-time
                    gamesite.nosql_client.update_map_feature(session.player.my_home.base_region, session.player.my_home.base_id, {'protection_end_time': session.player.resources.protection_end_time}, reason = 'SERVER_HELLO')

                else:
                    # uh oh, can't acquire our own home base lock - playerdb and map feature state are out of sync
                    gamesite.exception_log.event(server_time, 'player %d could not get own home base lock in %s on login, plucking from map!' % (session.player.user_id, session.player.home_region))
                    # re-place on map
                    session.player.home_region = session.player.my_home.base_region = session.player.my_home.base_map_loc = None
                    session.player.history['map_placement_gen'] = -1
                    session.player.update_map_placement(session, retmsg)

            retmsg.append(["REGION_CHANGE", session.player.home_region, session.player.my_home.base_map_loc, True, session.player.my_home.base_climate])
            if gamedata['regions'][session.player.home_region].get('enable_turf_control',False):
                retmsg.append(["REGION_TURF_UPDATE", session.player.home_region, gamesite.nosql_client.alliance_turf_get_by_region(session.player.home_region, reason = 'login')])
            session.init_region_chat(session.player.home_region, retmsg)

        retmsg.append(["MAP_BOOKMARKS_UPDATE", session.player.map_bookmarks])

        # this needs to come AFTER map state is initialized, because messages can be region-dependent
        if alliance_chat_catchup_messages: retmsg += alliance_chat_catchup_messages

        self.send_player_cache_update(session, 'login') # mainly for uninstalled flag and last_login_time

        # mark end of login messages
        retmsg.append(["END_SERVER_HELLO"])

        on_login_cons = player.get_abtest_consequent('on_login_post_hello', fail_missing = False)
        if on_login_cons:
            session.execute_consequent_safe(on_login_cons, session.player, retmsg,
                                            context = {}, reason='on_login_post_hello')

        session.last_active_time = server_time

        # since CLIENT_HELLO is a special case outside the usual message buffer handling,
        # we have to bump the expected next serial number here
        session.incoming_serial += 1
        session_table[session.session_id] = session
        d.callback(session)

    # like login, logout is broken into pre- and post-I/O portions

    # new asynchronous logout
    # it should be safe to call this function from any context
    def log_out_async(self, session, method, force = False):

        if session.logout_in_progress:
            if deferred_is_finished(session.logout_d):
                ascdebug('log_out_async (already finished) %d' % (session.user.user_id))
                # session has ALREADY finished logging out - this is a dangling reference!
                return defer.succeed(True) # probably OK to return session.logout_d, but that might have exceptions on it
            elif force:
                # do not wait for complete_attack(), just kill the session
                gamesite.exception_log.event(server_time, 'log_out_async: force-dropping broken session for player %d - possible data loss! logout_d %r' % (session.user.user_id, session.logout_d))
                session.logout_in_progress.wrote_user = True
                session.logout_in_progress.wrote_player = True
                reactor.callLater(0, session.logout_in_progress.try_finish)
                return defer.succeed(True)
            else:
                ascdebug('log_out_async (waiting) %d' % (session.user.user_id))
                return session.logout_d

        ascdebug('log_out_async %d' % (session.user.user_id))
        session.debug_log_action('log_out_async (%s)' % method)

        session.logout_in_progress = Session.AsyncLogout(session)
        session.logout_d = make_deferred('log_out_async')

        # we're going to get this exception from complete_async_request if after_async_request() waits, so absorb it
        def absorb_logout_exception(fail):
            fail.trap(Session.AlreadyLoggedOut)
            return None
        session.logout_d.addErrback(absorb_logout_exception)

        # if an attack was going on, clean it up
        session.logout_d.addCallback(lambda _, self=self,session=session:
                                     self.complete_attack(session, session.outgoing_messages, reason='log_out_async'))
        session.logout_d.addErrback(report_and_absorb_deferred_failure, session)

        # then continue with preflush
        session.logout_d.addCallback(lambda _, self=self, session=session, method=method:
                                     self.log_out_preflush(session, method))
        session.logout_d.addErrback(report_and_absorb_deferred_failure, session)

        # then session.shutdown
        session.logout_d.addCallback(lambda _, session=session, method=method: session.shutdown(method))
        session.logout_d.addErrback(report_and_absorb_deferred_failure, session)

        # then the flush happens...
        def flushit(session):
            user_table.store_async(session.user, session.logout_in_progress.user_cb, True, 'logout')
            player_table.store_async(session.player, session.logout_in_progress.player_cb, True, 'logout')
            return session.logout_in_progress.d or True

        session.logout_d.addCallback(lambda _, session=session: flushit(session))
        session.logout_d.addErrback(report_and_absorb_deferred_failure, session)

        # then postflush cleanup
        session.logout_d.addCallback(lambda _, self=self, session=session: self.log_out_postflush(session))

        return session.after_async_request(session.logout_d)

    def log_out_preflush(self, session, method):
        # PRE-WRITE portion

        session.player.prune_player_auras(is_logout = True)

        # force repairs to start to avoid exploits where you leave your own buildings unrepaired
        self.do_start_repairs(session, None, session.player.my_home.base_id, repair_units = False)
        session.player.ladder_point_decay_check(session) # logout

        # log metric event
        if method == 'timeout' or method == 'server_restart':
            # if a session times out, record the play time ending with
            # the player's last action, not with the current time
            logout_time = session.last_active_time
        else:
            logout_time = server_time

        playtime = logout_time - session.login_time

        # close final session
        session.player.history['sessions'][-1][1] = logout_time

        # record un-merged list of most recent (completed) sessions, for login abuse detection
        KEEP_RECENT_SESSIONS = gamedata['server'].get('track_last_raw_sessions', 200)
        if KEEP_RECENT_SESSIONS > 0:
            if 'last_raw_sessions' not in session.player.history:
                session.player.history['last_raw_sessions'] = []
            if len(session.player.history['last_raw_sessions']) > KEEP_RECENT_SESSIONS:
                del session.player.history['last_raw_sessions'][:-KEEP_RECENT_SESSIONS]
            session.player.history['last_raw_sessions'].append([session.login_time, logout_time])
        elif 'last_raw_sessions' in session.player.history:
            del session.player.history['last_raw_sessions']

        session.user.last_logout_time = logout_time

        metric_event_coded(session.user.user_id, '0900_logged_out',
                           {'method': method,
                            'playtime': playtime,
                            'last_active_time': session.last_active_time})

        # write MongoDB events
        if gamesite.nosql_client and gamedata['server'].get('log_dau_in_nosql', True):
            gamesite.nosql_client.dau_record(session.login_time, session.user.user_id, session.player.country_tier, playtime)

        self.log_record_session(session, session.login_time, logout_time, 'log_out_preflush')

        # add up play time
        session.increment_player_metric('time_in_game', playtime, time_series = False, bucket = True)
        session.setmax_player_metric('cum_time_in_game', session.player.history.get('time_in_game', 0)+playtime, time_series = False, bucket = True)

        if session.user.acquisition_campaign and (not session.user.acquisition_secondary):
            admin_stats.add_logout(session.user.user_id, session.user.acquisition_campaign, playtime)

        # track resource levels
        for res in gamedata['resources']:
            session.setvalue_player_metric('stored_'+res, getattr(session.player.resources,res), time_series=False, bucket=True, bucket_size=15*60)

        # record final activity sample
        session.record_activity_sample(force = True)

        session.send_adnetwork_events(None)
        self.send_fb_achievements(session)
        self.log_out_preflush_open_graph(session)
        self.send_kg_score_update(session)

        alliance_id = gamesite.sql_client.get_users_alliance(session.user.user_id, reason = 'log_out_preflush')
        if alliance_id >= 0:
            session.player.history['alliance_id_cache'] = alliance_id
        else:
            alliance_id = None
            if 'alliance_id_cache' in session.player.history:
                del session.player.history['alliance_id_cache']

        self.send_player_cache_update(session, 'log_out_preflush', alliance_id = alliance_id)

    # record login/logout in MongoDB log
    # if recording logins (that are still active), set logout_time = -1
    # upon logout, call this again with the proper logout_time, and it will overwrite the entry.
    def log_record_session(self, session, login_time, logout_time, reason):
        assert (logout_time == -1) or (logout_time >= login_time)
        if gamesite.nosql_client and gamedata['server'].get('log_sessions_in_nosql', True):
            props = {'user_id': session.user.user_id,
                     'in': login_time,
                     'out': logout_time}
            props.update(session.player.get_denormalized_summary_props('brief'))
            # unique tuple for each session
            id_key = '%d:%d:%s' % (session.user.user_id, login_time, session.session_id[0:4])
            gamesite.nosql_client.log_record('log_sessions', server_time, props, id_key=id_key, reason=reason)

    def send_fb_achievements(self, session):
        if not session.user.facebook_id: return
        if session.player.isolate_pvp or (session.player.tutorial_state != "COMPLETE"): return
        if not session.player.get_any_abtest_value('enable_fb_achievements', gamedata['enable_fb_achievements']): return
        if ((not session.player.facebook_permissions) or ('publish_actions' not in session.player.facebook_permissions)): return
        for name, player_data in session.player.achievements.iteritems():
            if name not in gamedata['achievements']: continue
            data = gamedata['achievements'][name]
            if 'fb_open_graph' not in data: continue
            if not data['fb_open_graph'].get('publish', True): continue
            if player_data.get('fb_published', False): continue

            endpoint = OGPAPI_instance.get_object_endpoint({'type':OGPAPI.object_type('achievement'), 'name': name})
            params = {'achievement': str(endpoint)}
            query = urllib.urlencode(params)
            url = SpinFacebook.versioned_graph_endpoint_secure('achievement', str(session.user.facebook_id)+'/achievements')
            if SpinConfig.config['enable_facebook']:
                if gamedata['server']['log_fb_achievements']:
                    gamesite.exception_log.event(server_time, 'send_fb_achievements(POST %s query %s)' % (url, query))
                gamesite.AsyncHTTP_Facebook.queue_request(server_time, url, lambda result: None, method = 'POST', postdata = query)
                player_data['fb_published'] = 1
            else:
                gamesite.exception_log.event(server_time, 'Facebook disabled: send_fb_achievements(POST %s query %s)' % (url, query))

    def send_kg_score_update(self, session):
        my_points = session.player.ladder_points()
        if my_points > 0:
            for api, context in session.adnetworks():
                if api == 'kg_conversion_pixels' and 'high_score_event' in gamedata['adnetworks'][api]: # only applies to KG network
                    session.do_send_adnetwork_event_serverside(None, 'kg_conversion_pixels', context, 'high_score_event', gamedata['adnetworks'][api]['high_score_event'], extra_qs = {"AllTimePvPPoints": my_points})

    def log_out_preflush_open_graph(self, session):
        # send FB open graph leaderboard update (throttle by time and level)
        # NOTE: writes player.last_rank_update etc, so must be done pre-flush!

        if not session.user.facebook_id: return

        if (not session.player.isolate_pvp):
            if session.player.tutorial_state == "COMPLETE":
                session.player.send_fb_score_update(session.user.facebook_id,
                                                    session.player.resources.xp)


    def log_out_postflush(self, session):
        ascdebug('log_out_postflush %d' % (session.user.user_id))
        session.debug_log_action('log_out_postflush')

        # remove the session from the global session table
        if session_table.get(session.session_id, None) is session:
            del session_table[session.session_id]

        # final step - release locks

        if session.player.is_on_map():
            # update status of player's home base on map, and broadcast lock release
            # assert session.player_base_lock
            gamesite.nosql_client.map_feature_lock_release(session.player.my_home.base_region, session.player.my_home.base_id, session.player.user_id, reason = 'log_out')
            session.player_base_lock = None

        ascdebug('UNLOCKED player %d (normal logout)' % session.user.user_id)
        gamesite.lock_client.player_lock_release(session.user.user_id, session.player.generation, Player.LockState.logged_in, expected_owner_id=session.user.user_id)

        if gamesite.nosql_client:
            # tell proxyserver the player is no longer logged in
            gamesite.nosql_client.session_drop_by_session_id(session.session_id)

            # send active session count to server status table
            if gamedata['server'].get('update_server_status_on_login', True):
                gamesite.nosql_client.server_status_update(spin_server_name, {'active_sessions':admin_stats.get_active_sessions()}, reason='logout')

    def send_player_cache_update(self, session, reason,
                                 # alliance update is optional. None is a possible value, so use special marker for skipping the update.
                                 alliance_id = 'skip'):

        base_damage, base_repair_time = session.player.my_home.report_base_damage_and_repair_time_for_ladder(session.player)

        # update dbserver player cache
        cache_props = {'tutorial_complete': (1 if session.player.tutorial_state == 'COMPLETE' else 0),
                       'home_region': session.player.home_region,
                       'lootable_buildings': session.player.get_lootable_buildings(),
                       'base_damage': base_damage,
                       'base_repair_time': base_repair_time,
                       'ladder_player': int(session.player.is_ladder_player(ignore_global=True)),
                       'protection_end_time': session.player.resources.protection_end_time,
                       'player_level': session.player.resources.player_level,
                       'account_creation_time': session.user.account_creation_time,
                       'last_login_time': session.user.last_login_time,
                       'last_login_ip': session.user.last_login_ip,
                       'country': session.user.country,
                       'timezone': session.user.timezone,
                       'locale': session.user.locale,
                       'developer': 1 if session.player.is_developer() else None,
                       'uninstalled': None,
                       'privacy_consent': session.user.privacy_consent,
                       'last_mtime': server_time,
                       'money_spent': session.player.history.get('money_spent',0.0),
                       'ui_name': session.user.get_ui_name(session.player),
                       'ui_name_searchable': session.user.get_ui_name_searchable(session.player)
                       }
        if reason.startswith('log_out'):
            cache_props['last_logout_time'] = session.user.last_logout_time
        real_name = session.user.get_real_name()
        if real_name != cache_props['ui_name']:
            cache_props['real_name'] = real_name
        else:
            cache_props['real_name'] = None # delete it because ui_name is all we need

        if session.user.social_id: cache_props['social_id'] = session.user.social_id
        if session.user.frame_platform: cache_props['frame_platform'] = session.user.frame_platform
        if session.user.frame_platform == 'fb':
            # publish a 0 here if FB notifications are off, otherwise None->null meaning they are on
            cache_props['enable_fb_notifications'] = 0 if (session.player.player_preferences and \
                                                           type(session.player.player_preferences) is dict and \
                                                           not session.player.player_preferences.get('enable_fb_notifications', True)) \
                                                           else None
        if session.user.facebook_id: cache_props['facebook_id'] = session.user.facebook_id
        if session.user.ag_id: cache_props['ag_id'] = session.user.ag_id
        if session.user.ag_avatar_url: cache_props['ag_avatar_url'] = session.user.ag_avatar_url
        if session.user.kg_id: cache_props['kg_id'] = session.user.kg_id
        if session.user.kg_avatar_url: cache_props['kg_avatar_url'] = session.user.kg_avatar_url
        if session.user.bh_id: cache_props['bh_id'] = session.user.bh_id
        if session.user.mm_id: cache_props['mm_id'] = session.user.mm_id

        cache_props[gamedata['townhall']+'_level'] = session.player.get_townhall_level()

        if (not gamedata['predicate_library']['pvp_requirement']['predicate'].startswith('ALWAYS_')):
            cache_props['pvp_player'] = int(session.player.is_pvp_player())

        if session.player.my_home.base_map_loc:
            cache_props['home_base_loc'] = session.player.my_home.base_map_loc

        if 'units_donated_cur_alliance' in session.player.history:
            cache_props['units_donated_cur_alliance'] = session.player.history['units_donated_cur_alliance']
        if 'help_responses_cur_alliance' in session.player.history:
            cache_props['help_responses_cur_alliance'] = session.player.history['help_responses_cur_alliance']

        if alliance_id != 'skip': # might be None
            if alliance_id is not None: assert alliance_id >= 0 # don't pass negative alliance_ids
            cache_props['alliance_id'] = alliance_id

        if session.player.isolate_pvp:
            cache_props['isolate_pvp'] = 1

        known_alt_count = sum(1 for data in session.player.known_alt_accounts.itervalues() if not data.get('ignore',False) and not \
                                (data.get('logins', 0) < gamedata['server'].get('alt_min_logins', 5)) and not \
                                (data.get('last_login', server_time) < (server_time - gamedata['server'].get('alt_ignore_age', 28*86400))))
        if known_alt_count >= 1:
            cache_props['known_alt_count'] = known_alt_count
        else:
            cache_props['known_alt_count'] = None

        session.player.idle_check.prune_history(server_time)
        idle_check_fails = session.player.idle_check.count_fails()
        if idle_check_fails >= 1:
            cache_props['idle_check_fails'] = idle_check_fails
            cache_props['idle_check_last_fail_time'] = session.player.idle_check.last_fail_time()
        else:
            cache_props['idle_check_fails'] = None
            cache_props['idle_check_last_fail_time'] = None

        gamesite.pcache_client.player_cache_update(session.user.user_id, cache_props, reason = reason)

    def handle_message_guts(self, session, arg, retmsg):

        if arg[0] == "VISIT_BASE" or arg[0] == "VISIT_BASE2" or arg[0] == "VISIT_LADDER_RIVAL":
            # do not allow overlapping client-initiated requests
            assert not session.visit_base_in_progress
            assert not session.complete_attack_in_progress

            if session.incoming_attack_pending():
                # don't allow the player to change sessions if an AI attack is about to occur
                retmsg.append(["ERROR", "INCOMING_ATTACK_PENDING"])
                return

            dest_id = None
            dest_base_id = None
            ladder_state = None
            delay = 0
            if len(arg) >= 3:
                client_props = arg[2]
            else:
                client_props = None

            if client_props and client_props.get('pre_attack',None):
                # sanity check for pre_attack option
                if client_props['pre_attack'] is True: # compatibility with old client
                    client_props['pre_attack'] = 1
                assert client_props['pre_attack'] in (1,2)
                assert session.home_base
                assert not session.has_attacked
                assert arg[0] in ("VISIT_BASE", "VISIT_BASE2")

            # special-case map/squad spying of yourself, to be a regular base visit
            if dest_base_id == home_base_id(session.player.user_id):
                dest_base_id = None
                dest_id = session.player.user_id

            if arg[0] == "VISIT_BASE2":
                # temporary test path for quarries
                dest_base_id = str(arg[1])
                if (not session.player.can_use_quarries()):
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                    return

                # check squad order cooldown
                if dest_base_id[0] == 's':
                    owner_id, squad_id = map(int, dest_base_id[1:].split('_'))
                    if owner_id == session.player.user_id:
                        cdname = 'squad_order:%d' % squad_id
                        if session.player.cooldown_active(cdname):
                            retmsg.append(["ERROR", "CANNOT_SPY_SQUAD_ON_COOLDOWN"])
                            return

            elif arg[0] == "VISIT_LADDER_RIVAL":
                force_switch = bool(arg[1]) or gamedata['matchmaking']['ladder_match_life'] <= 0
                exclude_user_ids = set()

                if (not session.player.is_ladder_player()):
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                    return

                if force_switch:
                    cost = Predicates.eval_cond_or_literal(gamedata['matchmaking']['ladder_match_switch_cost'], session, session.player)
                    for res in cost:
                        if (getattr(session.player.resources,res) < cost[res]):
                            retmsg.append(["ERROR", "INSUFFICIENT_"+res.upper(), cost[res]])
                            retmsg.append(["ERROR", "LADDER_MATCH_FAILED"])
                            return

                    negative_cost = dict((res,-cost[res]) for res in cost)
                    session.player.resources.gain_res(negative_cost, reason='ladder_switch')
                    admin_stats.econ_flow_player(session.player, 'consumption', 'ladder_switch', negative_cost)
                    session.player.record_ladder_pvp_event('3304_ladder_skip', {'defender_id': session.viewing_player.user_id,
                                                                                'battle_streak_ladder': session.player.cooldown_active('battle_streak_ladder'),
                                                                                'cost': cost})

                if force_switch:
                    session.player.cooldown_reset('ladder_match')
                    exclude_user_ids.add(session.player.ladder_match) # exclude previous ID, always
                    session.player.prune_ladder_match_history(session)
                    exclude_user_ids.update(filter(lambda x: x > 0, session.player.ladder_match_history)) # exclude previous non-generic opponents

                    # force a delay to make alt-shopping inconvenient
                    delay += gamedata['matchmaking']['ladder_match_switch_cooldown']
                    if gamedata['server']['log_ladder_pvp'] >= 2:
                        gamesite.exception_log.event(server_time, 'VISIT_LADDER_RIVAL: %d forcing switch' % (session.player.user_id))
                else:
                    delay += gamedata['matchmaking']['ladder_match_min_cooldown']

                if session.player.cooldown_active('ladder_match') and \
                   session.player.ladder_match and \
                   session.player.is_suitable_ladder_match(session.player.ladder_match):
                    if gamedata['server']['log_ladder_pvp'] >= 2:
                        gamesite.exception_log.event(server_time, 'VISIT_LADDER_RIVAL: %d re-using match %d' % (session.player.user_id, session.player.ladder_match))
                else:
                    if gamedata['server']['log_ladder_pvp'] >= 2:
                        if session.player.cooldown_active('ladder_match') and \
                           session.player.ladder_match:
                            gamesite.exception_log.event(server_time, 'VISIT_LADDER_RIVAL: %d cannot re-use last match %d' %
                                                         (session.player.user_id, session.player.ladder_match))

                    session.player.cooldown_reset('ladder_match')
                    session.player.ladder_match = None

                if not session.player.ladder_match:
                    if session.player.ladder_rival_override:
                        session.player.ladder_match = session.player.ladder_rival_override
                    else:
                        # find a player match
                        ai_chance = gamedata['matchmaking']['ladder_match_ai_chance']
                        force_ai = ((ai_chance > 0) and (random.random() < ai_chance))

                        if force_ai:
                            # only allow force_ai if there is an actual AI base you can attack
                            min_level = min([x.get('min_level',-1) for x in gamedata['ai_bases_server']['ladder_pvp_bases']])
                            max_level = max([x.get('max_level',999) for x in gamedata['ai_bases_server']['ladder_pvp_bases']])
                            if session.player.resources.player_level < min_level or session.player.resources.player_level > max_level:
                                force_ai = False # no available AI bases

                        if (not force_ai):
                            # seek player to fight
                            session.player.prune_cooldowns() # prune fatigue cooldowns
                            exclude_alliance_ids = []
                            aid = session.get_alliance_id(reason='find_suitable_ladder_match')
                            if aid >= 0 or gamedata['matchmaking'].get('ladder_match_non_alliance_bug',False):
                                exclude_alliance_ids.append(aid)
                            exclude_alliance_ids += session.player.get_sticky_alliances()
                            session.player.ladder_match = session.player.find_suitable_ladder_match(exclude_user_ids = exclude_user_ids, exclude_alliance_ids = exclude_alliance_ids)
                        if force_ai or ((not session.player.ladder_match) and gamedata['matchmaking']['ladder_match_ai_fallback']):
                            # assign AI opponent
                            candidates = []
                            for entry in gamedata['ai_bases_server']['ladder_pvp_bases']:
                                if session.player.resources.player_level < entry.get('min_level',-1) or \
                                   session.player.resources.player_level > entry.get('max_level',999) or \
                                   ('activation' in entry and not Predicates.read_predicate(entry['activation']).is_satisfied2(session, session.player, None)): continue # out of level range

                                id = entry['base_id']
                                if id in exclude_user_ids: continue

                                base = gamedata['ai_bases_server']['bases'].get(str(id),None)
                                if not base:
                                    gamesite.exception_log.event(server_time, 'invalid ladder_pvp AI base: %d' % id)
                                    continue

                                candidates.append(id)

                            if len(candidates) >= 1:
                                session.player.ladder_match = candidates[int(random.random()*len(candidates))]

                            if gamedata['server']['log_ladder_pvp'] >= 3:
                                gamesite.exception_log.event(server_time, 'VISIT_LADDER_RIVAL (AI): %d candidates %s (exclude %s) -> %s' % \
                                                             (session.player.user_id, repr(candidates), repr(exclude_user_ids), repr(session.player.ladder_match)))


                    event_props = {'attacker_pts': session.player.ladder_points(),
                                   'attacker_res': session.player.resources.get_fungible_amounts(),
                                   'battle_streak_ladder': session.player.cooldown_active('battle_streak_ladder')}

                    session.player.record_ladder_pvp_event('3300_ladder_search', copy.copy(event_props))

                    if session.player.ladder_match:
                        event_props.update({'defender_id': session.player.ladder_match})
                        session.player.record_ladder_pvp_event('3301_ladder_search_success', copy.copy(event_props))
                        session.player.cooldown_trigger('ladder_match', gamedata['matchmaking']['ladder_match_life'])

                        # append to history and truncate
                        # (option: for AIs, only append a generic -1, and thus allow max_exclude to be greater than the number of AIs available?)
                        # (session.player.ladder_match if str(session.player.ladder_match) not in gamedata['ai_bases_server']['bases'] else -1)
                        session.player.ladder_match_history.append(session.player.ladder_match)
                        session.player.prune_ladder_match_history(session)

                        if gamedata['server']['log_ladder_pvp'] >= 2:
                            gamesite.exception_log.event(server_time, 'VISIT_LADDER_RIVAL: %d found match %d' % (session.player.user_id, session.player.ladder_match))
                    else:
                        session.player.record_ladder_pvp_event('3302_ladder_search_fail', copy.copy(event_props))
                        retmsg.append(["ERROR", "LADDER_MATCH_FAILED"])
                        if gamedata['server']['log_ladder_pvp'] >= 1:
                            gamesite.exception_log.event(server_time, 'VISIT_LADDER_RIVAL: %d no match found!' % (session.player.user_id))
                        return

                if session.player.ladder_match:
                    dest_id = session.player.ladder_match
                    # create TEMPORARY ladder state - may be over-written in change_session()
                    ladder_state = session.player.create_ladder_state(dest_id, None)

                else:
                    dest_id = session.player.user_id
                    delay = 0

            else:
                # normal old player base visit
                dest_id = int(arg[1])

                # check AI destination eligibility
                if is_ai_user_id_range(dest_id):
                    if (str(dest_id) not in gamedata['ai_bases_server']['bases']) or \
                       gamedata['ai_bases_server']['bases'][str(dest_id)].get('kind','ai_base') != 'ai_base':
                        # dangling reference to removed AI base, or attempt to spy on an attack wave
                        retmsg.append(["ERROR", "CANNOT_SPY_INVALID_AI", dest_id])
                        return

                    base = gamedata['ai_bases_server']['bases'][str(dest_id)]
                    if ('activation' in base) and \
                       (not Predicates.read_predicate(base['activation']).is_satisfied2(session, session.player,None)) and \
                       (not session.player.is_cheater):
                        if 0:
                            gamesite.exception_log.event(server_time, 'preventing attempt by player %d to visit AI player %d - unsatisfied predicate' % (session.user.user_id, dest_id))
                        retmsg.append(["ERROR", "CANNOT_SPY_INVALID_AI", dest_id])
                        return

            if dest_base_id == home_base_id(session.player.user_id) or dest_id == session.player.user_id:
                spy_cooldown = gamedata['server'].get('spy_cooldown', 0)
                if spy_cooldown > 0:
                    session.player.cooldown_trigger('spy_cooldown', spy_cooldown)
                    retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])

            if session.player.cooldown_togo('spy_cooldown') > 0 and dest_id != session.player.user_id and dest_base_id != home_base_id(session.player.user_id) and not is_ai_user_id_range(dest_id):
                # if optional spy cooldown is active and player is not returning home, do not allow session change
                retmsg.append(["ERROR", "ON_COOLDOWN"])
                return

            return self.change_session(session, retmsg, dest_user_id = dest_id, dest_base_id = dest_base_id, force = True, new_ladder_state = ladder_state, delay = delay, client_props = client_props)

        elif arg[0] == "LOGOUT":
            return self.log_out_async(session, 'onunload')

        elif arg[0] == "CLIENT_SYNC":
            retmsg.append(["SERVER_SYNC", arg[1]])

        elif arg[0] == "TUTORIAL_STATE_UPDATE":
            newstate = arg[1]
            if session.player.tutorial_state != "COMPLETE":
                assert gamedata['tutorial'].has_key(newstate)
                # treat the "arrow to missions button" and "congratulations_message" the same as an actual completion
                if newstate == "open_missions_dialog" or newstate == "congratulations_message":
                    newstate = "COMPLETE"

                session.player.tutorial_state = newstate

                if newstate == "COMPLETE":
                    session.player.set_post_tutorial_state()
                    session.deferred_player_auras_update = True
                    session.deferred_stattab_update = True
                    session.deferred_player_state_update = True
                    metric_event_coded(session.user.user_id, '0399_tutorial_complete', {'sum': session.player.get_denormalized_summary_props('brief')})
                    session.setmax_player_metric('tutorial_complete', 1)
                    session.send_adnetwork_events(retmsg)

        elif arg[0] == "REPORT_DAMAGE_ATTRIBUTION":
            # see client's DamageAttribution.js
            owner_id = arg[1]
            props = arg[2] # {'damage_done': {...}, 'damage_taken': {...}}
            assert ('damage_done' in props) or ('damage_taken' in props)
            if owner_id == session.user.user_id:
                props['sum'] = session.player.get_denormalized_summary_props('brief')
            elif owner_id == session.viewing_user.user_id and (not session.viewing_player.is_ai()):
                props['sum'] = session.viewing_player.get_denormalized_summary_props('brief')
            elif owner_id == -1:
                pass # it's the AI - record, but without summary props
            else:
                return # unknown user
            metric_event_coded(owner_id, '3871_damage_attribution', props)

        elif arg[0] == "REPORT_METRIC":
            key = arg[1]
            val = arg[2]

            session.metric_event_coded(session.player, key, val)

            # save canvas_width/height from framerate events
            if key == '0960_framerate' and 'canvas_width' in val:
                session.user.canvas_width = int(val['canvas_width'])
                session.user.canvas_height = int(val['canvas_height'])
                if 'canvas_oversample' in val:
                    session.user.canvas_oversample = parse_canvas_oversample(val['canvas_oversample'])
                if 'devicePixelRatio' in val:
                    session.user.devicePixelratio = parse_canvas_oversample(val['devicePixelRatio'])

            elif key == '0961_sprobe_result':
                session.sprobe_in_progress = False
                val['report']['time'] = server_time
                if 'viewing_base_id' in val: val['report']['viewing_base_id'] = val['viewing_base_id']
                if 'graphics' in val['report']['tests']: # also save canvas width/height here
                    session.user.canvas_width = int(val['report']['tests']['graphics']['canvas_width'])
                    session.user.canvas_height = int(val['report']['tests']['graphics']['canvas_height'])
                    if 'canvas_oversample' in val['report']['tests']['graphics']:
                        session.user.canvas_oversample = parse_canvas_oversample(val['report']['tests']['graphics']['canvas_oversample'])
                    if 'devicePixelRatio' in val['report']['tests']['graphics']:
                        session.user.devicePixelRatio = parse_canvas_oversample(val['report']['tests']['graphics']['devicePixelRatio'])
                session.user.last_sprobe_result = val['report']

                log_chance = SpinConfig.config.get('gameserver_global',{}).get('log_client_perf',0)
                if log_chance > 0 and (log_chance >= 1 or random.random() < log_chance):
                    log_props = {'user_id': session.user.user_id,
                                 'player_level': session.player.resources.player_level,
                                 'country': session.user.country}
                    for test_name, test_data in val['report']['tests'].iteritems():
                        log_props[test_name] = test_data
                    gamesite.nosql_client.client_perf_record(log_props, reason='sprobe_result')

            # record privacy-prompt resuts
            elif key in ('0061_privacy_prompt_fail', '0062_privacy_prompt_success'):
                session.user.privacy_consent = {'0061_privacy_prompt_fail': 'no', '0062_privacy_prompt_success': 'yes'}[key]
                session.user.privacy_consent_time = server_time
                session.user.privacy_consent_reason = val.get('reason')
                retmsg.append(["PLAYER_PRIVACY_CONSENT_UPDATE", session.user.privacy_consent])

        elif arg[0] == "FB_GIFT_CARD_REDEEMED":
            # only for metrics recording
            #payment_id = arg[1]
            quantity = arg[2]
            session.increment_player_metric('fb_gift_cards_redeemed', 1)
            session.increment_player_metric('fb_gift_cards_redeemed_gamebucks', quantity)

        elif arg[0] == "FB_FEED_POST_COMPLETED":
            params = arg[1]
            session.increment_player_metric('fb_feed_posts_completed', 1)
            session.increment_player_metric('fb_feed_posts_%s_completed' % params['method'], 1)
            session.deferred_history_update = True

        elif arg[0] == "FB_INVITABLE_FRIENDS_QUERY":
            tag = arg[1]
            session.user.retrieve_facebook_invitable_friends(session, tag)
            return None # note: asynchronous with other session traffic!

        # simulate Facebook credits order
        elif arg[0] == "DEV_SIMULATE_ORDER":
            coded_order_info = arg[1]
            currency = arg[2]
            # don't allow this to happen on the live server!
            if spin_secure_mode:
                retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
            else:
                if currency == 'kgcredits':
                    order_info = SpinFacebook.order_data_decode(coded_order_info)
                else:
                    order_info = coded_order_info
                item = Store.make_credit_order('0', order_info, currency)
                print 'SIMULATED ORDER', item
                try:
                    network_id = {'fbcredits':session.user.facebook_id, 'kgcredits':session.user.kg_id}[currency]
                    Store.execute_credit_order('0', self, session, network_id, network_id, currency, item['price'],
                                               order_info if currency == 'kgcredits' else item['data'])
                except:
                    gamesite.exception_log.event(server_time, 'DEV_SIMULATE_ORDER Exception (player %d): %s' % (session.user.user_id, traceback.format_exc().strip())) # OK
                    retmsg.append(["ERROR", "ORDER_PROCESSING"])

        elif arg[0] == "FBPAYMENT_CREATE":
            # client has started the order flow - register the payment as inflight

            # warn if player is not using gamebucks
            if session.player.get_any_abtest_value('currency', gamedata['currency']) != 'gamebucks':
                gamesite.exception_log.event(server_time, 'FBPAYMENT_CREATE: player %d is not on gamebucks currency!' % session.user.user_id)

            # for testing (realtime updates) purposes only - deliberately break synchronous order ping
            if gamedata['server'].get('ignore_FBPAYMENT_CREATE', False): return

            tag = arg[1]
            request_id = arg[2]
            unit_id = arg[3]
            spellname = arg[4]
            spellarg = arg[5]
            client_price = arg[6]
            client_currency = arg[7]
            product_url = urllib.unquote(arg[8])
            init_quantity = arg[9]
            server_time_according_to_client = arg[10]
            gift_order = arg[11]

            payment_data = {
                'tag': tag,
                'request_id': request_id,
                'unit_id': unit_id,
                'spellname': spellname,
                'spellarg': spellarg,
                'client_price': client_price,
                'client_currency': client_currency,
                'product_url': product_url,
                'init_quantity': init_quantity,
                'time': server_time,
                'server_time_according_to_client': server_time_according_to_client,
                'state': 'new'
                }
            if gift_order: # do some type-checking
                assert type(gift_order) is dict
                assert 'gifts' in gift_order
                assert type(gift_order['gifts']) is list
                assert len(gift_order['gifts']) == 1 # for now
                for entry in gift_order['gifts']:
                    for FIELD in ('gamebucks','recipient_user_id','recipient_ui_name','recipient_player_level','recipient_facebook_id'): assert FIELD in entry
                payment_data['gift_order'] = gift_order
            session.player.fbpayments_inflight[request_id] = payment_data

        elif arg[0] == "FBPAYMENT_IGNORE":
            if gamedata['server'].get('ignore_FBPAYMENT_IGNORE', False): return
            request_id = arg[1]
            if request_id in session.player.fbpayments_inflight:
                del session.player.fbpayments_inflight[request_id]
        elif arg[0] == "FBPAYMENT_PING":
            request_id = arg[1]
            signed_request = arg[2] # optional - speeds processing by avoiding the round-trip
            d = session.user.ping_fbpayment(session, retmsg, request_id, signed_request = signed_request)
            # this might or might not go async
            return session.start_async_request(d) if d else None

        elif arg[0] == "FBPAYMENT_SIMULATE_PURCHASE":
            request_id = arg[1]
            if spin_secure_mode:
                retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
            else:
                if request_id in session.player.fbpayments_inflight:
                    # set a flag so the next FBPAYMENT_PING will pick it up
                    session.player.fbpayments_inflight[request_id]['simulate_purchase'] = 1
        elif arg[0] == "FBPAYMENT_SIMULATE_REFUND":
            if spin_secure_mode:
                retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                return
            for ent in reversed(session.player.history.get('money_purchase_history',[])):
                if ('payment_id' in ent) and (not ent.get('refunded',0)):
                    if 'product' in ent:
                        product = ent['product']
                    else:
                        product = OGPAPI_instance.get_object_endpoint({'type':OGPAPI.object_type('sku'), 'spellname': ent['description']})
                    session.user.ping_fbpayment_check_refund(session, retmsg, ent['payment_id'],
                                                             {'data':[{
                        'id': ent['payment_id'],
                        'actions': [{'type':'charge', 'status':'completed',
                                     'time_updated': SpinFacebook.unparse_fb_time(ent['time']),
                                     'amount': ent['currency_amount'], 'currency': ent['currency']},
                                    {'type':'decline', 'status':'completed',
                                     'time_updated': SpinFacebook.unparse_fb_time(ent['time']),
                                     'amount': ent['currency_amount'], 'currency': ent['currency']}],
                        'payout_foreign_exchange_rate': ent.get('payout_foreign_exchange_rate',1),
                        'items': [{'product':product, 'quantity': ent.get('quantity',1)}]
                        }]})
                    retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])
                    return

        elif arg[0] == "XSOLLA_GET_TOKEN":
            tag = arg[1]
            spellname = arg[2]
            spellarg = arg[3]
            d = gamesite.xsapi.get_token(session, retmsg, spellname, spellarg)
            if d:
                # let's try doing this asynchronously to the other session traffic...
                d.addCallback(lambda result, _session = session, _tag = tag: \
                              _session.send([["XSOLLA_GET_TOKEN_RESULT", _tag, result]], flush_now = True) if (not _session.logout_in_progress) else None)
            return # do not go async

        # pay with gamebucks
        elif arg[0] == "GAMEBUCKS_ORDER":
            tag = arg[1]
            client_price = int(arg[2])
            unit_id = arg[3]
            spellname = arg[4]
            spellarg = arg[5]
            server_time_according_to_client = arg[6]

            # time.sleep(5) # to test lag

            if (client_price > 0) and (session.player.get_any_abtest_value('currency', gamedata['currency']) != 'gamebucks'):
                # note: allow 0-priced orders even when currency does not match
                retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                return

            # note: client_price is UNTRUSTED input, but if it's too low, then execute_order() will throw an exception

            assert client_price >= 0
            if client_price > 0 and (session.player.resources.gamebucks < client_price):
                retmsg.append(["ERROR", "INSUFFICIENT_GAMEBUCKS", client_price - session.player.resources.gamebucks, client_price, unit_id, spellname, spellarg])
                retmsg.append(["GAMEBUCKS_ORDER_ACK", tag, False])
                return

            success = False

            try:
                descr = Store.execute_gamebucks_order(self, session, retmsg, client_price,
                                                      unit_id, spellname, spellarg,
                                                      server_time_according_to_client)
                # at this point the order has changed player state, so go ahead and subtract gamebucks
                session.player.resources.gain_gamebucks(-client_price, reason='spent', subreason=descr)
                success = True
                retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

            except:
                my_filter = gamedata['server'].get('bad_internet_exception_log_filter', None)
                if (not my_filter) or (Predicates.read_predicate(my_filter).is_satisfied2(session, session.player, None)):
                    gamesite.exception_log.event(server_time, '%s Exception (player %d): %s' % (arg[0],session.user.user_id,traceback.format_exc().strip())) # OK
                retmsg.append(["ERROR", "ORDER_PROCESSING"])
                # update object state, in case the client is out of sync
                if session.has_object(unit_id):
                    object = session.get_object(unit_id)
                    retmsg.append(["OBJECT_STATE_UPDATE", object.serialize_state(), session.player.resources.calc_snapshot().serialize()])
                elif spellname == 'UNIT_REPAIR_SPEEDUP_FOR_MONEY':
                    self.do_unit_repair_tick(session, retmsg, must_reply = True)
                    retmsg.append(["SQUADS_UPDATE", session.player.squads])

                elif spellname == 'REPAIR_ALL_FOR_MONEY':
                    # we currently have a rare bug where player.my_army gets out of sync with the server, causing repair pricing to mis-match
                    # until this is found and fixed, force a full query and update of the army on failure
                    session.player.ping_squads_and_send_update(session, retmsg, originator=session.player.user_id, reason='GAMEBUCKS_ORDER failure')


            finally:
                retmsg.append(["GAMEBUCKS_ORDER_ACK", tag, success])

        elif arg[0] == "ITEM_ORDER":
            tag = arg[1]
            item_name = arg[2]
            client_price = int(arg[3])
            unit_id = arg[4]
            spellname = arg[5]
            spellarg = arg[6]
            server_time_according_to_client = arg[7]
            success = False

            # note: client_price is UNTRUSTED input, but if it's too low, then execute_order() will throw an exception
            assert client_price >= 0

            # check for insufficient items
            has_qty = session.player.inventory_item_quantity(item_name)
            if has_qty < client_price:
                retmsg.append(["ERROR", "INSUFFICIENT_ITEMS", client_price - has_qty, client_price, unit_id, spellname, spellarg])
                retmsg.append(["ITEM_ORDER_ACK", tag, success])
                session.player.send_inventory_update(retmsg)
                return

            try:
                Store.execute_order(self, session, retmsg, 'item:'+str(item_name), client_price,
                                    unit_id, spellname, spellarg,
                                    server_time_according_to_client)
                # at this point the order has changed player state, so go ahead and take the items
                session.player.inventory_remove_by_type(item_name, client_price, '5130_item_activated',
                                                        use_priority = True,
                                                        reason='purchase')
                success = True

            except:
                gamesite.exception_log.event(server_time, '%s Exception (player %d): %s' % (arg[0],session.user.user_id,traceback.format_exc().strip())) # OK
                retmsg.append(["ERROR", "ORDER_PROCESSING"])

            finally:
                retmsg.append(["ITEM_ORDER_ACK", tag, success])
                session.player.send_inventory_update(retmsg)

        elif arg[0] == "FUNGIBLE_ORDER":
            tag = arg[1]
            resname = arg[2]
            client_price = int(arg[3])
            unit_id = arg[4]
            spellname = arg[5]
            spellarg = arg[6]
            server_time_according_to_client = arg[7]
            success = False

            # note: client_price is UNTRUSTED input, but if it's too low, then execute_order() will throw an exception
            assert client_price >= 0

            try:
                # check for insufficient resources
                if getattr(session.player.resources, resname) < client_price:
                    retmsg.append(["ERROR", "INSUFFICIENT_"+resname.upper(), client_price])
                else:
                    price_description, detail_props = Store.execute_order(self, session, retmsg, resname, client_price,
                                                                          unit_id, spellname, spellarg,
                                                                          server_time_according_to_client)
                    # at this point the order has changed player state, so go ahead and take the resources
                    success = True
                    negative_cost = {resname: -client_price}
                    session.player.resources.gain_res(negative_cost, reason='fungible_order')
                    admin_stats.econ_flow_player(session.player, 'consumption', 'store_purchase', negative_cost) # may want more detail by specifying an econ_category on the item or store sku

                    if spellname != 'BUY_ITEM': # awkward overlap with 5120_buy_item logging
                        descr = Store.get_description(session, unit_id, spellname, spellarg, price_description)
                        props = {'user_id': session.user.user_id,
                                 'summary': session.player.get_denormalized_summary_props('brief'),
                                 'event_name': '1401_fungible_spent',
                                 'code': 1401,
                                 'price': client_price,
                                 'price_currency': resname,
                                 'Billing Description': descr}
                        props.update(detail_props)
                        gamesite.gamebucks_log.event(server_time, props)

            except:
                gamesite.exception_log.event(server_time, '%s Exception (player %d): %s' % (arg[0],session.user.user_id,traceback.format_exc().strip())) # OK
                retmsg.append(["ERROR", "ORDER_PROCESSING"])

            retmsg.append(["FUNGIBLE_ORDER_ACK", tag, success])
            session.deferred_player_state_update = True

        elif arg[0] == "SCORE_ORDER":
            tag = arg[1]
            stat_name = arg[2]
            currency = 'score:'+stat_name
            client_price = int(arg[3])
            unit_id = arg[4]
            spellname = arg[5]
            spellarg = arg[6]
            server_time_according_to_client = arg[7]
            success = False

            # note: client_price is UNTRUSTED input, but if it's too low, then execute_order() will throw an exception
            assert client_price >= 0

            try:
                # check for insufficient resources
                if session.player.get_master_score(stat_name) < client_price:
                    retmsg.append(["ERROR", "INSUFFICIENT_"+stat_name.upper(), client_price])
                else:
                    price_description, detail_props = Store.execute_order(self, session, retmsg, currency, client_price,
                                                                          unit_id, spellname, spellarg,
                                                                          server_time_according_to_client)
                    # at this point the order has changed player state, so go ahead and take the resources
                    success = True
                    negative_cost = {stat_name: -client_price}
                    session.player.modify_scores(negative_cost, method = '+=', reason = 'score_order')
                    session.deferred_player_trophies_update = True

                    if spellname != 'BUY_ITEM': # awkward overlap with 5120_buy_item logging
                        descr = Store.get_description(session, unit_id, spellname, spellarg, price_description)
                        props = {'user_id': session.user.user_id,
                                 'summary': session.player.get_denormalized_summary_props('brief'),
                                 'event_name': '1402_score_spent',
                                 'code': 1401,
                                 'price': client_price,
                                 'price_currency': currency,
                                 'Billing Description': descr}
                        props.update(detail_props)
                        gamesite.gamebucks_log.event(server_time, props)

            except:
                gamesite.exception_log.event(server_time, '%s Exception (player %d): %s' % (arg[0],session.user.user_id,traceback.format_exc().strip())) # OK
                retmsg.append(["ERROR", "ORDER_PROCESSING"])

            retmsg.append(["SCORE_ORDER_ACK", tag, success])
            session.deferred_player_state_update = True

        elif arg[0] == "DSTROY_OBJECT":
            id = arg[1]
            death_location = arg[2]
            killer_info = arg[3]
            if len(arg) >= 5:
                method = arg[4]
            else:
                method = 'hostile'

            self.destroy_object(session, retmsg, id, death_location, killer_info, method = method)

        elif arg[0] == "REMOVE_OBJECT":
            # only for debugging/level-editing
            if (not session.player.is_cheater):
                retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                return

            id = arg[1]

            if session.has_object(id):
                obj = session.get_object(id)
                session.rem_object(id)
                if obj.is_mobile():
                    obj.owner.unit_repair_cancel(obj)
                if obj in session.viewing_base.iter_objects():
                    session.viewing_base.drop_object(obj)
                if obj.is_building():
                    session.power_changed(session.viewing_base, obj, retmsg)
                retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

        elif arg[0] == "RECYCLE_UNIT":
            self.recycle_unit(session, retmsg, arg[1])

        elif arg[0] == "OBJECT_COMBAT_UPDATES":
            self.object_combat_updates(session, retmsg, arg[1])

        elif arg[0] == "ON_APPROACH":
            self.fire_on_approach(session, retmsg, arg[1], arg[2], arg[3], arg[4])

        elif arg[0] == "AUTO_RESOLVE":
            self.auto_resolve(session, retmsg)

        elif arg[0] == "CREATE_INERT" or arg[0] == "CREATE_INERT2":
            inert_type = arg[1]
            coords = arg[2]
            metadata = arg[3]
            if arg[0] == "CREATE_INERT2":
                # new: use wrapped JSON for Unicode safety
                if metadata:
                    metadata = SpinJSON.loads(SpinHTTP.unwrap_string(metadata))
            self.do_create_inert(session, retmsg, inert_type, coords, metadata)

        elif arg[0] == "QUARRY_COLLECT":
            if (not session.player.can_use_quarries()) or (not gamesite.nosql_client):
                retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                return

            assert session.player.home_region
            togo = session.player.cooldown_togo('quarry_collect')
            if togo > 0:
                retmsg.append(["HARVESTED_RESOURCES", {'cooldown':server_time+togo+1}, -1, None, 'quarry', None])
                return

            session.player.cooldown_trigger('quarry_collect', gamedata['territory']['quarry_collect_cooldown'])
            retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])

            total_harvested = 0
            feature_list = gamesite.nosql_client.get_map_features_by_landlord_and_type(session.player.home_region, session.player.user_id, 'quarry', reason='QUARRY_COLLECT')

            for feature in feature_list:
                if feature['base_id'] == session.viewing_base.base_id:
                    assert session.viewing_base is not session.player.my_home
                    assert session.viewing_base.base_landlord_id == session.player.user_id

                lock_id = SpinDB.base_lock_id(session.player.home_region, feature['base_id'])
                if session.viewing_base_lock == lock_id:
                    lock_id = None # already locked by the session

                if lock_id:
                    # not going to hold it for an extended period of time, so no need to broadcast
                    if gamesite.nosql_client.map_feature_lock_acquire(session.player.home_region, feature['base_id'], session.player.user_id, do_hook=False, reason='QUARRY_COLLECT') != Player.LockState.being_attacked:
                        retmsg.append(["ERROR", "CANNOT_LOCK_QUARRY", feature['base_id']])
                        continue
                try:
                    if session.viewing_base.base_id == feature['base_id']:
                        # *might* open a race here, I'm not sure
                        obj_list = session.viewing_base.iter_objects()
                    else:
                        obj_list = [reconstitute_object(session.player, session.player, state, context='QUARRY_COLLECT') \
                                    for state in gamesite.nosql_client.get_fixed_objects_by_base(session.player.home_region, feature['base_id'], reason='QUARRY_COLLECT') \
                                    if ((state['spec'] in gamedata['buildings']) and ('production_capacity' in gamedata['buildings'][state['spec']]))]
                    total_harvested += self.do_harvest_all(session, retmsg, feature['base_type'], session.player.home_region, feature['base_id'], obj_list, 1, {'base_id': feature['base_id'],
                                                                                                                                                                'base_type':feature['base_type'],
                                                                                                                                                                'base_template':feature.get('base_template',None),
                                                                                                                                                                'base_ui_name':feature['base_ui_name']})
    #                for object in base.iter_objects():
    #                    if object.is_inert() and ("COLLECT_DEPOSIT" in object.spec.spells):
    #                        self.do_collect_one_deposit(session, retmsg, object)

                finally:
                    if lock_id: gamesite.nosql_client.map_feature_lock_release(session.player.home_region, feature['base_id'], session.player.user_id, do_hook=False, reason='QUARRY_COLLECT')

            if total_harvested > 0:
                session.player.send_history_update(retmsg)
                retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

        elif arg[0] == "QUARRY_ABANDON":
            base_id = arg[1]
            if (session.viewing_base.base_type != 'quarry') or \
               (session.viewing_base.base_landlord_id != session.player.user_id) or \
               (session.viewing_base.base_id != base_id) or \
               (session.using_squad_deployment() and session.defending_squads and len(session.defending_squads) == 1 and session.defending_squads.values[0]['squad_id'] == SQUAD_IDS.BASE_DEFENDERS): # still have a squad stationed here
                gamesite.exception_log.event(server_time, 'player %d failed to abandon quarry %s - base_type %s landlord %d viewing_base.base_id %s defending_squads %s' % \
                                             (session.player.user_id, base_id, session.viewing_base.base_type, session.viewing_base.base_landlord_id, repr(session.viewing_base.base_id), repr(session.defending_squads)))
                retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
                return
            base = session.viewing_base

            if session.viewing_base_lock != base.lock_id():
                if gamesite.nosql_client.map_feature_lock_acquire(base.base_region, base.base_id, session.player.user_id,
                                                                  generation=base.base_generation, do_hook=False, reason='QUARRY_ABANDON') != Player.LockState.being_attacked: # generation=-1?
                    retmsg.append(["ERROR", "CANNOT_LOCK_QUARRY", base.base_ui_name])
                    return # no async

            success = False
            try:
                base.quarry_abandon()
                base.send_map_feature_update(reason='quarry_abandon')
                success = True
                metric_event_coded(session.player.user_id, '4711_quarry_abandoned', {'region': base.base_region,
                                                                                     'base_id': base.base_id,
                                                                                     'new_landlord_id': base.base_landlord_id })
            finally:
                if session.viewing_base_lock != base.lock_id():
                    gamesite.nosql_client.map_feature_lock_release(base.base_region, base.base_id, session.player.user_id, generation=base.base_generation, reason='QUARRY_ABANDON')

            if not success:
                return # no async

            # go back home
            return self.change_session(session, retmsg, dest_user_id = session.player.user_id, force = True)

        elif arg[0] == "QUARRY_QUERY":
            tag = arg[1]
            updated_since = int(arg[2])
            region = session.player.home_region

            if (not region) or (not gamedata['regions'][region].get('enable_map',True)) or (not gamesite.nosql_client):
                return

            if session.last_quarry_query > 0 and server_time < (session.last_quarry_query + gamedata['rival_query_cooldown']):
                # ignore spammy request
                return
            session.last_quarry_query = server_time

            profile_start_time = time.time()
            profile_tags = []

            db_time = None
            codec = None
            z_result = None
            need_updates = False

            if updated_since < 0:
                # non-incremental query - try to use a cached result
                if region in self.quarry_query_cache:
                    if (server_time - self.quarry_query_cache[region][1]) < gamedata['server']['quarry_query_cache']:
                        db_time, query_time, codec, z_result = self.quarry_query_cache[region]
                        profile_tags.append('cached')
                        #gamesite.exception_log.event(server_time, 'using cached result '+str(db_time))
                        admin_stats.quarry_cache_hits += 1

                        # if responding to a full query with cached data, we need to check for updates
                        need_updates = True
                    else:
                        del self.quarry_query_cache[region] # too old
                        admin_stats.quarry_cache_misses += 1
                else:
                    admin_stats.quarry_cache_misses += 1

            if z_result is None:
                # refill cache
                db_time, codec, z_result = self.do_quarry_query_uncached(session, retmsg, region, updated_since, reason = 'fill_cache' if updated_since < 0 else 'incr_deltas')
                # stash last non-incremental query in the cache
                if updated_since < 0 and gamedata['server']['quarry_query_cache'] > 0:
                    profile_tags.append('uncached-store')
                    self.quarry_query_cache[region] = (db_time, server_time, codec, z_result)
                else:
                    profile_tags.append('uncached-nostore')

            retmsg.append(["QUARRY_QUERY_RESULT", tag, region, db_time, codec, z_result, updated_since])

            if need_updates:
                # send the deltas since the cached data was retrieved
                new_db_time, new_codec, new_z_result = self.do_quarry_query_uncached(session, retmsg, region, db_time, reason = 'full_deltas')
                profile_tags.append('deltas')
                retmsg.append(["QUARRY_QUERY_RESULT", tag, region, new_db_time, new_codec, new_z_result, db_time])

            admin_stats.record_latency('QUARRY_QUERY(%s)' % ','.join(profile_tags), time.time() - profile_start_time)

        elif arg[0] == "REGION_POP_QUERY":
            tag = arg[1]
            if not gamesite.nosql_client: return
            region_list = [data for data in gamedata['regions'].itervalues() if \
                           (data.get('open_join',True)) and \
                           ((not data.get('developer_only',0)) or session.player.is_developer()) and \
                           (('show_if' not in data) or (Predicates.read_predicate(data['show_if']).is_satisfied2(session, session.player, None)))]
            populations = dict([(data['id'], gamesite.nosql_client.get_map_feature_population(data['id'],'home',reason='REGION_POP_QUERY')) for data in region_list])

            # sort from high to low pop
            region_list = sorted(region_list, key = lambda data: -populations[data['id']])

            def classify(data, pop):
                soft_cap = data.get('pop_soft_cap',-1)
                hard_cap = data.get('pop_hard_cap',-1)
                if (hard_cap >= 0) and (pop >= hard_cap): return 'full'
                elif (soft_cap >= 0) and (pop >= soft_cap): return 'almost_full'
                return 'open'
            client_populations = dict([(data['id'], {'state':classify(data, populations[data['id']]),
                                                     'rank':region_list.index(data)
                                                     }) for data in region_list])
            retmsg.append(["REGION_POP_QUERY_RESULT", tag, client_populations])

            pred = gamedata['server'].get('log_region_pop_query_if',None)
            if pred and Predicates.read_predicate(pred).is_satisfied2(session, session.player, None):
                gamesite.exception_log.event(server_time, 'REGION_POP_QUERY (player %d) returns: %s' % (session.player.user_id, SpinJSON.dumps(client_populations)))

        elif arg[0] == "CHANGE_REGION":
            self.execute_spell(session, retmsg, arg[0], [arg[1],arg[2]])

        elif arg[0] == "SET_ALIAS" or arg[0] == "CHANGE_TITLE":
            spell = gamedata['spells'][arg[0]]
            for PRED in ('show_if', 'requires'):
                if spell.get(PRED) and (not Predicates.read_predicate(spell[PRED]).is_satisfied2(session, session.player, None)):
                    retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", spell[PRED]])
                    return
            self.execute_spell(session, retmsg, arg[0], arg[1])

        elif arg[0] == "TRAVEL_BEGIN":
            if session.has_attacked:
                retmsg.append(["ERROR", "CANNOT_TRAVEL_DURING_BATTLE"])
                return

            if session.player.region_map_building_is_busy():
                retmsg.append(["ERROR", "CANNOT_TRAVEL_TRANSMITTER_BUSY"])
                return

            destination = tuple(arg[1]) if arg[1] else None
            travel_time = int(arg[2]) # note: checked on base load
            session.player.travel_begin(destination, travel_time)
            retmsg.append(["PLAYER_TRAVEL_UPDATE", session.player.travel_state])

        elif arg[0] == "PING_MAP" or arg[0] == "PING":
            # this is just to collect deferred messages and update the ack
            pass
        elif arg[0] == "RECONNECT":
            # retransmit messages the client hadn't acked yet
            request = session.longpoll_request # grab the current connection
            assert request
            assert isinstance(request, WSFakeRequest)

            for serial, msg in session.retrans_buffer:
                request.write(SpinJSON.dumps({'serial': serial,
                                              'ack': session.incoming_serial-1,
                                              'clock': server_time,
                                              'msg': msg}))
            session.incoming_acked = session.incoming_serial-1
            retmsg.append(["RECONNECT_COMPLETE"])

        elif arg[0] == "PING_CHAT":
            # client tells us the timestamps of last seen messages
            assert type(arg[1]) is dict
            session.player.chat_seen = arg[1]

        elif arg[0] == "UPDATE_BATTLE_HISTORY_SEEN":
            session.player.battle_history_seen = int(arg[1])

        elif arg[0] == "PING_PLAYER":
            retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

        elif arg[0] == "PING_CREDITS":
            session.user.retrieve_facebook_credit_info_start()

        elif arg[0] == "CLAIM_BATTLE_STAR":
            name = arg[1]

            # only valid for attacks on hostile home bases
            if session.home_base or (session.viewing_base is not session.viewing_player.my_home):
                return
            if not session.claim_battle_star(name):
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED"])
                return
            retmsg.append(["SESSION_LOOT_UPDATE", copy.deepcopy(session.loot)])

        elif arg[0] == "PING_BASE_DAMAGE":
            # only valid for attacks on hostile home bases
            if session.home_base or (session.viewing_base is not session.viewing_player.my_home) or (arg[1] != session.viewing_base.base_id):
                retmsg.append(["PING_BASE_DAMAGE_RESULT", session.viewing_base.base_id, -1, None])
                return

            client_base_damage = arg[2]
            client_damaged_objects = arg[3]
            client_power_state = arg[4]
            base_damage, base_repair_time, server_damaged_objects = session.viewing_base.do_calc_base_damage(detail = client_damaged_objects is not None)

            # see how big the disagreement is, if any
            delta = abs(base_damage-client_base_damage)
            if delta >= gamedata['server']['log_base_damage_pings']:
                diffs = []
                if client_damaged_objects:
                    # reconcile list of damaged objects
                    for k, v in client_damaged_objects.iteritems():
                        if k not in server_damaged_objects or server_damaged_objects[k]['hp'] != v['hp'] or server_damaged_objects[k]['max_hp'] != v['max_hp']:
                            mydiff = '%s [client %s] [server %s]' % (k, repr(v), repr(server_damaged_objects.get(k,None)))
                            obj = session.viewing_player.get_object_by_obj_id(k, fail_missing = False)
                            if obj and obj.is_building() and obj.is_producer():
                                mydiff += ' server harv state repair_finish_time %d produce_rate %d contents %d' % (obj.repair_finish_time, obj.produce_rate, obj.contents)
                            diffs.append(mydiff)
                    for k, v in server_damaged_objects.iteritems():
                        if k not in client_damaged_objects:
                            diffs.append('%s [client %s] [server %s]' % (k, 'MISSING', repr(v)))
                gamesite.exception_log.event(server_time, 'PING_BASE_DAMAGE player %d at %s client %f server %f delta %f client_power %s server_power %s diffs %s' % \
                                             (session.player.user_id, session.viewing_base.base_id, client_base_damage, base_damage, delta, repr(client_power_state), repr(session.viewing_base.get_power_state()), ', '.join(diffs)))

            props = {}
            if session.has_attacked and session.is_ladder_battle():
                props['is_ladder_win'] = session.viewing_base.ladder_victory_satisfied(session, base_damage)
                if props['is_ladder_win']:
                    # note: this doesn't include the effect of any scale_by auras
                    props['ladder_win_points'] = session.ladder_state['points']['victory'][str(session.player.user_id)]
                    bonus = 0
                    if 'ladder_bonus_damage' in gamedata['matchmaking']:
                        for entry in gamedata['matchmaking']['ladder_bonus_damage']:
                            if base_damage >= entry[0]:
                                bonus = entry[1]
                                break
                    if bonus > 0:
                        props['ladder_win_points'] += max(1, int(props['ladder_win_points']*bonus))

                ladder_protection = -1
                if session.protection_eligible is True:
                    ladder_protection = session.viewing_base.calc_ladder_protection(base_damage)
                props['ladder_protection'] = ladder_protection
            retmsg.append(["PING_BASE_DAMAGE_RESULT", session.viewing_base.base_id, base_damage, props])
            retmsg.append(["SESSION_LOOT_UPDATE", copy.deepcopy(session.loot)])

        elif arg[0] == "PING_OBJECT":
            id = arg[1]
            self.ping_object(session, retmsg, id, session.viewing_base)

        elif arg[0] == "PING_TECH":
            retmsg.append(["TECH_UPDATE", session.player.tech])

        elif arg[0] == "POLL_BASE_LOCK_STATE":
            base_type = str(arg[1])
            base_id = str(arg[2])
            if session.player.cooldown_active('lock_state_poll'): return
            session.player.cooldown_trigger('lock_state_poll', gamedata['lock_state_poll_cooldown'])
            retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])
            if session.home_base: return

            if base_type == 'home' or base_id[0] == 'h': # home base check
                lock_state, owner_id = gamesite.lock_client.player_lock_get_state_batch([int(base_id[1:])], reason = 'poll')[0]
            else:
                assert session.player.home_region
                lock_state, owner_id = gamesite.nosql_client.map_feature_lock_get_state_batch(session.player.home_region, [base_id], reason='POLL_BASE_LOCK_STATE')[0]

            retmsg.append(["BASE_LOCK_STATE_UPDATE", base_id, lock_state, owner_id])

        elif arg[0] == "COMPLETE_QUEST":
            self.do_complete_quest(session, retmsg, arg[1])
        elif arg[0] == "CLAIM_ACHIEVEMENT":
            self.do_claim_achievement(session, retmsg, arg[1])

        elif arg[0] == "START_DAILY_ATTACK":
            if not session.home_base:
                return
            session.start_ai_attack(retmsg, 'daily')

        elif arg[0] == "START_AI_ATTACK":
            attack_type = arg[1]
            session.start_ai_attack(retmsg, attack_type, override_protection = True)

        elif arg[0] == "BEGIN_AI_ATTACK":
            session.deploy_ai_attack(retmsg)
        elif arg[0] == "NEXT_AI_ATTACK_WAVE":
            session.deploy_ai_attack_wave(retmsg)

        elif arg[0] == "SEND_GIFTS2":
            self.do_send_gifts(session, retmsg, arg)
        elif arg[0] == "SEND_GIFTS_BH":
            return self.do_send_gifts_bh(session, arg[1])

        elif arg[0] == "LEVEL_ME_UP":
            self.do_level_up(session, retmsg, arg)

        elif arg[0] == "UPDATE_PREFERENCES":
            assert type(arg[1]) == dict
            session.player.player_preferences = arg[1]
        elif arg[0] == "RESET_NOTIFICATION":
            ref = arg[1]
            if ref == 'ALL':
                for key in session.player.history.keys():
                    if (key.startswith('notification:') or key.startswith('notification2:')) \
                       and (key.endswith(':unacked') or key.endswith(':last_time')):
                        del session.player.history[key]
            else:
                for key in ('notification:'+ref+':unacked',
                            'notification:'+ref+':last_time',
                            'notification2:'+ref+':unacked',
                            'notification2:'+ref+':last_time',
                            ):
                    if key in session.player.history:
                        del session.player.history[key]

        elif arg[0] == "QUERY_SCOUT_REPORTS":
            self.query_scout_reports(session, retmsg, arg)
        elif arg[0] == "QUERY_RECENT_ATTACKERS":
            self.query_recent_attackers(session, retmsg, arg)
        elif arg[0] == "QUERY_PLAYER_ALLIANCE_MEMBERSHIP_HISTORY":
            return self.query_player_alliance_membership_history(session, arg)
        elif arg[0] == "QUERY_BATTLE_HISTORY":
            return self.query_battle_history(session, retmsg, arg)
        elif arg[0] == "GET_BATTLE_LOG3":
            return self.get_battle_log3(session, retmsg, arg)
        elif arg[0] == "UPLOAD_BATTLE_REPLAY":
            token, codec, first_line, n_lines, is_final, raw_length, zipped = arg[1:8]
            if token in session.attack_replay_receivers:
                if session.attack_replay_receivers[token].accumulate(codec, first_line, n_lines, is_final, raw_length, zipped):
                    # it's done
                    del session.attack_replay_receivers[token]
        elif arg[0] == "GET_BATTLE_REPLAY":
            return self.get_battle_replay(session, retmsg, arg)

        elif arg[0] == "UPLOAD_SCREEN_DATA":
            # receive and store a screenshot from the game client
            log_time, codec, base64buf = arg[1:4]

            # frequency limit
            if session.player.cooldown_active('UPLOAD_SCREEN_DATA'):
                return
            session.player.cooldown_trigger('UPLOAD_SCREEN_DATA', 10)

            # check parameters, and just ignore this if something is invalid
            try:
                # make sure time value is reasonable
                log_time = int(log_time)
                assert log_time >= server_time - 600 and log_time < server_time + 600

                buf = base64.b64decode(base64buf)

                ScreenRecordingReceiver.upload_frame(log_time, session.user.user_id, buf, codec)

            except:
                gamesite.exception_log.event(server_time, ('UPLOAD_SCREEN_DATA error from %r: ' % (session.user.user_id,))+traceback.format_exc().strip())

        elif arg[0] == "QUERY_MAP_LOG":
            if (not session.player.is_developer()):
                retmsg.append(["ERROR", "SERVER_PROTOCOL"])
            return self.query_map_log(session, retmsg, arg)
        elif arg[0] == "QUERY_ACHIEVEMENTS":
            return self.query_achievements(session, retmsg, arg)

        elif arg[0] == "QUERY_RIVALS":
            pass # obsolete legacy message

        elif arg[0] == "QUERY_PLAYER_CACHE":
            user_ids = map(int, arg[1])
            tag = arg[2]
            result = self.do_query_player_cache(session, user_ids, reason = 'QUERY_PLAYER_CACHE')
            retmsg.append(["QUERY_PLAYER_CACHE_RESULT", result, tag])

        elif arg[0] == "SEARCH_PLAYER_CACHE":
            search_terms = SpinHTTP.unwrap_string(arg[1]).strip()[0:64]
            tag = arg[2]

            # first get a list of user_ids, then query the pcache info for that list

            if not search_terms: # blank string
                user_ids = []
            else:
                start_time = time.time()
                user_ids = gamesite.nosql_client.player_cache_search(search_terms.lower(),
                                                                     limit = gamedata['search_player_list_limit'],
                                                                     match_mode = gamedata['search_player_match_mode'],
                                                                     name_field = 'ui_name_searchable',
                                                                     case_sensitive = True,
                                                                     reason = 'SEARCH_PLAYER_CACHE')
                end_time = time.time()
                if end_time - start_time >= gamedata['server'].get('player_cache_search_slow_threshold', 5.0):
                    gamesite.exception_log.event(server_time, 'slow player_cache_search(): terms = %r, limit = %r, match_mode = %r, name_field = \'ui_name_searchable\', case_sensitive = True, time = %.1f ms' % \
                                                 (search_terms.lower(), gamedata['search_player_list_limit'], gamedata['search_player_match_mode'], (end_time-start_time)*1000.0))

            pcache_data = self.do_query_player_cache(session, user_ids, reason = 'SEARCH_PLAYER_CACHE') if user_ids else []
            retmsg.append(["SEARCH_PLAYER_CACHE_RESULT", user_ids, pcache_data, tag])

        elif arg[0] == "QUERY_ALLIANCE_LIST":
            search_terms = SpinHTTP.unwrap_string(arg[1]).strip()[0:64] if arg[1] else None
            tag = arg[2]
            if gamesite.sql_client:
                if search_terms:
                    limit = gamedata['alliances']['search_list_limit']
                    result = gamesite.sql_client.search_alliance(search_terms, limit = limit, reason = 'QUERY_ALLIANCE_LIST')
                else:
                    result = []
                    exclude_alliance_id = -1

                    # check if we want to push a specific alliance to the front of the list
                    recommend_alliance_cond = gamedata['server'].get('recommend_alliance', None)
                    if recommend_alliance_cond:
                        recommend_alliance_id = Predicates.eval_cond_or_literal(recommend_alliance_cond, session, session.player)
                        if recommend_alliance_id:
                            # query for this specific alliance
                            recommend_alliance_info = gamesite.sql_client.get_alliance_info(recommend_alliance_id, reason = 'QUERY_ALLIANCE_LIST')
                            # make sure it exists
                            if recommend_alliance_info:
                                # make sure it's not full
                                if recommend_alliance_info['num_members'] < gamedata['alliances']['max_members']:
                                    # flag to tell the client that it should be sorted first
                                    recommend_alliance_info['ui_priority'] = 999
                                    result.append(recommend_alliance_info)
                                    exclude_alliance_id = recommend_alliance_id
                                else:
                                    gamesite.exception_log.event(server_time, 'recommend_alliance %d is full' % (recommend_alliance_id,))

                    limit = gamedata['alliances']['join_list_limit']
                    require_activity_within_time = gamedata['alliances'].get('join_list_require_activity_within_time', -1)
                    if require_activity_within_time > 0:
                        has_activity_since = server_time - require_activity_within_time
                    else:
                        has_activity_since = -1
                    result += gamesite.sql_client.get_alliance_list(limit, open_join_only = (not gamedata['alliances']['join_list_show_private']), members_fewer_than = gamedata['alliances']['max_members'], match_continent = session.player.home_continent() if gamedata['alliances']['join_list_match_continent'] else None, has_activity_since = has_activity_since, exclude_alliance_id = exclude_alliance_id, reason = 'QUERY_ALLIANCE_LIST')
            else:
                result = []
                retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])

            retmsg.append(["QUERY_ALLIANCE_LIST_RESULT", result, tag])

        elif arg[0] == "QUERY_ALLIANCE_SCORE_LEADERS":
            field_name, period = arg[1]
            include_my_alliance = arg[2]
            tag = arg[3]
            result = None
            success = True

            if (not session.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) or \
               (not gamesite.sql_client):
                retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])
                success = False

            LIST_MAX = 47 # 47 makes the display look nicer with current UI pagination
            LIST_NEAR_ME = 2

            # note: region would need to be specified separately by the client to distinguish region vs continent-scope region_specific stat counters
            addr = session.player.scores2_query_addr(field_name, period) # region = session.player.home_region

            if success:
                # get top 50 alliances
                result = gamesite.mongo_scores2_client.alliance_scores2_get_leaders([addr], LIST_MAX, reason = 'QUERY_ALLIANCE_SCORE_LEADERS')[0]
                if not result:
                    success = False

            if success and include_my_alliance:
                # now query standings near your own alliance, if you're not in the top 50
                alliance_id = gamesite.sql_client.get_users_alliance(session.user.user_id, reason = 'QUERY_ALLIANCE_SCORE_LEADERS')
                if alliance_id > 0:
                    myscore = gamesite.mongo_scores2_client.alliance_scores2_get([alliance_id], [addr], rank = True, reason = 'QUERY_ALLIANCE_SCORE_LEADERS')[0][0]

                    if myscore:
                        if myscore.get('rank',-1) > (LIST_MAX-1):
                            result += gamesite.mongo_scores2_client.alliance_scores2_get_leaders([addr], LIST_NEAR_ME*2+1, max(LIST_MAX, myscore['rank']-LIST_NEAR_ME), reason = 'QUERY_ALLIANCE_SCORE_LEADERS')[0]

            retmsg.append(["QUERY_ALLIANCE_SCORE_LEADERS_RESULT", field_name, period, result, tag])

        elif arg[0] == "QUERY_ALLIANCE_INFO" or arg[0] == "QUERY_ALLIANCE_INFO_PRIVATE":
            get_private = False
            get_roles = False
            if type(arg[1]) is list:
                alliance_ids = map(int, arg[1])
                get_roles = bool(len(arg[1]) == 1)
            else:
                alliance_ids = int(arg[1])
                get_roles = True

            get_private = (arg[0] == "QUERY_ALLIANCE_INFO_PRIVATE") and (len(alliance_ids) == 1) and (alliance_ids[0] == session.get_alliance_id())

            tag = arg[2]

            if gamesite.sql_client:
                result = gamesite.sql_client.get_alliance_info(alliance_ids, member_access = get_private, get_roles = get_roles, reason = arg[0])
            else:
                result = [None] * len(alliance_ids) if type(arg[1]) is list else None
            retmsg.append(["QUERY_ALLIANCE_INFO_RESULT", alliance_ids, result, tag])

        elif arg[0] == "QUERY_ALLIANCE_MEMBERS":
            alliance_id = int(arg[1])
            check_for_invite = arg[2]
            tag = arg[3]
            if len(arg) >= 5:
                score_fields_periods = arg[4]
            else:
                score_fields_periods = None
            result = None
            pcache_data = None
            invite_status = None

            if gamesite.sql_client:
                result = gamesite.sql_client.get_alliance_members(alliance_id, reason = 'QUERY_ALLIANCE_MEBERS')

                if result and len(result) > 0 and score_fields_periods:
                    score_result = gamesite.mongo_scores2_client.player_scores2_get([r['user_id'] for r in result],
                                                                                    [session.player.scores2_query_addr(field_name, period) \
                                                                                     for field_name, period in score_fields_periods],
                                                                                    reason = 'QUERY_ALLIANCE_MEMBERS(score)')
                else:
                    score_result = None

                # add player cache data
                if result and len(result) > 0:
                    pcache_data = self.do_query_player_cache(session, [r['user_id'] for r in result], reason = 'QUERY_ALLIANCE_MEMBERS')
                    for i in xrange(len(pcache_data)):
                        r = pcache_data[i]
                        if r:
                            # fill in alliance_id
                            r['alliance_id'] = alliance_id

                            # fill in score (XXXXXX awkward - this should be transmitted separate from pcache)
                            if score_fields_periods:
                                for n in xrange(len(score_fields_periods)):
                                    r[score_fields_periods[n][0]] = score_result[i][n]['absolute'] if score_result[i][n] else 0

                if check_for_invite:
                    invite_status = gamesite.sql_client.am_i_invited(alliance_id, session.user.user_id, server_time, reason = 'QUERY_ALLIANCE_MEMBERS')

            retmsg.append(["QUERY_ALLIANCE_MEMBERS_RESULT", alliance_id, result, pcache_data, invite_status, tag])

        elif arg[0] == "ALLIANCE_SEND_JOIN_REQUEST":
            alliance_id = int(arg[1])
            tag = arg[2]
            success = True

            if (not session.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) or \
               (not gamesite.sql_client):
                retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])
                success = False

            if (not Predicates.read_predicate({'predicate':'LIBRARY','name':'alliance_join_requirement'}).is_satisfied2(session, session.player, None)):
                retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED"])
                success = False

            if success:
                # cannot send join request when already in an alliance
                if session.get_alliance_id() >= 0:
                    success = False

            if success:
                # check for async notifications
                self.do_receive_mail(session, retmsg, type_filter = ['cooldown_trigger'])
                spell = gamedata['spells']['ALLIANCE_LEAVE']
                if spell.get('cooldown',-1) > 0 and session.player.cooldown_active(spell['cooldown_name']):
                    success = False

            if success:
                cd_name = 'alliance_join_request:%d' % alliance_id
                if session.player.cooldown_active(cd_name):
                    success = False

            if success:
                success = gamesite.sql_client.send_join_request(session.user.user_id, alliance_id, server_time, server_time + gamedata['alliances']['invite_duration'], reason = 'ALLIANCE_SEND_JOIN_REQUEST')

            if success:
                metric_event_coded(session.user.user_id, '4640_alliance_member_join_request_sent', {'alliance_id':alliance_id})
                session.player.cooldown_trigger(cd_name, gamedata['alliances']['join_request_cooldown'])
                retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])

            retmsg.append(["ALLIANCE_SEND_JOIN_REQUEST_RESULT", alliance_id, success, tag])

        elif arg[0] == "ALLIANCE_ACK_JOIN_REQUEST":
            alliance_id = int(arg[1])
            invitee = int(arg[2])
            accept = bool(arg[3])
            tag = arg[4]
            success = True

            if (not session.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) or \
               (not gamesite.sql_client):
                retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])
                success = False

            if success:
                success = gamesite.sql_client.ack_join_request(session.user.user_id, alliance_id, invitee, accept, server_time, gamedata['alliances']['max_members'], reason='ALLIANCE_ACK_JOIN_REQUEST')

            if success:
                info = gamesite.sql_client.get_alliance_info(alliance_id, get_roles = True, reason = 'ALLIANCE_ACK_JOIN_REQUEST')
                my_role_info = info['roles'][str(session.alliance_membership_cache.get('role',gamesite.sql_client.ROLE_DEFAULT))]
                if info and ('ui_name' in info):
                    msg = gamedata['strings']['alliance_join_request_' + ('accepted' if accept else 'rejected') + '_mail']
                    gamesite.msg_client.msg_send([{'type':'mail',
                                                   'expire_time': server_time + gamedata['alliances']['invite_duration'],
                                                   'from_name': msg['ui_from'].replace('%LEADER_NAME', session.user.get_chat_name(session.player)).replace('%LEADER_ROLE_NAME', my_role_info['ui_name']).replace('%ALLIANCE_NAME', alliance_display_name(info)),
                                                   'to': [invitee],
                                                   'subject': msg['ui_subject'],
                                                   'body': msg['ui_body'].replace('%ALLIANCE_NAME', alliance_display_name(info))
                                                   }])
                    if accept:
                        session.player.update_alliance_score_cache(alliance_id, alliance_info = info, reason='ALLIANCE_ACK_JOIN_REQUEST')
                        gamesite.pcache_client.player_cache_update(invitee, {'alliance_id': alliance_id}, reason = 'ALLIANCE_ACK_JOIN_REQUEST')
                        # send a separate async notification
                        gamesite.msg_client.msg_send([{'to': [invitee],
                                                       'from': session.user.user_id,
                                                       'type': 'alliance_status_changed',
                                                       'unique_per_sender': 'alliance_status_changed',
                                                       'expire_time': server_time + gamedata['alliances']['status_change_mail_duration']
                                                       }])
                    if accept:
                        if session.alliance_chat_channel and gamedata['server']['chat_alliance_membership']:
                            data = self.do_query_player_cache(session, [invitee], reason = 'ALLIANCE_ACK_JOIN_REQUEST', get_trophies = False)[0] or {}
                            session.do_chat_send(session.alliance_chat_channel, 'I accepted an alliance member!', bypass_gag = True, props = {'type':'accepted_alliance_member', 'target_user_id': invitee,
                                                                                                                                              'target_chat_name': pcache_get_chat_name(data)
                                                                                                                                              })

            if success:
                metric_event_coded(session.user.user_id,
                                   '4650_alliance_member_join_request_accepted' if accept else '4660_alliance_member_join_request_rejected',
                                   {'alliance_id':alliance_id,
                                    'alliance_ui_name': info['ui_name'],
                                    'alliance_chat_tag': info.get('chat_tag'),
                                    'target_id': invitee})

            retmsg.append(["ALLIANCE_ACK_JOIN_REQUEST_RESULT", alliance_id, invitee, success, tag])

        elif arg[0] == "ALLIANCE_INVITE":
            alliance_id = int(arg[1])
            invitee = int(arg[2])
            tag = arg[3]
            success = True

            if (not session.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) or \
               (not gamesite.sql_client):
                retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])
                success = False

            if session.player.cooldown_active('alliance_invite:'+str(invitee)):
                success = False
            else:
                session.player.cooldown_trigger('alliance_invite:'+str(invitee), gamedata['alliances']['invite_cooldown'])

            retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])

            if success:
                expire_time = server_time + gamedata['alliances']['invite_duration']
                success = gamesite.sql_client.send_alliance_invite(session.user.user_id, invitee, alliance_id,
                                                                   server_time, expire_time,
                                                                   reason='ALLIANCE_INVITE')
            if success:
                metric_event_coded(session.user.user_id, '4605_alliance_member_invite_sent', {'alliance_id':alliance_id, 'target_id':invitee})

            if success:
                info = gamesite.sql_client.get_alliance_info(alliance_id, get_roles = True, reason = 'ALLIANCE_INVITE')
                my_role_info = info['roles'][str(session.alliance_membership_cache.get('role',gamesite.sql_client.ROLE_DEFAULT))]
                if info and ('ui_name' in info):
                    msg = gamedata['strings']['alliance_invite_mail']
                    gamesite.msg_client.msg_send([{'type':'mail',
                                                   'expire_time': expire_time,
                                                   'from_name': msg['ui_from'].replace('%LEADER_NAME', session.user.get_chat_name(session.player)).replace('%LEADER_ROLE_NAME', my_role_info['ui_name']).replace('%ALLIANCE_NAME', alliance_display_name(info)),
                                                   'to': [invitee],
                                                   'subject': msg['ui_subject'],
                                                   'body': msg['ui_body'].replace('%LEADER_NAME', session.user.get_chat_name(session.player)).replace('%LEADER_ROLE_NAME', my_role_info['ui_name']).replace('%ALLIANCE_NAME', alliance_display_name(info)).replace('%ALLIANCE_ID', str(alliance_id))
                                                   }])

            retmsg.append(["ALLIANCE_INVITE_RESULT", alliance_id, invitee, success, tag])

        elif arg[0] == "ALLIANCE_KICK":
            alliance_id = int(arg[1])
            kickee = int(arg[2])
            tag = arg[3]
            success = True
            assert kickee != session.user.user_id

            if (not session.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) or \
               (not gamesite.sql_client):
                retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])
                success = False

            info = gamesite.sql_client.get_alliance_info(alliance_id, get_roles = True, reason = 'ALLIANCE_KICK')
            assert info

            if success:
                success = gamesite.sql_client.kick_from_alliance(session.user.user_id, alliance_id, kickee,
                                                                 reason='ALLIANCE_KICK')
            if success:
                session.player.update_alliance_score_cache(alliance_id, reason='ALLIANCE_KICK')
                gamesite.pcache_client.player_cache_update(kickee, {'alliance_id': -1}, reason = 'ALLIANCE_KICK')
                metric_event_coded(session.user.user_id, '4625_alliance_member_kicked', {'alliance_id':alliance_id,
                                                                                         'alliance_ui_name': info['ui_name'],
                                                                                         'alliance_chat_tag': info.get('chat_tag'),
                                                                                         'target_id':kickee})

            if success and session.alliance_chat_channel and gamedata['server']['chat_alliance_membership']:
                data = self.do_query_player_cache(session, [kickee], reason = 'ALLIANCE_KICK', get_trophies = False)[0] or {}
                session.do_chat_send(session.alliance_chat_channel, 'I kicked an alliance member!', bypass_gag = True, props = {'type':'kicked_alliance_member', 'target_user_id': kickee,
                                                                                                                                'target_chat_name': pcache_get_chat_name(data)
                                                                                                                                })

            if success:
                my_role_info = info['roles'][str(session.alliance_membership_cache.get('role',gamesite.sql_client.ROLE_DEFAULT))]
                if info and ('ui_name' in info):
                    msg = gamedata['strings']['alliance_kick_mail']
                    messages = [{'type':'mail',
                                 'expire_time': msg['duration'] if msg['duration'] < 0 else server_time + msg['duration'],
                                 'from_name': msg['ui_from'].replace('%LEADER_NAME', session.user.get_chat_name(session.player)).replace('%LEADER_ROLE_NAME', my_role_info['ui_name']).replace('%ALLIANCE_NAME', alliance_display_name(info)),
                                 'to': [kickee],
                                 'subject': msg['ui_subject'],
                                 'body': msg['ui_body'].replace('%LEADER_NAME', session.user.get_chat_name(session.player)).replace('%LEADER_ROLE_NAME', my_role_info['ui_name']).replace('%ALLIANCE_NAME', alliance_display_name(info))
                                 },
                                {'to': [kickee],
                                 'from': session.user.user_id,
                                 'type': 'alliance_status_changed',
                                 'unique_per_sender': 'alliance_status_changed',
                                 'expire_time': server_time + gamedata['alliances']['status_change_mail_duration']
                                 }
                                ]
                    spell = gamedata['spells']['ALLIANCE_LEAVE']
                    cd_time = spell.get('cooldown',-1) # note: does not check cooldown_if predicate
                    if cd_time > 0:
                        # queue asynchronous message to start the deserter cooldown
                        messages.append({'to': [kickee],
                                         'type':'cooldown_trigger',
                                         'expire_time': server_time + cd_time,
                                         'from': session.user.user_id,
                                         'cooldown_name': spell['cooldown_name'],
                                         'end_time': server_time + cd_time})
                    gamesite.msg_client.msg_send(messages)

                    gamesite.do_CONTROLAPI(session.user.user_id, {'method':'apply_alliance_leave_point_loss','reliable':1,'user_id':kickee,'alliance_ui_name':info['ui_name']})

                    metric_event_coded(session.user.user_id, '4602_alliance_num_members_updated', {'alliance_id': alliance_id, 'num_members_cache': info['num_members']})

            retmsg.append(["ALLIANCE_KICK_RESULT", alliance_id, kickee, success, tag])

        elif arg[0] == "ALLIANCE_PROMOTE":
            alliance_id = int(arg[1])
            promotee_id = int(arg[2])
            old_role = arg[3]
            new_role = arg[4]
            tag = arg[5]
            success = True
            assert promotee_id != session.user.user_id

            if (not session.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) or \
               (not gamesite.sql_client):
                retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])
                success = False

            if success:
                success = gamesite.sql_client.promote_alliance_member(alliance_id, session.user.user_id, promotee_id, old_role, new_role, reason='ALLIANCE_PROMOTE')

            if success:
                info = gamesite.sql_client.get_alliance_info(alliance_id, get_roles = True, reason = 'ALLIANCE_PROMOTE')
                metric_event_coded(session.user.user_id, '4626_alliance_member_promoted', {'alliance_id':alliance_id,
                                                                                           'alliance_ui_name': info['ui_name'],
                                                                                           'alliance_chat_tag': info.get('chat_tag'),
                                                                                           'target_id':promotee_id,
                                                                                           'role':new_role})
                new_role_info = info['roles'][str(new_role)]
                pcache_data = self.do_query_player_cache(session, [promotee_id], reason = 'ALLIANCE_PROMOTE', get_trophies = False)[0] or {}
                if session.alliance_chat_channel and gamedata['server']['chat_alliance_membership']:
                    session.do_chat_send(session.alliance_chat_channel, '',
                                         bypass_gag = True, props = {'type':'promoted_alliance_member' if new_role > old_role else 'demoted_alliance_member',
                                                                     'target_user_id': promotee_id, 'target_role_ui_name': new_role_info['ui_name'],
                                                                     'target_chat_name': pcache_get_chat_name(pcache_data)})

                # refresh our own membership, in case we got demoted
                my_alliance_info, my_alliance_membership = session.init_alliance(retmsg, chat_catchup = False, reason='ALLIANCE_PROMOTE')
                my_role_info = info['roles'][str(my_alliance_membership.get('role', gamesite.sql_client.ROLE_DEFAULT))]

                msg = gamedata['strings']['alliance_'+('promote' if new_role > old_role else 'demote')+'_mail']
                gamesite.msg_client.msg_send([{'type':'mail',
                                               'expire_time': msg['duration'] if msg['duration'] < 0 else server_time + msg['duration'],
                                               'from_name': msg['ui_from'].replace('%LEADER_NAME', session.user.get_chat_name(session.player)).replace('%LEADER_ROLE_NAME', my_role_info['ui_name']).replace('%ALLIANCE_NAME', alliance_display_name(info)),
                                               'to': [promotee_id],
                                               'subject': msg['ui_subject'].replace('%NEW_ROLE_NAME', new_role_info['ui_name']),
                                               'body': msg['ui_body'].replace('%LEADER_NAME', session.user.get_chat_name(session.player)).replace('%LEADER_ROLE_NAME', my_role_info['ui_name']).replace('%ALLIANCE_NAME', alliance_display_name(info)).replace('%NEW_ROLE_NAME', new_role_info['ui_name'])
                                               },
                                              {'type': 'alliance_role_changed',
                                               'to': [promotee_id],
                                               'from': session.user.user_id,
                                               'unique_per_sender': 'alliance_role_changed',
                                               'expire_time': server_time + gamedata['alliances']['status_change_mail_duration']
                                               }
                                              ])

                retmsg.append(["ALLIANCE_UPDATE", my_alliance_info['id'] if my_alliance_info else -1, True, my_alliance_info, my_alliance_membership, False])


                config_name = 'alliance_promoted' if new_role > old_role else 'alliance_demoted'
                config = gamesite.get_localized_gamedata('fb_notifications', pcache_data.get('locale'))['notifications'].get(config_name,None)
                if config:
                    notif_text = config['ui_name'].replace('%ACTOR_NAME', session.user.get_chat_name(session.player)).replace('%ACTOR_ROLE', my_role_info['ui_name']).replace('%NEW_ROLE', new_role_info['ui_name']).replace('%ALLIANCE_NAME', alliance_display_name(info))
                    gamesite.do_CONTROLAPI(session.user.user_id, {'method':'send_notification','reliable':1,'user_id':promotee_id,'text':notif_text,'config':config_name,'force':1})

            retmsg.append(["ALLIANCE_PROMOTE_RESULT", alliance_id, promotee_id, success, tag])

        elif arg[0] == "ALLIANCE_JOIN":
            alliance_id = int(arg[1])
            success = True

            if (not session.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) or \
               (not gamesite.sql_client):
                retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])
                return

            if success:
                if (not Predicates.read_predicate({'predicate':'LIBRARY','name':'alliance_join_requirement'}).is_satisfied2(session, session.player, None)):
                    retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED"])
                    success = False

            if success:
                # check for async notifications
                self.do_receive_mail(session, retmsg, type_filter = ['cooldown_trigger'])
                spell = gamedata['spells']['ALLIANCE_LEAVE']
                if spell.get('cooldown',-1) > 0 and session.player.cooldown_active(spell['cooldown_name']):
                    success = False

            inviter_id = None

            if success:
                success, inviter_id = gamesite.sql_client.join_alliance(session.user.user_id, alliance_id, server_time, gamedata['alliances']['max_members'], reason='ALLIANCE_JOIN')

            if success:
                new_alliance_info, new_alliance_membership = session.init_alliance(retmsg, reason='ALLIANCE_JOIN')
                retmsg.append(["ALLIANCE_UPDATE", new_alliance_info['id'] if new_alliance_info else -1, False, new_alliance_info, new_alliance_membership, False])

                if new_alliance_info:
                    session.player.update_alliance_score_cache(new_alliance_info['id'], alliance_info = new_alliance_info, reason='ALLIANCE_JOIN')
                    gamesite.pcache_client.player_cache_update(session.player.user_id, {'alliance_id': alliance_id}, reason = 'ALLIANCE_JOIN')

                    if session.player.history.get('alliances_joined',0) < 1:
                        session.player.history['alliance_first_join_time'] = server_time
                        session.player.history['alliance_first_join_created'] = 0
                    session.increment_player_metric('alliances_joined', 1, time_series = False)
                    session.deferred_history_update = True

                    metric_props = {'alliance_id': new_alliance_info['id'],
                                    'alliance_ui_name': new_alliance_info['ui_name'],
                                    'alliance_chat_tag': new_alliance_info.get('chat_tag'),
                                    'role': gamesite.sql_client.ROLE_DEFAULT,
                                    'sum':session.player.get_denormalized_summary_props('brief')}
                    if inviter_id: metric_props['inviter_id'] = inviter_id
                    metric_event_coded(session.user.user_id, '4610_alliance_member_joined', metric_props)
                    metric_event_coded(session.user.user_id, '4602_alliance_num_members_updated', {'alliance_id': new_alliance_info['id'], 'num_members_cache': new_alliance_info['num_members']})

                else:
                    success = False

            if success:
                if session.alliance_chat_channel and gamedata['server']['chat_alliance_membership']:
                        session.do_chat_send(session.alliance_chat_channel, 'I joined the alliance!', bypass_gag = True, props = {'type':'joined_alliance'})

            if not success:
                retmsg.append(["ERROR", "CANNOT_JOIN_ALLIANCE"])

        elif arg[0] == "ALLIANCE_LEAVE":
            alliance_id = int(arg[1])
            if (not session.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) or \
               (not gamesite.sql_client):
                retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])
                return
            info, membership = session.get_alliance_info(reason='ALLIANCE_LEAVE')
            old_channel = session.alliance_chat_channel
            new_alliance_info = info
            new_alliance_membership = membership
            if info:
                status = gamesite.sql_client.leave_alliance(session.user.user_id, reason='ALLIANCE_LEAVE')
                new_alliance_info, new_alliance_membership = session.init_alliance(retmsg, reason='ALLIANCE_LEAVE')
                if not new_alliance_info:
                    session.player.update_alliance_score_cache(info['id'], alliance_info = info, reason='ALLIANCE_LEAVE')
                    gamesite.pcache_client.player_cache_update(session.player.user_id, {'alliance_id': -1}, reason = 'ALLIANCE_LEAVE')
                    spell = gamedata['spells']['ALLIANCE_LEAVE']
                    if ('cooldown_if' not in spell) or Predicates.read_predicate(spell['cooldown_if']).is_satisfied2(session, session.player, None):
                        cd_time = spell.get('cooldown',-1)
                    else:
                        cd_time = -1
                    if cd_time > 0:
                        session.player.cooldown_trigger(spell['cooldown_name'], cd_time)
                        retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])
                    session.increment_player_metric('alliances_left', 1, time_series = False)
                    metric_event_coded(session.user.user_id, '4620_alliance_member_left', {'alliance_id': info['id'],
                                                                                           'alliance_ui_name': info['ui_name'],
                                                                                           'alliance_chat_tag': info.get('chat_tag'),
                                                                                           'sum':session.player.get_denormalized_summary_props('brief')})
                    metric_event_coded(session.user.user_id, '4602_alliance_num_members_updated', {'alliance_id': info['id'], 'num_members_cache': info['num_members']-1})

                    if old_channel and gamedata['server']['chat_alliance_membership']:
                        session.do_chat_send(old_channel, 'I left the alliance!', bypass_gag = True, props = {'type':'left_alliance'})

                    if session.player.apply_alliance_leave_point_loss(info['ui_name']):
                        session.deferred_mailbox_update = True
                        retmsg.append(["PLAYER_CACHE_UPDATE", [self.get_player_cache_props(session.user, session.player, -1)]])

                    if status == -1: # alliance was disbanded
                        session.increment_player_metric('alliances_disbanded', 1, time_series = False)
                        metric_event_coded(session.user.user_id, '4630_alliance_disbanded', {'alliance_id': info['id'],
                                                                                             'sum':session.player.get_denormalized_summary_props('brief')})
                    elif status > 0: # new leader was appointed
                        pass

            retmsg.append(["ALLIANCE_UPDATE", new_alliance_info['id'] if new_alliance_info else -1, False, new_alliance_info, new_alliance_membership, False])

        elif arg[0] == "QUERY_PLAYER_SCORES2":
            user_ids = arg[1]
            client_stat_axes_list = arg[2]
            tag = arg[3]
            get_rank = bool(arg[4])
            offline_msg = None

            query_addrs = [(stat, session.player.scores2_query_point(axes, allow_cold_history = True), sort_order) for stat, axes, sort_order in client_stat_axes_list]

            result = []
            for u in xrange(len(user_ids)):
                result.append([None,]*len(query_addrs))

            # check for invalid query coordinates (None return from scores2_query_point())
            for point in query_addrs:
                if point[1] is None:
                    retmsg.append(["QUERY_PLAYER_SCORES2_RESULT", user_ids, result, tag, None, point[0]])
                    return

            # split query into "hot" MongoDB and "cold" SQL parts
            # the "hot" stats are updated basically in realtime via MongoDB
            # "cold" stats are updated offline by scores2_to_sql.py (and may be in a maintenance window!)
            # so, any query that affects competition/game rules should use the "hot" stats!
            mongo_query_i_addrs = []
            sql_query_i_addrs = []

            def is_hot_point(point, cur_week, cur_season):
                # note: time_scope "ALL" queries can go to cold SQL, even though they are otherwise "hot",
                # if we need to cut down on synchronous MongoDB queries.
                time_all_is_hot = gamedata.get('scores2_time_all_is_hot', True)
                return (point[1]['time'][0] == Scores2.FREQ_WEEK and point[1]['time'][1] >= cur_week) or \
                       (point[1]['time'][0] == Scores2.FREQ_SEASON and point[1]['time'][1] >= cur_season) or \
                       (point[1]['time'][0] == Scores2.FREQ_ALL and time_all_is_hot)

            for i in xrange(len(query_addrs)):
                point = query_addrs[i]
                if is_hot_point(point,
                                SpinConfig.get_pvp_week(gamedata['matchmaking']['week_origin'], server_time), # note: use server_time, not player's override, since this is for talking to the database
                                SpinConfig.get_pvp_season(gamedata['matchmaking']['season_starts'], server_time)):
                    mongo_query_i_addrs.append((i, point))
                else:
                    sql_query_i_addrs.append((i, point))

            if mongo_query_i_addrs: # do hot query
                mongo_result = gamesite.mongo_scores2_client.player_scores2_get(user_ids, [x[1] for x in mongo_query_i_addrs], rank = get_rank, reason='QUERY_PLAYER_SCORES2')
                for u in xrange(len(user_ids)):
                    for j in xrange(len(mongo_query_i_addrs)):
                        result[u][mongo_query_i_addrs[j][0]] = mongo_result[u][j]

            if sql_query_i_addrs and gamesite.sql_scores2_client: # do cold query
                # this technique to launch a chain of sequential SQL queries is based on the test code in Scores2.py
                batch = gamesite.sql_scores2_client.player_scores2_get_async(user_ids, [x[1] for x in sql_query_i_addrs], rank = get_rank, reason='QUERY_PLAYER_SCORES2')
                bdict = batch.get_qs_dict()
                rdict = {}
                tag_list = sorted(bdict.keys())
                master_d = make_deferred('QUERY_PLAYER_SCORES2')

                # launch next query in chain
                def next_query(master_d, session, retmsg, retmsg_tag, result, user_ids, sql_query_i_addrs, batch, bdict, rdict, tag_list, i, last_result):
                    if session.logout_in_progress:
                        # session went away, abort
                        master_d.callback(True)
                        return

                    if i > 0: # remember result from previous successful query
                        rdict[tag_list[i-1]] = last_result

                    if i >= len(tag_list): # last query - done!
                        sql_result = gamesite.sql_scores2_client.player_scores2_get_async_complete(batch, rdict)
                        # combine with mongo_result above
                        for u in xrange(len(user_ids)):
                            for j in xrange(len(sql_query_i_addrs)):
                                result[u][sql_query_i_addrs[j][0]] = sql_result[u][j]
                        # complete async request
                        session.send([["QUERY_PLAYER_SCORES2_RESULT", user_ids, result, retmsg_tag, None]], flush_now = True)
                        master_d.callback(True)
                        return

                    def on_error(master_d, session, retmsg, retmsg_tag, result, user_ids, fail):
                        # complete async request, returning the incomplete results
                        if not session.logout_in_progress:
                            session.send([["QUERY_PLAYER_SCORES2_RESULT", user_ids, result, retmsg_tag, 'SCORES_OFFLINE']], flush_now = True)
                        master_d.callback(True)

                    if not gamesite.sql_scores2_client:
                        on_error(master_d, session, retmsg, retmsg_tag, result, user_ids, Exception('Scores2 SQL client is down'))
                        return # not async

                    qs, qs_args = bdict[tag_list[i]]
                    d = gamesite.sql_scores2_client.sql_client.runQuery(qs, qs_args) # "SELECT pg_sleep(2); "+qs for latency testing

                    d.addCallbacks(functools.partial(next_query, master_d, session, retmsg, retmsg_tag, result, user_ids, sql_query_i_addrs, batch, bdict, rdict, tag_list, i+1),
                                   functools.partial(on_error, master_d, session, retmsg, retmsg_tag, result, user_ids))

                reactor.callLater(0, functools.partial(next_query, master_d, session, retmsg, tag, result, user_ids, sql_query_i_addrs, batch, bdict, rdict, tag_list, -1, None))
                return None # note: asynchronous with other session traffic! - not session.start_async_request(master_d)

            elif sql_query_i_addrs: # client asked for historical scores, but we cannot provide them
                offline_msg = 'SCORES_OFFLINE'

            retmsg.append(["QUERY_PLAYER_SCORES2_RESULT", user_ids, result, tag, offline_msg])

        elif arg[0] == "QUERY_SCORE_LEADERS2":
            stat = arg[1]
            axes = arg[2]
            sort_order = arg[3]
            tag = arg[4]

            limit = gamedata['matchmaking']['max_leaderboard_entries']
            if len(arg) >= 6 and arg[5] > 0:
                limit = max(min(limit, arg[5]), 1)

            # note: this only hits the "hot" database
            query_point = session.player.scores2_query_point(axes)
            if query_point is not None:
                result = gamesite.mongo_scores2_client.player_scores2_get_leaders([(stat, query_point, sort_order)],
                                                                                  limit, reason = 'QUERY_SCORE_LEADERS2')[0]
            else:
                result = [] # invalid query

            # decorate result with player cache properties
            if result:
                props = self.do_query_player_cache(session, [x['user_id'] for x in result], reason = 'QUERY_SCORE_LEADERS')
                for r, p in zip(result, props):
                    r.update(p)

            retmsg.append(["QUERY_SCORE_LEADERS2_RESULT", stat, axes, result, tag])

        elif arg[0] == "CHAT_GETMORE":
            channel = arg[1]
            end_time = arg[2]
            end_msg_id = arg[3]
            request_tag = arg[4]
            # note: collect response manually, not in retmsg
            response = []
            is_final = session.do_chat_getmore(session.decode_chat_channel_name(channel), end_time, end_msg_id, response)
            retmsg.append(["CHAT_GETMORE_RESULT", request_tag, response, is_final])

        elif arg[0] == "CHAT_SEND":
            channel = arg[1]
            text = SpinHTTP.unwrap_string(arg[2]).strip()

            # try to avoid DOS attack spam
            limit = gamedata['chat_length_limit']
            if len(text) > limit:
                text = text[:limit]

            if not text: return # don't send empty message

            if chat_filter.is_ugly(text):
                if gamedata['server'].get('log_ugly_chat', True):
                    gamesite.exception_log.event(server_time, 'Player %d stopped from sending ugly chat message: %r' % (session.player.user_id, text))
                retmsg.append(["CHAT_RECV", channel, {'chat_name': 'System', 'time': server_time, 'facebook_id': -1, 'user_id': -1},
                               SpinHTTP.wrap_string(gamedata['errors']['CHAT_UGLY']['ui_name']), None, False])
                return

            success = True

            if session.player.cooldown_active('CHAT_SEND') >= gamedata['chat_spam_threshold'] or \
               (channel in ('GLOBAL','REGION',) and chat_filter.is_spammy(text)):
                session.player.cooldown_trigger('chat_spam_penalty', gamedata['chat_spam_penalty'])
                session.player.cooldown_reset('CHAT_SEND')
                metric_event_coded(session.user.user_id, '4023_chat_spam_throttled', {'text': text})

            togo = session.player.cooldown_togo('chat_spam_penalty')
            if togo > 0:
                success = False
                retmsg.append(["CHAT_RECV", channel, {'chat_name': 'System', 'time': server_time, 'facebook_id': -1, 'user_id': -1},
                               SpinHTTP.wrap_string(gamedata['errors']['CHAT_THROTTLED']['ui_name'].replace('%d', str(togo))), None, False])

            retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])

            if success:
                session.player.cooldown_trigger('CHAT_SEND', gamedata['chat_spam_cooldown'], add_stack = 1)

                bypass_gag = (channel not in ('GLOBAL','REGION'))

                session.activity_classifier.sent_chat_message(channel, is_public = (not bypass_gag), is_alliance = (channel == 'ALLIANCE'))

                if session.setmax_player_metric('feature_used:alliance_chat' if (channel == 'ALLIANCE') else 'feature_used:public_chat', 1):
                    session.deferred_history_update = True

                # remap channel name from generic client-side names to specific server-side names
                channel = session.decode_chat_channel_name(channel)
                if not channel:
                    retmsg.append(["ERROR", "INVALID_CHAT_CHANNEL"])
                    return

                if not bypass_gag:
                    session.player.cooldown_trigger('chat_reportable', gamedata['chat_report_window'])

                special_template = None
                if session.player.chat_official:
                    special_template = 'official'
                elif channel != session.alliance_chat_channel:
                    special_template = session.player.stattab.get_player_stat('chat_template')

                props = None
                if special_template and special_template != 'default':
                    props = {'type':special_template}
                else:
                    props = None

                session.do_chat_send(channel, text, bypass_gag = bypass_gag, props = props, retmsg = retmsg)

        elif arg[0] == "CHAT_REPORT":
            target_uid = arg[1]
            target_chat_name = SpinHTTP.unwrap_string(arg[2])
            session.do_chat_report(target_uid, target_chat_name, retmsg)
        elif arg[0] == "CHAT_REPORT2":
            target_uid = arg[1]
            channel = {'GLOBAL': session.global_chat_channel,
                       'REGION': session.region_chat_channel,
                       }.get(arg[2], None)
            context_time = arg[3]
            target_message_id = arg[4] if len(arg) >= 5 else None
            if not channel:
                retmsg.append(["ERROR", "INVALID_CHAT_CHANNEL"])
                return
            assert target_uid > 0
            session.do_chat_report2(target_uid, channel, context_time, target_message_id)

        elif arg[0] == "UNIT_REPAIR_TICK":
            self.do_unit_repair_tick(session, retmsg, must_reply = True)
        elif arg[0] == "UNIT_REPAIR_QUEUE":
            if session.player.squads_enabled():
                retmsg.append(["ERROR", "SERVER_PROTOCOL"])
                return
            error = self.do_unit_repair_queue(session, arg[1])
            if error: retmsg.append(["ERROR"] + error)
            session.player.unit_repair_send(retmsg)
            retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])
        elif arg[0] == "UNIT_REPAIR_CANCEL":
            if session.player.squads_enabled():
                retmsg.append(["ERROR", "SERVER_PROTOCOL"])
                return
            self.do_unit_repair_cancel(session, retmsg, arg[1])
        elif arg[0] == "UNIT_REPAIR_SPEEDUP_FOR_FREE":
            if session.player.squads_enabled():
                retmsg.append(["ERROR", "SERVER_PROTOCOL"])
                return
            self.do_unit_repair_speedup_for_free(session, retmsg)

        elif arg[0] == "CANCEL_PLAYER_AURA":
            specname = arg[1]
            if specname == 'damage_protection': # special case
                if session.player.has_damage_protection():
                    session.player.set_protection_end_time(session, -1, '3886_protection_removed_manually')
            else:
                session.remove_player_aura(specname)

        elif arg[0] in ("INVENTORY_TRASH", "INVENTORY_TRASH_ALL", "INVENTORY_REFUND", "INVENTORY_REFUND_ALL"):
            if session.player.warehouse_is_busy():
                retmsg.append(["ERROR", "WAREHOUSE_IS_BUSY"])
                return

            slot = arg[1]
            specname = arg[2]
            want_refund = arg[0].startswith("INVENTORY_REFUND")
            success = False

            spec = gamedata['items'].get(specname, None)
            if want_refund:
                assert spec
                if (not spec.get('refund',False)) or (('refundable_when' in spec) and (not Predicates.read_predicate(spec['refundable_when']).is_satisfied2(session, session.player, None))):
                    retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
                    return

            num_removed = 0
            item = session.player.inventory_verify_item(slot, specname)
            if item is not None:
                if arg[0].endswith("_ALL"):
                    session.player.inventory_remove_stack(item, '5131_item_trashed', reason='inventory')
                    num_removed = item.get('stack',1)
                else:
                    session.player.inventory_remove(item, 1, '5131_item_trashed', reason='inventory')
                    num_removed = 1
                success = True

                if want_refund:
                    loot_table = spec['refund']
                    if len(loot_table) >= 1 and (isinstance(loot_table[0], list) or loot_table[0] is None):
                        # per-level list
                        loot_table = loot_table[item.get('level',1)-1]

                    if loot_table: # might be None
                        if num_removed != 1:
                            loot_table = [{'multi':[loot_table], 'multi_stack':num_removed}]
                        session.give_loot(session.player, retmsg, loot_table, 'refund', reason_id = '%dx %s' % (num_removed, specname))
                if spec:
                    session.increment_player_metric('item:'+spec['name']+':trashed', num_removed, time_series=False)
            else:
                retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])

            if success:
                session.deferred_stattab_update = True

            retmsg.append(["INVENTORY_REFUND_RESULT" if want_refund else "INVENTORY_TRASH_RESULT", slot, specname, success, num_removed])
            session.player.send_inventory_update(retmsg)
            session.deferred_player_state_update = True

            if success and want_refund:
                retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, True])

        elif arg[0] == "INVENTORY_USE":
            # note: this now handles using items equipped to buildings, in addition to items from the inventory
            # for inventory items, "slot" is the integer index into player.inventory
            # for equipped items, "slot" is {"obj_id": ..., "slot_type": ..., "slot_index": ... }
            # which is the same format returned by Player.equipped_items_serialize()
            slot = arg[1]
            is_equipped = (type(slot) is dict) # equip item, not in inventory
            client_item = arg[2]
            specname = client_item['spec']
            max_count = arg[3]
            extra_spellargs = arg[4]

            if session.player.warehouse_is_busy(): # XXX what about equip items?
                retmsg.append(["ERROR", "WAREHOUSE_IS_BUSY"])
                retmsg.append(["INVENTORY_USE_RESULT", slot, specname, False, 0, None])
                return

            if is_equipped:
                addr = (slot['slot_type'],slot['slot_index'])
                obj = session.player.get_object_by_obj_id(slot['obj_id'], fail_missing = False)
                if (not obj) or (obj.owner is not session.player) or (not obj.equipment) or \
                   (not Equipment.equip_has(obj.equipment, addr, specname, level = client_item.get('level',None))):
                    # XXX also test if obj is damaged or busy?
                    retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
                    retmsg.append(["INVENTORY_USE_RESULT", slot, specname, False, 0, None])
                    return
                item = Equipment.equip_get(obj.equipment, addr)
            else:
                item = session.player.inventory_verify_item(slot, specname, level = client_item.get('level',None))

            spec = gamedata['items'].get(specname, None)
            if (item is None) or (spec is None):
                retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
                retmsg.append(["INVENTORY_USE_RESULT", slot, specname, False, 0, None])
                session.player.send_inventory_update(retmsg)
                return

            success = False
            used_count = 0

            if spec.get('fungible',False):
                # add directly. Ignore max_count.
                if spec['resource'] == 'gamebucks':
                    success = True
                    used_count = item.get('stack',1)
                    session.player.resources.gain_gamebucks(used_count, reason='item')
                    session.player.inventory_remove_stack(item, '5130_item_activated', reason='fungible')
                elif spec['resource'] in gamedata['resources']:
                    gained_res = session.player.resources.gain_res({spec['resource']:item.get('stack',1)}, reason='item_fungible')
                    used_count = sum(gained_res.itervalues(),0)
                    if used_count > 0:
                        session.player.inventory_remove(item, used_count, '5130_item_activated', reason='fungible')
                        admin_stats.econ_flow_player(session.player, 'item', 'fungible', gained_res)
                        success = True
                    else:
                        retmsg.append(["ERROR", "STORAGE_LIMIT", spec['resource']])

                elif spec['resource'] == 'lottery_scans':
                    used_count = item.get('stack',1)
                    if item.get('expire_time',-1) < 0 or item.get('expire_time',-1) > server_time:
                        assert session.player.do_apply_aura('lottery_scans', stack = used_count,
                                                            duration = (item['expire_time'] - server_time) if item.get('expire_time',-1) > 0 else -1,
                                                            ignore_limit = True)
                    success = True
                    session.player.inventory_remove_stack(item, '5130_item_activated', reason='lottery')
                    session.deferred_player_auras_update = True

                else:
                    raise Exception('unhandled fungible resource '+spec['resource'])

            elif 'use' in spec:
                success = False

                if 'requires' in spec:
                    if not Predicates.read_predicate(spec['requires']).is_satisfied2(session, session.player, None):
                        retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED"])
                        return

                if (not session.viewing_base.deployment_allowed) and (not session.home_base):
                    retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED"])
                    return

                uselist = spec['use'] if type(spec['use']) is list else [spec['use']]

                assert max_count >= 1 and max_count <= item.get('stack',1)

                try: # ensure item conservation!

                    for i in xrange(max_count):
                        one_success = False
                        for use in uselist:
                            assert type(use) is dict
                            if 'spellname' in use:
                                spellname = use['spellname']
                                spellarg = use.get('spellarg', None)

                                if (spellarg is not None) and extra_spellargs:
                                    if not isinstance(spellarg, list):
                                        spellarg = [spellarg]
                                    else:
                                        spellarg = copy.copy(spellarg)
                                    spellarg += extra_spellargs

                                # XXX special case for GIVE_UNITS items with their own level - read min_level
                                item_level = item.get('level', 1)
                                if spellname == 'GIVE_UNITS' and 'max_level' in spec and isinstance(spellarg, dict):
                                    spellarg = copy.deepcopy(spellarg)
                                    for k, v in spellarg.iteritems():
                                        if isinstance(v, dict) and v.get('min_level') == 'from_item':
                                            v['min_level'] = item_level

                                one_success = self.execute_spell(session, retmsg, spellname, spellarg, reason = 'item')
                            elif 'consequent' in use:
                                # do abort here on exceptions
                                one_success = False
                                session.execute_consequent_safe(use, session.player, retmsg, reason='use(%s)' % spec['name'], rethrow = True)
                                one_success = True

                            if not one_success:
                                break # one of the 'use' actions failed

                        if one_success:
                            success = True # any one item succeeding makes the whole operation count as successful
                            used_count += 1
                        else: # hit an error, don't try to activate any more items
                            break

                finally: # on the way out, remove used items
                    if success:
                        if spec.get('consumable', True):
                            if is_equipped:
                                assert used_count == 1 # might need handling for stacked equipped items for e.g. consumable ammo
                                Equipment.equip_remove(obj.equipment, (slot['slot_type'], slot['slot_index']), specname) # we don't care about the level here
                            else:
                                session.player.inventory_remove(item, used_count, '5130_item_activated', reason='consumed')

                            if session.has_attacked:
                                # record the expenditure for this battle
                                session.attack_item_expended(session.player.user_id, specname, used_count)

                        session.increment_player_metric('items_activated', used_count, time_series = False)
                        session.increment_player_metric('item:'+spec['name']+':activated', used_count, time_series = False)
                        if session.has_attacked:
                            # in battle - history update will come after battle ends
                            pass
                        else:
                            session.deferred_history_update = True

            else:
                raise Exception('item not usable '+repr(spec))

            retmsg.append(["INVENTORY_USE_RESULT", slot, specname, success, used_count, extra_spellargs]) # XXX return full item here
            if success and (not is_equipped):
                session.player.send_inventory_update(retmsg)
                retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

        elif arg[0] == "INVENTORY_RESTACK":
            sort_order = arg[1]
            if session.player.warehouse_is_busy():
                retmsg.append(["ERROR", "WAREHOUSE_IS_BUSY"])
                return
            session.player.inventory_restack(sort_order)
            session.player.send_inventory_update(retmsg)

        elif arg[0] == "EQUIP_BUILDING":
            try:
                success = self.do_equip_building(session, retmsg, arg)
            except:
                gamesite.exception_log.event(server_time, 'exception in EQUIP_BUILDING! item duped or lost! player %d arg %s' % (session.player.user_id, repr(arg)))
                raise
            retmsg.append(["EQUIP_BUILDING_RESULT", arg, success])
            return
        elif arg[0] == "EQUIP_UNIT":
            try:
                success = self.do_equip_unit(session, retmsg, arg)
            except:
                gamesite.exception_log.event(server_time, 'exception in EQUIP_UNIT! item duped or lost! player %d arg %s' % (session.player.user_id, repr(arg)))
                raise
            retmsg.append(["EQUIP_UNIT_RESULT", arg, success])
            return

        elif arg[0] == "MAIL_READ":
            msg_id = arg[1]
            for mail in session.player.mailbox:
                if mail['msg_id'] == msg_id:
                    mail['read'] = 1
                    break

        elif arg[0] == "MAIL_DELETE":
            msg_id = arg[1]
            to_remove = []
            for mail in session.player.mailbox:
                if mail['msg_id'] == msg_id:
                    if any(item.get('undiscardable',False) for item in mail.get('attachments',[])):
                        # message has an undiscardable attachment - do not delete it
                        retmsg.append(["ERROR", "UNDISCARDABLE_ATTACHMENT"])
                        continue
                    to_remove.append(mail)
            for mail in to_remove:
                session.player.mailbox.remove(mail)
            session.player.send_mailbox_update(retmsg)

        elif arg[0] == "MAIL_TAKE_ATTACHMENTS":
            msg_id = arg[1]
            client_index = arg[2]
            client_spec = arg[3]
            client_stack = arg[4]

            if gamedata['server'].get('log_mail',0) >= 3:
                client_debug_info = arg[5]
            else:
                client_debug_info = None

            success = False
            need_space = False
            need_resource_update = False
            need_lottery_update = False
            mail = None
            VERIFY = gamedata['server']['verify_item_conservation']

            if not session.home_base:
                retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])

            for m in session.player.mailbox:
                if m['msg_id'] == msg_id:
                    mail = m
                    break

            if mail and ('attachments' in mail):
                res = session.player.resources.calc_snapshot()

                if VERIFY:
                    old_mail = copy.deepcopy(mail)
                    old_inventory = copy.deepcopy(session.player.inventory)

                to_take = []
                if client_index >= 0 and client_index < len(mail['attachments']):
                    # take one attached stack
                    at = mail['attachments'][client_index]
                    if at['spec'] == client_spec and at.get('stack',1) == client_stack:
                        if at['spec'] in gamedata['items']:
                            spec = gamedata['items'][at['spec']]

                            to_take.append(at)
                            if spec.get('fungible',False):
                                # if we successfully take a fungible item, which adds to resources directly,
                                # then we'll need to send an update of that
                                if spec['resource'] == 'lottery_scans':
                                    need_lottery_update = True
                                    session.deferred_player_auras_update = True
                                else:
                                    need_resource_update = True

                elif client_index < 0:
                    # take all
                    to_take = mail['attachments']

                to_remove = []

                for at in to_take:
                    full_stack = at.get('stack', 1)
                    original_at = copy.deepcopy(at)
                    ret = session.player.inventory_add_item(at, res.max_usable_inventory())
                    if ret >= full_stack:
                        success = True
                        to_remove.append(at)
                    elif ret > 0: # partial success
                        success = True
                        need_space = True
                        original_at['stack'] = ret # reduce stack down to how much was taken
                    else:
                        need_space = True

                    if ret > 0:
                        original_at['collected_at'] = server_time
                        if 'attachments_ghost' not in mail: mail['attachments_ghost'] = []
                        mail['attachments_ghost'].append(original_at)

                        session.player.inventory_log_event('5140_mail_attachment_collected', original_at['spec'], original_at.get('stack',1), original_at.get('expire_time',-1), level=original_at.get('level',None))
                        if original_at.get('log',False):
                            if 'mail_attachment_history' not in session.player.history: session.player.history['mail_attachment_history'] = []
                            session.player.history['mail_attachment_history'].append({'reason':original_at['log'],
                                                                                      'item':copy.deepcopy(original_at)})


                for at in to_remove:
                    mail['attachments'].remove(at)
                if len(mail['attachments']) == 0:
                    del mail['attachments']

                if VERIFY:
                    def count_attachments(m):
                        gamebucks = 0; items = 0 # unfinished gamebucks checking
                        for at in m.get('attachments',[]):
                            spec = gamedata['items'].get(at['spec'],None)
                            if spec and spec.get('fungible',False):
                                if spec['resource'] == 'gamebucks':
                                    gamebucks += at.get('stack',1)
                            else:
                                items += at.get('stack',1)
                        return items
                    def count_inventory(inv):
                        return sum([item.get('stack',1) for item in inv])
                    old_count = count_attachments(old_mail)+count_inventory(old_inventory)
                    new_count = count_attachments(mail)+count_inventory(session.player.inventory)
                    if old_count != new_count:
                        gamesite.exception_log.event(server_time, 'item conservation broken! %s->%s old_mail %s old_inv %s new_mail %s new_inv %s' % \
                                                     (repr(old_count), repr(new_count), repr(old_mail), repr(old_inventory), repr(mail), repr(session.player.inventory)))
                        session.player.inventory = old_inventory
                        session.player.mailbox.remove(mail)
                        session.player.mailbox.append(old_mail)
            else:
                gamesite.exception_log.event(server_time, 'player %d MAIL_TAKE_ATTACHMENTS: msg_id %s present %r index %d spec %s stack %d debug %r' % \
                                             (session.player.user_id, msg_id, bool(mail), client_index, client_spec, client_stack, client_debug_info))
                retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])

            #time.sleep(3) # to test lag

            if success:
                session.player.send_inventory_update(retmsg)
                if need_resource_update:
                    retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])

            retmsg.append(["MAIL_TAKE_ATTACHMENTS_RESULT", msg_id, client_index, success, need_resource_update or need_lottery_update, mail if mail else None])
            if need_space:
                retmsg.append(["ERROR", "INVENTORY_LIMIT"])

        elif arg[0] == "LOOT_BUFFER_TAKE":
            client_contents = arg[1]
            client_index = arg[2]
            success = True
            need_space = False
            need_storage = False

            if (not inventory_list_equal(session.player.loot_buffer, client_contents)) or \
               ((client_index != -1) and \
                (client_index < 0 or \
                 client_index >= len(session.player.loot_buffer))):
                retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
                success = False

            if success:
                res = session.player.resources.calc_snapshot()
                if client_index == -1:
                    to_take = copy.copy(session.player.loot_buffer)
                else:
                    to_take = [session.player.loot_buffer[client_index],]

                for item in to_take:
                    full_stack = item.get('stack',1)
                    item_spec = gamedata['items'].get(item['spec'],{})

                    taken = session.player.inventory_add_item(item, res.max_usable_inventory())

                    if taken > 0 and item_spec.get('fungible',False) and item_spec['resource'] == 'lottery_scans':
                        session.deferred_player_auras_update = True

                    if taken >= full_stack:
                        session.player.loot_buffer.remove(item)
                    elif taken > 0:
                        item['stack'] = full_stack - taken
                        if item_spec.get('fungible',False):
                            need_storage = item_spec['resource']
                        else:
                            need_space = True
                    else:
                        if item_spec.get('fungible',False):
                            need_storage = item_spec['resource']
                        else:
                            need_space = True

            session.player.send_inventory_update(retmsg)
            retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, False])
            if need_space:
                retmsg.append(["ERROR", "INVENTORY_LIMIT"])
            if need_storage:
                retmsg.append(["ERROR", "STORAGE_LIMIT", need_storage])
            if success:
                session.deferred_stattab_update = True

            session.deferred_player_state_update = True

        elif arg[0] == "LOOT_BUFFER_RELEASE":
            client_contents = arg[1]
            session.player.loot_buffer_release('LOOT_BUFFER_RELEASE')
            retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, False])

        elif arg[0] == "LOGIN_INCENTIVE_CLAIM":
            for aura in session.player.player_auras_iter_const():
                if aura['spec'] == 'login_incentive_ready':
                    cur_count = aura.get('stack',1)
                    next_count = cur_count + 1

                    # cycle back to 1 after the last reward
                    if ('login_incentive_%d' % next_count) not in gamedata['loot_tables']:
                        next_count = 1

                    context = {'loot_reason_id': cur_count,
                               'next_count': next_count}
                    session.execute_consequent_safe(session.player.get_abtest_consequent('login_incentive_claim'), session.player, retmsg,
                                                    context = context, reason = arg[0])

                    break

            if session.player.loot_buffer:
                retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, True])

        elif arg[0] == "DAILY_TIP_UNDERSTOOD":
            tipname = arg[1]
            understood = arg[2]
            key = 'daily_tip:'+tipname
            session.setmax_player_metric(key, 2 if understood else 1)

        elif arg[0] == "RECORD_FEATURE_USE":
            name = arg[1]
            key = 'feature_used:'+name
            session.setmax_player_metric(key, 1)

        elif arg[0] == "RECORD_CLIENT_HISTORY":
            name = arg[1]
            incr = arg[2]
            assert len(name) <= 64 # protect against DoS
            key = 'client:'+name
            session.increment_player_metric(key, incr, time_series = False)

        elif arg[0] == "WORLD_COUNTER_UPDATE": # camouflaged name for "start a clock race"
            tag = arg[1]
            assert isinstance(tag, basestring) and len(tag) <= 64
            assert len(session.clock_races) < 64
            session.clock_races[tag] = time.time()

        elif arg[0] == "WORLD_COUNTER_QUERY": # camouflaged name for "end a clock race"
            tag = arg[1]
            client_elapsed_time = float(arg[2])
            client_timeout_target = float(arg[3])
            if tag not in session.clock_races:
                return
            server_elapsed_time = time.time() - session.clock_races[tag]
            del session.clock_races[tag]
            metric_event_coded(session.user.user_id, '3975_clock_race', {'client_interval': client_elapsed_time,
                                                                         'client_timeout_target': client_timeout_target,
                                                                         'server_interval': server_elapsed_time})

        elif arg[0] == "MAP_BOOKMARK_UPDATE":
            region = arg[1]
            ui_name = SpinHTTP.unwrap_string(arg[2])[:24].strip()
            coords = map(int, arg[3])
            new_time = int(arg[4]) if len(arg) >= 5 else None
            assert region in gamedata['regions']
            assert len(coords) == 2
            if ui_name == 'DELETED':
                if region in session.player.map_bookmarks:
                    to_remove = filter(lambda x: x['coords'] == coords, session.player.map_bookmarks[region])
                    for item in to_remove: session.player.map_bookmarks[region].remove(item)
                    if len(session.player.map_bookmarks[region]) < 1:
                        del session.player.map_bookmarks[region]
            else:
                if region not in session.player.map_bookmarks:
                    session.player.map_bookmarks[region] = []
                entry = None
                for item in session.player.map_bookmarks[region]:
                    if item['coords'] == coords:
                        entry = item
                        break
                if entry:
                    entry['ui_name'] = ui_name
                    if new_time:
                        entry['time'] = new_time
                    elif 'time' in entry:
                        del entry['time']

                else:
                    new_entry = {'region':region, 'coords':coords, 'ui_name':ui_name}
                    if new_time: new_entry['time'] = new_time
                    session.player.map_bookmarks[region].append(new_entry)
                    if len(session.player.map_bookmarks[region]) > gamedata['client']['map_bookmarks_max']:
                        session.player.map_bookmarks[region].remove(session.player.map_bookmarks[region][0])

        elif arg[0] == "IDLE_CHECK_RESPONSE":
            response_data = arg[1]
            playtime = session.cur_playtime()
            status = session.player.idle_check.got_response(session.login_time, server_time, playtime, response_data)
            if status == IdleCheck.STATUS_NO_RESULT:
                pass
            elif status == IdleCheck.STATUS_SEND_AGAIN:
                idle_check_msg = session.player.idle_check.start_check(session.login_time, server_time, playtime)
                retmsg.append(["IDLE_CHECK", idle_check_msg])
                metric_event_coded(session.user.user_id, '0691_idle_check', idle_check_msg)
            elif status == IdleCheck.STATUS_FAIL:
                metric_event_coded(session.user.user_id, '0693_idle_check_fail', response_data)
            elif status == IdleCheck.STATUS_SUCCESS:
                metric_event_coded(session.user.user_id, '0692_idle_check_success', response_data)

        elif arg[0] == "INVOKE_FACEBOOK_AUTH_RESPONSE":
            #wanted_scope = arg[1]
            new_perms = arg[2]
            success = arg[3]
            if new_perms and len(new_perms) > 0:
                # add to facebook_permissions to update cache, so we don't go prompting the user again
                for perm in new_perms.split(','):
                    if session.player.facebook_permissions is None:
                        session.player.facebook_permissions = []
                    if perm not in session.player.facebook_permissions:
                        session.player.facebook_permissions.append(perm)
            if success:
                ev = '0038_request_permission_add_scope_success'
            else:
                ev = '0039_request_permission_add_scope_fail'
            metric_event_coded(session.user.user_id, ev, {'method':'gameserver', 'scope':str(new_perms)})

        elif arg[0] == "CLIENT_EVAL_RESULT":
            eval_str = arg[1]
            result = arg[2]
            gamesite.exception_log.event(server_time, 'user %d eval %s -> %s' % (session.user.user_id, str(eval_str), str(result)))

        elif arg[0] == "BH_WEB_PUSH_PROMPT":
            session.increment_player_metric('bh_web_push_prompt', 1, time_series = False)
            session.deferred_history_update = True

        elif arg[0] == "BH_WEB_PUSH_PROMPT_OK":
            session.increment_player_metric('bh_web_push_prompt_ok', 1)
            session.deferred_history_update = True

            config = gamesite.get_localized_gamedata('fb_notifications', session.user.locale)['notifications'].get('bh_web_push_incentive',None)
            if config and session.player.history.get('bh_web_push_incentive',0) < 1:
                notif_text = config['ui_name']
                self.send_offline_notification(session.player.user_id, session.user.social_id,
                                               notif_text, 'bh_web_push_incentive', config['ref'],
                                               session.player.get_denormalized_summary_props('brief'),
                                               locale = session.user.locale,
                                               mirror_to_facebook = False)
                if 'on_send' in config:
                    session.execute_consequent_safe(config['on_send'], session.player, retmsg,
                                                    reason='bh_web_push_prompt_ok')
                session.increment_player_metric('bh_web_push_incentive', 1)

            metric_event_coded(session.player.user_id, '6410_web_push_sub_created', {})

        elif arg[0] == "BH_WEB_PUSH_PROMPT_FAILED":
            if len(arg) >= 4:
                cdname, cduration = arg[2], arg[3]

            if cdname: # trigger anti-annoyance cooldown
                assert cdname == 'bh_web_push_prompt'
                cduration = int(cduration)
                assert cduration > 0
                session.player.cooldown_trigger(cdname, cduration)

            session.increment_player_metric('bh_web_push_prompt_failed', 1)
            session.deferred_history_update = True
            session.deferred_player_cooldowns_update = True


        elif arg[0] == "CLIENT_TRACKING_PIXEL_RESULT":
            pass
        elif arg[0] == "CLIENT_TRACKING_PIXEL_IMAGE_RESULT":
            pass
        elif arg[0] == "CLIENT_TRACKING_PIXEL_BH_RESULT":
            pass

        elif arg[0] == "VERIFY_MICROSOFT_STORE_RECEIPT":
            receipt = arg[1]
            server_tag = arg[2]
            microsoft_outcome = arg[3]
            return session.start_async_request(session.user.verify_ms_store_receipt_async(session, retmsg, receipt, server_tag, microsoft_outcome))

        elif arg[0] == "MICROSOFT_CONSUMABLE_FULFILLED":
            purchase_id = arg[1]
            tracking_id = arg[2]
            if 'ms_store_purchase_history' not in session.player.history: return
            for purchase in session.player.history['ms_store_purchase_history']:
                if purchase['purchase_id'] == purchase_id:
                    purchase['ms_tracking_id'] = tracking_id

        elif arg[0] == "CAST_SPELL":
            id, spellname, spellargs = arg[1], arg[2], arg[3:]

            # XXX need to check that object is actually capable of casting 'spellname'
            if id == GameObject.VIRTUAL_ID:
                # virtual object
                object = None
            elif id == 0:
                raise Exception('bad legacy virtual object id 0 for %s' % spellname)
            else:
                # possible race condition due to unserialized AJAX
                if not session.has_object(id):
                    if gamedata['server'].get('log_combat_race_conditions', False):
                        gamesite.exception_log.event(server_time, 'CAST_SPELL on missing object player %d: %d %s %s' % \
                                                     (session.player.user_id, id, spellname, repr(spellargs)))
                    return

                object = session.get_object(id)
                assert (object.owner is session.player) or (session.player.is_cheater)

            if spellname == "SPEEDUP_FOR_FREE":
                self.do_speedup_for_free(session, retmsg, object)

            elif spellname == "DISABLE_MINEFIELDS":
                spell = gamedata['spells'][spellname]
                assert self.execute_spell(session, retmsg, spell['effect']['spellname'], spell['effect']['spellarg'])

            elif spellname == "REPAIR":
                self.do_start_repairs(session, retmsg, spellargs[0])

            elif spellname == "UPGRADE_FOR_FREE":
                self.do_upgrade(session, retmsg, object)
            elif spellname == "CANCEL_UPGRADE":
                self.do_cancel_upgrade(session, retmsg, object)

            elif spellname == "RESEARCH_FOR_FREE":
                if object not in session.player.home_base_iter():
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                self.do_research(session, retmsg, object, spellargs)
            elif spellname == "CANCEL_RESEARCH":
                if object not in session.player.home_base_iter():
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                self.do_cancel_research(session, retmsg, object)

            elif spellname == "ENHANCE_FOR_FREE":
                if (not object.spec.quarry_upgradable) and (object not in session.player.home_base_iter()):
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                self.do_enhance(session, retmsg, object, spellargs)
            elif spellname == "CANCEL_ENHANCE":
                if (not object.spec.quarry_upgradable) and (object not in session.player.home_base_iter()):
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                self.do_cancel_enhance(session, retmsg, object)

            elif spellname == "CRAFT_FOR_FREE":
                if (not object.spec.quarry_upgradable) and (object not in session.player.home_base_iter()):
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                self.do_craft(session, session.player, retmsg, object, self.CraftSpellarg(spellargs[0]),
                              check_predicates = (not session.player.is_cheater),
                              take_resources = (not session.player.is_cheater),
                              take_ingredients = (not session.player.is_cheater))

            elif spellname == "CANCEL_CRAFT":
                if (not object.spec.quarry_upgradable) and (object not in session.player.home_base_iter()):
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                self.do_cancel_craft(session, retmsg, object, spellargs[0])
            elif spellname == "COLLECT_CRAFT":
                if object not in session.player.home_base_iter():
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                self.do_collect_craft(session, retmsg, object, attempt_id_list = spellargs[0])
                retmsg.append(["OBJECT_STATE_UPDATE2", object.serialize_state()])

            elif spellname == "REMOVE_OBSTACLE_FOR_FREE":
                if object not in session.player.home_base_iter():
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                self.do_remove_obstacle(session, session.player, retmsg, object,
                                        check_predicates = (not session.player.is_cheater),
                                        take_resources = (not session.player.is_cheater),
                                        take_ingredients = (not session.player.is_cheater))

            elif spellname == "COLLECT_DEPOSIT":
                if object not in session.player.home_base_iter():
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                self.do_collect_one_deposit(session, retmsg, object)
                session.player.send_history_update(retmsg)

            elif spellname == "HARVEST":
                if (not session.home_base):
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                session.activity_classifier.harvested()
                self.do_harvest_one(session, retmsg, session.viewing_base.base_type, session.viewing_base.base_region, session.viewing_base.base_id,
                                    object, compute_power_factor(session.player.my_home.get_power_state()), None, None)
                retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])
                session.player.send_history_update(retmsg)
            elif spellname == "HARVEST_ALL2":
                session.activity_classifier.harvested()
                self.do_harvest_all(session, retmsg, session.player.my_home.base_type, session.player.my_home.base_region, session.player.my_home.base_id,
                                    session.player.home_base_iter(), compute_power_factor(session.player.my_home.get_power_state()), None)
                retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])
                session.player.send_history_update(retmsg)

            elif spellname == "MAKE_DROIDS":
                if object not in session.player.home_base_iter():
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                self.do_make_droids(session, retmsg, object, spellargs)

            elif spellname == "CANCEL_MAKE_DROIDS":
                if object not in session.player.home_base_iter():
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                self.do_cancel_make_droids(session, retmsg, object, spellargs)

            elif spellname == "BUILD":
                self.do_build(session, retmsg, spellargs, False)

            elif spellname == "DEPLOY_UNITS":
                self.do_attack(session, retmsg, spellargs)

            elif spellname == "INSTANT_ATTACK":
                if not session.player.is_cheater:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    return session.start_async_request(self.instant_attack(session, retmsg, spellargs))

            elif spellname == "CONFIG_SET":
                if (not object.is_building()) or (object.owner is not session.player):
                    retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
                    return

                if object not in session.player.home_base_iter() and not object.spec.quarry_upgradable:
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return

                config = spellargs[0]
                if config is not None:
                    assert type(config) is dict
                    # sanity-check to prevent DDOS
                    if len(config) > gamedata['server'].get('max_object_config_settings', 10):
                        gamesite.exception_log.event(server_time, 'Received CONFIG_SET with config length > 10: %r' % config)
                    assert len(config) <= gamedata['server'].get('max_object_config_settings', 10)
                    for key, val in config.iteritems():
                        assert type(key) in (str, unicode)
                        assert type(val) in (int, str, unicode, list, dict)
                        if type(val) in (str, unicode): assert len(val) <= gamedata['server'].get('max_object_config_string', 64)
                        if type(val) is list:
                            if len(val) > gamedata['server'].get('max_object_config_settings', 10):
                                gamesite.exception_log.event(server_time, 'Received CONFIG_SET with val length > 10: %r' % val)
                            assert len(val) <= gamedata['server'].get('max_object_config_settings', 10)
                            for item in val:
                                assert (type(item) in (str, unicode) or (item is None))
                                if type(item) in (str, unicode): assert len(item) <= gamedata['server'].get('max_object_config_string', 64)
                        if type(val) is dict:
                            if len(val) > gamedata['server'].get('max_object_config_settings', 10):
                                gamesite.exception_log.event(server_time, 'Received CONFIG_SET with val length > 10: %r' % val)
                            assert len(val) <= gamedata['server'].get('max_object_config_settings', 10)
                            for subkey in val:
                                item = val[subkey]
                                assert (type(item) in (str, unicode, int) or (item is None))
                                if type(item) in (str, unicode): assert len(item) <= gamedata['server'].get('max_object_config_string', 64)
                object.config = copy.deepcopy(config)
                retmsg.append(["OBJECT_STATE_UPDATE2", object.serialize_state()])
                session.viewing_base.nosql_write_one(object, 'CONFIG_SET', fields = ['config'])

            elif spellname == "MOVE_BUILDING":
                self.do_move_building(session, retmsg, object, spellargs)

            elif spellname == "LOTTERY_GET_SLATE":
                session.player.reseed_lottery(session, force = False)
                result = session.player.get_lottery_slate(session)
                retmsg.append(["LOTTERY_GET_SLATE_RESULT", result])

            elif spellname == "LOTTERY_SCAN":
                source = spellargs[0]
                assert source in ('cooldown','contents','aura') # cannot use "paid" here!
                if (session.viewing_base is not session.player.my_home) or (object.owner is not session.player):
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                self.do_lottery_scan(session, retmsg, object, spellname, source)

            elif spellname == "FISH_SLATE_ASSIGN":
                if 'assign_fish_slate' not in gamedata['consequent_library']:
                    retmsg.append(["ERROR", "SERVER_PROTOCOL"])
                    return
                if not session.player.cooldown_active('fish_slate_assigned'):
                    session.execute_consequent_safe(session.player.get_abtest_consequent('assign_fish_slate'), session.player, retmsg, reason=spellname)

            elif spellname == "HITLIST_ASSIGN":
                if not session.player.get_any_abtest_value('enable_hitlist', gamedata.get('enable_hitlist',False)) or \
                   ('assign_hitlist' not in gamedata['consequent_library']):
                    retmsg.append(["ERROR", "SERVER_PROTOCOL"])
                    return
                if not session.player.cooldown_active('hitlist_assigned'):
                    session.execute_consequent_safe(session.player.get_abtest_consequent('assign_hitlist'), session.player, retmsg, reason=spellname)

                # XXXXXX temporary
                if 'assign_skill_challenges' in gamedata['consequent_library'] and (not session.player.cooldown_active('skill_challenges_assigned')):
                    session.execute_consequent_safe(session.player.get_abtest_consequent('assign_skill_challenges'), session.player, retmsg, reason=spellname)

            elif spellname == "MIGRATE_TURRET_HEADS":
                spell = session.player.get_abtest_spell(spellname); assert spell
                for PRED in ('requires','show_if'):
                    if (PRED in spell) and (not Predicates.read_predicate(spell[PRED]).is_satisfied2(session, session.player, None)):
                        retmsg.append(["ERROR", "SERVER_PROTOCOL"])
                        return
                session.execute_consequent_safe(spell['consequent'], session.player, retmsg, reason=spellname)

            elif spellname == "CHEAT_REMOVE_LIMITS":
                if spin_secure_mode or (not session.player.is_developer()):
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    session.player.is_cheater = bool(spellargs[0])
            elif spellname == "CHEAT_CLEAR_COOLDOWNS":
                if not session.player.is_cheater:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    session.player.cooldowns = {}
                    retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])
            elif spellname == "CHEAT_CLEAR_PLAYER_AURAS":
                if not session.player.is_cheater:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    session.player.player_auras = []
                    session.player.player_auras_recently_expired = []
                    session.deferred_player_auras_update = True
                    session.deferred_stattab_update = True
            elif spellname == "CHEAT_GIVE_GAMEBUCKS":
                if not session.player.is_cheater:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    session.player.resources.gain_gamebucks(spellargs[0], reason=spellname)
                    retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])
            elif spellname == "CHEAT_DRAIN_RESOURCES":
                if not session.player.is_cheater:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    for res in gamedata['resources']:
                        setattr(session.player.resources, res, 0)
                    session.player.resources.gamebucks = 0
                    session.deferred_player_state_update = True
                    scores_to_modify = {}
                    if session.player.ladder_points() != 0:
                        scores_to_modify['trophies_pvp'] = 0
                    if session.player.trophies_pvv() != 0:
                        scores_to_modify['trophies_pvv'] = 0
                    if scores_to_modify:
                        if session.player.modify_scores(scores_to_modify, method = '=', reason = spellname):
                            session.deferred_player_trophies_update = True
            elif spellname == "CHEAT_GET_DONATED_UNITS":
                if not session.player.is_cheater:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    session.player.donated_units = {}
                    for specname in gamedata['units'].iterkeys():
                        for i in xrange(4):
                            session.player.add_donated_unit(specname)
                    retmsg.append(["DONATED_UNITS_UPDATE", session.player.donated_units])
            elif spellname == "CHEAT_EXECUTE_CONSEQUENT":
                if not session.player.is_cheater:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    session.execute_consequent_safe(spellargs[0], session.player, retmsg, reason='CHEAT_EXECUTE_CONSEQUENT')
            elif spellname == "CHEAT_GIVE_GIFTS":
                if not session.player.is_cheater:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    for i in xrange(5):
                        gamesite.msg_client.msg_send([{'from': session.player.user_id + i,
                                                       'to': [session.player.user_id],
                                                       'type': 'resource_gift',
                                                       'msg_id': generate_mail_id(),
                                                       'expire_time': server_time + gamedata['server']['message_expire_time']['resource_gift'],
                                                       'from_pcache': self.get_player_cache_props(session.user, session.player, session.alliance_id_cache),
                                                       'unique_per_sender': 'resource_gift'}])
                    mail_stat = self.do_receive_mail(session, retmsg)
                    if mail_stat and mail_stat['new_mail']:
                        session.player.send_mailbox_update(retmsg)

            elif spellname == "CHEAT_GIVE_ITEMS":
                if not session.player.is_cheater:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                    return

                attachments = []

                if len(spellargs) > 0:
                    # give a list of items, even if just a single one was passed
                    if type(spellargs[0]) is not list:
                        item_list = [spellargs[0]]
                    else:
                        item_list = spellargs[0]

                    for item in item_list:
                        # strings: interpret as item or loot table name
                        if type(item) in (str,unicode):
                            if item in gamedata['items']:
                                spec = gamedata['items'][item]
                                attachments.append({'spec': item, 'stack': spec.get('max_stack',1)})
                            elif item in gamedata['loot_tables']:
                                attachments += session.get_loot_items(session.player, gamedata['loot_tables'][item]['loot'], -1, -1)
                            else:
                                pass # unrecognized

                        elif type(item) is dict:
                            # dict: interpret as item object
                            if item['spec'] in gamedata['items']:
                                spec = gamedata['items'][item['spec']]
                                level = min(item.get('level',1), spec.get('max_level',1))
                                stack = item.get('stack',1)
                                at = {'spec':spellargs[0]['spec']}
                                if level > 1:
                                    at['level'] = level
                                if stack > 1:
                                    at['stack'] = stack
                                if 'expire_time' in item:
                                    at['expire_time'] = item['expire_time']
                                attachments.append(at)
                            else:
                                pass # unrecognized
                else:
                    n_attachments = 9 if random.random() > 0.25 else 1
                    possible_items = gamedata['items'].keys()
                    for n in xrange(n_attachments):
                        choice = int(len(possible_items)*random.random())
                        spec_name = possible_items[choice]
                        spec = gamedata['items'][spec_name]
                        stack = 1
                        if 'fungible' in spec:
                            stack = int(30000*random.random())
                        elif 'max_stack' in spec:
                            stack = spec['max_stack'] # int((spec['max_stack']+1)*random.random())
                        item = {'spec':spec_name}
                        if stack > 1:
                            item['stack'] = stack
                        attachments.append(item)

                if attachments:
                    if session.player.get_any_abtest_value('modal_looting', gamedata['modal_looting']) and \
                       session.player.find_object_by_type(gamedata['inventory_building']):
                        session.player.loot_buffer += attachments
                        retmsg.append(["LOOT_BUFFER_UPDATE", session.player.loot_buffer, False])
                    else:
                        session.player.mailbox_append({'type':'mail',
                                                       'expire_time': server_time + 60*60,
                                                       'msg_id': generate_mail_id(),
                                                       'from_name': 'Valentina',
                                                       'subject': 'Test Message',
                                                       'body': "Greetings Commander,\n\nMessages let you receive communications and special items as \"attachments\".\n\nHere's a bonus item to try.",
                                                       'attachments': attachments})
                        session.player.send_mailbox_update(retmsg)

                    #session.player.send_history_update(retmsg)

            elif spellname == "CHEAT_MODIFY_ABTESTS":
                if spin_secure_mode or (not session.player.is_developer()):
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                    return
                data = spellargs[0]
                for name, group in data.iteritems():
                    assert name in gamedata['abtests']
                    if group is None and (name in session.player.abtests):
                        del session.player.abtests[name]
                    else:
                        assert group in gamedata['abtests'][name]['groups']
                        session.player.abtests[name] = group

                # really the user needs to be kicked and relogged
                return self.log_out_async(session, spellname)

            elif spellname == "CHEAT_RESET_GAME":
                if spin_secure_mode:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    if session.player.is_on_map():
                        gamesite.nosql_client.drop_map_feature(session.player.my_home.base_region, session.player.my_home.base_id, reason='reset_game')
                        session.player.my_home.base_region = session.player.home_region = session.player.my_home.base_map_loc = None
                        session.player.history['map_placement_gen'] = -1
                    session.player.reset()
                    init_game(session.player, 0)
                    session.player.history['sessions'] = [[server_time,-1],]
                    session.player.history['last_raw_sessions'] = []
                    session.player.creation_time = session.user.account_creation_time = server_time
                    retmsg.append(["ABTEST_UPDATE", session.player.abtests])

                    # have to reset the tutorial before changing sessions, so that client will apply special AI states correctly
                    retmsg.append(["TUTORIAL_STATE_UPDATE", session.player.tutorial_state])

                    d = self.change_session(session, retmsg, dest_user_id = session.user.user_id, force = True)

                    def after_session_change(self, session, retmsg, change_session_result):
                        spawn_tutorial_units(session, retmsg)
                        session.player.send_history_update(retmsg)
                        retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])
                        retmsg.append(["TECH_UPDATE", session.player.tech])
                        retmsg.append(["QUEST_STATE_UPDATE", session.player.completed_quests])

                    d.addCallback(functools.partial(after_session_change, self, session, retmsg))
                    return d # async

            elif spellname == "CHEAT_SPAWN_UNITS":
                if not session.player.is_cheater:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    self.execute_spell(session, retmsg, "GIVE_UNITS_LIMIT_BREAK", spellargs[0])

            elif spellname == "CHEAT_MODIFY_SCORE":
                if not session.player.is_cheater:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    stat_name, stat_method, stat_delta = spellargs[0:3]
                    if session.player.modify_scores({stat_name: stat_delta}, method = stat_method, reason = spellname):
                        session.deferred_player_trophies_update = True

            elif spellname == "LOAD_AI_BASE":
                if spin_secure_mode or not session.home_base:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    success = True
                    error_msg = None
                    base_id = spellargs[0]
                    filename = str(base_id)

                    session.player.is_cheater = True # needed so that we can safely break unit space limits etc

                    try:
                        filename = ai_base_source_file(base_id)
                        base = SpinConfig.load(filename, stripped = True)
                        if 'units' in base and len(base['units']) > 0 and ('direction' in base['units'][0]):
                            raise Exception('%s is an AI attack, not an AI base.' % filename)

                        session.player.unit_repair_queue = []
                        session.player.tech = base.get('tech',{})
                        session.player.unit_equipment = base.get('unit_equipment',{})
                        session.player.my_home = Base(None, home_base_id(session.user.user_id), session.user.user_id, 'home')
                        session.player.my_home.base_region = session.player.home_region
                        if 'base_climate' in base: session.player.my_home.base_climate = base['base_climate']
                        if 'base_ncells' in base: session.player.my_home.base_ncells = base['base_ncells']
                        if 'deployment_buffer' in base: session.player.my_home.deployment_buffer = base['deployment_buffer']
                        # note: deployment_allowed is NOT loaded here. We assume the base header will include it.

                        for data in base.get('buildings',[]):
                            spec = data['spec']
                            if ('quarr' in filename or 'strongpoint' in filename) and \
                               spec == '%RESOURCE_harvester': # for quarries
                                spec = gamedata['resources']['iron']['harvester_building']
                            obj = instantiate_object_for_player(session.player, session.player, spec, x=data['xy'][0], y=data['xy'][1],
                                                                level = data.get('force_level', data.get('level',1)))
                            if 'force_level' in data: obj.force_ai_level = data['force_level']
                            if 'force_team' in data: obj.force_team = data['force_team']
                            if 'equipment' in data: obj.equipment = data['equipment']
                            if 'enhancements' in data: obj.enhancements = data['enhancements']
                            if 'behaviors' in data: obj.behaviors = data['behaviors']
                            session.player.home_base_add(obj)
                        for data in base.get('units',[]):
                            obj = instantiate_object_for_player(session.player, session.player, data['spec'], x=data['xy'][0], y=data['xy'][1],
                                                                level = data.get('force_level', data.get('level',1)))
                            if 'force_level' in data: obj.force_ai_level = data['force_level']
                            if 'force_team' in data: obj.force_team = data['force_team']
                            if 'equipment' in data: obj.equipment = data['equipment']
                            if 'orders' in data: obj.orders = data['orders']
                            if 'patrol' in data: obj.patrol = data['patrol']
                            if 'pack_id' in data: obj.pack_id = data['pack_id']
                            if 'behaviors' in data: obj.behaviors = data['behaviors']
                            if 'temporary' in data: obj.temporary = data['temporary']
                            session.player.home_base_add(obj)
                        for data in base.get('scenery',[]):
                            obj = instantiate_object_for_player(session.player, EnvironmentOwner, data['spec'], x=data['xy'][0], y=data['xy'][1])
                            session.player.home_base_add(obj)

                        session.player.ping_squads_and_send_update(session, retmsg, originator = session.player.user_id, reason = 'load_ai_base')
                        d = self.change_session(session, retmsg, dest_user_id = session.user.user_id, force = True)

                        def after_session_change(self, session, retmsg, filename, change_session_result):
                            retmsg.append(["LOAD_AI_BASE_RESULT", True, None, filename])

                        d.addCallback(functools.partial(after_session_change, self, session, retmsg, filename))
                        return d # async

                    except:
                        error_msg = traceback.format_exc().strip() # OK
                        success = False

                    retmsg.append(["LOAD_AI_BASE_RESULT", success, "LOAD_AI_BASE_ERROR" if (not success) else None, error_msg if (not success) else filename])

            elif spellname == "SAVE_AI_BASE":
                if spin_secure_mode or not session.home_base:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    success = True
                    error_msg = None
                    base_id = spellargs[0]
                    filename = str(base_id)

                    try:
                        filename = ai_base_source_file(base_id)
                        out = {'deployment_buffer': session.player.my_home.deployment_buffer,
                               'tech': session.player.tech,
                               'unit_equipment': session.player.unit_equipment,
                               'buildings': [], 'units': [], 'scenery': []}

                        # only write base_climate if it differs from the default
                        if session.player.my_home.base_climate != gamedata.get('default_climate', None):
                            out['base_climate'] = session.player.my_home.base_climate

                        # force an explicit ncells value
                        out['base_ncells'] = session.player.my_home.base_ncells or gamedata['map']['default_ncells']

                        # deployment_allowed is NOT stored - we expect this to be in the base header

                        for obj in session.player.home_base_iter():
                            if obj.is_building():
                                spec = obj.spec.name
                                if ('quarr' in filename or 'strongpoint' in filename) \
                                   and spec in [x['harvester_building'] for x in gamedata['resources'].itervalues()]:
                                    spec = '%RESOURCE_harvester'
                                props = {'spec':spec, 'xy': [obj.x,obj.y],
                                         'force_level': obj.level }
                                if obj.force_team: props['force_team'] = obj.force_team
                                if obj.equipment: props['equipment'] = obj.equipment
                                if obj.enhancements: props['enhancements'] = obj.enhancements
                                if obj.behaviors: props['behaviors'] = obj.behaviors
                                out['buildings'].append(props)
                            elif obj.is_mobile():
                                if obj.is_temporary(): continue # don't save these
                                props = {'spec': obj.spec.name, 'xy': [obj.x, obj.y] }
                                if obj.force_team: props['force_team'] = obj.force_team
                                if obj.equipment: props['equipment'] = obj.equipment
                                if obj.behaviors: props['behaviors'] = obj.behaviors
                                if obj.orders: props['orders'] = obj.orders
                                if obj.patrol: props['patrol'] = obj.patrol
                                if obj.pack_id: props['pack_id'] = obj.pack_id
                                if obj.force_ai_level is not None: props['force_level'] = obj.force_ai_level
                                out['units'].append(props)
                            elif obj.owner is EnvironmentOwner:
                                props = {'spec': obj.spec.name, 'xy': [obj.x, obj.y] }
                                out['scenery'].append(props)

                        atom = AtomicFileWrite.AtomicFileWrite(filename, 'w') # DANGEROUS - can overwrite any file!
                        atom.fd.write(SpinJSON.dumps(out, pretty = True)[1:-1]+'\n') # note: get rid of surrounding {}
                        atom.complete()
                    except:
                        error_msg = traceback.format_exc().strip() # OK
                        success = False

                    retmsg.append(["SAVE_AI_BASE_RESULT", success, "SAVE_AI_BASE_ERROR" if (not success) else None, error_msg if (not success) else filename])
            elif spellname == "PUBLISH_AI_BASE":
                if spin_secure_mode or not session.home_base:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    success = True
                    error_msg = None
                    idnum = spellargs[0]
                    try:
                        if (type(idnum) is not int) or (str(idnum) not in gamedata['ai_bases_server']['bases']):
                            success = False
                            error_msg = "Invalid base ID %s" % idnum

                        if success:
                            cmdline = ['./make-gamedata.sh', '-u', '-n']
                            proc = subprocess.Popen(cmdline, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                            stdoutdata, stderrdata = proc.communicate()
                            if proc.returncode != 0:
                                success = False
                                error_msg = '%s failed - run this command in your terminal and check errors.' % cmdline[0]
                                error_msg += '\nLog:\n'+ stderrdata + '\n' + stdoutdata

                        if success:
                            # HUP proxyserver
                            os.kill(int(open('proxyserver.pid').read().strip()), signal.SIGHUP)

                            # remove any partially-damaged aistate versions of this base
                            for file in glob.glob(os.path.join(SpinConfig.config.get('aistate_dir', 'aistate'), '*_%d.txt' % (idnum))):
                                os.unlink(file)

                        if success:
                            reload_gamedata()
                            setup_next_ai_base([str(idnum),])

                    except:
                        error_msg = traceback.format_exc().strip() # OK
                        success = False

                    retmsg.append(["PUBLISH_AI_BASE_RESULT", success, "PUBLISH_AI_BASE_ERROR" if (not success) else None, error_msg if (not success) else str(idnum)])

            elif spellname == "SET_FORCE_TEAM":
                if not session.player.is_cheater or not session.home_base or not object:
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                new_value = spellargs[0]
                assert (new_value is None) or (isinstance(new_value, basestring))
                object.force_team = new_value

            elif spellname == "CHEAT_AI_ATTACK":
                if (not session.player.is_developer()):
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    session.start_ai_attack(retmsg, spellargs[0] if spellargs else 'daily', override_protection = True)

            elif spellname == "TUTORIAL_AI_ATTACK":
                if session.player.tutorial_state == "COMPLETE":
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                else:
                    session.start_ai_attack(retmsg, 'tutorial')

            elif spellname == "CHAT_GAG" or spellname == "CHAT_UNGAG":
                if not session.user.is_chat_mod():
                    retmsg.append(["ERROR", "DISALLOWED_IN_SECURE_MODE"])
                    return
                target_id = spellargs[0]

                # fire an asynchronous request to proxyserver, who
                # will then route it to whatever game server is
                # handling the player, or a random server to do an
                # offline mutation.
                d = gamesite.do_CONTROLAPI(session.user.user_id, {'method': spellname.lower(), 'user_id': target_id})
                def finish(response_or_error, retmsg, spellname, target_id):
                    retmsg.append([spellname+"_RESULT", target_id, True])

                d.addErrback(report_and_absorb_deferred_failure, session)
                d.addCallback(finish, retmsg, spellname, target_id)

                return session.start_async_request(d) # go async

            elif spellname == "ALLIANCE_CREATE" or spellname == "ALLIANCE_MODIFY":
                props = spellargs[0]
                success = True
                new_id = -1

                # unwrap strings
                props['ui_name'] = SpinHTTP.unwrap_string(props['ui_name_enc']); del props['ui_name_enc']
                props['chat_tag'] = SpinHTTP.unwrap_string(props['chat_tag_enc']); del props['chat_tag_enc']
                props['ui_descr'] = SpinHTTP.unwrap_string(props['ui_descr_enc']); del props['ui_descr_enc']
                props['chat_motd'] = SpinHTTP.unwrap_string(props['chat_motd_enc']); del props['chat_motd_enc']

                if (not session.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) or \
                   (not gamesite.sql_client):
                    retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])
                    success = False

                if spellname == "ALLIANCE_CREATE" and (not Predicates.read_predicate({'predicate':'LIBRARY','name':'alliance_create_requirement'}).is_satisfied2(session, session.player, None)):
                    retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED"])
                    success = False

                if success and (spellname == "ALLIANCE_CREATE"):
                    # check for async notifications
                    self.do_receive_mail(session, retmsg, type_filter = ['cooldown_trigger'])
                    spell = gamedata['spells']['ALLIANCE_LEAVE']
                    if spell.get('cooldown',-1) > 0 and session.player.cooldown_active(spell['cooldown_name']):
                        retmsg.append(["ERROR", "CANNOT_CREATE_ALLIANCE_ON_COOLDOWN"])
                        success = False


                spell = gamedata['spells'][spellname]
                cost = spell['price']
                for res in cost:
                    if (getattr(session.player.resources,res) < cost[res]):
                        retmsg.append(["ERROR", "INSUFFICIENT_"+res.upper(), cost[res]])
                        success = False

                # sanitize parameters
                props['ui_name'] = props['ui_name'][:64].strip()
                props['chat_tag'] = props['chat_tag'][:3].strip().upper()
                props['ui_descr'] = props['ui_descr'][:256].strip()
                props['logo'] = props['logo'][:32].strip()
                props['chat_motd'] = props['chat_motd'][:256].strip()

                if not is_valid_alliance_name(props['ui_name']):
                    retmsg.append(["ERROR", "CANNOT_CREATE_ALLIANCE_NAME_BAD"])
                    success = False
                elif not is_valid_alliance_tag(props['chat_tag']):
                    retmsg.append(["ERROR", "CANNOT_CREATE_ALLIANCE_TAG_BAD"])
                    success = False
                elif not is_valid_alliance_descr(props['ui_descr']):
                    retmsg.append(["ERROR", "CANNOT_CREATE_ALLIANCE_DESCR_BAD"])
                    success = False

                elif not is_valid_alliance_descr(props['chat_motd']):
                    retmsg.append(["ERROR", "CANNOT_CREATE_ALLIANCE_CHAT_MOTD_BAD"])
                    success = False

                assert str(props['join_type']) in ('anyone', 'invite_only')

                if success:
                    cur_id = session.get_alliance_id()

                    if spellname == "ALLIANCE_CREATE" and cur_id > 0:
                        # make sure player is not currently in an alliance
                        success = False

                if success:
                    if spellname == "ALLIANCE_MODIFY":
                        success, err_reason = gamesite.sql_client.modify_alliance(cur_id, session.user.user_id, ui_name = props['ui_name'], ui_description = props['ui_descr'],
                                                                                  join_type = props['join_type'], logo = props['logo'],
                                                                                  chat_motd = props['chat_motd'], chat_tag = props['chat_tag'],
                                                                                  reason = 'ALLIANCE_MODIFY')
                        if success:
                            # take resources
                            negative_cost = dict((res,-cost[res]) for res in cost)
                            session.player.resources.gain_res(negative_cost, reason='alliance_modification')
                            admin_stats.econ_flow_player(session.player, 'investment', 'alliance_modification', negative_cost)
                            retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])
                            new_info, new_membership = session.init_alliance(retmsg, reason='ALLIANCE_MODIFY')
                            assert new_info
                            retmsg.append(["ALLIANCE_UPDATE", new_info['id'], False, new_info, new_membership, False])
                        else:
                            retmsg.append(["ERROR", err_reason])

                    else:
                        new_id, err_reason = gamesite.sql_client.create_alliance(props['ui_name'], props['ui_descr'], props['join_type'], session.user.user_id, props['logo'], server_time, session.player.home_continent(), chat_motd = props['chat_motd'], chat_tag = props['chat_tag'], reason='ALLIANCE_CREATE')
                        if new_id > 0:
                            try:
                                session.increment_player_metric('alliances_created', 1, time_series = False)

                                # send invite
                                if props['join_type'] == 'invite_only':
                                    assert gamesite.sql_client.send_alliance_invite(session.user.user_id, session.user.user_id, new_id,
                                                                                    server_time, server_time + gamedata['alliances']['invite_duration'],
                                                                                    force = True,
                                                                                    reason='ALLIANCE_CREATE')

                                # join
                                assert gamesite.sql_client.join_alliance(session.user.user_id, new_id, server_time, gamedata['alliances']['max_members'], role=gamesite.sql_client.ROLE_LEADER, force=True, reason='ALLIANCE_CREATE')[0]

                                # verify that join worked, and set up chat
                                new_info, new_membership = session.init_alliance(retmsg, reason='ALLIANCE_CREATE')
                                assert new_info and new_info['id'] == new_id

                                retmsg.append(["ALLIANCE_UPDATE", new_info['id'], False, new_info, new_membership, False])
                                if session.player.history.get('alliances_joined',0) < 1:
                                    session.player.history['alliance_first_join_time'] = server_time
                                    session.player.history['alliance_first_join_created'] = 1
                                session.increment_player_metric('alliances_joined', 1, time_series = False)
                                session.deferred_history_update = True

                                metric_event_coded(session.user.user_id, '4610_alliance_member_joined', {'alliance_id': new_id, 'role': gamesite.sql_client.ROLE_LEADER,
                                                                                                         'sum':session.player.get_denormalized_summary_props('brief')})

                                session.player.update_alliance_score_cache(new_id, alliance_info = new_info, reason='ALLIANCE_CREATE')
                                gamesite.pcache_client.player_cache_update(session.player.user_id, {'alliance_id': new_id}, reason = 'ALLIANCE_CREATE')

                            finally:
                                # take resources
                                negative_cost = dict((res,-cost[res]) for res in cost)
                                session.player.resources.gain_res(negative_cost, reason='alliance_creation')
                                admin_stats.econ_flow_player(session.player, 'investment', 'alliance_creation', negative_cost)
                                retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])
                        else:
                            success = False
                            retmsg.append(["ERROR", err_reason])

                if success:
                    metric_event_coded(session.user.user_id, '4601_alliance_settings_updated' if spellname == "ALLIANCE_MODIFY" else '4600_alliance_created',
                                       {'alliance_id': new_id if spellname == "ALLIANCE_CREATE" else cur_id,
                                        'sum':session.player.get_denormalized_summary_props('brief'),
                                        'chat_tag': props['chat_tag'],
                                        'ui_name': props['ui_name'],
                                        'num_members_cache': 1 if spellname == "ALLIANCE_CREATE" else None,
                                        'ui_description': props['ui_descr'],
                                        'logo': props['logo'],
                                        'continent': session.player.home_continent() if spellname == "ALLIANCE_CREATE" else None,
                                        'join_type': props['join_type'],
                                        'chat_motd': props['chat_motd']
                                        })

                retmsg.append([spellname+"_RESULT", props, new_id])

            # SQUADS

            elif spellname == 'SQUAD_CREATE':
                if session.player.squad_bay_is_busy():
                    retmsg.append(["ERROR", "SQUAD_BAY_IS_BUSY"])
                    return

                ui_name = spellargs[0][:64].strip()
                success = True

                # subtract 1 for Base Defenders which doesn't count against the squad limit
                if len(session.player.squads)-1 >= session.player.stattab.max_squads:
                    retmsg.append(["ERROR", "CANNOT_CREATE_SQUAD_LIMIT_REACHED"])
                    success = False
                if success:
                    new_id = max([x['id'] for x in session.player.squads.itervalues()]+[0,]) + 1
                    session.player.squads[str(new_id)] = {'id':new_id, 'ui_name': ui_name}
                    if session.increment_player_metric('squads_created', 1, time_series = False):
                        session.deferred_history_update = True

                retmsg.append(["SQUADS_UPDATE", session.player.squads])

            elif spellname == 'SQUAD_RENAME':
                squad_id = int(spellargs[0])
                ui_name = SpinHTTP.unwrap_string(spellargs[1])[:24].strip()
                if not ui_name: return
                if SQUAD_IDS.is_mobile_squad_id(squad_id) and str(squad_id) in session.player.squads:
                    session.player.squads[str(squad_id)]['ui_name'] = ui_name
                    if session.player.squad_is_deployed(squad_id) and gamesite.nosql_client:
                        gamesite.nosql_client.update_map_feature(session.player.home_region, session.player.squad_base_id(squad_id), {'base_ui_name':ui_name}, originator=session.player.user_id, reason='SQUAD_RENAME')
                retmsg.append(["SQUADS_UPDATE", session.player.squads])

            elif spellname == 'SQUAD_DELETE':
                squad_id = int(spellargs[0])
                if not SQUAD_IDS.is_mobile_squad_id(squad_id):
                    gamesite.exception_log.event(server_time, 'SQUAD_DELETE of non-mobile squad_id %r' % squad_id)
                    retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
                    return
                if session.has_attacked:
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_IN_COMBAT"])
                    return
                squad = session.player.verify_squad(squad_id)
                if False and session.player.squad_is_under_repair(squad_id):
                    retmsg.append(["ERROR", "CANNOT_ALTER_SQUAD_UNDER_REPAIR"])
                    return

                if squad:
                    # reassign units to reserves
                    for object in session.player.home_base_iter():
                        if object.is_mobile() and object.squad_id == squad_id:
                            object.squad_id = SQUAD_IDS.RESERVES
                            session.player.unit_repair_cancel(object)
                            session.player.send_army_update_one(object, retmsg)
                    del session.player.squads[str(squad_id)]
                    session.player.unit_repair_send(retmsg)
                else:
                    retmsg.append(["ERROR", "CANNOT_ALTER_SQUAD_WHILE_TRAVELING"])
                retmsg.append(["SQUADS_UPDATE", session.player.squads])

            elif spellname == 'SQUAD_UNASSIGN_UNIT':
                squad_id = int(spellargs[0])
                object_id = spellargs[1]

                if not session.home_base:
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                if session.has_attacked:
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_IN_COMBAT"])
                    return
                if squad_id != SQUAD_IDS.BASE_DEFENDERS and session.player.squad_bay_is_busy():
                    retmsg.append(["ERROR", "SQUAD_BAY_IS_BUSY"])
                    return

                squad = session.player.verify_squad(squad_id)
                object = session.player.get_object_by_obj_id(object_id, fail_missing = False)
                if (not object) or (not object.is_mobile()) or (object.owner is not session.player) or ((object.squad_id or 0) != squad_id) or (not squad) or (session.player.squad_is_under_repair(squad_id)):
                    if object: session.player.send_army_update_one(object, retmsg)
                    retmsg.append(["ERROR", "CANNOT_ALTER_SQUAD_UNDER_REPAIR" if session.player.squad_is_under_repair(squad_id) else "HARMLESS_RACE_CONDITION"])
                    return
                session.player.unit_repair_cancel(object)

                object.squad_id = SQUAD_IDS.RESERVES # return to reserves
                session.player.send_army_update_one(object, retmsg)

                if True: # players shouldn't expect that squad units maintain orders after moving between squads
                    # clear movement orders
                    object.reset_as_squad_unit(session.player.my_home.ncells())

                if session.home_base and (squad_id == SQUAD_IDS.BASE_DEFENDERS):
                    # removed from base defenders at home base - remove from session
                    if session.has_object(object.obj_id):
                        # this should always be the case, but might be racy?
                        session.rem_object(object.obj_id)
                        retmsg.append(["OBJECT_REMOVED2", object.obj_id])

            elif spellname == 'SQUAD_ASSIGN_UNIT':
                squad_id = int(spellargs[0])
                object_id = spellargs[1]

                if not session.home_base:
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                if session.has_attacked:
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_IN_COMBAT"])
                    return
                if squad_id != SQUAD_IDS.BASE_DEFENDERS and session.player.squad_bay_is_busy():
                    retmsg.append(["ERROR", "SQUAD_BAY_IS_BUSY"])
                    return

                squad = session.player.verify_squad(squad_id)
                object = session.player.get_object_by_obj_id(object_id, fail_missing = False)
                if (not object) or (not object.is_mobile()) or (object.owner is not session.player) or (object.squad_id != SQUAD_IDS.RESERVES) or (not squad) or (session.player.squad_is_under_repair(squad_id)):
                    if object: session.player.send_army_update_one(object, retmsg)
                    retmsg.append(["ERROR", "CANNOT_ALTER_SQUAD_UNDER_REPAIR" if session.player.squad_is_under_repair(squad_id) else "HARMLESS_RACE_CONDITION"])
                    return
                # see if the squad has room
                # note: since squad is at home base, all squad objects will be in home_base_iter, so we don't have to query the map
                # XXX this doesn't work for base_defenders if produce_to_reserves is off, it needs to add manuf_queue space!
                space = sum([x.get_leveled_quantity(x.spec.consumes_space) for x in session.player.home_base_iter() \
                             if x.is_mobile() and x.squad_id == squad_id],0)
                if squad_id == SQUAD_IDS.BASE_DEFENDERS:
                    space_limit = session.player.stattab.main_squad_space
                else:
                    space_limit = session.player.stattab.squad_space
                if space + object.get_leveled_quantity(object.spec.consumes_space) > space_limit:
                    retmsg.append(["ERROR", "CANNOT_SQUAD_ASSIGN_UNIT_LIMIT_REACHED"])
                else:
                    session.player.unit_repair_cancel(object)
                    object.squad_id = squad_id
                    if squad_id == SQUAD_IDS.BASE_DEFENDERS and session.home_base and gamedata.get('enable_defending_units',True):
                        # assigned to base defenders - add to session
                        session.add_object(object)
                        retmsg.append(["OBJECT_CREATED2", object.serialize_state()])
                        if object.auras:
                            retmsg.append(["OBJECT_AURAS_UPDATE", object.serialize_auras()])

                session.player.send_army_update_one(object, retmsg) # also send in failure case

            elif spellname == 'SQUAD_ENTER_MAP':
                if session.has_attacked:
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_IN_COMBAT"])
                    return
                squad_id = int(spellargs[0])
                coords = spellargs[1]
                raid_info = spellargs[2] # None for regular squads, {'path':[[x,y],...], 'mode':...} for raids
                is_raid = bool(raid_info)
                if is_raid:
                    assert raid_info['mode'] in ('pickup','attack','defend','scout','guard')
                    if not session.player.alliance_raids_enabled(): assert raid_info['mode'] != 'guard'
                    raid_mode = raid_info['mode']
                    raid_path = raid_info['path']
                else:
                    raid_mode = None
                success, map_features, error_code = session.player.squad_enter_map(session, squad_id, coords, raid_mode)
                if is_raid and (not error_code):
                    # raid squads: continue immediately with step
                    # (this is the only chance to step towards something other than home base)
                    step_success = True
                    try:
                        step_success, step_map_features, error_code = session.player.squad_step(session, squad_id, raid_path, raid_mode, bypass_cooldown = True)
                        map_features += step_map_features
                    finally:
                        if not step_success:
                            # dock it immediately
                            exit_success, exit_map_features, exit_error_code = session.player.squad_exit_map(session, squad_id, originator = session.player.user_id, force = True, reason='SQUAD_ENTER_MAP(raid failure)')
                            map_features += exit_map_features

                if error_code:
                    retmsg.append(["ERROR"] + error_code)
                if map_features: retmsg.append(["REGION_MAP_UPDATES", session.player.home_region, map_features, server_time])
                retmsg.append(["SQUADS_UPDATE", session.player.squads])

            elif spellname == 'SQUAD_STEP':
                squad_id = int(spellargs[0])
                coords = session.player.squad_path_sanitize(spellargs[1]) if spellargs[1] else None # may be null
                success, map_features, error_code = session.player.squad_step(session, squad_id, coords, False)
                if error_code: retmsg.append(["ERROR"] + error_code)
                if map_features: retmsg.append(["REGION_MAP_UPDATES", session.player.home_region, map_features, server_time])
                retmsg.append(["SQUADS_UPDATE", session.player.squads])

            elif spellname == 'SQUAD_STEP_MULTIPLE_CHOICE':
                squad_id = int(spellargs[0])
                path_choices = dict((k,session.player.squad_path_sanitize(v)) for k,v in spellargs[1].iteritems())
                success, map_features, error_code = session.player.squad_step(session, squad_id, None, False, path_choices = path_choices)
                if error_code: retmsg.append(["ERROR"] + error_code)
                if map_features: retmsg.append(["REGION_MAP_UPDATES", session.player.home_region, map_features, server_time])
                retmsg.append(["SQUADS_UPDATE", session.player.squads])

            elif spellname == 'SQUAD_RESOLVE':
                # this is just a hint that "hey, you should check this hex and resolve anything there"
                # all the action happens asynchronously
                loc = spellargs[0]
                assert session.player.home_region and session.player.raids_enabled()

                # check that the player actually has a stationary raid squad here
                if not any(squad_data.get('raid') and \
                           session.player.squad_is_deployed(int(squad_sid)) and \
                           (not session.player.squad_is_moving(int(squad_sid))) and \
                           squad_data.get('map_loc') == loc \
                           for squad_sid, squad_data in session.player.squads.iteritems()):
                    retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
                    return

                @admin_stats.measure_latency('do_squad_resolve')
                def do_squad_resolve(on_behalf_of_session, region_id, loc):
                    # query for squads and targets at this location
                    features = gamesite.nosql_client.get_map_features_by_loc(region_id, loc)
                    # filter out not-arrived-yet moving features (use strict time comparison)
                    features = filter(lambda feature: ('base_map_path' not in feature) or \
                                      feature['base_map_path'][-1]['eta'] < server_time, features)
                    raid_squads = filter(lambda feature: feature['base_type'] == 'squad' and feature.get('raid'), features)
                    if not raid_squads: return # no raids to process

                    lock_manager = SpinNoSQLLockManager.LockManager(gamesite.nosql_client) # adaptor for Raid.py

                    raid_targets = filter(lambda x: x['base_type'] == 'raid', features)
                    for targ in raid_targets:
                        Raid.resolve_target(gamedata, gamesite.nosql_client, gamesite.chat_mgr, lock_manager, region_id, targ, raid_squads, server_time)

                    home_targets = filter(lambda x: x['base_type'] == 'home', features)
                    for targ in home_targets:
                        d = gamesite.do_CONTROLAPI(on_behalf_of_session.user.user_id,
                                                   {'user_id': targ['base_landlord_id'], 'method':'resolve_home_raid',
                                                    'region_id': region_id, 'loc': SpinJSON.dumps(loc),
                                                    'squad_base_ids': SpinJSON.dumps([x['base_id'] for x in raid_squads])},
                                                   max_tries = 1)
                        #d.addCallback(lambda x: gamesite.exception_log.event(server_time, 'RESPONSE %r' % x))
                        d.addErrback(report_and_absorb_deferred_failure, on_behalf_of_session)

                reactor.callLater(0, do_squad_resolve, session, session.player.home_region, loc)

            elif spellname == 'SQUAD_EXIT_MAP':
                # not sure how much protection against concurrency is really needed here?
                if (not gamedata['territory'].get('enable_squad_control_away_from_home', False)) and \
                   session.has_attacked:
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_IN_COMBAT"])
                    return
                squad_id = int(spellargs[0])
                success, map_features, error_code = session.player.squad_exit_map(session, squad_id, originator = session.player.user_id, reason='SQUAD_EXIT_MAP')
                if error_code:
                    retmsg.append(["ERROR"] + error_code)
                if map_features: retmsg.append(["REGION_MAP_UPDATES", session.player.home_region, map_features, server_time])
                retmsg.append(["SQUADS_UPDATE", session.player.squads])

            elif spellname == 'SQUAD_REPAIR_CANCEL':
                if not session.home_base:
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                squad_id = int(spellargs[0])
                assert (SQUAD_IDS.is_mobile_squad_id(squad_id) or squad_id == SQUAD_IDS.BASE_DEFENDERS)
                squad = session.player.verify_squad(squad_id)
                if (not squad) or (not session.player.squad_is_under_repair(squad_id)):
                    retmsg.append(["ERROR", "HARMLESS_RACE_CONDITION"])
                    session.player.unit_repair_send(retmsg)
                else:
                    self.do_unit_repair_cancel_all(session, retmsg)
                retmsg.append(["SQUADS_UPDATE", session.player.squads]) # to unblock the GUI

            elif spellname == 'SQUAD_REPAIR_QUEUE':
                if not session.home_base:
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                    return
                if session.has_attacked:
                    retmsg.append(["ERROR", "CANNOT_CAST_SPELL_IN_COMBAT"])
                    return
                squad_id = int(spellargs[0])
                assert (SQUAD_IDS.is_mobile_squad_id(squad_id) or squad_id == SQUAD_IDS.BASE_DEFENDERS)
                squad = session.player.verify_squad(squad_id)

                to_repair = []
                errors = []
                cost = dict([(res,0) for res in gamedata['resources']])

                for obj in session.player.home_base_iter():
                    if obj.owner is session.player and obj.is_mobile() and ((obj.squad_id or 0) == squad_id) and obj.is_damaged():
                        if not session.player.can_repair_unit(obj):
                            errors.append(["REQUIREMENTS_NOT_SATISFIED", {'predicate':'TECH_LEVEL','tech':obj.spec.level_determined_by_tech,'min_level':1}])
                            continue
                        obj_cost = obj.cost_to_repair(session.player)
                        for res in gamedata['resources']:
                            cost[res] += obj_cost.get(res,0)
                        to_repair.append(obj)

                for res in cost:
                    if (getattr(session.player.resources,res) < cost[res]):
                        errors.append(["INSUFFICIENT_RESOURCES_TO_REPAIR", cost.copy(), squad_id])
                        break

                if errors:
                    retmsg += [["ERROR"]+x for x in errors]
                else:
                    self.do_unit_repair_cancel_all(session, retmsg)
                    assert len(session.player.unit_repair_queue) == 0
                    # order units by repair time, lowest to highest
                    to_repair.sort(key = lambda obj: obj.time_to_repair(session.player))
                    for obj in to_repair:
                        assert self.do_unit_repair_queue(session, obj.obj_id) is None

                session.player.unit_repair_send(retmsg)
                retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])
                retmsg.append(["SQUADS_UPDATE", session.player.squads]) # to unblock the GUI

            elif spellname == 'REQUEST_UNIT_DONATION':
                assert object and (spellname in object.spec.spells)

                success = True

                if session.player.cooldown_active(gamedata['spells'][spellname]['cooldown_name']):
                    retmsg.append(["ERROR", "ON_COOLDOWN"])
                    success = False

                if success:
                    if session.has_attacked or (object not in session.player.home_base_iter()):
                        retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                        success = False

                if success:
                    if (not session.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) or \
                       (not gamesite.sql_client) or (not session.alliance_chat_channel):
                        retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])
                        success = False

                if success:
                    if (not session.player.unit_donation_enabled()) or \
                       object.is_damaged() or object.is_busy():
                        retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED"])
                        success = False

                if success:
                    alliance_id = session.get_alliance_id()
                    if alliance_id <= 0:
                        retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED"])
                        success = False

                if success:
                    # tag we will use for the NEW request
                    tag = random.randrange(1<<31)

                    # in order to prevent race conditions, stop further donations from coming in, then check for any in-flight donations
                    # before calculating how much space we can request
                    if session.alliance_chat_channel:
                        session.do_chat_send(session.alliance_chat_channel,
                                             'Invalidate my unit donation request!',
                                             bypass_gag = True, props = {'type':'unit_donation_request_invalidation', 'new_tag': tag})
                    gamesite.sql_client.invalidate_unit_donation_request(session.player.user_id)
                    self.do_receive_mail(session, retmsg, type_filter = ['donated_units'])
                    cur_space = session.player.donated_units_space()
                    max_space = object.get_leveled_quantity(object.spec.provides_donated_space)
                    if cur_space >= max_space:
                        retmsg.append(["ERROR", "CANNOT_REQUEST_UNIT_DONATION_NO_SPACE"])
                        success = False

                if success:
                    region_id = session.player.home_region if gamedata.get('unit_donation_restrict_region', False) else None
                    if not gamesite.sql_client.request_unit_donation(session.player.user_id, alliance_id, server_time, tag, cur_space, max_space, region_id):
                        success = False

                if success:
                    session.player.cooldown_trigger(gamedata['spells'][spellname]['cooldown_name'], gamedata['spells'][spellname]['cooldown'])
                    if session.increment_player_metric('unit_donations_requested', 1, time_series = False):
                        session.deferred_history_update = True
                    metric_event_coded(session.player.user_id, '4140_unit_donation_requested',
                                       {'sum':session.player.get_denormalized_summary_props('brief'),
                                        'alliance_id':alliance_id,'tag':tag,
                                        'max_space':max_space,'cur_space':cur_space,'region_id': region_id})
                    if session.alliance_chat_channel:
                        session.do_chat_send(session.alliance_chat_channel,
                                             'I need units! (tag %d cur %d max %d region %r)' % (tag, cur_space, max_space, region_id),
                                             bypass_gag = True, props = {'type':'unit_donation_request', 'tag':tag, 'max_space':max_space, 'cur_space':cur_space, 'region_id': region_id})

                # send this regardless of success state
                retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])

            elif spellname == 'DONATE_UNITS':
                recipient_id = spellargs[0]
                tag = spellargs[1]
                unit_ids = spellargs[2]
                success = True
                error_reason = None

                assert object and (spellname in object.spec.spells)
                assert recipient_id != session.player.user_id

                if success:
                    if session.has_attacked or (object not in session.player.home_base_iter()):
                        error_reason = "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"
                        success = False

                if success:
                    if (not session.player.get_any_abtest_value('enable_alliances', gamedata['client']['enable_alliances'])) or \
                       (not gamesite.sql_client) or (not session.alliance_chat_channel):
                        error_reason = "ALLIANCES_OFFLINE"
                        success = False

                if success:
                    if (not session.player.unit_donation_enabled()):
                        error_reason = "CANNOT_DONATE_NOT_ENABLED"
                        success = False
                    elif object.is_damaged():
                        error_reason = "CANNOT_DONATE_BUILDING_DAMAGED"
                        success = False
                    elif object.is_busy():
                        success = False
                        if object.is_crafting():
                            error_reason = "CANNOT_DONATE_BUILDING_CRAFTING"
                        else:
                            error_reason = "CANNOT_DONATE_BUILDING_BUSY"

                if success:
                    alliance_id = session.get_alliance_id()
                    if alliance_id <= 0:
                        error_reason = "REQUIREMENTS_NOT_SATISFIED"
                        success = False

                units = []
                attachments = []

                if success:
                    # dictionary mapping (specname,level) -> qty donated
                    qty_by_specname_and_level = {}
                    for id in unit_ids:
                        unit = session.player.get_object_by_obj_id(id, fail_missing = False)
                        if (not unit) or (unit.owner is not session.player) or (not unit.is_mobile()) or \
                           (not unit.spec.donatable) or \
                           (unit.hp < unit.max_hp) or \
                           SQUAD_IDS.is_mobile_squad_id(unit.squad_id or 0) or \
                           (unit.get_leveled_quantity(unit.spec.consumes_space) > object.get_leveled_quantity(object.spec.max_individual_donation_space)):
                            success = False
                            error_reason = "HARMLESS_RACE_CONDITION"
                            break
                        units.append(unit) # mark this as a unit we'd delete if the donation succeeds
                        level = 1 # XXXXXX carry over level here?
                        key = (unit.spec.name, level)
                        qty_by_specname_and_level[key] = qty_by_specname_and_level.get(key,0) + 1

                    if len(qty_by_specname_and_level) < 1:
                        success = False # nothing to donate
                    else:
                        # compress to a single attachment by specname and level
                        for key, qty in qty_by_specname_and_level.iteritems():
                            specname, level = key
                            p = {'spec': specname}
                            if qty > 1: p['stack'] = qty
                            if level > 1: p['level'] = level
                            attachments.append(p)

                if success:
                    region_id = session.player.home_region if gamedata.get('unit_donation_restrict_region', False) else None

                    total_space = sum([u.get_leveled_quantity(u.spec.consumes_space) for u in units])
                    result = gamesite.sql_client.make_unit_donation(recipient_id, alliance_id, tag, [total_space], region_id)

                if success:
                    if result:
                        cur_space, max_space = result
                        gamesite.msg_client.msg_send([{'to':[recipient_id],
                                                       'type':'donated_units',
                                                       'attachments':attachments,
                                                       'from': session.player.user_id,
                                                       'from_fbid': session.user.facebook_id,
                                                       'from_name': session.user.get_chat_name(session.player)}])

                        for unit in units:
                            if session.has_object(unit.obj_id):
                                retmsg.append(["OBJECT_REMOVED2", unit.obj_id])
                                session.rem_object(unit.obj_id)
                            session.player.unit_repair_cancel(unit)
                            session.player.home_base_remove(unit)
                            session.player.send_army_update_destroyed(unit, retmsg) # may be redundant with OBJECT_REMOVED, but a player reported army desync here

                        num_donated = sum([item.get('stack',1) for item in attachments])

                        xp = max(1, int(total_space*gamedata['player_xp']['donate_units']))
                        cc = session.player.find_object_by_type(gamedata['townhall'])
                        self.give_xp_to(session, session.player, retmsg, xp, 'donate_units', [cc.x,cc.y] if cc else None, obj_session_id = cc.obj_id if cc else None)

                        session.increment_player_metric('units_donated', num_donated, time_series = False)
                        session.increment_player_metric('units_donated_cur_alliance', num_donated, time_series = False)
                        retmsg.append(["PLAYER_STATE_UPDATE", session.player.resources.calc_snapshot().serialize()])
                        session.player.send_history_update(retmsg)
                        session.activity_classifier.set_flag('alliance_unit_donation')
                        metric_event_coded(session.player.user_id, '4150_units_donated', {'sum':session.player.get_denormalized_summary_props('brief'),
                                                                                          'alliance_id':alliance_id,
                                                                                          'recipient_id':recipient_id,
                                                                                          'tag':tag,
                                                                                          'units':attachments})

                        if session.alliance_chat_channel:
                            session.do_chat_send(session.alliance_chat_channel,
                                                 'I donated units! (tag %d cur %d max %d)' % (tag, cur_space, max_space),
                                                 bypass_gag = True, props = {'type':'unit_donation',
                                                                             'recipient_id': recipient_id,
                                                                             'tag':tag, 'xp_gained': xp,
                                                                             'max_space':max_space, 'cur_space':cur_space})
                    else:
                        # space race condition
                        error_reason = "CANNOT_DONATE_UNITS_NO_SPACE"
                        success = False

                retmsg.append(["DONATE_UNITS_RESULT", success, error_reason])

            elif spellname == 'REQUEST_ALLIANCE_HELP':
                assert object

                success = True
                spell = gamedata['spells'][spellname]

                for PRED in ('show_if', 'requires'):
                    if PRED in spell and (not Predicates.read_predicate(spell[PRED]).is_satisfied2(session, session.player, None)):
                        retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED", spell[PRED]])
                        success = False
                        break

                if session.player.cooldown_active(spell['cooldown_name']) >= session.player.stattab.alliance_help_daily_limit:
                    retmsg.append(["ERROR", "ON_COOLDOWN"])
                    success = False

                if success:
                    if session.has_attacked or (object not in session.player.home_base_iter()):
                        retmsg.append(["ERROR", "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"])
                        success = False

                if success:
                    if (not session.player.alliance_help_enabled()) or \
                       (not gamesite.sql_client) or (not session.alliance_chat_channel):
                        retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])
                        success = False

                if success:
                    if object.is_damaged() or (not object.is_building()) or (not object.is_upgrading()) or \
                       (not object.upgrade_help.can_request_now(server_time)):
                        retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED"])
                        success = False

                if success:
                    alliance_id = session.get_alliance_id()
                    if alliance_id <= 0:
                        retmsg.append(["ERROR", "REQUIREMENTS_NOT_SATISFIED"])
                        success = False

                # you may request alliance help even if you aren't on the map yet

                if success:
                    # note: region_id may be None if the player is not on the map
                    region_id = session.player.home_region if gamedata.get('alliance_help_restrict_region', True) else None
                    expire_time = server_time + gamedata['alliance_help_request_duration']
                    req_props = {'obj_id': object.obj_id, 'obj_spec': object.spec.name, 'obj_level': object.level,
                                 'kind': 'speedup', 'action': 'upgrade',
                                 'action_spec': object.spec.name, 'action_level': object.level+1,
                                 'start_time': object.upgrade_start_time, 'total_time': object.upgrade_total_time, 'done_time': object.upgrade_done_time}
                    req_id = gamesite.sql_client.help_request_create(session.player.user_id, alliance_id, region_id, req_props,
                                                                     expire_time = expire_time)
                    if not req_id:
                        success = False

                if success:
                    object.upgrade_help.help_requested = True
                    object.upgrade_help.help_request_expire_time = expire_time
                    session.deferred_object_state_updates.add(object)
                    session.player.cooldown_trigger(gamedata['spells'][spellname]['cooldown_name'], gamedata['spells'][spellname]['cooldown'], add_stack = 1)
                    if session.increment_player_metric('alliance_help_requested', 1, time_series = False):
                        session.deferred_history_update = True
                    metric_event_coded(session.player.user_id, '4180_alliance_help_requested',
                                       {'sum':session.player.get_denormalized_summary_props('brief'),
                                        'alliance_id':alliance_id, 'req_id':req_id, 'region_id': region_id,
                                        'expire_time': expire_time,
                                        'req_props': req_props})

                    retmsg.append(["HELP_REQUESTED", object.obj_id, [object.x, object.y]])

                    if session.alliance_chat_channel:
                        session.do_chat_send(session.alliance_chat_channel,
                                             'I want help! (req_id %r region %r)' % (req_id, region_id),
                                             bypass_gag = True, props = {'type':'help_request', 'req_id':req_id, 'region_id': region_id,
                                                                         'cur_helpers': 0, 'max_helpers': gamedata['alliance_help_quorum'],
                                                                         'req_props': req_props, 'expire_time': expire_time})

                    if gamedata.get('alliance_help_notifications', True):
                        member_list = gamesite.sql_client.get_alliance_members(alliance_id, reason = 'REQUEST_ALLIANCE_HELP')
                        if member_list:
                            pcache_data = self.do_query_player_cache(None, [m['user_id'] for m in member_list],
                                                                     fields = ['home_region'],
                                                                     reason = 'REQUEST_ALLIANCE_HELP')

                            replacements = SpinJSON.dumps({'%SENDER_UI_NAME': session.user.get_ui_name(session.player),
                                                           '%DESCR': '%s L%d' % (gamedata['buildings'][req_props['action_spec']]['ui_name'], req_props['action_level'])})
                            for member, pinfo in zip(member_list, pcache_data):
                                if member['user_id'] != session.user.user_id:
                                    # don't notify if the region restriction would prevent you from responding
                                    if region_id and gamedata.get('alliance_help_restrict_region', True) and \
                                       pinfo and pinfo.get('home_region',None) != region_id:
                                        continue
                                    gamesite.do_CONTROLAPI(session.user.user_id, {'method': 'send_notification', # 'reliable': 1,
                                                                                  'ignore_if_online': 1, # only send to offline people
                                                                                  'user_id': member['user_id'],
                                                                                  'replacements': replacements,
                                                                                  'config': 'alliance_help_request'})
                # send this regardless of success state
                retmsg.append(["COOLDOWNS_UPDATE", session.player.cooldowns])

            elif spellname == 'GIVE_ALLIANCE_HELP':
                recipient_id = spellargs[0]
                req_id = spellargs[1]
                success = True
                error_reason = None

                spell = gamedata['spells'][spellname]

                for PRED in ('show_if', 'requires'):
                    if PRED in spell and (not Predicates.read_predicate(spell[PRED]).is_satisfied2(session, session.player, None)):
                        error_reason = "REQUIREMENTS_NOT_SATISFIED"
                        success = False

                if success:
                    if session.has_attacked:
                        error_reason = "CANNOT_CAST_SPELL_OUTSIDE_HOME_BASE"
                        success = False

                if success:
                    if (not session.player.alliance_help_enabled()) or \
                       (not gamesite.sql_client) or (not session.alliance_chat_channel):
                        retmsg.append(["ERROR", "ALLIANCES_OFFLINE"])
                        success = False

                if success:
                    alliance_id = session.get_alliance_id()
                    if alliance_id <= 0:
                        error_reason = "REQUIREMENTS_NOT_SATISFIED"
                        success = False

                if success:
                    region_id = session.player.home_region if gamedata.get('alliance_help_restrict_region', True) else None
                    cur_helpers, req = gamesite.sql_client.help_request_help(req_id = req_id, helper_id = session.player.user_id,
                                                                             alliance_id = alliance_id, region_id = region_id)
                    if cur_helpers < 0 or (not req):
                        # help failed
                        success = False
                        error_reason = "HELP_REQUEST_STALE"

                if success and req:
                    xp = gamedata['player_xp'].get('respond_to_help_request', 0)
                    if xp:
                        cc = session.player.find_object_by_type(gamedata['townhall'])
                        self.give_xp_to(session, session.player, retmsg, xp, 'respond_to_help_request', [cc.x,cc.y] if cc else None, obj_session_id = cc.obj_id if cc else None)

                    session.increment_player_metric('help_responses', 1, time_series = False)
                    session.increment_player_metric('help_responses_cur_alliance', 1, time_series = False)
                    session.deferred_history_update = True

                    if session.alliance_chat_channel:
                        session.do_chat_send(session.alliance_chat_channel,
                                             'I helped! (req_id %r region %r)' % (req_id, region_id),
                                             bypass_gag = True, props = {'type':'help_response', 'req_id': req_id, 'region_id': region_id,
                                                                         'recipient_id': recipient_id,
                                                                         'cur_helpers': cur_helpers, 'max_helpers': gamedata['alliance_help_quorum'],
                                                                         'req_props': req['req_props'], 'expire_time': req['expire_time'],
                                                                         'xp_gained': xp})

                    #session.activity_classifier.set_flag('alliance_help')
                    metric_event_coded(session.player.user_id, '4181_alliance_help_added',
                                       {'sum':session.player.get_denormalized_summary_props('brief'),
                                        'alliance_id':alliance_id,
                                        'recipient_id':recipient_id, 'cur_helpers': cur_helpers, 'max_helpers': gamedata['alliance_help_quorum'],
                                        'req_id':req_id, 'req_props': req['req_props']})

                    if cur_helpers >= gamedata['alliance_help_quorum']:
                        # trigger the completion!
                        gamesite.sql_client.help_request_remove(req_id)
                        gamesite.msg_client.msg_send([{'to':[recipient_id],
                                                       'type':'help_complete',
                                                       'from': session.player.user_id,
                                                       'from_name': session.user.get_ui_name(session.player),
                                                       'req': req,
                                                       }])
                        # tell recipient to check mail
                        gamesite.do_CONTROLAPI(session.user.user_id, {'method': 'receive_mail', 'user_id': recipient_id})

                    else:
                        # incomplete, send GUI-only notification
                        gamesite.do_CONTROLAPI(session.user.user_id, {'method': 'help_response', 'user_id': recipient_id,
                                                                      'sender_name': session.user.get_ui_name(session.player),
                                                                      'req': SpinJSON.dumps(req)})

                retmsg.append(["GIVE_ALLIANCE_HELP_RESULT", success, error_reason])

            else:
                return self.handle_protocol_error(session, retmsg, arg)

        else:
            return self.handle_protocol_error(session, retmsg, arg)

        return

    def broadcast_map_update(self, region_id, base_id, data, originator, send_to_net = True, map_time = None):
        assert region_id and base_id
        if data is None:
            data = {'base_id':base_id, 'DELETED':1}
        elif 'base_id' not in data:
            data['base_id'] = base_id
        upd = ["REGION_MAP_UPDATES", region_id, [data], map_time or server_time]

        if base_id[0] == 's':
            squad_owner_id = int(base_id[1:].split('_')[0])
        else:
            squad_owner_id = None

        for session in iter_sessions():
            if session.player.home_region == region_id:
                # if the update concerns one of the player's squads, and it's from an external player,
                # then have the owner ping squads to see what happened
                # (right now, this just handles squads being destroyed, and post-combat updates)
                if (squad_owner_id == session.player.user_id) and (originator != session.player.user_id):
                    session.deferred_ping_squads = True

                if (originator != session.player.user_id): # is async to session
                    session.send([upd], flush_now = False) # avoid storms

        if send_to_net:
            gamesite.chat_mgr.send('CONTROL', None, {'secret':SpinConfig.config['proxy_api_secret'],
                                                     'server':spin_server_name,
                                                     'method':'broadcast_map_update',
                                                     'args': { 'region_id': region_id, 'base_id': base_id, 'data': data,
                                                               # note: time is boxed here in "args" since it refers to the region map update time,
                                                               # which could conceivably be on a different clock than the chat message time
                                                               'map_time': server_time,
                                                               'server': spin_server_name, 'originator': originator },
                                                     }, '', log = False)

    def broadcast_map_attack(self, region_id, feature, attacker_id, defender_id, summary, pcache_info, send_to_net = True, msg = None, map_time = None):
        if msg is None:
            msg = "REGION_MAP_ATTACK_COMPLETE" if summary else "REGION_MAP_ATTACK_START" # legacy compatibility
        upd = [msg, region_id, feature, attacker_id, defender_id, summary, pcache_info, map_time or server_time]
        for session in iter_sessions():
            if session.player.home_region == region_id:

                # if session.player is a passive participant (defender, or either role in a raid),
                # ping their battle history so the GUI will display a jewel
                if summary and (session.player.user_id == defender_id or
                                (summary.get('battle_type')=='raid') and session.player.user_id == attacker_id):
                    session.deferred_battle_history_update = True

                if gamedata['server'].get('broadcast_thirdparty_map_attack', True) or (session.user.user_id in (attacker_id, defender_id)):
                    session.send([upd], flush_now = (session.user.user_id in (attacker_id, defender_id)))

        if send_to_net:
            gamesite.chat_mgr.send('CONTROL', None, {'secret':SpinConfig.config['proxy_api_secret'],
                                                     'server':spin_server_name,
                                                     'method':'broadcast_map_attack',
                                                     'args': { 'msg': msg,
                                                               'region_id': region_id, 'feature': feature,
                                                               'attacker_id': attacker_id, 'defender_id': defender_id,
                                                               'summary': summary, 'pcache_info': pcache_info,
                                                               # note: time is boxed here in "args" since it refers to the region map update time,
                                                               # which could conceivably be on a different clock than the chat message time
                                                               'map_time': server_time,
                                                               'server': spin_server_name },
                                                     }, '', log = False)

    # this is async
    @inlineCallbacks
    def update_bh_blog_feed(self):
        if 'bh_blog_mail' not in gamedata['strings']:
            returnValue(None)
        if self.bh_blog_feed_time >= server_time - 15*60: # cache is recent
            returnValue(self.bh_blog_feed_cache)

        self.bh_blog_feed_time = server_time
        self.bh_blog_feed_cache = None

        try:
            response_raw = yield gamesite.AsyncHTTP_Battlehouse.queue_request_deferred(
                server_time, 'https://www.battlehouse.com/feed/atom/')
            self.bh_blog_feed_cache = SpinAtomFeed.get_feed(game_id, gamedata['strings']['game_name'], response_raw)
        except BaseException as e:
            gamesite.exception_log.event(server_time, 'error fetching battlehouse.com news feed: %r' % e)
            returnValue(None)

        returnValue(self.bh_blog_feed_cache)

    def handle_protocol_error(self, session, retmsg, arg):
        # called when there is a problem with the AJAX message the client sent
        # records this to the exceptions log to pick up hacking/fuzzing attempts
        # then logs out the client
        retmsg.append(["ERROR", "SERVER_PROTOCOL"])
        if gamedata['server']['log_protocol_errors']:
            gamesite.exception_log.event(server_time, ('user %d sent invalid message: ' % session.user.user_id) + repr(arg))

        return self.log_out_async(session, 'protocol_error')


# subclass of Twisted's built-in web server
# this adds periodic function calls to perform background tasks for the game
class GameSite(server.Site):
    class GameProtocol(http.HTTPChannel):
        def __init__(self, *args, **kwargs):
            http.HTTPChannel.__init__(self, *args, **kwargs)
            self.close_connection_watchdog = None
            self.connect_time = -1
            self.last_request = None # for debugging only
            self.last_request_time = -1
        def connectionMade(self):
            http.HTTPChannel.connectionMade(self)
            self.connect_time = int(time.time())
            self.site.gotClient(self)
        def connectionLost(self, reason):
            http.HTTPChannel.connectionLost(self, reason)
            self.connect_time = -1
            self.site.lostClient(self)
            if self.close_connection_watchdog:
                self.close_connection_watchdog.cancel()
                self.close_connection_watchdog = None
            self.last_request = None # break circular reference
        def close_connection_aggressively(self, force = False):
            if force:
                self.close_connection_watchdog = None
                self.transport.abortConnection()
            else:
                self.transport.loseConnection()

                if not self.close_connection_watchdog:
                    # set watchdog timer to abort badly-behaved TCP connections
                    self.close_connection_watchdog = reactor.callLater(10.0, self.close_connection_aggressively, True)

        def allContentReceived(self): # remember last request for debugging
            self.last_request_time = int(time.time())
            self.last_request = self.requests[-1] # save reference here, but have to wait until it parses request to repr()
            return http.HTTPChannel.allContentReceived(self)

        def __repr__(self):
            if self.last_request_time > 0:
                ago = server_time - self.last_request_time
            else:
                ago = -1
            return 'GameProtocol (last request %ds ago: %r)' % (ago, self.last_request)

    displayTracebacks = False
    protocol = GameProtocol

    # allow CustomerSupport/Consequents/etc to access global variables
    def get_server_time(self): return server_time
    def get_gamedata(self): return gamedata
    def get_localized_gamedata(self, *args, **kwargs):
        return get_localized_gamedata(*args, **kwargs)

    # quick-and-dirty pcache query to grab the locale
    def get_locale_for_player(self, user_id, reason = None):
        pcache = self.pcache_client.player_cache_lookup_batch([user_id,], fields = ['locale'], reason = reason)[0]
        if pcache:
            return pcache.get('locale')
        return None

    def log_async_exception(self, exc):
        self.exception_log.event(server_time, exc)
    def log_facebook_exception(self, exc):
        MAX_LEN = 1000
        if len(exc) >= MAX_LEN:
            exc = exc[0:MAX_LEN]+'...'
        self.facebook_log.event(server_time, exc)
    def log_kongregate_exception(self, exc):
        self.kongregate_log.event(server_time, exc)
    def log_armorgames_exception(self, exc):
        self.armorgames_log.event(server_time, exc)
    def log_battlehouse_exception(self, exc):
        self.battlehouse_log.event(server_time, exc)
    def log_mattermost_exception(self, exc):
        self.mattermost_log.event(server_time, exc)
    def log_xsolla_exception(self, exc):
        self.xsolla_log.event(server_time, exc)

    # keep track of per-server-instance configuration variables here
    class Configuration(object):
        def __init__(self, json):
            self.game_host = json.get('game_host', os.getenv('HOSTNAME') or socket.gethostname())
            self.game_snam = json.get('game_snam', '')
            self.game_listen_host = json.get('game_listen_host', '')
            self.game_http_port = json.get('game_http_port',-1)
            self.game_ssl_port = json.get('game_ssl_port',-1)
            self.game_ws_port = json.get('game_ws_port',-1)
            self.game_wss_port = json.get('game_wss_port',-1)
            self.tcp_accept_backlog = json.get('tcp_accept_backlog', 511)
            self.affinities = json.get('affinities',['default'])
            self.start_state = json.get('start_state', 'ok')

    def __init__(self, config, root, gameapi, controlapi, trialpayapi, xsapi):

        # set this here because setup_test_user() references gamesite
        global gamesite
        gamesite = self

        # note: the "timeout" here applies to HTTP KeepAlive
        # connections, it does NOT have any impact on game-relevant
        # timeouts like the session or proxy timeout
        server.Site.__init__(self, root, timeout = gamedata['server']['http_connection_timeout'])

        self.server_name = spin_server_name
        self.config = config
        self.gameapi = gameapi
        self.controlapi = controlapi
        self.trialpayapi = trialpayapi
        self.xsapi = xsapi
        self.player_table = player_table
        self.user_table = user_table
        self.admin_stats = admin_stats

        self.last_ai_base_gc_time = 0
        self.last_player_flush_time = 0
        self.maint_kick_time = -1
        self.bg_task_interval = -1
        self.server_status_interval = -1

        # init AsyncHTTP requesters

        data = gamedata['server']['AsyncHTTP_metrics']
        self.AsyncHTTP_metrics = AsyncHTTP.AsyncHTTPRequester(data['concurrent_request_limit'],
                                                                  data['total_request_limit'],
                                                                  data['request_timeout'],
                                                                  spin_log_verbosity,
                                                                  self.log_async_exception)
        data = gamedata['server']['AsyncHTTP_Facebook']
        self.AsyncHTTP_Facebook = AsyncHTTP.AsyncHTTPRequester(data['concurrent_request_limit'],
                                                               data['total_request_limit'],
                                                               data['request_timeout'],
                                                               spin_log_verbosity,
                                                               self.log_facebook_exception,
                                                               max_tries = data['max_tries'],
                                                               retry_delay = data['retry_delay'])
        data = gamedata['server'].get('AsyncHTTP_Kongregate', gamedata['server']['AsyncHTTP_Facebook'])
        self.AsyncHTTP_Kongregate = AsyncHTTP.AsyncHTTPRequester(data['concurrent_request_limit'],
                                                                 data['total_request_limit'],
                                                                 data['request_timeout'],
                                                                 spin_log_verbosity,
                                                                 self.log_kongregate_exception,
                                                                 max_tries = data['max_tries'],
                                                                 retry_delay = data['retry_delay'])
        data = gamedata['server'].get('AsyncHTTP_ArmorGames', gamedata['server']['AsyncHTTP_Facebook'])
        self.AsyncHTTP_ArmorGames = AsyncHTTP.AsyncHTTPRequester(data['concurrent_request_limit'],
                                                                 data['total_request_limit'],
                                                                 data['request_timeout'],
                                                                 spin_log_verbosity,
                                                                 self.log_armorgames_exception,
                                                                 max_tries = data['max_tries'],
                                                                 retry_delay = data['retry_delay'])
        data = gamedata['server'].get('AsyncHTTP_Battlehouse', gamedata['server']['AsyncHTTP_Facebook'])
        self.AsyncHTTP_Battlehouse = AsyncHTTP.AsyncHTTPRequester(data['concurrent_request_limit'],
                                                                  data['total_request_limit'],
                                                                  data['request_timeout'],
                                                                  spin_log_verbosity,
                                                                  self.log_battlehouse_exception,
                                                                  max_tries = data['max_tries'],
                                                                  retry_delay = data['retry_delay'])
        data = gamedata['server'].get('AsyncHTTP_Microsoft', gamedata['server']['AsyncHTTP_Facebook'])
        self.AsyncHTTP_Microsoft = AsyncHTTP.AsyncHTTPRequester(data['concurrent_request_limit'],
                                                                  data['total_request_limit'],
                                                                  data['request_timeout'],
                                                                  spin_log_verbosity,
                                                                  self.log_battlehouse_exception, # note: log microsoft API errors to the battlehouse API log for now
                                                                  max_tries = data['max_tries'],
                                                                  retry_delay = data['retry_delay'])
        data = gamedata['server'].get('AsyncHTTP_Mattermost', gamedata['server']['AsyncHTTP_Facebook'])
        self.AsyncHTTP_Mattermost = AsyncHTTP.AsyncHTTPRequester(data['concurrent_request_limit'],
                                                                 data['total_request_limit'],
                                                                 data['request_timeout'],
                                                                 spin_log_verbosity,
                                                                 self.log_mattermost_exception,
                                                                 max_tries = data['max_tries'],
                                                                 retry_delay = data['retry_delay'])
        data = gamedata['server'].get('AsyncHTTP_Xsolla', gamedata['server']['AsyncHTTP_Facebook'])
        self.AsyncHTTP_Xsolla = AsyncHTTP.AsyncHTTPRequester(data['concurrent_request_limit'],
                                                             data['total_request_limit'],
                                                             data['request_timeout'],
                                                             spin_log_verbosity,
                                                             self.log_xsolla_exception,
                                                             max_tries = data['max_tries'],
                                                             retry_delay = data['retry_delay'])
        # for making async cross-server IPC calls (FB notifications etc)
        self.AsyncHTTP_CONTROLAPI = AsyncHTTP.AsyncHTTPRequester(-1, -1, 30, # timeout = 30s
                                                                 0, self.log_async_exception,
                                                                 # need retries for "offline but locked" issues
                                                                 max_tries = 10, retry_delay = 60)

        self.nosql_id_generator = SpinNoSQLId.Generator()

        self.nosql_client = None
        self.db_client = None
        self.lock_client = None # XXX temp - easy way to switch message_table API between dbserver and mongodb
        self.pcache_client = None # XXX temp - easy way to switch message_table API between dbserver and mongodb
        self.msg_client = None # XXX temp - easy way to switch message_table API between dbserver and mongodb
        self.sql_client = None # XXX temp - easy way to switch alliances/scores API between SQL and mongodb
        self.social_id_table = None
        self.player_portraits = None

        # connect to MongoDB
        self.nosql_init(is_startup = True)

        # connect to SQL server, if configured
        self.sql_init()

        assert self.social_id_table is not None

        # init logging (requires NoSQL to be set up for NoSQL logs)

        if gamedata['server'].get('log_machine_stats', False):
            self.machine_log = SpinLog.DailyJSONLog(spin_log_dir+'/','-machine.json')
        else:
            self.machine_log = None

        # best to keep this in sync with the metrics_log setup in proxyserver.py!
        self.metrics_log = SpinLog.MultiLog([SpinLog.DailyJSONLog(spin_log_dir+'/','-metrics.json'), # ALL metrics to local file
                                             SpinLog.MetricsLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_metrics')), # important metrics to MongoDB log_metrics
                                             SpinLog.AcquisitionsLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_acquisitions')), # (re)acquisitions to MongoDB log_acquisitions
                                             SpinLog.InventoryLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_inventory')), # inventory events to MongoDB log_inventory
                                             SpinLog.LadderPvPLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_ladder_pvp')), # ladder pvp events to MongoDB log_ladder_pvp
                                             SpinLog.DamageProtectionLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_damage_protection')), # damage protection events to MongoDB log_damage_protection
                                             SpinLog.AlliancesLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_alliances')), # alliance events to MongoDB log_alliances
                                             SpinLog.AllianceMembersLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_alliance_members')), # alliance member events to MongoDB log_alliance_members
                                             SpinLog.UnitDonationLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_unit_donation')), # unit donation events to MongoDB log_unit_donation
                                             SpinLog.AllianceHelpLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_alliance_help')), # alliance help events to MongoDB log_alliance_help
                                             SpinLog.DamageAttributionLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_damage_attribution')), # damage attribution events to MongoDB log_damage_attribution
                                             SpinLog.FishingLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_fishing')), # fishing events to MongoDB log_fishing
                                             SpinLog.QuestsLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_quests')), # quests events to MongoDB log_quests
                                             SpinLog.LotteryLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_lottery')), # lottery events to MongoDB log_lottery
                                             SpinLog.AchievementsLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_achievements')), # achievements events to MongoDB log_achievements
                                             SpinLog.LoginSourcesFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_login_sources')), # login source events to MongoDB log_login_sources
                                             SpinLog.LoginFlowFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_login_flow')), # login flow events to MongoDB log_login_flow
                                             SpinLog.PrivacyLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_privacy')), # privacy-related events to MongoDB log_privacy
                                             SpinLog.PrivacyLogFilter(SpinLog.DailyJSONLog(spin_log_dir+'/','-privacy.json')), # privacy-related events toJSON privacy file
                                             SpinLog.FBPermissionsLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_fb_permissions')), # FB Permissions events to MongoDB log_fb_notifications
                                             SpinLog.FBNotificationsLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_fb_notifications')), # FB Notification events to MongoDB log_fb_notifications
                                             SpinLog.FBRequestsLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_fb_requests')), # FB Requests events to MongoDB log_fb_requests
                                             SpinLog.FBSharingLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_fb_sharing')), # FB Sharing events to MongoDB log_fb_sharing
                                             SpinLog.FBOpenGraphLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_fb_open_graph')), # FB Open Graph events to MongoDB log_fb_open_graph
                                             SpinLog.ClientTroubleLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_client_trouble')), # misc client trouble to MongoDB log_client_trouble (for analytics)
                                             SpinLog.ClientExceptionLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_client_trouble'), brief = True), # abbreviated client exceptions to MongoDB log_client_trouble (for analytics)
                                             SpinLog.ClientExceptionLogFilter(SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_client_exceptions'), brief = False)]) # full client exceptions to MongoDB log_client_exceptions (for PCHECK)

        self.credits_log = SpinLog.MultiLog([SpinLog.DailyJSONLog(spin_log_dir+'/','-credits.json'),
                                             SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_credits', safe = True)])
        self.gamebucks_log = SpinLog.MultiLog([SpinLog.DailyJSONLog(spin_log_dir+'/','-gamebucks.json'),
                                               SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_gamebucks')])
        self.purchase_ui_log = SpinLog.MultiLog([SpinLog.DailyJSONLog(spin_log_dir+'/','-purchase_ui.json'),
                                                 SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_purchase_ui')])

        self.adnetworks_logs = {}
        if gamedata['server'].get('log_sessions', False):
            self.sessions_log = SpinLog.DailyJSONLog(spin_log_dir+'/','-sessions.json')
        else:
            self.sessions_log = None

        self.raw_log = None  # set in self.reset_interval

        # log ALL exceptions to local exceptions.txt, plus interesting ones to log_exceptions table
        self.exception_log = SpinLog.MultiLog([SpinLog.DailyRawLog(spin_log_dir+'/', '-exceptions.txt'),
                                               SpinLog.ServerExceptionLogFilter(SpinNoSQLLog.NoSQLRawLog(self.nosql_client, 'log_exceptions'))])
        self.player_io_log = SpinLog.DailyRawLog(spin_log_dir+'/', '-player-io.txt')
        self.controlapi_log = SpinLog.DailyRawLog(spin_log_dir+'/', '-controlapi.txt')
        self.facebook_log = SpinLog.DailyRawLog(spin_log_dir+'/', '-facebook.txt')
        self.armorgames_log = SpinLog.DailyRawLog(spin_log_dir+'/', '-armorgames.txt')
        self.kongregate_log = SpinLog.DailyRawLog(spin_log_dir+'/', '-kongregate.txt')
        self.battlehouse_log = SpinLog.DailyRawLog(spin_log_dir+'/', '-battlehouse.txt')
        self.mattermost_log = SpinLog.DailyRawLog(spin_log_dir+'/', '-mattermost.txt')
        self.xsolla_log = SpinLog.DailyRawLog(spin_log_dir+'/', '-xsolla.txt')
        self.trace_log = SpinLog.DailyRawLog(spin_log_dir+'/', '-traces.txt')

        self.metrics_log.event(server_time, {'event_name':'1500_server_restart', 'code':1500, 'scm_version':SERVER_VERSION})


        # connect to global chat server, if one is configured
        if 'chatserver' in SpinConfig.config:
            self.chat_client = SpinChatClient.Client(SpinConfig.config['chatserver']['chat_host'],
                                                     SpinConfig.config['chatserver']['chat_port'],
                                                     SpinConfig.config['chatserver'].get('secret_full', SpinChatProtocol.default_secret_full),
                                                     self.log_async_exception, latency_func = admin_stats.record_latency,
                                                     identity = spin_server_name)

            self.chat_log = None # chat logging is done by global server
        else:
            self.chat_client = None
            self.chat_log = SpinLog.DailyJSONLog(spin_log_dir+'/','-chat.json')

        self.chat_mgr = ChatChannels.ChatChannelMgr(relay = self.chat_client)
        self.chat_mgr.join(controlapi, 'CONTROL')

        # will be fired when last connection drops
        self.clients_stopped_deferred = None
        self.active_clients = set()
        self.active_requests = dict()

        signal.signal(signal.SIGUSR1, self.handle_SIGUSR1)
        signal.signal(signal.SIGUSR2, self.handle_SIGUSR2)
        signal.signal(signal.SIGHUP, self.handle_SIGHUP)

        self.server_state = config.start_state

        # init housekeeping function
        self.bg_task = task.LoopingCall(self.bgfunc)
        self.server_status_task = task.LoopingCall(self.server_status_func)
        self.reset_interval(True)

        # these will be set up by start_listening()
        self.listener_tcp = None
        self.listener_ssl = None

    def start_listening(self):
        self.listener_tcp = reactor.listenTCP(self.config.game_http_port, self, interface=self.config.game_listen_host, backlog=self.config.tcp_accept_backlog)
        # awkward - when using external SSL termination, we don't want to start this listener, but we DO want to publish "ssl" ports. Fix later.
        if self.config.game_ssl_port > 0 and SpinConfig.config.get('ssl_key_file'):
            self.listener_ssl = reactor.listenSSL(self.config.game_ssl_port, self,
                                                  SpinSSL.ChainingOpenSSLContextFactory(SpinConfig.config['ssl_key_file'],
                                                                                        SpinConfig.config['ssl_crt_file'],
                                                                                        certificateChainFile=SpinConfig.config.get('ssl_chain_file',None)),
                                                  interface=self.config.game_listen_host, backlog=self.config.tcp_accept_backlog)

        # make sure players are logged out and flushed before server shuts down
        reactor.addSystemEventTrigger('before', 'shutdown', self.shutdown)

    def shutdown(self):
        # ordering here is important: close listening socket, then close sessions, then close HTTP/WS traffic

        self.change_state('shutting_down') # send status update to tell latency probe to ignore us
        # (there's a small race condition here - could fix by inserting a deley here, but probably not a problem)

        d = self.stop_listening()
        d.addCallback(lambda _, self=self: self.stop_all_sessions())
        d.addErrback(lambda err, self=self: self.exception_log.event(server_time, 'stop_all_sessions() exception: %s' % err.getTraceback()))
        d.addCallback(lambda _, self=self: self.stop_all_clients())
        d.addErrback(lambda err, self=self: self.exception_log.event(server_time, 'stop_all_clients() exception: %s' % err.getTraceback()))
        if self.chat_client:
            d.addCallback(lambda _, self=self: self.chat_client.disconnect())
            d.addErrback(lambda err, self=self: self.exception_log.event(server_time, 'chat_client.disconnect() exception: %s' % err.getTraceback()))
        d.addCallback(lambda _: io_system.shutdown())
        d.addErrback(lambda err, self=self: self.exception_log.event(server_time, 'io_system.shutdown() exception: %s' % err.getTraceback()))
        # send a final server status update when we're finished
        d.addCallback(lambda _, self=self: self.nosql_client.server_status_update(spin_server_name, None, reason='shutdown'))
        return d

    def stop_listening(self):
        return defer.DeferredList([defer.maybeDeferred(self.listener_tcp.stopListening)] + \
                                  ([defer.maybeDeferred(self.listener_ssl.stopListening)] if self.listener_ssl else []))

    # client/request management boilerplate - see https://github.com/habnabit/polecat/blob/master/polecat.py
    def gotClient(self, client):
        self.active_clients.add(client)
        #gamesite.exception_log.event(server_time, 'gotClient %r clients %d requests %d' % (client, len(self.active_clients), len(self.active_requests)))
    def lostClient(self, client):
        self.active_clients.discard(client)
        #gamesite.exception_log.event(server_time, 'lostClient %r clients %d requests %d' % (client, len(self.active_clients), len(self.active_requests)))
        if not self.active_clients and self.clients_stopped_deferred:
            d = self.clients_stopped_deferred
            self.clients_stopped_deferred = None
            d.callback(None)
    def getResourceFor(self, request):
        self.active_requests[id(request)] = request
        def remove_from_active(_, self, request):
            del self.active_requests[id(request)]
            return _
        request.notifyFinish().addBoth(remove_from_active, self, request)
        return server.Site.getResourceFor(self, request)

    def stop_all_clients(self):
        "Returns a Deferred that fires when all clients have disconnected."
        if not self.active_clients:
            return defer.succeed(None)
        else:
            d = make_deferred('stop_all_clients')
            self.clients_stopped_deferred = d

            # tell any keep-alive requests that we're closing down
            for request in self.active_requests.itervalues():
                request.setHeader('Connection', 'close')

            for client in self.active_clients:
                client.close_connection_aggressively()
            return d

    def log_exception_func(self, x): self.exception_log.event(server_time, x)

    def sql_init(self):
        self.sql_scores2_client = None
        self.sql_alliance_events_client = None
        if ((game_id+'_scores2') in SpinConfig.config.get('pgsql_servers',{})):
            import AsyncPostgres
            pg = AsyncPostgres.AsyncPostgres(SpinConfig.get_pgsql_config(game_id+'_scores2'),
                                             verbosity = 0,
                                             log_exception_func = self.log_exception_func)
            self.sql_scores2_client = Scores2.SQLScores2(pg)
            # tie alliance events to the scores2 config for now (later: merge all pgsql configs)
            self.sql_alliance_events_client = SpinSQLAllianceEvents.SQLAllianceEventsClient(pg)

        self.sql_battles_client = None
        if ((game_id+'_battles') in SpinConfig.config.get('pgsql_servers',{})):
            import AsyncPostgres
            if self.sql_scores2_client and \
               SpinConfig.get_pgsql_config(game_id+'_battles') == self.sql_scores2_client.sql_client.dbconfig:
                # re-use same connection
                pg = self.sql_scores2_client.sql_client
            else:
                pg = AsyncPostgres.AsyncPostgres(SpinConfig.get_pgsql_config(game_id+'_battles'),
                                                 verbosity = 0,
                                                 log_exception_func = self.log_exception_func)
            self.sql_battles_client = SpinSQLBattles.SQLBattlesClient(pg, timeout = SpinConfig.config['pgsql_servers'][game_id+'_battles'].get('timeout', 30))

    def sql_shutdown(self):
        self.sql_scores2_client = None
        self.sql_battles_client = None
        self.sql_alliance_events_client = None

    def nosql_init(self, is_startup = False):
        if self.nosql_client: return
        if ('mongodb_servers' not in SpinConfig.config) or (game_id not in SpinConfig.config['mongodb_servers']):
            if is_startup:
                raise Exception('mongodb_servers["%s"] not found in config.json. Please ask Dan for help setting up MongoDB.' % game_id)
            else:
                self.exception_log.event(server_time, 'NoSQL init fails - mongodb_servers not found in config.json')
            return

        config = SpinConfig.get_mongodb_config(game_id)
        try:
            self.nosql_client = SpinNoSQL.NoSQLClient(config,
                                                      map_update_hook = self.gameapi.broadcast_map_update,
                                                      identity = spin_server_name,
                                                      max_retries = -1, # never give up
                                                      log_exception_func = self.log_exception_func,
                                                      latency_func = admin_stats.record_latency)
        except Exception as e:
            if is_startup:
                raise Exception('Error was: %s\nUnable to connect to mongodb server (%s). Host or Username/password may be wrong. Please ask Dan for help setting up MongoDB.' % (repr(e), repr(config)))
            else:
                raise

        self.nosql_client.set_time(server_time)

        self.db_client = self.nosql_client
        self.social_id_table = SocialIDCache.SocialIDCache(self.db_client)
        self.sql_client = self.nosql_client
        self.msg_client = self.db_client
        self.lock_client = self.db_client
        self.pcache_client = self.db_client
        self.mongo_scores2_client = Scores2.MongoScores2(self.nosql_client)

        self.player_portraits = PlayerPortraits.PlayerPortraits(self.nosql_client,
                                                                {'fb': self.AsyncHTTP_Facebook,
                                                                 'kg': self.AsyncHTTP_Kongregate,
                                                                 'ag': self.AsyncHTTP_ArmorGames,
                                                                 'bh': self.AsyncHTTP_Battlehouse,
                                                                 'mm': self.AsyncHTTP_Mattermost,
                                                                 },
                                                                {'fb': self.log_facebook_exception,
                                                                 'kg': self.log_kongregate_exception,
                                                                 'ag': self.log_armorgames_exception,
                                                                 'bh': self.log_battlehouse_exception,
                                                                 'mm': self.log_mattermost_exception,
                                                                 'default': self.log_async_exception})

    def nosql_shutdown(self):
        if self.nosql_client:
            self.social_id_table = None
            self.nosql_client.shutdown()
            self.exception_log.event(server_time, 'NoSQL connection shutdown')
            if self.sql_client is self.nosql_client: self.sql_client = None
            if self.msg_client is self.nosql_client: self.msg_client = None
            if self.lock_client is self.nosql_client: self.lock_client = None
            if self.pcache_client is self.nosql_client: self.pcache_client = None
            self.nosql_client = None

    def do_log_adnetwork_event(self, api, props):
        if not gamedata['server']['enable_adnetwork_logs']: return
        if api not in self.adnetworks_logs:
            file_log = SpinLog.DailyJSONLog(spin_log_dir+'/','-%s.json' % api)
            if self.nosql_client:
                nosql_log = SpinNoSQLLog.NoSQLJSONLog(self.nosql_client, 'log_'+api)
                log = SpinLog.MultiLog([file_log, nosql_log])
            else:
                log = file_log
            self.adnetworks_logs[api] = log
        props['api'] = api
        self.adnetworks_logs[api].event(server_time, props)

    def reset_interval(self, run_now):
        enable_raw_log = gamedata['server'].get('enable_raw_log', False)
        if self.raw_log and not enable_raw_log:
            self.raw_log = None
        elif (not self.raw_log) and enable_raw_log:
            self.raw_log = SpinLog.DailyRawLog(spin_log_dir+'/', '-raw-%s.txt' % spin_server_name)

        new_interval = gamedata['server'].get('bg_task_interval', 30)
        if new_interval != self.bg_task_interval:
            if self.bg_task_interval > 0:
                self.bg_task.stop()
            self.bg_task_interval = new_interval
            self.bg_task.start(self.bg_task_interval, now = run_now)

        new_status_interval = gamedata['server'].get('server_status_interval', 15)
        if new_status_interval != self.server_status_interval:
            if self.server_status_interval > 0:
                self.server_status_task.stop()
            self.server_status_interval = new_status_interval
            self.server_status_task.start(self.server_status_interval, now = run_now)

    def change_state(self, state):
        assert state in ('ok','closed','shutting_down')
        if self.server_state == state: return admin_stats.get_server_status_json()
        self.server_state = state
        if state == 'ok':
            self.maint_kick_time = -1
        status_json = admin_stats.get_server_status_json()
        self.nosql_client.server_status_update(spin_server_name, status_json, reason='change_state')
        return status_json

    # reload config.json and gamedata
    def reconfig(self):
        reload(SpinConfig) # reload SpinConfig module
        SpinConfig.reload() # reload config.json file
        reload_gamedata()
        status_json = admin_stats.get_server_status_json()
        if self.nosql_client:
            self.nosql_client.update_dbconfig(SpinConfig.get_mongodb_config(game_id))
            self.nosql_client.server_status_update(spin_server_name, status_json, reason='reconfig')
        self.reset_interval(False)
        return status_json

    # send logged-in players maintenance warnings, then kick all after 5 minutes
    # note: this does not prevent NEW log-ins, so make sure the proxyserver is not routing any new logins here
    def start_maint_kick(self):
        for session in iter_sessions():
            session.send([["SERVER_MAINTENANCE_WARNING"]], flush_now = False)
        self.maint_kick_time = server_time + gamedata['server']['maint_kick_time']
        self.server_state = 'maint_kick'
        status_json = admin_stats.get_server_status_json()
        if self.nosql_client:
            self.nosql_client.server_status_update(spin_server_name, status_json, reason='start_maint_kick')
        return status_json

    # immediately kick all sessions, even if they are stuck on I/O
    def panic_kick(self, ignore_transport):
        for session in list(iter_sessions()):
            try:
                self.gameapi.log_out_async(session, 'panic', force = True)
            except:
                pass
        for client in list(self.active_clients):
            if client.transport is not ignore_transport:
                client.transport.abortConnection() # if loseConnection() isn't enough

    # print Python stack frame to trace log upon receiving SIGUSR1
    def handle_SIGUSR1(self, signum, frm):
        self.trace_log.event(server_time, ''.join(traceback.format_stack(frm)))

    # reload config.json and gamedatadata upon receiving SIGHUP
    def handle_SIGHUP(self, signum, frm):
        reactor.callLater(0, self.reconfig)

    # start_maint_kick upon receiving SIGUSR2
    def handle_SIGUSR2(self, signum, frm):
        reactor.callLater(0, self.start_maint_kick)

    def log_exceptions(self, eventDict):
        if eventDict['isError']:
            if 'failure' in eventDict:
                text = ((eventDict.get('why') or 'Unhandled Error')
                        + '\n' + eventDict['failure'].getTraceback())
            else:
                text = ' '.join([str(m) for m in eventDict['message']])
            self.exception_log.event(server_time, text)

    def log_raw(self, eventDict):
        if not self.raw_log:
            return
        text = log.textFromEventDict(eventDict)
        if text is None:
            return
        self.raw_log.event(server_time, text)

    def log(self, request):
        if spin_log_verbosity >= 1:
            return server.Site.log(self, request)
        else:
            # don't log every boring HTTP request
            pass

    def stop_all_sessions(self):
        # server is shutting down - forcefully log out all active sessions

        # need to wait for all async logouts to finish before proceeding
        waiting_on = []
        for session in list(iter_sessions(include_logout_in_progress = True)):
            waiting_on.append(self.gameapi.log_out_async(session, 'server_shutdown'))

        return defer.DeferredList(waiting_on, consumeErrors = True)

    @catch_all('server_status_func')
    def server_status_func(self):
        # report server stats
        if self.nosql_client:
            self.nosql_client.server_status_update(spin_server_name, admin_stats.get_server_status_json(), reason='server_status_func')

    @catch_all('bgfunc')
    @admin_stats.measure_latency('bgfunc')
    def bgfunc(self):
        # run housekeeping functions

        update_server_time()

        # garbage-collect old AI instances
        if (server_time - self.last_ai_base_gc_time) >= gamedata['server'].get('ai_base_gc_interval', 1800):
            self.last_ai_base_gc_time = server_time
            ai_instance_table.collect_garbage()

        # if we're about to go down for maintenance, kick all logged-in players
        maint_kicks = 0
        if self.maint_kick_time > 0 and server_time >= self.maint_kick_time:
            for session in list(iter_sessions()):
                session.send([["ERROR", "MAINT_KICK"]], flush_now = True)
                self.gameapi.log_out_async(session, 'maint_kick')
                maint_kicks += 1
                if maint_kicks >= gamedata['server']['maint_kicks_at_once']:
                    break

        # garbage-collect the Session table
        timeout = gamedata['server']['session_timeout']
        absolute_timeout = gamedata['server']['absolute_session_timeout']

        lock_keepalive_sessions = []
        lock_keepalive_ids = []
        lock_keepalive_generations = []
        lock_keepalive_states = []
        region_lock_keepalives = {}

        for session in list(iter_sessions()): # make a copy since we might mutate the table

            kick_reason = None

            # check for expired idle sessions

            if (server_time - session.last_active_time) > timeout:
                kick_reason = 'timeout'
                session.send([["ERROR", "IDLE_KICK"]], flush_now = True)

            elif (session.last_active_time <= session.login_time) and ((server_time - session.last_active_time) > gamedata['server']['initial_session_timeout']):
                kick_reason = 'timeout'
                session.send([["ERROR", "IDLE_KICK"]], flush_now = True)
                if gamedata['server']['log_abnormal_logins'] >= 2:
                    gamesite.exception_log.event(server_time, 'user %d - no activity within %d sec of login, kicking.' % (session.user.user_id, gamedata['server']['initial_session_timeout']))

            elif (server_time - session.login_time) > absolute_timeout and (not session.has_attacked):
                kick_reason = 'long_session'
                gamesite.exception_log.event(server_time, 'user %d - terminating extremely long session (%dmin)' % (session.user.user_id, (server_time-session.login_time)/60))

            # perform idle check
            playtime = session.cur_playtime()

            idle_timeout_status = session.player.idle_check.timeout(session.login_time, server_time, playtime)
            # gamesite.exception_log.event(server_time, 'user %d - playtime %d check status %d needed %d' % (session.user.user_id, playtime, idle_timeout_status, session.player.idle_check.check_needed(session.login_time, server_time, playtime)))

            if idle_timeout_status == IdleCheck.STATUS_FAIL:
                metric_event_coded(session.user.user_id, '0694_idle_check_timeout', {})
            elif idle_timeout_status == IdleCheck.STATUS_SEND_AGAIN or \
                 (idle_timeout_status == IdleCheck.STATUS_NO_RESULT and \
                  (session.player.idle_check.forced_check_needed() or \
                   Predicates.read_predicate(gamedata['server']['idle_check']['enable_if']).is_satisfied2(session, session.player, None)) and \
                  session.player.idle_check.check_needed(session.login_time, server_time, playtime)):
                idle_check_msg = session.player.idle_check.start_check(session.login_time, server_time, playtime)
                session.send([["IDLE_CHECK", idle_check_msg]])
                metric_event_coded(session.user.user_id, '0691_idle_check', idle_check_msg)

            if not kick_reason:
                unused, abuse_warning_msg = session.player.detect_login_abuse(cur_session_length = server_time - session.login_time)
                if (session.player.lockout_until > 0) and (server_time < session.player.lockout_until):
                    # abuse detected, kick them out
                    m = session.player.lockout_message if (session.player.lockout_message and (session.player.lockout_message in gamedata['errors'])) else gamedata['server']['login_abuse_error_code']
                    session.send([["ERROR", m]], flush_now = True)
                    kick_reason = 'abuse'
                elif abuse_warning_msg:
                    session.send(abuse_warning_msg)

            if kick_reason:
                self.gameapi.log_out_async(session, kick_reason)
                continue

            # conclude any longpolls that are idle for more than the wait interval
            if session.longpoll_request and session.longpoll_request_time > 0 and \
               ((server_time - session.longpoll_request_time) >= gamedata['server']['ajax_longpoll_wait']):
                request = session.longpoll_request
                session.longpoll_request = None
                self.gameapi.complete_longpoll(request, session)

            # session is still good, send keepalive to the DB lock server and proxy sessions table
            lock_keepalive_sessions.append(session)
            lock_keepalive_ids.append(session.user.user_id)
            lock_keepalive_generations.append(session.player.generation)
            lock_keepalive_states.append(Player.LockState.logged_in)
            if session.player.is_on_map() and gamesite.nosql_client:
                if session.player.home_region not in region_lock_keepalives:
                    region_lock_keepalives[session.player.home_region] = []
                region_lock_keepalives[session.player.home_region].append(session.player.my_home.base_id)

            session.prune_attack_replay_receivers()

            # check for sessions with pending AI attacks
            if session.incoming_attack_pending() and (server_time >= session.incoming_attack_time):
                if gamedata['server']['log_ai_attack_overdue'] and session.incoming_attack_type != 'tutorial':
                    gamesite.exception_log.event(server_time, 'deploying overdue AI attack (%s) on player %d' % \
                                                 (str(session.incoming_attack_type), session.player.user_id))
                session.deploy_ai_attack(session.outgoing_messages, force = True)
                session.queue_flush_outgoing_messages()

            elif session.incoming_attack_wave_time > 0 and (server_time >= session.incoming_attack_wave_time):
                if gamedata['server']['log_ai_attack_overdue'] and session.incoming_attack_type != 'tutorial':
                    gamesite.exception_log.event(server_time, 'deploying overdue AI attack wave (%s) on player %d' % \
                                                 (str(session.incoming_attack_type), session.player.user_id))
                session.deploy_ai_attack_wave(session.outgoing_messages)
                session.queue_flush_outgoing_messages()

            # check for sessions where an attack has been going on for too long
            elif (session.has_attacked) and (not session.is_async()) and \
                 (session.attack_finish_time > 0) and (server_time >= session.attack_finish_time):
                # force the attack to conclude
                client_inactive_time = server_time - session.last_active_time
                if client_inactive_time < gamedata['server'].get('log_long_attack_threshold',-1):
                    # only make a note if the client was detecting mouse clicks happening beyond the time limit
                    # (either the client's clock is way out of sync, or very lagged, or the player is trying to cheat by changing his clock to get more battle time)
                    gamesite.exception_log.event(server_time, 'user %d - forcing long attack at %d:%s to conclude (client inactive %d sec)' % (session.user.user_id, session.viewing_user.user_id, session.viewing_base.base_id, client_inactive_time))
                session.attack_finish_time = -1

                # note: change_session will unlock the victim's state for us
                d = make_deferred('force_attack_end')
                def force_attack_end(self, session):
                    if session.has_attacked:
                        return self.gameapi.change_session(session, session.outgoing_messages, dest_user_id = session.user.user_id, force = True)
                def ignore_logout_race(fail):
                    fail.trap(Session.AlreadyLoggedOut)
                    return None
                d.addCallbacks(lambda _, self=self, session=session: force_attack_end(self, session),
                               ignore_logout_race)
                session.debug_log_action('force_attack_end')
                session.after_async_request(d)

            if (not session.sprobe_in_progress):
                sprobe_config = gamedata['server'].get('sprobe',None)
                if sprobe_config and sprobe_config.get('enable',True):
                    last_sprobe_time = session.user.last_sprobe_result['time'] if session.user.last_sprobe_result else -1
                    if (server_time - last_sprobe_time) >= sprobe_config['min_interval']:
                        when = sprobe_config.get('when','only_during_attack')
                        if ((when == 'only_during_attack') and session.has_attacked) or \
                           ((when == 'anytime') and ((server_time - session.login_time) >= sprobe_config.get('sec_after_login',15))):
                            session.sprobe_in_progress = True
                            session.send([["SPROBE_RUN"]], flush_now = True)

            session.record_activity_sample()

        # send lock keepalive requests in one big batch
        messages_pending = gamesite.lock_client.player_lock_keepalive_batch(lock_keepalive_ids, lock_keepalive_generations, lock_keepalive_states, True, reason='bgfunc')

        if gamesite.nosql_client:
            if gamesite.msg_client is gamesite.nosql_client:
                # poll for messages separately
                messages_pending = gamesite.nosql_client.msg_poll(lock_keepalive_ids, reason='bgfunc')

            # send region map lock keepalives
            for region_id, base_id_list in region_lock_keepalives.iteritems():
                gamesite.nosql_client.map_feature_lock_keepalive_batch(region_id, base_id_list)

            # send proxy session keepalives
            gamesite.nosql_client.session_keepalive_batch([session2.session_id for session2 in lock_keepalive_sessions], reason='bgfunc')

        # kick off update of BH blog feed
        gamesite.gameapi.update_bh_blog_feed()

        # hand out pending mail to players
        for i in xrange(len(lock_keepalive_sessions)):
            if messages_pending[i]:
                session = lock_keepalive_sessions[i]
                if session.has_attacked: continue
                stat = self.gameapi.do_receive_mail(session, session.outgoing_messages)
                if stat and stat['new_mail']:
                    session.deferred_mailbox_update = True
                    session.deferred_history_update = True
                    session.queue_flush_outgoing_messages()

        # close TCP connections that have been idling too long
        for client in list(self.active_clients):
            assert isinstance(client, self.GameProtocol) or isinstance(client, WS_GAMEAPI_Protocol) # duck typed :P
            last_activity = max(client.connect_time, client.last_request_time)
            if server_time - last_activity > gamedata['server']['http_connection_timeout']:
                if isinstance(client, WS_GAMEAPI_Protocol) and gamedata['server'].get('log_websocket_events',0) >= 2:
                    gamesite.exception_log.event(server_time, 'Closing WebSocket due to http_connection_timeout: %s' % client.peer_ip)
                client.close_connection_aggressively()
                continue # don't ping

            # send WebSocket pings periodically to avoid timeouts along the proxy chain
            if isinstance(client, WS_GAMEAPI_Protocol):
                if client.last_xmit_time > 0 and \
                   server_time - client.last_xmit_time > gamedata['server']['http_connection_timeout']//2:
                    client.last_xmit_time = server_time
                    client.transport.sendPing()

                    # note: Chrome throttles background tabs really aggressively, so send a game-level message
                    # in addition to a WebSocket-only ping, so that the client JavaScript has a chance to
                    # respond with a ping of its own (avoiding http_connection_timeout for lack of incoming messages).
                    client.transport.write('SPws_ping')

    def do_CONTROLAPI(self, on_behalf_of_user_id, caller_args, max_tries = None):
        host = SpinConfig.config['proxyserver'].get('external_listen_host', self.config.game_host)
        if SpinConfig.config['proxyserver'].get('external_ssl_port', -1) > 0:
            proto = 'https'
            port = SpinConfig.config['proxyserver']['external_ssl_port']
        else:
            proto = 'http'
            port = SpinConfig.config['proxyserver']['external_http_port']
        base_url = '%s://%s:%d/CONTROLAPI?' % (proto,host,port)
        args = copy.copy(caller_args)

        # ensure all string args are UTF-8 encoded str()s, which urllib.urlencode() will turn into percent-escaped UTF-8
        for k, v in args.items():
            if type(v) is str:
                try:
                    args[k] = v.decode('utf-8').encode('utf-8')
                except Exception as e:
                    gamesite.exception_log.event(server_time, 'error UTF-8 decoding-encoding text for CONTROLAPI call: %r %r\n%r' % (type(v), v, e))
                    raise
            elif type(v) is unicode:
                try:
                    args[k] = v.encode('utf-8')
                except Exception as e:
                    gamesite.exception_log.event(server_time, 'error UTF-8 encoding text for CONTROLAPI call: %r %r\n%r' % (type(v), v, e))
                    raise

        # log without the secret
        full_url = base_url + urllib.urlencode(args)
        gamesite.controlapi_log.event(server_time, full_url)
        args['secret'] = SpinConfig.config['proxy_api_secret']

        full_url = base_url + urllib.urlencode(args)
        d = make_deferred('CONTROLAPI:'+caller_args['method'])
        self.AsyncHTTP_CONTROLAPI.queue_request(server_time, full_url,
                                                lambda response, _d=d: _d.callback(response),
                                                error_callback = lambda err, _d=d, _method=caller_args['method'], _user_id=on_behalf_of_user_id: \
                                                _d.errback(failure.Failure(Exception('AsyncHTTP_CONTROLAPI %r failure on behalf of player %d: %r' % \
                                                                                     (_method, _user_id, err)))),
                                                max_tries = max_tries)

        # error handling note: it's not necessary to attach an errback here.
        # If caller attaches an errback, that will be used, otherwise
        # an error will fall back to the default "Unhandled error in deferred" path
        # d.addErrback(report_and_reraise_deferred_failure, session)

        # assumes modern CustomerSupport return conventions
        def check_result(result, user_id):
            ret = SpinJSON.loads(result)
            if 'error' in ret:
                raise Exception('AsyncHTTP_CONTROLAPI %r error on behalf of player %d: %r' % \
                                (caller_args['method'], user_id, ret))
            return ret['result']
        d.addCallback(check_result, on_behalf_of_user_id)

        return d


# glue code that links GAMEAPI to WebSocket

# nasty hack - this is a fake substitute for the HTTP request objects that GAMEAPI passes around
class WSFakeRequest(object):
    def __init__(self, proto):
        self.proto = proto
        self.want_close = False
    def setHeader(self, key, val):
        # detect removal of keepalive header to signal that we should close after next write
        if key == 'Connection' and val == 'close':
            self.want_close = True
    def write(self, buf):
        if self.proto.connected:
            self.proto.transport.write(buf)
    def finish(self):
        if self.want_close:
            self.proto.close_connection_aggressively()
    def close_connection_aggressively(self): return self.proto.close_connection_aggressively()

class WS_GAMEAPI_Protocol(protocol.Protocol):
    def __init__(self, gameapi, peer, headers):
        self.gameapi = gameapi
        self.peer_ip = str(peer.host)
        if 'User-Agent' in headers:
            self.user_agent = headers['User-Agent'][0]
        else:
            self.user_agent = 'unknown(WS_GAMEAPI_Protocol)'
        self.connected = False
        self.sp_length = -1 # for SpinPunch fragmentation
        self.sp_buffer = [] # for SpinPunch fragmentation
        self.close_connection_watchdog = None
        self.connect_time = -1
        self.last_request_repr = '' # for debugging only
        self.last_request_time = -1

        # really this should track the time we last sent bytes to the client,
        # but it's hard to reach down into Twisted to grab that info,
        # so let's just use it as the last *ping* xmit time
        self.last_xmit_time = -1

    def connectionMade(self):
        self.connected = True
        self.connect_time = int(time.time())
        self.last_xmit_time = self.connect_time
        gamesite.gotClient(self) # XXX not sure how to get a reference to the "site" here

    def connectionLost(self, reason):
        self.connected = False
        self.connect_time = -1
        self.last_xmit_time = -1
        if self.close_connection_watchdog:
            self.close_connection_watchdog.cancel()
            self.close_connection_watchdog = None
        gamesite.lostClient(self) # XXX not sure how to get a reference to the "site" here
        self.last_request_repr = 'connectionLost'

    def close_connection_aggressively(self, force = False):
        if self.connected:
            if force:
                self.close_connection_watchdog = None
                self.transport.abortConnection()
            else:
                self.transport.loseConnection()

                if not self.close_connection_watchdog:
                    # set watchdog timer to abort badly-behaved TCP connections
                    self.close_connection_watchdog = reactor.callLater(10.0, self.close_connection_aggressively, True)

    def dataReceived(self, data):
        update_server_time()

        # SpinPunch fragmentation protocol: this is another layer of fragmentation
        # ON TOP OF WebSocket messages. Necessary because some browsers (IE)
        # in some configurations seem to have trouble transmitting >32KB messages
        # intact.
        # The protocol is just this: one websocket message of the characters 'SP'
        # plus the decimal length (0-padded to 20 digits), followed by individual
        # messages to concatenate to re-assemble the original message.

        if self.sp_length < 0 and len(data) >= 22 and data[0] == 'S' and data[1] == 'P':
            # start of a SpinPunch fragmented message
            self.sp_length = int(data[2:])
            return
        elif self.sp_length >= 0:
            # inside of a SpinPunch fragmented message
            self.sp_buffer.append(data)
            if sum(len(x) for x in self.sp_buffer) >= self.sp_length:
                # full message received
                message = "".join(self.sp_buffer)
                self.sp_buffer = []
                self.sp_length = -1
            else:
                # still waiting for more fragments
                return
        else:
            # literal message
            message = data

        self.messageReceived(message)

    @catch_all('WS_GAMEAPI')
    def messageReceived(self, data):

        try:
            args_dict = SpinJSON.loads(data)
            if not isinstance(args_dict, dict):
                raise ValueError('expected dict but got %r' % type(args_dict))

        except ValueError:
            if len(data) < 100:
                ui_message = data
            else:
                # abbreviate
                ui_message = data[0:16] + '...' + data[-16:]
            gamesite.exception_log.event(server_time, 'WS_GAMEAPI received bad JSON message from %r (len %d): %r' % \
                                         (self.peer_ip, len(data), ui_message))
            # write the corrupted data out for later analysis
            with open("/tmp/websocket-debug-%.6f.txt" % time.time(), "w") as fd:
                fd.write(data)
            self.transport.write(SpinJSON.dumps({'serial':-1, 'clock': server_time, 'msg': [["ERROR", "SERVER_PROTOCOL"]]}))
            self.transport.loseConnection()
            return

        self.last_request_repr = repr(args_dict)[0:100] # for debugging only - text representation
        self.last_request_time = server_time

        reply, is_error = gamesite.gameapi.render_request(WSFakeRequest(self), args_dict, self.peer_ip, self.user_agent)

        if reply == twisted.web.server.NOT_DONE_YET:
            pass
        else:
            self.transport.write(reply)

        if is_error:
            # disconnect when there's a protocol error or server exception
            self.transport.loseConnection()

    def __repr__(self):
        if self.last_request_time > 0:
            ago = server_time - self.last_request_time
        else:
            ago = -1
        return 'WS_GAMEAPI_Protocol (last request %ds ago: %s...)' % (ago, self.last_request_repr)

class WS_GAMEAPI_Factory(protocol.Factory):
    def __init__(self, gameapi):
        self.gameapi = gameapi
    def buildProtocol(self, addr, headers):
        return WS_GAMEAPI_Protocol(self.gameapi, addr, headers)
class WS_GAMEAPI(websockets.WebSocketsResource):
    def __init__(self, gameapi):
        websockets.WebSocketsResource.__init__(self, WS_GAMEAPI_Factory(gameapi))
    def render(self, request):
        update_server_time()
        SpinHTTP.set_access_control_headers(request)

        # WebSocketsResource swaps WS_GAMEAPI_Protocol in place of GameProtocol, so we have
        # to let the gamesite know it's gone to get the accounting right

        # Secure connections wrap in TLSMemoryBIOProtocol too.
        old_protocol = request.channel.transport.wrappedProtocol if isinstance(request.channel.transport, ProtocolWrapper) else request.channel.transport.protocol
        assert isinstance(old_protocol, GameSite.GameProtocol)

        ret = websockets.WebSocketsResource.render(self, request)
        if ret is server.NOT_DONE_YET:
            # success - drop the GameProtocol client since it's been swapped to WS_GAMEAPI_Protocol
            old_protocol.site.lostClient(old_protocol)
            del old_protocol.site.active_requests[id(request)]
        return ret

class AdminResource(resource.Resource):
    isLeaf = True
    def render(self, request):
        # do not return a revealing error message on exceptions
        ret = catch_all('ADMIN')(resource.Resource.render)(self, request)
        if ret is None:
            request.setResponseCode(http.BAD_REQUEST)
            ret = 'spinpunch error'
        return ret

    def revenue_image(self):
        rev = admin_stats.revenue
        src = 'https://spinpunch-public.spinpunch.com/'
        if rev >= 1000.0:
            src += 'revenue5.jpg'
        elif rev >= 500.0:
            src += 'revenue6.jpg' # swapped
        elif rev >= 150.0:
            src += 'revenue4.jpg'
        elif rev >= 20.00:
            src += 'revenue3.jpg'
        elif rev >= 3.00:
            src += 'revenue2.jpg'
        elif rev > 0:
            src += 'revenue1.jpg'
        else:
            src += 'revenue0.jpg'
        return '<div style="position:absolute; top:50px;right:30px;"><img src="%s" border="0"></div>' % src

    @admin_stats.measure_latency('ADMIN')
    def render_GET(self, request):
        update_server_time()

        # protect with auth
        if (not SpinGoogleAuth.twisted_request_is_local(request, proxy_secret = SpinConfig.config['proxy_api_secret'])):
            if spin_secure_mode and (not SpinHTTP.twisted_request_is_ssl(request, proxy_secret = SpinConfig.config['proxy_api_secret'])): return 'must use HTTPS'
            auth_info = SpinGoogleAuth.twisted_do_auth(request, 'ADMIN', server_time, proxy_secret = SpinConfig.config['proxy_api_secret'])
            if not auth_info['ok']:
                if 'redirect' in auth_info:
                    return str(auth_info['redirect'])
                else:
                    return str(auth_info['error'])

        ret = u'<html><head><title>Admin</title>'
        ret += '<style type="text/css">body {font-family:serif; font-size: 100%;} thead {background: #aaa;} .sessions tbody { font-family: monospace; } td { font-size: 1.0em; padding: 1px;}</style>'
        ret += '</head><body>'

        #ret += self.revenue_image()

        ret += 'server name: %s<br>' % spin_server_name
        ret += 'server time: %d<br>' % server_time
        ret += 'version: ' + SERVER_VERSION
        ret += '<p>'

        def print_table(d):
            ret = '<table border="1" cellspacing="1">'
            for key, val in sorted(d.items()):
                if key.startswith('disk_space_total') or key.startswith('disk_space_used'):
                    continue
                if type(val) == float:
                    if key.startswith('disk_space_free_gb'):
                        # make shorter version of the path
                        path = re.search('.*\((.*)\)', key).groups()[0]
                        if path.endswith('/'):
                            path = path[:-1]
                        path = os.path.basename(path)
                        path += '/'
                        # check near-fullness
                        freeness = val / d[key.replace('_free_gb', '_total_gb')]

                        key = 'disk space free (%s)' % path
                        val = '%.2f GB %.0f%%' % (val, 100.0*freeness)
                        if freeness < 0.25:
                            val = '<font color="#ff0000" size="+2">%s</font>' % val
                    elif key == 'revenue':
                        val = '<font size="+1"><b>$%.2f</b></font>' % val
                    elif (key == 'loadavg_15min' and float(val) > cpu_count()) or \
                         (key == 'load_unhalted' and float(val) > 0.70):
                        val = '<font color="#ff0000" size="+2"><b>%.2f</b></font>' % val
                    elif key == 'machine_swap_used_mb' and float(val) > 1000.0:
                        val = '<font color="#ff0000"><b>%.2f</b></font>' % val
                    elif key == 'machine_mem_free_mb' and float(val) < 1000.0:
                        val = '<font color="#ff0000"><b>%.2f</b></font>' % val
                    else:
                        val = '%.2f' % val
                ret += '<tr><td>%s</td><td>%s</td></tr>' % (key, str(val))
            ret += '</table>'
            return ret

        ret += print_table(admin_stats.get_stats())
        mystats = MachineStats.get_stats(filesystems=machine_stats_filesystems)
        mystats['load_unhalted'] = admin_stats.get_load()
        ret += print_table(mystats)

        ret += '<hr>'
        ret += '<b>'+str(len(session_table)) +' active session(s):</b><p>'
        ret += '<table border="1" cellspacing="1" class="sessions">'

        def make_red(text):
            return '<font color="#ff0000">'+text+'</font>'
        def make_blue(text):
            return '<font color="#0000ff">'+text+'</font>'

        def make_sortlink(text, request, newkey):
            props = dict([(name, val[0]) for name, val in request.args.iteritems()])
            props['sort'] = newkey
            link = urllib.urlencode(props)
            return '<a href="?%s">%s</a>' % (link, text)

        ret += '<thead><tr><th>User</th><th>Name</th><th>'+make_sortlink('Level', request, 'level')+'</th><th>Country</th><th>Age</th><th>'+make_sortlink('IP', request, 'ip')+'</th><th>RetransBuf</th>'+'<th>Campaign</th><th>'+make_sortlink('Acct Age', request, 'acct_age')+'</th><th>'+make_sortlink('Session Length', request, 'session_length')+'</th><th>Async</th><th>Idle For</th><th>Last Actions (sec ago)</th><th>Tut</th><th>&#35;PvE</th><th>&#35;PvP</th><th>Protect</th><th>Where</th><th>Logins</th><th>Alloy Bal.</th><th>'+make_sortlink('Lifetime Receipts', request, 'default')+'</th></tr></thead><tbody>'

        # sort by money spent, then player level
        sort_by = request.args['sort'][0] if ('sort' in request.args) else 'default'

        def sort_default(k_s):
            s = k_s[1]
            return -(s.player.history.get('money_spent',0) + 0.001*s.player.resources.player_level)
        def sort_ip(k_s): s = k_s[1]; return str(s.user.last_login_ip)
        def sort_session_length(k_s): s = k_s[1]; return s.last_active_time - s.login_time
        def sort_acct_age(k_s): s = k_s[1]; return s.user.account_creation_time
        def sort_level(k_s): s = k_s[1]; return s.player.resources.player_level

        sort_funcs = {'default': sort_default,
                      'ip': sort_ip,
                      'acct_age': sort_acct_age,
                      'level': sort_level,
                      'session_length': sort_session_length}

        for id, session in sorted(session_table.items(), key = sort_funcs[sort_by]):
            user = str(session.user.user_id)
            user_link = '<a href="http://apps.facebook.com/'+SpinConfig.config['facebook_app_namespace']+'/?visit_base='+user+'">'+user+'</a>'
            name = session.user.get_ui_name(session.player)
            if session.user.facebook_id:
                name = '<a href="https://www.facebook.com/'+session.user.facebook_id+'/">'+name+'</a>'

            country = session.user.country + (' (%d)' % SpinConfig.country_tier_map.get(session.user.country, 4))

            years_old = -1
            if session.user.birthday:
                years_old = int((server_time - session.user.birthday)/(365*24*60*60))
            years_old = str(years_old) if years_old > 0 else '?'

            ip_addr = str(session.user.last_login_ip)
            retrans_info = '%d' % len(session.retrans_buffer)

            campaign = session.user.acquisition_campaign
            if campaign is None:
                campaign = 'unknown'
            acct_age = 'unk' if (session.player.creation_time < 0) else '%0.1f' % ((server_time - session.player.creation_time)/86400.0)
            active = SpinConfig.pretty_print_time(session.last_active_time - session.login_time)
            if len(session.async_ds) + len(session.after_async) > 0:
                async = '%d,%d' % (len(session.async_ds), len(session.after_async))
            else:
                async = ''
            last_active = SpinConfig.pretty_print_time(server_time - session.last_active_time)

            action = []
            for act in reversed(session.last_action):
                s = '%s (%ds)' % (act['tag'], server_time-act['time'])
                if not act['keepalive']:
                    s = '<font color="#a0a0a0">'+s+'</font>'
                action.append(s)
            action = '<font size="-2">'+string.join(action, '<br>')+'</font>'

            tutorial = session.player.tutorial_state
            tutorial = tutorial[0:1]
            if tutorial != "C":
                tutorial = make_red(tutorial)
            if session.player.has_damage_protection():
                protect = make_blue(SpinConfig.pretty_print_time(session.player.resources.protection_end_time - server_time))
            else:
                protect = ''

            battle = ''
            if session.player.home_region:
                battle += session.player.home_region+' '

            # "battle" shows viewing base
            if session.home_base:
                battle += 'home'
            else:
                battle += '%d' % session.viewing_user.user_id
                if is_ai_user_id_range(session.viewing_user.user_id):
                    sid = str(session.viewing_user.user_id)
                    base = gamedata['ai_bases_server']['bases'].get(sid,None)
                    if base:
                        battle += ' (%s L%d)' % (base['ui_name'], base['resources']['player_level'])
                if session.viewing_base is not session.viewing_player.my_home:
                    battle += ':%s' % session.viewing_base.base_id

            if session.has_attacked:
                if session.using_squad_deployment():
                    battle = 'SQD '+ battle
                if session.is_ladder_battle():
                    battle = 'LAD '+battle
                if session.home_base:
                    battle += ' ' + str(session.incoming_attack_type)
                battle = make_red('ATK '+battle)
            else:
                pass # battle = 'NO ' + battle

            pve = session.player.history.get('attacks_launched_vs_ai',0)
            pvp = session.player.history.get('attacks_launched_vs_human',0)
            spend = session.player.history.get('money_spent', 0.0)
            if spend > 0:
                spend = '<b>$%.2f</b>' % spend
            else:
                spend = '$%.2f' % spend
            ret += '<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%d</td><td>%d</td><td>%s</td><td>%s</td><td>%d</td><td>%d</td><td>%s</td></tr>' % (user_link,name,str(session.player.resources.player_level),country,years_old,ip_addr,retrans_info,campaign,acct_age,active,async,last_active,action,tutorial,pve,pvp,protect,battle,session.player.history.get('logged_in_times',0),session.player.resources.gamebucks,spend)

        ret += '</tbody></table><p>'

        ret += '<hr><b>Campaign Data</b><p>'
        ret += admin_stats.get_campaigns()

        ret += '<hr><b>Recent Payments</b><p>'
        ret += admin_stats.get_payments()

        ret += '<hr><b>Recent Alloy Expenditures by Paying Users</b><p>'
        ret += admin_stats.get_gamebucks()

        ret += '<hr><b>Iron/Water Economy</b><p>'
        ret += admin_stats.get_econ()

        ret += '<hr><b>Server Latency</b><p>'
        ret += admin_stats.get_latency()

        if SpinConfig.config['enable_facebook']:
            ret += '<hr><b>AsyncHTTP_Facebook</b><p>'
            ret += gamesite.AsyncHTTP_Facebook.get_stats_html(server_time)
        if SpinConfig.config.get('enable_kongregate',0):
            ret += '<hr><b>AsyncHTTP_Kongregate</b><p>'
            ret += gamesite.AsyncHTTP_Kongregate.get_stats_html(server_time)
        if SpinConfig.config.get('enable_armorgames',0):
            ret += '<hr><b>AsyncHTTP_ArmorGames</b><p>'
            ret += gamesite.AsyncHTTP_ArmorGames.get_stats_html(server_time)
        if SpinConfig.config.get('enable_battlehouse',0):
            ret += '<hr><b>AsyncHTTP_Battlehouse</b><p>'
            ret += gamesite.AsyncHTTP_Battlehouse.get_stats_html(server_time)
            ret += '<hr><b>AsyncHTTP_Microsoft</b><p>'
            ret += gamesite.AsyncHTTP_Microsoft.get_stats_html(server_time)
        if SpinConfig.config.get('enable_mattermost',0):
            ret += '<hr><b>AsyncHTTP_Mattermost</b><p>'
            ret += gamesite.AsyncHTTP_Mattermost.get_stats_html(server_time)

        if SpinConfig.config['enable_kissmetrics'] or SpinConfig.config.get('enable_adotomi', False) or SpinConfig.config.get('enable_dauup', False):
            ret += '<hr><b>AsyncHTTP_metrics</b><p>'
            ret += gamesite.AsyncHTTP_metrics.get_stats_html(server_time)

        io_stats = io_system.get_stats()
        if io_stats:
            ret += '<hr><b>I/O System</b><p>'
            ret += io_stats

        ret += '<hr><b>AsyncHTTP_CONTROLAPI</b><p>'
        ret += gamesite.AsyncHTTP_CONTROLAPI.get_stats_html(server_time)
        ret += '<hr><b>CONTROLAPI Calls</b><p>'
        ret += admin_stats.get_controlapi_calls()
        ret += '<hr><b>OGPAPI Calls</b><p>'
        ret += admin_stats.get_ogpapi_calls()

        ret += '</body></html>'
        ret = ret.encode('utf-8')
        request.setHeader('content-type', 'text/html; charset=UTF-8')
        request.setHeader('content-length', str(len(ret)))
        request.setHeader('Pragma','no-cache, no-store')
        request.setHeader('Cache-Control','no-cache, no-store')
        return ret

ADMINAPI_instance = AdminResource()

# this piece of code allows the Twisted web server to run PHP scripts
#class MyPHPScript(twcgi.FilteredScript):
#    filter = '/usr/bin/php-cgi'
#    def runProcess(self, env, request, qargs):
#        env['REDIRECT_STATUS'] = '200'
#        ret = twcgi.FilteredScript.runProcess(self, env, request, qargs)
#        return ret

# this is just an HTTP "virtual root directory" that will have only the children we give it with putChild()
class GameRoot(TwistedNoResource):
    def getChildWithDefault(self, pathel, request):
        return resource.Resource.getChildWithDefault(self, pathel, request)

def do_main(pidfile, do_ai_setup, do_daemonize, cmdline_config):
    # create necessary directories
    for mypath in [spin_log_dir,
                   SpinConfig.config['userdb_dir'],
                   SpinConfig.config['playerdb_dir'],
                   SpinConfig.config.get('basedb_dir', 'basedb'),
                   SpinConfig.config.get('aistate_dir', 'aistate')]:
        if not os.path.exists(mypath):
            os.mkdir(mypath)

    if spin_secure_mode and (not SpinConfig.config.get('use_compiled_client', 0)):
        raise Exception('use_compiled_client must be enabled in config.json when in secure_mode')

    # get server instance configuration (port numbers etc)
    global_config = SpinConfig.config.get('gameserver_global',{})
    if cmdline_config is not None:
        instance_config = cmdline_config
    else:
        instance_config = copy.deepcopy(SpinConfig.config['gameservers'][spin_server_name])
    for k,v in global_config.iteritems():
        if k not in instance_config: instance_config[k] = v
    config = GameSite.Configuration(instance_config)

    # For now, WS_GAMEAPI exists as a child under GameSite, on the
    # same port.  It could be moved to different port if necessary,
    # that would means it needs to have listening set up separately.
    if config.game_ws_port > 0: assert config.game_ws_port == config.game_http_port
    if config.game_wss_port > 0:
        assert config.game_wss_port == config.game_ssl_port
        try:
            __import__('twisted.protocols.tls')
        except ImportError:
            raise Exception('game_wss_port is enabled but this Twisted version is too old to support WebSockets with TLS.')

    # NEW - game server is not responsible for static content; the proxy handles it now
    root = GameRoot() # static.File('/var/empty')

    gameapi = GAMEAPI()
    controlapi = CONTROLAPI(gameapi)
    statsapi = STATSAPI(gameapi)
    trialpayapi = TRIALPAYAPI(gameapi)
    xsapi = XSAPI(gamedata)

    root.putChild("GAMEAPI",gameapi)
    root.putChild("CREDITAPI",CREDITAPI(gameapi))
    root.putChild("TRIALPAYAPI",trialpayapi)
    root.putChild("XSAPI",xsapi)
    root.putChild("KGAPI",KGAPI(gameapi))
    root.putChild("K2API",K2API(gameapi))
    root.putChild("CONTROLAPI",controlapi)
    root.putChild("STATSAPI",statsapi)
    root.putChild("OGPAPI",OGPAPI_instance)
    root.putChild("ADMIN",ADMINAPI_instance)
    if config.game_ws_port > 0 or config.game_wss_port > 0:
        root.putChild("WS_GAMEAPI",WS_GAMEAPI(gameapi))

    # init IO system
    io_system_init(instance_config.get('io', {}).copy())

    global gamesite
    gamesite = GameSite(config, root, gameapi, controlapi, trialpayapi, xsapi)

    # optional memory profiling using Dowser library
    if SpinConfig.config.get('enable_dowser', 0):
        import cherrypy
        import dowser
        cherrypy.config.update({'server.socket_port':SpinConfig.config.get('dowser_port', 8080)})
        cherrypy.tree.mount(dowser.Root())
        cherrypy.engine.autoreload.unsubscribe()
        cherrypy.engine.start()
        reactor.addSystemEventTrigger('after', 'shutdown', cherrypy.engine.exit)

    gamesite.start_listening()

    print 'Game server up and running on %s:%d (HTTP)%s%s%s' % (config.game_snam or config.game_host, config.game_http_port,
                                                                (' :%d (SSL)' % config.game_ssl_port) if config.game_ssl_port > 0 else '',
                                                                (' :%d (WS)' % config.game_ws_port) if config.game_ws_port > 0 else '',
                                                                (' :%d (WSS)' % config.game_wss_port) if config.game_wss_port > 0 else '')

    # startup completes here

    if not spin_secure_mode:
        print 'SERVER IS NOT RUNNING IN SECURE MODE - NOT FOR PRODUCTION!'

    if not has_lz4:
        print 'warning: lz4 compression library not detected, cannot use it for regional map :('

    if do_daemonize:
        Daemonize.daemonize()

        # turn on Twisted logging
        log.startLoggingWithObserver(gamesite.log_raw)
        log.addObserver(gamesite.log_exceptions)

        # update PID file with new PID
        open(pidfile, 'w').write('%d\n' % os.getpid())

    gamesite.exception_log.event(server_time, 'server "'+spin_server_name+'" starting up')

    io_system.start()

    def do_account_setup():
        # set up test and AI accounts
        setup_test_user(6, gamesite.social_id_table.social_id_to_spinpunch('fb6', True), 'Test User #6')
        setup_ai_bases()

    if do_ai_setup:
        # have to do this after the loop starts, because we need to wait for io_system to be fully alive
        reactor.callLater(0, do_account_setup)

    TwistedLatency.setup(reactor, admin_stats.record_latency)

    reactor.run()

    gamesite.exception_log.event(server_time, 'server "'+spin_server_name+'" shutdown complete')

def main():
    global spin_server_name

    opts, args = getopt.gnu_getopt(sys.argv[1:], 'n', ['skip-ai-setup','config='])

    do_ai_setup = True
    do_daemonize = True
    cmdline_config = None

    for key, val in opts:
        if key == '--skip-ai-setup': do_ai_setup = False
        elif key == '-n': do_daemonize = False
        elif key == '--config': cmdline_config = SpinJSON.loads(val)

    if len(args) < 1:
        print 'Please specify server name, as found in config.json'
        sys.exit(1)

    spin_server_name = args[0]

    if (cmdline_config is None) and (spin_server_name not in SpinConfig.config['gameservers']):
        print 'No configuration found for server "%s" in config.json:gameservers.' % spin_server_name
        sys.exit(1)


    pidfile = 'server_%s.pid' % spin_server_name

    if os.path.exists(pidfile):
        print 'Server is already running (%s), use ./stopserver.sh to stop it.' % pidfile
        sys.exit(1)

    # create PID file
    open(pidfile, 'w').write('%d\n' % os.getpid())
    try:
        do_main(pidfile, do_ai_setup, do_daemonize, cmdline_config)
    finally:
        # remove PID file
        os.unlink(pidfile)

def update_bh_user_spend(bh_id, money_spent, user_id, bh_token):
    d = make_deferred('update_bh_user_spend')
    gamesite.AsyncHTTP_Battlehouse.queue_request(server_time,
                                                 SpinConfig.config['battlehouse_api_path']+('/user/%s/update_money_spent/' % bh_id) + '?service=' + SpinConfig.game(),
                                                 lambda result, _d=d, _user_id=user_id: update_bh_user_spend_complete(_d, _user_id, result),
                                                 headers = {'Authorization': 'Bearer ' + bh_token,
                                                            'X-BHLogin-API-Secret': SpinConfig.config['battlehouse_api_secret'].encode('utf-8')})

def update_bh_user_spend_complete(self, d, user_id, result):
    data = SpinJSON.loads(result)
    if data.get('result') != 'ok':
        gamesite.exception_log.event(server_time, 'Sent updated spend for player %d, got back invalid result %s.' % (user_id, str(result)))
    d.callback(True)

if __name__ == '__main__':
    main()
